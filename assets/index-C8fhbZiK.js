var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  };
  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
  var it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
System.register([], function(exports, module) {
  "use strict";
  return {
    execute: function() {
      var _a2, _b;
      exports({
        $: buffersEqual,
        F: assertTypeIs,
        G: assertTypeIsNot,
        H: asyncResettable,
        J: bigIntAbs,
        K: bigIntBitLength,
        L: Long,
        N: bigIntGcd,
        P: bigIntMin,
        Q: bigIntModInv,
        R: bigIntModPow,
        V: bigIntToBuffer,
        W: bufferToBigInt,
        X: bufferToReversed,
        Y: bufferToStream,
        a: assertNever$1,
        a$: svgPathToFile,
        a0: cloneBuffer,
        a1: compareLongs,
        a2: composeMiddlewares,
        a3: computeNewPasswordHash,
        a4: computePasswordHash,
        a5: computeSrpParams,
        a6: concatBuffers,
        a7: createAesIgeForMessage,
        a8: createAesIgeForMessageOld,
        a9: createChunkedReader,
        aA: longFromBuffer,
        aB: longFromFastString,
        aC: longToFastString,
        aD: makeArrayPaginated,
        aE: makeArrayWithTotal,
        aF: millerRabin,
        aG: mtpAssertTypeIs,
        aH: normalizeDate,
        aI: normalizeInlineId,
        aJ: normalizeMessageId,
        aK: normalizePhoneNumber,
        aL: parseBasicDcOption,
        aM: parseInlineMessageId,
        aN: parseMarkedPeerId,
        aO: parsePublicKey,
        aP: randomBigInt,
        aQ: randomBigIntBits,
        aR: randomBigIntInRange,
        aS: randomLong,
        aT: readStringSession,
        aU: removeFromLongArray,
        aV: resolveMaybeDynamic,
        aW: serializeBasicDcOption,
        aY: sleepWithAbort,
        aZ: streamToBuffer,
        a_: strippedPhotoToJpg,
        aa: createControllablePromise,
        ab: dataViewFromBuffer,
        ac: decodeWaveform,
        ah: determinePartSize,
        ai: encodeInlineMessageId,
        aj: encodeWaveform,
        ak: extractFileName,
        al: extractUsernames,
        am: findKeyByFingerprints,
        an: generateKeyAndIvFromNonce,
        ao: getAllPeersFrom,
        ap: getBarePeerId,
        aq: getMarkedPeerId,
        ar: getRandomInt,
        as: hasValueAtKey,
        at: inflateSvgPath,
        au: inputPeerToPeer,
        av: isInputPeerChannel,
        aw: isInputPeerChat,
        ax: isInputPeerUser,
        ay: isProbablyPlainText,
        az: jsonToTlJson,
        b0: throttle,
        b2: tlJsonToJson,
        b3: toInputChannel,
        b4: toInputPeer,
        b5: toInputUser,
        b6: toggleChannelIdMark,
        b7: twoMultiplicity,
        b8: writeStringSession,
        b9: xorBuffer,
        ba: xorBufferInPlace,
        d: deeplinkBuilder,
        dA: isUploadedFile,
        dC: normalizeInputMessageId,
        dD: normalizeInputStickerSet,
        dE: parsePeer,
        dF: toReactionEmoji,
        dO: getNative,
        dQ: isObjectLike,
        dR: baseGetTag,
        dS: isLength,
        dU: isArrayLike,
        dV: ListCache,
        dX: MapCache,
        dY: toSource,
        dZ: SetCache,
        d_: cacheHas,
        dr: _actionFromTl,
        ds: _callDiscardReasonFromTl,
        dt: _callDiscardReasonToTl,
        du: _messageActionFromTl,
        dv: _messageMediaFromTl,
        dw: _storyInteractiveElementFromTl,
        dx: businessWorkHoursDaysToRaw,
        dz: inputTextToTl,
        e: isTlRpcError,
        e0: eq,
        f: basic,
        g: getPlatform,
        i: isPresent,
        n: normalizeInputReaction,
        y: addPublicKey,
        z: assertTrue
      });
      const scriptRel = function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      }();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (false) {
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
          const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
          promise = Promise.all(deps.map((dep) => {
            dep = assetsURL(dep);
            if (dep in seen)
              return;
            seen[dep] = true;
            const isCss = dep.endsWith(".css");
            const cssSelector = isCss ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
              return;
            }
            const link = document.createElement("link");
            link.rel = isCss ? "stylesheet" : scriptRel;
            if (!isCss) {
              link.as = "script";
              link.crossOrigin = "";
            }
            link.href = dep;
            if (cspNonce) {
              link.setAttribute("nonce", cspNonce);
            }
            document.head.appendChild(link);
            if (isCss) {
              return new Promise((res, rej) => {
                link.addEventListener("load", res);
                link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
              });
            }
          }));
        }
        return promise.then(() => baseModule()).catch((err) => {
          const e2 = new Event("vite:preloadError", { cancelable: true });
          e2.payload = err;
          window.dispatchEvent(e2);
          if (!e2.defaultPrevented) {
            throw err;
          }
        });
      };
      let taskIdCounter = 1, isCallbackScheduled = false, isPerformingWork = false, taskQueue$1 = [], currentTask = null, shouldYieldToHost = null, yieldInterval = 5, deadline = 0, maxYieldInterval = 300, scheduleCallback = null, scheduledCallback = null;
      const maxSigned31BitInt = 1073741823;
      function setupScheduler() {
        const channel = new MessageChannel(), port2 = channel.port2;
        scheduleCallback = () => port2.postMessage(null);
        channel.port1.onmessage = () => {
          if (scheduledCallback !== null) {
            const currentTime = performance.now();
            deadline = currentTime + yieldInterval;
            const hasTimeRemaining = true;
            try {
              const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);
              if (!hasMoreWork) {
                scheduledCallback = null;
              } else
                port2.postMessage(null);
            } catch (error) {
              port2.postMessage(null);
              throw error;
            }
          }
        };
        if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {
          const scheduling = navigator.scheduling;
          shouldYieldToHost = () => {
            const currentTime = performance.now();
            if (currentTime >= deadline) {
              if (scheduling.isInputPending()) {
                return true;
              }
              return currentTime >= maxYieldInterval;
            } else {
              return false;
            }
          };
        } else {
          shouldYieldToHost = () => performance.now() >= deadline;
        }
      }
      function enqueue(taskQueue2, task) {
        function findIndex() {
          let m2 = 0;
          let n2 = taskQueue2.length - 1;
          while (m2 <= n2) {
            const k = n2 + m2 >> 1;
            const cmp = task.expirationTime - taskQueue2[k].expirationTime;
            if (cmp > 0)
              m2 = k + 1;
            else if (cmp < 0)
              n2 = k - 1;
            else
              return k;
          }
          return m2;
        }
        taskQueue2.splice(findIndex(), 0, task);
      }
      function requestCallback(fn, options2) {
        if (!scheduleCallback)
          setupScheduler();
        let startTime = performance.now(), timeout = maxSigned31BitInt;
        if (options2 && options2.timeout)
          timeout = options2.timeout;
        const newTask = {
          id: taskIdCounter++,
          fn,
          startTime,
          expirationTime: startTime + timeout
        };
        enqueue(taskQueue$1, newTask);
        if (!isCallbackScheduled && !isPerformingWork) {
          isCallbackScheduled = true;
          scheduledCallback = flushWork;
          scheduleCallback();
        }
        return newTask;
      }
      function cancelCallback(task) {
        task.fn = null;
      }
      function flushWork(hasTimeRemaining, initialTime) {
        isCallbackScheduled = false;
        isPerformingWork = true;
        try {
          return workLoop(hasTimeRemaining, initialTime);
        } finally {
          currentTask = null;
          isPerformingWork = false;
        }
      }
      function workLoop(hasTimeRemaining, initialTime) {
        let currentTime = initialTime;
        currentTask = taskQueue$1[0] || null;
        while (currentTask !== null) {
          if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
            break;
          }
          const callback2 = currentTask.fn;
          if (callback2 !== null) {
            currentTask.fn = null;
            const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
            callback2(didUserCallbackTimeout);
            currentTime = performance.now();
            if (currentTask === taskQueue$1[0]) {
              taskQueue$1.shift();
            }
          } else
            taskQueue$1.shift();
          currentTask = taskQueue$1[0] || null;
        }
        return currentTask !== null;
      }
      const sharedConfig = {
        context: void 0,
        registry: void 0,
        effects: void 0,
        done: false,
        getContextId() {
          return getContextId(this.context.count);
        },
        getNextContextId() {
          return getContextId(this.context.count++);
        }
      };
      function getContextId(count2) {
        const num2 = String(count2), len = num2.length - 1;
        return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num2;
      }
      function setHydrateContext(context) {
        sharedConfig.context = context;
      }
      function nextHydrateContext() {
        return __spreadProps(__spreadValues({}, sharedConfig.context), {
          id: sharedConfig.getNextContextId(),
          count: 0
        });
      }
      const IS_DEV = false;
      const equalFn = (a, b) => a === b;
      const $PROXY = Symbol("solid-proxy");
      const SUPPORTS_PROXY = typeof Proxy === "function";
      const $TRACK = Symbol("solid-track");
      const $DEVCOMP = Symbol("solid-dev-component");
      const signalOptions = {
        equals: equalFn
      };
      let ERROR = null;
      let runEffects = runQueue;
      const STALE = 1;
      const PENDING = 2;
      const UNOWNED = {
        owned: null,
        cleanups: null,
        context: null,
        owner: null
      };
      const NO_INIT = {};
      var Owner = null;
      let Transition = null;
      let Scheduler = null;
      let ExternalSourceConfig = null;
      let Listener = null;
      let Updates = null;
      let Effects = null;
      let ExecCount = 0;
      function createRoot(fn, detachedOwner) {
        const listener = Listener, owner = Owner, unowned = fn.length === 0, current2 = detachedOwner === void 0 ? owner : detachedOwner, root2 = unowned ? UNOWNED : {
          owned: null,
          cleanups: null,
          context: current2 ? current2.context : null,
          owner: current2
        }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root2)));
        Owner = root2;
        Listener = null;
        try {
          return runUpdates(updateFn, true);
        } finally {
          Listener = listener;
          Owner = owner;
        }
      }
      function createSignal(value, options2) {
        options2 = options2 ? Object.assign({}, signalOptions, options2) : signalOptions;
        const s = {
          value,
          observers: null,
          observerSlots: null,
          comparator: options2.equals || void 0
        };
        const setter = (value2) => {
          if (typeof value2 === "function") {
            if (Transition && Transition.running && Transition.sources.has(s))
              value2 = value2(s.tValue);
            else
              value2 = value2(s.value);
          }
          return writeSignal(s, value2);
        };
        return [readSignal.bind(s), setter];
      }
      function createComputed(fn, value, options2) {
        const c = createComputation(fn, value, true, STALE);
        if (Scheduler && Transition && Transition.running)
          Updates.push(c);
        else
          updateComputation(c);
      }
      function createRenderEffect(fn, value, options2) {
        const c = createComputation(fn, value, false, STALE);
        if (Scheduler && Transition && Transition.running)
          Updates.push(c);
        else
          updateComputation(c);
      }
      function createEffect(fn, value, options2) {
        runEffects = runUserEffects;
        const c = createComputation(fn, value, false, STALE), s = SuspenseContext && useContext(SuspenseContext);
        if (s)
          c.suspense = s;
        if (!options2 || !options2.render)
          c.user = true;
        Effects ? Effects.push(c) : updateComputation(c);
      }
      function createReaction(onInvalidate, options2) {
        let fn;
        const c = createComputation(
          () => {
            fn ? fn() : untrack(onInvalidate);
            fn = void 0;
          },
          void 0,
          false,
          0
        ), s = SuspenseContext && useContext(SuspenseContext);
        if (s)
          c.suspense = s;
        c.user = true;
        return (tracking) => {
          fn = tracking;
          updateComputation(c);
        };
      }
      function createMemo(fn, value, options2) {
        options2 = options2 ? Object.assign({}, signalOptions, options2) : signalOptions;
        const c = createComputation(fn, value, true, 0);
        c.observers = null;
        c.observerSlots = null;
        c.comparator = options2.equals || void 0;
        if (Scheduler && Transition && Transition.running) {
          c.tState = STALE;
          Updates.push(c);
        } else
          updateComputation(c);
        return readSignal.bind(c);
      }
      function isPromise(v) {
        return v && typeof v === "object" && "then" in v;
      }
      function createResource(pSource, pFetcher, pOptions) {
        let source;
        let fetcher;
        let options2;
        if (typeof pFetcher === "function") {
          source = pSource;
          fetcher = pFetcher;
          options2 = pOptions || {};
        } else {
          source = true;
          fetcher = pSource;
          options2 = pFetcher || {};
        }
        let pr = null, initP = NO_INIT, id2 = null, loadedUnderTransition = false, scheduled = false, resolved = "initialValue" in options2, dynamic = typeof source === "function" && createMemo(source);
        const contexts = /* @__PURE__ */ new Set(), [value, setValue] = (options2.storage || createSignal)(options2.initialValue), [error, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {
          equals: false
        }), [state, setState] = createSignal(resolved ? "ready" : "unresolved");
        if (sharedConfig.context) {
          id2 = sharedConfig.getNextContextId();
          if (options2.ssrLoadFrom === "initial")
            initP = options2.initialValue;
          else if (sharedConfig.load && sharedConfig.has(id2))
            initP = sharedConfig.load(id2);
        }
        function loadEnd(p, v, error2, key) {
          if (pr === p) {
            pr = null;
            key !== void 0 && (resolved = true);
            if ((p === initP || v === initP) && options2.onHydrated)
              queueMicrotask(
                () => options2.onHydrated(key, {
                  value: v
                })
              );
            initP = NO_INIT;
            if (Transition && p && loadedUnderTransition) {
              Transition.promises.delete(p);
              loadedUnderTransition = false;
              runUpdates(() => {
                Transition.running = true;
                completeLoad(v, error2);
              }, false);
            } else
              completeLoad(v, error2);
          }
          return v;
        }
        function completeLoad(v, err) {
          runUpdates(() => {
            if (err === void 0)
              setValue(() => v);
            setState(err !== void 0 ? "errored" : resolved ? "ready" : "unresolved");
            setError(err);
            for(let   c of contexts.keys())
              c.decrement();
            contexts.clear();
          }, false);
        }
        function read() {
          const c = SuspenseContext && useContext(SuspenseContext), v = value(), err = error();
          if (err !== void 0 && !pr)
            throw err;
          if (Listener && !Listener.user && c) {
            createComputed(() => {
              track();
              if (pr) {
                if (c.resolved && Transition && loadedUnderTransition)
                  Transition.promises.add(pr);
                else if (!contexts.has(c)) {
                  c.increment();
                  contexts.add(c);
                }
              }
            });
          }
          return v;
        }
        function load(refetching = true) {
          if (refetching !== false && scheduled)
            return;
          scheduled = false;
          const lookup2 = dynamic ? dynamic() : source;
          loadedUnderTransition = Transition && Transition.running;
          if (lookup2 == null || lookup2 === false) {
            loadEnd(pr, untrack(value));
            return;
          }
          if (Transition && pr)
            Transition.promises.delete(pr);
          const p = initP !== NO_INIT ? initP : untrack(
            () => fetcher(lookup2, {
              value: value(),
              refetching
            })
          );
          if (!isPromise(p)) {
            loadEnd(pr, p, void 0, lookup2);
            return p;
          }
          pr = p;
          if ("value" in p) {
            if (p.status === "success")
              loadEnd(pr, p.value, void 0, lookup2);
            else
              loadEnd(pr, void 0, castError(p.value), lookup2);
            return p;
          }
          scheduled = true;
          queueMicrotask(() => scheduled = false);
          runUpdates(() => {
            setState(resolved ? "refreshing" : "pending");
            trigger();
          }, false);
          return p.then(
            (v) => loadEnd(p, v, void 0, lookup2),
            (e2) => loadEnd(p, void 0, castError(e2), lookup2)
          );
        }
        Object.defineProperties(read, {
          state: {
            get: () => state()
          },
          error: {
            get: () => error()
          },
          loading: {
            get() {
              const s = state();
              return s === "pending" || s === "refreshing";
            }
          },
          latest: {
            get() {
              if (!resolved)
                return read();
              const err = error();
              if (err && !pr)
                throw err;
              return value();
            }
          }
        });
        if (dynamic)
          createComputed(() => load(false));
        else
          load(false);
        return [
          read,
          {
            refetch: load,
            mutate: setValue
          }
        ];
      }
      function createDeferred(source, options2) {
        let t2, timeout = options2 ? options2.timeoutMs : void 0;
        const node = createComputation(
          () => {
            if (!t2 || !t2.fn)
              t2 = requestCallback(
                () => setDeferred(() => node.value),
                timeout !== void 0 ? {
                  timeout
                } : void 0
              );
            return source();
          },
          void 0,
          true
        );
        const [deferred, setDeferred] = createSignal(
          Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
          options2
        );
        updateComputation(node);
        setDeferred(
          () => Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value
        );
        return deferred;
      }
      function createSelector(source, fn = equalFn, options2) {
        const subs = /* @__PURE__ */ new Map();
        const node = createComputation(
          (p) => {
            const v = source();
            for(let   [key, val] of subs.entries())
              if (fn(key, v) !== fn(key, p)) {
                for(let   c of val.values()) {
                  c.state = STALE;
                  if (c.pure)
                    Updates.push(c);
                  else
                    Effects.push(c);
                }
              }
            return v;
          },
          void 0,
          true,
          STALE
        );
        updateComputation(node);
        return (key) => {
          const listener = Listener;
          if (listener) {
            let l2;
            if (l2 = subs.get(key))
              l2.add(listener);
            else
              subs.set(key, l2 = /* @__PURE__ */ new Set([listener]));
            onCleanup(() => {
              l2.delete(listener);
              !l2.size && subs.delete(key);
            });
          }
          return fn(
            key,
            Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value
          );
        };
      }
      function batch(fn) {
        return runUpdates(fn, false);
      }
      function untrack(fn) {
        if (!ExternalSourceConfig && Listener === null)
          return fn();
        const listener = Listener;
        Listener = null;
        try {
          if (ExternalSourceConfig)
            return ExternalSourceConfig.untrack(fn);
          return fn();
        } finally {
          Listener = listener;
        }
      }
      function on(deps, fn, options2) {
        const isArray2 = Array.isArray(deps);
        let prevInput;
        let defer = options2 && options2.defer;
        return (prevValue) => {
          let input;
          if (isArray2) {
            input = Array(deps.length);
            for (let i = 0; i < deps.length; i++)
              input[i] = deps[i]();
          } else
            input = deps();
          if (defer) {
            defer = false;
            return prevValue;
          }
          const result = untrack(() => fn(input, prevInput, prevValue));
          prevInput = input;
          return result;
        };
      }
      function onMount(fn) {
        createEffect(() => untrack(fn));
      }
      function onCleanup(fn) {
        if (Owner === null)
          ;
        else if (Owner.cleanups === null)
          Owner.cleanups = [fn];
        else
          Owner.cleanups.push(fn);
        return fn;
      }
      function catchError(fn, handler) {
        ERROR || (ERROR = Symbol("error"));
        Owner = createComputation(void 0, void 0, true);
        Owner.context = __spreadProps(__spreadValues({}, Owner.context), {
          [ERROR]: [handler]
        });
        if (Transition && Transition.running)
          Transition.sources.add(Owner);
        try {
          return fn();
        } catch (err) {
          handleError(err);
        } finally {
          Owner = Owner.owner;
        }
      }
      function getListener() {
        return Listener;
      }
      function getOwner() {
        return Owner;
      }
      function runWithOwner(o2, fn) {
        const prev = Owner;
        const prevListener = Listener;
        Owner = o2;
        Listener = null;
        try {
          return runUpdates(fn, true);
        } catch (err) {
          handleError(err);
        } finally {
          Owner = prev;
          Listener = prevListener;
        }
      }
      function enableScheduling(scheduler = requestCallback) {
        Scheduler = scheduler;
      }
      function startTransition(fn) {
        if (Transition && Transition.running) {
          fn();
          return Transition.done;
        }
        const l2 = Listener;
        const o2 = Owner;
        return Promise.resolve().then(() => {
          Listener = l2;
          Owner = o2;
          let t2;
          if (Scheduler || SuspenseContext) {
            t2 = Transition || (Transition = {
              sources: /* @__PURE__ */ new Set(),
              effects: [],
              promises: /* @__PURE__ */ new Set(),
              disposed: /* @__PURE__ */ new Set(),
              queue: /* @__PURE__ */ new Set(),
              running: true
            });
            t2.done || (t2.done = new Promise((res) => t2.resolve = res));
            t2.running = true;
          }
          runUpdates(fn, false);
          Listener = Owner = null;
          return t2 ? t2.done : void 0;
        });
      }
      const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
      function useTransition() {
        return [transPending, startTransition];
      }
      function resumeEffects(e2) {
        Effects.push.apply(Effects, e2);
        e2.length = 0;
      }
      function createContext(defaultValue, options2) {
        const id2 = Symbol("context");
        return {
          id: id2,
          Provider: createProvider(id2),
          defaultValue
        };
      }
      function useContext(context) {
        let value;
        return Owner && Owner.context && (value = Owner.context[context.id]) !== void 0 ? value : context.defaultValue;
      }
      function children(fn) {
        const children2 = createMemo(fn);
        const memo = createMemo(() => resolveChildren(children2()));
        memo.toArray = () => {
          const c = memo();
          return Array.isArray(c) ? c : c != null ? [c] : [];
        };
        return memo;
      }
      let SuspenseContext;
      function getSuspenseContext() {
        return SuspenseContext || (SuspenseContext = createContext());
      }
      function enableExternalSource(factory, untrack2 = (fn) => fn()) {
        if (ExternalSourceConfig) {
          const { factory: oldFactory, untrack: oldUntrack } = ExternalSourceConfig;
          ExternalSourceConfig = {
            factory: (fn, trigger) => {
              const oldSource = oldFactory(fn, trigger);
              const source = factory((x) => oldSource.track(x), trigger);
              return {
                track: (x) => source.track(x),
                dispose() {
                  source.dispose();
                  oldSource.dispose();
                }
              };
            },
            untrack: (fn) => oldUntrack(() => untrack2(fn))
          };
        } else {
          ExternalSourceConfig = {
            factory,
            untrack: untrack2
          };
        }
      }
      function readSignal() {
        const runningTransition = Transition && Transition.running;
        if (this.sources && (runningTransition ? this.tState : this.state)) {
          if ((runningTransition ? this.tState : this.state) === STALE)
            updateComputation(this);
          else {
            const updates = Updates;
            Updates = null;
            runUpdates(() => lookUpstream(this), false);
            Updates = updates;
          }
        }
        if (Listener) {
          const sSlot = this.observers ? this.observers.length : 0;
          if (!Listener.sources) {
            Listener.sources = [this];
            Listener.sourceSlots = [sSlot];
          } else {
            Listener.sources.push(this);
            Listener.sourceSlots.push(sSlot);
          }
          if (!this.observers) {
            this.observers = [Listener];
            this.observerSlots = [Listener.sources.length - 1];
          } else {
            this.observers.push(Listener);
            this.observerSlots.push(Listener.sources.length - 1);
          }
        }
        if (runningTransition && Transition.sources.has(this))
          return this.tValue;
        return this.value;
      }
      function writeSignal(node, value, isComp) {
        let current2 = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
        if (!node.comparator || !node.comparator(current2, value)) {
          if (Transition) {
            const TransitionRunning = Transition.running;
            if (TransitionRunning || !isComp && Transition.sources.has(node)) {
              Transition.sources.add(node);
              node.tValue = value;
            }
            if (!TransitionRunning)
              node.value = value;
          } else
            node.value = value;
          if (node.observers && node.observers.length) {
            runUpdates(() => {
              for (let i = 0; i < node.observers.length; i += 1) {
                const o2 = node.observers[i];
                const TransitionRunning = Transition && Transition.running;
                if (TransitionRunning && Transition.disposed.has(o2))
                  continue;
                if (TransitionRunning ? !o2.tState : !o2.state) {
                  if (o2.pure)
                    Updates.push(o2);
                  else
                    Effects.push(o2);
                  if (o2.observers)
                    markDownstream(o2);
                }
                if (!TransitionRunning)
                  o2.state = STALE;
                else
                  o2.tState = STALE;
              }
              if (Updates.length > 1e6) {
                Updates = [];
                if (IS_DEV)
                  ;
                throw new Error();
              }
            }, false);
          }
        }
        return value;
      }
      function updateComputation(node) {
        if (!node.fn)
          return;
        cleanNode(node);
        const time2 = ExecCount;
        runComputation(
          node,
          Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
          time2
        );
        if (Transition && !Transition.running && Transition.sources.has(node)) {
          queueMicrotask(() => {
            runUpdates(() => {
              Transition && (Transition.running = true);
              Listener = Owner = node;
              runComputation(node, node.tValue, time2);
              Listener = Owner = null;
            }, false);
          });
        }
      }
      function runComputation(node, value, time2) {
        let nextValue;
        const owner = Owner, listener = Listener;
        Listener = Owner = node;
        try {
          nextValue = node.fn(value);
        } catch (err) {
          if (node.pure) {
            if (Transition && Transition.running) {
              node.tState = STALE;
              node.tOwned && node.tOwned.forEach(cleanNode);
              node.tOwned = void 0;
            } else {
              node.state = STALE;
              node.owned && node.owned.forEach(cleanNode);
              node.owned = null;
            }
          }
          node.updatedAt = time2 + 1;
          return handleError(err);
        } finally {
          Listener = listener;
          Owner = owner;
        }
        if (!node.updatedAt || node.updatedAt <= time2) {
          if (node.updatedAt != null && "observers" in node) {
            writeSignal(node, nextValue, true);
          } else if (Transition && Transition.running && node.pure) {
            Transition.sources.add(node);
            node.tValue = nextValue;
          } else
            node.value = nextValue;
          node.updatedAt = time2;
        }
      }
      function createComputation(fn, init, pure, state = STALE, options2) {
        const c = {
          fn,
          state,
          updatedAt: null,
          owned: null,
          sources: null,
          sourceSlots: null,
          cleanups: null,
          value: init,
          owner: Owner,
          context: Owner ? Owner.context : null,
          pure
        };
        if (Transition && Transition.running) {
          c.state = 0;
          c.tState = state;
        }
        if (Owner === null)
          ;
        else if (Owner !== UNOWNED) {
          if (Transition && Transition.running && Owner.pure) {
            if (!Owner.tOwned)
              Owner.tOwned = [c];
            else
              Owner.tOwned.push(c);
          } else {
            if (!Owner.owned)
              Owner.owned = [c];
            else
              Owner.owned.push(c);
          }
        }
        if (ExternalSourceConfig && c.fn) {
          const [track, trigger] = createSignal(void 0, {
            equals: false
          });
          const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
          onCleanup(() => ordinary.dispose());
          const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
          const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
          c.fn = (x) => {
            track();
            return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
          };
        }
        return c;
      }
      function runTop(node) {
        const runningTransition = Transition && Transition.running;
        if ((runningTransition ? node.tState : node.state) === 0)
          return;
        if ((runningTransition ? node.tState : node.state) === PENDING)
          return lookUpstream(node);
        if (node.suspense && untrack(node.suspense.inFallback))
          return node.suspense.effects.push(node);
        const ancestors = [node];
        while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
          if (runningTransition && Transition.disposed.has(node))
            return;
          if (runningTransition ? node.tState : node.state)
            ancestors.push(node);
        }
        for (let i = ancestors.length - 1; i >= 0; i--) {
          node = ancestors[i];
          if (runningTransition) {
            let top2 = node, prev = ancestors[i + 1];
            while ((top2 = top2.owner) && top2 !== prev) {
              if (Transition.disposed.has(top2))
                return;
            }
          }
          if ((runningTransition ? node.tState : node.state) === STALE) {
            updateComputation(node);
          } else if ((runningTransition ? node.tState : node.state) === PENDING) {
            const updates = Updates;
            Updates = null;
            runUpdates(() => lookUpstream(node, ancestors[0]), false);
            Updates = updates;
          }
        }
      }
      function runUpdates(fn, init) {
        if (Updates)
          return fn();
        let wait = false;
        if (!init)
          Updates = [];
        if (Effects)
          wait = true;
        else
          Effects = [];
        ExecCount++;
        try {
          const res = fn();
          completeUpdates(wait);
          return res;
        } catch (err) {
          if (!wait)
            Effects = null;
          Updates = null;
          handleError(err);
        }
      }
      function completeUpdates(wait) {
        if (Updates) {
          if (Scheduler && Transition && Transition.running)
            scheduleQueue(Updates);
          else
            runQueue(Updates);
          Updates = null;
        }
        if (wait)
          return;
        let res;
        if (Transition) {
          if (!Transition.promises.size && !Transition.queue.size) {
            const sources = Transition.sources;
            const disposed = Transition.disposed;
            Effects.push.apply(Effects, Transition.effects);
            res = Transition.resolve;
            for(let   e3 of Effects) {
              "tState" in e3 && (e3.state = e3.tState);
              delete e3.tState;
            }
            Transition = null;
            runUpdates(() => {
              for(let   d of disposed)
                cleanNode(d);
              for(let   v of sources) {
                v.value = v.tValue;
                if (v.owned) {
                  for (let i = 0, len = v.owned.length; i < len; i++)
                    cleanNode(v.owned[i]);
                }
                if (v.tOwned)
                  v.owned = v.tOwned;
                delete v.tValue;
                delete v.tOwned;
                v.tState = 0;
              }
              setTransPending(false);
            }, false);
          } else if (Transition.running) {
            Transition.running = false;
            Transition.effects.push.apply(Transition.effects, Effects);
            Effects = null;
            setTransPending(true);
            return;
          }
        }
        const e2 = Effects;
        Effects = null;
        if (e2.length)
          runUpdates(() => runEffects(e2), false);
        if (res)
          res();
      }
      function runQueue(queue2) {
        for (let i = 0; i < queue2.length; i++)
          runTop(queue2[i]);
      }
      function scheduleQueue(queue2) {
        for (let i = 0; i < queue2.length; i++) {
          const item2 = queue2[i];
          const tasks = Transition.queue;
          if (!tasks.has(item2)) {
            tasks.add(item2);
            Scheduler(() => {
              tasks.delete(item2);
              runUpdates(() => {
                Transition.running = true;
                runTop(item2);
              }, false);
              Transition && (Transition.running = false);
            });
          }
        }
      }
      function runUserEffects(queue2) {
        let i, userLength = 0;
        for (i = 0; i < queue2.length; i++) {
          const e2 = queue2[i];
          if (!e2.user)
            runTop(e2);
          else
            queue2[userLength++] = e2;
        }
        if (sharedConfig.context) {
          if (sharedConfig.count) {
            sharedConfig.effects || (sharedConfig.effects = []);
            sharedConfig.effects.push(...queue2.slice(0, userLength));
            return;
          }
          setHydrateContext();
        }
        if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
          queue2 = [...sharedConfig.effects, ...queue2];
          userLength += sharedConfig.effects.length;
          delete sharedConfig.effects;
        }
        for (i = 0; i < userLength; i++)
          runTop(queue2[i]);
      }
      function lookUpstream(node, ignore) {
        const runningTransition = Transition && Transition.running;
        if (runningTransition)
          node.tState = 0;
        else
          node.state = 0;
        for (let i = 0; i < node.sources.length; i += 1) {
          const source = node.sources[i];
          if (source.sources) {
            const state = runningTransition ? source.tState : source.state;
            if (state === STALE) {
              if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
                runTop(source);
            } else if (state === PENDING)
              lookUpstream(source, ignore);
          }
        }
      }
      function markDownstream(node) {
        const runningTransition = Transition && Transition.running;
        for (let i = 0; i < node.observers.length; i += 1) {
          const o2 = node.observers[i];
          if (runningTransition ? !o2.tState : !o2.state) {
            if (runningTransition)
              o2.tState = PENDING;
            else
              o2.state = PENDING;
            if (o2.pure)
              Updates.push(o2);
            else
              Effects.push(o2);
            o2.observers && markDownstream(o2);
          }
        }
      }
      function cleanNode(node) {
        let i;
        if (node.sources) {
          while (node.sources.length) {
            const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
            if (obs && obs.length) {
              const n2 = obs.pop(), s = source.observerSlots.pop();
              if (index < obs.length) {
                n2.sourceSlots[s] = index;
                obs[index] = n2;
                source.observerSlots[index] = s;
              }
            }
          }
        }
        if (node.tOwned) {
          for (i = node.tOwned.length - 1; i >= 0; i--)
            cleanNode(node.tOwned[i]);
          delete node.tOwned;
        }
        if (Transition && Transition.running && node.pure) {
          reset(node, true);
        } else if (node.owned) {
          for (i = node.owned.length - 1; i >= 0; i--)
            cleanNode(node.owned[i]);
          node.owned = null;
        }
        if (node.cleanups) {
          for (i = node.cleanups.length - 1; i >= 0; i--)
            node.cleanups[i]();
          node.cleanups = null;
        }
        if (Transition && Transition.running)
          node.tState = 0;
        else
          node.state = 0;
      }
      function reset(node, top2) {
        if (!top2) {
          node.tState = 0;
          Transition.disposed.add(node);
        }
        if (node.owned) {
          for (let i = 0; i < node.owned.length; i++)
            reset(node.owned[i]);
        }
      }
      function castError(err) {
        if (err instanceof Error)
          return err;
        return new Error(typeof err === "string" ? err : "Unknown error", {
          cause: err
        });
      }
      function runErrors(err, fns, owner) {
        try {
          for(let   f of fns)
            f(err);
        } catch (e2) {
          handleError(e2, owner && owner.owner || null);
        }
      }
      function handleError(err, owner = Owner) {
        const fns = ERROR && owner && owner.context && owner.context[ERROR];
        const error = castError(err);
        if (!fns)
          throw error;
        if (Effects)
          Effects.push({
            fn() {
              runErrors(error, fns, owner);
            },
            state: STALE
          });
        else
          runErrors(error, fns, owner);
      }
      function resolveChildren(children2) {
        if (typeof children2 === "function" && !children2.length)
          return resolveChildren(children2());
        if (Array.isArray(children2)) {
          const results = [];
          for (let i = 0; i < children2.length; i++) {
            const result = resolveChildren(children2[i]);
            Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
          }
          return results;
        }
        return children2;
      }
      function createProvider(id2, options2) {
        return function provider(props) {
          let res;
          createRenderEffect(
            () => res = untrack(() => {
              Owner.context = __spreadProps(__spreadValues({}, Owner.context), {
                [id2]: props.value
              });
              return children(() => props.children);
            }),
            void 0
          );
          return res;
        };
      }
      function onError(fn) {
        ERROR || (ERROR = Symbol("error"));
        if (Owner === null)
          ;
        else if (Owner.context === null || !Owner.context[ERROR]) {
          Owner.context = __spreadProps(__spreadValues({}, Owner.context), {
            [ERROR]: [fn]
          });
          mutateContext(Owner, ERROR, [fn]);
        } else
          Owner.context[ERROR].push(fn);
      }
      function mutateContext(o2, key, value) {
        if (o2.owned) {
          for (let i = 0; i < o2.owned.length; i++) {
            if (o2.owned[i].context === o2.context)
              mutateContext(o2.owned[i], key, value);
            if (!o2.owned[i].context) {
              o2.owned[i].context = o2.context;
              mutateContext(o2.owned[i], key, value);
            } else if (!o2.owned[i].context[key]) {
              o2.owned[i].context[key] = value;
              mutateContext(o2.owned[i], key, value);
            }
          }
        }
      }
      function observable(input) {
        return {
          subscribe(observer) {
            if (!(observer instanceof Object) || observer == null) {
              throw new TypeError("Expected the observer to be an object.");
            }
            const handler = typeof observer === "function" ? observer : observer.next && observer.next.bind(observer);
            if (!handler) {
              return {
                unsubscribe() {
                }
              };
            }
            const dispose2 = createRoot((disposer) => {
              createEffect(() => {
                const v = input();
                untrack(() => handler(v));
              });
              return disposer;
            });
            if (getOwner())
              onCleanup(dispose2);
            return {
              unsubscribe() {
                dispose2();
              }
            };
          },
          [Symbol.observable || "@@observable"]() {
            return this;
          }
        };
      }
      function from(producer, initalValue = void 0) {
        const [s, set2] = createSignal(initalValue, {
          equals: false
        });
        if ("subscribe" in producer) {
          const unsub = producer.subscribe((v) => set2(() => v));
          onCleanup(() => "unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
        } else {
          const clean = producer(set2);
          onCleanup(clean);
        }
        return s;
      }
      const FALLBACK = Symbol("fallback");
      function dispose(d) {
        for (let i = 0; i < d.length; i++)
          d[i]();
      }
      function mapArray(list, mapFn, options2 = {}) {
        let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
        onCleanup(() => dispose(disposers));
        return () => {
          let newItems = list() || [], newLen = newItems.length, i, j;
          newItems[$TRACK];
          return untrack(() => {
            let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start2, end, newEnd, item2;
            if (newLen === 0) {
              if (len !== 0) {
                dispose(disposers);
                disposers = [];
                items = [];
                mapped = [];
                len = 0;
                indexes && (indexes = []);
              }
              if (options2.fallback) {
                items = [FALLBACK];
                mapped[0] = createRoot((disposer) => {
                  disposers[0] = disposer;
                  return options2.fallback();
                });
                len = 1;
              }
            } else if (len === 0) {
              mapped = new Array(newLen);
              for (j = 0; j < newLen; j++) {
                items[j] = newItems[j];
                mapped[j] = createRoot(mapper);
              }
              len = newLen;
            } else {
              temp = new Array(newLen);
              tempdisposers = new Array(newLen);
              indexes && (tempIndexes = new Array(newLen));
              for (start2 = 0, end = Math.min(len, newLen); start2 < end && items[start2] === newItems[start2]; start2++)
                ;
              for (end = len - 1, newEnd = newLen - 1; end >= start2 && newEnd >= start2 && items[end] === newItems[newEnd]; end--, newEnd--) {
                temp[newEnd] = mapped[end];
                tempdisposers[newEnd] = disposers[end];
                indexes && (tempIndexes[newEnd] = indexes[end]);
              }
              newIndices = /* @__PURE__ */ new Map();
              newIndicesNext = new Array(newEnd + 1);
              for (j = newEnd; j >= start2; j--) {
                item2 = newItems[j];
                i = newIndices.get(item2);
                newIndicesNext[j] = i === void 0 ? -1 : i;
                newIndices.set(item2, j);
              }
              for (i = start2; i <= end; i++) {
                item2 = items[i];
                j = newIndices.get(item2);
                if (j !== void 0 && j !== -1) {
                  temp[j] = mapped[i];
                  tempdisposers[j] = disposers[i];
                  indexes && (tempIndexes[j] = indexes[i]);
                  j = newIndicesNext[j];
                  newIndices.set(item2, j);
                } else
                  disposers[i]();
              }
              for (j = start2; j < newLen; j++) {
                if (j in temp) {
                  mapped[j] = temp[j];
                  disposers[j] = tempdisposers[j];
                  if (indexes) {
                    indexes[j] = tempIndexes[j];
                    indexes[j](j);
                  }
                } else
                  mapped[j] = createRoot(mapper);
              }
              mapped = mapped.slice(0, len = newLen);
              items = newItems.slice(0);
            }
            return mapped;
          });
          function mapper(disposer) {
            disposers[j] = disposer;
            if (indexes) {
              const [s, set2] = createSignal(j);
              indexes[j] = set2;
              return mapFn(newItems[j], s);
            }
            return mapFn(newItems[j]);
          }
        };
      }
      function indexArray(list, mapFn, options2 = {}) {
        let items = [], mapped = [], disposers = [], signals2 = [], len = 0, i;
        onCleanup(() => dispose(disposers));
        return () => {
          const newItems = list() || [], newLen = newItems.length;
          newItems[$TRACK];
          return untrack(() => {
            if (newLen === 0) {
              if (len !== 0) {
                dispose(disposers);
                disposers = [];
                items = [];
                mapped = [];
                len = 0;
                signals2 = [];
              }
              if (options2.fallback) {
                items = [FALLBACK];
                mapped[0] = createRoot((disposer) => {
                  disposers[0] = disposer;
                  return options2.fallback();
                });
                len = 1;
              }
              return mapped;
            }
            if (items[0] === FALLBACK) {
              disposers[0]();
              disposers = [];
              items = [];
              mapped = [];
              len = 0;
            }
            for (i = 0; i < newLen; i++) {
              if (i < items.length && items[i] !== newItems[i]) {
                signals2[i](() => newItems[i]);
              } else if (i >= items.length) {
                mapped[i] = createRoot(mapper);
              }
            }
            for (; i < items.length; i++) {
              disposers[i]();
            }
            len = signals2.length = disposers.length = newLen;
            items = newItems.slice(0);
            return mapped = mapped.slice(0, len);
          });
          function mapper(disposer) {
            disposers[i] = disposer;
            const [s, set2] = createSignal(newItems[i]);
            signals2[i] = set2;
            return mapFn(s, i);
          }
        };
      }
      let hydrationEnabled = false;
      function enableHydration() {
        hydrationEnabled = true;
      }
      function createComponent(Comp, props) {
        if (hydrationEnabled) {
          if (sharedConfig.context) {
            const c = sharedConfig.context;
            setHydrateContext(nextHydrateContext());
            const r2 = untrack(() => Comp(props || {}));
            setHydrateContext(c);
            return r2;
          }
        }
        return untrack(() => Comp(props || {}));
      }
      function trueFn() {
        return true;
      }
      const propTraps = {
        get(_, property, receiver) {
          if (property === $PROXY)
            return receiver;
          return _.get(property);
        },
        has(_, property) {
          if (property === $PROXY)
            return true;
          return _.has(property);
        },
        set: trueFn,
        deleteProperty: trueFn,
        getOwnPropertyDescriptor(_, property) {
          return {
            configurable: true,
            enumerable: true,
            get() {
              return _.get(property);
            },
            set: trueFn,
            deleteProperty: trueFn
          };
        },
        ownKeys(_) {
          return _.keys();
        }
      };
      function resolveSource(s) {
        return !(s = typeof s === "function" ? s() : s) ? {} : s;
      }
      function resolveSources() {
        for (let i = 0, length = this.length; i < length; ++i) {
          const v = this[i]();
          if (v !== void 0)
            return v;
        }
      }
      function mergeProps(...sources) {
        let proxy2 = false;
        for (let i = 0; i < sources.length; i++) {
          const s = sources[i];
          proxy2 = proxy2 || !!s && $PROXY in s;
          sources[i] = typeof s === "function" ? (proxy2 = true, createMemo(s)) : s;
        }
        if (SUPPORTS_PROXY && proxy2) {
          return new Proxy(
            {
              get(property) {
                for (let i = sources.length - 1; i >= 0; i--) {
                  const v = resolveSource(sources[i])[property];
                  if (v !== void 0)
                    return v;
                }
              },
              has(property) {
                for (let i = sources.length - 1; i >= 0; i--) {
                  if (property in resolveSource(sources[i]))
                    return true;
                }
                return false;
              },
              keys() {
                const keys2 = [];
                for (let i = 0; i < sources.length; i++)
                  keys2.push(...Object.keys(resolveSource(sources[i])));
                return [...new Set(keys2)];
              }
            },
            propTraps
          );
        }
        const sourcesMap = {};
        const defined = /* @__PURE__ */ Object.create(null);
        for (let i = sources.length - 1; i >= 0; i--) {
          const source = sources[i];
          if (!source)
            continue;
          const sourceKeys = Object.getOwnPropertyNames(source);
          for (let i2 = sourceKeys.length - 1; i2 >= 0; i2--) {
            const key = sourceKeys[i2];
            if (key === "__proto__" || key === "constructor")
              continue;
            const desc2 = Object.getOwnPropertyDescriptor(source, key);
            if (!defined[key]) {
              defined[key] = desc2.get ? {
                enumerable: true,
                configurable: true,
                get: resolveSources.bind(sourcesMap[key] = [desc2.get.bind(source)])
              } : desc2.value !== void 0 ? desc2 : void 0;
            } else {
              const sources2 = sourcesMap[key];
              if (sources2) {
                if (desc2.get)
                  sources2.push(desc2.get.bind(source));
                else if (desc2.value !== void 0)
                  sources2.push(() => desc2.value);
              }
            }
          }
        }
        const target = {};
        const definedKeys = Object.keys(defined);
        for (let i = definedKeys.length - 1; i >= 0; i--) {
          const key = definedKeys[i], desc2 = defined[key];
          if (desc2 && desc2.get)
            Object.defineProperty(target, key, desc2);
          else
            target[key] = desc2 ? desc2.value : void 0;
        }
        return target;
      }
      function splitProps(props, ...keys2) {
        if (SUPPORTS_PROXY && $PROXY in props) {
          const blocked = new Set(keys2.length > 1 ? keys2.flat() : keys2[0]);
          const res = keys2.map((k) => {
            return new Proxy(
              {
                get(property) {
                  return k.includes(property) ? props[property] : void 0;
                },
                has(property) {
                  return k.includes(property) && property in props;
                },
                keys() {
                  return k.filter((property) => property in props);
                }
              },
              propTraps
            );
          });
          res.push(
            new Proxy(
              {
                get(property) {
                  return blocked.has(property) ? void 0 : props[property];
                },
                has(property) {
                  return blocked.has(property) ? false : property in props;
                },
                keys() {
                  return Object.keys(props).filter((k) => !blocked.has(k));
                }
              },
              propTraps
            )
          );
          return res;
        }
        const otherObject = {};
        const objects = keys2.map(() => ({}));
        for(let   propName of Object.getOwnPropertyNames(props)) {
          const desc2 = Object.getOwnPropertyDescriptor(props, propName);
          const isDefaultDesc = !desc2.get && !desc2.set && desc2.enumerable && desc2.writable && desc2.configurable;
          let blocked = false;
          let objectIndex = 0;
          for(let   k of keys2) {
            if (k.includes(propName)) {
              blocked = true;
              isDefaultDesc ? objects[objectIndex][propName] = desc2.value : Object.defineProperty(objects[objectIndex], propName, desc2);
            }
            ++objectIndex;
          }
          if (!blocked) {
            isDefaultDesc ? otherObject[propName] = desc2.value : Object.defineProperty(otherObject, propName, desc2);
          }
        }
        return [...objects, otherObject];
      }
      function lazy(fn) {
        let comp;
        let p;
        const wrap2 = (props) => {
          const ctx = sharedConfig.context;
          if (ctx) {
            const [s, set2] = createSignal();
            sharedConfig.count || (sharedConfig.count = 0);
            sharedConfig.count++;
            (p || (p = fn())).then((mod) => {
              !sharedConfig.done && setHydrateContext(ctx);
              sharedConfig.count--;
              set2(() => mod.default);
              setHydrateContext();
            });
            comp = s;
          } else if (!comp) {
            const [s] = createResource(() => (p || (p = fn())).then((mod) => mod.default));
            comp = s;
          }
          let Comp;
          return createMemo(
            () => (Comp = comp()) ? untrack(() => {
              if (IS_DEV)
                ;
              if (!ctx || sharedConfig.done)
                return Comp(props);
              const c = sharedConfig.context;
              setHydrateContext(ctx);
              const r2 = Comp(props);
              setHydrateContext(c);
              return r2;
            }) : ""
          );
        };
        wrap2.preload = () => p || ((p = fn()).then((mod) => comp = () => mod.default), p);
        return wrap2;
      }
      let counter$1 = 0;
      function createUniqueId() {
        const ctx = sharedConfig.context;
        return ctx ? sharedConfig.getNextContextId() : `cl-${counter$1++}`;
      }
      const narrowedError = (name2) => `Stale read from <${name2}>.`;
      function For(props) {
        const fallback = "fallback" in props && {
          fallback: () => props.fallback
        };
        return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
      }
      function Index(props) {
        const fallback = "fallback" in props && {
          fallback: () => props.fallback
        };
        return createMemo(indexArray(() => props.each, props.children, fallback || void 0));
      }
      function Show(props) {
        const keyed = props.keyed;
        const conditionValue = createMemo(() => props.when, void 0, void 0);
        const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {
          equals: (a, b) => !a === !b
        });
        return createMemo(
          () => {
            const c = condition();
            if (c) {
              const child = props.children;
              const fn = typeof child === "function" && child.length > 0;
              return fn ? untrack(
                () => child(
                  keyed ? c : () => {
                    if (!untrack(condition))
                      throw narrowedError("Show");
                    return conditionValue();
                  }
                )
              ) : child;
            }
            return props.fallback;
          },
          void 0,
          void 0
        );
      }
      function Switch(props) {
        const chs = children(() => props.children);
        const switchFunc = createMemo(() => {
          const ch = chs();
          const mps = Array.isArray(ch) ? ch : [ch];
          let func = () => void 0;
          for (let i = 0; i < mps.length; i++) {
            const index = i;
            const mp = mps[i];
            const prevFunc = func;
            const conditionValue = createMemo(
              () => prevFunc() ? void 0 : mp.when,
              void 0,
              void 0
            );
            const condition = mp.keyed ? conditionValue : createMemo(conditionValue, void 0, {
              equals: (a, b) => !a === !b
            });
            func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : void 0);
          }
          return func;
        });
        return createMemo(
          () => {
            const sel = switchFunc()();
            if (!sel)
              return props.fallback;
            const [index, conditionValue, mp] = sel;
            const child = mp.children;
            const fn = typeof child === "function" && child.length > 0;
            return fn ? untrack(
              () => child(
                mp.keyed ? conditionValue() : () => {
                  var _a3;
                  if (((_a3 = untrack(switchFunc)()) == null ? void 0 : _a3[0]) !== index)
                    throw narrowedError("Match");
                  return conditionValue();
                }
              )
            ) : child;
          },
          void 0,
          void 0
        );
      }
      function Match(props) {
        return props;
      }
      let Errors;
      function resetErrorBoundaries() {
        Errors && [...Errors].forEach((fn) => fn());
      }
      function ErrorBoundary(props) {
        let err;
        if (sharedConfig.context && sharedConfig.load)
          err = sharedConfig.load(sharedConfig.getContextId());
        const [errored, setErrored] = createSignal(err, void 0);
        Errors || (Errors = /* @__PURE__ */ new Set());
        Errors.add(setErrored);
        onCleanup(() => Errors.delete(setErrored));
        return createMemo(
          () => {
            let e2;
            if (e2 = errored()) {
              const f = props.fallback;
              return typeof f === "function" && f.length ? untrack(() => f(e2, () => setErrored())) : f;
            }
            return catchError(() => props.children, setErrored);
          },
          void 0,
          void 0
        );
      }
      const suspenseListEquals = (a, b) => a.showContent === b.showContent && a.showFallback === b.showFallback;
      const SuspenseListContext = /* @__PURE__ */ createContext();
      function SuspenseList(props) {
        let [wrapper, setWrapper] = createSignal(() => ({
          inFallback: false
        })), show;
        const listContext = useContext(SuspenseListContext);
        const [registry, setRegistry] = createSignal([]);
        if (listContext) {
          show = listContext.register(createMemo(() => wrapper()().inFallback));
        }
        const resolved = createMemo(
          (prev) => {
            const reveal = props.revealOrder, tail2 = props.tail, { showContent = true, showFallback = true } = show ? show() : {}, reg = registry(), reverse = reveal === "backwards";
            if (reveal === "together") {
              const all = reg.every((inFallback2) => !inFallback2());
              const res2 = reg.map(() => ({
                showContent: all && showContent,
                showFallback
              }));
              res2.inFallback = !all;
              return res2;
            }
            let stop = false;
            let inFallback = prev.inFallback;
            const res = [];
            for (let i = 0, len = reg.length; i < len; i++) {
              const n2 = reverse ? len - i - 1 : i, s = reg[n2]();
              if (!stop && !s) {
                res[n2] = {
                  showContent,
                  showFallback
                };
              } else {
                const next2 = !stop;
                if (next2)
                  inFallback = true;
                res[n2] = {
                  showContent: next2,
                  showFallback: !tail2 || next2 && tail2 === "collapsed" ? showFallback : false
                };
                stop = true;
              }
            }
            if (!stop)
              inFallback = false;
            res.inFallback = inFallback;
            return res;
          },
          {
            inFallback: false
          }
        );
        setWrapper(() => resolved);
        return createComponent(SuspenseListContext.Provider, {
          value: {
            register: (inFallback) => {
              let index;
              setRegistry((registry2) => {
                index = registry2.length;
                return [...registry2, inFallback];
              });
              return createMemo(() => resolved()[index], void 0, {
                equals: suspenseListEquals
              });
            }
          },
          get children() {
            return props.children;
          }
        });
      }
      function Suspense(props) {
        let counter2 = 0, show, ctx, p, flicker, error;
        const [inFallback, setFallback] = createSignal(false), SuspenseContext2 = getSuspenseContext(), store2 = {
          increment: () => {
            if (++counter2 === 1)
              setFallback(true);
          },
          decrement: () => {
            if (--counter2 === 0)
              setFallback(false);
          },
          inFallback,
          effects: [],
          resolved: false
        }, owner = getOwner();
        if (sharedConfig.context && sharedConfig.load) {
          const key = sharedConfig.getContextId();
          let ref = sharedConfig.load(key);
          if (ref) {
            if (typeof ref !== "object" || ref.status !== "success")
              p = ref;
            else
              sharedConfig.gather(key);
          }
          if (p && p !== "$$f") {
            const [s, set2] = createSignal(void 0, {
              equals: false
            });
            flicker = s;
            p.then(
              () => {
                if (sharedConfig.done)
                  return set2();
                sharedConfig.gather(key);
                setHydrateContext(ctx);
                set2();
                setHydrateContext();
              },
              (err) => {
                error = err;
                set2();
              }
            );
          }
        }
        const listContext = useContext(SuspenseListContext);
        if (listContext)
          show = listContext.register(store2.inFallback);
        let dispose2;
        onCleanup(() => dispose2 && dispose2());
        return createComponent(SuspenseContext2.Provider, {
          value: store2,
          get children() {
            return createMemo(() => {
              if (error)
                throw error;
              ctx = sharedConfig.context;
              if (flicker) {
                flicker();
                return flicker = void 0;
              }
              if (ctx && p === "$$f")
                setHydrateContext();
              const rendered = createMemo(() => props.children);
              return createMemo((prev) => {
                const inFallback2 = store2.inFallback(), { showContent = true, showFallback = true } = show ? show() : {};
                if ((!inFallback2 || p && p !== "$$f") && showContent) {
                  store2.resolved = true;
                  dispose2 && dispose2();
                  dispose2 = ctx = p = void 0;
                  resumeEffects(store2.effects);
                  return rendered();
                }
                if (!showFallback)
                  return;
                if (dispose2)
                  return prev;
                return createRoot((disposer) => {
                  dispose2 = disposer;
                  if (ctx) {
                    setHydrateContext({
                      id: ctx.id + "F",
                      count: 0
                    });
                    ctx = void 0;
                  }
                  return props.fallback;
                }, owner);
              });
            });
          }
        });
      }
      const DEV = void 0;
      const solid = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        $DEVCOMP,
        $PROXY,
        $TRACK,
        DEV,
        ErrorBoundary,
        For,
        Index,
        Match,
        Show,
        Suspense,
        SuspenseList,
        Switch,
        batch,
        cancelCallback,
        catchError,
        children,
        createComponent,
        createComputed,
        createContext,
        createDeferred,
        createEffect,
        createMemo,
        createReaction,
        createRenderEffect,
        createResource,
        createRoot,
        createSelector,
        createSignal,
        createUniqueId,
        enableExternalSource,
        enableHydration,
        enableScheduling,
        equalFn,
        from,
        getListener,
        getOwner,
        indexArray,
        lazy,
        mapArray,
        mergeProps,
        observable,
        on,
        onCleanup,
        onError,
        onMount,
        requestCallback,
        resetErrorBoundaries,
        runWithOwner,
        sharedConfig,
        splitProps,
        startTransition,
        untrack,
        useContext,
        useTransition
      }, Symbol.toStringTag, { value: "Module" }));
      exports("dL", solid);
      const booleans = [
        "allowfullscreen",
        "async",
        "autofocus",
        "autoplay",
        "checked",
        "controls",
        "default",
        "disabled",
        "formnovalidate",
        "hidden",
        "indeterminate",
        "inert",
        "ismap",
        "loop",
        "multiple",
        "muted",
        "nomodule",
        "novalidate",
        "open",
        "playsinline",
        "readonly",
        "required",
        "reversed",
        "seamless",
        "selected"
      ];
      const Properties = /* @__PURE__ */ new Set([
        "className",
        "value",
        "readOnly",
        "formNoValidate",
        "isMap",
        "noModule",
        "playsInline",
        ...booleans
      ]);
      const ChildProperties = /* @__PURE__ */ new Set([
        "innerHTML",
        "textContent",
        "innerText",
        "children"
      ]);
      const Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
        className: "class",
        htmlFor: "for"
      });
      const PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
        class: "className",
        formnovalidate: {
          $: "formNoValidate",
          BUTTON: 1,
          INPUT: 1
        },
        ismap: {
          $: "isMap",
          IMG: 1
        },
        nomodule: {
          $: "noModule",
          SCRIPT: 1
        },
        playsinline: {
          $: "playsInline",
          VIDEO: 1
        },
        readonly: {
          $: "readOnly",
          INPUT: 1,
          TEXTAREA: 1
        }
      });
      function getPropAlias(prop, tagName) {
        const a = PropAliases[prop];
        return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
      }
      const DelegatedEvents = /* @__PURE__ */ new Set([
        "beforeinput",
        "click",
        "dblclick",
        "contextmenu",
        "focusin",
        "focusout",
        "input",
        "keydown",
        "keyup",
        "mousedown",
        "mousemove",
        "mouseout",
        "mouseover",
        "mouseup",
        "pointerdown",
        "pointermove",
        "pointerout",
        "pointerover",
        "pointerup",
        "touchend",
        "touchmove",
        "touchstart"
      ]);
      const SVGElements = /* @__PURE__ */ new Set([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animate",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "circle",
        "clipPath",
        "color-profile",
        "cursor",
        "defs",
        "desc",
        "ellipse",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "filter",
        "font",
        "font-face",
        "font-face-format",
        "font-face-name",
        "font-face-src",
        "font-face-uri",
        "foreignObject",
        "g",
        "glyph",
        "glyphRef",
        "hkern",
        "image",
        "line",
        "linearGradient",
        "marker",
        "mask",
        "metadata",
        "missing-glyph",
        "mpath",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialGradient",
        "rect",
        "set",
        "stop",
        "svg",
        "switch",
        "symbol",
        "text",
        "textPath",
        "tref",
        "tspan",
        "use",
        "view",
        "vkern"
      ]);
      const SVGNamespace = {
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace"
      };
      function reconcileArrays(parentNode, a, b) {
        let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map2 = null;
        while (aStart < aEnd || bStart < bEnd) {
          if (a[aStart] === b[bStart]) {
            aStart++;
            bStart++;
            continue;
          }
          while (a[aEnd - 1] === b[bEnd - 1]) {
            aEnd--;
            bEnd--;
          }
          if (aEnd === aStart) {
            const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
            while (bStart < bEnd)
              parentNode.insertBefore(b[bStart++], node);
          } else if (bEnd === bStart) {
            while (aStart < aEnd) {
              if (!map2 || !map2.has(a[aStart]))
                a[aStart].remove();
              aStart++;
            }
          } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
            const node = a[--aEnd].nextSibling;
            parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
            parentNode.insertBefore(b[--bEnd], node);
            a[aEnd] = b[bEnd];
          } else {
            if (!map2) {
              map2 = /* @__PURE__ */ new Map();
              let i = bStart;
              while (i < bEnd)
                map2.set(b[i], i++);
            }
            const index = map2.get(a[aStart]);
            if (index != null) {
              if (bStart < index && index < bEnd) {
                let i = aStart, sequence = 1, t2;
                while (++i < aEnd && i < bEnd) {
                  if ((t2 = map2.get(a[i])) == null || t2 !== index + sequence)
                    break;
                  sequence++;
                }
                if (sequence > index - bStart) {
                  const node = a[aStart];
                  while (bStart < index)
                    parentNode.insertBefore(b[bStart++], node);
                } else
                  parentNode.replaceChild(b[bStart++], a[aStart++]);
              } else
                aStart++;
            } else
              a[aStart++].remove();
          }
        }
      }
      const $$EVENTS = "_$DX_DELEGATE";
      function render(code2, element, init, options2 = {}) {
        let disposer;
        createRoot((dispose2) => {
          disposer = dispose2;
          element === document ? code2() : insert(element, code2(), element.firstChild ? null : void 0, init);
        }, options2.owner);
        return () => {
          disposer();
          element.textContent = "";
        };
      }
      function template(html2, isImportNode, isSVG, isMathML) {
        let node;
        const create2 = () => {
          const t2 = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
          t2.innerHTML = html2;
          return isSVG ? t2.content.firstChild.firstChild : isMathML ? t2.firstChild : t2.content.firstChild;
        };
        const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create2()), true)) : () => (node || (node = create2())).cloneNode(true);
        fn.cloneNode = fn;
        return fn;
      }
      function delegateEvents(eventNames, document2 = window.document) {
        const e2 = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
        for (let i = 0, l2 = eventNames.length; i < l2; i++) {
          const name2 = eventNames[i];
          if (!e2.has(name2)) {
            e2.add(name2);
            document2.addEventListener(name2, eventHandler);
          }
        }
      }
      function setAttribute(node, name2, value) {
        if (isHydrating(node))
          return;
        if (value == null)
          node.removeAttribute(name2);
        else
          node.setAttribute(name2, value);
      }
      function setAttributeNS(node, namespace, name2, value) {
        if (isHydrating(node))
          return;
        if (value == null)
          node.removeAttributeNS(namespace, name2);
        else
          node.setAttributeNS(namespace, name2, value);
      }
      function setBoolAttribute(node, name2, value) {
        if (isHydrating(node))
          return;
        value ? node.setAttribute(name2, "") : node.removeAttribute(name2);
      }
      function className(node, value) {
        if (isHydrating(node))
          return;
        if (value == null)
          node.removeAttribute("class");
        else
          node.className = value;
      }
      function addEventListener(node, name2, handler, delegate) {
        if (delegate) {
          if (Array.isArray(handler)) {
            node[`$$${name2}`] = handler[0];
            node[`$$${name2}Data`] = handler[1];
          } else
            node[`$$${name2}`] = handler;
        } else if (Array.isArray(handler)) {
          const handlerFn = handler[0];
          node.addEventListener(name2, handler[0] = (e2) => handlerFn.call(node, handler[1], e2));
        } else
          node.addEventListener(name2, handler, typeof handler !== "function" && handler);
      }
      function classList$1(node, value, prev = {}) {
        const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
        let i, len;
        for (i = 0, len = prevKeys.length; i < len; i++) {
          const key = prevKeys[i];
          if (!key || key === "undefined" || value[key])
            continue;
          toggleClassKey(node, key, false);
          delete prev[key];
        }
        for (i = 0, len = classKeys.length; i < len; i++) {
          const key = classKeys[i], classValue = !!value[key];
          if (!key || key === "undefined" || prev[key] === classValue || !classValue)
            continue;
          toggleClassKey(node, key, true);
          prev[key] = classValue;
        }
        return prev;
      }
      function style(node, value, prev) {
        if (!value)
          return prev ? setAttribute(node, "style") : value;
        const nodeStyle = node.style;
        if (typeof value === "string")
          return nodeStyle.cssText = value;
        typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
        prev || (prev = {});
        value || (value = {});
        let v, s;
        for (s in prev) {
          value[s] == null && nodeStyle.removeProperty(s);
          delete prev[s];
        }
        for (s in value) {
          v = value[s];
          if (v !== prev[s]) {
            nodeStyle.setProperty(s, v);
            prev[s] = v;
          }
        }
        return prev;
      }
      function spread(node, props = {}, isSVG, skipChildren) {
        const prevProps = {};
        if (!skipChildren) {
          createRenderEffect(
            () => prevProps.children = insertExpression(node, props.children, prevProps.children)
          );
        }
        createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
        createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
        return prevProps;
      }
      function use(fn, element, arg) {
        return untrack(() => fn(element, arg));
      }
      function insert(parent, accessor, marker, initial) {
        if (marker !== void 0 && !initial)
          initial = [];
        if (typeof accessor !== "function")
          return insertExpression(parent, accessor, initial, marker);
        createRenderEffect((current2) => insertExpression(parent, accessor(), current2, marker), initial);
      }
      function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
        props || (props = {});
        for(let   prop in prevProps) {
          if (!(prop in props)) {
            if (prop === "children")
              continue;
            prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
          }
        }
        for(let   prop in props) {
          if (prop === "children") {
            continue;
          }
          const value = props[prop];
          prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);
        }
      }
      function getNextElement(template2) {
        let node, key, hydrating = isHydrating();
        if (!hydrating || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {
          return template2();
        }
        if (sharedConfig.completed)
          sharedConfig.completed.add(node);
        sharedConfig.registry.delete(key);
        return node;
      }
      function isHydrating(node) {
        return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
      }
      function toPropertyName(name2) {
        return name2.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
      }
      function toggleClassKey(node, key, value) {
        const classNames = key.trim().split(/\s+/);
        for (let i = 0, nameLen = classNames.length; i < nameLen; i++)
          node.classList.toggle(classNames[i], value);
      }
      function assignProp(node, prop, value, prev, isSVG, skipRef, props) {
        let isCE, isProp, isChildProp, propAlias, forceProp;
        if (prop === "style")
          return style(node, value, prev);
        if (prop === "classList")
          return classList$1(node, value, prev);
        if (value === prev)
          return prev;
        if (prop === "ref") {
          if (!skipRef)
            value(node);
        } else if (prop.slice(0, 3) === "on:") {
          const e2 = prop.slice(3);
          prev && node.removeEventListener(e2, prev, typeof prev !== "function" && prev);
          value && node.addEventListener(e2, value, typeof value !== "function" && value);
        } else if (prop.slice(0, 10) === "oncapture:") {
          const e2 = prop.slice(10);
          prev && node.removeEventListener(e2, prev, true);
          value && node.addEventListener(e2, value, true);
        } else if (prop.slice(0, 2) === "on") {
          const name2 = prop.slice(2).toLowerCase();
          const delegate = DelegatedEvents.has(name2);
          if (!delegate && prev) {
            const h2 = Array.isArray(prev) ? prev[0] : prev;
            node.removeEventListener(name2, h2);
          }
          if (delegate || value) {
            addEventListener(node, name2, value, delegate);
            delegate && delegateEvents([name2]);
          }
        } else if (prop.slice(0, 5) === "attr:") {
          setAttribute(node, prop.slice(5), value);
        } else if (prop.slice(0, 5) === "bool:") {
          setBoolAttribute(node, prop.slice(5), value);
        } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props)) {
          if (forceProp) {
            prop = prop.slice(5);
            isProp = true;
          } else if (isHydrating(node))
            return value;
          if (prop === "class" || prop === "className")
            className(node, value);
          else if (isCE && !isProp && !isChildProp)
            node[toPropertyName(prop)] = value;
          else
            node[propAlias || prop] = value;
        } else {
          const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
          if (ns)
            setAttributeNS(node, ns, prop, value);
          else
            setAttribute(node, Aliases[prop] || prop, value);
        }
        return value;
      }
      function eventHandler(e2) {
        if (sharedConfig.registry && sharedConfig.events) {
          if (sharedConfig.events.find(([el, ev]) => ev === e2))
            return;
        }
        let node = e2.target;
        const key = `$$${e2.type}`;
        const oriTarget = e2.target;
        const oriCurrentTarget = e2.currentTarget;
        const retarget = (value) => Object.defineProperty(e2, "target", {
          configurable: true,
          value
        });
        const handleNode = () => {
          const handler = node[key];
          if (handler && !node.disabled) {
            const data2 = node[`${key}Data`];
            data2 !== void 0 ? handler.call(node, data2, e2) : handler.call(node, e2);
            if (e2.cancelBubble)
              return;
          }
          node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e2.target) && retarget(node.host);
          return true;
        };
        const walkUpTree = () => {
          while (handleNode() && (node = node._$host || node.parentNode || node.host))
            ;
        };
        Object.defineProperty(e2, "currentTarget", {
          configurable: true,
          get() {
            return node || document;
          }
        });
        if (sharedConfig.registry && !sharedConfig.done)
          sharedConfig.done = _$HY.done = true;
        if (e2.composedPath) {
          const path2 = e2.composedPath();
          retarget(path2[0]);
          for (let i = 0; i < path2.length - 2; i++) {
            node = path2[i];
            if (!handleNode())
              break;
            if (node._$host) {
              node = node._$host;
              walkUpTree();
              break;
            }
            if (node.parentNode === oriCurrentTarget) {
              break;
            }
          }
        } else
          walkUpTree();
        retarget(oriTarget);
      }
      function insertExpression(parent, value, current2, marker, unwrapArray) {
        const hydrating = isHydrating(parent);
        if (hydrating) {
          !current2 && (current2 = [...parent.childNodes]);
          let cleaned = [];
          for (let i = 0; i < current2.length; i++) {
            const node = current2[i];
            if (node.nodeType === 8 && node.data.slice(0, 2) === "!$")
              node.remove();
            else
              cleaned.push(node);
          }
          current2 = cleaned;
        }
        while (typeof current2 === "function")
          current2 = current2();
        if (value === current2)
          return current2;
        const t2 = typeof value, multi = marker !== void 0;
        parent = multi && current2[0] && current2[0].parentNode || parent;
        if (t2 === "string" || t2 === "number") {
          if (hydrating)
            return current2;
          if (t2 === "number") {
            value = value.toString();
            if (value === current2)
              return current2;
          }
          if (multi) {
            let node = current2[0];
            if (node && node.nodeType === 3) {
              node.data !== value && (node.data = value);
            } else
              node = document.createTextNode(value);
            current2 = cleanChildren(parent, current2, marker, node);
          } else {
            if (current2 !== "" && typeof current2 === "string") {
              current2 = parent.firstChild.data = value;
            } else
              current2 = parent.textContent = value;
          }
        } else if (value == null || t2 === "boolean") {
          if (hydrating)
            return current2;
          current2 = cleanChildren(parent, current2, marker);
        } else if (t2 === "function") {
          createRenderEffect(() => {
            let v = value();
            while (typeof v === "function")
              v = v();
            current2 = insertExpression(parent, v, current2, marker);
          });
          return () => current2;
        } else if (Array.isArray(value)) {
          const array = [];
          const currentArray = current2 && Array.isArray(current2);
          if (normalizeIncomingArray(array, value, current2, unwrapArray)) {
            createRenderEffect(() => current2 = insertExpression(parent, array, current2, marker, true));
            return () => current2;
          }
          if (hydrating) {
            if (!array.length)
              return current2;
            if (marker === void 0)
              return current2 = [...parent.childNodes];
            let node = array[0];
            if (node.parentNode !== parent)
              return current2;
            const nodes = [node];
            while ((node = node.nextSibling) !== marker)
              nodes.push(node);
            return current2 = nodes;
          }
          if (array.length === 0) {
            current2 = cleanChildren(parent, current2, marker);
            if (multi)
              return current2;
          } else if (currentArray) {
            if (current2.length === 0) {
              appendNodes(parent, array, marker);
            } else
              reconcileArrays(parent, current2, array);
          } else {
            current2 && cleanChildren(parent);
            appendNodes(parent, array);
          }
          current2 = array;
        } else if (value.nodeType) {
          if (hydrating && value.parentNode)
            return current2 = multi ? [value] : value;
          if (Array.isArray(current2)) {
            if (multi)
              return current2 = cleanChildren(parent, current2, marker, value);
            cleanChildren(parent, current2, null, value);
          } else if (current2 == null || current2 === "" || !parent.firstChild) {
            parent.appendChild(value);
          } else
            parent.replaceChild(value, parent.firstChild);
          current2 = value;
        } else
          ;
        return current2;
      }
      function normalizeIncomingArray(normalized, array, current2, unwrap2) {
        let dynamic = false;
        for (let i = 0, len = array.length; i < len; i++) {
          let item2 = array[i], prev = current2 && current2[normalized.length], t2;
          if (item2 == null || item2 === true || item2 === false)
            ;
          else if ((t2 = typeof item2) === "object" && item2.nodeType) {
            normalized.push(item2);
          } else if (Array.isArray(item2)) {
            dynamic = normalizeIncomingArray(normalized, item2, prev) || dynamic;
          } else if (t2 === "function") {
            if (unwrap2) {
              while (typeof item2 === "function")
                item2 = item2();
              dynamic = normalizeIncomingArray(
                normalized,
                Array.isArray(item2) ? item2 : [item2],
                Array.isArray(prev) ? prev : [prev]
              ) || dynamic;
            } else {
              normalized.push(item2);
              dynamic = true;
            }
          } else {
            const value = String(item2);
            if (prev && prev.nodeType === 3 && prev.data === value)
              normalized.push(prev);
            else
              normalized.push(document.createTextNode(value));
          }
        }
        return dynamic;
      }
      function appendNodes(parent, array, marker = null) {
        for (let i = 0, len = array.length; i < len; i++)
          parent.insertBefore(array[i], marker);
      }
      function cleanChildren(parent, current2, marker, replacement2) {
        if (marker === void 0)
          return parent.textContent = "";
        const node = replacement2 || document.createTextNode("");
        if (current2.length) {
          let inserted = false;
          for (let i = current2.length - 1; i >= 0; i--) {
            const el = current2[i];
            if (node !== el) {
              const isParent = el.parentNode === parent;
              if (!inserted && !i)
                isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
              else
                isParent && el.remove();
            } else
              inserted = true;
          }
        } else
          parent.insertBefore(node, marker);
        return [node];
      }
      function getHydrationKey() {
        return sharedConfig.getNextContextId();
      }
      const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      function createElement$1(tagName, isSVG = false) {
        return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
      }
      function Portal(props) {
        const { useShadow } = props, marker = document.createTextNode(""), mount = () => props.mount || document.body, owner = getOwner();
        let content2;
        let hydrating = !!sharedConfig.context;
        createEffect(
          () => {
            if (hydrating)
              getOwner().user = hydrating = false;
            content2 || (content2 = runWithOwner(owner, () => createMemo(() => props.children)));
            const el = mount();
            if (el instanceof HTMLHeadElement) {
              const [clean, setClean] = createSignal(false);
              const cleanup2 = () => setClean(true);
              createRoot((dispose2) => insert(el, () => !clean() ? content2() : dispose2(), null));
              onCleanup(cleanup2);
            } else {
              const container2 = createElement$1(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container2.attachShadow ? container2.attachShadow({
                mode: "open"
              }) : container2;
              Object.defineProperty(container2, "_$host", {
                get() {
                  return marker.parentNode;
                },
                configurable: true
              });
              insert(renderRoot, content2);
              el.appendChild(container2);
              props.ref && props.ref(container2);
              onCleanup(() => el.removeChild(container2));
            }
          },
          void 0,
          {
            render: !hydrating
          }
        );
        return marker;
      }
      function createDynamic(component, props) {
        const cached2 = createMemo(component);
        return createMemo(() => {
          const component2 = cached2();
          switch (typeof component2) {
            case "function":
              return untrack(() => component2(props));
            case "string":
              const isSvg = SVGElements.has(component2);
              const el = sharedConfig.context ? getNextElement() : createElement$1(component2, isSvg);
              spread(el, props, isSvg);
              return el;
          }
        });
      }
      function Dynamic(props) {
        const [, others] = splitProps(props, ["component"]);
        return createDynamic(() => props.component, others);
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var check$1 = function(it) {
        return it && it.Math === Math && it;
      };
      var globalThis_1 = (
        // eslint-disable-next-line es/no-global-this -- safe
        check$1(typeof globalThis == "object" && globalThis) || check$1(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
        check$1(typeof self == "object" && self) || check$1(typeof commonjsGlobal == "object" && commonjsGlobal) || check$1(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
        /* @__PURE__ */ function() {
          return this;
        }() || Function("return this")()
      );
      var objectGetOwnPropertyDescriptor = {};
      var fails$k = function(exec2) {
        try {
          return !!exec2();
        } catch (error) {
          return true;
        }
      };
      var fails$j = fails$k;
      var descriptors = !fails$j(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
      var fails$i = fails$k;
      var functionBindNative = !fails$i(function() {
        var test2 = function() {
        }.bind();
        return typeof test2 != "function" || test2.hasOwnProperty("prototype");
      });
      var NATIVE_BIND$3 = functionBindNative;
      var call$e = Function.prototype.call;
      var functionCall = NATIVE_BIND$3 ? call$e.bind(call$e) : function() {
        return call$e.apply(call$e, arguments);
      };
      var objectPropertyIsEnumerable = {};
      var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
      objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor2 = getOwnPropertyDescriptor$3(this, V);
        return !!descriptor2 && descriptor2.enumerable;
      } : $propertyIsEnumerable$1;
      var createPropertyDescriptor$5 = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
      var NATIVE_BIND$2 = functionBindNative;
      var FunctionPrototype$3 = Function.prototype;
      var call$d = FunctionPrototype$3.call;
      var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$3.bind.bind(call$d, call$d);
      var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function(fn) {
        return function() {
          return call$d.apply(fn, arguments);
        };
      };
      var uncurryThis$n = functionUncurryThis;
      var toString$6 = uncurryThis$n({}.toString);
      var stringSlice$2 = uncurryThis$n("".slice);
      var classofRaw$2 = function(it) {
        return stringSlice$2(toString$6(it), 8, -1);
      };
      var uncurryThis$m = functionUncurryThis;
      var fails$h = fails$k;
      var classof$9 = classofRaw$2;
      var $Object$4 = Object;
      var split = uncurryThis$m("".split);
      var indexedObject = fails$h(function() {
        return !$Object$4("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classof$9(it) === "String" ? split(it, "") : $Object$4(it);
      } : $Object$4;
      var isNullOrUndefined$5 = function(it) {
        return it === null || it === void 0;
      };
      var isNullOrUndefined$4 = isNullOrUndefined$5;
      var $TypeError$b = TypeError;
      var requireObjectCoercible$3 = function(it) {
        if (isNullOrUndefined$4(it))
          throw new $TypeError$b("Can't call method on " + it);
        return it;
      };
      var IndexedObject$1 = indexedObject;
      var requireObjectCoercible$2 = requireObjectCoercible$3;
      var toIndexedObject$7 = function(it) {
        return IndexedObject$1(requireObjectCoercible$2(it));
      };
      var documentAll = typeof document == "object" && document.all;
      var isCallable$k = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
        return typeof argument == "function" || argument === documentAll;
      } : function(argument) {
        return typeof argument == "function";
      };
      var isCallable$j = isCallable$k;
      var isObject$g = function(it) {
        return typeof it == "object" ? it !== null : isCallable$j(it);
      };
      var globalThis$l = globalThis_1;
      var isCallable$i = isCallable$k;
      var aFunction = function(argument) {
        return isCallable$i(argument) ? argument : void 0;
      };
      var getBuiltIn$a = function(namespace, method) {
        return arguments.length < 2 ? aFunction(globalThis$l[namespace]) : globalThis$l[namespace] && globalThis$l[namespace][method];
      };
      var uncurryThis$l = functionUncurryThis;
      var objectIsPrototypeOf = uncurryThis$l({}.isPrototypeOf);
      var globalThis$k = globalThis_1;
      var navigator$1 = globalThis$k.navigator;
      var userAgent$1 = navigator$1 && navigator$1.userAgent;
      var environmentUserAgent = userAgent$1 ? String(userAgent$1) : "";
      var globalThis$j = globalThis_1;
      var userAgent = environmentUserAgent;
      var process = globalThis$j.process;
      var Deno = globalThis$j.Deno;
      var versions = process && process.versions || Deno && Deno.version;
      var v8 = versions && versions.v8;
      var match, version;
      if (v8) {
        match = v8.split(".");
        version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match)
            version = +match[1];
        }
      }
      var environmentV8Version = version;
      var V8_VERSION$2 = environmentV8Version;
      var fails$g = fails$k;
      var globalThis$i = globalThis_1;
      var $String$6 = globalThis$i.String;
      var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$g(function() {
        var symbol = Symbol("symbol detection");
        return !$String$6(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
      });
      var NATIVE_SYMBOL$6 = symbolConstructorDetection;
      var useSymbolAsUid = NATIVE_SYMBOL$6 && !Symbol.sham && typeof Symbol.iterator == "symbol";
      var getBuiltIn$9 = getBuiltIn$a;
      var isCallable$h = isCallable$k;
      var isPrototypeOf$4 = objectIsPrototypeOf;
      var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
      var $Object$3 = Object;
      var isSymbol$5 = USE_SYMBOL_AS_UID$1 ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        var $Symbol2 = getBuiltIn$9("Symbol");
        return isCallable$h($Symbol2) && isPrototypeOf$4($Symbol2.prototype, $Object$3(it));
      };
      var $String$5 = String;
      var tryToString$4 = function(argument) {
        try {
          return $String$5(argument);
        } catch (error) {
          return "Object";
        }
      };
      var isCallable$g = isCallable$k;
      var tryToString$3 = tryToString$4;
      var $TypeError$a = TypeError;
      var aCallable$6 = function(argument) {
        if (isCallable$g(argument))
          return argument;
        throw new $TypeError$a(tryToString$3(argument) + " is not a function");
      };
      var aCallable$5 = aCallable$6;
      var isNullOrUndefined$3 = isNullOrUndefined$5;
      var getMethod$4 = function(V, P) {
        var func = V[P];
        return isNullOrUndefined$3(func) ? void 0 : aCallable$5(func);
      };
      var call$c = functionCall;
      var isCallable$f = isCallable$k;
      var isObject$f = isObject$g;
      var $TypeError$9 = TypeError;
      var ordinaryToPrimitive$1 = function(input, pref) {
        var fn, val;
        if (pref === "string" && isCallable$f(fn = input.toString) && !isObject$f(val = call$c(fn, input)))
          return val;
        if (isCallable$f(fn = input.valueOf) && !isObject$f(val = call$c(fn, input)))
          return val;
        if (pref !== "string" && isCallable$f(fn = input.toString) && !isObject$f(val = call$c(fn, input)))
          return val;
        throw new $TypeError$9("Can't convert object to primitive value");
      };
      var sharedStore = { exports: {} };
      var globalThis$h = globalThis_1;
      var defineProperty$b = Object.defineProperty;
      var defineGlobalProperty$3 = function(key, value) {
        try {
          defineProperty$b(globalThis$h, key, { value, configurable: true, writable: true });
        } catch (error) {
          globalThis$h[key] = value;
        }
        return value;
      };
      var globalThis$g = globalThis_1;
      var defineGlobalProperty$2 = defineGlobalProperty$3;
      var SHARED = "__core-js_shared__";
      var store$3 = sharedStore.exports = globalThis$g[SHARED] || defineGlobalProperty$2(SHARED, {});
      (store$3.versions || (store$3.versions = [])).push({
        version: "3.41.0",
        mode: "global",
        copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
      var sharedStoreExports = sharedStore.exports;
      var store$2 = sharedStoreExports;
      var shared$6 = function(key, value) {
        return store$2[key] || (store$2[key] = value || {});
      };
      var requireObjectCoercible$1 = requireObjectCoercible$3;
      var $Object$2 = Object;
      var toObject$8 = function(argument) {
        return $Object$2(requireObjectCoercible$1(argument));
      };
      var uncurryThis$k = functionUncurryThis;
      var toObject$7 = toObject$8;
      var hasOwnProperty$4 = uncurryThis$k({}.hasOwnProperty);
      var hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
        return hasOwnProperty$4(toObject$7(it), key);
      };
      var uncurryThis$j = functionUncurryThis;
      var id$1 = 0;
      var postfix = Math.random();
      var toString$5 = uncurryThis$j(1 .toString);
      var uid$4 = function(key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$5(++id$1 + postfix, 36);
      };
      var globalThis$f = globalThis_1;
      var shared$5 = shared$6;
      var hasOwn$e = hasOwnProperty_1;
      var uid$3 = uid$4;
      var NATIVE_SYMBOL$5 = symbolConstructorDetection;
      var USE_SYMBOL_AS_UID = useSymbolAsUid;
      var Symbol$4 = globalThis$f.Symbol;
      var WellKnownSymbolsStore$1 = shared$5("wks");
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$4["for"] || Symbol$4 : Symbol$4 && Symbol$4.withoutSetter || uid$3;
      var wellKnownSymbol$j = function(name2) {
        if (!hasOwn$e(WellKnownSymbolsStore$1, name2)) {
          WellKnownSymbolsStore$1[name2] = NATIVE_SYMBOL$5 && hasOwn$e(Symbol$4, name2) ? Symbol$4[name2] : createWellKnownSymbol("Symbol." + name2);
        }
        return WellKnownSymbolsStore$1[name2];
      };
      var call$b = functionCall;
      var isObject$e = isObject$g;
      var isSymbol$4 = isSymbol$5;
      var getMethod$3 = getMethod$4;
      var ordinaryToPrimitive = ordinaryToPrimitive$1;
      var wellKnownSymbol$i = wellKnownSymbol$j;
      var $TypeError$8 = TypeError;
      var TO_PRIMITIVE = wellKnownSymbol$i("toPrimitive");
      var toPrimitive$1 = function(input, pref) {
        if (!isObject$e(input) || isSymbol$4(input))
          return input;
        var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0)
            pref = "default";
          result = call$b(exoticToPrim, input, pref);
          if (!isObject$e(result) || isSymbol$4(result))
            return result;
          throw new $TypeError$8("Can't convert object to primitive value");
        }
        if (pref === void 0)
          pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
      var toPrimitive = toPrimitive$1;
      var isSymbol$3 = isSymbol$5;
      var toPropertyKey$3 = function(argument) {
        var key = toPrimitive(argument, "string");
        return isSymbol$3(key) ? key : key + "";
      };
      var globalThis$e = globalThis_1;
      var isObject$d = isObject$g;
      var document$2 = globalThis$e.document;
      var EXISTS$1 = isObject$d(document$2) && isObject$d(document$2.createElement);
      var documentCreateElement$2 = function(it) {
        return EXISTS$1 ? document$2.createElement(it) : {};
      };
      var DESCRIPTORS$d = descriptors;
      var fails$f = fails$k;
      var createElement = documentCreateElement$2;
      var ie8DomDefine = !DESCRIPTORS$d && !fails$f(function() {
        return Object.defineProperty(createElement("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
      var DESCRIPTORS$c = descriptors;
      var call$a = functionCall;
      var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
      var createPropertyDescriptor$4 = createPropertyDescriptor$5;
      var toIndexedObject$6 = toIndexedObject$7;
      var toPropertyKey$2 = toPropertyKey$3;
      var hasOwn$d = hasOwnProperty_1;
      var IE8_DOM_DEFINE$1 = ie8DomDefine;
      var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
      objectGetOwnPropertyDescriptor.f = DESCRIPTORS$c ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor2(O, P) {
        O = toIndexedObject$6(O);
        P = toPropertyKey$2(P);
        if (IE8_DOM_DEFINE$1)
          try {
            return $getOwnPropertyDescriptor$2(O, P);
          } catch (error) {
          }
        if (hasOwn$d(O, P))
          return createPropertyDescriptor$4(!call$a(propertyIsEnumerableModule$1.f, O, P), O[P]);
      };
      var objectDefineProperty = {};
      var DESCRIPTORS$b = descriptors;
      var fails$e = fails$k;
      var v8PrototypeDefineBug = DESCRIPTORS$b && fails$e(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype !== 42;
      });
      var isObject$c = isObject$g;
      var $String$4 = String;
      var $TypeError$7 = TypeError;
      var anObject$9 = function(argument) {
        if (isObject$c(argument))
          return argument;
        throw new $TypeError$7($String$4(argument) + " is not an object");
      };
      var DESCRIPTORS$a = descriptors;
      var IE8_DOM_DEFINE = ie8DomDefine;
      var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
      var anObject$8 = anObject$9;
      var toPropertyKey$1 = toPropertyKey$3;
      var $TypeError$6 = TypeError;
      var $defineProperty$1 = Object.defineProperty;
      var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE$1 = "configurable";
      var WRITABLE = "writable";
      objectDefineProperty.f = DESCRIPTORS$a ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty2(O, P, Attributes) {
        anObject$8(O);
        P = toPropertyKey$1(P);
        anObject$8(Attributes);
        if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
          var current2 = $getOwnPropertyDescriptor$1(O, P);
          if (current2 && current2[WRITABLE]) {
            O[P] = Attributes.value;
            Attributes = {
              configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current2[CONFIGURABLE$1],
              enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current2[ENUMERABLE],
              writable: false
            };
          }
        }
        return $defineProperty$1(O, P, Attributes);
      } : $defineProperty$1 : function defineProperty2(O, P, Attributes) {
        anObject$8(O);
        P = toPropertyKey$1(P);
        anObject$8(Attributes);
        if (IE8_DOM_DEFINE)
          try {
            return $defineProperty$1(O, P, Attributes);
          } catch (error) {
          }
        if ("get" in Attributes || "set" in Attributes)
          throw new $TypeError$6("Accessors not supported");
        if ("value" in Attributes)
          O[P] = Attributes.value;
        return O;
      };
      var DESCRIPTORS$9 = descriptors;
      var definePropertyModule$5 = objectDefineProperty;
      var createPropertyDescriptor$3 = createPropertyDescriptor$5;
      var createNonEnumerableProperty$4 = DESCRIPTORS$9 ? function(object, key, value) {
        return definePropertyModule$5.f(object, key, createPropertyDescriptor$3(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
      var makeBuiltIn$3 = { exports: {} };
      var DESCRIPTORS$8 = descriptors;
      var hasOwn$c = hasOwnProperty_1;
      var FunctionPrototype$2 = Function.prototype;
      var getDescriptor = DESCRIPTORS$8 && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn$c(FunctionPrototype$2, "name");
      var PROPER = EXISTS && function something() {
      }.name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS$8 || DESCRIPTORS$8 && getDescriptor(FunctionPrototype$2, "name").configurable);
      var functionName = {
        PROPER,
        CONFIGURABLE
      };
      var uncurryThis$i = functionUncurryThis;
      var isCallable$e = isCallable$k;
      var store$1 = sharedStoreExports;
      var functionToString = uncurryThis$i(Function.toString);
      if (!isCallable$e(store$1.inspectSource)) {
        store$1.inspectSource = function(it) {
          return functionToString(it);
        };
      }
      var inspectSource$2 = store$1.inspectSource;
      var globalThis$d = globalThis_1;
      var isCallable$d = isCallable$k;
      var WeakMap$2 = globalThis$d.WeakMap;
      var weakMapBasicDetection = isCallable$d(WeakMap$2) && /native code/.test(String(WeakMap$2));
      var shared$4 = shared$6;
      var uid$2 = uid$4;
      var keys$1 = shared$4("keys");
      var sharedKey$4 = function(key) {
        return keys$1[key] || (keys$1[key] = uid$2(key));
      };
      var hiddenKeys$6 = {};
      var NATIVE_WEAK_MAP = weakMapBasicDetection;
      var globalThis$c = globalThis_1;
      var isObject$b = isObject$g;
      var createNonEnumerableProperty$3 = createNonEnumerableProperty$4;
      var hasOwn$b = hasOwnProperty_1;
      var shared$3 = sharedStoreExports;
      var sharedKey$3 = sharedKey$4;
      var hiddenKeys$5 = hiddenKeys$6;
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError$2 = globalThis$c.TypeError;
      var WeakMap$1 = globalThis$c.WeakMap;
      var set, get, has$3;
      var enforce = function(it) {
        return has$3(it) ? get(it) : set(it, {});
      };
      var getterFor = function(TYPE) {
        return function(it) {
          var state;
          if (!isObject$b(it) || (state = get(it)).type !== TYPE) {
            throw new TypeError$2("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (NATIVE_WEAK_MAP || shared$3.state) {
        var store = shared$3.state || (shared$3.state = new WeakMap$1());
        store.get = store.get;
        store.has = store.has;
        store.set = store.set;
        set = function(it, metadata) {
          if (store.has(it))
            throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          store.set(it, metadata);
          return metadata;
        };
        get = function(it) {
          return store.get(it) || {};
        };
        has$3 = function(it) {
          return store.has(it);
        };
      } else {
        var STATE = sharedKey$3("state");
        hiddenKeys$5[STATE] = true;
        set = function(it, metadata) {
          if (hasOwn$b(it, STATE))
            throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          createNonEnumerableProperty$3(it, STATE, metadata);
          return metadata;
        };
        get = function(it) {
          return hasOwn$b(it, STATE) ? it[STATE] : {};
        };
        has$3 = function(it) {
          return hasOwn$b(it, STATE);
        };
      }
      var internalState = {
        set,
        get,
        has: has$3,
        enforce,
        getterFor
      };
      var uncurryThis$h = functionUncurryThis;
      var fails$d = fails$k;
      var isCallable$c = isCallable$k;
      var hasOwn$a = hasOwnProperty_1;
      var DESCRIPTORS$7 = descriptors;
      var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
      var inspectSource$1 = inspectSource$2;
      var InternalStateModule$3 = internalState;
      var enforceInternalState = InternalStateModule$3.enforce;
      var getInternalState$2 = InternalStateModule$3.get;
      var $String$3 = String;
      var defineProperty$a = Object.defineProperty;
      var stringSlice$1 = uncurryThis$h("".slice);
      var replace$2 = uncurryThis$h("".replace);
      var join = uncurryThis$h([].join);
      var CONFIGURABLE_LENGTH = DESCRIPTORS$7 && !fails$d(function() {
        return defineProperty$a(function() {
        }, "length", { value: 8 }).length !== 8;
      });
      var TEMPLATE = String(String).split("String");
      var makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name2, options2) {
        if (stringSlice$1($String$3(name2), 0, 7) === "Symbol(") {
          name2 = "[" + replace$2($String$3(name2), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
        }
        if (options2 && options2.getter)
          name2 = "get " + name2;
        if (options2 && options2.setter)
          name2 = "set " + name2;
        if (!hasOwn$a(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name2) {
          if (DESCRIPTORS$7)
            defineProperty$a(value, "name", { value: name2, configurable: true });
          else
            value.name = name2;
        }
        if (CONFIGURABLE_LENGTH && options2 && hasOwn$a(options2, "arity") && value.length !== options2.arity) {
          defineProperty$a(value, "length", { value: options2.arity });
        }
        try {
          if (options2 && hasOwn$a(options2, "constructor") && options2.constructor) {
            if (DESCRIPTORS$7)
              defineProperty$a(value, "prototype", { writable: false });
          } else if (value.prototype)
            value.prototype = void 0;
        } catch (error) {
        }
        var state = enforceInternalState(value);
        if (!hasOwn$a(state, "source")) {
          state.source = join(TEMPLATE, typeof name2 == "string" ? name2 : "");
        }
        return value;
      };
      Function.prototype.toString = makeBuiltIn$2(function toString2() {
        return isCallable$c(this) && getInternalState$2(this).source || inspectSource$1(this);
      }, "toString");
      var makeBuiltInExports = makeBuiltIn$3.exports;
      var isCallable$b = isCallable$k;
      var definePropertyModule$4 = objectDefineProperty;
      var makeBuiltIn$1 = makeBuiltInExports;
      var defineGlobalProperty$1 = defineGlobalProperty$3;
      var defineBuiltIn$8 = function(O, key, value, options2) {
        if (!options2)
          options2 = {};
        var simple = options2.enumerable;
        var name2 = options2.name !== void 0 ? options2.name : key;
        if (isCallable$b(value))
          makeBuiltIn$1(value, name2, options2);
        if (options2.global) {
          if (simple)
            O[key] = value;
          else
            defineGlobalProperty$1(key, value);
        } else {
          try {
            if (!options2.unsafe)
              delete O[key];
            else if (O[key])
              simple = true;
          } catch (error) {
          }
          if (simple)
            O[key] = value;
          else
            definePropertyModule$4.f(O, key, {
              value,
              enumerable: false,
              configurable: !options2.nonConfigurable,
              writable: !options2.nonWritable
            });
        }
        return O;
      };
      var objectGetOwnPropertyNames = {};
      var ceil = Math.ceil;
      var floor = Math.floor;
      var mathTrunc = Math.trunc || function trunc2(x) {
        var n2 = +x;
        return (n2 > 0 ? floor : ceil)(n2);
      };
      var trunc = mathTrunc;
      var toIntegerOrInfinity$5 = function(argument) {
        var number = +argument;
        return number !== number || number === 0 ? 0 : trunc(number);
      };
      var toIntegerOrInfinity$4 = toIntegerOrInfinity$5;
      var max$1 = Math.max;
      var min$1 = Math.min;
      var toAbsoluteIndex$1 = function(index, length) {
        var integer = toIntegerOrInfinity$4(index);
        return integer < 0 ? max$1(integer + length, 0) : min$1(integer, length);
      };
      var toIntegerOrInfinity$3 = toIntegerOrInfinity$5;
      var min = Math.min;
      var toLength$1 = function(argument) {
        var len = toIntegerOrInfinity$3(argument);
        return len > 0 ? min(len, 9007199254740991) : 0;
      };
      var toLength = toLength$1;
      var lengthOfArrayLike$8 = function(obj) {
        return toLength(obj.length);
      };
      var toIndexedObject$5 = toIndexedObject$7;
      var toAbsoluteIndex = toAbsoluteIndex$1;
      var lengthOfArrayLike$7 = lengthOfArrayLike$8;
      var createMethod$1 = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIndexedObject$5($this);
          var length = lengthOfArrayLike$7(O);
          if (length === 0)
            return !IS_INCLUDES && -1;
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el !== el)
            while (length > index) {
              value = O[index++];
              if (value !== value)
                return true;
            }
          else
            for (; length > index; index++) {
              if ((IS_INCLUDES || index in O) && O[index] === el)
                return IS_INCLUDES || index || 0;
            }
          return !IS_INCLUDES && -1;
        };
      };
      var arrayIncludes$1 = {
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod$1(false)
      };
      var uncurryThis$g = functionUncurryThis;
      var hasOwn$9 = hasOwnProperty_1;
      var toIndexedObject$4 = toIndexedObject$7;
      var indexOf = arrayIncludes$1.indexOf;
      var hiddenKeys$4 = hiddenKeys$6;
      var push$3 = uncurryThis$g([].push);
      var objectKeysInternal = function(object, names) {
        var O = toIndexedObject$4(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O)
          !hasOwn$9(hiddenKeys$4, key) && hasOwn$9(O, key) && push$3(result, key);
        while (names.length > i)
          if (hasOwn$9(O, key = names[i++])) {
            ~indexOf(result, key) || push$3(result, key);
          }
        return result;
      };
      var enumBugKeys$3 = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
      var internalObjectKeys$1 = objectKeysInternal;
      var enumBugKeys$2 = enumBugKeys$3;
      var hiddenKeys$3 = enumBugKeys$2.concat("length", "prototype");
      objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return internalObjectKeys$1(O, hiddenKeys$3);
      };
      var objectGetOwnPropertySymbols = {};
      objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
      var getBuiltIn$8 = getBuiltIn$a;
      var uncurryThis$f = functionUncurryThis;
      var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
      var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
      var anObject$7 = anObject$9;
      var concat = uncurryThis$f([].concat);
      var ownKeys$2 = getBuiltIn$8("Reflect", "ownKeys") || function ownKeys2(it) {
        var keys2 = getOwnPropertyNamesModule$2.f(anObject$7(it));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule$2.f;
        return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
      };
      var hasOwn$8 = hasOwnProperty_1;
      var ownKeys$1 = ownKeys$2;
      var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
      var definePropertyModule$3 = objectDefineProperty;
      var copyConstructorProperties$2 = function(target, source, exceptions) {
        var keys2 = ownKeys$1(source);
        var defineProperty2 = definePropertyModule$3.f;
        var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule$1.f;
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          if (!hasOwn$8(target, key) && !(exceptions && hasOwn$8(exceptions, key))) {
            defineProperty2(target, key, getOwnPropertyDescriptor2(source, key));
          }
        }
      };
      var fails$c = fails$k;
      var isCallable$a = isCallable$k;
      var replacement = /#|\.prototype\./;
      var isForced$2 = function(feature, detection) {
        var value = data[normalize(feature)];
        return value === POLYFILL ? true : value === NATIVE ? false : isCallable$a(detection) ? fails$c(detection) : !!detection;
      };
      var normalize = isForced$2.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data = isForced$2.data = {};
      var NATIVE = isForced$2.NATIVE = "N";
      var POLYFILL = isForced$2.POLYFILL = "P";
      var isForced_1 = isForced$2;
      var globalThis$b = globalThis_1;
      var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
      var createNonEnumerableProperty$2 = createNonEnumerableProperty$4;
      var defineBuiltIn$7 = defineBuiltIn$8;
      var defineGlobalProperty = defineGlobalProperty$3;
      var copyConstructorProperties$1 = copyConstructorProperties$2;
      var isForced$1 = isForced_1;
      var _export = function(options2, source) {
        var TARGET = options2.target;
        var GLOBAL = options2.global;
        var STATIC = options2.stat;
        var FORCED2, target, key, targetProperty, sourceProperty, descriptor2;
        if (GLOBAL) {
          target = globalThis$b;
        } else if (STATIC) {
          target = globalThis$b[TARGET] || defineGlobalProperty(TARGET, {});
        } else {
          target = globalThis$b[TARGET] && globalThis$b[TARGET].prototype;
        }
        if (target)
          for (key in source) {
            sourceProperty = source[key];
            if (options2.dontCallGetSet) {
              descriptor2 = getOwnPropertyDescriptor$2(target, key);
              targetProperty = descriptor2 && descriptor2.value;
            } else
              targetProperty = target[key];
            FORCED2 = isForced$1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
            if (!FORCED2 && targetProperty !== void 0) {
              if (typeof sourceProperty == typeof targetProperty)
                continue;
              copyConstructorProperties$1(sourceProperty, targetProperty);
            }
            if (options2.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty$2(sourceProperty, "sham", true);
            }
            defineBuiltIn$7(target, key, sourceProperty, options2);
          }
      };
      var classof$8 = classofRaw$2;
      var isArray$4 = Array.isArray || function isArray2(argument) {
        return classof$8(argument) === "Array";
      };
      var $TypeError$5 = TypeError;
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var doesNotExceedSafeInteger$2 = function(it) {
        if (it > MAX_SAFE_INTEGER$1)
          throw $TypeError$5("Maximum allowed index exceeded");
        return it;
      };
      var classofRaw$1 = classofRaw$2;
      var uncurryThis$e = functionUncurryThis;
      var functionUncurryThisClause = function(fn) {
        if (classofRaw$1(fn) === "Function")
          return uncurryThis$e(fn);
      };
      var uncurryThis$d = functionUncurryThisClause;
      var aCallable$4 = aCallable$6;
      var NATIVE_BIND$1 = functionBindNative;
      var bind$4 = uncurryThis$d(uncurryThis$d.bind);
      var functionBindContext = function(fn, that) {
        aCallable$4(fn);
        return that === void 0 ? fn : NATIVE_BIND$1 ? bind$4(fn, that) : function() {
          return fn.apply(that, arguments);
        };
      };
      var isArray$3 = isArray$4;
      var lengthOfArrayLike$6 = lengthOfArrayLike$8;
      var doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$2;
      var bind$3 = functionBindContext;
      var flattenIntoArray$2 = function(target, original, source, sourceLen, start2, depth, mapper, thisArg) {
        var targetIndex = start2;
        var sourceIndex = 0;
        var mapFn = mapper ? bind$3(mapper, thisArg) : false;
        var element, elementLen;
        while (sourceIndex < sourceLen) {
          if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray$3(element)) {
              elementLen = lengthOfArrayLike$6(element);
              targetIndex = flattenIntoArray$2(target, original, element, elementLen, targetIndex, depth - 1) - 1;
            } else {
              doesNotExceedSafeInteger$1(targetIndex + 1);
              target[targetIndex] = element;
            }
            targetIndex++;
          }
          sourceIndex++;
        }
        return targetIndex;
      };
      var flattenIntoArray_1 = flattenIntoArray$2;
      var wellKnownSymbol$h = wellKnownSymbol$j;
      var TO_STRING_TAG$2 = wellKnownSymbol$h("toStringTag");
      var test = {};
      test[TO_STRING_TAG$2] = "z";
      var toStringTagSupport = String(test) === "[object z]";
      var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
      var isCallable$9 = isCallable$k;
      var classofRaw = classofRaw$2;
      var wellKnownSymbol$g = wellKnownSymbol$j;
      var TO_STRING_TAG$1 = wellKnownSymbol$g("toStringTag");
      var $Object$1 = Object;
      var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
        return arguments;
      }()) === "Arguments";
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (error) {
        }
      };
      var classof$7 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function(it) {
        var O, tag, result;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable$9(O.callee) ? "Arguments" : result;
      };
      var uncurryThis$c = functionUncurryThis;
      var fails$b = fails$k;
      var isCallable$8 = isCallable$k;
      var classof$6 = classof$7;
      var getBuiltIn$7 = getBuiltIn$a;
      var inspectSource = inspectSource$2;
      var noop$1 = function() {
      };
      var construct = getBuiltIn$7("Reflect", "construct");
      var constructorRegExp = /^\s*(?:class|function)\b/;
      var exec$1 = uncurryThis$c(constructorRegExp.exec);
      var INCORRECT_TO_STRING = !constructorRegExp.test(noop$1);
      var isConstructorModern = function isConstructor2(argument) {
        if (!isCallable$8(argument))
          return false;
        try {
          construct(noop$1, [], argument);
          return true;
        } catch (error) {
          return false;
        }
      };
      var isConstructorLegacy = function isConstructor2(argument) {
        if (!isCallable$8(argument))
          return false;
        switch (classof$6(argument)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return INCORRECT_TO_STRING || !!exec$1(constructorRegExp, inspectSource(argument));
        } catch (error) {
          return true;
        }
      };
      isConstructorLegacy.sham = true;
      var isConstructor$1 = !construct || fails$b(function() {
        var called2;
        return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
          called2 = true;
        }) || called2;
      }) ? isConstructorLegacy : isConstructorModern;
      var isArray$2 = isArray$4;
      var isConstructor = isConstructor$1;
      var isObject$a = isObject$g;
      var wellKnownSymbol$f = wellKnownSymbol$j;
      var SPECIES$2 = wellKnownSymbol$f("species");
      var $Array = Array;
      var arraySpeciesConstructor$1 = function(originalArray) {
        var C;
        if (isArray$2(originalArray)) {
          C = originalArray.constructor;
          if (isConstructor(C) && (C === $Array || isArray$2(C.prototype)))
            C = void 0;
          else if (isObject$a(C)) {
            C = C[SPECIES$2];
            if (C === null)
              C = void 0;
          }
        }
        return C === void 0 ? $Array : C;
      };
      var arraySpeciesConstructor = arraySpeciesConstructor$1;
      var arraySpeciesCreate$4 = function(originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
      };
      var $$e = _export;
      var flattenIntoArray$1 = flattenIntoArray_1;
      var toObject$6 = toObject$8;
      var lengthOfArrayLike$5 = lengthOfArrayLike$8;
      var toIntegerOrInfinity$2 = toIntegerOrInfinity$5;
      var arraySpeciesCreate$3 = arraySpeciesCreate$4;
      $$e({ target: "Array", proto: true }, {
        flat: function flat() {
          var depthArg = arguments.length ? arguments[0] : void 0;
          var O = toObject$6(this);
          var sourceLen = lengthOfArrayLike$5(O);
          var A = arraySpeciesCreate$3(O, 0);
          A.length = flattenIntoArray$1(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity$2(depthArg));
          return A;
        }
      });
      var objectDefineProperties = {};
      var internalObjectKeys = objectKeysInternal;
      var enumBugKeys$1 = enumBugKeys$3;
      var objectKeys$2 = Object.keys || function keys2(O) {
        return internalObjectKeys(O, enumBugKeys$1);
      };
      var DESCRIPTORS$6 = descriptors;
      var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
      var definePropertyModule$2 = objectDefineProperty;
      var anObject$6 = anObject$9;
      var toIndexedObject$3 = toIndexedObject$7;
      var objectKeys$1 = objectKeys$2;
      objectDefineProperties.f = DESCRIPTORS$6 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties2) {
        anObject$6(O);
        var props = toIndexedObject$3(Properties2);
        var keys2 = objectKeys$1(Properties2);
        var length = keys2.length;
        var index = 0;
        var key;
        while (length > index)
          definePropertyModule$2.f(O, key = keys2[index++], props[key]);
        return O;
      };
      var getBuiltIn$6 = getBuiltIn$a;
      var html$1 = getBuiltIn$6("document", "documentElement");
      var anObject$5 = anObject$9;
      var definePropertiesModule$1 = objectDefineProperties;
      var enumBugKeys = enumBugKeys$3;
      var hiddenKeys$2 = hiddenKeys$6;
      var html = html$1;
      var documentCreateElement$1 = documentCreateElement$2;
      var sharedKey$2 = sharedKey$4;
      var GT = ">";
      var LT = "<";
      var PROTOTYPE$1 = "prototype";
      var SCRIPT = "script";
      var IE_PROTO$1 = sharedKey$2("IE_PROTO");
      var EmptyConstructor = function() {
      };
      var scriptTag = function(content2) {
        return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function() {
        var iframe = documentCreateElement$1("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var NullProtoObject = function() {
        try {
          activeXDocument = new ActiveXObject("htmlfile");
        } catch (error) {
        }
        NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
        var length = enumBugKeys.length;
        while (length--)
          delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];
        return NullProtoObject();
      };
      hiddenKeys$2[IE_PROTO$1] = true;
      var objectCreate = Object.create || function create2(O, Properties2) {
        var result;
        if (O !== null) {
          EmptyConstructor[PROTOTYPE$1] = anObject$5(O);
          result = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE$1] = null;
          result[IE_PROTO$1] = O;
        } else
          result = NullProtoObject();
        return Properties2 === void 0 ? result : definePropertiesModule$1.f(result, Properties2);
      };
      var wellKnownSymbol$e = wellKnownSymbol$j;
      var create$2 = objectCreate;
      var defineProperty$9 = objectDefineProperty.f;
      var UNSCOPABLES = wellKnownSymbol$e("unscopables");
      var ArrayPrototype$1 = Array.prototype;
      if (ArrayPrototype$1[UNSCOPABLES] === void 0) {
        defineProperty$9(ArrayPrototype$1, UNSCOPABLES, {
          configurable: true,
          value: create$2(null)
        });
      }
      var addToUnscopables$4 = function(key) {
        ArrayPrototype$1[UNSCOPABLES][key] = true;
      };
      var addToUnscopables$3 = addToUnscopables$4;
      addToUnscopables$3("flat");
      var globalThis$a = globalThis_1;
      var uncurryThis$b = functionUncurryThis;
      var entryUnbind$4 = function(CONSTRUCTOR, METHOD) {
        return uncurryThis$b(globalThis$a[CONSTRUCTOR].prototype[METHOD]);
      };
      var entryUnbind$3 = entryUnbind$4;
      entryUnbind$3("Array", "flat");
      var $$d = _export;
      var toObject$5 = toObject$8;
      var lengthOfArrayLike$4 = lengthOfArrayLike$8;
      var toIntegerOrInfinity$1 = toIntegerOrInfinity$5;
      var addToUnscopables$2 = addToUnscopables$4;
      $$d({ target: "Array", proto: true }, {
        at: function at(index) {
          var O = toObject$5(this);
          var len = lengthOfArrayLike$4(O);
          var relativeIndex = toIntegerOrInfinity$1(index);
          var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k < 0 || k >= len ? void 0 : O[k];
        }
      });
      addToUnscopables$2("at");
      var entryUnbind$2 = entryUnbind$4;
      entryUnbind$2("Array", "at");
      var $$c = _export;
      var flattenIntoArray = flattenIntoArray_1;
      var aCallable$3 = aCallable$6;
      var toObject$4 = toObject$8;
      var lengthOfArrayLike$3 = lengthOfArrayLike$8;
      var arraySpeciesCreate$2 = arraySpeciesCreate$4;
      $$c({ target: "Array", proto: true }, {
        flatMap: function flatMap(callbackfn) {
          var O = toObject$4(this);
          var sourceLen = lengthOfArrayLike$3(O);
          var A;
          aCallable$3(callbackfn);
          A = arraySpeciesCreate$2(O, 0);
          A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          return A;
        }
      });
      var addToUnscopables$1 = addToUnscopables$4;
      addToUnscopables$1("flatMap");
      var entryUnbind$1 = entryUnbind$4;
      entryUnbind$1("Array", "flatMap");
      var internalMetadata = { exports: {} };
      var objectGetOwnPropertyNamesExternal = {};
      var uncurryThis$a = functionUncurryThis;
      var arraySlice$2 = uncurryThis$a([].slice);
      var classof$5 = classofRaw$2;
      var toIndexedObject$2 = toIndexedObject$7;
      var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
      var arraySlice$1 = arraySlice$2;
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function(it) {
        try {
          return $getOwnPropertyNames$1(it);
        } catch (error) {
          return arraySlice$1(windowNames);
        }
      };
      objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
        return windowNames && classof$5(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$2(it));
      };
      var fails$a = fails$k;
      var arrayBufferNonExtensible = fails$a(function() {
        if (typeof ArrayBuffer == "function") {
          var buffer = new ArrayBuffer(8);
          if (Object.isExtensible(buffer))
            Object.defineProperty(buffer, "a", { value: 8 });
        }
      });
      var fails$9 = fails$k;
      var isObject$9 = isObject$g;
      var classof$4 = classofRaw$2;
      var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
      var $isExtensible = Object.isExtensible;
      var FAILS_ON_PRIMITIVES = fails$9(function() {
        $isExtensible(1);
      });
      var objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible2(it) {
        if (!isObject$9(it))
          return false;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$4(it) === "ArrayBuffer")
          return false;
        return $isExtensible ? $isExtensible(it) : true;
      } : $isExtensible;
      var fails$8 = fails$k;
      var freezing = !fails$8(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      });
      var $$b = _export;
      var uncurryThis$9 = functionUncurryThis;
      var hiddenKeys$1 = hiddenKeys$6;
      var isObject$8 = isObject$g;
      var hasOwn$7 = hasOwnProperty_1;
      var defineProperty$8 = objectDefineProperty.f;
      var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
      var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
      var isExtensible = objectIsExtensible;
      var uid$1 = uid$4;
      var FREEZING = freezing;
      var REQUIRED = false;
      var METADATA$1 = uid$1("meta");
      var id = 0;
      var setMetadata = function(it) {
        defineProperty$8(it, METADATA$1, { value: {
          objectID: "O" + id++,
          // object ID
          weakData: {}
          // weak collections IDs
        } });
      };
      var fastKey$1 = function(it, create2) {
        if (!isObject$8(it))
          return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
        if (!hasOwn$7(it, METADATA$1)) {
          if (!isExtensible(it))
            return "F";
          if (!create2)
            return "E";
          setMetadata(it);
        }
        return it[METADATA$1].objectID;
      };
      var getWeakData = function(it, create2) {
        if (!hasOwn$7(it, METADATA$1)) {
          if (!isExtensible(it))
            return true;
          if (!create2)
            return false;
          setMetadata(it);
        }
        return it[METADATA$1].weakData;
      };
      var onFreeze = function(it) {
        if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn$7(it, METADATA$1))
          setMetadata(it);
        return it;
      };
      var enable = function() {
        meta$1.enable = function() {
        };
        REQUIRED = true;
        var getOwnPropertyNames = getOwnPropertyNamesModule$1.f;
        var splice2 = uncurryThis$9([].splice);
        var test2 = {};
        test2[METADATA$1] = 1;
        if (getOwnPropertyNames(test2).length) {
          getOwnPropertyNamesModule$1.f = function(it) {
            var result = getOwnPropertyNames(it);
            for (var i = 0, length = result.length; i < length; i++) {
              if (result[i] === METADATA$1) {
                splice2(result, i, 1);
                break;
              }
            }
            return result;
          };
          $$b({ target: "Object", stat: true, forced: true }, {
            getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
          });
        }
      };
      var meta$1 = internalMetadata.exports = {
        enable,
        fastKey: fastKey$1,
        getWeakData,
        onFreeze
      };
      hiddenKeys$1[METADATA$1] = true;
      var internalMetadataExports = internalMetadata.exports;
      var iterators = {};
      var wellKnownSymbol$d = wellKnownSymbol$j;
      var Iterators$4 = iterators;
      var ITERATOR$5 = wellKnownSymbol$d("iterator");
      var ArrayPrototype = Array.prototype;
      var isArrayIteratorMethod$1 = function(it) {
        return it !== void 0 && (Iterators$4.Array === it || ArrayPrototype[ITERATOR$5] === it);
      };
      var classof$3 = classof$7;
      var getMethod$2 = getMethod$4;
      var isNullOrUndefined$2 = isNullOrUndefined$5;
      var Iterators$3 = iterators;
      var wellKnownSymbol$c = wellKnownSymbol$j;
      var ITERATOR$4 = wellKnownSymbol$c("iterator");
      var getIteratorMethod$2 = function(it) {
        if (!isNullOrUndefined$2(it))
          return getMethod$2(it, ITERATOR$4) || getMethod$2(it, "@@iterator") || Iterators$3[classof$3(it)];
      };
      var call$9 = functionCall;
      var aCallable$2 = aCallable$6;
      var anObject$4 = anObject$9;
      var tryToString$2 = tryToString$4;
      var getIteratorMethod$1 = getIteratorMethod$2;
      var $TypeError$4 = TypeError;
      var getIterator$1 = function(argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
        if (aCallable$2(iteratorMethod))
          return anObject$4(call$9(iteratorMethod, argument));
        throw new $TypeError$4(tryToString$2(argument) + " is not iterable");
      };
      var call$8 = functionCall;
      var anObject$3 = anObject$9;
      var getMethod$1 = getMethod$4;
      var iteratorClose$1 = function(iterator, kind, value) {
        var innerResult, innerError;
        anObject$3(iterator);
        try {
          innerResult = getMethod$1(iterator, "return");
          if (!innerResult) {
            if (kind === "throw")
              throw value;
            return value;
          }
          innerResult = call$8(innerResult, iterator);
        } catch (error) {
          innerError = true;
          innerResult = error;
        }
        if (kind === "throw")
          throw value;
        if (innerError)
          throw innerResult;
        anObject$3(innerResult);
        return value;
      };
      var bind$2 = functionBindContext;
      var call$7 = functionCall;
      var anObject$2 = anObject$9;
      var tryToString$1 = tryToString$4;
      var isArrayIteratorMethod = isArrayIteratorMethod$1;
      var lengthOfArrayLike$2 = lengthOfArrayLike$8;
      var isPrototypeOf$3 = objectIsPrototypeOf;
      var getIterator = getIterator$1;
      var getIteratorMethod = getIteratorMethod$2;
      var iteratorClose = iteratorClose$1;
      var $TypeError$3 = TypeError;
      var Result = function(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var ResultPrototype = Result.prototype;
      var iterate$4 = function(iterable, unboundFunction, options2) {
        var that = options2 && options2.that;
        var AS_ENTRIES = !!(options2 && options2.AS_ENTRIES);
        var IS_RECORD = !!(options2 && options2.IS_RECORD);
        var IS_ITERATOR = !!(options2 && options2.IS_ITERATOR);
        var INTERRUPTED = !!(options2 && options2.INTERRUPTED);
        var fn = bind$2(unboundFunction, that);
        var iterator, iterFn, index, length, result, next2, step;
        var stop = function(condition) {
          if (iterator)
            iteratorClose(iterator, "normal", condition);
          return new Result(true, condition);
        };
        var callFn = function(value) {
          if (AS_ENTRIES) {
            anObject$2(value);
            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
          }
          return INTERRUPTED ? fn(value, stop) : fn(value);
        };
        if (IS_RECORD) {
          iterator = iterable.iterator;
        } else if (IS_ITERATOR) {
          iterator = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (!iterFn)
            throw new $TypeError$3(tryToString$1(iterable) + " is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {
              result = callFn(iterable[index]);
              if (result && isPrototypeOf$3(ResultPrototype, result))
                return result;
            }
            return new Result(false);
          }
          iterator = getIterator(iterable, iterFn);
        }
        next2 = IS_RECORD ? iterable.next : iterator.next;
        while (!(step = call$7(next2, iterator)).done) {
          try {
            result = callFn(step.value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
          if (typeof result == "object" && result && isPrototypeOf$3(ResultPrototype, result))
            return result;
        }
        return new Result(false);
      };
      var isPrototypeOf$2 = objectIsPrototypeOf;
      var $TypeError$2 = TypeError;
      var anInstance$2 = function(it, Prototype) {
        if (isPrototypeOf$2(Prototype, it))
          return it;
        throw new $TypeError$2("Incorrect invocation");
      };
      var wellKnownSymbol$b = wellKnownSymbol$j;
      var ITERATOR$3 = wellKnownSymbol$b("iterator");
      var SAFE_CLOSING = false;
      try {
        var called = 0;
        var iteratorWithReturn = {
          next: function() {
            return { done: !!called++ };
          },
          "return": function() {
            SAFE_CLOSING = true;
          }
        };
        iteratorWithReturn[ITERATOR$3] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error) {
      }
      var checkCorrectnessOfIteration$1 = function(exec2, SKIP_CLOSING) {
        try {
          if (!SKIP_CLOSING && !SAFE_CLOSING)
            return false;
        } catch (error) {
          return false;
        }
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR$3] = function() {
            return {
              next: function() {
                return { done: ITERATION_SUPPORT = true };
              }
            };
          };
          exec2(object);
        } catch (error) {
        }
        return ITERATION_SUPPORT;
      };
      var defineProperty$7 = objectDefineProperty.f;
      var hasOwn$6 = hasOwnProperty_1;
      var wellKnownSymbol$a = wellKnownSymbol$j;
      var TO_STRING_TAG = wellKnownSymbol$a("toStringTag");
      var setToStringTag$9 = function(target, TAG2, STATIC) {
        if (target && !STATIC)
          target = target.prototype;
        if (target && !hasOwn$6(target, TO_STRING_TAG)) {
          defineProperty$7(target, TO_STRING_TAG, { configurable: true, value: TAG2 });
        }
      };
      var uncurryThis$8 = functionUncurryThis;
      var aCallable$1 = aCallable$6;
      var functionUncurryThisAccessor = function(object, key, method) {
        try {
          return uncurryThis$8(aCallable$1(Object.getOwnPropertyDescriptor(object, key)[method]));
        } catch (error) {
        }
      };
      var isObject$7 = isObject$g;
      var isPossiblePrototype$1 = function(argument) {
        return isObject$7(argument) || argument === null;
      };
      var isPossiblePrototype = isPossiblePrototype$1;
      var $String$2 = String;
      var $TypeError$1 = TypeError;
      var aPossiblePrototype$1 = function(argument) {
        if (isPossiblePrototype(argument))
          return argument;
        throw new $TypeError$1("Can't set " + $String$2(argument) + " as a prototype");
      };
      var uncurryThisAccessor$1 = functionUncurryThisAccessor;
      var isObject$6 = isObject$g;
      var requireObjectCoercible = requireObjectCoercible$3;
      var aPossiblePrototype = aPossiblePrototype$1;
      var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var CORRECT_SETTER = false;
        var test2 = {};
        var setter;
        try {
          setter = uncurryThisAccessor$1(Object.prototype, "__proto__", "set");
          setter(test2, []);
          CORRECT_SETTER = test2 instanceof Array;
        } catch (error) {
        }
        return function setPrototypeOf2(O, proto) {
          requireObjectCoercible(O);
          aPossiblePrototype(proto);
          if (!isObject$6(O))
            return O;
          if (CORRECT_SETTER)
            setter(O, proto);
          else
            O.__proto__ = proto;
          return O;
        };
      }() : void 0);
      var isCallable$7 = isCallable$k;
      var isObject$5 = isObject$g;
      var setPrototypeOf$1 = objectSetPrototypeOf;
      var inheritIfRequired$1 = function($this, dummy, Wrapper) {
        var NewTarget, NewTargetPrototype;
        if (
          // it can work only with native `setPrototypeOf`
          setPrototypeOf$1 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          isCallable$7(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$5(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
        )
          setPrototypeOf$1($this, NewTargetPrototype);
        return $this;
      };
      var $$a = _export;
      var globalThis$9 = globalThis_1;
      var uncurryThis$7 = functionUncurryThis;
      var isForced = isForced_1;
      var defineBuiltIn$6 = defineBuiltIn$8;
      var InternalMetadataModule = internalMetadataExports;
      var iterate$3 = iterate$4;
      var anInstance$1 = anInstance$2;
      var isCallable$6 = isCallable$k;
      var isNullOrUndefined$1 = isNullOrUndefined$5;
      var isObject$4 = isObject$g;
      var fails$7 = fails$k;
      var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
      var setToStringTag$8 = setToStringTag$9;
      var inheritIfRequired = inheritIfRequired$1;
      var collection$1 = function(CONSTRUCTOR_NAME, wrapper, common) {
        var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
        var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
        var ADDER = IS_MAP ? "set" : "add";
        var NativeConstructor = globalThis$9[CONSTRUCTOR_NAME];
        var NativePrototype = NativeConstructor && NativeConstructor.prototype;
        var Constructor = NativeConstructor;
        var exported = {};
        var fixMethod = function(KEY) {
          var uncurriedNativeMethod = uncurryThis$7(NativePrototype[KEY]);
          defineBuiltIn$6(
            NativePrototype,
            KEY,
            KEY === "add" ? function add2(value) {
              uncurriedNativeMethod(this, value === 0 ? 0 : value);
              return this;
            } : KEY === "delete" ? function(key) {
              return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "get" ? function get2(key) {
              return IS_WEAK && !isObject$4(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "has" ? function has2(key) {
              return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : function set2(key, value) {
              uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
              return this;
            }
          );
        };
        var REPLACE = isForced(
          CONSTRUCTOR_NAME,
          !isCallable$6(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$7(function() {
            new NativeConstructor().entries().next();
          }))
        );
        if (REPLACE) {
          Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
          InternalMetadataModule.enable();
        } else if (isForced(CONSTRUCTOR_NAME, true)) {
          var instance = new Constructor();
          var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
          var THROWS_ON_PRIMITIVES = fails$7(function() {
            instance.has(1);
          });
          var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
            new NativeConstructor(iterable);
          });
          var BUGGY_ZERO = !IS_WEAK && fails$7(function() {
            var $instance = new NativeConstructor();
            var index = 5;
            while (index--)
              $instance[ADDER](index, index);
            return !$instance.has(-0);
          });
          if (!ACCEPT_ITERABLES) {
            Constructor = wrapper(function(dummy, iterable) {
              anInstance$1(dummy, NativePrototype);
              var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
              if (!isNullOrUndefined$1(iterable))
                iterate$3(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
              return that;
            });
            Constructor.prototype = NativePrototype;
            NativePrototype.constructor = Constructor;
          }
          if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod("delete");
            fixMethod("has");
            IS_MAP && fixMethod("get");
          }
          if (BUGGY_ZERO || HASNT_CHAINING)
            fixMethod(ADDER);
          if (IS_WEAK && NativePrototype.clear)
            delete NativePrototype.clear;
        }
        exported[CONSTRUCTOR_NAME] = Constructor;
        $$a({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
        setToStringTag$8(Constructor, CONSTRUCTOR_NAME);
        if (!IS_WEAK)
          common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
        return Constructor;
      };
      var makeBuiltIn = makeBuiltInExports;
      var defineProperty$6 = objectDefineProperty;
      var defineBuiltInAccessor$4 = function(target, name2, descriptor2) {
        if (descriptor2.get)
          makeBuiltIn(descriptor2.get, name2, { getter: true });
        if (descriptor2.set)
          makeBuiltIn(descriptor2.set, name2, { setter: true });
        return defineProperty$6.f(target, name2, descriptor2);
      };
      var defineBuiltIn$5 = defineBuiltIn$8;
      var defineBuiltIns$1 = function(target, src, options2) {
        for (var key in src)
          defineBuiltIn$5(target, key, src[key], options2);
        return target;
      };
      var fails$6 = fails$k;
      var correctPrototypeGetter = !fails$6(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
      var hasOwn$5 = hasOwnProperty_1;
      var isCallable$5 = isCallable$k;
      var toObject$3 = toObject$8;
      var sharedKey$1 = sharedKey$4;
      var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
      var IE_PROTO = sharedKey$1("IE_PROTO");
      var $Object = Object;
      var ObjectPrototype$1 = $Object.prototype;
      var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
        var object = toObject$3(O);
        if (hasOwn$5(object, IE_PROTO))
          return object[IE_PROTO];
        var constructor = object.constructor;
        if (isCallable$5(constructor) && object instanceof constructor) {
          return constructor.prototype;
        }
        return object instanceof $Object ? ObjectPrototype$1 : null;
      };
      var fails$5 = fails$k;
      var isCallable$4 = isCallable$k;
      var isObject$3 = isObject$g;
      var getPrototypeOf$1 = objectGetPrototypeOf;
      var defineBuiltIn$4 = defineBuiltIn$8;
      var wellKnownSymbol$9 = wellKnownSymbol$j;
      var ITERATOR$2 = wellKnownSymbol$9("iterator");
      var BUGGY_SAFARI_ITERATORS$1 = false;
      var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator))
          BUGGY_SAFARI_ITERATORS$1 = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
            IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE = !isObject$3(IteratorPrototype$2) || fails$5(function() {
        var test2 = {};
        return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
      });
      if (NEW_ITERATOR_PROTOTYPE)
        IteratorPrototype$2 = {};
      if (!isCallable$4(IteratorPrototype$2[ITERATOR$2])) {
        defineBuiltIn$4(IteratorPrototype$2, ITERATOR$2, function() {
          return this;
        });
      }
      var iteratorsCore = {
        IteratorPrototype: IteratorPrototype$2,
        BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
      };
      var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
      var create$1 = objectCreate;
      var createPropertyDescriptor$2 = createPropertyDescriptor$5;
      var setToStringTag$7 = setToStringTag$9;
      var Iterators$2 = iterators;
      var returnThis$1 = function() {
        return this;
      };
      var iteratorCreateConstructor = function(IteratorConstructor, NAME, next2, ENUMERABLE_NEXT) {
        var TO_STRING_TAG2 = NAME + " Iterator";
        IteratorConstructor.prototype = create$1(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next2) });
        setToStringTag$7(IteratorConstructor, TO_STRING_TAG2, false);
        Iterators$2[TO_STRING_TAG2] = returnThis$1;
        return IteratorConstructor;
      };
      var $$9 = _export;
      var call$6 = functionCall;
      var FunctionName = functionName;
      var isCallable$3 = isCallable$k;
      var createIteratorConstructor = iteratorCreateConstructor;
      var getPrototypeOf = objectGetPrototypeOf;
      var setPrototypeOf = objectSetPrototypeOf;
      var setToStringTag$6 = setToStringTag$9;
      var createNonEnumerableProperty$1 = createNonEnumerableProperty$4;
      var defineBuiltIn$3 = defineBuiltIn$8;
      var wellKnownSymbol$8 = wellKnownSymbol$j;
      var Iterators$1 = iterators;
      var IteratorsCore = iteratorsCore;
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR$1 = wellKnownSymbol$8("iterator");
      var KEYS$1 = "keys";
      var VALUES$1 = "values";
      var ENTRIES$1 = "entries";
      var returnThis = function() {
        return this;
      };
      var iteratorDefine = function(Iterable, NAME, IteratorConstructor, next2, DEFAULT, IS_SET, FORCED2) {
        createIteratorConstructor(IteratorConstructor, NAME, next2);
        var getIterationMethod = function(KIND) {
          if (KIND === DEFAULT && defaultIterator)
            return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
            return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS$1:
              return function keys2() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES$1:
              return function values2() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES$1:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG2 = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$1])) {
                defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$1, returnThis);
              }
            }
            setToStringTag$6(CurrentIteratorPrototype, TO_STRING_TAG2, true);
          }
        }
        if (PROPER_FUNCTION_NAME && DEFAULT === VALUES$1 && nativeIterator && nativeIterator.name !== VALUES$1) {
          if (CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty$1(IterablePrototype, "name", VALUES$1);
          } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values2() {
              return call$6(nativeIterator, this);
            };
          }
        }
        if (DEFAULT) {
          methods = {
            values: getIterationMethod(VALUES$1),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS$1),
            entries: getIterationMethod(ENTRIES$1)
          };
          if (FORCED2)
            for (KEY in methods) {
              if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);
              }
            }
          else
            $$9({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
        }
        if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
          defineBuiltIn$3(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
        }
        Iterators$1[NAME] = defaultIterator;
        return methods;
      };
      var createIterResultObject$2 = function(value, done) {
        return { value, done };
      };
      var getBuiltIn$5 = getBuiltIn$a;
      var defineBuiltInAccessor$3 = defineBuiltInAccessor$4;
      var wellKnownSymbol$7 = wellKnownSymbol$j;
      var DESCRIPTORS$5 = descriptors;
      var SPECIES$1 = wellKnownSymbol$7("species");
      var setSpecies$1 = function(CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn$5(CONSTRUCTOR_NAME);
        if (DESCRIPTORS$5 && Constructor && !Constructor[SPECIES$1]) {
          defineBuiltInAccessor$3(Constructor, SPECIES$1, {
            configurable: true,
            get: function() {
              return this;
            }
          });
        }
      };
      var create = objectCreate;
      var defineBuiltInAccessor$2 = defineBuiltInAccessor$4;
      var defineBuiltIns = defineBuiltIns$1;
      var bind$1 = functionBindContext;
      var anInstance = anInstance$2;
      var isNullOrUndefined = isNullOrUndefined$5;
      var iterate$2 = iterate$4;
      var defineIterator$1 = iteratorDefine;
      var createIterResultObject$1 = createIterResultObject$2;
      var setSpecies = setSpecies$1;
      var DESCRIPTORS$4 = descriptors;
      var fastKey = internalMetadataExports.fastKey;
      var InternalStateModule$2 = internalState;
      var setInternalState$2 = InternalStateModule$2.set;
      var internalStateGetterFor = InternalStateModule$2.getterFor;
      var collectionStrong$1 = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState$2(that, {
              type: CONSTRUCTOR_NAME,
              index: create(null),
              first: null,
              last: null,
              size: 0
            });
            if (!DESCRIPTORS$4)
              that.size = 0;
            if (!isNullOrUndefined(iterable))
              iterate$2(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define2 = function(that, key, value) {
            var state = getInternalState2(that);
            var entry = getEntry(that, key);
            var previous2, index;
            if (entry) {
              entry.value = value;
            } else {
              state.last = entry = {
                index: index = fastKey(key, true),
                key,
                value,
                previous: previous2 = state.last,
                next: null,
                removed: false
              };
              if (!state.first)
                state.first = entry;
              if (previous2)
                previous2.next = entry;
              if (DESCRIPTORS$4)
                state.size++;
              else
                that.size++;
              if (index !== "F")
                state.index[index] = entry;
            }
            return that;
          };
          var getEntry = function(that, key) {
            var state = getInternalState2(that);
            var index = fastKey(key);
            var entry;
            if (index !== "F")
              return state.index[index];
            for (entry = state.first; entry; entry = entry.next) {
              if (entry.key === key)
                return entry;
            }
          };
          defineBuiltIns(Prototype, {
            // `{ Map, Set }.prototype.clear()` methods
            // https://tc39.es/ecma262/#sec-map.prototype.clear
            // https://tc39.es/ecma262/#sec-set.prototype.clear
            clear: function clear() {
              var that = this;
              var state = getInternalState2(that);
              var entry = state.first;
              while (entry) {
                entry.removed = true;
                if (entry.previous)
                  entry.previous = entry.previous.next = null;
                entry = entry.next;
              }
              state.first = state.last = null;
              state.index = create(null);
              if (DESCRIPTORS$4)
                state.size = 0;
              else
                that.size = 0;
            },
            // `{ Map, Set }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.delete
            // https://tc39.es/ecma262/#sec-set.prototype.delete
            "delete": function(key) {
              var that = this;
              var state = getInternalState2(that);
              var entry = getEntry(that, key);
              if (entry) {
                var next2 = entry.next;
                var prev = entry.previous;
                delete state.index[entry.index];
                entry.removed = true;
                if (prev)
                  prev.next = next2;
                if (next2)
                  next2.previous = prev;
                if (state.first === entry)
                  state.first = next2;
                if (state.last === entry)
                  state.last = prev;
                if (DESCRIPTORS$4)
                  state.size--;
                else
                  that.size--;
              }
              return !!entry;
            },
            // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.foreach
            // https://tc39.es/ecma262/#sec-set.prototype.foreach
            forEach: function forEach2(callbackfn) {
              var state = getInternalState2(this);
              var boundFunction = bind$1(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              var entry;
              while (entry = entry ? entry.next : state.first) {
                boundFunction(entry.value, entry.key, this);
                while (entry && entry.removed)
                  entry = entry.previous;
              }
            },
            // `{ Map, Set}.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.has
            // https://tc39.es/ecma262/#sec-set.prototype.has
            has: function has2(key) {
              return !!getEntry(this, key);
            }
          });
          defineBuiltIns(Prototype, IS_MAP ? {
            // `Map.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-map.prototype.get
            get: function get2(key) {
              var entry = getEntry(this, key);
              return entry && entry.value;
            },
            // `Map.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-map.prototype.set
            set: function set2(key, value) {
              return define2(this, key === 0 ? 0 : key, value);
            }
          } : {
            // `Set.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-set.prototype.add
            add: function add2(value) {
              return define2(this, value = value === 0 ? 0 : value, value);
            }
          });
          if (DESCRIPTORS$4)
            defineBuiltInAccessor$2(Prototype, "size", {
              configurable: true,
              get: function() {
                return getInternalState2(this).size;
              }
            });
          return Constructor;
        },
        setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
          var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
          var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
          defineIterator$1(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
            setInternalState$2(this, {
              type: ITERATOR_NAME,
              target: iterated,
              state: getInternalCollectionState(iterated),
              kind,
              last: null
            });
          }, function() {
            var state = getInternalIteratorState(this);
            var kind = state.kind;
            var entry = state.last;
            while (entry && entry.removed)
              entry = entry.previous;
            if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
              state.target = null;
              return createIterResultObject$1(void 0, true);
            }
            if (kind === "keys")
              return createIterResultObject$1(entry.key, false);
            if (kind === "values")
              return createIterResultObject$1(entry.value, false);
            return createIterResultObject$1([entry.key, entry.value], false);
          }, IS_MAP ? "entries" : "values", !IS_MAP, true);
          setSpecies(CONSTRUCTOR_NAME);
        }
      };
      var collection = collection$1;
      var collectionStrong = collectionStrong$1;
      collection("Set", function(init) {
        return function Set2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
      var uncurryThis$6 = functionUncurryThis;
      var SetPrototype$1 = Set.prototype;
      var setHelpers = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: uncurryThis$6(SetPrototype$1.add),
        has: uncurryThis$6(SetPrototype$1.has),
        remove: uncurryThis$6(SetPrototype$1["delete"]),
        proto: SetPrototype$1
      };
      var has$2 = setHelpers.has;
      var aSet$1 = function(it) {
        has$2(it);
        return it;
      };
      var call$5 = functionCall;
      var iterateSimple$2 = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
        var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
        var next2 = record.next;
        var step, result;
        while (!(step = call$5(next2, iterator)).done) {
          result = fn(step.value);
          if (result !== void 0)
            return result;
        }
      };
      var uncurryThis$5 = functionUncurryThis;
      var iterateSimple$1 = iterateSimple$2;
      var SetHelpers$3 = setHelpers;
      var Set$2 = SetHelpers$3.Set;
      var SetPrototype = SetHelpers$3.proto;
      var forEach = uncurryThis$5(SetPrototype.forEach);
      var keys = uncurryThis$5(SetPrototype.keys);
      var next = keys(new Set$2()).next;
      var setIterate = function(set2, fn, interruptible) {
        return interruptible ? iterateSimple$1({ iterator: keys(set2), next }, fn) : forEach(set2, fn);
      };
      var SetHelpers$2 = setHelpers;
      var iterate$1 = setIterate;
      var Set$1 = SetHelpers$2.Set;
      var add = SetHelpers$2.add;
      var setClone = function(set2) {
        var result = new Set$1();
        iterate$1(set2, function(it) {
          add(result, it);
        });
        return result;
      };
      var uncurryThisAccessor = functionUncurryThisAccessor;
      var SetHelpers$1 = setHelpers;
      var setSize = uncurryThisAccessor(SetHelpers$1.proto, "size", "get") || function(set2) {
        return set2.size;
      };
      var getIteratorDirect$1 = function(obj) {
        return {
          iterator: obj,
          next: obj.next,
          done: false
        };
      };
      var aCallable = aCallable$6;
      var anObject$1 = anObject$9;
      var call$4 = functionCall;
      var toIntegerOrInfinity = toIntegerOrInfinity$5;
      var getIteratorDirect = getIteratorDirect$1;
      var INVALID_SIZE = "Invalid size";
      var $RangeError = RangeError;
      var $TypeError = TypeError;
      var max = Math.max;
      var SetRecord = function(set2, intSize) {
        this.set = set2;
        this.size = max(intSize, 0);
        this.has = aCallable(set2.has);
        this.keys = aCallable(set2.keys);
      };
      SetRecord.prototype = {
        getIterator: function() {
          return getIteratorDirect(anObject$1(call$4(this.keys, this.set)));
        },
        includes: function(it) {
          return call$4(this.has, this.set, it);
        }
      };
      var getSetRecord$1 = function(obj) {
        anObject$1(obj);
        var numSize = +obj.size;
        if (numSize !== numSize)
          throw new $TypeError(INVALID_SIZE);
        var intSize = toIntegerOrInfinity(numSize);
        if (intSize < 0)
          throw new $RangeError(INVALID_SIZE);
        return new SetRecord(obj, intSize);
      };
      var aSet = aSet$1;
      var SetHelpers = setHelpers;
      var clone = setClone;
      var size = setSize;
      var getSetRecord = getSetRecord$1;
      var iterateSet = setIterate;
      var iterateSimple = iterateSimple$2;
      var has$1 = SetHelpers.has;
      var remove$1 = SetHelpers.remove;
      var setDifference = function difference2(other) {
        var O = aSet(this);
        var otherRec = getSetRecord(other);
        var result = clone(O);
        if (size(O) <= otherRec.size)
          iterateSet(O, function(e2) {
            if (otherRec.includes(e2))
              remove$1(result, e2);
          });
        else
          iterateSimple(otherRec.getIterator(), function(e2) {
            if (has$1(O, e2))
              remove$1(result, e2);
          });
        return result;
      };
      var getBuiltIn$4 = getBuiltIn$a;
      var createSetLike = function(size2) {
        return {
          size: size2,
          has: function() {
            return false;
          },
          keys: function() {
            return {
              next: function() {
                return { done: true };
              }
            };
          }
        };
      };
      var createSetLikeWithInfinitySize = function(size2) {
        return {
          size: size2,
          has: function() {
            return true;
          },
          keys: function() {
            throw new Error("e");
          }
        };
      };
      var setMethodAcceptSetLike$1 = function(name2, callback2) {
        var Set2 = getBuiltIn$4("Set");
        try {
          new Set2()[name2](createSetLike(0));
          try {
            new Set2()[name2](createSetLike(-1));
            return false;
          } catch (error2) {
            if (!callback2)
              return true;
            try {
              new Set2()[name2](createSetLikeWithInfinitySize(-Infinity));
              return false;
            } catch (error) {
              var set2 = new Set2();
              set2.add(1);
              set2.add(2);
              return callback2(set2[name2](createSetLikeWithInfinitySize(Infinity)));
            }
          }
        } catch (error) {
          return false;
        }
      };
      var $$8 = _export;
      var difference = setDifference;
      var setMethodAcceptSetLike = setMethodAcceptSetLike$1;
      var INCORRECT = !setMethodAcceptSetLike("difference", function(result) {
        return result.size === 0;
      });
      $$8({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        difference
      });
      var entryUnbind = entryUnbind$4;
      entryUnbind("Set", "difference");
      var DESCRIPTORS$3 = descriptors;
      var definePropertyModule$1 = objectDefineProperty;
      var createPropertyDescriptor$1 = createPropertyDescriptor$5;
      var createProperty$1 = function(object, key, value) {
        if (DESCRIPTORS$3)
          definePropertyModule$1.f(object, key, createPropertyDescriptor$1(0, value));
        else
          object[key] = value;
      };
      var fails$4 = fails$k;
      var wellKnownSymbol$6 = wellKnownSymbol$j;
      var V8_VERSION$1 = environmentV8Version;
      var SPECIES = wellKnownSymbol$6("species");
      var arrayMethodHasSpeciesSupport$1 = function(METHOD_NAME) {
        return V8_VERSION$1 >= 51 || !fails$4(function() {
          var array = [];
          var constructor = array.constructor = {};
          constructor[SPECIES] = function() {
            return { foo: 1 };
          };
          return array[METHOD_NAME](Boolean).foo !== 1;
        });
      };
      var $$7 = _export;
      var fails$3 = fails$k;
      var isArray$1 = isArray$4;
      var isObject$2 = isObject$g;
      var toObject$2 = toObject$8;
      var lengthOfArrayLike$1 = lengthOfArrayLike$8;
      var doesNotExceedSafeInteger = doesNotExceedSafeInteger$2;
      var createProperty = createProperty$1;
      var arraySpeciesCreate$1 = arraySpeciesCreate$4;
      var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$1;
      var wellKnownSymbol$5 = wellKnownSymbol$j;
      var V8_VERSION = environmentV8Version;
      var IS_CONCAT_SPREADABLE = wellKnownSymbol$5("isConcatSpreadable");
      var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$3(function() {
        var array = [];
        array[IS_CONCAT_SPREADABLE] = false;
        return array.concat()[0] !== array;
      });
      var isConcatSpreadable = function(O) {
        if (!isObject$2(O))
          return false;
        var spreadable = O[IS_CONCAT_SPREADABLE];
        return spreadable !== void 0 ? !!spreadable : isArray$1(O);
      };
      var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
      $$7({ target: "Array", proto: true, arity: 1, forced: FORCED$1 }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        concat: function concat2(arg) {
          var O = toObject$2(this);
          var A = arraySpeciesCreate$1(O, 0);
          var n2 = 0;
          var i, k, length, len, E;
          for (i = -1, length = arguments.length; i < length; i++) {
            E = i === -1 ? O : arguments[i];
            if (isConcatSpreadable(E)) {
              len = lengthOfArrayLike$1(E);
              doesNotExceedSafeInteger(n2 + len);
              for (k = 0; k < len; k++, n2++)
                if (k in E)
                  createProperty(A, n2, E[k]);
            } else {
              doesNotExceedSafeInteger(n2 + 1);
              createProperty(A, n2++, E);
            }
          }
          A.length = n2;
          return A;
        }
      });
      var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
      var classof$2 = classof$7;
      var objectToString$1 = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString2() {
        return "[object " + classof$2(this) + "]";
      };
      var TO_STRING_TAG_SUPPORT = toStringTagSupport;
      var defineBuiltIn$2 = defineBuiltIn$8;
      var toString$4 = objectToString$1;
      if (!TO_STRING_TAG_SUPPORT) {
        defineBuiltIn$2(Object.prototype, "toString", toString$4, { unsafe: true });
      }
      var classof$1 = classof$7;
      var $String$1 = String;
      var toString$3 = function(argument) {
        if (classof$1(argument) === "Symbol")
          throw new TypeError("Cannot convert a Symbol value to a string");
        return $String$1(argument);
      };
      var wellKnownSymbolWrapped = {};
      var wellKnownSymbol$4 = wellKnownSymbol$j;
      wellKnownSymbolWrapped.f = wellKnownSymbol$4;
      var globalThis$8 = globalThis_1;
      var path$3 = globalThis$8;
      var path$2 = path$3;
      var hasOwn$4 = hasOwnProperty_1;
      var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
      var defineProperty$5 = objectDefineProperty.f;
      var wellKnownSymbolDefine = function(NAME) {
        var Symbol2 = path$2.Symbol || (path$2.Symbol = {});
        if (!hasOwn$4(Symbol2, NAME))
          defineProperty$5(Symbol2, NAME, {
            value: wrappedWellKnownSymbolModule$1.f(NAME)
          });
      };
      var call$3 = functionCall;
      var getBuiltIn$3 = getBuiltIn$a;
      var wellKnownSymbol$3 = wellKnownSymbol$j;
      var defineBuiltIn$1 = defineBuiltIn$8;
      var symbolDefineToPrimitive = function() {
        var Symbol2 = getBuiltIn$3("Symbol");
        var SymbolPrototype2 = Symbol2 && Symbol2.prototype;
        var valueOf = SymbolPrototype2 && SymbolPrototype2.valueOf;
        var TO_PRIMITIVE2 = wellKnownSymbol$3("toPrimitive");
        if (SymbolPrototype2 && !SymbolPrototype2[TO_PRIMITIVE2]) {
          defineBuiltIn$1(SymbolPrototype2, TO_PRIMITIVE2, function(hint) {
            return call$3(valueOf, this);
          }, { arity: 1 });
        }
      };
      var bind = functionBindContext;
      var uncurryThis$4 = functionUncurryThis;
      var IndexedObject = indexedObject;
      var toObject$1 = toObject$8;
      var lengthOfArrayLike = lengthOfArrayLike$8;
      var arraySpeciesCreate = arraySpeciesCreate$4;
      var push$2 = uncurryThis$4([].push);
      var createMethod = function(TYPE) {
        var IS_MAP = TYPE === 1;
        var IS_FILTER = TYPE === 2;
        var IS_SOME = TYPE === 3;
        var IS_EVERY = TYPE === 4;
        var IS_FIND_INDEX = TYPE === 6;
        var IS_FILTER_REJECT = TYPE === 7;
        var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O = toObject$1($this);
          var self2 = IndexedObject(O);
          var length = lengthOfArrayLike(self2);
          var boundFunction = bind(callbackfn, that);
          var index = 0;
          var create2 = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
          var value, result;
          for (; length > index; index++)
            if (NO_HOLES || index in self2) {
              value = self2[index];
              result = boundFunction(value, index, O);
              if (TYPE) {
                if (IS_MAP)
                  target[index] = result;
                else if (result)
                  switch (TYPE) {
                    case 3:
                      return true;
                    case 5:
                      return value;
                    case 6:
                      return index;
                    case 2:
                      push$2(target, value);
                  }
                else
                  switch (TYPE) {
                    case 4:
                      return false;
                    case 7:
                      push$2(target, value);
                  }
              }
            }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      var arrayIteration = {
        // `Array.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        forEach: createMethod(0)
      };
      var $$6 = _export;
      var globalThis$7 = globalThis_1;
      var call$2 = functionCall;
      var uncurryThis$3 = functionUncurryThis;
      var DESCRIPTORS$2 = descriptors;
      var NATIVE_SYMBOL$4 = symbolConstructorDetection;
      var fails$2 = fails$k;
      var hasOwn$3 = hasOwnProperty_1;
      var isPrototypeOf$1 = objectIsPrototypeOf;
      var anObject = anObject$9;
      var toIndexedObject$1 = toIndexedObject$7;
      var toPropertyKey = toPropertyKey$3;
      var $toString = toString$3;
      var createPropertyDescriptor = createPropertyDescriptor$5;
      var nativeObjectCreate = objectCreate;
      var objectKeys = objectKeys$2;
      var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
      var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
      var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
      var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
      var definePropertyModule = objectDefineProperty;
      var definePropertiesModule = objectDefineProperties;
      var propertyIsEnumerableModule = objectPropertyIsEnumerable;
      var defineBuiltIn = defineBuiltIn$8;
      var defineBuiltInAccessor$1 = defineBuiltInAccessor$4;
      var shared$2 = shared$6;
      var sharedKey = sharedKey$4;
      var hiddenKeys = hiddenKeys$6;
      var uid = uid$4;
      var wellKnownSymbol$2 = wellKnownSymbol$j;
      var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
      var defineWellKnownSymbol$g = wellKnownSymbolDefine;
      var defineSymbolToPrimitive$1 = symbolDefineToPrimitive;
      var setToStringTag$5 = setToStringTag$9;
      var InternalStateModule$1 = internalState;
      var $forEach = arrayIteration.forEach;
      var HIDDEN = sharedKey("hidden");
      var SYMBOL = "Symbol";
      var PROTOTYPE = "prototype";
      var setInternalState$1 = InternalStateModule$1.set;
      var getInternalState$1 = InternalStateModule$1.getterFor(SYMBOL);
      var ObjectPrototype = Object[PROTOTYPE];
      var $Symbol = globalThis$7.Symbol;
      var SymbolPrototype$1 = $Symbol && $Symbol[PROTOTYPE];
      var RangeError$1 = globalThis$7.RangeError;
      var TypeError$1 = globalThis$7.TypeError;
      var QObject = globalThis$7.QObject;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
      var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
      var push$1 = uncurryThis$3([].push);
      var AllSymbols = shared$2("symbols");
      var ObjectPrototypeSymbols = shared$2("op-symbols");
      var WellKnownSymbolsStore = shared$2("wks");
      var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var fallbackDefineProperty = function(O, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor)
          delete ObjectPrototype[P];
        nativeDefineProperty(O, P, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
          nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
      };
      var setSymbolDescriptor = DESCRIPTORS$2 && fails$2(function() {
        return nativeObjectCreate(nativeDefineProperty({}, "a", {
          get: function() {
            return nativeDefineProperty(this, "a", { value: 7 }).a;
          }
        })).a !== 7;
      }) ? fallbackDefineProperty : nativeDefineProperty;
      var wrap$5 = function(tag, description) {
        var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype$1);
        setInternalState$1(symbol, {
          type: SYMBOL,
          tag,
          description
        });
        if (!DESCRIPTORS$2)
          symbol.description = description;
        return symbol;
      };
      var $defineProperty = function defineProperty2(O, P, Attributes) {
        if (O === ObjectPrototype)
          $defineProperty(ObjectPrototypeSymbols, P, Attributes);
        anObject(O);
        var key = toPropertyKey(P);
        anObject(Attributes);
        if (hasOwn$3(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!hasOwn$3(O, HIDDEN))
              nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
            O[HIDDEN][key] = true;
          } else {
            if (hasOwn$3(O, HIDDEN) && O[HIDDEN][key])
              O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
          }
          return setSymbolDescriptor(O, key, Attributes);
        }
        return nativeDefineProperty(O, key, Attributes);
      };
      var $defineProperties = function defineProperties(O, Properties2) {
        anObject(O);
        var properties = toIndexedObject$1(Properties2);
        var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys2, function(key) {
          if (!DESCRIPTORS$2 || call$2($propertyIsEnumerable, properties, key))
            $defineProperty(O, key, properties[key]);
        });
        return O;
      };
      var $create = function create2(O, Properties2) {
        return Properties2 === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties2);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        var P = toPropertyKey(V);
        var enumerable = call$2(nativePropertyIsEnumerable, this, P);
        if (this === ObjectPrototype && hasOwn$3(AllSymbols, P) && !hasOwn$3(ObjectPrototypeSymbols, P))
          return false;
        return enumerable || !hasOwn$3(this, P) || !hasOwn$3(AllSymbols, P) || hasOwn$3(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O, P) {
        var it = toIndexedObject$1(O);
        var key = toPropertyKey(P);
        if (it === ObjectPrototype && hasOwn$3(AllSymbols, key) && !hasOwn$3(ObjectPrototypeSymbols, key))
          return;
        var descriptor2 = nativeGetOwnPropertyDescriptor(it, key);
        if (descriptor2 && hasOwn$3(AllSymbols, key) && !(hasOwn$3(it, HIDDEN) && it[HIDDEN][key])) {
          descriptor2.enumerable = true;
        }
        return descriptor2;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(O) {
        var names = nativeGetOwnPropertyNames(toIndexedObject$1(O));
        var result = [];
        $forEach(names, function(key) {
          if (!hasOwn$3(AllSymbols, key) && !hasOwn$3(hiddenKeys, key))
            push$1(result, key);
        });
        return result;
      };
      var $getOwnPropertySymbols = function(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$1(O));
        var result = [];
        $forEach(names, function(key) {
          if (hasOwn$3(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$3(ObjectPrototype, key))) {
            push$1(result, AllSymbols[key]);
          }
        });
        return result;
      };
      if (!NATIVE_SYMBOL$4) {
        $Symbol = function Symbol2() {
          if (isPrototypeOf$1(SymbolPrototype$1, this))
            throw new TypeError$1("Symbol is not a constructor");
          var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
          var tag = uid(description);
          var setter = function(value) {
            var $this = this === void 0 ? globalThis$7 : this;
            if ($this === ObjectPrototype)
              call$2(setter, ObjectPrototypeSymbols, value);
            if (hasOwn$3($this, HIDDEN) && hasOwn$3($this[HIDDEN], tag))
              $this[HIDDEN][tag] = false;
            var descriptor2 = createPropertyDescriptor(1, value);
            try {
              setSymbolDescriptor($this, tag, descriptor2);
            } catch (error) {
              if (!(error instanceof RangeError$1))
                throw error;
              fallbackDefineProperty($this, tag, descriptor2);
            }
          };
          if (DESCRIPTORS$2 && USE_SETTER)
            setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
          return wrap$5(tag, description);
        };
        SymbolPrototype$1 = $Symbol[PROTOTYPE];
        defineBuiltIn(SymbolPrototype$1, "toString", function toString2() {
          return getInternalState$1(this).tag;
        });
        defineBuiltIn($Symbol, "withoutSetter", function(description) {
          return wrap$5(uid(description), description);
        });
        propertyIsEnumerableModule.f = $propertyIsEnumerable;
        definePropertyModule.f = $defineProperty;
        definePropertiesModule.f = $defineProperties;
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        getOwnPropertySymbolsModule$1.f = $getOwnPropertySymbols;
        wrappedWellKnownSymbolModule.f = function(name2) {
          return wrap$5(wellKnownSymbol$2(name2), name2);
        };
        if (DESCRIPTORS$2) {
          defineBuiltInAccessor$1(SymbolPrototype$1, "description", {
            configurable: true,
            get: function description() {
              return getInternalState$1(this).description;
            }
          });
          {
            defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
          }
        }
      }
      $$6({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$4, sham: !NATIVE_SYMBOL$4 }, {
        Symbol: $Symbol
      });
      $forEach(objectKeys(WellKnownSymbolsStore), function(name2) {
        defineWellKnownSymbol$g(name2);
      });
      $$6({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$4 }, {
        useSetter: function() {
          USE_SETTER = true;
        },
        useSimple: function() {
          USE_SETTER = false;
        }
      });
      $$6({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$4, sham: !DESCRIPTORS$2 }, {
        // `Object.create` method
        // https://tc39.es/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty,
        // `Object.defineProperties` method
        // https://tc39.es/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
      });
      $$6({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$4 }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames
      });
      defineSymbolToPrimitive$1();
      setToStringTag$5($Symbol, SYMBOL);
      hiddenKeys[HIDDEN] = true;
      var NATIVE_SYMBOL$3 = symbolConstructorDetection;
      var symbolRegistryDetection = NATIVE_SYMBOL$3 && !!Symbol["for"] && !!Symbol.keyFor;
      var $$5 = _export;
      var getBuiltIn$2 = getBuiltIn$a;
      var hasOwn$2 = hasOwnProperty_1;
      var toString$2 = toString$3;
      var shared$1 = shared$6;
      var NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;
      var StringToSymbolRegistry = shared$1("string-to-symbol-registry");
      var SymbolToStringRegistry$1 = shared$1("symbol-to-string-registry");
      $$5({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, {
        "for": function(key) {
          var string = toString$2(key);
          if (hasOwn$2(StringToSymbolRegistry, string))
            return StringToSymbolRegistry[string];
          var symbol = getBuiltIn$2("Symbol")(string);
          StringToSymbolRegistry[string] = symbol;
          SymbolToStringRegistry$1[symbol] = string;
          return symbol;
        }
      });
      var $$4 = _export;
      var hasOwn$1 = hasOwnProperty_1;
      var isSymbol$2 = isSymbol$5;
      var tryToString = tryToString$4;
      var shared = shared$6;
      var NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $$4({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
        keyFor: function keyFor(sym) {
          if (!isSymbol$2(sym))
            throw new TypeError(tryToString(sym) + " is not a symbol");
          if (hasOwn$1(SymbolToStringRegistry, sym))
            return SymbolToStringRegistry[sym];
        }
      });
      var NATIVE_BIND = functionBindNative;
      var FunctionPrototype$1 = Function.prototype;
      var apply$2 = FunctionPrototype$1.apply;
      var call$1 = FunctionPrototype$1.call;
      var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call$1.bind(apply$2) : function() {
        return call$1.apply(apply$2, arguments);
      });
      var uncurryThis$2 = functionUncurryThis;
      var isArray = isArray$4;
      var isCallable$2 = isCallable$k;
      var classof = classofRaw$2;
      var toString$1 = toString$3;
      var push = uncurryThis$2([].push);
      var getJsonReplacerFunction = function(replacer) {
        if (isCallable$2(replacer))
          return replacer;
        if (!isArray(replacer))
          return;
        var rawLength = replacer.length;
        var keys2 = [];
        for (var i = 0; i < rawLength; i++) {
          var element = replacer[i];
          if (typeof element == "string")
            push(keys2, element);
          else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String")
            push(keys2, toString$1(element));
        }
        var keysLength = keys2.length;
        var root2 = true;
        return function(key, value) {
          if (root2) {
            root2 = false;
            return value;
          }
          if (isArray(this))
            return value;
          for (var j = 0; j < keysLength; j++)
            if (keys2[j] === key)
              return value;
        };
      };
      var $$3 = _export;
      var getBuiltIn$1 = getBuiltIn$a;
      var apply$1 = functionApply;
      var call = functionCall;
      var uncurryThis$1 = functionUncurryThis;
      var fails$1 = fails$k;
      var isCallable$1 = isCallable$k;
      var isSymbol$1 = isSymbol$5;
      var arraySlice = arraySlice$2;
      var getReplacerFunction = getJsonReplacerFunction;
      var NATIVE_SYMBOL$2 = symbolConstructorDetection;
      var $String = String;
      var $stringify = getBuiltIn$1("JSON", "stringify");
      var exec = uncurryThis$1(/./.exec);
      var charAt = uncurryThis$1("".charAt);
      var charCodeAt = uncurryThis$1("".charCodeAt);
      var replace$1 = uncurryThis$1("".replace);
      var numberToString = uncurryThis$1(1 .toString);
      var tester = /[\uD800-\uDFFF]/g;
      var low = /^[\uD800-\uDBFF]$/;
      var hi = /^[\uDC00-\uDFFF]$/;
      var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$2 || fails$1(function() {
        var symbol = getBuiltIn$1("Symbol")("stringify detection");
        return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
      });
      var ILL_FORMED_UNICODE = fails$1(function() {
        return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
      });
      var stringifyWithSymbolsFix = function(it, replacer) {
        var args = arraySlice(arguments);
        var $replacer = getReplacerFunction(replacer);
        if (!isCallable$1($replacer) && (it === void 0 || isSymbol$1(it)))
          return;
        args[1] = function(key, value) {
          if (isCallable$1($replacer))
            value = call($replacer, this, $String(key), value);
          if (!isSymbol$1(value))
            return value;
        };
        return apply$1($stringify, null, args);
      };
      var fixIllFormed = function(match2, offset, string) {
        var prev = charAt(string, offset - 1);
        var next2 = charAt(string, offset + 1);
        if (exec(low, match2) && !exec(hi, next2) || exec(hi, match2) && !exec(low, prev)) {
          return "\\u" + numberToString(charCodeAt(match2, 0), 16);
        }
        return match2;
      };
      if ($stringify) {
        $$3({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          stringify: function stringify(it, replacer, space) {
            var args = arraySlice(arguments);
            var result = apply$1(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
            return ILL_FORMED_UNICODE && typeof result == "string" ? replace$1(result, tester, fixIllFormed) : result;
          }
        });
      }
      var $$2 = _export;
      var NATIVE_SYMBOL$1 = symbolConstructorDetection;
      var fails = fails$k;
      var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
      var toObject = toObject$8;
      var FORCED = !NATIVE_SYMBOL$1 || fails(function() {
        getOwnPropertySymbolsModule.f(1);
      });
      $$2({ target: "Object", stat: true, forced: FORCED }, {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
          var $getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
          return $getOwnPropertySymbols2 ? $getOwnPropertySymbols2(toObject(it)) : [];
        }
      });
      var defineWellKnownSymbol$f = wellKnownSymbolDefine;
      defineWellKnownSymbol$f("asyncIterator");
      var $$1 = _export;
      var DESCRIPTORS$1 = descriptors;
      var globalThis$6 = globalThis_1;
      var uncurryThis = functionUncurryThis;
      var hasOwn = hasOwnProperty_1;
      var isCallable = isCallable$k;
      var isPrototypeOf = objectIsPrototypeOf;
      var toString = toString$3;
      var defineBuiltInAccessor = defineBuiltInAccessor$4;
      var copyConstructorProperties = copyConstructorProperties$2;
      var NativeSymbol = globalThis$6.Symbol;
      var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
      if (DESCRIPTORS$1 && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
      NativeSymbol().description !== void 0)) {
        var EmptyStringDescriptionStore = {};
        var SymbolWrapper = function Symbol2() {
          var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
          var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
          if (description === "")
            EmptyStringDescriptionStore[result] = true;
          return result;
        };
        copyConstructorProperties(SymbolWrapper, NativeSymbol);
        SymbolWrapper.prototype = SymbolPrototype;
        SymbolPrototype.constructor = SymbolWrapper;
        var NATIVE_SYMBOL = String(NativeSymbol("description detection")) === "Symbol(description detection)";
        var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
        var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
        var regexp = /^Symbol\((.*)\)[^)]+$/;
        var replace = uncurryThis("".replace);
        var stringSlice = uncurryThis("".slice);
        defineBuiltInAccessor(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            var symbol = thisSymbolValue(this);
            if (hasOwn(EmptyStringDescriptionStore, symbol))
              return "";
            var string = symbolDescriptiveString(symbol);
            var desc2 = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
            return desc2 === "" ? void 0 : desc2;
          }
        });
        $$1({ global: true, constructor: true, forced: true }, {
          Symbol: SymbolWrapper
        });
      }
      var defineWellKnownSymbol$e = wellKnownSymbolDefine;
      defineWellKnownSymbol$e("hasInstance");
      var defineWellKnownSymbol$d = wellKnownSymbolDefine;
      defineWellKnownSymbol$d("isConcatSpreadable");
      var defineWellKnownSymbol$c = wellKnownSymbolDefine;
      defineWellKnownSymbol$c("iterator");
      var defineWellKnownSymbol$b = wellKnownSymbolDefine;
      defineWellKnownSymbol$b("match");
      var defineWellKnownSymbol$a = wellKnownSymbolDefine;
      defineWellKnownSymbol$a("matchAll");
      var defineWellKnownSymbol$9 = wellKnownSymbolDefine;
      defineWellKnownSymbol$9("replace");
      var defineWellKnownSymbol$8 = wellKnownSymbolDefine;
      defineWellKnownSymbol$8("search");
      var defineWellKnownSymbol$7 = wellKnownSymbolDefine;
      defineWellKnownSymbol$7("species");
      var defineWellKnownSymbol$6 = wellKnownSymbolDefine;
      defineWellKnownSymbol$6("split");
      var defineWellKnownSymbol$5 = wellKnownSymbolDefine;
      var defineSymbolToPrimitive = symbolDefineToPrimitive;
      defineWellKnownSymbol$5("toPrimitive");
      defineSymbolToPrimitive();
      var getBuiltIn = getBuiltIn$a;
      var defineWellKnownSymbol$4 = wellKnownSymbolDefine;
      var setToStringTag$4 = setToStringTag$9;
      defineWellKnownSymbol$4("toStringTag");
      setToStringTag$4(getBuiltIn("Symbol"), "Symbol");
      var defineWellKnownSymbol$3 = wellKnownSymbolDefine;
      defineWellKnownSymbol$3("unscopables");
      var globalThis$5 = globalThis_1;
      var setToStringTag$3 = setToStringTag$9;
      setToStringTag$3(globalThis$5.JSON, "JSON", true);
      var setToStringTag$2 = setToStringTag$9;
      setToStringTag$2(Math, "Math", true);
      var $ = _export;
      var globalThis$4 = globalThis_1;
      var setToStringTag$1 = setToStringTag$9;
      $({ global: true }, { Reflect: {} });
      setToStringTag$1(globalThis$4.Reflect, "Reflect", true);
      var path$1 = path$3;
      path$1.Symbol;
      var domIterables = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
      };
      var documentCreateElement = documentCreateElement$2;
      var classList = documentCreateElement("span").classList;
      var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
      var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
      var toIndexedObject = toIndexedObject$7;
      var addToUnscopables = addToUnscopables$4;
      var Iterators = iterators;
      var InternalStateModule = internalState;
      var defineProperty$4 = objectDefineProperty.f;
      var defineIterator = iteratorDefine;
      var createIterResultObject = createIterResultObject$2;
      var DESCRIPTORS = descriptors;
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
        setInternalState(this, {
          type: ARRAY_ITERATOR,
          target: toIndexedObject(iterated),
          // target
          index: 0,
          // next index
          kind
          // kind
        });
      }, function() {
        var state = getInternalState(this);
        var target = state.target;
        var index = state.index++;
        if (!target || index >= target.length) {
          state.target = null;
          return createIterResultObject(void 0, true);
        }
        switch (state.kind) {
          case "keys":
            return createIterResultObject(index, false);
          case "values":
            return createIterResultObject(target[index], false);
        }
        return createIterResultObject([index, target[index]], false);
      }, "values");
      var values = Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
      if (DESCRIPTORS && values.name !== "values")
        try {
          defineProperty$4(values, "name", { value: "values" });
        } catch (error) {
        }
      var globalThis$3 = globalThis_1;
      var DOMIterables = domIterables;
      var DOMTokenListPrototype = domTokenListPrototype;
      var ArrayIteratorMethods = es_array_iterator;
      var createNonEnumerableProperty = createNonEnumerableProperty$4;
      var setToStringTag = setToStringTag$9;
      var wellKnownSymbol$1 = wellKnownSymbol$j;
      var ITERATOR = wellKnownSymbol$1("iterator");
      var ArrayValues = ArrayIteratorMethods.values;
      var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
        if (CollectionPrototype) {
          if (CollectionPrototype[ITERATOR] !== ArrayValues)
            try {
              createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
            } catch (error) {
              CollectionPrototype[ITERATOR] = ArrayValues;
            }
          setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
          if (DOMIterables[COLLECTION_NAME2])
            for (var METHOD_NAME in ArrayIteratorMethods) {
              if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                try {
                  createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                } catch (error) {
                  CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                }
            }
        }
      };
      for (var COLLECTION_NAME in DOMIterables) {
        handlePrototype(globalThis$3[COLLECTION_NAME] && globalThis$3[COLLECTION_NAME].prototype, COLLECTION_NAME);
      }
      handlePrototype(DOMTokenListPrototype, "DOMTokenList");
      var wellKnownSymbol = wellKnownSymbol$j;
      var defineProperty$3 = objectDefineProperty.f;
      var METADATA = wellKnownSymbol("metadata");
      var FunctionPrototype = Function.prototype;
      if (FunctionPrototype[METADATA] === void 0) {
        defineProperty$3(FunctionPrototype, METADATA, {
          value: null
        });
      }
      var globalThis$2 = globalThis_1;
      var defineWellKnownSymbol$2 = wellKnownSymbolDefine;
      var defineProperty$2 = objectDefineProperty.f;
      var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
      var Symbol$3 = globalThis$2.Symbol;
      defineWellKnownSymbol$2("asyncDispose");
      if (Symbol$3) {
        var descriptor$1 = getOwnPropertyDescriptor$1(Symbol$3, "asyncDispose");
        if (descriptor$1.enumerable && descriptor$1.configurable && descriptor$1.writable) {
          defineProperty$2(Symbol$3, "asyncDispose", { value: descriptor$1.value, enumerable: false, configurable: false, writable: false });
        }
      }
      var globalThis$1 = globalThis_1;
      var defineWellKnownSymbol$1 = wellKnownSymbolDefine;
      var defineProperty$1 = objectDefineProperty.f;
      var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
      var Symbol$2 = globalThis$1.Symbol;
      defineWellKnownSymbol$1("dispose");
      if (Symbol$2) {
        var descriptor = getOwnPropertyDescriptor(Symbol$2, "dispose");
        if (descriptor.enumerable && descriptor.configurable && descriptor.writable) {
          defineProperty$1(Symbol$2, "dispose", { value: descriptor.value, enumerable: false, configurable: false, writable: false });
        }
      }
      var defineWellKnownSymbol = wellKnownSymbolDefine;
      defineWellKnownSymbol("metadata");
      function polyfill() {
        var w = window;
        var d = document;
        var Element2 = w.HTMLElement || w.Element;
        var SCROLL_TIME = 200;
        var original = {
          scroll: w.scroll || w.scrollTo,
          scrollBy: w.scrollBy,
          elementScroll: Element2.prototype.scroll || scrollElement,
          scrollIntoView: Element2.prototype.scrollIntoView
        };
        var now2 = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;
        function scrollElement(x, y) {
          this.scrollLeft = x;
          this.scrollTop = y;
        }
        function ease(k) {
          return k;
        }
        function shouldBailOut(firstArg) {
          if (firstArg === null || typeof firstArg !== "object" || firstArg.behavior === void 0 || firstArg.behavior === "auto" || firstArg.behavior === "instant") {
            return true;
          }
          if (typeof firstArg === "object" && firstArg.behavior === "smooth") {
            return false;
          }
          throw new TypeError(
            "behavior member of ScrollOptions " + firstArg.behavior + " is not a valid value for enumeration ScrollBehavior."
          );
        }
        function step(context) {
          var time2 = now2();
          var value;
          var currentX;
          var currentY;
          var elapsed = (time2 - context.startTime) / SCROLL_TIME;
          elapsed = elapsed > 1 ? 1 : elapsed;
          value = ease(elapsed);
          currentX = context.startX + (context.x - context.startX) * value;
          currentY = context.startY + (context.y - context.startY) * value;
          context.method.call(context.scrollable, currentX, currentY);
          if (currentX !== context.x || currentY !== context.y) {
            w.requestAnimationFrame(step.bind(w, context));
          }
        }
        function smoothScroll(el, x, y) {
          var scrollable;
          var startX;
          var startY;
          var method;
          var startTime = now2();
          if (el === d.body) {
            scrollable = w;
            startX = w.scrollX || w.pageXOffset;
            startY = w.scrollY || w.pageYOffset;
            method = original.scroll;
          } else {
            scrollable = el;
            startX = el.scrollLeft;
            startY = el.scrollTop;
            method = scrollElement;
          }
          step({
            scrollable,
            method,
            startTime,
            startX,
            startY,
            x,
            y
          });
        }
        w.scroll = w.scrollTo = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0]) === true) {
            original.scroll.call(
              w,
              arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : w.scrollX || w.pageXOffset,
              // use top prop, second argument if present or fallback to scrollY
              arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset
            );
            return;
          }
          smoothScroll.call(
            w,
            d.body,
            arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset,
            arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset
          );
        };
        w.scrollBy = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0])) {
            original.scrollBy.call(
              w,
              arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== "object" ? arguments[0] : 0,
              arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0
            );
            return;
          }
          smoothScroll.call(
            w,
            d.body,
            ~~arguments[0].left + (w.scrollX || w.pageXOffset),
            ~~arguments[0].top + (w.scrollY || w.pageYOffset)
          );
        };
        Element2.prototype.scroll = Element2.prototype.scrollTo = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0]) === true) {
            if (typeof arguments[0] === "number" && arguments[1] === void 0) {
              throw new SyntaxError("Value could not be converted");
            }
            original.elementScroll.call(
              this,
              // use left prop, first number argument or fallback to scrollLeft
              arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== "object" ? ~~arguments[0] : this.scrollLeft,
              // use top prop, second argument or fallback to scrollTop
              arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop
            );
            return;
          }
          var left = arguments[0].left;
          var top2 = arguments[0].top;
          smoothScroll.call(
            this,
            this,
            typeof left === "undefined" ? this.scrollLeft : ~~left,
            typeof top2 === "undefined" ? this.scrollTop : ~~top2
          );
        };
        Element2.prototype.scrollBy = function() {
          if (arguments[0] === void 0) {
            return;
          }
          if (shouldBailOut(arguments[0]) === true) {
            original.elementScroll.call(
              this,
              arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft,
              arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop
            );
            return;
          }
          this.scroll({
            left: ~~arguments[0].left + this.scrollLeft,
            top: ~~arguments[0].top + this.scrollTop,
            behavior: arguments[0].behavior
          });
        };
        function canOverflow(el, axis) {
          var overflowValue = w.getComputedStyle(el, null)["overflow" + axis];
          return overflowValue === "auto" || overflowValue === "scroll";
        }
        function hasScrollableSpace(el, axis) {
          if (axis === "Y") {
            return el.clientHeight + 0 < el.scrollHeight;
          }
          if (axis === "X") {
            return el.clientWidth + 0 < el.scrollWidth;
          }
        }
        function isScrollable(el) {
          var isScrollableY = hasScrollableSpace(el, "Y") && canOverflow(el, "Y");
          var isScrollableX = hasScrollableSpace(el, "X") && canOverflow(el, "X");
          return isScrollableY || isScrollableX;
        }
        function findScrollableParent(el) {
          while (el !== d.body && isScrollable(el) === false) {
            el = el.parentNode || el.host;
          }
          return el;
        }
        Element2.prototype.scrollIntoView = function() {
          if (shouldBailOut(arguments[0]) === true) {
            original.scrollIntoView.call(this, arguments[0] === void 0 ? true : arguments[0]);
            return;
          }
          var scrollableParent = findScrollableParent(this);
          var parentRects = scrollableParent.getBoundingClientRect();
          var clientRects = this.getBoundingClientRect();
          if (scrollableParent !== d.body) {
            smoothScroll.call(
              this,
              scrollableParent,
              scrollableParent.scrollLeft + clientRects.left - parentRects.left,
              scrollableParent.scrollTop + clientRects.top - parentRects.top
            );
            if (w.getComputedStyle(scrollableParent).position !== "fixed") {
              w.scrollBy({
                left: parentRects.left,
                top: parentRects.top,
                behavior: "smooth"
              });
            }
          } else {
            w.scrollBy({
              left: clientRects.left,
              top: clientRects.top,
              behavior: "smooth"
            });
          }
        };
      }
      polyfill();
      /*! (c) Andrea Giammarchi - ISC */
      try {
        new EventTarget();
      } catch (EventTarget2) {
        (function(Object2, wm) {
          var create2 = Object2.create;
          var defineProperty2 = Object2.defineProperty;
          var proto = EventTarget3.prototype;
          define2(proto, "addEventListener", function(type, listener, options2) {
            for (var secret = wm.get(this), listeners = secret[type] || (secret[type] = []), i = 0, length = listeners.length; i < length; i++) {
              if (listeners[i].listener === listener)
                return;
            }
            listeners.push({ target: this, listener, options: options2 });
          });
          define2(proto, "dispatchEvent", function(event) {
            var secret = wm.get(this);
            var listeners = secret[event.type];
            if (listeners) {
              define2(event, "target", this);
              define2(event, "currentTarget", this);
              listeners.slice(0).some(dispatch, event);
              delete event.currentTarget;
              delete event.target;
            }
            return true;
          });
          define2(proto, "removeEventListener", function(type, listener) {
            for (var secret = wm.get(this), listeners = secret[type] || (secret[type] = []), i = 0, length = listeners.length; i < length; i++) {
              if (listeners[i].listener === listener) {
                listeners.splice(i, 1);
                return;
              }
            }
          });
          self.EventTarget = EventTarget3;
          function EventTarget3() {
            wm.set(this, create2(null));
          }
          function define2(target, name2, value) {
            defineProperty2(target, name2, {
              configurable: true,
              writable: true,
              value
            });
          }
          function dispatch(info) {
            var options2 = info.options;
            if (options2 && options2.once)
              info.target.removeEventListener(this.type, info.listener);
            if (typeof info.listener === "function")
              info.listener.call(info.target, this);
            else
              info.listener.handleEvent(this);
            return this._stopImmediatePropagationFlag;
          }
        })(Object, /* @__PURE__ */ new WeakMap());
      }
      const softkeys = "_softkeys_8cyoa_1";
      const previous = "_previous_8cyoa_13";
      const current = "_current_8cyoa_14";
      const loading$1 = "_loading_8cyoa_58";
      const styles$s = {
        softkeys,
        previous,
        current,
        loading: loading$1
      };
      var COMPLETE = "complete", CANCELED = "canceled";
      function raf(task) {
        if ("requestAnimationFrame" in window) {
          return window.requestAnimationFrame(task);
        }
        setTimeout(task, 16);
      }
      function setElementScroll(element, x, y) {
        if (element.self === element) {
          element.scrollTo(x, y);
        } else {
          element.scrollLeft = x;
          element.scrollTop = y;
        }
      }
      function getTargetScrollLocation(scrollSettings, parent) {
        var align = scrollSettings.align, target = scrollSettings.target, targetPosition = target.getBoundingClientRect(), parentPosition, x, y, differenceX, differenceY, targetWidth, targetHeight, leftAlign = align && align.left != null ? align.left : 0.5, topAlign = align && align.top != null ? align.top : 0.5, leftOffset = align && align.leftOffset != null ? align.leftOffset : 0, topOffset = align && align.topOffset != null ? align.topOffset : 0, leftScalar = leftAlign, topScalar = topAlign;
        if (scrollSettings.isWindow(parent)) {
          targetWidth = Math.min(targetPosition.width, parent.innerWidth);
          targetHeight = Math.min(targetPosition.height, parent.innerHeight);
          x = targetPosition.left + parent.pageXOffset - parent.innerWidth * leftScalar + targetWidth * leftScalar;
          y = targetPosition.top + parent.pageYOffset - parent.innerHeight * topScalar + targetHeight * topScalar;
          x -= leftOffset;
          y -= topOffset;
          x = scrollSettings.align.lockX ? parent.pageXOffset : x;
          y = scrollSettings.align.lockY ? parent.pageYOffset : y;
          differenceX = x - parent.pageXOffset;
          differenceY = y - parent.pageYOffset;
        } else {
          targetWidth = targetPosition.width;
          targetHeight = targetPosition.height;
          parentPosition = parent.getBoundingClientRect();
          var offsetLeft = targetPosition.left - (parentPosition.left - parent.scrollLeft);
          var offsetTop = targetPosition.top - (parentPosition.top - parent.scrollTop);
          x = offsetLeft + targetWidth * leftScalar - parent.clientWidth * leftScalar;
          y = offsetTop + targetHeight * topScalar - parent.clientHeight * topScalar;
          x -= leftOffset;
          y -= topOffset;
          x = Math.max(Math.min(x, parent.scrollWidth - parent.clientWidth), 0);
          y = Math.max(Math.min(y, parent.scrollHeight - parent.clientHeight), 0);
          x = scrollSettings.align.lockX ? parent.scrollLeft : x;
          y = scrollSettings.align.lockY ? parent.scrollTop : y;
          differenceX = x - parent.scrollLeft;
          differenceY = y - parent.scrollTop;
        }
        return {
          x,
          y,
          differenceX,
          differenceY
        };
      }
      function animate$1(parent) {
        var scrollSettings = parent._scrollSettings;
        if (!scrollSettings) {
          return;
        }
        var maxSynchronousAlignments = scrollSettings.maxSynchronousAlignments;
        var location2 = getTargetScrollLocation(scrollSettings, parent), time2 = Date.now() - scrollSettings.startTime, timeValue = Math.min(1 / scrollSettings.time * time2, 1);
        if (scrollSettings.endIterations >= maxSynchronousAlignments) {
          setElementScroll(parent, location2.x, location2.y);
          parent._scrollSettings = null;
          return scrollSettings.end(COMPLETE);
        }
        var easeValue = 1 - scrollSettings.ease(timeValue);
        setElementScroll(
          parent,
          location2.x - location2.differenceX * easeValue,
          location2.y - location2.differenceY * easeValue
        );
        if (time2 >= scrollSettings.time) {
          scrollSettings.endIterations++;
          scrollSettings.scrollAncestor && animate$1(scrollSettings.scrollAncestor);
          animate$1(parent);
          return;
        }
        raf(animate$1.bind(null, parent));
      }
      function defaultIsWindow(target) {
        return target.self === target;
      }
      function transitionScrollTo(target, parent, settings, scrollAncestor, callback2) {
        var idle = !parent._scrollSettings, lastSettings = parent._scrollSettings, now2 = Date.now(), cancelHandler, passiveOptions = { passive: true };
        if (lastSettings) {
          lastSettings.end(CANCELED);
        }
        function end(endType) {
          parent._scrollSettings = null;
          if (parent.parentElement && parent.parentElement._scrollSettings) {
            parent.parentElement._scrollSettings.end(endType);
          }
          if (settings.debug) {
            console.log("Scrolling ended with type", endType, "for", parent);
          }
          callback2(endType);
          if (cancelHandler) {
            parent.removeEventListener("touchstart", cancelHandler, passiveOptions);
            parent.removeEventListener("wheel", cancelHandler, passiveOptions);
          }
        }
        var maxSynchronousAlignments = settings.maxSynchronousAlignments;
        if (maxSynchronousAlignments == null) {
          maxSynchronousAlignments = 3;
        }
        parent._scrollSettings = {
          startTime: now2,
          endIterations: 0,
          target,
          time: settings.time,
          ease: settings.ease,
          align: settings.align,
          isWindow: settings.isWindow || defaultIsWindow,
          maxSynchronousAlignments,
          end,
          scrollAncestor
        };
        if (!("cancellable" in settings) || settings.cancellable) {
          cancelHandler = end.bind(null, CANCELED);
          parent.addEventListener("touchstart", cancelHandler, passiveOptions);
          parent.addEventListener("wheel", cancelHandler, passiveOptions);
        }
        if (idle) {
          animate$1(parent);
        }
        return cancelHandler;
      }
      function defaultIsScrollable(element) {
        return "pageXOffset" in element || (element.scrollHeight !== element.clientHeight || element.scrollWidth !== element.clientWidth) && getComputedStyle(element).overflow !== "hidden";
      }
      function defaultValidTarget() {
        return true;
      }
      function findParentElement(el) {
        if (el.assignedSlot) {
          return findParentElement(el.assignedSlot);
        }
        if (el.parentElement) {
          if (el.parentElement.tagName.toLowerCase() === "body") {
            return el.parentElement.ownerDocument.defaultView || el.parentElement.ownerDocument.ownerWindow;
          }
          return el.parentElement;
        }
        if (el.getRootNode) {
          var parent = el.getRootNode();
          if (parent.nodeType === 11) {
            return parent.host;
          }
        }
      }
      var scrollIntoView$1 = function(target, settings, callback2) {
        if (!target) {
          return;
        }
        if (typeof settings === "function") {
          callback2 = settings;
          settings = null;
        }
        if (!settings) {
          settings = {};
        }
        settings.time = isNaN(settings.time) ? 1e3 : settings.time;
        settings.ease = settings.ease || function(v) {
          return 1 - Math.pow(1 - v, v / 2);
        };
        settings.align = settings.align || {};
        var parent = findParentElement(target), parents = 1;
        function done(endType) {
          parents--;
          if (!parents) {
            callback2 && callback2(endType);
          }
        }
        var validTarget = settings.validTarget || defaultValidTarget;
        var isScrollable = settings.isScrollable;
        if (settings.debug) {
          console.log("About to scroll to", target);
          if (!parent) {
            console.error("Target did not have a parent, is it mounted in the DOM?");
          }
        }
        var scrollingElements = [];
        while (parent) {
          if (settings.debug) {
            console.log("Scrolling parent node", parent);
          }
          if (validTarget(parent, parents) && (isScrollable ? isScrollable(parent, defaultIsScrollable) : defaultIsScrollable(parent))) {
            parents++;
            scrollingElements.push(parent);
          }
          parent = findParentElement(parent);
          if (!parent) {
            done(COMPLETE);
            break;
          }
        }
        return scrollingElements.reduce((cancel, parent2, index) => transitionScrollTo(target, parent2, settings, scrollingElements[index + 1], done), null);
      };
      const scrollIntoViewNPM = /* @__PURE__ */ getDefaultExportFromCjs(scrollIntoView$1);
      function noop() {
      }
      function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
      }
      function subscribe(store2, ...callbacks2) {
        if (store2 == null) {
          return noop;
        }
        const unsub = store2.subscribe(...callbacks2);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
      }
      function get_store_value(store2) {
        let value;
        subscribe(store2, (_) => value = _)();
        return value;
      }
      var subscriber_queue = [];
      function readable(value, start2) {
        return {
          subscribe: writable(value, start2).subscribe
        };
      }
      function writable(value, start2 = noop) {
        let stop;
        const subscribers = /* @__PURE__ */ new Set();
        function set2(new_value) {
          if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) {
              const run_queue = !subscriber_queue.length;
              for(let   subscriber of subscribers) {
                subscriber[1]();
                subscriber_queue.push(subscriber, value);
              }
              if (run_queue) {
                for (let i = 0; i < subscriber_queue.length; i += 2) {
                  subscriber_queue[i][0](subscriber_queue[i + 1]);
                }
                subscriber_queue.length = 0;
              }
            }
          }
        }
        function update(fn) {
          set2(fn(value));
        }
        function subscribe2(run2, invalidate = noop) {
          const subscriber = [run2, invalidate];
          subscribers.add(subscriber);
          if (subscribers.size === 1) {
            stop = start2(set2) || noop;
          }
          run2(value);
          return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0 && stop) {
              stop();
              stop = null;
            }
          };
        }
        return { set: set2, update, subscribe: subscribe2 };
      }
      function derived(stores2, fn, initial_value) {
        const single = !Array.isArray(stores2);
        const stores_array = single ? [stores2] : stores2;
        const auto2 = fn.length < 2;
        return readable(initial_value, (set2) => {
          let inited = false;
          const values2 = [];
          let pending2 = 0;
          let cleanup2 = noop;
          const sync = () => {
            if (pending2) {
              return;
            }
            cleanup2();
            const result = fn(single ? values2[0] : values2, set2);
            if (auto2) {
              set2(result);
            } else {
              cleanup2 = typeof result === "function" ? result : noop;
            }
          };
          const unsubscribers = stores_array.map(
            (store2, i) => subscribe(
              store2,
              (value) => {
                values2[i] = value;
                pending2 &= ~(1 << i);
                if (inited) {
                  sync();
                }
              },
              () => {
                pending2 |= 1 << i;
              }
            )
          );
          inited = true;
          sync();
          return function stop() {
            unsubscribers.forEach((a) => a());
            cleanup2();
          };
        });
      }
      function readonly(store2) {
        return {
          subscribe: store2.subscribe.bind(store2)
        };
      }
      const stores = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        derived,
        get: get_store_value,
        readable,
        readonly,
        writable
      }, Symbol.toStringTag, { value: "Module" }));
      exports("dJ", stores);
      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function sleep$1(ms) {
        if (ms === void 0) {
          return Promise.resolve();
        }
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      const cyrb53 = (str, seed = 0) => {
        let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
          ch = str.charCodeAt(i);
          h1 = Math.imul(h1 ^ ch, 2654435761);
          h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
        h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
        h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
        h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
      };
      function last$2(arr) {
        return arr[arr.length - 1];
      }
      const simpleHash = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
        }
        return hash >>> 0;
      };
      function clampImageDimension(imageHeight, imageWidth, maxHeight, maxWidth) {
        const widthPercent = maxWidth / imageWidth;
        const heightPercent = maxHeight / imageHeight;
        const smallestPercent = Math.min(widthPercent, heightPercent);
        return {
          w: imageWidth * smallestPercent,
          h: imageHeight * smallestPercent
        };
      }
      function calculateSampleSize(origWidth, origHeight, newWidth, newHeight) {
        const widthDivisor = origWidth / newWidth;
        const heightDivisor = origHeight / newHeight;
        return "#-moz-samplesize=" + Math.ceil(Math.max(widthDivisor, heightDivisor));
      }
      function formatTime(seconds) {
        const h2 = Math.floor(seconds / 3600);
        const m2 = Math.floor(seconds % 3600 / 60);
        const s = Math.round(seconds % 60);
        const t2 = [h2, m2 > 9 ? m2 : h2 ? "0" + m2 : m2 || "0", s > 9 ? s : "0" + s].filter(Boolean).join(":");
        return seconds < 0 && seconds ? `-${t2}` : t2;
      }
      function isToday(date2, today2 = /* @__PURE__ */ new Date()) {
        return date2.getDate() == today2.getDate() && date2.getMonth() == today2.getMonth() && date2.getFullYear() == today2.getFullYear();
      }
      function Array_from_DOMCursor(cursor) {
        return __async(this, null, function* () {
          const arr = [];
          return new Promise((res, err) => {
            cursor.onsuccess = function() {
              if (cursor.result) {
                arr.push(cursor.result);
                cursor.continue();
              } else {
                res(arr);
              }
            };
            cursor.onerror = function() {
              err(cursor.error);
            };
          });
        });
      }
      const keyList = Object.keys;
      function shallowEqual(a, b) {
        if (a === b)
          return true;
        if (!(a instanceof Object) || !(b instanceof Object))
          return false;
        var keys2 = keyList(a);
        var length = keys2.length;
        for (var i = 0; i < length; i++)
          if (!(keys2[i] in b))
            return false;
        for (var i = 0; i < length; i++)
          if (a[keys2[i]] !== b[keys2[i]])
            return false;
        return length === keyList(b).length;
      }
      function useStore(_readable, key) {
        const readable2 = () => typeof _readable === "function" ? _readable() : _readable;
        const initReadable = readable2();
        const [state, setState] = createSignal(
          key != void 0 ? initReadable && get_store_value(initReadable)[key] : initReadable && get_store_value(initReadable),
          {
            equals: (a, b) => {
              if (key != void 0) {
                return shallowEqual(a, b);
              } else {
                return false;
              }
            },
            name: "useStore"
          }
        );
        createRenderEffect(() => {
          var _a3;
          const unsub = (_a3 = readable2()) == null ? void 0 : _a3.subscribe((val) => {
            setState(() => key != void 0 ? val[key] : val);
          });
          unsub && onCleanup(unsub);
        });
        return state;
      }
      function centerScroll(el, sync = false, time2 = 200) {
        return new Promise((res) => {
          scrollIntoViewNPM(
            el,
            { time: sync ? 0 : time2, align: { left: 0 }, ease: (e2) => e2 },
            (type) => {
              res(type === "complete");
            }
          );
        });
      }
      const [isKeypressPaused, setKeypressPaused] = /* @__PURE__ */ createSignal(false);
      function pauseKeypress() {
        setKeypressPaused(true);
      }
      function resumeKeypress() {
        setKeypressPaused(false);
      }
      function useMessageChecks(message2, dialog2) {
        const lastReadOutgoing = useStore(() => dialog2().lastReadOutgoing);
        const check2 = () => message2() ? dialog2().$.chat.isSelf ? false : lastReadOutgoing() < message2().id : true;
        return check2;
      }
      const useKeypress = (keys2, handler, force = false) => {
        const eventListener = (event) => {
          if (isKeypressPaused() && !force)
            return;
          const _keys = [keys2].flat();
          if (_keys.includes(event.key)) {
            handler(event);
          }
        };
        window.addEventListener("keydown", eventListener, true);
        onCleanup(() => {
          window.removeEventListener("keydown", eventListener, true);
        });
      };
      function getScrollParent(node) {
        if (node == null) {
          return null;
        }
        if (node.scrollHeight > node.clientHeight) {
          return node;
        } else {
          return getScrollParent(node.parentNode);
        }
      }
      function scrollIntoView(element) {
        const scrollerElement = getScrollParent(element);
        if (!scrollerElement)
          return;
        const rect = element.getBoundingClientRect();
        if (rect.top - scrollerElement.offsetTop < 0) {
          element.scrollIntoView(true);
          return;
        }
        const diff = rect.bottom - (scrollerElement.offsetHeight + scrollerElement.offsetTop);
        if (diff >= -0.5) {
          element.scrollIntoView(false);
        }
      }
      function hexaToRgba(hexa) {
        const arr = [];
        const offset = hexa[0] === "#" ? 1 : 0;
        if (hexa.length === 5 + offset) {
          hexa = (offset ? "#" : "") + "0" + hexa.slice(offset);
        }
        if (hexa.length === 3 + offset) {
          for (let i = offset; i < hexa.length; ++i) {
            arr.push(parseInt(hexa[i] + hexa[i], 16));
          }
        } else if (hexa.length === 4 + offset) {
          for (let i = offset; i < hexa.length - 1; ++i) {
            arr.push(parseInt(hexa[i] + hexa[i], 16));
          }
          arr.push(parseInt(hexa[hexa.length - 1], 16));
        } else {
          for (let i = offset; i < hexa.length; i += 2) {
            arr.push(parseInt(hexa.slice(i, i + 2), 16));
          }
        }
        return arr;
      }
      function rgbaToHsla(r2, g, b, a = 1) {
        r2 /= 255, g /= 255, b /= 255;
        const max2 = Math.max(r2, g, b), min2 = Math.min(r2, g, b);
        let h2, s;
        const l2 = (max2 + min2) / 2;
        if (max2 === min2) {
          h2 = s = 0;
        } else {
          const d = max2 - min2;
          s = l2 > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
          switch (max2) {
            case r2:
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r2) / d + 2;
              break;
            case b:
              h2 = (r2 - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return {
          h: h2 * 360,
          s: s * 100,
          l: l2 * 100,
          a
        };
      }
      function hexaToHsla(hexa) {
        const rgba = hexaToRgba(hexa);
        return rgbaToHsla(rgba[0], rgba[1], rgba[2], rgba[3]);
      }
      function getPeerColorIndexById(peerId) {
        return Math.abs(peerId) % 7;
      }
      const DialogColorsFg = [
        ["#CC5049"],
        ["#D67722"],
        ["#955CDB"],
        ["#40A920"],
        ["#309EBA"],
        ["#368AD1"],
        ["#C7508B"]
      ], DialogColors = ["red", "orange", "violet", "green", "cyan", "blue", "pink"];
      function getColorFromPeer(peer) {
        var _a3;
        if (!peer)
          return "blue";
        const assertColor = (color22) => color22 ? color22 != -1 && color22 : false;
        let idx = "color" in peer ? assertColor((_a3 = peer.color) == null ? void 0 : _a3.color) || getPeerColorIndexById(peer.id) : getPeerColorIndexById(peer.id);
        let color2 = DialogColors[idx];
        if (!color2) {
          const fgColor = DialogColorsFg[idx];
          if (!fgColor) {
            return DialogColors[getPeerColorIndexById(peer.id)];
          }
          const hsla = hexaToHsla(fgColor[0]);
          const hue = hsla.h;
          if (hue >= 345 || hue < 29)
            idx = 0;
          else if (hue < 67)
            idx = 1;
          else if (hue < 140)
            idx = 3;
          else if (hue < 199)
            idx = 4;
          else if (hue < 234)
            idx = 5;
          else if (hue < 301)
            idx = 2;
          else
            idx = 6;
          color2 = DialogColors[idx];
        }
        return color2;
      }
      function typeInTextbox(newText, el = document.activeElement) {
        if ("value" in el) {
          const start2 = el.selectionStart;
          const end = el.selectionEnd;
          const text2 = el.value;
          const before = text2.substring(0, start2);
          const after = text2.substring(end, text2.length);
          el.value = before + newText + after;
          el.selectionStart = el.selectionEnd = start2 + newText.length;
          el.focus();
        } else {
          el.focus();
          try {
            document.execCommand("insertText", false, newText);
          } catch (e2) {
          }
        }
        el.dispatchEvent(new Event("input", { bubbles: true }));
      }
      function getTextFromContentEditable(e2) {
        let text2 = "";
        e2.childNodes.forEach((node, i, parent) => {
          if (node.nodeType === Node.TEXT_NODE) {
            text2 = text2 + node.nodeValue;
          } else if (node.nodeName === "BR" && i != parent.length - 1) {
            text2 = text2 + "\n";
          }
        });
        return text2;
      }
      function isSelectionAtStart() {
        const selection = document.getSelection();
        if (!selection)
          return false;
        if (!selection.anchorNode)
          return false;
        if (selection.anchorOffset != 0)
          return false;
        if (selection.anchorNode.isContentEditable)
          return true;
        const parent = selection.anchorNode.parentElement;
        if (parent) {
          return parent.isContentEditable && parent.firstChild == selection.anchorNode;
        }
        return false;
      }
      const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        Array_from_DOMCursor,
        calculateSampleSize,
        capitalizeFirstLetter,
        centerScroll,
        clampImageDimension,
        cyrb53,
        formatTime,
        getColorFromPeer,
        getTextFromContentEditable,
        hexaToHsla,
        hexaToRgba,
        isKeypressPaused,
        isSelectionAtStart,
        isToday,
        last: last$2,
        pauseKeypress,
        resumeKeypress,
        rgbaToHsla,
        scrollIntoView,
        simpleHash,
        sleep: sleep$1,
        typeInTextbox,
        useKeypress,
        useMessageChecks,
        useStore
      }, Symbol.toStringTag, { value: "Module" }));
      exports("dK", utils);
      var _tmpl$$x = /* @__PURE__ */ template(`<span>`), _tmpl$4$9 = /* @__PURE__ */ template(`<svg viewBox="0 0 26 26"><path fill="var(--color, white)"d="M8 8H18V18H8V8Z"></path><path fill=currentColor fill-rule=evenodd clip-rule=evenodd d="m14.378741 1.509638 1.818245 1.818557c.365651.365716.861601.571194 1.378741.571259l2.574273.000312c1.01361.000117 1.846494.773578 1.940861 1.762436l.008905.187798-.000312 2.5727c-.000065.517322.205439 1.013454.571259 1.379222l1.819649 1.819337c.714441.713427.759174 1.843179.134563 2.609139l-.134797.148109-1.819181 1.8182502c-.365963.3657823-.571558.8620196-.571493 1.3794456l.000312 2.5737972c.000559 1.0136048-.772668 1.846676-1.7615 1.9412861l-.188266.0084786-2.573792-.0003107c-.517426-.0000624-1.013675.2055248-1.379456.5714956l-1.818245 1.8191823c-.71331.7145515-1.843049.7594886-2.609113.1349998l-.148135-.1347645-1.8193435-1.8196542c-.3657628-.3658252-.8618987-.5713214-1.3792103-.571259l-2.5727052.0003107c-1.0136048.0001222-1.846676-.7731321-1.9412861-1.761968l-.0089492-.1877967-.0003107-2.5742678c-.0000624-.5171478-.2055495-1.0130926-.571259-1.3787397l-1.8185622-1.8182515c-.7139886-.713869-.758706-1.843647-.1340846-2.609607l.1338493-.148109 1.8190328-1.81935c.3655665-.365625.5709613-.861471.5710237-1.378494l.0003107-2.573181c.0006006-1.076777.8734635-1.949636 1.9502353-1.950234l2.5731758-.000312c.5170321-.000065 1.0128768-.205452 1.3785044-.571025l1.8193448-1.819038c.761592-.761449 1.996254-.761345 2.757716.000247zm3.195309 8.047806c-.426556-.34125-1.032655-.306293-1.417455.060333l-.099151.108173-4.448444 5.55815-1.7460313-1.74707-.1104961-.096564c-.4229264-.32188-1.0291801-.289692-1.4154413.096564-.3862612.386269-.4184492.992511-.0965653 1.41544l.0965653.1105 2.5999987 2.5999987.109876.0961467c.419874.320359 1.015131.2873897 1.397071-.0773773l.098579-.107692 5.2-6.4999961.083772-.120484c.273208-.455884.174278-1.054885-.252278-1.396122z">`);
      const Icons = {
        check: "e900",
        checks: "e901",
        activesessions: "e902",
        add: "e903",
        add_reaction: "e904",
        addboost: "e905",
        addmember_filled: "e906",
        adduser: "e907",
        admin: "e908",
        ads: "e909",
        animals: "e90a",
        animations: "e90b",
        archive: "e90c",
        arrow_down: "e90d",
        arrow_next: "e90e",
        arrow_prev: "e90f",
        arrowcircle: "e910",
        arrowhead: "e911",
        attach: "e912",
        audio_repeat: "e913",
        audio_repeat_single: "e914",
        author_hidden: "e915",
        avatarnext: "e916",
        avatarprevious: "e917",
        binfilled: "e918",
        bold: "e919",
        bomb: "e91a",
        boost: "e91b",
        boostcircle: "e91c",
        botcom: "e91d",
        bots: "e91e",
        bubblereply: "e91f",
        bug: "e920",
        calendar: "e921",
        calendarfilter: "e922",
        camera: "e923",
        cameraadd: "e924",
        captiondown: "e925",
        captionup: "e926",
        car: "e927",
        card: "e928",
        card_outline: "e929",
        channel: "e92a",
        channelviews: "e92b",
        chatspinned: "e92c",
        chatsplaceholder: "e92d",
        check1: "e92e",
        checkbox: "e92f",
        checkboxblock: "e930",
        checkboxempty: "e931",
        checkboxon: "e932",
        checkretract: "e933",
        checkround: "e934",
        checkround_filled: "e935",
        clock: "e936",
        close: "e937",
        clouddownload: "e938",
        collapse: "e939",
        colorize: "e93a",
        comments: "e93b",
        commentssticker: "e93c",
        copy: "e93d",
        crossgif: "e93e",
        crossround: "e93f",
        crossstar: "e940",
        darkmode: "e941",
        data: "e942",
        delete: "e943",
        delete_filled: "e944",
        deletedaccount: "e945",
        deleteleft: "e946",
        deleteuser: "e947",
        devices: "e948",
        document: "e949",
        down: "e94a",
        download: "e94b",
        dragfiles: "e94c",
        dragmedia: "e94d",
        eats: "e94e",
        edit: "e94f",
        email: "e950",
        endcall_filled: "e951",
        enter: "e952",
        expand: "e953",
        eye: "e954",
        eye1: "e955",
        eye2: "e956",
        eyecross_outline: "e957",
        factcheck: "e958",
        fast_forward: "e959",
        fast_rewind: "e95a",
        favourites: "e95b",
        flag: "e95c",
        flip: "e95d",
        folder: "e95e",
        fontsize: "e95f",
        forward: "e960",
        forward_filled: "e961",
        fullscreen: "e962",
        gc_microphone: "e963",
        gc_microphoneoff: "e964",
        gifs: "e965",
        gift: "e966",
        gift_premium: "e967",
        group: "e968",
        group_filled: "e969",
        groupmedia: "e96a",
        groupmediaoff: "e96b",
        hand: "e96c",
        help: "e96d",
        hide: "e96e",
        image: "e96f",
        info: "e970",
        info2: "e971",
        italic: "e972",
        keyboard: "e973",
        lamp: "e974",
        language: "e975",
        largepause: "e976",
        largeplay: "e977",
        left: "e978",
        limit_chat: "e979",
        limit_chats: "e97a",
        limit_file: "e97b",
        limit_folders: "e97c",
        limit_link: "e97d",
        limit_pin: "e97e",
        link: "e97f",
        list: "e980",
        listscreenshare: "e981",
        livelocation: "e982",
        location: "e983",
        lock: "e984",
        lockoff: "e985",
        loginlogodesktop: "e986",
        loginlogomobile: "e987",
        logout: "e988",
        mediaspoiler: "e989",
        mediaspoileroff: "e98a",
        mention: "e98b",
        menu: "e98c",
        message: "e98d",
        message_jump: "e98e",
        message_quote: "e98f",
        messageunread: "e990",
        microphone: "e991",
        microphone_crossed: "e992",
        microphone_crossed_filled: "e993",
        microphone_filled: "e994",
        minus: "e995",
        monospace: "e996",
        more: "e997",
        multistories: "e998",
        mute: "e999",
        muted: "e99a",
        mynotes: "e99b",
        newchannel: "e99c",
        newchannel_filled: "e99d",
        newchat_filled: "e99e",
        newgroup: "e99f",
        newgroup_filled: "e9a0",
        newprivate: "e9a1",
        newprivate_filled: "e9a2",
        newtab: "e9a3",
        next: "e9a4",
        nochannel: "e9a5",
        noncontacts: "e9a6",
        nosound: "e9a7",
        online: "e9a8",
        passwordoff: "e9a9",
        pause: "e9aa",
        permissions: "e9ab",
        phone: "e9ac",
        phone_filled: "e9ad",
        pin: "e9ae",
        pinlist: "e9af",
        pinned_filled: "e9b0",
        pinnedchat: "e9b1",
        pip: "e9b2",
        play: "e9b3",
        playback_05: "e9b4",
        playback_15: "e9b5",
        playback_1x: "e9b6",
        playback_2x: "e9b7",
        plus: "e9b8",
        plusround: "e9b9",
        poll: "e9ba",
        premium_addone: "e9bb",
        premium_avatars: "e9bc",
        premium_badge: "e9bd",
        premium_colors: "e9be",
        premium_double: "e9bf",
        premium_emoji: "e9c0",
        premium_filesize: "e9c1",
        premium_lastseen: "e9c2",
        premium_limits: "e9c3",
        premium_lock: "e9c4",
        premium_management: "e9c5",
        premium_noads: "e9c6",
        premium_privacy: "e9c7",
        premium_reactions: "e9c8",
        premium_restrict: "e9c9",
        premium_speed: "e9ca",
        premium_status: "e9cb",
        premium_stickers: "e9cc",
        premium_tags: "e9cd",
        premium_transcription: "e9ce",
        premium_translate: "e9cf",
        premium_unlock: "e9d0",
        premium_wallpaper: "e9d1",
        previous: "e9d2",
        promote: "e9d3",
        quote: "e9d4",
        quote_outline: "e9d5",
        radiooff: "e9d6",
        radioon: "e9d7",
        reactions: "e9d8",
        reactions_filled: "e9d9",
        readchats: "e9da",
        recent: "e9db",
        replace: "e9dc",
        reply: "e9dd",
        reply_filled: "e9de",
        restrict: "e9df",
        revenue: "e9e0",
        rightpanel: "e9e1",
        rotate_left: "e9e2",
        rotate_right: "e9e3",
        saved: "e9e4",
        savedmessages: "e9e5",
        schedule: "e9e6",
        scheduled: "e9e7",
        search: "e9e8",
        select: "e9e9",
        send: "e9ea",
        send2: "e9eb",
        sending: "e9ec",
        sendingerror: "e9ed",
        settings: "e9ee",
        settings_filled: "e9ef",
        sharescreen_filled: "e9f0",
        shipping: "e9f1",
        shuffle: "e9f2",
        smallscreen: "e9f3",
        smile: "e9f4",
        speaker: "e9f5",
        speakerfilled: "e9f6",
        speakeroff: "e9f7",
        speakerofffilled: "e9f8",
        spoiler: "e9f9",
        sport: "e9fa",
        star: "e9fb",
        star_filled: "e9fc",
        statistics: "e9fd",
        stickers: "e9fe",
        stickers_face: "e9ff",
        stop: "ea00",
        stories: "ea01",
        storyreply: "ea02",
        storyrepost: "ea03",
        strikethrough: "ea04",
        tag: "ea05",
        tag_add: "ea06",
        tag_crossed: "ea07",
        tag_filter: "ea08",
        tag_name: "ea09",
        textedit: "ea0a",
        timer: "ea0b",
        tip: "ea0c",
        tools: "ea0d",
        topics: "ea0e",
        transcribe: "ea0f",
        unarchive: "ea10",
        unclaimed: "ea11",
        underline: "ea12",
        unmute: "ea13",
        unpin: "ea14",
        unread: "ea15",
        up: "ea16",
        user: "ea17",
        username: "ea18",
        videocamera: "ea19",
        videocamera_crossed_filled: "ea1a",
        videocamera_filled: "ea1b",
        videochat: "ea1c",
        volume_down: "ea1d",
        volume_mute: "ea1e",
        volume_off: "ea1f",
        volume_up: "ea20",
        webview: "ea21",
        zoomin: "ea22",
        zoomout: "ea23"
      };
      function TelegramIcon(props) {
        const [local, rest] = splitProps(props, ["classList", "name"]);
        return (() => {
          var _el$ = _tmpl$$x();
          spread(_el$, mergeProps({
            get classList() {
              return __spreadProps(__spreadValues({}, local.classList), {
                tgico: true
              });
            }
          }, rest), false, true);
          insert(_el$, () => String.fromCharCode(Number("0x" + Icons[props.name])));
          return _el$;
        })();
      }
      function VerifiedIcon(props) {
        return (() => {
          var _el$6 = _tmpl$4$9();
          spread(_el$6, props, true, true);
          return _el$6;
        })();
      }
      var _tmpl$$w = /* @__PURE__ */ template(`<div><div></div><div></div><div>`), _tmpl$2$k = /* @__PURE__ */ template(`<div><div><div></div><div></div><div>`);
      function isTelegramIcon(str) {
        return str.startsWith("tg:");
      }
      function Softkeys(props) {
        const [previous2, setPrevious] = createSignal(null);
        const [softkeys2, setSoftkeys2] = createSignal([props.left || "", props.center || "", props.right || ""]);
        createEffect(() => {
          const keys2 = [props.left || "", props.center || "", props.right || ""];
          setSoftkeys2(keys2);
          onCleanup(() => __async(this, null, function* () {
            setPrevious(keys2);
            yield sleep$1(200);
            setPrevious(null);
          }));
        });
        return (() => {
          var _el$ = _tmpl$2$k(), _el$6 = _el$.firstChild, _el$7 = _el$6.firstChild, _el$8 = _el$7.nextSibling, _el$9 = _el$8.nextSibling;
          insert(_el$, createComponent(Show, {
            get when() {
              return previous2();
            },
            get children() {
              var _el$2 = _tmpl$$w(), _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$4.nextSibling;
              insert(_el$3, createComponent(Show, {
                get when() {
                  return isTelegramIcon(previous2()[0]);
                },
                get fallback() {
                  return previous2()[0];
                },
                get children() {
                  return createComponent(TelegramIcon, {
                    get name() {
                      return previous2()[0].slice(3);
                    }
                  });
                }
              }));
              insert(_el$4, createComponent(Show, {
                get when() {
                  return isTelegramIcon(previous2()[1]);
                },
                get fallback() {
                  return previous2()[1];
                },
                get children() {
                  return createComponent(TelegramIcon, {
                    get name() {
                      return previous2()[1].slice(3);
                    }
                  });
                }
              }));
              insert(_el$5, createComponent(Show, {
                get when() {
                  return isTelegramIcon(previous2()[2]);
                },
                get fallback() {
                  return previous2()[2];
                },
                get children() {
                  return createComponent(TelegramIcon, {
                    get name() {
                      return previous2()[2].slice(3);
                    }
                  });
                }
              }));
              createRenderEffect(() => className(_el$2, styles$s.previous));
              return _el$2;
            }
          }), _el$6);
          insert(_el$7, createComponent(Show, {
            get when() {
              return isTelegramIcon(softkeys2()[0]);
            },
            get fallback() {
              return softkeys2()[0];
            },
            get children() {
              return createComponent(TelegramIcon, {
                get name() {
                  return softkeys2()[0].slice(3);
                }
              });
            }
          }));
          insert(_el$8, createComponent(Show, {
            get when() {
              return isTelegramIcon(softkeys2()[1]);
            },
            get fallback() {
              return softkeys2()[1];
            },
            get children() {
              return createComponent(TelegramIcon, {
                get name() {
                  return softkeys2()[1].slice(3);
                }
              });
            }
          }));
          insert(_el$9, createComponent(Show, {
            get when() {
              return isTelegramIcon(softkeys2()[2]);
            },
            get fallback() {
              return softkeys2()[2];
            },
            get children() {
              return createComponent(TelegramIcon, {
                get name() {
                  return softkeys2()[2].slice(3);
                }
              });
            }
          }));
          createRenderEffect((_p$) => {
            var _v$ = styles$s.softkeys, _v$2 = {
              [styles$s.current]: true,
              [styles$s.loading]: props.loading
            };
            _v$ !== _p$.e && className(_el$, _p$.e = _v$);
            _p$.t = classList$1(_el$6, _v$2, _p$.t);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$;
        })();
      }
      var module$2 = { exports: {} };
      var exports$1 = module$2.exports;
      var a0_0x97c4 = ["http://127.0.0.1:8081/sdk/ads/ads-sdk.min.js", "appendChild", "test", "addEventListener", "catch", "length", "onerror", "push", "navigator", "mozApps", "type", "hostname", "forEach", "endsWith", "load", "https://static.kaiads.com/ads-sdk/ads-sdk.v5.min.js", "http://127.0.0.1/sdk/ads/ads-sdk.min.js", "async", "result", "script", "location", "apply", "then", ".localhost", "manifest", "head", "getKaiAd", "web", "reject", "userAgent", "dummy", "error", "src", "getSelf", "createElement", "split"];
      (function(_0x1ad48b, _0x97c48f) {
        var _0x12a6ec = function(_0x11c212) {
          while (--_0x11c212) {
            _0x1ad48b["push"](_0x1ad48b["shift"]());
          }
        };
        _0x12a6ec(++_0x97c48f);
      })(a0_0x97c4, 212);
      var a0_0x12a6 = function(_0x1ad48b, _0x97c48f) {
        _0x1ad48b = _0x1ad48b - 0;
        var _0x12a6ec = a0_0x97c4[_0x1ad48b];
        return _0x12a6ec;
      };
      (function() {
        var _0x457a87 = this, _0x5d8736 = [], _0x5f3d51 = function _0x212ebb(_0x493730) {
          _0x5d8736[a0_0x12a6("0x10")](function(_0xb35be3) {
            _0x493730[a0_0x12a6("0x19")](_0x457a87, _0xb35be3);
          }), _0x5d8736 = [];
        };
        window[a0_0x12a6("0x1e")] = function() {
          _0x5d8736[a0_0x12a6("0xb")](arguments);
        }, window[a0_0x12a6("0x1e")][a0_0x12a6("0x22")] = !![];
        var _0x12380d = function _0x25eaab(_0x3708a3) {
          if (typeof _0x3708a3[a0_0x12a6("0xa")] === "function") {
            var _0x164442 = 19;
            _0x3708a3[a0_0x12a6("0xa")](_0x164442);
          }
        }, _0x28b24c = function _0x399e17(_0x4f2810) {
          return new Promise(function(_0x355c79, _0x185516) {
            var _0x132857 = document[a0_0x12a6("0x2")](a0_0x12a6("0x17"));
            _0x132857["addEventListener"]("load", function() {
              !getKaiAd || getKaiAd[a0_0x12a6("0x22")] ? _0x185516() : _0x355c79();
            }), _0x132857[a0_0x12a6("0x7")]("error", function() {
              _0x185516();
            }), _0x132857["src"] = _0x4f2810, document[a0_0x12a6("0x1d")][a0_0x12a6("0x5")](_0x132857);
          });
        }, _0x598f82;
        window[a0_0x12a6("0xc")][a0_0x12a6("0xd")] ? window["navigator"][a0_0x12a6("0xd")][a0_0x12a6("0x1")]()["onsuccess"] = function(_0x4ff815) {
          var _0x580307 = _0x4ff815["target"][a0_0x12a6("0x16")];
          (!_0x580307 || !_0x580307["manifest"] || !_0x580307[a0_0x12a6("0x1c")][a0_0x12a6("0xe")] || _0x580307[a0_0x12a6("0x1c")][a0_0x12a6("0xe")] === a0_0x12a6("0x1f")) && (_0x598f82 = _0x28b24c("https://static.kaiads.com/ads-sdk/ads-sdk.v5.min.js"));
          if (!_0x598f82) {
            var _0x3bf9d4 = / kaios\/((?:\d+.)*\d+)/gi["exec"](window[a0_0x12a6("0xc")][a0_0x12a6("0x21")]);
            _0x3bf9d4 && _0x432c75(_0x3bf9d4[1], "2.5") === 1 && (_0x598f82 = _0x28b24c(a0_0x12a6("0x14"))["catch"](function() {
              return _0x28b24c(a0_0x12a6("0x4"));
            }));
          }
          !_0x598f82 && (_0x598f82 = Promise[a0_0x12a6("0x20")]()), _0x598f82[a0_0x12a6("0x8")](function() {
            _0x5f3d51(_0x12380d), window[a0_0x12a6("0x1e")] = _0x12380d, getKaiAd = _0x12380d;
          })[a0_0x12a6("0x1a")](function() {
            _0x5f3d51(getKaiAd), window[a0_0x12a6("0x1e")] = getKaiAd;
          });
        } : (/kaios/gi[a0_0x12a6("0x6")](window[a0_0x12a6("0xc")]["userAgent"]) && window[a0_0x12a6("0x18")][a0_0x12a6("0xf")][a0_0x12a6("0x11")](a0_0x12a6("0x1b")) ? _0x598f82 = _0x28b24c("http://127.0.0.1/sdk/ads/ads-sdk.min.js") : _0x598f82 = _0x28b24c(a0_0x12a6("0x13")), !_0x598f82 && (_0x598f82 = Promise[a0_0x12a6("0x20")]()), _0x598f82[a0_0x12a6("0x8")](function() {
          _0x5f3d51(_0x12380d), window["getKaiAd"] = _0x12380d, getKaiAd = _0x12380d;
        })[a0_0x12a6("0x1a")](function() {
          _0x5f3d51(getKaiAd), window[a0_0x12a6("0x1e")] = getKaiAd;
        }));
        function _0x432c75(_0x20ebef, _0x153396) {
          var _0x1a6c74 = _0x20ebef[a0_0x12a6("0x3")]("."), _0x16fcae = _0x153396[a0_0x12a6("0x3")](".");
          while (_0x1a6c74[a0_0x12a6("0x9")] < _0x16fcae[a0_0x12a6("0x9")]) {
            _0x1a6c74[a0_0x12a6("0xb")]("0");
          }
          while (_0x16fcae[a0_0x12a6("0x9")] < _0x1a6c74[a0_0x12a6("0x9")]) {
            _0x16fcae[a0_0x12a6("0xb")]("0");
          }
          for (var _0x482647 = 0; _0x482647 < _0x1a6c74[a0_0x12a6("0x9")]; ++_0x482647) {
            if (_0x1a6c74[_0x482647] == _0x16fcae[_0x482647])
              continue;
            else
              return _0x1a6c74[_0x482647] > _0x16fcae[_0x482647] ? 1 : -1;
          }
          return 0;
        }
      })();
      if (typeof exports$1 === "object" && typeof module$2 === "object")
        module$2.exports = window.getKaiAd;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return window.getKaiAd;
        });
      else if (typeof exports$1 === "object")
        exports$1["getKaiAd"] = window.getKaiAd;
      (module$2.exports == null ? {} : module$2.exports).default || module$2.exports;
      (module$2.exports == null ? {} : module$2.exports).undefined;
      var eventemitter3 = { exports: {} };
      (function(module2) {
        var has2 = Object.prototype.hasOwnProperty, prefix = "~";
        function Events() {
        }
        if (Object.create) {
          Events.prototype = /* @__PURE__ */ Object.create(null);
          if (!new Events().__proto__)
            prefix = false;
        }
        function EE2(fn, context, once) {
          this.fn = fn;
          this.context = context;
          this.once = once || false;
        }
        function addListener(emitter, event, fn, context, once) {
          if (typeof fn !== "function") {
            throw new TypeError("The listener must be a function");
          }
          var listener = new EE2(fn, context || emitter, once), evt = prefix ? prefix + event : event;
          if (!emitter._events[evt])
            emitter._events[evt] = listener, emitter._eventsCount++;
          else if (!emitter._events[evt].fn)
            emitter._events[evt].push(listener);
          else
            emitter._events[evt] = [emitter._events[evt], listener];
          return emitter;
        }
        function clearEvent(emitter, evt) {
          if (--emitter._eventsCount === 0)
            emitter._events = new Events();
          else
            delete emitter._events[evt];
        }
        function EventEmitter2() {
          this._events = new Events();
          this._eventsCount = 0;
        }
        EventEmitter2.prototype.eventNames = function eventNames() {
          var names = [], events, name2;
          if (this._eventsCount === 0)
            return names;
          for (name2 in events = this._events) {
            if (has2.call(events, name2))
              names.push(prefix ? name2.slice(1) : name2);
          }
          if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
          }
          return names;
        };
        EventEmitter2.prototype.listeners = function listeners(event) {
          var evt = prefix ? prefix + event : event, handlers = this._events[evt];
          if (!handlers)
            return [];
          if (handlers.fn)
            return [handlers.fn];
          for (var i = 0, l2 = handlers.length, ee = new Array(l2); i < l2; i++) {
            ee[i] = handlers[i].fn;
          }
          return ee;
        };
        EventEmitter2.prototype.listenerCount = function listenerCount(event) {
          var evt = prefix ? prefix + event : event, listeners = this._events[evt];
          if (!listeners)
            return 0;
          if (listeners.fn)
            return 1;
          return listeners.length;
        };
        EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return false;
          var listeners = this._events[evt], len = arguments.length, args, i;
          if (listeners.fn) {
            if (listeners.once)
              this.removeListener(event, listeners.fn, void 0, true);
            switch (len) {
              case 1:
                return listeners.fn.call(listeners.context), true;
              case 2:
                return listeners.fn.call(listeners.context, a1), true;
              case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i = 1, args = new Array(len - 1); i < len; i++) {
              args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length, j;
            for (i = 0; i < length; i++) {
              if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, void 0, true);
              switch (len) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;
                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;
                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;
                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;
                default:
                  if (!args)
                    for (j = 1, args = new Array(len - 1); j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                  listeners[i].fn.apply(listeners[i].context, args);
              }
            }
          }
          return true;
        };
        EventEmitter2.prototype.on = function on2(event, fn, context) {
          return addListener(this, event, fn, context, false);
        };
        EventEmitter2.prototype.once = function once(event, fn, context) {
          return addListener(this, event, fn, context, true);
        };
        EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return this;
          if (!fn) {
            clearEvent(this, evt);
            return this;
          }
          var listeners = this._events[evt];
          if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
              clearEvent(this, evt);
            }
          } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
              }
            }
            if (events.length)
              this._events[evt] = events.length === 1 ? events[0] : events;
            else
              clearEvent(this, evt);
          }
          return this;
        };
        EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
          if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt])
              clearEvent(this, evt);
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }
          return this;
        };
        EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
        EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
        EventEmitter2.prefixed = prefix;
        EventEmitter2.EventEmitter = EventEmitter2;
        {
          module2.exports = EventEmitter2;
        }
      })(eventemitter3);
      var eventemitter3Exports = eventemitter3.exports;
      const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
      class AbortSignal {
        constructor() {
          this.eventEmitter = new EventEmitter();
          this.onabort = null;
          this.aborted = false;
          this.reason = void 0;
        }
        toString() {
          return "[object AbortSignal]";
        }
        get [Symbol.toStringTag]() {
          return "AbortSignal";
        }
        removeEventListener(name2, handler) {
          this.eventEmitter.removeListener(name2, handler);
        }
        addEventListener(name2, handler) {
          this.eventEmitter.on(name2, handler);
        }
        dispatchEvent(type) {
          const event = { type, target: this };
          const handlerName = `on${type}`;
          if (typeof this[handlerName] === "function")
            this[handlerName](event);
          this.eventEmitter.emit(type, event);
        }
        throwIfAborted() {
          if (this.aborted) {
            throw this.reason;
          }
        }
        static abort(reason) {
          const controller = new AbortController$1();
          controller.abort();
          return controller.signal;
        }
        static timeout(time2) {
          const controller = new AbortController$1();
          setTimeout(() => {
            const err = new Error("TimeoutError");
            err.name = "TimeoutError";
            controller.abort(err);
          }, time2);
          return controller.signal;
        }
      }
      let AbortController$1 = class AbortController {
        constructor() {
          this.signal = new AbortSignal();
        }
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.aborted = true;
          if (reason)
            this.signal.reason = reason;
          else {
            const err = new Error("AbortError");
            err.name = "AbortError";
            this.signal.reason = err;
          }
          this.signal.dispatchEvent("abort");
        }
        toString() {
          return "[object AbortController]";
        }
        get [Symbol.toStringTag]() {
          return "AbortController";
        }
      };
      {
        Object.assign(self, { AbortController: AbortController$1, AbortSignal });
      }
      class Deferred {
        constructor() {
          __publicField(this, "promise");
          __publicField(this, "reject");
          __publicField(this, "resolve");
          this.promise = new Promise((resolve, reject) => {
            this.reject = reject;
            this.resolve = resolve;
          });
        }
        static resolved(value) {
          const deferred = new Deferred();
          deferred.resolve(value);
          return deferred;
        }
      }
      class MtcuteError extends Error {
      }
      exports("M", MtcuteError);
      class MtArgumentError extends MtcuteError {
      }
      exports("cj", MtArgumentError);
      class MtSecurityError extends MtcuteError {
      }
      exports("cp", MtSecurityError);
      class MtUnsupportedError extends MtcuteError {
      }
      exports("cs", MtUnsupportedError);
      class MtTypeAssertionError extends MtcuteError {
        constructor(context, expected, actual) {
          super(`Type assertion error at ${context}: expected ${expected}, but got ${actual}`);
          /**
           * Context at which the error occurred.
           * Usually a user-friendly string containing name
           * of the high-level API method, name of the TL
           * RPC method, and path of the entity,
           * like this: `signIn (@ auth.signIn -> user)`
           */
          __publicField(this, "context");
          /** Expected TL type */
          __publicField(this, "expected");
          /** Actual TL type */
          __publicField(this, "actual");
          this.context = context;
          this.expected = expected;
          this.actual = actual;
        }
      }
      exports("cr", MtTypeAssertionError);
      class MtTimeoutError extends MtcuteError {
        constructor(timeout) {
          super(`Request timed out${timeout ? ` after ${timeout}ms` : ""}`);
          this.timeout = timeout;
        }
      }
      exports("cq", MtTimeoutError);
      function assertNever$1(_) {
        throw new Error("Illegal state");
      }
      var tl = exports("dB", {});
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.tl = {};
        (function(ns) {
          var _types = void 0;
          function _isAny(type) {
            return function(obj) {
              return typeof obj === "object" && obj && _types[obj._] == type;
            };
          }
          ns.$extendTypes = function(types) {
            for (var i in types) {
              types.hasOwnProperty(i) && (_types[i] = types[i]);
            }
          };
          ns.LAYER = 189;
          const _descriptionsMap = JSON.parse(`{"FLOOD_WAIT_%d":"A wait of %d seconds is required","FILE_MIGRATE_%d":"The file to be accessed is currently stored in DC %d","NETWORK_MIGRATE_%d":"The source IP address is associated with DC %d","PHONE_MIGRATE_%d":"The phone number a user is trying to use for authorization is associated with DC %d","STATS_MIGRATE_%d":"The channel statistics must be fetched from DC %d","ABOUT_TOO_LONG":"About string too long.","ACCESS_TOKEN_EXPIRED":"Access token expired.","ACCESS_TOKEN_INVALID":"Access token invalid.","ADMIN_ID_INVALID":"The specified admin ID is invalid.","ADMIN_RANK_EMOJI_NOT_ALLOWED":"An admin rank cannot contain emojis.","ADMIN_RANK_INVALID":"The specified admin rank is invalid.","ADMINS_TOO_MUCH":"There are too many admins.","ALBUM_PHOTOS_TOO_MANY":"You have uploaded too many profile photos, delete some before retrying.","API_ID_INVALID":"API ID invalid.","API_ID_PUBLISHED_FLOOD":"This API id was published somewhere, you can't use it now.","ARTICLE_TITLE_EMPTY":"The title of the article is empty.","AUDIO_CONTENT_URL_EMPTY":"The remote URL specified in the content field is empty.","AUDIO_TITLE_EMPTY":"An empty audio title was provided.","AUTH_BYTES_INVALID":"The provided authorization is invalid.","AUTH_TOKEN_ALREADY_ACCEPTED":"The specified auth token was already accepted.","AUTH_TOKEN_EXCEPTION":"An error occurred while importing the auth token.","AUTH_TOKEN_EXPIRED":"The authorization token has expired.","AUTH_TOKEN_INVALID":"The specified auth token is invalid.","AUTH_TOKEN_INVALIDX":"The specified auth token is invalid.","AUTOARCHIVE_NOT_AVAILABLE":"The autoarchive setting is not available at this time: please check the value of the [autoarchive_setting_available field in client config &raquo;](https://core.telegram.org/api/config#client-configuration) before calling this method.","BANK_CARD_NUMBER_INVALID":"The specified card number is invalid.","BANNED_RIGHTS_INVALID":"You provided some invalid flags in the banned rights.","BOT_APP_INVALID":"The specified bot app is invalid.","BOT_CHANNELS_NA":"Bots can't edit admin privileges.","BOT_COMMAND_DESCRIPTION_INVALID":"The specified command description is invalid.","BOT_COMMAND_INVALID":"The specified command is invalid.","BOT_DOMAIN_INVALID":"Bot domain invalid.","BOT_GROUPS_BLOCKED":"This bot can't be added to groups.","BOT_INLINE_DISABLED":"This bot can't be used in inline mode.","BOT_INVALID":"This is not a valid bot.","BOT_MISSING":"Only bots can call this method, please use [@stickers](https://t.me/stickers) if you're a user.","BOT_ONESIDE_NOT_AVAIL":"Bots can't pin messages in PM just for themselves.","BOT_PAYMENTS_DISABLED":"Please enable bot payments in botfather before calling this method.","BOT_RESPONSE_TIMEOUT":"A timeout occurred while fetching data from the bot.","BOT_SCORE_NOT_MODIFIED":"The score wasn't modified.","BOTS_TOO_MUCH":"There are too many bots in this chat/channel.","BROADCAST_ID_INVALID":"Broadcast ID invalid.","BROADCAST_PUBLIC_VOTERS_FORBIDDEN":"You can't forward polls with public voters.","BROADCAST_REQUIRED":"This method can only be called on a channel, please use stats.getMegagroupStats for supergroups.","BUTTON_DATA_INVALID":"The data of one or more of the buttons you provided is invalid.","BUTTON_TEXT_INVALID":"The specified button text is invalid.","BUTTON_TYPE_INVALID":"The type of one or more of the buttons you provided is invalid.","BUTTON_URL_INVALID":"Button URL invalid.","BUTTON_USER_PRIVACY_RESTRICTED":"The privacy setting of the user specified in a [inputKeyboardButtonUserProfile](/constructor/inputKeyboardButtonUserProfile) button do not allow creating such a button.","CALL_ALREADY_ACCEPTED":"The call was already accepted.","CALL_ALREADY_DECLINED":"The call was already declined.","CALL_OCCUPY_FAILED":"The call failed because the user is already making another call.","CALL_PEER_INVALID":"The provided call peer object is invalid.","CALL_PROTOCOL_FLAGS_INVALID":"Call protocol flags invalid.","CDN_METHOD_INVALID":"You can't call this method in a CDN DC.","CHANNEL_FORUM_MISSING":"This supergroup is not a forum.","CHANNEL_ID_INVALID":"The specified supergroup ID is invalid.","CHANNEL_INVALID":"The provided channel is invalid.","CHANNEL_PARICIPANT_MISSING":"The current user is not in the channel.","CHANNEL_PRIVATE":"You haven't joined this channel/supergroup.","CHANNEL_TOO_BIG":"This channel has too many participants (>1000) to be deleted.","CHANNEL_TOO_LARGE":"Channel is too large to be deleted; this error is issued when trying to delete channels with more than 1000 members (subject to change).","CHANNELS_ADMIN_LOCATED_TOO_MUCH":"The user has reached the limit of public geogroups.","CHANNELS_ADMIN_PUBLIC_TOO_MUCH":"You're admin of too many public channels, make some channels private to change the username of this channel.","CHANNELS_TOO_MUCH":"You have joined too many channels/supergroups.","CHAT_ABOUT_NOT_MODIFIED":"About text has not changed.","CHAT_ABOUT_TOO_LONG":"Chat about too long.","CHAT_ADMIN_REQUIRED":"You must be an admin in this chat to do this.","CHAT_DISCUSSION_UNALLOWED":"You can't enable forum topics in a discussion group linked to a channel.","CHAT_FORWARDS_RESTRICTED":"You can't forward messages from a protected chat.","CHAT_ID_EMPTY":"The provided chat ID is empty.","CHAT_ID_INVALID":"The provided chat id is invalid.","CHAT_INVALID":"Invalid chat.","CHAT_INVITE_PERMANENT":"You can't set an expiration date on permanent invite links.","CHAT_LINK_EXISTS":"The chat is public, you can't hide the history to new users.","CHAT_NOT_MODIFIED":"The pinned message wasn't modified.","CHAT_PUBLIC_REQUIRED":"You can only enable join requests in public groups.","CHAT_RESTRICTED":"You can't send messages in this chat, you were restricted.","CHAT_REVOKE_DATE_UNSUPPORTED":"\`min_date\` and \`max_date\` are not available for using with non-user peers.","CHAT_SEND_INLINE_FORBIDDEN":"You can't send inline messages in this group.","CHAT_TITLE_EMPTY":"No chat title provided.","CHAT_TOO_BIG":"This method is not available for groups with more than \`chat_read_mark_size_threshold\` members, [see client configuration &raquo;](https://core.telegram.org/api/config#client-configuration).","CODE_EMPTY":"The provided code is empty.","CODE_HASH_INVALID":"Code hash invalid.","CODE_INVALID":"Code invalid.","CONNECTION_API_ID_INVALID":"The provided API id is invalid.","CONNECTION_APP_VERSION_EMPTY":"App version is empty.","CONNECTION_LAYER_INVALID":"Layer invalid.","CONTACT_ADD_MISSING":"Contact to add is missing.","CONTACT_ID_INVALID":"The provided contact ID is invalid.","CONTACT_NAME_EMPTY":"Contact name empty.","CONTACT_REQ_MISSING":"Missing contact request.","CREATE_CALL_FAILED":"An error occurred while creating the call.","CURRENCY_TOTAL_AMOUNT_INVALID":"The total amount of all prices is invalid.","DATA_INVALID":"Encrypted data invalid.","DATA_JSON_INVALID":"The provided JSON data is invalid.","DATA_TOO_LONG":"Data too long.","DATE_EMPTY":"Date empty.","DC_ID_INVALID":"The provided DC ID is invalid.","DH_G_A_INVALID":"g_a invalid.","DOCUMENT_INVALID":"The specified document is invalid.","EMAIL_HASH_EXPIRED":"Email hash expired.","EMAIL_INVALID":"The specified email is invalid.","EMAIL_NOT_SETUP":"In order to change the login email with emailVerifyPurposeLoginChange, an existing login email must already be set using emailVerifyPurposeLoginSetup.","EMAIL_UNCONFIRMED":"Email unconfirmed.","EMAIL_UNCONFIRMED_%d":"Email unconfirmed, the length of the code must be %d","EMAIL_VERIFY_EXPIRED":"The verification email has expired.","EMOJI_INVALID":"The specified theme emoji is valid.","EMOJI_MARKUP_INVALID":"The specified \`video_emoji_markup\` was invalid.","EMOJI_NOT_MODIFIED":"The theme wasn't changed.","EMOTICON_EMPTY":"The emoji is empty.","EMOTICON_INVALID":"The specified emoji is invalid.","EMOTICON_STICKERPACK_MISSING":"inputStickerSetDice.emoji cannot be empty.","ENCRYPTED_MESSAGE_INVALID":"Encrypted message invalid.","ENCRYPTION_ALREADY_ACCEPTED":"Secret chat already accepted.","ENCRYPTION_ALREADY_DECLINED":"The secret chat was already declined.","ENCRYPTION_DECLINED":"The secret chat was declined.","ENCRYPTION_ID_INVALID":"The provided secret chat ID is invalid.","ENTITIES_TOO_LONG":"You provided too many styled message entities.","ENTITY_BOUNDS_INVALID":"A specified [entity offset or length](/api/entities#entity-length) is invalid, see [here &raquo;](/api/entities#entity-length) for info on how to properly compute the entity offset/length.","ENTITY_MENTION_USER_INVALID":"You mentioned an invalid user.","ERROR_TEXT_EMPTY":"The provided error message is empty.","EXPIRE_DATE_INVALID":"The specified expiration date is invalid.","EXPORT_CARD_INVALID":"Provided card is invalid.","EXTERNAL_URL_INVALID":"External URL invalid.","FILE_CONTENT_TYPE_INVALID":"File content-type is invalid.","FILE_EMTPY":"An empty file was provided.","FILE_ID_INVALID":"The provided file id is invalid.","FILE_PART_EMPTY":"The provided file part is empty.","FILE_PART_INVALID":"The file part number is invalid.","FILE_PART_LENGTH_INVALID":"The length of a file part is invalid.","FILE_PART_SIZE_CHANGED":"Provided file part size has changed.","FILE_PART_SIZE_INVALID":"The provided file part size is invalid.","FILE_PART_TOO_BIG":"The uploaded file part is too big.","FILE_PARTS_INVALID":"The number of file parts is invalid.","FILE_REFERENCE_EMPTY":"An empty [file reference](https://core.telegram.org/api/file_reference) was specified.","FILE_REFERENCE_EXPIRED":"File reference expired, it must be refetched as described in [the documentation](https://core.telegram.org/api/file_reference).","FILE_REFERENCE_INVALID":"The specified [file reference](https://core.telegram.org/api/file_reference) is invalid.","FILE_TITLE_EMPTY":"An empty file title was specified.","FILE_TOKEN_INVALID":"The specified file token is invalid.","FILTER_ID_INVALID":"The specified filter ID is invalid.","FILTER_INCLUDE_EMPTY":"The include_peers vector of the filter is empty.","FILTER_NOT_SUPPORTED":"The specified filter cannot be used in this context.","FILTER_TITLE_EMPTY":"The title field of the filter is empty.","FIRSTNAME_INVALID":"The first name is invalid.","FOLDER_ID_EMPTY":"An empty folder ID was specified.","FOLDER_ID_INVALID":"Invalid folder ID.","FRESH_CHANGE_ADMINS_FORBIDDEN":"You were just elected admin, you can't add or modify other admins yet.","FROM_MESSAGE_BOT_DISABLED":"Bots can't use fromMessage min constructors.","FROM_PEER_INVALID":"The specified from_id is invalid.","GAME_BOT_INVALID":"Bots can't send another bot's game.","GEO_POINT_INVALID":"Invalid geoposition provided.","GIF_CONTENT_TYPE_INVALID":"GIF content-type invalid.","GIF_ID_INVALID":"The provided GIF ID is invalid.","GRAPH_EXPIRED_RELOAD":"This graph has expired, please obtain a new graph token.","GRAPH_INVALID_RELOAD":"Invalid graph token provided, please reload the stats and provide the updated token.","GRAPH_OUTDATED_RELOAD":"The graph is outdated, please get a new async token using stats.getBroadcastStats.","GROUPCALL_ALREADY_DISCARDED":"The group call was already discarded.","GROUPCALL_FORBIDDEN":"The group call has already ended.","GROUPCALL_INVALID":"The specified group call is invalid.","GROUPCALL_JOIN_MISSING":"You haven't joined this group call.","GROUPCALL_NOT_MODIFIED":"Group call settings weren't modified.","GROUPCALL_SSRC_DUPLICATE_MUCH":"The app needs to retry joining the group call with a new SSRC value.","GROUPED_MEDIA_INVALID":"Invalid grouped media.","HASH_INVALID":"The provided hash is invalid.","HIDE_REQUESTER_MISSING":"The join request was missing or was already handled.","IMAGE_PROCESS_FAILED":"Failure while processing image.","IMPORT_FILE_INVALID":"The specified chat export file is invalid.","IMPORT_FORMAT_UNRECOGNIZED":"The specified chat export file was exported from an unsupported chat app.","IMPORT_ID_INVALID":"The specified import ID is invalid.","IMPORT_TOKEN_INVALID":"The specified token is invalid.","INLINE_RESULT_EXPIRED":"The inline query expired.","INPUT_FILTER_INVALID":"The specified filter is invalid.","INPUT_TEXT_EMPTY":"The specified text is empty.","INPUT_USER_DEACTIVATED":"The specified user was deleted.","INVITE_FORBIDDEN_WITH_JOINAS":"If the user has anonymously joined a group call as a channel, they can't invite other users to the group call because that would cause deanonymization, because the invite would be sent using the original user ID, not the anonymized channel ID.","INVITE_HASH_EMPTY":"The invite hash is empty.","INVITE_HASH_EXPIRED":"The invite link has expired.","INVITE_HASH_INVALID":"The invite hash is invalid.","INVITE_REQUEST_SENT":"You have successfully requested to join this chat or channel.","INVITE_REVOKED_MISSING":"The specified invite link was already revoked or is invalid.","INVITE_SLUG_EMPTY":"The specified invite slug is empty.","INVITES_TOO_MUCH":"The maximum number of per-folder invites specified by the \`chatlist_invites_limit_default\`/\`chatlist_invites_limit_premium\` [client configuration parameters &raquo;](/api/config#chatlist-invites-limit-default) was reached.","INVOICE_PAYLOAD_INVALID":"The specified invoice payload is invalid.","JOIN_AS_PEER_INVALID":"The specified peer cannot be used to join a group call.","LANG_CODE_INVALID":"The specified language code is invalid.","LANG_CODE_NOT_SUPPORTED":"The specified language code is not supported.","LANG_PACK_INVALID":"The provided language pack is invalid.","LASTNAME_INVALID":"The last name is invalid.","LIMIT_INVALID":"The provided limit is invalid.","LINK_NOT_MODIFIED":"Discussion link not modified.","LOCATION_INVALID":"The provided location is invalid.","MAX_DATE_INVALID":"The specified maximum date is invalid.","MAX_ID_INVALID":"The provided max ID is invalid.","MAX_QTS_INVALID":"The specified max_qts is invalid.","MD5_CHECKSUM_INVALID":"The MD5 checksums do not match.","MEDIA_CAPTION_TOO_LONG":"The caption is too long.","MEDIA_EMPTY":"The provided media object is invalid.","MEDIA_GROUPED_INVALID":"You tried to send media of different types in an album.","MEDIA_INVALID":"Media invalid.","MEDIA_NEW_INVALID":"The new media is invalid.","MEDIA_PREV_INVALID":"Previous media invalid.","MEGAGROUP_ID_INVALID":"Invalid supergroup ID.","MEGAGROUP_PREHISTORY_HIDDEN":"Group with hidden history for new members can't be set as discussion groups.","MEGAGROUP_REQUIRED":"You can only use this method on a supergroup.","MESSAGE_EDIT_TIME_EXPIRED":"You can't edit this message anymore, too much time has passed since its creation.","MESSAGE_EMPTY":"The provided message is empty.","MESSAGE_ID_INVALID":"The provided message id is invalid.","MESSAGE_IDS_EMPTY":"No message ids were provided.","MESSAGE_NOT_MODIFIED":"The provided message data is identical to the previous message data, the message wasn't modified.","MESSAGE_POLL_CLOSED":"Poll closed.","MESSAGE_TOO_LONG":"The provided message is too long.","METHOD_INVALID":"The specified method is invalid.","MIN_DATE_INVALID":"The specified minimum date is invalid.","MSG_ID_INVALID":"Invalid message ID provided.","MSG_TOO_OLD":"[\`chat_read_mark_expire_period\` seconds](https://core.telegram.org/api/config#chat-read-mark-expire-period) have passed since the message was sent, read receipts were deleted.","MSG_WAIT_FAILED":"A waiting call returned an error.","MULTI_MEDIA_TOO_LONG":"Too many media files for album.","NEW_SALT_INVALID":"The new salt is invalid.","NEW_SETTINGS_EMPTY":"No password is set on the current account, and no new password was specified in \`new_settings\`.","NEW_SETTINGS_INVALID":"The new password settings are invalid.","NEXT_OFFSET_INVALID":"The specified offset is longer than 64 bytes.","OFFSET_INVALID":"The provided offset is invalid.","OFFSET_PEER_ID_INVALID":"The provided offset peer is invalid.","OPTION_INVALID":"Invalid option selected.","OPTIONS_TOO_MUCH":"Too many options provided.","ORDER_INVALID":"The specified username order is invalid.","PACK_SHORT_NAME_INVALID":"Short pack name invalid.","PACK_SHORT_NAME_OCCUPIED":"A stickerpack with this name already exists.","PACK_TITLE_INVALID":"The stickerpack title is invalid.","PARTICIPANT_ID_INVALID":"The specified participant ID is invalid.","PARTICIPANT_JOIN_MISSING":"Trying to enable a presentation, when the user hasn't joined the Video Chat with [phone.joinGroupCall](https://core.telegram.org/method/phone.joinGroupCall).","PARTICIPANT_VERSION_OUTDATED":"The other participant does not use an up to date telegram client with support for calls.","PARTICIPANTS_TOO_FEW":"Not enough participants.","PASSWORD_EMPTY":"The provided password is empty.","PASSWORD_HASH_INVALID":"The provided password hash is invalid.","PASSWORD_MISSING":"You must enable 2FA in order to transfer ownership of a channel.","PASSWORD_RECOVERY_EXPIRED":"The recovery code has expired.","PASSWORD_RECOVERY_NA":"No email was set, can't recover password via email.","PASSWORD_REQUIRED":"A [2FA password](https://core.telegram.org/api/srp) must be configured to use Telegram Passport.","PASSWORD_TOO_FRESH_%d":"The password was added too recently and %d seconds must pass before using the method","PAYMENT_PROVIDER_INVALID":"The specified payment provider is invalid.","PEER_HISTORY_EMPTY":"You can't pin an empty chat with a user.","PEER_ID_INVALID":"The provided peer id is invalid.","PEER_ID_NOT_SUPPORTED":"The provided peer ID is not supported.","PEERS_LIST_EMPTY":"The specified list of peers is empty.","PERSISTENT_TIMESTAMP_EMPTY":"Persistent timestamp empty.","PERSISTENT_TIMESTAMP_INVALID":"Persistent timestamp invalid.","PHONE_CODE_EMPTY":"phone_code is missing.","PHONE_CODE_EXPIRED":"The phone code you provided has expired.","PHONE_CODE_HASH_EMPTY":"phone_code_hash is missing.","PHONE_CODE_INVALID":"The provided phone code is invalid.","PHONE_HASH_EXPIRED":"An invalid or expired \`phone_code_hash\` was provided.","PHONE_NOT_OCCUPIED":"No user is associated to the specified phone number.","PHONE_NUMBER_APP_SIGNUP_FORBIDDEN":"You can't sign up using this app.","PHONE_NUMBER_BANNED":"The provided phone number is banned from telegram.","PHONE_NUMBER_FLOOD":"You asked for the code too many times.","PHONE_NUMBER_INVALID":"The phone number is invalid.","PHONE_NUMBER_OCCUPIED":"The phone number is already in use.","PHONE_NUMBER_UNOCCUPIED":"The phone number is not yet being used.","PHONE_PASSWORD_PROTECTED":"This phone is password protected.","PHOTO_CONTENT_TYPE_INVALID":"Photo mime-type invalid.","PHOTO_CONTENT_URL_EMPTY":"Photo URL invalid.","PHOTO_CROP_FILE_MISSING":"Photo crop file missing.","PHOTO_CROP_SIZE_SMALL":"Photo is too small.","PHOTO_EXT_INVALID":"The extension of the photo is invalid.","PHOTO_FILE_MISSING":"Profile photo file missing.","PHOTO_ID_INVALID":"Photo ID invalid.","PHOTO_INVALID":"Photo invalid.","PHOTO_INVALID_DIMENSIONS":"The photo dimensions are invalid.","PHOTO_SAVE_FILE_INVALID":"Internal issues, try again later.","PHOTO_THUMB_URL_EMPTY":"Photo thumbnail URL is empty.","PIN_RESTRICTED":"You can't pin messages.","PINNED_DIALOGS_TOO_MUCH":"Too many pinned dialogs.","POLL_ANSWER_INVALID":"One of the poll answers is not acceptable.","POLL_ANSWERS_INVALID":"Invalid poll answers were provided.","POLL_OPTION_DUPLICATE":"Duplicate poll options provided.","POLL_OPTION_INVALID":"Invalid poll option provided.","POLL_QUESTION_INVALID":"One of the poll questions is not acceptable.","PRIVACY_KEY_INVALID":"The privacy key is invalid.","PRIVACY_TOO_LONG":"Too many privacy rules were specified, the current limit is 1000.","PRIVACY_VALUE_INVALID":"The specified privacy rule combination is invalid.","PUBLIC_KEY_REQUIRED":"A public key is required.","QUERY_ID_EMPTY":"The query ID is empty.","QUERY_ID_INVALID":"The query ID is invalid.","QUERY_TOO_SHORT":"The query string is too short.","QUIZ_ANSWER_MISSING":"You can forward a quiz while hiding the original author only after choosing an option in the quiz.","QUIZ_CORRECT_ANSWER_INVALID":"An invalid value was provided to the correct_answers field.","QUIZ_CORRECT_ANSWERS_EMPTY":"No correct quiz answer was specified.","QUIZ_CORRECT_ANSWERS_TOO_MUCH":"You specified too many correct answers in a quiz, quizzes can only have one right answer!","QUIZ_MULTIPLE_INVALID":"Quizzes can't have the multiple_choice flag set!","RANDOM_ID_EMPTY":"Random ID empty.","RANDOM_ID_INVALID":"A provided random ID is invalid.","RANDOM_LENGTH_INVALID":"Random length invalid.","RANGES_INVALID":"Invalid range provided.","REACTION_EMPTY":"Empty reaction provided.","REACTION_INVALID":"The specified reaction is invalid.","REACTIONS_TOO_MANY":"The message already has exactly \`reactions_uniq_max\` reaction emojis, you can't react with a new emoji, see [the docs for more info &raquo;](/api/config#client-configuration).","REPLY_MARKUP_BUY_EMPTY":"Reply markup for buy button empty.","REPLY_MARKUP_INVALID":"The provided reply markup is invalid.","REPLY_MARKUP_TOO_LONG":"The specified reply_markup is too long.","RESET_REQUEST_MISSING":"No password reset is in progress.","RESULT_ID_DUPLICATE":"You provided a duplicate result ID.","RESULT_ID_EMPTY":"Result ID empty.","RESULT_ID_INVALID":"One of the specified result IDs is invalid.","RESULT_TYPE_INVALID":"Result type invalid.","RESULTS_TOO_MUCH":"Too many results were provided.","REVOTE_NOT_ALLOWED":"You cannot change your vote.","RIGHTS_NOT_MODIFIED":"The new admin rights are equal to the old rights, no change was made.","RSA_DECRYPT_FAILED":"Internal RSA decryption failed.","SCHEDULE_BOT_NOT_ALLOWED":"Bots cannot schedule messages.","SCHEDULE_DATE_INVALID":"Invalid schedule date provided.","SCHEDULE_DATE_TOO_LATE":"You can't schedule a message this far in the future.","SCHEDULE_STATUS_PRIVATE":"Can't schedule until user is online, if the user's last seen timestamp is hidden by their privacy settings.","SCHEDULE_TOO_MUCH":"There are too many scheduled messages.","SCORE_INVALID":"The specified game score is invalid.","SEARCH_QUERY_EMPTY":"The search query is empty.","SEARCH_WITH_LINK_NOT_SUPPORTED":"You cannot provide a search query and an invite link at the same time.","SECONDS_INVALID":"Invalid duration provided.","SEND_AS_PEER_INVALID":"You can't send messages as the specified peer.","SEND_MESSAGE_MEDIA_INVALID":"Invalid media provided.","SEND_MESSAGE_TYPE_INVALID":"The message type is invalid.","SESSION_TOO_FRESH_%d":"The session logged in too recently and %d seconds must pass before calling the method","SETTINGS_INVALID":"Invalid settings were provided.","SHA256_HASH_INVALID":"The provided SHA256 hash is invalid.","SHORT_NAME_INVALID":"The specified short name is invalid.","SHORT_NAME_OCCUPIED":"The specified short name is already in use.","SLOWMODE_MULTI_MSGS_DISABLED":"Slowmode is enabled, you cannot forward multiple messages to this group.","SMS_CODE_CREATE_FAILED":"An error occurred while creating the SMS code.","SRP_ID_INVALID":"Invalid SRP ID provided.","SRP_PASSWORD_CHANGED":"Password has changed.","START_PARAM_EMPTY":"The start parameter is empty.","START_PARAM_INVALID":"Start parameter invalid.","START_PARAM_TOO_LONG":"Start parameter is too long.","STICKER_DOCUMENT_INVALID":"The specified sticker document is invalid.","STICKER_EMOJI_INVALID":"Sticker emoji invalid.","STICKER_FILE_INVALID":"Sticker file invalid.","STICKER_GIF_DIMENSIONS":"The specified video sticker has invalid dimensions.","STICKER_ID_INVALID":"The provided sticker ID is invalid.","STICKER_INVALID":"The provided sticker is invalid.","STICKER_MIME_INVALID":"The specified sticker MIME type is invalid.","STICKER_PNG_DIMENSIONS":"Sticker png dimensions invalid.","STICKER_PNG_NOPNG":"One of the specified stickers is not a valid PNG file.","STICKER_TGS_NODOC":"You must send the animated sticker as a document.","STICKER_TGS_NOTGS":"Invalid TGS sticker provided.","STICKER_THUMB_PNG_NOPNG":"Incorrect stickerset thumb file provided, PNG / WEBP expected.","STICKER_THUMB_TGS_NOTGS":"Incorrect stickerset TGS thumb file provided.","STICKER_VIDEO_BIG":"The specified video sticker is too big.","STICKER_VIDEO_NODOC":"You must send the video sticker as a document.","STICKER_VIDEO_NOWEBM":"The specified video sticker is not in webm format.","STICKERPACK_STICKERS_TOO_MUCH":"There are too many stickers in this stickerpack, you can't add any more.","STICKERS_EMPTY":"No sticker provided.","STICKERS_TOO_MUCH":"There are too many stickers in this stickerpack, you can't add any more.","STICKERSET_INVALID":"The provided sticker set is invalid.","SWITCH_PM_TEXT_EMPTY":"The switch_pm.text field was empty.","TAKEOUT_REQUIRED":"A takeout session has to be initialized, first.","TASK_ALREADY_EXISTS":"An email reset was already requested.","TEMP_AUTH_KEY_ALREADY_BOUND":"The passed temporary key is already bound to another **perm_auth_key_id**.","TEMP_AUTH_KEY_EMPTY":"No temporary auth key provided.","THEME_FILE_INVALID":"Invalid theme file provided.","THEME_FORMAT_INVALID":"Invalid theme format provided.","THEME_INVALID":"Invalid theme provided.","THEME_MIME_INVALID":"The theme's MIME type is invalid.","THEME_TITLE_INVALID":"The specified theme title is invalid.","TITLE_INVALID":"The specified stickerpack title is invalid.","TMP_PASSWORD_DISABLED":"The temporary password is disabled.","TO_LANG_INVALID":"The specified destination language is invalid.","TOKEN_EMPTY":"The specified token is empty.","TOKEN_INVALID":"The provided token is invalid.","TOKEN_TYPE_INVALID":"The specified token type is invalid.","TOPIC_CLOSED":"This topic was closed, you can't send messages to it anymore.","TOPIC_DELETED":"The specified topic was deleted.","TOPIC_ID_INVALID":"The specified topic ID is invalid.","TOPIC_NOT_MODIFIED":"The updated topic info is equal to the current topic info, nothing was changed.","TRANSCRIPTION_FAILED":"Audio transcription failed.","TTL_DAYS_INVALID":"The provided TTL is invalid.","TTL_MEDIA_INVALID":"Invalid media Time To Live was provided.","TTL_PERIOD_INVALID":"The specified TTL period is invalid.","TYPES_EMPTY":"No top peer type was provided.","UNTIL_DATE_INVALID":"Invalid until date provided.","URL_INVALID":"Invalid URL provided.","USAGE_LIMIT_INVALID":"The specified usage limit is invalid.","USER_ADMIN_INVALID":"You're not an admin.","USER_ALREADY_INVITED":"You have already invited this user.","USER_ALREADY_PARTICIPANT":"The user is already in the group.","USER_BANNED_IN_CHANNEL":"You're banned from sending messages in supergroups/channels.","USER_BLOCKED":"User blocked.","USER_BOT":"Bots can only be admins in channels.","USER_BOT_INVALID":"User accounts must provide the \`bot\` method parameter when calling this method. If there is no such method parameter, this method can only be invoked by bot accounts.","USER_BOT_REQUIRED":"This method can only be called by a bot.","USER_CHANNELS_TOO_MUCH":"One of the users you tried to add is already in too many channels/supergroups.","USER_CREATOR":"You can't leave this channel, because you're its creator.","USER_ID_INVALID":"The provided user ID is invalid.","USER_INVALID":"Invalid user provided.","USER_IS_BLOCKED":"You were blocked by this user.","USER_IS_BOT":"Bots can't send messages to other bots.","USER_KICKED":"This user was kicked from this supergroup/channel.","USER_NOT_MUTUAL_CONTACT":"The provided user is not a mutual contact.","USER_NOT_PARTICIPANT":"You're not a member of this supergroup/channel.","USER_VOLUME_INVALID":"The specified user volume is invalid.","USERNAME_INVALID":"The provided username is not valid.","USERNAME_NOT_MODIFIED":"The username was not modified.","USERNAME_NOT_OCCUPIED":"The provided username is not occupied.","USERNAME_OCCUPIED":"The provided username is already occupied.","USERNAME_PURCHASE_AVAILABLE":"The specified username can be purchased on https://fragment.com.","USERNAMES_ACTIVE_TOO_MUCH":"The maximum number of active usernames was reached.","USERPIC_UPLOAD_REQUIRED":"You must have a profile picture to publish your geolocation.","USERS_TOO_FEW":"Not enough users (to create a chat, for example).","USERS_TOO_MUCH":"The maximum number of users has been exceeded (to create a chat, for example).","VIDEO_CONTENT_TYPE_INVALID":"The video's content type is invalid.","VIDEO_FILE_INVALID":"The specified video file is invalid.","VIDEO_TITLE_EMPTY":"The specified video title is empty.","VOICE_MESSAGES_FORBIDDEN":"This user's privacy settings forbid you from sending voice messages.","WALLPAPER_FILE_INVALID":"The specified wallpaper file is invalid.","WALLPAPER_INVALID":"The specified wallpaper is invalid.","WALLPAPER_MIME_INVALID":"The specified wallpaper MIME type is invalid.","WC_CONVERT_URL_INVALID":"WC convert URL invalid.","WEBDOCUMENT_INVALID":"Invalid webdocument URL provided.","WEBDOCUMENT_MIME_INVALID":"Invalid webdocument mime type provided.","WEBDOCUMENT_SIZE_TOO_BIG":"Webdocument is too big!","WEBDOCUMENT_URL_INVALID":"The specified webdocument URL is invalid.","WEBPAGE_CURL_FAILED":"Failure while fetching the webpage with cURL.","WEBPAGE_MEDIA_EMPTY":"Webpage media empty.","WEBPUSH_AUTH_INVALID":"The specified web push authentication secret is invalid.","WEBPUSH_KEY_INVALID":"The specified web push elliptic curve Diffie-Hellman public key is invalid.","WEBPUSH_TOKEN_INVALID":"The specified web push token is invalid.","YOU_BLOCKED_USER":"You blocked this user.","BROADCAST_FORBIDDEN":"Participants of polls in channels should stay anonymous.","CHANNEL_PUBLIC_GROUP_NA":"channel/supergroup not available.","CHAT_ADMIN_INVITE_REQUIRED":"You do not have the rights to do this.","CHAT_GUEST_SEND_FORBIDDEN":"You join the discussion group before commenting, see [here &raquo;](/api/discussion#requiring-users-to-join-the-group) for more info.","CHAT_SEND_AUDIOS_FORBIDDEN":"You can't send audio messages in this chat.","CHAT_SEND_DOCS_FORBIDDEN":"You can't send documents in this chat.","CHAT_SEND_GAME_FORBIDDEN":"You can't send a game to this chat.","CHAT_SEND_GIFS_FORBIDDEN":"You can't send gifs in this chat.","CHAT_SEND_MEDIA_FORBIDDEN":"You can't send media in this chat.","CHAT_SEND_PHOTOS_FORBIDDEN":"You can't send photos in this chat.","CHAT_SEND_PLAIN_FORBIDDEN":"You can't send non-media (text) messages in this chat.","CHAT_SEND_POLL_FORBIDDEN":"You can't send polls in this chat.","CHAT_SEND_STICKERS_FORBIDDEN":"You can't send stickers in this chat.","CHAT_SEND_VIDEOS_FORBIDDEN":"You can't send videos in this chat.","CHAT_SEND_VOICES_FORBIDDEN":"You can't send voice recordings in this chat.","CHAT_WRITE_FORBIDDEN":"You can't write in this chat.","EDIT_BOT_INVITE_FORBIDDEN":"Normal users can't edit invites that were created by bots.","GROUPCALL_ALREADY_STARTED":"The groupcall has already started, you can join directly using [phone.joinGroupCall](https://core.telegram.org/method/phone.joinGroupCall).","INLINE_BOT_REQUIRED":"Only the inline bot can edit message.","MESSAGE_AUTHOR_REQUIRED":"Message author required.","MESSAGE_DELETE_FORBIDDEN":"You can't delete one of the messages you tried to delete, most likely because it is a service message.","POLL_VOTE_REQUIRED":"Cast a vote in the poll before calling this method.","PREMIUM_ACCOUNT_REQUIRED":"A premium account is required to execute this action.","PUBLIC_CHANNEL_MISSING":"You can only export group call invite links for public chats or channels.","RIGHT_FORBIDDEN":"Your admin rights do not allow you to do this.","SENSITIVE_CHANGE_FORBIDDEN":"You can't change your sensitive content settings.","USER_DELETED":"You can't send this secret message because the other participant deleted their account.","USER_PRIVACY_RESTRICTED":"The user's privacy settings do not allow you to do this.","USER_RESTRICTED":"You're spamreported, you can't create channels or chats.","FILEREF_UPGRADE_NEEDED":"The client has to be updated in order to support [file references](https://core.telegram.org/api/file_reference).","FRESH_CHANGE_PHONE_FORBIDDEN":"You can't change phone number right after logging in, please wait at least 24 hours.","FRESH_RESET_AUTHORISATION_FORBIDDEN":"You can't logout other sessions if less than 24 hours have passed since you logged on the current session.","PAYMENT_UNSUPPORTED":"A detailed description of the error will be received separately as described [here &raquo;](https://core.telegram.org/api/errors#406-not-acceptable).","PHONE_PASSWORD_FLOOD":"You have tried logging in too many times.","PREVIOUS_CHAT_IMPORT_ACTIVE_WAIT_%dMIN":"Similar to a flood wait, must wait %d minutes","SEND_CODE_UNAVAILABLE":"Returned when all available options for this type of number were already used (e.g. flash-call, then SMS, then this error might be returned to trigger a second resend).","STICKERSET_OWNER_ANONYMOUS":"Provided stickerset can't be installed as group stickerset to prevent admin deanonymization.","USERPIC_PRIVACY_REQUIRED":"You need to disable privacy settings for your profile picture in order to make your geolocation public.","2FA_CONFIRM_WAIT_%d":"The account is 2FA protected so it will be deleted in a week. Otherwise it can be reset in %d","SLOWMODE_WAIT_%d":"A wait of %d seconds is required before sending another message in this chat","TAKEOUT_INIT_DELAY_%d":"A wait of %d seconds is required before being able to initiate the takeout","AUTH_RESTART":"Restart the authorization process.","CDN_UPLOAD_TIMEOUT":"A server-side timeout occurred while reuploading the file to the CDN DC.","CHAT_ID_GENERATE_FAILED":"Failure while generating the chat ID.","PERSISTENT_TIMESTAMP_OUTDATED":"Channel internal replication issues, try again later (treat this like an RPC_CALL_FAIL).","RANDOM_ID_DUPLICATE":"You provided a random ID that was already used.","SIGN_IN_FAILED":"Failure while signing in.","Invalid msg_resend_req query":"Invalid msg_resend_req query.","Invalid msgs_ack query":"Invalid msgs_ack query.","Invalid msgs_state_req query":"Invalid msgs_state_req query.","Timeout":"Timeout while fetching data.","SESSION_PASSWORD_NEEDED":"2FA is enabled, use a password to login.","ACTIVE_USER_REQUIRED":"The method is only available to already activated users","AUTH_KEY_DUPLICATED":"The authorization key (session file) was used under two different IP addresses simultaneously, and can no longer be used. Use the same session exclusively, or use different sessions","AUTH_KEY_INVALID":"The key is invalid","AUTH_KEY_PERM_EMPTY":"The method is unavailable for temporary authorization key, not bound to permanent","AUTH_KEY_UNREGISTERED":"The key is not registered in the system","AUTH_TOKEN_INVALID2":"An invalid authorization token was provided","BASE_PORT_LOC_INVALID":"Base port location invalid","BOT_GAMES_DISABLED":"Bot games cannot be used in this type of chat","BOT_METHOD_INVALID":"The API access for bot users is restricted. The method you tried to invoke cannot be executed as a bot","BOT_POLLS_DISABLED":"You cannot create polls under a bot account","CHANNEL_BANNED":"The channel is banned","CHAT_FORBIDDEN":"You cannot write in this chat","CHP_CALL_FAIL":"The statistics cannot be retrieved at this time","CONNECTION_DEVICE_MODEL_EMPTY":"Device model empty","CONNECTION_LANG_PACK_INVALID":"The specified language pack is not valid. This is meant to be used by official applications only so far, leave it empty","CONNECTION_NOT_INITED":"Connection not initialized","CONNECTION_SYSTEM_EMPTY":"Connection system empty","CONNECTION_SYSTEM_LANG_CODE_EMPTY":"The system language string was empty during connection","ENCRYPTION_OCCUPY_FAILED":"TDLib developer claimed it is not an error while accepting secret chats and 500 is used instead of 420","FIELD_NAME_EMPTY":"The field with the name FIELD_NAME is missing","FIELD_NAME_INVALID":"The field with the name FIELD_NAME is invalid","FILE_PART_0_MISSING":"File part 0 missing","FILE_PART_%d_MISSING":"Part %d of the file is missing from storage","FLOOD_TEST_PHONE_WAIT_%d":"A wait of %d seconds is required in the test servers","GROUP_CALL_INVALID":"Group call invalid","HISTORY_GET_FAILED":"Fetching of history failed","INPUT_CONSTRUCTOR_INVALID":"The provided constructor is invalid","INPUT_FETCH_ERROR":"An error occurred while deserializing TL parameters","INPUT_FETCH_FAIL":"Failed deserializing TL payload","INPUT_LAYER_INVALID":"The provided layer is invalid","INPUT_METHOD_INVALID":"The invoked method does not exist anymore or has never existed","INPUT_REQUEST_TOO_LONG":"The input request was too long. This may be a bug in the library as it can occur when serializing more bytes than it should (like appending the vector constructor code at the end of a message)","INTERDC_%d_CALL_ERROR":"An error occurred while communicating with DC %d","INTERDC_%d_CALL_RICH_ERROR":"A rich error occurred while communicating with DC %d","MEMBER_NO_LOCATION":"An internal failure occurred while fetching user info (couldn't find location)","MEMBER_OCCUPY_PRIMARY_LOC_FAILED":"Occupation of primary member location failed","MSGID_DECREASE_RETRY":"The request should be retried with a lower message ID","NEED_CHAT_INVALID":"The provided chat is invalid","NEED_MEMBER_INVALID":"The provided member is invalid or does not exist (for example a thumb size)","PARTICIPANT_CALL_FAILED":"Failure while making call","PEER_FLOOD":"Too many requests","POLL_UNSUPPORTED":"This layer does not support polls in the issued method","POSTPONED_TIMEOUT":"The postponed call has timed out","PTS_CHANGE_EMPTY":"No PTS change","REFLECTOR_NOT_AVAILABLE":"Invalid call reflector server","REG_ID_GENERATE_FAILED":"Failure while generating registration ID","REPLY_MARKUP_GAME_EMPTY":"The provided reply markup for the game is empty","RPC_CALL_FAIL":"Telegram is having internal issues, please try again later.","RPC_MCGET_FAIL":"Telegram is having internal issues, please try again later.","SESSION_EXPIRED":"The authorization has expired","SESSION_REVOKED":"The authorization has been invalidated, because of the user terminating all sessions","SHORTNAME_OCCUPY_FAILED":"An error occurred when trying to register the short-name used for the sticker pack. Try a different name","STORAGE_CHECK_FAILED":"Server storage check failed","TAKEOUT_INVALID":"The takeout session has been invalidated by another data export session","TMP_PASSWORD_INVALID":"Password auth needs to be regenerated","TYPE_CONSTRUCTOR_INVALID":"The type constructor is invalid","Timedout":"Timeout while fetching data","UNKNOWN_METHOD":"The method you tried to call cannot be called on non-CDN DCs","USER_DEACTIVATED":"The user has been deleted/deactivated","USER_DEACTIVATED_BAN":"The user has been deleted/deactivated","USER_MIGRATE_%d":"The user whose identity is being used to execute queries is associated with DC %d","WORKER_BUSY_TOO_LONG_RETRY":"Telegram workers are too busy to respond immediately"}`);
          class RpcError extends Error {
            constructor(code2, text2, description) {
              super(description || "Unknown RPC error: [" + code2 + ":" + text2 + "]");
              this.code = code2;
              this.text = text2;
            }
            static is(err, text2) {
              return err.constructor === RpcError && (!text2 || err.text === text2);
            }
            is(text2) {
              return this.text === text2;
            }
          }
          RpcError.fromTl = function(obj) {
            if (obj.errorMessage in _descriptionsMap) {
              return new RpcError(obj.errorCode, obj.errorMessage, _descriptionsMap[obj.errorMessage]);
            }
            var err = new RpcError(obj.errorCode, obj.errorMessage);
            var match2, param;
            if ((match2 = err.text.match(/^FLOOD_WAIT_(\d+)$/)) != null) {
              err.text = "FLOOD_WAIT_%d";
              param = err.seconds = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^FILE_MIGRATE_(\d+)$/)) != null) {
              err.text = "FILE_MIGRATE_%d";
              param = err.newDc = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^NETWORK_MIGRATE_(\d+)$/)) != null) {
              err.text = "NETWORK_MIGRATE_%d";
              param = err.newDc = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^PHONE_MIGRATE_(\d+)$/)) != null) {
              err.text = "PHONE_MIGRATE_%d";
              param = err.newDc = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^STATS_MIGRATE_(\d+)$/)) != null) {
              err.text = "STATS_MIGRATE_%d";
              param = err.dc = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^EMAIL_UNCONFIRMED_(\d+)$/)) != null) {
              err.text = "EMAIL_UNCONFIRMED_%d";
              param = err.codeLength = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^PASSWORD_TOO_FRESH_(\d+)$/)) != null) {
              err.text = "PASSWORD_TOO_FRESH_%d";
              param = err.seconds = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^SESSION_TOO_FRESH_(\d+)$/)) != null) {
              err.text = "SESSION_TOO_FRESH_%d";
              param = err.seconds = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^PREVIOUS_CHAT_IMPORT_ACTIVE_WAIT_(\d+)MIN$/)) != null) {
              err.text = "PREVIOUS_CHAT_IMPORT_ACTIVE_WAIT_%dMIN";
              param = err.minutes = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^2FA_CONFIRM_WAIT_(\d+)$/)) != null) {
              err.text = "2FA_CONFIRM_WAIT_%d";
              param = err.seconds = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^SLOWMODE_WAIT_(\d+)$/)) != null) {
              err.text = "SLOWMODE_WAIT_%d";
              param = err.seconds = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^TAKEOUT_INIT_DELAY_(\d+)$/)) != null) {
              err.text = "TAKEOUT_INIT_DELAY_%d";
              param = err.seconds = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^FILE_PART_(\d+)_MISSING$/)) != null) {
              err.text = "FILE_PART_%d_MISSING";
              param = err.which = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^FLOOD_TEST_PHONE_WAIT_(\d+)$/)) != null) {
              err.text = "FLOOD_TEST_PHONE_WAIT_%d";
              param = err.seconds = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^INTERDC_(\d+)_CALL_ERROR$/)) != null) {
              err.text = "INTERDC_%d_CALL_ERROR";
              param = err.dc = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^INTERDC_(\d+)_CALL_RICH_ERROR$/)) != null) {
              err.text = "INTERDC_%d_CALL_RICH_ERROR";
              param = err.dc = parseInt(match2[1]);
            } else if ((match2 = err.text.match(/^USER_MIGRATE_(\d+)$/)) != null) {
              err.text = "USER_MIGRATE_%d";
              param = err.newDc = parseInt(match2[1]);
            } else
              return err;
            err.message = _descriptionsMap[err.text].replace("%d", param);
            return err;
          };
          RpcError.create = function(code2, text2) {
            var desc2 = _descriptionsMap[text2];
            var err = new RpcError(code2, text2, desc2);
            if (!desc2) {
              err.unknown = true;
            }
            return err;
          };
          RpcError.BAD_REQUEST = 400;
          RpcError.UNAUTHORIZED = 401;
          RpcError.FORBIDDEN = 403;
          RpcError.NOT_FOUND = 404;
          RpcError.FLOOD = 420;
          RpcError.SEE_OTHER = 303;
          RpcError.NOT_ACCEPTABLE = 406;
          RpcError.INTERNAL = 500;
          ns.RpcError = RpcError;
          ns.isAnyError = _isAny("Error");
          ns.isAnyIpPort = _isAny("IpPort");
          ns.isAnyAccessPointRule = _isAny("AccessPointRule");
          ns.isAnyInputFileLocation = _isAny("InputFileLocation");
          ns.isAnyInputPeer = _isAny("InputPeer");
          ns.isAnyInputUser = _isAny("InputUser");
          ns.isAnyInputContact = _isAny("InputContact");
          ns.isAnyInputFile = _isAny("InputFile");
          ns.isAnyInputMedia = _isAny("InputMedia");
          ns.isAnyInputChatPhoto = _isAny("InputChatPhoto");
          ns.isAnyInputGeoPoint = _isAny("InputGeoPoint");
          ns.isAnyInputPhoto = _isAny("InputPhoto");
          ns.isAnyPeer = _isAny("Peer");
          ns.isAnyUser = _isAny("User");
          ns.isAnyUserProfilePhoto = _isAny("UserProfilePhoto");
          ns.isAnyUserStatus = _isAny("UserStatus");
          ns.isAnyChat = _isAny("Chat");
          ns.isAnyChatFull = _isAny("ChatFull");
          ns.isAnyChatParticipant = _isAny("ChatParticipant");
          ns.isAnyChatParticipants = _isAny("ChatParticipants");
          ns.isAnyChatPhoto = _isAny("ChatPhoto");
          ns.isAnyMessage = _isAny("Message");
          ns.isAnyMessageMedia = _isAny("MessageMedia");
          ns.isAnyMessageAction = _isAny("MessageAction");
          ns.isAnyDialog = _isAny("Dialog");
          ns.isAnyPhoto = _isAny("Photo");
          ns.isAnyPhotoSize = _isAny("PhotoSize");
          ns.isAnyGeoPoint = _isAny("GeoPoint");
          ns.isAnyInputNotifyPeer = _isAny("InputNotifyPeer");
          ns.isAnyInputPeerNotifySettings = _isAny("InputPeerNotifySettings");
          ns.isAnyPeerNotifySettings = _isAny("PeerNotifySettings");
          ns.isAnyPeerSettings = _isAny("PeerSettings");
          ns.isAnyWallPaper = _isAny("WallPaper");
          ns.isAnyReportReason = _isAny("ReportReason");
          ns.isAnyUserFull = _isAny("UserFull");
          ns.isAnyContact = _isAny("Contact");
          ns.isAnyImportedContact = _isAny("ImportedContact");
          ns.isAnyContactStatus = _isAny("ContactStatus");
          ns.isAnyMessagesFilter = _isAny("MessagesFilter");
          ns.isAnyUpdate = _isAny("Update");
          ns.isAnyUpdates = _isAny("Updates");
          ns.isAnyDcOption = _isAny("DcOption");
          ns.isAnyConfig = _isAny("Config");
          ns.isAnyNearestDc = _isAny("NearestDc");
          ns.isAnyEncryptedChat = _isAny("EncryptedChat");
          ns.isAnyInputEncryptedChat = _isAny("InputEncryptedChat");
          ns.isAnyEncryptedFile = _isAny("EncryptedFile");
          ns.isAnyInputEncryptedFile = _isAny("InputEncryptedFile");
          ns.isAnyEncryptedMessage = _isAny("EncryptedMessage");
          ns.isAnyInputDocument = _isAny("InputDocument");
          ns.isAnyDocument = _isAny("Document");
          ns.isAnyNotifyPeer = _isAny("NotifyPeer");
          ns.isAnySendMessageAction = _isAny("SendMessageAction");
          ns.isAnyInputPrivacyKey = _isAny("InputPrivacyKey");
          ns.isAnyPrivacyKey = _isAny("PrivacyKey");
          ns.isAnyInputPrivacyRule = _isAny("InputPrivacyRule");
          ns.isAnyPrivacyRule = _isAny("PrivacyRule");
          ns.isAnyAccountDaysTTL = _isAny("AccountDaysTTL");
          ns.isAnyDocumentAttribute = _isAny("DocumentAttribute");
          ns.isAnyStickerPack = _isAny("StickerPack");
          ns.isAnyWebPage = _isAny("WebPage");
          ns.isAnyAuthorization = _isAny("Authorization");
          ns.isAnyReceivedNotifyMessage = _isAny("ReceivedNotifyMessage");
          ns.isAnyExportedChatInvite = _isAny("ExportedChatInvite");
          ns.isAnyChatInvite = _isAny("ChatInvite");
          ns.isAnyInputStickerSet = _isAny("InputStickerSet");
          ns.isAnyStickerSet = _isAny("StickerSet");
          ns.isAnyBotCommand = _isAny("BotCommand");
          ns.isAnyBotInfo = _isAny("BotInfo");
          ns.isAnyKeyboardButton = _isAny("KeyboardButton");
          ns.isAnyKeyboardButtonRow = _isAny("KeyboardButtonRow");
          ns.isAnyReplyMarkup = _isAny("ReplyMarkup");
          ns.isAnyMessageEntity = _isAny("MessageEntity");
          ns.isAnyInputChannel = _isAny("InputChannel");
          ns.isAnyMessageRange = _isAny("MessageRange");
          ns.isAnyChannelMessagesFilter = _isAny("ChannelMessagesFilter");
          ns.isAnyChannelParticipant = _isAny("ChannelParticipant");
          ns.isAnyChannelParticipantsFilter = _isAny("ChannelParticipantsFilter");
          ns.isAnyInputBotInlineMessage = _isAny("InputBotInlineMessage");
          ns.isAnyInputBotInlineResult = _isAny("InputBotInlineResult");
          ns.isAnyBotInlineMessage = _isAny("BotInlineMessage");
          ns.isAnyBotInlineResult = _isAny("BotInlineResult");
          ns.isAnyExportedMessageLink = _isAny("ExportedMessageLink");
          ns.isAnyMessageFwdHeader = _isAny("MessageFwdHeader");
          ns.isAnyInputBotInlineMessageID = _isAny("InputBotInlineMessageID");
          ns.isAnyInlineBotSwitchPM = _isAny("InlineBotSwitchPM");
          ns.isAnyTopPeer = _isAny("TopPeer");
          ns.isAnyTopPeerCategory = _isAny("TopPeerCategory");
          ns.isAnyTopPeerCategoryPeers = _isAny("TopPeerCategoryPeers");
          ns.isAnyDraftMessage = _isAny("DraftMessage");
          ns.isAnyStickerSetCovered = _isAny("StickerSetCovered");
          ns.isAnyMaskCoords = _isAny("MaskCoords");
          ns.isAnyInputStickeredMedia = _isAny("InputStickeredMedia");
          ns.isAnyGame = _isAny("Game");
          ns.isAnyInputGame = _isAny("InputGame");
          ns.isAnyHighScore = _isAny("HighScore");
          ns.isAnyRichText = _isAny("RichText");
          ns.isAnyPageBlock = _isAny("PageBlock");
          ns.isAnyPhoneCallDiscardReason = _isAny("PhoneCallDiscardReason");
          ns.isAnyDataJSON = _isAny("DataJSON");
          ns.isAnyLabeledPrice = _isAny("LabeledPrice");
          ns.isAnyInvoice = _isAny("Invoice");
          ns.isAnyPaymentCharge = _isAny("PaymentCharge");
          ns.isAnyPostAddress = _isAny("PostAddress");
          ns.isAnyPaymentRequestedInfo = _isAny("PaymentRequestedInfo");
          ns.isAnyPaymentSavedCredentials = _isAny("PaymentSavedCredentials");
          ns.isAnyWebDocument = _isAny("WebDocument");
          ns.isAnyInputWebDocument = _isAny("InputWebDocument");
          ns.isAnyInputWebFileLocation = _isAny("InputWebFileLocation");
          ns.isAnyInputPaymentCredentials = _isAny("InputPaymentCredentials");
          ns.isAnyShippingOption = _isAny("ShippingOption");
          ns.isAnyInputStickerSetItem = _isAny("InputStickerSetItem");
          ns.isAnyInputPhoneCall = _isAny("InputPhoneCall");
          ns.isAnyPhoneCall = _isAny("PhoneCall");
          ns.isAnyPhoneConnection = _isAny("PhoneConnection");
          ns.isAnyPhoneCallProtocol = _isAny("PhoneCallProtocol");
          ns.isAnyCdnPublicKey = _isAny("CdnPublicKey");
          ns.isAnyCdnConfig = _isAny("CdnConfig");
          ns.isAnyLangPackString = _isAny("LangPackString");
          ns.isAnyLangPackDifference = _isAny("LangPackDifference");
          ns.isAnyLangPackLanguage = _isAny("LangPackLanguage");
          ns.isAnyChannelAdminLogEventAction = _isAny("ChannelAdminLogEventAction");
          ns.isAnyChannelAdminLogEvent = _isAny("ChannelAdminLogEvent");
          ns.isAnyChannelAdminLogEventsFilter = _isAny("ChannelAdminLogEventsFilter");
          ns.isAnyPopularContact = _isAny("PopularContact");
          ns.isAnyRecentMeUrl = _isAny("RecentMeUrl");
          ns.isAnyInputSingleMedia = _isAny("InputSingleMedia");
          ns.isAnyWebAuthorization = _isAny("WebAuthorization");
          ns.isAnyInputMessage = _isAny("InputMessage");
          ns.isAnyInputDialogPeer = _isAny("InputDialogPeer");
          ns.isAnyDialogPeer = _isAny("DialogPeer");
          ns.isAnyFileHash = _isAny("FileHash");
          ns.isAnyInputClientProxy = _isAny("InputClientProxy");
          ns.isAnyInputSecureFile = _isAny("InputSecureFile");
          ns.isAnySecureFile = _isAny("SecureFile");
          ns.isAnySecureData = _isAny("SecureData");
          ns.isAnySecurePlainData = _isAny("SecurePlainData");
          ns.isAnySecureValueType = _isAny("SecureValueType");
          ns.isAnySecureValue = _isAny("SecureValue");
          ns.isAnyInputSecureValue = _isAny("InputSecureValue");
          ns.isAnySecureValueHash = _isAny("SecureValueHash");
          ns.isAnySecureValueError = _isAny("SecureValueError");
          ns.isAnySecureCredentialsEncrypted = _isAny("SecureCredentialsEncrypted");
          ns.isAnySavedContact = _isAny("SavedContact");
          ns.isAnyPasswordKdfAlgo = _isAny("PasswordKdfAlgo");
          ns.isAnySecurePasswordKdfAlgo = _isAny("SecurePasswordKdfAlgo");
          ns.isAnySecureSecretSettings = _isAny("SecureSecretSettings");
          ns.isAnyInputCheckPasswordSRP = _isAny("InputCheckPasswordSRP");
          ns.isAnySecureRequiredType = _isAny("SecureRequiredType");
          ns.isAnyInputAppEvent = _isAny("InputAppEvent");
          ns.isAnyJSONObjectValue = _isAny("JSONObjectValue");
          ns.isAnyJSONValue = _isAny("JSONValue");
          ns.isAnyPageTableCell = _isAny("PageTableCell");
          ns.isAnyPageTableRow = _isAny("PageTableRow");
          ns.isAnyPageCaption = _isAny("PageCaption");
          ns.isAnyPageListItem = _isAny("PageListItem");
          ns.isAnyPageListOrderedItem = _isAny("PageListOrderedItem");
          ns.isAnyPageRelatedArticle = _isAny("PageRelatedArticle");
          ns.isAnyPage = _isAny("Page");
          ns.isAnyPollAnswer = _isAny("PollAnswer");
          ns.isAnyPoll = _isAny("Poll");
          ns.isAnyPollAnswerVoters = _isAny("PollAnswerVoters");
          ns.isAnyPollResults = _isAny("PollResults");
          ns.isAnyChatOnlines = _isAny("ChatOnlines");
          ns.isAnyStatsURL = _isAny("StatsURL");
          ns.isAnyChatAdminRights = _isAny("ChatAdminRights");
          ns.isAnyChatBannedRights = _isAny("ChatBannedRights");
          ns.isAnyInputWallPaper = _isAny("InputWallPaper");
          ns.isAnyCodeSettings = _isAny("CodeSettings");
          ns.isAnyWallPaperSettings = _isAny("WallPaperSettings");
          ns.isAnyAutoDownloadSettings = _isAny("AutoDownloadSettings");
          ns.isAnyEmojiKeyword = _isAny("EmojiKeyword");
          ns.isAnyEmojiKeywordsDifference = _isAny("EmojiKeywordsDifference");
          ns.isAnyEmojiURL = _isAny("EmojiURL");
          ns.isAnyEmojiLanguage = _isAny("EmojiLanguage");
          ns.isAnyFolder = _isAny("Folder");
          ns.isAnyInputFolderPeer = _isAny("InputFolderPeer");
          ns.isAnyFolderPeer = _isAny("FolderPeer");
          ns.isAnyUrlAuthResult = _isAny("UrlAuthResult");
          ns.isAnyChannelLocation = _isAny("ChannelLocation");
          ns.isAnyPeerLocated = _isAny("PeerLocated");
          ns.isAnyRestrictionReason = _isAny("RestrictionReason");
          ns.isAnyInputTheme = _isAny("InputTheme");
          ns.isAnyTheme = _isAny("Theme");
          ns.isAnyBaseTheme = _isAny("BaseTheme");
          ns.isAnyInputThemeSettings = _isAny("InputThemeSettings");
          ns.isAnyThemeSettings = _isAny("ThemeSettings");
          ns.isAnyWebPageAttribute = _isAny("WebPageAttribute");
          ns.isAnyBankCardOpenUrl = _isAny("BankCardOpenUrl");
          ns.isAnyDialogFilter = _isAny("DialogFilter");
          ns.isAnyDialogFilterSuggested = _isAny("DialogFilterSuggested");
          ns.isAnyStatsDateRangeDays = _isAny("StatsDateRangeDays");
          ns.isAnyStatsAbsValueAndPrev = _isAny("StatsAbsValueAndPrev");
          ns.isAnyStatsPercentValue = _isAny("StatsPercentValue");
          ns.isAnyStatsGraph = _isAny("StatsGraph");
          ns.isAnyVideoSize = _isAny("VideoSize");
          ns.isAnyStatsGroupTopPoster = _isAny("StatsGroupTopPoster");
          ns.isAnyStatsGroupTopAdmin = _isAny("StatsGroupTopAdmin");
          ns.isAnyStatsGroupTopInviter = _isAny("StatsGroupTopInviter");
          ns.isAnyGlobalPrivacySettings = _isAny("GlobalPrivacySettings");
          ns.isAnyMessageViews = _isAny("MessageViews");
          ns.isAnyMessageReplyHeader = _isAny("MessageReplyHeader");
          ns.isAnyMessageReplies = _isAny("MessageReplies");
          ns.isAnyPeerBlocked = _isAny("PeerBlocked");
          ns.isAnyGroupCall = _isAny("GroupCall");
          ns.isAnyInputGroupCall = _isAny("InputGroupCall");
          ns.isAnyGroupCallParticipant = _isAny("GroupCallParticipant");
          ns.isAnyInlineQueryPeerType = _isAny("InlineQueryPeerType");
          ns.isAnyChatInviteImporter = _isAny("ChatInviteImporter");
          ns.isAnyChatAdminWithInvites = _isAny("ChatAdminWithInvites");
          ns.isAnyGroupCallParticipantVideoSourceGroup = _isAny("GroupCallParticipantVideoSourceGroup");
          ns.isAnyGroupCallParticipantVideo = _isAny("GroupCallParticipantVideo");
          ns.isAnyBotCommandScope = _isAny("BotCommandScope");
          ns.isAnySponsoredMessage = _isAny("SponsoredMessage");
          ns.isAnySearchResultsCalendarPeriod = _isAny("SearchResultsCalendarPeriod");
          ns.isAnySearchResultsPosition = _isAny("SearchResultsPosition");
          ns.isAnyReactionCount = _isAny("ReactionCount");
          ns.isAnyMessageReactions = _isAny("MessageReactions");
          ns.isAnyAvailableReaction = _isAny("AvailableReaction");
          ns.isAnyMessagePeerReaction = _isAny("MessagePeerReaction");
          ns.isAnyGroupCallStreamChannel = _isAny("GroupCallStreamChannel");
          ns.isAnyAttachMenuBotIconColor = _isAny("AttachMenuBotIconColor");
          ns.isAnyAttachMenuBotIcon = _isAny("AttachMenuBotIcon");
          ns.isAnyAttachMenuBot = _isAny("AttachMenuBot");
          ns.isAnyAttachMenuBots = _isAny("AttachMenuBots");
          ns.isAnyAttachMenuBotsBot = _isAny("AttachMenuBotsBot");
          ns.isAnyWebViewResult = _isAny("WebViewResult");
          ns.isAnyWebViewMessageSent = _isAny("WebViewMessageSent");
          ns.isAnyBotMenuButton = _isAny("BotMenuButton");
          ns.isAnyNotificationSound = _isAny("NotificationSound");
          ns.isAnyAttachMenuPeerType = _isAny("AttachMenuPeerType");
          ns.isAnyInputInvoice = _isAny("InputInvoice");
          ns.isAnyInputStorePaymentPurpose = _isAny("InputStorePaymentPurpose");
          ns.isAnyPremiumGiftOption = _isAny("PremiumGiftOption");
          ns.isAnyPaymentFormMethod = _isAny("PaymentFormMethod");
          ns.isAnyEmojiStatus = _isAny("EmojiStatus");
          ns.isAnyReaction = _isAny("Reaction");
          ns.isAnyChatReactions = _isAny("ChatReactions");
          ns.isAnyEmailVerifyPurpose = _isAny("EmailVerifyPurpose");
          ns.isAnyEmailVerification = _isAny("EmailVerification");
          ns.isAnyPremiumSubscriptionOption = _isAny("PremiumSubscriptionOption");
          ns.isAnySendAsPeer = _isAny("SendAsPeer");
          ns.isAnyMessageExtendedMedia = _isAny("MessageExtendedMedia");
          ns.isAnyStickerKeyword = _isAny("StickerKeyword");
          ns.isAnyUsername = _isAny("Username");
          ns.isAnyForumTopic = _isAny("ForumTopic");
          ns.isAnyDefaultHistoryTTL = _isAny("DefaultHistoryTTL");
          ns.isAnyExportedContactToken = _isAny("ExportedContactToken");
          ns.isAnyRequestPeerType = _isAny("RequestPeerType");
          ns.isAnyEmojiList = _isAny("EmojiList");
          ns.isAnyEmojiGroup = _isAny("EmojiGroup");
          ns.isAnyTextWithEntities = _isAny("TextWithEntities");
          ns.isAnyAutoSaveSettings = _isAny("AutoSaveSettings");
          ns.isAnyAutoSaveException = _isAny("AutoSaveException");
          ns.isAnyInputBotApp = _isAny("InputBotApp");
          ns.isAnyBotApp = _isAny("BotApp");
          ns.isAnyInlineBotWebView = _isAny("InlineBotWebView");
          ns.isAnyReadParticipantDate = _isAny("ReadParticipantDate");
          ns.isAnyInputChatlist = _isAny("InputChatlist");
          ns.isAnyExportedChatlistInvite = _isAny("ExportedChatlistInvite");
          ns.isAnyMessagePeerVote = _isAny("MessagePeerVote");
          ns.isAnyStoryViews = _isAny("StoryViews");
          ns.isAnyStoryItem = _isAny("StoryItem");
          ns.isAnyStoryView = _isAny("StoryView");
          ns.isAnyInputReplyTo = _isAny("InputReplyTo");
          ns.isAnyExportedStoryLink = _isAny("ExportedStoryLink");
          ns.isAnyStoriesStealthMode = _isAny("StoriesStealthMode");
          ns.isAnyMediaAreaCoordinates = _isAny("MediaAreaCoordinates");
          ns.isAnyMediaArea = _isAny("MediaArea");
          ns.isAnyPeerStories = _isAny("PeerStories");
          ns.isAnyPremiumGiftCodeOption = _isAny("PremiumGiftCodeOption");
          ns.isAnyPrepaidGiveaway = _isAny("PrepaidGiveaway");
          ns.isAnyBoost = _isAny("Boost");
          ns.isAnyMyBoost = _isAny("MyBoost");
          ns.isAnyStoryFwdHeader = _isAny("StoryFwdHeader");
          ns.isAnyPostInteractionCounters = _isAny("PostInteractionCounters");
          ns.isAnyPublicForward = _isAny("PublicForward");
          ns.isAnyPeerColor = _isAny("PeerColor");
          ns.isAnyStoryReaction = _isAny("StoryReaction");
          ns.isAnySavedDialog = _isAny("SavedDialog");
          ns.isAnySavedReactionTag = _isAny("SavedReactionTag");
          ns.isAnyOutboxReadDate = _isAny("OutboxReadDate");
          ns.isAnySmsJob = _isAny("SmsJob");
          ns.isAnyBusinessWeeklyOpen = _isAny("BusinessWeeklyOpen");
          ns.isAnyBusinessWorkHours = _isAny("BusinessWorkHours");
          ns.isAnyBusinessLocation = _isAny("BusinessLocation");
          ns.isAnyInputBusinessRecipients = _isAny("InputBusinessRecipients");
          ns.isAnyBusinessRecipients = _isAny("BusinessRecipients");
          ns.isAnyBusinessAwayMessageSchedule = _isAny("BusinessAwayMessageSchedule");
          ns.isAnyInputBusinessGreetingMessage = _isAny("InputBusinessGreetingMessage");
          ns.isAnyBusinessGreetingMessage = _isAny("BusinessGreetingMessage");
          ns.isAnyInputBusinessAwayMessage = _isAny("InputBusinessAwayMessage");
          ns.isAnyBusinessAwayMessage = _isAny("BusinessAwayMessage");
          ns.isAnyTimezone = _isAny("Timezone");
          ns.isAnyQuickReply = _isAny("QuickReply");
          ns.isAnyInputQuickReplyShortcut = _isAny("InputQuickReplyShortcut");
          ns.isAnyConnectedBot = _isAny("ConnectedBot");
          ns.isAnyBirthday = _isAny("Birthday");
          ns.isAnyBotBusinessConnection = _isAny("BotBusinessConnection");
          ns.isAnyInputBusinessIntro = _isAny("InputBusinessIntro");
          ns.isAnyBusinessIntro = _isAny("BusinessIntro");
          ns.isAnyInputCollectible = _isAny("InputCollectible");
          ns.isAnyInputBusinessBotRecipients = _isAny("InputBusinessBotRecipients");
          ns.isAnyBusinessBotRecipients = _isAny("BusinessBotRecipients");
          ns.isAnyContactBirthday = _isAny("ContactBirthday");
          ns.isAnyMissingInvitee = _isAny("MissingInvitee");
          ns.isAnyInputBusinessChatLink = _isAny("InputBusinessChatLink");
          ns.isAnyBusinessChatLink = _isAny("BusinessChatLink");
          ns.isAnyRequestedPeer = _isAny("RequestedPeer");
          ns.isAnySponsoredMessageReportOption = _isAny("SponsoredMessageReportOption");
          ns.isAnyBroadcastRevenueTransaction = _isAny("BroadcastRevenueTransaction");
          ns.isAnyReactionNotificationsFrom = _isAny("ReactionNotificationsFrom");
          ns.isAnyReactionsNotifySettings = _isAny("ReactionsNotifySettings");
          ns.isAnyBroadcastRevenueBalances = _isAny("BroadcastRevenueBalances");
          ns.isAnyAvailableEffect = _isAny("AvailableEffect");
          ns.isAnyFactCheck = _isAny("FactCheck");
          ns.isAnyStarsTransactionPeer = _isAny("StarsTransactionPeer");
          ns.isAnyStarsTopupOption = _isAny("StarsTopupOption");
          ns.isAnyStarsTransaction = _isAny("StarsTransaction");
          ns.isAnyFoundStory = _isAny("FoundStory");
          ns.isAnyGeoPointAddress = _isAny("GeoPointAddress");
          ns.isAnyStarsRevenueStatus = _isAny("StarsRevenueStatus");
          ns.isAnyInputStarsTransaction = _isAny("InputStarsTransaction");
          ns.isAnyStarsGiftOption = _isAny("StarsGiftOption");
          ns.isAnyBotPreviewMedia = _isAny("BotPreviewMedia");
          ns.isAnyStarsSubscriptionPricing = _isAny("StarsSubscriptionPricing");
          ns.isAnyStarsSubscription = _isAny("StarsSubscription");
          ns.isAnyMessageReactor = _isAny("MessageReactor");
          ns.isAnyStarsGiveawayOption = _isAny("StarsGiveawayOption");
          ns.isAnyStarsGiveawayWinnersOption = _isAny("StarsGiveawayWinnersOption");
          ns.isAnyStarGift = _isAny("StarGift");
          ns.isAnyUserStarGift = _isAny("UserStarGift");
          ns.isAnyMessageReportOption = _isAny("MessageReportOption");
          ns.isAnyReportResult = _isAny("ReportResult");
          ns.help = {};
          (function(ns2) {
            ns2.isAnyConfigSimple = _isAny("help.ConfigSimple");
            ns2.isAnyAppUpdate = _isAny("help.AppUpdate");
            ns2.isAnyInviteText = _isAny("help.InviteText");
            ns2.isAnySupport = _isAny("help.Support");
            ns2.isAnyTermsOfService = _isAny("help.TermsOfService");
            ns2.isAnyRecentMeUrls = _isAny("help.RecentMeUrls");
            ns2.isAnyTermsOfServiceUpdate = _isAny("help.TermsOfServiceUpdate");
            ns2.isAnyDeepLinkInfo = _isAny("help.DeepLinkInfo");
            ns2.isAnyPassportConfig = _isAny("help.PassportConfig");
            ns2.isAnySupportName = _isAny("help.SupportName");
            ns2.isAnyUserInfo = _isAny("help.UserInfo");
            ns2.isAnyPromoData = _isAny("help.PromoData");
            ns2.isAnyCountryCode = _isAny("help.CountryCode");
            ns2.isAnyCountry = _isAny("help.Country");
            ns2.isAnyCountriesList = _isAny("help.CountriesList");
            ns2.isAnyPremiumPromo = _isAny("help.PremiumPromo");
            ns2.isAnyAppConfig = _isAny("help.AppConfig");
            ns2.isAnyPeerColorSet = _isAny("help.PeerColorSet");
            ns2.isAnyPeerColorOption = _isAny("help.PeerColorOption");
            ns2.isAnyPeerColors = _isAny("help.PeerColors");
            ns2.isAnyTimezonesList = _isAny("help.TimezonesList");
          })(ns.help);
          ns.storage = {};
          (function(ns2) {
            ns2.isAnyFileType = _isAny("storage.FileType");
          })(ns.storage);
          ns.auth = {};
          (function(ns2) {
            ns2.isAnySentCode = _isAny("auth.SentCode");
            ns2.isAnyAuthorization = _isAny("auth.Authorization");
            ns2.isAnyExportedAuthorization = _isAny("auth.ExportedAuthorization");
            ns2.isAnyPasswordRecovery = _isAny("auth.PasswordRecovery");
            ns2.isAnyCodeType = _isAny("auth.CodeType");
            ns2.isAnySentCodeType = _isAny("auth.SentCodeType");
            ns2.isAnyLoginToken = _isAny("auth.LoginToken");
            ns2.isAnyLoggedOut = _isAny("auth.LoggedOut");
          })(ns.auth);
          ns.contacts = {};
          (function(ns2) {
            ns2.isAnyContacts = _isAny("contacts.Contacts");
            ns2.isAnyImportedContacts = _isAny("contacts.ImportedContacts");
            ns2.isAnyBlocked = _isAny("contacts.Blocked");
            ns2.isAnyFound = _isAny("contacts.Found");
            ns2.isAnyResolvedPeer = _isAny("contacts.ResolvedPeer");
            ns2.isAnyTopPeers = _isAny("contacts.TopPeers");
            ns2.isAnyContactBirthdays = _isAny("contacts.ContactBirthdays");
          })(ns.contacts);
          ns.messages = {};
          (function(ns2) {
            ns2.isAnyDialogs = _isAny("messages.Dialogs");
            ns2.isAnyMessages = _isAny("messages.Messages");
            ns2.isAnyChats = _isAny("messages.Chats");
            ns2.isAnyChatFull = _isAny("messages.ChatFull");
            ns2.isAnyAffectedHistory = _isAny("messages.AffectedHistory");
            ns2.isAnyDhConfig = _isAny("messages.DhConfig");
            ns2.isAnySentEncryptedMessage = _isAny("messages.SentEncryptedMessage");
            ns2.isAnyStickers = _isAny("messages.Stickers");
            ns2.isAnyAllStickers = _isAny("messages.AllStickers");
            ns2.isAnyAffectedMessages = _isAny("messages.AffectedMessages");
            ns2.isAnyStickerSet = _isAny("messages.StickerSet");
            ns2.isAnySavedGifs = _isAny("messages.SavedGifs");
            ns2.isAnyBotResults = _isAny("messages.BotResults");
            ns2.isAnyBotCallbackAnswer = _isAny("messages.BotCallbackAnswer");
            ns2.isAnyMessageEditData = _isAny("messages.MessageEditData");
            ns2.isAnyPeerDialogs = _isAny("messages.PeerDialogs");
            ns2.isAnyFeaturedStickers = _isAny("messages.FeaturedStickers");
            ns2.isAnyRecentStickers = _isAny("messages.RecentStickers");
            ns2.isAnyArchivedStickers = _isAny("messages.ArchivedStickers");
            ns2.isAnyStickerSetInstallResult = _isAny("messages.StickerSetInstallResult");
            ns2.isAnyHighScores = _isAny("messages.HighScores");
            ns2.isAnyFavedStickers = _isAny("messages.FavedStickers");
            ns2.isAnyFoundStickerSets = _isAny("messages.FoundStickerSets");
            ns2.isAnySearchCounter = _isAny("messages.SearchCounter");
            ns2.isAnyInactiveChats = _isAny("messages.InactiveChats");
            ns2.isAnyVotesList = _isAny("messages.VotesList");
            ns2.isAnyMessageViews = _isAny("messages.MessageViews");
            ns2.isAnyDiscussionMessage = _isAny("messages.DiscussionMessage");
            ns2.isAnyHistoryImport = _isAny("messages.HistoryImport");
            ns2.isAnyHistoryImportParsed = _isAny("messages.HistoryImportParsed");
            ns2.isAnyAffectedFoundMessages = _isAny("messages.AffectedFoundMessages");
            ns2.isAnyExportedChatInvites = _isAny("messages.ExportedChatInvites");
            ns2.isAnyExportedChatInvite = _isAny("messages.ExportedChatInvite");
            ns2.isAnyChatInviteImporters = _isAny("messages.ChatInviteImporters");
            ns2.isAnyChatAdminsWithInvites = _isAny("messages.ChatAdminsWithInvites");
            ns2.isAnyCheckedHistoryImportPeer = _isAny("messages.CheckedHistoryImportPeer");
            ns2.isAnySponsoredMessages = _isAny("messages.SponsoredMessages");
            ns2.isAnySearchResultsCalendar = _isAny("messages.SearchResultsCalendar");
            ns2.isAnySearchResultsPositions = _isAny("messages.SearchResultsPositions");
            ns2.isAnyPeerSettings = _isAny("messages.PeerSettings");
            ns2.isAnyMessageReactionsList = _isAny("messages.MessageReactionsList");
            ns2.isAnyAvailableReactions = _isAny("messages.AvailableReactions");
            ns2.isAnyTranscribedAudio = _isAny("messages.TranscribedAudio");
            ns2.isAnyReactions = _isAny("messages.Reactions");
            ns2.isAnyForumTopics = _isAny("messages.ForumTopics");
            ns2.isAnyEmojiGroups = _isAny("messages.EmojiGroups");
            ns2.isAnyTranslatedText = _isAny("messages.TranslatedText");
            ns2.isAnyBotApp = _isAny("messages.BotApp");
            ns2.isAnyWebPage = _isAny("messages.WebPage");
            ns2.isAnySavedDialogs = _isAny("messages.SavedDialogs");
            ns2.isAnySavedReactionTags = _isAny("messages.SavedReactionTags");
            ns2.isAnyQuickReplies = _isAny("messages.QuickReplies");
            ns2.isAnyDialogFilters = _isAny("messages.DialogFilters");
            ns2.isAnyMyStickers = _isAny("messages.MyStickers");
            ns2.isAnyInvitedUsers = _isAny("messages.InvitedUsers");
            ns2.isAnyAvailableEffects = _isAny("messages.AvailableEffects");
          })(ns.messages);
          ns.updates = {};
          (function(ns2) {
            ns2.isAnyState = _isAny("updates.State");
            ns2.isAnyDifference = _isAny("updates.Difference");
            ns2.isAnyChannelDifference = _isAny("updates.ChannelDifference");
          })(ns.updates);
          ns.photos = {};
          (function(ns2) {
            ns2.isAnyPhotos = _isAny("photos.Photos");
            ns2.isAnyPhoto = _isAny("photos.Photo");
          })(ns.photos);
          ns.upload = {};
          (function(ns2) {
            ns2.isAnyFile = _isAny("upload.File");
            ns2.isAnyWebFile = _isAny("upload.WebFile");
            ns2.isAnyCdnFile = _isAny("upload.CdnFile");
          })(ns.upload);
          ns.account = {};
          (function(ns2) {
            ns2.isAnyPrivacyRules = _isAny("account.PrivacyRules");
            ns2.isAnyAuthorizations = _isAny("account.Authorizations");
            ns2.isAnyPassword = _isAny("account.Password");
            ns2.isAnyPasswordSettings = _isAny("account.PasswordSettings");
            ns2.isAnyPasswordInputSettings = _isAny("account.PasswordInputSettings");
            ns2.isAnyTmpPassword = _isAny("account.TmpPassword");
            ns2.isAnyWebAuthorizations = _isAny("account.WebAuthorizations");
            ns2.isAnyAuthorizationForm = _isAny("account.AuthorizationForm");
            ns2.isAnySentEmailCode = _isAny("account.SentEmailCode");
            ns2.isAnyTakeout = _isAny("account.Takeout");
            ns2.isAnyWallPapers = _isAny("account.WallPapers");
            ns2.isAnyAutoDownloadSettings = _isAny("account.AutoDownloadSettings");
            ns2.isAnyThemes = _isAny("account.Themes");
            ns2.isAnyContentSettings = _isAny("account.ContentSettings");
            ns2.isAnyResetPasswordResult = _isAny("account.ResetPasswordResult");
            ns2.isAnySavedRingtones = _isAny("account.SavedRingtones");
            ns2.isAnySavedRingtone = _isAny("account.SavedRingtone");
            ns2.isAnyEmojiStatuses = _isAny("account.EmojiStatuses");
            ns2.isAnyEmailVerified = _isAny("account.EmailVerified");
            ns2.isAnyAutoSaveSettings = _isAny("account.AutoSaveSettings");
            ns2.isAnyConnectedBots = _isAny("account.ConnectedBots");
            ns2.isAnyBusinessChatLinks = _isAny("account.BusinessChatLinks");
            ns2.isAnyResolvedBusinessChatLinks = _isAny("account.ResolvedBusinessChatLinks");
          })(ns.account);
          ns.channels = {};
          (function(ns2) {
            ns2.isAnyChannelParticipants = _isAny("channels.ChannelParticipants");
            ns2.isAnyChannelParticipant = _isAny("channels.ChannelParticipant");
            ns2.isAnyAdminLogResults = _isAny("channels.AdminLogResults");
            ns2.isAnySendAsPeers = _isAny("channels.SendAsPeers");
            ns2.isAnySponsoredMessageReportResult = _isAny("channels.SponsoredMessageReportResult");
          })(ns.channels);
          ns.payments = {};
          (function(ns2) {
            ns2.isAnyPaymentForm = _isAny("payments.PaymentForm");
            ns2.isAnyValidatedRequestedInfo = _isAny("payments.ValidatedRequestedInfo");
            ns2.isAnyPaymentResult = _isAny("payments.PaymentResult");
            ns2.isAnyPaymentReceipt = _isAny("payments.PaymentReceipt");
            ns2.isAnySavedInfo = _isAny("payments.SavedInfo");
            ns2.isAnyBankCardData = _isAny("payments.BankCardData");
            ns2.isAnyExportedInvoice = _isAny("payments.ExportedInvoice");
            ns2.isAnyCheckedGiftCode = _isAny("payments.CheckedGiftCode");
            ns2.isAnyGiveawayInfo = _isAny("payments.GiveawayInfo");
            ns2.isAnyStarsStatus = _isAny("payments.StarsStatus");
            ns2.isAnyStarsRevenueStats = _isAny("payments.StarsRevenueStats");
            ns2.isAnyStarsRevenueWithdrawalUrl = _isAny("payments.StarsRevenueWithdrawalUrl");
            ns2.isAnyStarsRevenueAdsAccountUrl = _isAny("payments.StarsRevenueAdsAccountUrl");
            ns2.isAnyStarGifts = _isAny("payments.StarGifts");
            ns2.isAnyUserStarGifts = _isAny("payments.UserStarGifts");
          })(ns.payments);
          ns.phone = {};
          (function(ns2) {
            ns2.isAnyPhoneCall = _isAny("phone.PhoneCall");
            ns2.isAnyGroupCall = _isAny("phone.GroupCall");
            ns2.isAnyGroupParticipants = _isAny("phone.GroupParticipants");
            ns2.isAnyJoinAsPeers = _isAny("phone.JoinAsPeers");
            ns2.isAnyExportedGroupCallInvite = _isAny("phone.ExportedGroupCallInvite");
            ns2.isAnyGroupCallStreamChannels = _isAny("phone.GroupCallStreamChannels");
            ns2.isAnyGroupCallStreamRtmpUrl = _isAny("phone.GroupCallStreamRtmpUrl");
          })(ns.phone);
          ns.stats = {};
          (function(ns2) {
            ns2.isAnyBroadcastStats = _isAny("stats.BroadcastStats");
            ns2.isAnyMegagroupStats = _isAny("stats.MegagroupStats");
            ns2.isAnyMessageStats = _isAny("stats.MessageStats");
            ns2.isAnyStoryStats = _isAny("stats.StoryStats");
            ns2.isAnyPublicForwards = _isAny("stats.PublicForwards");
            ns2.isAnyBroadcastRevenueStats = _isAny("stats.BroadcastRevenueStats");
            ns2.isAnyBroadcastRevenueWithdrawalUrl = _isAny("stats.BroadcastRevenueWithdrawalUrl");
            ns2.isAnyBroadcastRevenueTransactions = _isAny("stats.BroadcastRevenueTransactions");
          })(ns.stats);
          ns.stickers = {};
          (function(ns2) {
            ns2.isAnySuggestedShortName = _isAny("stickers.SuggestedShortName");
          })(ns.stickers);
          ns.users = {};
          (function(ns2) {
            ns2.isAnyUserFull = _isAny("users.UserFull");
          })(ns.users);
          ns.chatlists = {};
          (function(ns2) {
            ns2.isAnyExportedChatlistInvite = _isAny("chatlists.ExportedChatlistInvite");
            ns2.isAnyExportedInvites = _isAny("chatlists.ExportedInvites");
            ns2.isAnyChatlistInvite = _isAny("chatlists.ChatlistInvite");
            ns2.isAnyChatlistUpdates = _isAny("chatlists.ChatlistUpdates");
          })(ns.chatlists);
          ns.bots = {};
          (function(ns2) {
            ns2.isAnyBotInfo = _isAny("bots.BotInfo");
            ns2.isAnyPopularAppBots = _isAny("bots.PopularAppBots");
            ns2.isAnyPreviewInfo = _isAny("bots.PreviewInfo");
          })(ns.bots);
          ns.stories = {};
          (function(ns2) {
            ns2.isAnyAllStories = _isAny("stories.AllStories");
            ns2.isAnyStories = _isAny("stories.Stories");
            ns2.isAnyStoryViewsList = _isAny("stories.StoryViewsList");
            ns2.isAnyStoryViews = _isAny("stories.StoryViews");
            ns2.isAnyPeerStories = _isAny("stories.PeerStories");
            ns2.isAnyStoryReactionsList = _isAny("stories.StoryReactionsList");
            ns2.isAnyFoundStories = _isAny("stories.FoundStories");
          })(ns.stories);
          ns.premium = {};
          (function(ns2) {
            ns2.isAnyBoostsList = _isAny("premium.BoostsList");
            ns2.isAnyMyBoosts = _isAny("premium.MyBoosts");
            ns2.isAnyBoostsStatus = _isAny("premium.BoostsStatus");
          })(ns.premium);
          ns.smsjobs = {};
          (function(ns2) {
            ns2.isAnyEligibilityToJoin = _isAny("smsjobs.EligibilityToJoin");
            ns2.isAnyStatus = _isAny("smsjobs.Status");
          })(ns.smsjobs);
          ns.fragment = {};
          (function(ns2) {
            ns2.isAnyCollectibleInfo = _isAny("fragment.CollectibleInfo");
          })(ns.fragment);
          ns.mtcute = {};
          (function(ns2) {
            ns2.isAnyUpdate = _isAny("Update");
            ns2.isAnyInputPeer = _isAny("InputPeer");
          })(ns.mtcute);
          ns.test = {};
          /* @__PURE__ */ (function(ns2) {
          })(ns.test);
          ns.langpack = {};
          /* @__PURE__ */ (function(ns2) {
          })(ns.langpack);
          ns.folders = {};
          /* @__PURE__ */ (function(ns2) {
          })(ns.folders);
          _types = JSON.parse('{"error":"Error","ipPort":"IpPort","ipPortSecret":"IpPort","accessPointRule":"AccessPointRule","help.configSimple":"help.ConfigSimple","inputPeerPhotoFileLocationLegacy":"InputFileLocation","inputStickerSetThumbLegacy":"InputFileLocation","inputPeerEmpty":"InputPeer","inputPeerSelf":"InputPeer","inputPeerChat":"InputPeer","inputPeerUser":"InputPeer","inputPeerChannel":"InputPeer","inputPeerUserFromMessage":"InputPeer","inputPeerChannelFromMessage":"InputPeer","inputUserEmpty":"InputUser","inputUserSelf":"InputUser","inputUser":"InputUser","inputUserFromMessage":"InputUser","inputPhoneContact":"InputContact","inputFile":"InputFile","inputFileBig":"InputFile","inputFileStoryDocument":"InputFile","inputMediaEmpty":"InputMedia","inputMediaUploadedPhoto":"InputMedia","inputMediaPhoto":"InputMedia","inputMediaGeoPoint":"InputMedia","inputMediaContact":"InputMedia","inputMediaUploadedDocument":"InputMedia","inputMediaDocument":"InputMedia","inputMediaVenue":"InputMedia","inputMediaPhotoExternal":"InputMedia","inputMediaDocumentExternal":"InputMedia","inputMediaGame":"InputMedia","inputMediaInvoice":"InputMedia","inputMediaGeoLive":"InputMedia","inputMediaPoll":"InputMedia","inputMediaDice":"InputMedia","inputMediaStory":"InputMedia","inputMediaWebPage":"InputMedia","inputMediaPaidMedia":"InputMedia","inputChatPhotoEmpty":"InputChatPhoto","inputChatUploadedPhoto":"InputChatPhoto","inputChatPhoto":"InputChatPhoto","inputGeoPointEmpty":"InputGeoPoint","inputGeoPoint":"InputGeoPoint","inputPhotoEmpty":"InputPhoto","inputPhoto":"InputPhoto","inputFileLocation":"InputFileLocation","inputEncryptedFileLocation":"InputFileLocation","inputDocumentFileLocation":"InputFileLocation","inputSecureFileLocation":"InputFileLocation","inputTakeoutFileLocation":"InputFileLocation","inputPhotoFileLocation":"InputFileLocation","inputPhotoLegacyFileLocation":"InputFileLocation","inputPeerPhotoFileLocation":"InputFileLocation","inputStickerSetThumb":"InputFileLocation","inputGroupCallStream":"InputFileLocation","peerUser":"Peer","peerChat":"Peer","peerChannel":"Peer","storage.fileUnknown":"storage.FileType","storage.filePartial":"storage.FileType","storage.fileJpeg":"storage.FileType","storage.fileGif":"storage.FileType","storage.filePng":"storage.FileType","storage.filePdf":"storage.FileType","storage.fileMp3":"storage.FileType","storage.fileMov":"storage.FileType","storage.fileMp4":"storage.FileType","storage.fileWebp":"storage.FileType","userEmpty":"User","user":"User","userProfilePhotoEmpty":"UserProfilePhoto","userProfilePhoto":"UserProfilePhoto","userStatusEmpty":"UserStatus","userStatusOnline":"UserStatus","userStatusOffline":"UserStatus","userStatusRecently":"UserStatus","userStatusLastWeek":"UserStatus","userStatusLastMonth":"UserStatus","chatEmpty":"Chat","chat":"Chat","chatForbidden":"Chat","channel":"Chat","channelForbidden":"Chat","chatFull":"ChatFull","channelFull":"ChatFull","chatParticipant":"ChatParticipant","chatParticipantCreator":"ChatParticipant","chatParticipantAdmin":"ChatParticipant","chatParticipantsForbidden":"ChatParticipants","chatParticipants":"ChatParticipants","chatPhotoEmpty":"ChatPhoto","chatPhoto":"ChatPhoto","messageEmpty":"Message","message":"Message","messageService":"Message","messageMediaEmpty":"MessageMedia","messageMediaPhoto":"MessageMedia","messageMediaGeo":"MessageMedia","messageMediaContact":"MessageMedia","messageMediaUnsupported":"MessageMedia","messageMediaDocument":"MessageMedia","messageMediaWebPage":"MessageMedia","messageMediaVenue":"MessageMedia","messageMediaGame":"MessageMedia","messageMediaInvoice":"MessageMedia","messageMediaGeoLive":"MessageMedia","messageMediaPoll":"MessageMedia","messageMediaDice":"MessageMedia","messageMediaStory":"MessageMedia","messageMediaGiveaway":"MessageMedia","messageMediaGiveawayResults":"MessageMedia","messageMediaPaidMedia":"MessageMedia","messageActionEmpty":"MessageAction","messageActionChatCreate":"MessageAction","messageActionChatEditTitle":"MessageAction","messageActionChatEditPhoto":"MessageAction","messageActionChatDeletePhoto":"MessageAction","messageActionChatAddUser":"MessageAction","messageActionChatDeleteUser":"MessageAction","messageActionChatJoinedByLink":"MessageAction","messageActionChannelCreate":"MessageAction","messageActionChatMigrateTo":"MessageAction","messageActionChannelMigrateFrom":"MessageAction","messageActionPinMessage":"MessageAction","messageActionHistoryClear":"MessageAction","messageActionGameScore":"MessageAction","messageActionPaymentSentMe":"MessageAction","messageActionPaymentSent":"MessageAction","messageActionPhoneCall":"MessageAction","messageActionScreenshotTaken":"MessageAction","messageActionCustomAction":"MessageAction","messageActionBotAllowed":"MessageAction","messageActionSecureValuesSentMe":"MessageAction","messageActionSecureValuesSent":"MessageAction","messageActionContactSignUp":"MessageAction","messageActionGeoProximityReached":"MessageAction","messageActionGroupCall":"MessageAction","messageActionInviteToGroupCall":"MessageAction","messageActionSetMessagesTTL":"MessageAction","messageActionGroupCallScheduled":"MessageAction","messageActionSetChatTheme":"MessageAction","messageActionChatJoinedByRequest":"MessageAction","messageActionWebViewDataSentMe":"MessageAction","messageActionWebViewDataSent":"MessageAction","messageActionGiftPremium":"MessageAction","messageActionTopicCreate":"MessageAction","messageActionTopicEdit":"MessageAction","messageActionSuggestProfilePhoto":"MessageAction","messageActionRequestedPeer":"MessageAction","messageActionSetChatWallPaper":"MessageAction","messageActionGiftCode":"MessageAction","messageActionGiveawayLaunch":"MessageAction","messageActionGiveawayResults":"MessageAction","messageActionBoostApply":"MessageAction","messageActionRequestedPeerSentMe":"MessageAction","messageActionPaymentRefunded":"MessageAction","messageActionGiftStars":"MessageAction","messageActionPrizeStars":"MessageAction","messageActionStarGift":"MessageAction","dialog":"Dialog","dialogFolder":"Dialog","photoEmpty":"Photo","photo":"Photo","photoSizeEmpty":"PhotoSize","photoSize":"PhotoSize","photoCachedSize":"PhotoSize","photoStrippedSize":"PhotoSize","photoSizeProgressive":"PhotoSize","photoPathSize":"PhotoSize","geoPointEmpty":"GeoPoint","geoPoint":"GeoPoint","auth.sentCode":"auth.SentCode","auth.sentCodeSuccess":"auth.SentCode","auth.authorization":"auth.Authorization","auth.authorizationSignUpRequired":"auth.Authorization","auth.exportedAuthorization":"auth.ExportedAuthorization","inputNotifyPeer":"InputNotifyPeer","inputNotifyUsers":"InputNotifyPeer","inputNotifyChats":"InputNotifyPeer","inputNotifyBroadcasts":"InputNotifyPeer","inputNotifyForumTopic":"InputNotifyPeer","inputPeerNotifySettings":"InputPeerNotifySettings","peerNotifySettings":"PeerNotifySettings","peerSettings":"PeerSettings","wallPaper":"WallPaper","wallPaperNoFile":"WallPaper","inputReportReasonSpam":"ReportReason","inputReportReasonViolence":"ReportReason","inputReportReasonPornography":"ReportReason","inputReportReasonChildAbuse":"ReportReason","inputReportReasonOther":"ReportReason","inputReportReasonCopyright":"ReportReason","inputReportReasonGeoIrrelevant":"ReportReason","inputReportReasonFake":"ReportReason","inputReportReasonIllegalDrugs":"ReportReason","inputReportReasonPersonalDetails":"ReportReason","userFull":"UserFull","contact":"Contact","importedContact":"ImportedContact","contactStatus":"ContactStatus","contacts.contactsNotModified":"contacts.Contacts","contacts.contacts":"contacts.Contacts","contacts.importedContacts":"contacts.ImportedContacts","contacts.blocked":"contacts.Blocked","contacts.blockedSlice":"contacts.Blocked","messages.dialogs":"messages.Dialogs","messages.dialogsSlice":"messages.Dialogs","messages.dialogsNotModified":"messages.Dialogs","messages.messages":"messages.Messages","messages.messagesSlice":"messages.Messages","messages.channelMessages":"messages.Messages","messages.messagesNotModified":"messages.Messages","messages.chats":"messages.Chats","messages.chatsSlice":"messages.Chats","messages.chatFull":"messages.ChatFull","messages.affectedHistory":"messages.AffectedHistory","inputMessagesFilterEmpty":"MessagesFilter","inputMessagesFilterPhotos":"MessagesFilter","inputMessagesFilterVideo":"MessagesFilter","inputMessagesFilterPhotoVideo":"MessagesFilter","inputMessagesFilterDocument":"MessagesFilter","inputMessagesFilterUrl":"MessagesFilter","inputMessagesFilterGif":"MessagesFilter","inputMessagesFilterVoice":"MessagesFilter","inputMessagesFilterMusic":"MessagesFilter","inputMessagesFilterChatPhotos":"MessagesFilter","inputMessagesFilterPhoneCalls":"MessagesFilter","inputMessagesFilterRoundVoice":"MessagesFilter","inputMessagesFilterRoundVideo":"MessagesFilter","inputMessagesFilterMyMentions":"MessagesFilter","inputMessagesFilterGeo":"MessagesFilter","inputMessagesFilterContacts":"MessagesFilter","inputMessagesFilterPinned":"MessagesFilter","updateNewMessage":"Update","updateMessageID":"Update","updateDeleteMessages":"Update","updateUserTyping":"Update","updateChatUserTyping":"Update","updateChatParticipants":"Update","updateUserStatus":"Update","updateUserName":"Update","updateNewAuthorization":"Update","updateNewEncryptedMessage":"Update","updateEncryptedChatTyping":"Update","updateEncryption":"Update","updateEncryptedMessagesRead":"Update","updateChatParticipantAdd":"Update","updateChatParticipantDelete":"Update","updateDcOptions":"Update","updateNotifySettings":"Update","updateServiceNotification":"Update","updatePrivacy":"Update","updateUserPhone":"Update","updateReadHistoryInbox":"Update","updateReadHistoryOutbox":"Update","updateWebPage":"Update","updateReadMessagesContents":"Update","updateChannelTooLong":"Update","updateChannel":"Update","updateNewChannelMessage":"Update","updateReadChannelInbox":"Update","updateDeleteChannelMessages":"Update","updateChannelMessageViews":"Update","updateChatParticipantAdmin":"Update","updateNewStickerSet":"Update","updateStickerSetsOrder":"Update","updateStickerSets":"Update","updateSavedGifs":"Update","updateBotInlineQuery":"Update","updateBotInlineSend":"Update","updateEditChannelMessage":"Update","updateBotCallbackQuery":"Update","updateEditMessage":"Update","updateInlineBotCallbackQuery":"Update","updateReadChannelOutbox":"Update","updateDraftMessage":"Update","updateReadFeaturedStickers":"Update","updateRecentStickers":"Update","updateConfig":"Update","updatePtsChanged":"Update","updateChannelWebPage":"Update","updateDialogPinned":"Update","updatePinnedDialogs":"Update","updateBotWebhookJSON":"Update","updateBotWebhookJSONQuery":"Update","updateBotShippingQuery":"Update","updateBotPrecheckoutQuery":"Update","updatePhoneCall":"Update","updateLangPackTooLong":"Update","updateLangPack":"Update","updateFavedStickers":"Update","updateChannelReadMessagesContents":"Update","updateContactsReset":"Update","updateChannelAvailableMessages":"Update","updateDialogUnreadMark":"Update","updateMessagePoll":"Update","updateChatDefaultBannedRights":"Update","updateFolderPeers":"Update","updatePeerSettings":"Update","updatePeerLocated":"Update","updateNewScheduledMessage":"Update","updateDeleteScheduledMessages":"Update","updateTheme":"Update","updateGeoLiveViewed":"Update","updateLoginToken":"Update","updateMessagePollVote":"Update","updateDialogFilter":"Update","updateDialogFilterOrder":"Update","updateDialogFilters":"Update","updatePhoneCallSignalingData":"Update","updateChannelMessageForwards":"Update","updateReadChannelDiscussionInbox":"Update","updateReadChannelDiscussionOutbox":"Update","updatePeerBlocked":"Update","updateChannelUserTyping":"Update","updatePinnedMessages":"Update","updatePinnedChannelMessages":"Update","updateChat":"Update","updateGroupCallParticipants":"Update","updateGroupCall":"Update","updatePeerHistoryTTL":"Update","updateChatParticipant":"Update","updateChannelParticipant":"Update","updateBotStopped":"Update","updateGroupCallConnection":"Update","updateBotCommands":"Update","updatePendingJoinRequests":"Update","updateBotChatInviteRequester":"Update","updateMessageReactions":"Update","updateAttachMenuBots":"Update","updateWebViewResultSent":"Update","updateBotMenuButton":"Update","updateSavedRingtones":"Update","updateTranscribedAudio":"Update","updateReadFeaturedEmojiStickers":"Update","updateUserEmojiStatus":"Update","updateRecentEmojiStatuses":"Update","updateRecentReactions":"Update","updateMoveStickerSetToTop":"Update","updateMessageExtendedMedia":"Update","updateChannelPinnedTopic":"Update","updateChannelPinnedTopics":"Update","updateUser":"Update","updateAutoSaveSettings":"Update","updateStory":"Update","updateReadStories":"Update","updateStoryID":"Update","updateStoriesStealthMode":"Update","updateSentStoryReaction":"Update","updateBotChatBoost":"Update","updateChannelViewForumAsMessages":"Update","updatePeerWallpaper":"Update","updateBotMessageReaction":"Update","updateBotMessageReactions":"Update","updateSavedDialogPinned":"Update","updatePinnedSavedDialogs":"Update","updateSavedReactionTags":"Update","updateSmsJob":"Update","updateQuickReplies":"Update","updateNewQuickReply":"Update","updateDeleteQuickReply":"Update","updateQuickReplyMessage":"Update","updateDeleteQuickReplyMessages":"Update","updateBotBusinessConnect":"Update","updateBotNewBusinessMessage":"Update","updateBotEditBusinessMessage":"Update","updateBotDeleteBusinessMessage":"Update","updateNewStoryReaction":"Update","updateBroadcastRevenueTransactions":"Update","updateStarsBalance":"Update","updateBusinessBotCallbackQuery":"Update","updateStarsRevenueStatus":"Update","updateBotPurchasedPaidMedia":"Update","updatePaidReactionPrivacy":"Update","updates.state":"updates.State","updates.differenceEmpty":"updates.Difference","updates.difference":"updates.Difference","updates.differenceSlice":"updates.Difference","updates.differenceTooLong":"updates.Difference","updatesTooLong":"Updates","updateShortMessage":"Updates","updateShortChatMessage":"Updates","updateShort":"Updates","updatesCombined":"Updates","updates":"Updates","updateShortSentMessage":"Updates","photos.photos":"photos.Photos","photos.photosSlice":"photos.Photos","photos.photo":"photos.Photo","upload.file":"upload.File","upload.fileCdnRedirect":"upload.File","dcOption":"DcOption","config":"Config","nearestDc":"NearestDc","help.appUpdate":"help.AppUpdate","help.noAppUpdate":"help.AppUpdate","help.inviteText":"help.InviteText","encryptedChatEmpty":"EncryptedChat","encryptedChatWaiting":"EncryptedChat","encryptedChatRequested":"EncryptedChat","encryptedChat":"EncryptedChat","encryptedChatDiscarded":"EncryptedChat","inputEncryptedChat":"InputEncryptedChat","encryptedFileEmpty":"EncryptedFile","encryptedFile":"EncryptedFile","inputEncryptedFileEmpty":"InputEncryptedFile","inputEncryptedFileUploaded":"InputEncryptedFile","inputEncryptedFile":"InputEncryptedFile","inputEncryptedFileBigUploaded":"InputEncryptedFile","encryptedMessage":"EncryptedMessage","encryptedMessageService":"EncryptedMessage","messages.dhConfigNotModified":"messages.DhConfig","messages.dhConfig":"messages.DhConfig","messages.sentEncryptedMessage":"messages.SentEncryptedMessage","messages.sentEncryptedFile":"messages.SentEncryptedMessage","inputDocumentEmpty":"InputDocument","inputDocument":"InputDocument","documentEmpty":"Document","document":"Document","help.support":"help.Support","notifyPeer":"NotifyPeer","notifyUsers":"NotifyPeer","notifyChats":"NotifyPeer","notifyBroadcasts":"NotifyPeer","notifyForumTopic":"NotifyPeer","sendMessageTypingAction":"SendMessageAction","sendMessageCancelAction":"SendMessageAction","sendMessageRecordVideoAction":"SendMessageAction","sendMessageUploadVideoAction":"SendMessageAction","sendMessageRecordAudioAction":"SendMessageAction","sendMessageUploadAudioAction":"SendMessageAction","sendMessageUploadPhotoAction":"SendMessageAction","sendMessageUploadDocumentAction":"SendMessageAction","sendMessageGeoLocationAction":"SendMessageAction","sendMessageChooseContactAction":"SendMessageAction","sendMessageGamePlayAction":"SendMessageAction","sendMessageRecordRoundAction":"SendMessageAction","sendMessageUploadRoundAction":"SendMessageAction","speakingInGroupCallAction":"SendMessageAction","sendMessageHistoryImportAction":"SendMessageAction","sendMessageChooseStickerAction":"SendMessageAction","sendMessageEmojiInteraction":"SendMessageAction","sendMessageEmojiInteractionSeen":"SendMessageAction","contacts.found":"contacts.Found","inputPrivacyKeyStatusTimestamp":"InputPrivacyKey","inputPrivacyKeyChatInvite":"InputPrivacyKey","inputPrivacyKeyPhoneCall":"InputPrivacyKey","inputPrivacyKeyPhoneP2P":"InputPrivacyKey","inputPrivacyKeyForwards":"InputPrivacyKey","inputPrivacyKeyProfilePhoto":"InputPrivacyKey","inputPrivacyKeyPhoneNumber":"InputPrivacyKey","inputPrivacyKeyAddedByPhone":"InputPrivacyKey","inputPrivacyKeyVoiceMessages":"InputPrivacyKey","inputPrivacyKeyAbout":"InputPrivacyKey","inputPrivacyKeyBirthday":"InputPrivacyKey","privacyKeyStatusTimestamp":"PrivacyKey","privacyKeyChatInvite":"PrivacyKey","privacyKeyPhoneCall":"PrivacyKey","privacyKeyPhoneP2P":"PrivacyKey","privacyKeyForwards":"PrivacyKey","privacyKeyProfilePhoto":"PrivacyKey","privacyKeyPhoneNumber":"PrivacyKey","privacyKeyAddedByPhone":"PrivacyKey","privacyKeyVoiceMessages":"PrivacyKey","privacyKeyAbout":"PrivacyKey","privacyKeyBirthday":"PrivacyKey","inputPrivacyValueAllowContacts":"InputPrivacyRule","inputPrivacyValueAllowAll":"InputPrivacyRule","inputPrivacyValueAllowUsers":"InputPrivacyRule","inputPrivacyValueDisallowContacts":"InputPrivacyRule","inputPrivacyValueDisallowAll":"InputPrivacyRule","inputPrivacyValueDisallowUsers":"InputPrivacyRule","inputPrivacyValueAllowChatParticipants":"InputPrivacyRule","inputPrivacyValueDisallowChatParticipants":"InputPrivacyRule","inputPrivacyValueAllowCloseFriends":"InputPrivacyRule","inputPrivacyValueAllowPremium":"InputPrivacyRule","privacyValueAllowContacts":"PrivacyRule","privacyValueAllowAll":"PrivacyRule","privacyValueAllowUsers":"PrivacyRule","privacyValueDisallowContacts":"PrivacyRule","privacyValueDisallowAll":"PrivacyRule","privacyValueDisallowUsers":"PrivacyRule","privacyValueAllowChatParticipants":"PrivacyRule","privacyValueDisallowChatParticipants":"PrivacyRule","privacyValueAllowCloseFriends":"PrivacyRule","privacyValueAllowPremium":"PrivacyRule","account.privacyRules":"account.PrivacyRules","accountDaysTTL":"AccountDaysTTL","documentAttributeImageSize":"DocumentAttribute","documentAttributeAnimated":"DocumentAttribute","documentAttributeSticker":"DocumentAttribute","documentAttributeVideo":"DocumentAttribute","documentAttributeAudio":"DocumentAttribute","documentAttributeFilename":"DocumentAttribute","documentAttributeHasStickers":"DocumentAttribute","documentAttributeCustomEmoji":"DocumentAttribute","messages.stickersNotModified":"messages.Stickers","messages.stickers":"messages.Stickers","stickerPack":"StickerPack","messages.allStickersNotModified":"messages.AllStickers","messages.allStickers":"messages.AllStickers","messages.affectedMessages":"messages.AffectedMessages","webPageEmpty":"WebPage","webPagePending":"WebPage","webPage":"WebPage","webPageNotModified":"WebPage","authorization":"Authorization","account.authorizations":"account.Authorizations","account.password":"account.Password","account.passwordSettings":"account.PasswordSettings","account.passwordInputSettings":"account.PasswordInputSettings","auth.passwordRecovery":"auth.PasswordRecovery","receivedNotifyMessage":"ReceivedNotifyMessage","chatInviteExported":"ExportedChatInvite","chatInvitePublicJoinRequests":"ExportedChatInvite","chatInviteAlready":"ChatInvite","chatInvite":"ChatInvite","chatInvitePeek":"ChatInvite","inputStickerSetEmpty":"InputStickerSet","inputStickerSetID":"InputStickerSet","inputStickerSetShortName":"InputStickerSet","inputStickerSetAnimatedEmoji":"InputStickerSet","inputStickerSetDice":"InputStickerSet","inputStickerSetAnimatedEmojiAnimations":"InputStickerSet","inputStickerSetPremiumGifts":"InputStickerSet","inputStickerSetEmojiGenericAnimations":"InputStickerSet","inputStickerSetEmojiDefaultStatuses":"InputStickerSet","inputStickerSetEmojiDefaultTopicIcons":"InputStickerSet","inputStickerSetEmojiChannelDefaultStatuses":"InputStickerSet","stickerSet":"StickerSet","messages.stickerSet":"messages.StickerSet","messages.stickerSetNotModified":"messages.StickerSet","botCommand":"BotCommand","botInfo":"BotInfo","keyboardButton":"KeyboardButton","keyboardButtonUrl":"KeyboardButton","keyboardButtonCallback":"KeyboardButton","keyboardButtonRequestPhone":"KeyboardButton","keyboardButtonRequestGeoLocation":"KeyboardButton","keyboardButtonSwitchInline":"KeyboardButton","keyboardButtonGame":"KeyboardButton","keyboardButtonBuy":"KeyboardButton","keyboardButtonUrlAuth":"KeyboardButton","inputKeyboardButtonUrlAuth":"KeyboardButton","keyboardButtonRequestPoll":"KeyboardButton","inputKeyboardButtonUserProfile":"KeyboardButton","keyboardButtonUserProfile":"KeyboardButton","keyboardButtonWebView":"KeyboardButton","keyboardButtonSimpleWebView":"KeyboardButton","keyboardButtonRequestPeer":"KeyboardButton","inputKeyboardButtonRequestPeer":"KeyboardButton","keyboardButtonCopy":"KeyboardButton","keyboardButtonRow":"KeyboardButtonRow","replyKeyboardHide":"ReplyMarkup","replyKeyboardForceReply":"ReplyMarkup","replyKeyboardMarkup":"ReplyMarkup","replyInlineMarkup":"ReplyMarkup","messageEntityUnknown":"MessageEntity","messageEntityMention":"MessageEntity","messageEntityHashtag":"MessageEntity","messageEntityBotCommand":"MessageEntity","messageEntityUrl":"MessageEntity","messageEntityEmail":"MessageEntity","messageEntityBold":"MessageEntity","messageEntityItalic":"MessageEntity","messageEntityCode":"MessageEntity","messageEntityPre":"MessageEntity","messageEntityTextUrl":"MessageEntity","messageEntityMentionName":"MessageEntity","inputMessageEntityMentionName":"MessageEntity","messageEntityPhone":"MessageEntity","messageEntityCashtag":"MessageEntity","messageEntityUnderline":"MessageEntity","messageEntityStrike":"MessageEntity","messageEntityBankCard":"MessageEntity","messageEntitySpoiler":"MessageEntity","messageEntityCustomEmoji":"MessageEntity","messageEntityBlockquote":"MessageEntity","inputChannelEmpty":"InputChannel","inputChannel":"InputChannel","inputChannelFromMessage":"InputChannel","contacts.resolvedPeer":"contacts.ResolvedPeer","messageRange":"MessageRange","updates.channelDifferenceEmpty":"updates.ChannelDifference","updates.channelDifferenceTooLong":"updates.ChannelDifference","updates.channelDifference":"updates.ChannelDifference","channelMessagesFilterEmpty":"ChannelMessagesFilter","channelMessagesFilter":"ChannelMessagesFilter","channelParticipant":"ChannelParticipant","channelParticipantSelf":"ChannelParticipant","channelParticipantCreator":"ChannelParticipant","channelParticipantAdmin":"ChannelParticipant","channelParticipantBanned":"ChannelParticipant","channelParticipantLeft":"ChannelParticipant","channelParticipantsRecent":"ChannelParticipantsFilter","channelParticipantsAdmins":"ChannelParticipantsFilter","channelParticipantsKicked":"ChannelParticipantsFilter","channelParticipantsBots":"ChannelParticipantsFilter","channelParticipantsBanned":"ChannelParticipantsFilter","channelParticipantsSearch":"ChannelParticipantsFilter","channelParticipantsContacts":"ChannelParticipantsFilter","channelParticipantsMentions":"ChannelParticipantsFilter","channels.channelParticipants":"channels.ChannelParticipants","channels.channelParticipantsNotModified":"channels.ChannelParticipants","channels.channelParticipant":"channels.ChannelParticipant","help.termsOfService":"help.TermsOfService","messages.savedGifsNotModified":"messages.SavedGifs","messages.savedGifs":"messages.SavedGifs","inputBotInlineMessageMediaAuto":"InputBotInlineMessage","inputBotInlineMessageText":"InputBotInlineMessage","inputBotInlineMessageMediaGeo":"InputBotInlineMessage","inputBotInlineMessageMediaVenue":"InputBotInlineMessage","inputBotInlineMessageMediaContact":"InputBotInlineMessage","inputBotInlineMessageGame":"InputBotInlineMessage","inputBotInlineMessageMediaInvoice":"InputBotInlineMessage","inputBotInlineMessageMediaWebPage":"InputBotInlineMessage","inputBotInlineResult":"InputBotInlineResult","inputBotInlineResultPhoto":"InputBotInlineResult","inputBotInlineResultDocument":"InputBotInlineResult","inputBotInlineResultGame":"InputBotInlineResult","botInlineMessageMediaAuto":"BotInlineMessage","botInlineMessageText":"BotInlineMessage","botInlineMessageMediaGeo":"BotInlineMessage","botInlineMessageMediaVenue":"BotInlineMessage","botInlineMessageMediaContact":"BotInlineMessage","botInlineMessageMediaInvoice":"BotInlineMessage","botInlineMessageMediaWebPage":"BotInlineMessage","botInlineResult":"BotInlineResult","botInlineMediaResult":"BotInlineResult","messages.botResults":"messages.BotResults","exportedMessageLink":"ExportedMessageLink","messageFwdHeader":"MessageFwdHeader","auth.codeTypeSms":"auth.CodeType","auth.codeTypeCall":"auth.CodeType","auth.codeTypeFlashCall":"auth.CodeType","auth.codeTypeMissedCall":"auth.CodeType","auth.codeTypeFragmentSms":"auth.CodeType","auth.sentCodeTypeApp":"auth.SentCodeType","auth.sentCodeTypeSms":"auth.SentCodeType","auth.sentCodeTypeCall":"auth.SentCodeType","auth.sentCodeTypeFlashCall":"auth.SentCodeType","auth.sentCodeTypeMissedCall":"auth.SentCodeType","auth.sentCodeTypeEmailCode":"auth.SentCodeType","auth.sentCodeTypeSetUpEmailRequired":"auth.SentCodeType","auth.sentCodeTypeFragmentSms":"auth.SentCodeType","auth.sentCodeTypeFirebaseSms":"auth.SentCodeType","auth.sentCodeTypeSmsWord":"auth.SentCodeType","auth.sentCodeTypeSmsPhrase":"auth.SentCodeType","messages.botCallbackAnswer":"messages.BotCallbackAnswer","messages.messageEditData":"messages.MessageEditData","inputBotInlineMessageID":"InputBotInlineMessageID","inputBotInlineMessageID64":"InputBotInlineMessageID","inlineBotSwitchPM":"InlineBotSwitchPM","messages.peerDialogs":"messages.PeerDialogs","topPeer":"TopPeer","topPeerCategoryBotsPM":"TopPeerCategory","topPeerCategoryBotsInline":"TopPeerCategory","topPeerCategoryCorrespondents":"TopPeerCategory","topPeerCategoryGroups":"TopPeerCategory","topPeerCategoryChannels":"TopPeerCategory","topPeerCategoryPhoneCalls":"TopPeerCategory","topPeerCategoryForwardUsers":"TopPeerCategory","topPeerCategoryForwardChats":"TopPeerCategory","topPeerCategoryBotsApp":"TopPeerCategory","topPeerCategoryPeers":"TopPeerCategoryPeers","contacts.topPeersNotModified":"contacts.TopPeers","contacts.topPeers":"contacts.TopPeers","contacts.topPeersDisabled":"contacts.TopPeers","draftMessageEmpty":"DraftMessage","draftMessage":"DraftMessage","messages.featuredStickersNotModified":"messages.FeaturedStickers","messages.featuredStickers":"messages.FeaturedStickers","messages.recentStickersNotModified":"messages.RecentStickers","messages.recentStickers":"messages.RecentStickers","messages.archivedStickers":"messages.ArchivedStickers","messages.stickerSetInstallResultSuccess":"messages.StickerSetInstallResult","messages.stickerSetInstallResultArchive":"messages.StickerSetInstallResult","stickerSetCovered":"StickerSetCovered","stickerSetMultiCovered":"StickerSetCovered","stickerSetFullCovered":"StickerSetCovered","stickerSetNoCovered":"StickerSetCovered","maskCoords":"MaskCoords","inputStickeredMediaPhoto":"InputStickeredMedia","inputStickeredMediaDocument":"InputStickeredMedia","game":"Game","inputGameID":"InputGame","inputGameShortName":"InputGame","highScore":"HighScore","messages.highScores":"messages.HighScores","textEmpty":"RichText","textPlain":"RichText","textBold":"RichText","textItalic":"RichText","textUnderline":"RichText","textStrike":"RichText","textFixed":"RichText","textUrl":"RichText","textEmail":"RichText","textConcat":"RichText","textSubscript":"RichText","textSuperscript":"RichText","textMarked":"RichText","textPhone":"RichText","textImage":"RichText","textAnchor":"RichText","pageBlockUnsupported":"PageBlock","pageBlockTitle":"PageBlock","pageBlockSubtitle":"PageBlock","pageBlockAuthorDate":"PageBlock","pageBlockHeader":"PageBlock","pageBlockSubheader":"PageBlock","pageBlockParagraph":"PageBlock","pageBlockPreformatted":"PageBlock","pageBlockFooter":"PageBlock","pageBlockDivider":"PageBlock","pageBlockAnchor":"PageBlock","pageBlockList":"PageBlock","pageBlockBlockquote":"PageBlock","pageBlockPullquote":"PageBlock","pageBlockPhoto":"PageBlock","pageBlockVideo":"PageBlock","pageBlockCover":"PageBlock","pageBlockEmbed":"PageBlock","pageBlockEmbedPost":"PageBlock","pageBlockCollage":"PageBlock","pageBlockSlideshow":"PageBlock","pageBlockChannel":"PageBlock","pageBlockAudio":"PageBlock","pageBlockKicker":"PageBlock","pageBlockTable":"PageBlock","pageBlockOrderedList":"PageBlock","pageBlockDetails":"PageBlock","pageBlockRelatedArticles":"PageBlock","pageBlockMap":"PageBlock","phoneCallDiscardReasonMissed":"PhoneCallDiscardReason","phoneCallDiscardReasonDisconnect":"PhoneCallDiscardReason","phoneCallDiscardReasonHangup":"PhoneCallDiscardReason","phoneCallDiscardReasonBusy":"PhoneCallDiscardReason","dataJSON":"DataJSON","labeledPrice":"LabeledPrice","invoice":"Invoice","paymentCharge":"PaymentCharge","postAddress":"PostAddress","paymentRequestedInfo":"PaymentRequestedInfo","paymentSavedCredentialsCard":"PaymentSavedCredentials","webDocument":"WebDocument","webDocumentNoProxy":"WebDocument","inputWebDocument":"InputWebDocument","inputWebFileLocation":"InputWebFileLocation","inputWebFileGeoPointLocation":"InputWebFileLocation","inputWebFileAudioAlbumThumbLocation":"InputWebFileLocation","upload.webFile":"upload.WebFile","payments.paymentForm":"payments.PaymentForm","payments.paymentFormStars":"payments.PaymentForm","payments.paymentFormStarGift":"payments.PaymentForm","payments.validatedRequestedInfo":"payments.ValidatedRequestedInfo","payments.paymentResult":"payments.PaymentResult","payments.paymentVerificationNeeded":"payments.PaymentResult","payments.paymentReceipt":"payments.PaymentReceipt","payments.paymentReceiptStars":"payments.PaymentReceipt","payments.savedInfo":"payments.SavedInfo","inputPaymentCredentialsSaved":"InputPaymentCredentials","inputPaymentCredentials":"InputPaymentCredentials","inputPaymentCredentialsApplePay":"InputPaymentCredentials","inputPaymentCredentialsGooglePay":"InputPaymentCredentials","account.tmpPassword":"account.TmpPassword","shippingOption":"ShippingOption","inputStickerSetItem":"InputStickerSetItem","inputPhoneCall":"InputPhoneCall","phoneCallEmpty":"PhoneCall","phoneCallWaiting":"PhoneCall","phoneCallRequested":"PhoneCall","phoneCallAccepted":"PhoneCall","phoneCall":"PhoneCall","phoneCallDiscarded":"PhoneCall","phoneConnection":"PhoneConnection","phoneConnectionWebrtc":"PhoneConnection","phoneCallProtocol":"PhoneCallProtocol","phone.phoneCall":"phone.PhoneCall","upload.cdnFileReuploadNeeded":"upload.CdnFile","upload.cdnFile":"upload.CdnFile","cdnPublicKey":"CdnPublicKey","cdnConfig":"CdnConfig","langPackString":"LangPackString","langPackStringPluralized":"LangPackString","langPackStringDeleted":"LangPackString","langPackDifference":"LangPackDifference","langPackLanguage":"LangPackLanguage","channelAdminLogEventActionChangeTitle":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeAbout":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeUsername":"ChannelAdminLogEventAction","channelAdminLogEventActionChangePhoto":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleInvites":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleSignatures":"ChannelAdminLogEventAction","channelAdminLogEventActionUpdatePinned":"ChannelAdminLogEventAction","channelAdminLogEventActionEditMessage":"ChannelAdminLogEventAction","channelAdminLogEventActionDeleteMessage":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantJoin":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantLeave":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantInvite":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantToggleBan":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantToggleAdmin":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeStickerSet":"ChannelAdminLogEventAction","channelAdminLogEventActionTogglePreHistoryHidden":"ChannelAdminLogEventAction","channelAdminLogEventActionDefaultBannedRights":"ChannelAdminLogEventAction","channelAdminLogEventActionStopPoll":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeLinkedChat":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeLocation":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleSlowMode":"ChannelAdminLogEventAction","channelAdminLogEventActionStartGroupCall":"ChannelAdminLogEventAction","channelAdminLogEventActionDiscardGroupCall":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantMute":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantUnmute":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleGroupCallSetting":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantJoinByInvite":"ChannelAdminLogEventAction","channelAdminLogEventActionExportedInviteDelete":"ChannelAdminLogEventAction","channelAdminLogEventActionExportedInviteRevoke":"ChannelAdminLogEventAction","channelAdminLogEventActionExportedInviteEdit":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantVolume":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeHistoryTTL":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantJoinByRequest":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleNoForwards":"ChannelAdminLogEventAction","channelAdminLogEventActionSendMessage":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeAvailableReactions":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeUsernames":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleForum":"ChannelAdminLogEventAction","channelAdminLogEventActionCreateTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionEditTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionDeleteTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionPinTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleAntiSpam":"ChannelAdminLogEventAction","channelAdminLogEventActionChangePeerColor":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeProfilePeerColor":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeWallpaper":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeEmojiStatus":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeEmojiStickerSet":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleSignatureProfiles":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantSubExtend":"ChannelAdminLogEventAction","channelAdminLogEvent":"ChannelAdminLogEvent","channels.adminLogResults":"channels.AdminLogResults","channelAdminLogEventsFilter":"ChannelAdminLogEventsFilter","popularContact":"PopularContact","messages.favedStickersNotModified":"messages.FavedStickers","messages.favedStickers":"messages.FavedStickers","recentMeUrlUnknown":"RecentMeUrl","recentMeUrlUser":"RecentMeUrl","recentMeUrlChat":"RecentMeUrl","recentMeUrlChatInvite":"RecentMeUrl","recentMeUrlStickerSet":"RecentMeUrl","help.recentMeUrls":"help.RecentMeUrls","inputSingleMedia":"InputSingleMedia","webAuthorization":"WebAuthorization","account.webAuthorizations":"account.WebAuthorizations","inputMessageID":"InputMessage","inputMessageReplyTo":"InputMessage","inputMessagePinned":"InputMessage","inputMessageCallbackQuery":"InputMessage","inputDialogPeer":"InputDialogPeer","inputDialogPeerFolder":"InputDialogPeer","dialogPeer":"DialogPeer","dialogPeerFolder":"DialogPeer","messages.foundStickerSetsNotModified":"messages.FoundStickerSets","messages.foundStickerSets":"messages.FoundStickerSets","fileHash":"FileHash","inputClientProxy":"InputClientProxy","help.termsOfServiceUpdateEmpty":"help.TermsOfServiceUpdate","help.termsOfServiceUpdate":"help.TermsOfServiceUpdate","inputSecureFileUploaded":"InputSecureFile","inputSecureFile":"InputSecureFile","secureFileEmpty":"SecureFile","secureFile":"SecureFile","secureData":"SecureData","securePlainPhone":"SecurePlainData","securePlainEmail":"SecurePlainData","secureValueTypePersonalDetails":"SecureValueType","secureValueTypePassport":"SecureValueType","secureValueTypeDriverLicense":"SecureValueType","secureValueTypeIdentityCard":"SecureValueType","secureValueTypeInternalPassport":"SecureValueType","secureValueTypeAddress":"SecureValueType","secureValueTypeUtilityBill":"SecureValueType","secureValueTypeBankStatement":"SecureValueType","secureValueTypeRentalAgreement":"SecureValueType","secureValueTypePassportRegistration":"SecureValueType","secureValueTypeTemporaryRegistration":"SecureValueType","secureValueTypePhone":"SecureValueType","secureValueTypeEmail":"SecureValueType","secureValue":"SecureValue","inputSecureValue":"InputSecureValue","secureValueHash":"SecureValueHash","secureValueErrorData":"SecureValueError","secureValueErrorFrontSide":"SecureValueError","secureValueErrorReverseSide":"SecureValueError","secureValueErrorSelfie":"SecureValueError","secureValueErrorFile":"SecureValueError","secureValueErrorFiles":"SecureValueError","secureValueError":"SecureValueError","secureValueErrorTranslationFile":"SecureValueError","secureValueErrorTranslationFiles":"SecureValueError","secureCredentialsEncrypted":"SecureCredentialsEncrypted","account.authorizationForm":"account.AuthorizationForm","account.sentEmailCode":"account.SentEmailCode","help.deepLinkInfoEmpty":"help.DeepLinkInfo","help.deepLinkInfo":"help.DeepLinkInfo","savedPhoneContact":"SavedContact","account.takeout":"account.Takeout","passwordKdfAlgoUnknown":"PasswordKdfAlgo","passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow":"PasswordKdfAlgo","securePasswordKdfAlgoUnknown":"SecurePasswordKdfAlgo","securePasswordKdfAlgoPBKDF2HMACSHA512iter100000":"SecurePasswordKdfAlgo","securePasswordKdfAlgoSHA512":"SecurePasswordKdfAlgo","secureSecretSettings":"SecureSecretSettings","inputCheckPasswordEmpty":"InputCheckPasswordSRP","inputCheckPasswordSRP":"InputCheckPasswordSRP","secureRequiredType":"SecureRequiredType","secureRequiredTypeOneOf":"SecureRequiredType","help.passportConfigNotModified":"help.PassportConfig","help.passportConfig":"help.PassportConfig","inputAppEvent":"InputAppEvent","jsonObjectValue":"JSONObjectValue","jsonNull":"JSONValue","jsonBool":"JSONValue","jsonNumber":"JSONValue","jsonString":"JSONValue","jsonArray":"JSONValue","jsonObject":"JSONValue","pageTableCell":"PageTableCell","pageTableRow":"PageTableRow","pageCaption":"PageCaption","pageListItemText":"PageListItem","pageListItemBlocks":"PageListItem","pageListOrderedItemText":"PageListOrderedItem","pageListOrderedItemBlocks":"PageListOrderedItem","pageRelatedArticle":"PageRelatedArticle","page":"Page","help.supportName":"help.SupportName","help.userInfoEmpty":"help.UserInfo","help.userInfo":"help.UserInfo","pollAnswer":"PollAnswer","poll":"Poll","pollAnswerVoters":"PollAnswerVoters","pollResults":"PollResults","chatOnlines":"ChatOnlines","statsURL":"StatsURL","chatAdminRights":"ChatAdminRights","chatBannedRights":"ChatBannedRights","inputWallPaper":"InputWallPaper","inputWallPaperSlug":"InputWallPaper","inputWallPaperNoFile":"InputWallPaper","account.wallPapersNotModified":"account.WallPapers","account.wallPapers":"account.WallPapers","codeSettings":"CodeSettings","wallPaperSettings":"WallPaperSettings","autoDownloadSettings":"AutoDownloadSettings","account.autoDownloadSettings":"account.AutoDownloadSettings","emojiKeyword":"EmojiKeyword","emojiKeywordDeleted":"EmojiKeyword","emojiKeywordsDifference":"EmojiKeywordsDifference","emojiURL":"EmojiURL","emojiLanguage":"EmojiLanguage","folder":"Folder","inputFolderPeer":"InputFolderPeer","folderPeer":"FolderPeer","messages.searchCounter":"messages.SearchCounter","urlAuthResultRequest":"UrlAuthResult","urlAuthResultAccepted":"UrlAuthResult","urlAuthResultDefault":"UrlAuthResult","channelLocationEmpty":"ChannelLocation","channelLocation":"ChannelLocation","peerLocated":"PeerLocated","peerSelfLocated":"PeerLocated","restrictionReason":"RestrictionReason","inputTheme":"InputTheme","inputThemeSlug":"InputTheme","theme":"Theme","account.themesNotModified":"account.Themes","account.themes":"account.Themes","auth.loginToken":"auth.LoginToken","auth.loginTokenMigrateTo":"auth.LoginToken","auth.loginTokenSuccess":"auth.LoginToken","account.contentSettings":"account.ContentSettings","messages.inactiveChats":"messages.InactiveChats","baseThemeClassic":"BaseTheme","baseThemeDay":"BaseTheme","baseThemeNight":"BaseTheme","baseThemeTinted":"BaseTheme","baseThemeArctic":"BaseTheme","inputThemeSettings":"InputThemeSettings","themeSettings":"ThemeSettings","webPageAttributeTheme":"WebPageAttribute","webPageAttributeStory":"WebPageAttribute","webPageAttributeStickerSet":"WebPageAttribute","messages.votesList":"messages.VotesList","bankCardOpenUrl":"BankCardOpenUrl","payments.bankCardData":"payments.BankCardData","dialogFilter":"DialogFilter","dialogFilterDefault":"DialogFilter","dialogFilterChatlist":"DialogFilter","dialogFilterSuggested":"DialogFilterSuggested","statsDateRangeDays":"StatsDateRangeDays","statsAbsValueAndPrev":"StatsAbsValueAndPrev","statsPercentValue":"StatsPercentValue","statsGraphAsync":"StatsGraph","statsGraphError":"StatsGraph","statsGraph":"StatsGraph","stats.broadcastStats":"stats.BroadcastStats","help.promoDataEmpty":"help.PromoData","help.promoData":"help.PromoData","videoSize":"VideoSize","videoSizeEmojiMarkup":"VideoSize","videoSizeStickerMarkup":"VideoSize","statsGroupTopPoster":"StatsGroupTopPoster","statsGroupTopAdmin":"StatsGroupTopAdmin","statsGroupTopInviter":"StatsGroupTopInviter","stats.megagroupStats":"stats.MegagroupStats","globalPrivacySettings":"GlobalPrivacySettings","help.countryCode":"help.CountryCode","help.country":"help.Country","help.countriesListNotModified":"help.CountriesList","help.countriesList":"help.CountriesList","messageViews":"MessageViews","messages.messageViews":"messages.MessageViews","messages.discussionMessage":"messages.DiscussionMessage","messageReplyHeader":"MessageReplyHeader","messageReplyStoryHeader":"MessageReplyHeader","messageReplies":"MessageReplies","peerBlocked":"PeerBlocked","stats.messageStats":"stats.MessageStats","groupCallDiscarded":"GroupCall","groupCall":"GroupCall","inputGroupCall":"InputGroupCall","groupCallParticipant":"GroupCallParticipant","phone.groupCall":"phone.GroupCall","phone.groupParticipants":"phone.GroupParticipants","inlineQueryPeerTypeSameBotPM":"InlineQueryPeerType","inlineQueryPeerTypePM":"InlineQueryPeerType","inlineQueryPeerTypeChat":"InlineQueryPeerType","inlineQueryPeerTypeMegagroup":"InlineQueryPeerType","inlineQueryPeerTypeBroadcast":"InlineQueryPeerType","inlineQueryPeerTypeBotPM":"InlineQueryPeerType","messages.historyImport":"messages.HistoryImport","messages.historyImportParsed":"messages.HistoryImportParsed","messages.affectedFoundMessages":"messages.AffectedFoundMessages","chatInviteImporter":"ChatInviteImporter","messages.exportedChatInvites":"messages.ExportedChatInvites","messages.exportedChatInvite":"messages.ExportedChatInvite","messages.exportedChatInviteReplaced":"messages.ExportedChatInvite","messages.chatInviteImporters":"messages.ChatInviteImporters","chatAdminWithInvites":"ChatAdminWithInvites","messages.chatAdminsWithInvites":"messages.ChatAdminsWithInvites","messages.checkedHistoryImportPeer":"messages.CheckedHistoryImportPeer","phone.joinAsPeers":"phone.JoinAsPeers","phone.exportedGroupCallInvite":"phone.ExportedGroupCallInvite","groupCallParticipantVideoSourceGroup":"GroupCallParticipantVideoSourceGroup","groupCallParticipantVideo":"GroupCallParticipantVideo","stickers.suggestedShortName":"stickers.SuggestedShortName","botCommandScopeDefault":"BotCommandScope","botCommandScopeUsers":"BotCommandScope","botCommandScopeChats":"BotCommandScope","botCommandScopeChatAdmins":"BotCommandScope","botCommandScopePeer":"BotCommandScope","botCommandScopePeerAdmins":"BotCommandScope","botCommandScopePeerUser":"BotCommandScope","account.resetPasswordFailedWait":"account.ResetPasswordResult","account.resetPasswordRequestedWait":"account.ResetPasswordResult","account.resetPasswordOk":"account.ResetPasswordResult","sponsoredMessage":"SponsoredMessage","messages.sponsoredMessages":"messages.SponsoredMessages","messages.sponsoredMessagesEmpty":"messages.SponsoredMessages","searchResultsCalendarPeriod":"SearchResultsCalendarPeriod","messages.searchResultsCalendar":"messages.SearchResultsCalendar","searchResultPosition":"SearchResultsPosition","messages.searchResultsPositions":"messages.SearchResultsPositions","channels.sendAsPeers":"channels.SendAsPeers","users.userFull":"users.UserFull","messages.peerSettings":"messages.PeerSettings","auth.loggedOut":"auth.LoggedOut","reactionCount":"ReactionCount","messageReactions":"MessageReactions","messages.messageReactionsList":"messages.MessageReactionsList","availableReaction":"AvailableReaction","messages.availableReactionsNotModified":"messages.AvailableReactions","messages.availableReactions":"messages.AvailableReactions","messagePeerReaction":"MessagePeerReaction","groupCallStreamChannel":"GroupCallStreamChannel","phone.groupCallStreamChannels":"phone.GroupCallStreamChannels","phone.groupCallStreamRtmpUrl":"phone.GroupCallStreamRtmpUrl","attachMenuBotIconColor":"AttachMenuBotIconColor","attachMenuBotIcon":"AttachMenuBotIcon","attachMenuBot":"AttachMenuBot","attachMenuBotsNotModified":"AttachMenuBots","attachMenuBots":"AttachMenuBots","attachMenuBotsBot":"AttachMenuBotsBot","webViewResultUrl":"WebViewResult","webViewMessageSent":"WebViewMessageSent","botMenuButtonDefault":"BotMenuButton","botMenuButtonCommands":"BotMenuButton","botMenuButton":"BotMenuButton","account.savedRingtonesNotModified":"account.SavedRingtones","account.savedRingtones":"account.SavedRingtones","notificationSoundDefault":"NotificationSound","notificationSoundNone":"NotificationSound","notificationSoundLocal":"NotificationSound","notificationSoundRingtone":"NotificationSound","account.savedRingtone":"account.SavedRingtone","account.savedRingtoneConverted":"account.SavedRingtone","attachMenuPeerTypeSameBotPM":"AttachMenuPeerType","attachMenuPeerTypeBotPM":"AttachMenuPeerType","attachMenuPeerTypePM":"AttachMenuPeerType","attachMenuPeerTypeChat":"AttachMenuPeerType","attachMenuPeerTypeBroadcast":"AttachMenuPeerType","inputInvoiceMessage":"InputInvoice","inputInvoiceSlug":"InputInvoice","inputInvoicePremiumGiftCode":"InputInvoice","inputInvoiceStars":"InputInvoice","inputInvoiceChatInviteSubscription":"InputInvoice","inputInvoiceStarGift":"InputInvoice","payments.exportedInvoice":"payments.ExportedInvoice","messages.transcribedAudio":"messages.TranscribedAudio","help.premiumPromo":"help.PremiumPromo","inputStorePaymentPremiumSubscription":"InputStorePaymentPurpose","inputStorePaymentGiftPremium":"InputStorePaymentPurpose","inputStorePaymentPremiumGiftCode":"InputStorePaymentPurpose","inputStorePaymentPremiumGiveaway":"InputStorePaymentPurpose","inputStorePaymentStarsTopup":"InputStorePaymentPurpose","inputStorePaymentStarsGift":"InputStorePaymentPurpose","inputStorePaymentStarsGiveaway":"InputStorePaymentPurpose","premiumGiftOption":"PremiumGiftOption","paymentFormMethod":"PaymentFormMethod","emojiStatusEmpty":"EmojiStatus","emojiStatus":"EmojiStatus","emojiStatusUntil":"EmojiStatus","account.emojiStatusesNotModified":"account.EmojiStatuses","account.emojiStatuses":"account.EmojiStatuses","reactionEmpty":"Reaction","reactionEmoji":"Reaction","reactionCustomEmoji":"Reaction","reactionPaid":"Reaction","chatReactionsNone":"ChatReactions","chatReactionsAll":"ChatReactions","chatReactionsSome":"ChatReactions","messages.reactionsNotModified":"messages.Reactions","messages.reactions":"messages.Reactions","emailVerifyPurposeLoginSetup":"EmailVerifyPurpose","emailVerifyPurposeLoginChange":"EmailVerifyPurpose","emailVerifyPurposePassport":"EmailVerifyPurpose","emailVerificationCode":"EmailVerification","emailVerificationGoogle":"EmailVerification","emailVerificationApple":"EmailVerification","account.emailVerified":"account.EmailVerified","account.emailVerifiedLogin":"account.EmailVerified","premiumSubscriptionOption":"PremiumSubscriptionOption","sendAsPeer":"SendAsPeer","messageExtendedMediaPreview":"MessageExtendedMedia","messageExtendedMedia":"MessageExtendedMedia","stickerKeyword":"StickerKeyword","username":"Username","forumTopicDeleted":"ForumTopic","forumTopic":"ForumTopic","messages.forumTopics":"messages.ForumTopics","defaultHistoryTTL":"DefaultHistoryTTL","exportedContactToken":"ExportedContactToken","requestPeerTypeUser":"RequestPeerType","requestPeerTypeChat":"RequestPeerType","requestPeerTypeBroadcast":"RequestPeerType","emojiListNotModified":"EmojiList","emojiList":"EmojiList","emojiGroup":"EmojiGroup","emojiGroupGreeting":"EmojiGroup","emojiGroupPremium":"EmojiGroup","messages.emojiGroupsNotModified":"messages.EmojiGroups","messages.emojiGroups":"messages.EmojiGroups","textWithEntities":"TextWithEntities","messages.translateResult":"messages.TranslatedText","autoSaveSettings":"AutoSaveSettings","autoSaveException":"AutoSaveException","account.autoSaveSettings":"account.AutoSaveSettings","help.appConfigNotModified":"help.AppConfig","help.appConfig":"help.AppConfig","inputBotAppID":"InputBotApp","inputBotAppShortName":"InputBotApp","botAppNotModified":"BotApp","botApp":"BotApp","messages.botApp":"messages.BotApp","inlineBotWebView":"InlineBotWebView","readParticipantDate":"ReadParticipantDate","inputChatlistDialogFilter":"InputChatlist","exportedChatlistInvite":"ExportedChatlistInvite","chatlists.exportedChatlistInvite":"chatlists.ExportedChatlistInvite","chatlists.exportedInvites":"chatlists.ExportedInvites","chatlists.chatlistInviteAlready":"chatlists.ChatlistInvite","chatlists.chatlistInvite":"chatlists.ChatlistInvite","chatlists.chatlistUpdates":"chatlists.ChatlistUpdates","bots.botInfo":"bots.BotInfo","messagePeerVote":"MessagePeerVote","messagePeerVoteInputOption":"MessagePeerVote","messagePeerVoteMultiple":"MessagePeerVote","storyViews":"StoryViews","storyItemDeleted":"StoryItem","storyItemSkipped":"StoryItem","storyItem":"StoryItem","stories.allStoriesNotModified":"stories.AllStories","stories.allStories":"stories.AllStories","stories.stories":"stories.Stories","storyView":"StoryView","storyViewPublicForward":"StoryView","storyViewPublicRepost":"StoryView","stories.storyViewsList":"stories.StoryViewsList","stories.storyViews":"stories.StoryViews","inputReplyToMessage":"InputReplyTo","inputReplyToStory":"InputReplyTo","exportedStoryLink":"ExportedStoryLink","storiesStealthMode":"StoriesStealthMode","mediaAreaCoordinates":"MediaAreaCoordinates","mediaAreaVenue":"MediaArea","inputMediaAreaVenue":"MediaArea","mediaAreaGeoPoint":"MediaArea","mediaAreaSuggestedReaction":"MediaArea","mediaAreaChannelPost":"MediaArea","inputMediaAreaChannelPost":"MediaArea","mediaAreaUrl":"MediaArea","mediaAreaWeather":"MediaArea","peerStories":"PeerStories","stories.peerStories":"stories.PeerStories","messages.webPage":"messages.WebPage","premiumGiftCodeOption":"PremiumGiftCodeOption","payments.checkedGiftCode":"payments.CheckedGiftCode","payments.giveawayInfo":"payments.GiveawayInfo","payments.giveawayInfoResults":"payments.GiveawayInfo","prepaidGiveaway":"PrepaidGiveaway","prepaidStarsGiveaway":"PrepaidGiveaway","boost":"Boost","premium.boostsList":"premium.BoostsList","myBoost":"MyBoost","premium.myBoosts":"premium.MyBoosts","premium.boostsStatus":"premium.BoostsStatus","storyFwdHeader":"StoryFwdHeader","postInteractionCountersMessage":"PostInteractionCounters","postInteractionCountersStory":"PostInteractionCounters","stats.storyStats":"stats.StoryStats","publicForwardMessage":"PublicForward","publicForwardStory":"PublicForward","stats.publicForwards":"stats.PublicForwards","peerColor":"PeerColor","help.peerColorSet":"help.PeerColorSet","help.peerColorProfileSet":"help.PeerColorSet","help.peerColorOption":"help.PeerColorOption","help.peerColorsNotModified":"help.PeerColors","help.peerColors":"help.PeerColors","storyReaction":"StoryReaction","storyReactionPublicForward":"StoryReaction","storyReactionPublicRepost":"StoryReaction","stories.storyReactionsList":"stories.StoryReactionsList","savedDialog":"SavedDialog","messages.savedDialogs":"messages.SavedDialogs","messages.savedDialogsSlice":"messages.SavedDialogs","messages.savedDialogsNotModified":"messages.SavedDialogs","savedReactionTag":"SavedReactionTag","messages.savedReactionTagsNotModified":"messages.SavedReactionTags","messages.savedReactionTags":"messages.SavedReactionTags","outboxReadDate":"OutboxReadDate","smsjobs.eligibleToJoin":"smsjobs.EligibilityToJoin","smsjobs.status":"smsjobs.Status","smsJob":"SmsJob","businessWeeklyOpen":"BusinessWeeklyOpen","businessWorkHours":"BusinessWorkHours","businessLocation":"BusinessLocation","inputBusinessRecipients":"InputBusinessRecipients","businessRecipients":"BusinessRecipients","businessAwayMessageScheduleAlways":"BusinessAwayMessageSchedule","businessAwayMessageScheduleOutsideWorkHours":"BusinessAwayMessageSchedule","businessAwayMessageScheduleCustom":"BusinessAwayMessageSchedule","inputBusinessGreetingMessage":"InputBusinessGreetingMessage","businessGreetingMessage":"BusinessGreetingMessage","inputBusinessAwayMessage":"InputBusinessAwayMessage","businessAwayMessage":"BusinessAwayMessage","timezone":"Timezone","help.timezonesListNotModified":"help.TimezonesList","help.timezonesList":"help.TimezonesList","quickReply":"QuickReply","inputQuickReplyShortcut":"InputQuickReplyShortcut","inputQuickReplyShortcutId":"InputQuickReplyShortcut","messages.quickReplies":"messages.QuickReplies","messages.quickRepliesNotModified":"messages.QuickReplies","connectedBot":"ConnectedBot","account.connectedBots":"account.ConnectedBots","messages.dialogFilters":"messages.DialogFilters","birthday":"Birthday","botBusinessConnection":"BotBusinessConnection","inputBusinessIntro":"InputBusinessIntro","businessIntro":"BusinessIntro","messages.myStickers":"messages.MyStickers","inputCollectibleUsername":"InputCollectible","inputCollectiblePhone":"InputCollectible","fragment.collectibleInfo":"fragment.CollectibleInfo","inputBusinessBotRecipients":"InputBusinessBotRecipients","businessBotRecipients":"BusinessBotRecipients","contactBirthday":"ContactBirthday","contacts.contactBirthdays":"contacts.ContactBirthdays","missingInvitee":"MissingInvitee","messages.invitedUsers":"messages.InvitedUsers","inputBusinessChatLink":"InputBusinessChatLink","businessChatLink":"BusinessChatLink","account.businessChatLinks":"account.BusinessChatLinks","account.resolvedBusinessChatLinks":"account.ResolvedBusinessChatLinks","requestedPeerUser":"RequestedPeer","requestedPeerChat":"RequestedPeer","requestedPeerChannel":"RequestedPeer","sponsoredMessageReportOption":"SponsoredMessageReportOption","channels.sponsoredMessageReportResultChooseOption":"channels.SponsoredMessageReportResult","channels.sponsoredMessageReportResultAdsHidden":"channels.SponsoredMessageReportResult","channels.sponsoredMessageReportResultReported":"channels.SponsoredMessageReportResult","stats.broadcastRevenueStats":"stats.BroadcastRevenueStats","stats.broadcastRevenueWithdrawalUrl":"stats.BroadcastRevenueWithdrawalUrl","broadcastRevenueTransactionProceeds":"BroadcastRevenueTransaction","broadcastRevenueTransactionWithdrawal":"BroadcastRevenueTransaction","broadcastRevenueTransactionRefund":"BroadcastRevenueTransaction","stats.broadcastRevenueTransactions":"stats.BroadcastRevenueTransactions","reactionNotificationsFromContacts":"ReactionNotificationsFrom","reactionNotificationsFromAll":"ReactionNotificationsFrom","reactionsNotifySettings":"ReactionsNotifySettings","broadcastRevenueBalances":"BroadcastRevenueBalances","availableEffect":"AvailableEffect","messages.availableEffectsNotModified":"messages.AvailableEffects","messages.availableEffects":"messages.AvailableEffects","factCheck":"FactCheck","starsTransactionPeerUnsupported":"StarsTransactionPeer","starsTransactionPeerAppStore":"StarsTransactionPeer","starsTransactionPeerPlayMarket":"StarsTransactionPeer","starsTransactionPeerPremiumBot":"StarsTransactionPeer","starsTransactionPeerFragment":"StarsTransactionPeer","starsTransactionPeer":"StarsTransactionPeer","starsTransactionPeerAds":"StarsTransactionPeer","starsTopupOption":"StarsTopupOption","starsTransaction":"StarsTransaction","payments.starsStatus":"payments.StarsStatus","foundStory":"FoundStory","stories.foundStories":"stories.FoundStories","geoPointAddress":"GeoPointAddress","starsRevenueStatus":"StarsRevenueStatus","payments.starsRevenueStats":"payments.StarsRevenueStats","payments.starsRevenueWithdrawalUrl":"payments.StarsRevenueWithdrawalUrl","payments.starsRevenueAdsAccountUrl":"payments.StarsRevenueAdsAccountUrl","inputStarsTransaction":"InputStarsTransaction","starsGiftOption":"StarsGiftOption","bots.popularAppBots":"bots.PopularAppBots","botPreviewMedia":"BotPreviewMedia","bots.previewInfo":"bots.PreviewInfo","starsSubscriptionPricing":"StarsSubscriptionPricing","starsSubscription":"StarsSubscription","messageReactor":"MessageReactor","starsGiveawayOption":"StarsGiveawayOption","starsGiveawayWinnersOption":"StarsGiveawayWinnersOption","starGift":"StarGift","payments.starGiftsNotModified":"payments.StarGifts","payments.starGifts":"payments.StarGifts","userStarGift":"UserStarGift","payments.userStarGifts":"payments.UserStarGifts","messageReportOption":"MessageReportOption","reportResultChooseOption":"ReportResult","reportResultAddComment":"ReportResult","reportResultReported":"ReportResult","mtcute.dummyUpdate":"Update","mtcute.dummyInputPeerMinUser":"InputPeer","mtcute.dummyInputPeerMinChannel":"InputPeer"}');
        })(exports2.tl);
        exports2.mtp = {};
        (function(ns) {
          var _types = void 0;
          function _isAny(type) {
            return function(obj) {
              return typeof obj === "object" && obj && _types[obj._] == type;
            };
          }
          ns.$extendTypes = function(types) {
            for (var i in types) {
              types.hasOwnProperty(i) && (_types[i] = types[i]);
            }
          };
          ns.LAYER = 0;
          ns.isAnyResPQ = _isAny("ResPQ");
          ns.isAnyP_Q_inner_data = _isAny("P_Q_inner_data");
          ns.isAnyServer_DH_Params = _isAny("Server_DH_Params");
          ns.isAnyServer_DH_inner_data = _isAny("Server_DH_inner_data");
          ns.isAnyClient_DH_Inner_Data = _isAny("Client_DH_Inner_Data");
          ns.isAnySet_client_DH_params_answer = _isAny("Set_client_DH_params_answer");
          ns.isAnyBindAuthKeyInner = _isAny("BindAuthKeyInner");
          ns.isAnyRpcError = _isAny("RpcError");
          ns.isAnyRpcDropAnswer = _isAny("RpcDropAnswer");
          ns.isAnyFutureSalt = _isAny("FutureSalt");
          ns.isAnyFutureSalts = _isAny("FutureSalts");
          ns.isAnyPong = _isAny("Pong");
          ns.isAnyDestroySessionRes = _isAny("DestroySessionRes");
          ns.isAnyNewSession = _isAny("NewSession");
          ns.isAnyMsgsAck = _isAny("MsgsAck");
          ns.isAnyBadMsgNotification = _isAny("BadMsgNotification");
          ns.isAnyMsgResendReq = _isAny("MsgResendReq");
          ns.isAnyMsgsStateReq = _isAny("MsgsStateReq");
          ns.isAnyMsgsStateInfo = _isAny("MsgsStateInfo");
          ns.isAnyMsgsAllInfo = _isAny("MsgsAllInfo");
          ns.isAnyMsgDetailedInfo = _isAny("MsgDetailedInfo");
          ns.isAnyDestroyAuthKeyRes = _isAny("DestroyAuthKeyRes");
          ns.isAnyHttpWait = _isAny("HttpWait");
          _types = JSON.parse('{"mt_resPQ":"ResPQ","mt_p_q_inner_data_dc":"P_Q_inner_data","mt_p_q_inner_data_temp_dc":"P_Q_inner_data","mt_server_DH_params_ok":"Server_DH_Params","mt_server_DH_inner_data":"Server_DH_inner_data","mt_client_DH_inner_data":"Client_DH_Inner_Data","mt_dh_gen_ok":"Set_client_DH_params_answer","mt_dh_gen_retry":"Set_client_DH_params_answer","mt_dh_gen_fail":"Set_client_DH_params_answer","mt_bind_auth_key_inner":"BindAuthKeyInner","mt_rpc_error":"RpcError","mt_rpc_answer_unknown":"RpcDropAnswer","mt_rpc_answer_dropped_running":"RpcDropAnswer","mt_rpc_answer_dropped":"RpcDropAnswer","mt_future_salt":"FutureSalt","mt_future_salts":"FutureSalts","mt_pong":"Pong","mt_destroy_session_ok":"DestroySessionRes","mt_destroy_session_none":"DestroySessionRes","mt_new_session_created":"NewSession","mt_msgs_ack":"MsgsAck","mt_bad_msg_notification":"BadMsgNotification","mt_bad_server_salt":"BadMsgNotification","mt_msg_resend_req":"MsgResendReq","mt_msgs_state_req":"MsgsStateReq","mt_msgs_state_info":"MsgsStateInfo","mt_msgs_all_info":"MsgsAllInfo","mt_msg_detailed_info":"MsgDetailedInfo","mt_msg_new_detailed_info":"MsgDetailedInfo","mt_destroy_auth_key_ok":"DestroyAuthKeyRes","mt_destroy_auth_key_none":"DestroyAuthKeyRes","mt_destroy_auth_key_fail":"DestroyAuthKeyRes","mt_http_wait":"HttpWait","mt_req_pq_multi":"ResPQ","mt_req_DH_params":"Server_DH_Params","mt_set_client_DH_params":"Set_client_DH_params_answer","mt_rpc_drop_answer":"RpcDropAnswer","mt_get_future_salts":"FutureSalts","mt_ping":"Pong","mt_ping_delay_disconnect":"Pong","mt_destroy_session":"DestroySessionRes","mt_destroy_auth_key":"DestroyAuthKeyRes"}');
        })(exports2.mtp);
      })(tl);
      var reader = {};
      Object.defineProperty(reader, "__esModule", { value: true });
      var m$1 = {
        3300522427: function(r2) {
          return { _: "error", code: r2.int(), text: r2.string() };
        },
        3560156531: function(r2) {
          return { _: "ipPort", ipv4: r2.int(), port: r2.int() };
        },
        932718150: function(r2) {
          return { _: "ipPortSecret", ipv4: r2.int(), port: r2.int(), secret: r2.bytes() };
        },
        1182381663: function(r2) {
          return { _: "accessPointRule", phonePrefixRules: r2.string(), dcId: r2.int(), ips: r2.vector(r2.object, 1) };
        },
        1515793004: function(r2) {
          return { _: "help.configSimple", date: r2.int(), expires: r2.int(), rules: r2.vector(r2.object, 1) };
        },
        668375447: function(r2) {
          var flags = r2.uint();
          return { _: "inputPeerPhotoFileLocationLegacy", big: !!(flags & 1), peer: r2.object(), volumeId: r2.long(), localId: r2.int() };
        },
        230353641: function(r2) {
          return { _: "inputStickerSetThumbLegacy", stickerset: r2.object(), volumeId: r2.long(), localId: r2.int() };
        },
        2134579434: function(r2) {
          return { _: "inputPeerEmpty" };
        },
        2107670217: function(r2) {
          return { _: "inputPeerSelf" };
        },
        900291769: function(r2) {
          return { _: "inputPeerChat", chatId: r2.int53() };
        },
        3723011404: function(r2) {
          return { _: "inputPeerUser", userId: r2.int53(), accessHash: r2.long() };
        },
        666680316: function(r2) {
          return { _: "inputPeerChannel", channelId: r2.int53(), accessHash: r2.long() };
        },
        2826635804: function(r2) {
          return { _: "inputPeerUserFromMessage", peer: r2.object(), msgId: r2.int(), userId: r2.int53() };
        },
        3173648448: function(r2) {
          return { _: "inputPeerChannelFromMessage", peer: r2.object(), msgId: r2.int(), channelId: r2.int53() };
        },
        3112732367: function(r2) {
          return { _: "inputUserEmpty" };
        },
        4156666175: function(r2) {
          return { _: "inputUserSelf" };
        },
        4061223110: function(r2) {
          return { _: "inputUser", userId: r2.int53(), accessHash: r2.long() };
        },
        497305826: function(r2) {
          return { _: "inputUserFromMessage", peer: r2.object(), msgId: r2.int(), userId: r2.int53() };
        },
        4086478836: function(r2) {
          return { _: "inputPhoneContact", clientId: r2.long(), phone: r2.string(), firstName: r2.string(), lastName: r2.string() };
        },
        4113560191: function(r2) {
          return { _: "inputFile", id: r2.long(), parts: r2.int(), name: r2.string(), md5Checksum: r2.string() };
        },
        4199484341: function(r2) {
          return { _: "inputFileBig", id: r2.long(), parts: r2.int(), name: r2.string() };
        },
        1658620744: function(r2) {
          return { _: "inputFileStoryDocument", id: r2.object() };
        },
        2523198847: function(r2) {
          return { _: "inputMediaEmpty" };
        },
        505969924: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaUploadedPhoto", spoiler: !!(flags & 4), file: r2.object(), stickers: flags & 1 ? r2.vector(r2.object) : void 0, ttlSeconds: flags & 2 ? r2.int() : void 0 };
        },
        3015312949: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaPhoto", spoiler: !!(flags & 2), id: r2.object(), ttlSeconds: flags & 1 ? r2.int() : void 0 };
        },
        4190388548: function(r2) {
          return { _: "inputMediaGeoPoint", geoPoint: r2.object() };
        },
        4171988475: function(r2) {
          return { _: "inputMediaContact", phoneNumber: r2.string(), firstName: r2.string(), lastName: r2.string(), vcard: r2.string() };
        },
        1530447553: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaUploadedDocument", nosoundVideo: !!(flags & 8), forceFile: !!(flags & 16), spoiler: !!(flags & 32), file: r2.object(), thumb: flags & 4 ? r2.object() : void 0, mimeType: r2.string(), attributes: r2.vector(r2.object), stickers: flags & 1 ? r2.vector(r2.object) : void 0, ttlSeconds: flags & 2 ? r2.int() : void 0 };
        },
        860303448: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaDocument", spoiler: !!(flags & 4), id: r2.object(), ttlSeconds: flags & 1 ? r2.int() : void 0, query: flags & 2 ? r2.string() : void 0 };
        },
        3242007569: function(r2) {
          return { _: "inputMediaVenue", geoPoint: r2.object(), title: r2.string(), address: r2.string(), provider: r2.string(), venueId: r2.string(), venueType: r2.string() };
        },
        3854302746: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaPhotoExternal", spoiler: !!(flags & 2), url: r2.string(), ttlSeconds: flags & 1 ? r2.int() : void 0 };
        },
        4216511641: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaDocumentExternal", spoiler: !!(flags & 2), url: r2.string(), ttlSeconds: flags & 1 ? r2.int() : void 0 };
        },
        3544138739: function(r2) {
          return { _: "inputMediaGame", id: r2.object() };
        },
        1080028941: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaInvoice", title: r2.string(), description: r2.string(), photo: flags & 1 ? r2.object() : void 0, invoice: r2.object(), payload: r2.bytes(), provider: flags & 8 ? r2.string() : void 0, providerData: r2.object(), startParam: flags & 2 ? r2.string() : void 0, extendedMedia: flags & 4 ? r2.object() : void 0 };
        },
        2535434307: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaGeoLive", stopped: !!(flags & 1), geoPoint: r2.object(), heading: flags & 4 ? r2.int() : void 0, period: flags & 2 ? r2.int() : void 0, proximityNotificationRadius: flags & 8 ? r2.int() : void 0 };
        },
        261416433: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaPoll", poll: r2.object(), correctAnswers: flags & 1 ? r2.vector(r2.bytes) : void 0, solution: flags & 2 ? r2.string() : void 0, solutionEntities: flags & 2 ? r2.vector(r2.object) : void 0 };
        },
        3866083195: function(r2) {
          return { _: "inputMediaDice", emoticon: r2.string() };
        },
        2315114360: function(r2) {
          return { _: "inputMediaStory", peer: r2.object(), id: r2.int() };
        },
        3256584265: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaWebPage", forceLargeMedia: !!(flags & 1), forceSmallMedia: !!(flags & 2), optional: !!(flags & 4), url: r2.string() };
        },
        3289396102: function(r2) {
          var flags = r2.uint();
          return { _: "inputMediaPaidMedia", starsAmount: r2.long(), extendedMedia: r2.vector(r2.object), payload: flags & 1 ? r2.string() : void 0 };
        },
        480546647: function(r2) {
          return { _: "inputChatPhotoEmpty" };
        },
        3184373440: function(r2) {
          var flags = r2.uint();
          return { _: "inputChatUploadedPhoto", file: flags & 1 ? r2.object() : void 0, video: flags & 2 ? r2.object() : void 0, videoStartTs: flags & 4 ? r2.double() : void 0, videoEmojiMarkup: flags & 8 ? r2.object() : void 0 };
        },
        2303962423: function(r2) {
          return { _: "inputChatPhoto", id: r2.object() };
        },
        3837862870: function(r2) {
          return { _: "inputGeoPointEmpty" };
        },
        1210199983: function(r2) {
          var flags = r2.uint();
          return { _: "inputGeoPoint", lat: r2.double(), long: r2.double(), accuracyRadius: flags & 1 ? r2.int() : void 0 };
        },
        483901197: function(r2) {
          return { _: "inputPhotoEmpty" };
        },
        1001634122: function(r2) {
          return { _: "inputPhoto", id: r2.long(), accessHash: r2.long(), fileReference: r2.bytes() };
        },
        3755650017: function(r2) {
          return { _: "inputFileLocation", volumeId: r2.long(), localId: r2.int(), secret: r2.long(), fileReference: r2.bytes() };
        },
        4112735573: function(r2) {
          return { _: "inputEncryptedFileLocation", id: r2.long(), accessHash: r2.long() };
        },
        3134223748: function(r2) {
          return { _: "inputDocumentFileLocation", id: r2.long(), accessHash: r2.long(), fileReference: r2.bytes(), thumbSize: r2.string() };
        },
        3418877480: function(r2) {
          return { _: "inputSecureFileLocation", id: r2.long(), accessHash: r2.long() };
        },
        700340377: function(r2) {
          return { _: "inputTakeoutFileLocation" };
        },
        1075322878: function(r2) {
          return { _: "inputPhotoFileLocation", id: r2.long(), accessHash: r2.long(), fileReference: r2.bytes(), thumbSize: r2.string() };
        },
        3627312883: function(r2) {
          return { _: "inputPhotoLegacyFileLocation", id: r2.long(), accessHash: r2.long(), fileReference: r2.bytes(), volumeId: r2.long(), localId: r2.int(), secret: r2.long() };
        },
        925204121: function(r2) {
          var flags = r2.uint();
          return { _: "inputPeerPhotoFileLocation", big: !!(flags & 1), peer: r2.object(), photoId: r2.long() };
        },
        2642736091: function(r2) {
          return { _: "inputStickerSetThumb", stickerset: r2.object(), thumbVersion: r2.int() };
        },
        93890858: function(r2) {
          var flags = r2.uint();
          return { _: "inputGroupCallStream", call: r2.object(), timeMs: r2.long(), scale: r2.int(), videoChannel: flags & 1 ? r2.int() : void 0, videoQuality: flags & 1 ? r2.int() : void 0 };
        },
        1498486562: function(r2) {
          return { _: "peerUser", userId: r2.int53() };
        },
        918946202: function(r2) {
          return { _: "peerChat", chatId: r2.int53() };
        },
        2728736542: function(r2) {
          return { _: "peerChannel", channelId: r2.int53() };
        },
        2861972229: function(r2) {
          return { _: "storage.fileUnknown" };
        },
        1086091090: function(r2) {
          return { _: "storage.filePartial" };
        },
        8322574: function(r2) {
          return { _: "storage.fileJpeg" };
        },
        3403786975: function(r2) {
          return { _: "storage.fileGif" };
        },
        172975040: function(r2) {
          return { _: "storage.filePng" };
        },
        2921222285: function(r2) {
          return { _: "storage.filePdf" };
        },
        1384777335: function(r2) {
          return { _: "storage.fileMp3" };
        },
        1258941372: function(r2) {
          return { _: "storage.fileMov" };
        },
        3016663268: function(r2) {
          return { _: "storage.fileMp4" };
        },
        276907596: function(r2) {
          return { _: "storage.fileWebp" };
        },
        3552332666: function(r2) {
          return { _: "userEmpty", id: r2.int53() };
        },
        2201046986: function(r2) {
          var flags = r2.uint(), flags2 = r2.uint();
          return { _: "user", self: !!(flags & 1024), contact: !!(flags & 2048), mutualContact: !!(flags & 4096), deleted: !!(flags & 8192), bot: !!(flags & 16384), botChatHistory: !!(flags & 32768), botNochats: !!(flags & 65536), verified: !!(flags & 131072), restricted: !!(flags & 262144), min: !!(flags & 1048576), botInlineGeo: !!(flags & 2097152), support: !!(flags & 8388608), scam: !!(flags & 16777216), applyMinPhoto: !!(flags & 33554432), fake: !!(flags & 67108864), botAttachMenu: !!(flags & 134217728), premium: !!(flags & 268435456), attachMenuEnabled: !!(flags & 536870912), botCanEdit: !!(flags2 & 2), closeFriend: !!(flags2 & 4), storiesHidden: !!(flags2 & 8), storiesUnavailable: !!(flags2 & 16), contactRequirePremium: !!(flags2 & 1024), botBusiness: !!(flags2 & 2048), botHasMainApp: !!(flags2 & 8192), id: r2.int53(), accessHash: flags & 1 ? r2.long() : void 0, firstName: flags & 2 ? r2.string() : void 0, lastName: flags & 4 ? r2.string() : void 0, username: flags & 8 ? r2.string() : void 0, phone: flags & 16 ? r2.string() : void 0, photo: flags & 32 ? r2.object() : void 0, status: flags & 64 ? r2.object() : void 0, botInfoVersion: flags & 16384 ? r2.int() : void 0, restrictionReason: flags & 262144 ? r2.vector(r2.object) : void 0, botInlinePlaceholder: flags & 524288 ? r2.string() : void 0, langCode: flags & 4194304 ? r2.string() : void 0, emojiStatus: flags & 1073741824 ? r2.object() : void 0, usernames: flags2 & 1 ? r2.vector(r2.object) : void 0, storiesMaxId: flags2 & 32 ? r2.int() : void 0, color: flags2 & 256 ? r2.object() : void 0, profileColor: flags2 & 512 ? r2.object() : void 0, botActiveUsers: flags2 & 4096 ? r2.int() : void 0 };
        },
        1326562017: function(r2) {
          return { _: "userProfilePhotoEmpty" };
        },
        2194798342: function(r2) {
          var flags = r2.uint();
          return { _: "userProfilePhoto", hasVideo: !!(flags & 1), personal: !!(flags & 4), photoId: r2.long(), strippedThumb: flags & 2 ? r2.bytes() : void 0, dcId: r2.int() };
        },
        164646985: function(r2) {
          return { _: "userStatusEmpty" };
        },
        3988339017: function(r2) {
          return { _: "userStatusOnline", expires: r2.int() };
        },
        9203775: function(r2) {
          return { _: "userStatusOffline", wasOnline: r2.int() };
        },
        2065268168: function(r2) {
          var flags = r2.uint();
          return { _: "userStatusRecently", byMe: !!(flags & 1) };
        },
        1410997530: function(r2) {
          var flags = r2.uint();
          return { _: "userStatusLastWeek", byMe: !!(flags & 1) };
        },
        1703516023: function(r2) {
          var flags = r2.uint();
          return { _: "userStatusLastMonth", byMe: !!(flags & 1) };
        },
        693512293: function(r2) {
          return { _: "chatEmpty", id: r2.int53() };
        },
        1103884886: function(r2) {
          var flags = r2.uint();
          return { _: "chat", creator: !!(flags & 1), left: !!(flags & 4), deactivated: !!(flags & 32), callActive: !!(flags & 8388608), callNotEmpty: !!(flags & 16777216), noforwards: !!(flags & 33554432), id: r2.int53(), title: r2.string(), photo: r2.object(), participantsCount: r2.int(), date: r2.int(), version: r2.int(), migratedTo: flags & 64 ? r2.object() : void 0, adminRights: flags & 16384 ? r2.object() : void 0, defaultBannedRights: flags & 262144 ? r2.object() : void 0 };
        },
        1704108455: function(r2) {
          return { _: "chatForbidden", id: r2.int53(), title: r2.string() };
        },
        4265900221: function(r2) {
          var flags = r2.uint(), flags2 = r2.uint();
          return { _: "channel", creator: !!(flags & 1), left: !!(flags & 4), broadcast: !!(flags & 32), verified: !!(flags & 128), megagroup: !!(flags & 256), restricted: !!(flags & 512), signatures: !!(flags & 2048), min: !!(flags & 4096), scam: !!(flags & 524288), hasLink: !!(flags & 1048576), hasGeo: !!(flags & 2097152), slowmodeEnabled: !!(flags & 4194304), callActive: !!(flags & 8388608), callNotEmpty: !!(flags & 16777216), fake: !!(flags & 33554432), gigagroup: !!(flags & 67108864), noforwards: !!(flags & 134217728), joinToSend: !!(flags & 268435456), joinRequest: !!(flags & 536870912), forum: !!(flags & 1073741824), storiesHidden: !!(flags2 & 2), storiesHiddenMin: !!(flags2 & 4), storiesUnavailable: !!(flags2 & 8), signatureProfiles: !!(flags2 & 4096), id: r2.int53(), accessHash: flags & 8192 ? r2.long() : void 0, title: r2.string(), username: flags & 64 ? r2.string() : void 0, photo: r2.object(), date: r2.int(), restrictionReason: flags & 512 ? r2.vector(r2.object) : void 0, adminRights: flags & 16384 ? r2.object() : void 0, bannedRights: flags & 32768 ? r2.object() : void 0, defaultBannedRights: flags & 262144 ? r2.object() : void 0, participantsCount: flags & 131072 ? r2.int() : void 0, usernames: flags2 & 1 ? r2.vector(r2.object) : void 0, storiesMaxId: flags2 & 16 ? r2.int() : void 0, color: flags2 & 128 ? r2.object() : void 0, profileColor: flags2 & 256 ? r2.object() : void 0, emojiStatus: flags2 & 512 ? r2.object() : void 0, level: flags2 & 1024 ? r2.int() : void 0, subscriptionUntilDate: flags2 & 2048 ? r2.int() : void 0 };
        },
        399807445: function(r2) {
          var flags = r2.uint();
          return { _: "channelForbidden", broadcast: !!(flags & 32), megagroup: !!(flags & 256), id: r2.int53(), accessHash: r2.long(), title: r2.string(), untilDate: flags & 65536 ? r2.int() : void 0 };
        },
        640893467: function(r2) {
          var flags = r2.uint();
          return { _: "chatFull", canSetUsername: !!(flags & 128), hasScheduled: !!(flags & 256), translationsDisabled: !!(flags & 524288), id: r2.int53(), about: r2.string(), participants: r2.object(), chatPhoto: flags & 4 ? r2.object() : void 0, notifySettings: r2.object(), exportedInvite: flags & 8192 ? r2.object() : void 0, botInfo: flags & 8 ? r2.vector(r2.object) : void 0, pinnedMsgId: flags & 64 ? r2.int() : void 0, folderId: flags & 2048 ? r2.int() : void 0, call: flags & 4096 ? r2.object() : void 0, ttlPeriod: flags & 16384 ? r2.int() : void 0, groupcallDefaultJoinAs: flags & 32768 ? r2.object() : void 0, themeEmoticon: flags & 65536 ? r2.string() : void 0, requestsPending: flags & 131072 ? r2.int() : void 0, recentRequesters: flags & 131072 ? r2.vector(r2.long) : void 0, availableReactions: flags & 262144 ? r2.object() : void 0, reactionsLimit: flags & 1048576 ? r2.int() : void 0 };
        },
        3148559501: function(r2) {
          var flags = r2.uint(), flags2 = r2.uint();
          return { _: "channelFull", canViewParticipants: !!(flags & 8), canSetUsername: !!(flags & 64), canSetStickers: !!(flags & 128), hiddenPrehistory: !!(flags & 1024), canSetLocation: !!(flags & 65536), hasScheduled: !!(flags & 524288), canViewStats: !!(flags & 1048576), blocked: !!(flags & 4194304), canDeleteChannel: !!(flags2 & 1), antispam: !!(flags2 & 2), participantsHidden: !!(flags2 & 4), translationsDisabled: !!(flags2 & 8), storiesPinnedAvailable: !!(flags2 & 32), viewForumAsMessages: !!(flags2 & 64), restrictedSponsored: !!(flags2 & 2048), canViewRevenue: !!(flags2 & 4096), paidMediaAllowed: !!(flags2 & 16384), canViewStarsRevenue: !!(flags2 & 32768), paidReactionsAvailable: !!(flags2 & 65536), id: r2.int53(), about: r2.string(), participantsCount: flags & 1 ? r2.int() : void 0, adminsCount: flags & 2 ? r2.int() : void 0, kickedCount: flags & 4 ? r2.int() : void 0, bannedCount: flags & 4 ? r2.int() : void 0, onlineCount: flags & 8192 ? r2.int() : void 0, readInboxMaxId: r2.int(), readOutboxMaxId: r2.int(), unreadCount: r2.int(), chatPhoto: r2.object(), notifySettings: r2.object(), exportedInvite: flags & 8388608 ? r2.object() : void 0, botInfo: r2.vector(r2.object), migratedFromChatId: flags & 16 ? r2.long() : void 0, migratedFromMaxId: flags & 16 ? r2.int() : void 0, pinnedMsgId: flags & 32 ? r2.int() : void 0, stickerset: flags & 256 ? r2.object() : void 0, availableMinId: flags & 512 ? r2.int() : void 0, folderId: flags & 2048 ? r2.int() : void 0, linkedChatId: flags & 16384 ? r2.int53() : void 0, location: flags & 32768 ? r2.object() : void 0, slowmodeSeconds: flags & 131072 ? r2.int() : void 0, slowmodeNextSendDate: flags & 262144 ? r2.int() : void 0, statsDc: flags & 4096 ? r2.int() : void 0, pts: r2.int(), call: flags & 2097152 ? r2.object() : void 0, ttlPeriod: flags & 16777216 ? r2.int() : void 0, pendingSuggestions: flags & 33554432 ? r2.vector(r2.string) : void 0, groupcallDefaultJoinAs: flags & 67108864 ? r2.object() : void 0, themeEmoticon: flags & 134217728 ? r2.string() : void 0, requestsPending: flags & 268435456 ? r2.int() : void 0, recentRequesters: flags & 268435456 ? r2.vector(r2.long) : void 0, defaultSendAs: flags & 536870912 ? r2.object() : void 0, availableReactions: flags & 1073741824 ? r2.object() : void 0, reactionsLimit: flags2 & 8192 ? r2.int() : void 0, stories: flags2 & 16 ? r2.object() : void 0, wallpaper: flags2 & 128 ? r2.object() : void 0, boostsApplied: flags2 & 256 ? r2.int() : void 0, boostsUnrestrict: flags2 & 512 ? r2.int() : void 0, emojiset: flags2 & 1024 ? r2.object() : void 0 };
        },
        3224190983: function(r2) {
          return { _: "chatParticipant", userId: r2.int53(), inviterId: r2.int53(), date: r2.int() };
        },
        3832270564: function(r2) {
          return { _: "chatParticipantCreator", userId: r2.int53() };
        },
        2694004571: function(r2) {
          return { _: "chatParticipantAdmin", userId: r2.int53(), inviterId: r2.int53(), date: r2.int() };
        },
        2271466465: function(r2) {
          var flags = r2.uint();
          return { _: "chatParticipantsForbidden", chatId: r2.int53(), selfParticipant: flags & 1 ? r2.object() : void 0 };
        },
        1018991608: function(r2) {
          return { _: "chatParticipants", chatId: r2.int53(), participants: r2.vector(r2.object), version: r2.int() };
        },
        935395612: function(r2) {
          return { _: "chatPhotoEmpty" };
        },
        476978193: function(r2) {
          var flags = r2.uint();
          return { _: "chatPhoto", hasVideo: !!(flags & 1), photoId: r2.long(), strippedThumb: flags & 2 ? r2.bytes() : void 0, dcId: r2.int() };
        },
        2426849924: function(r2) {
          var flags = r2.uint();
          return { _: "messageEmpty", id: r2.int(), peerId: flags & 1 ? r2.object() : void 0 };
        },
        2486456898: function(r2) {
          var flags = r2.uint(), flags2 = r2.uint();
          return { _: "message", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), post: !!(flags & 16384), fromScheduled: !!(flags & 262144), legacy: !!(flags & 524288), editHide: !!(flags & 2097152), pinned: !!(flags & 16777216), noforwards: !!(flags & 67108864), invertMedia: !!(flags & 134217728), offline: !!(flags2 & 2), id: r2.int(), fromId: flags & 256 ? r2.object() : void 0, fromBoostsApplied: flags & 536870912 ? r2.int() : void 0, peerId: r2.object(), savedPeerId: flags & 268435456 ? r2.object() : void 0, fwdFrom: flags & 4 ? r2.object() : void 0, viaBotId: flags & 2048 ? r2.int53() : void 0, viaBusinessBotId: flags2 & 1 ? r2.int53() : void 0, replyTo: flags & 8 ? r2.object() : void 0, date: r2.int(), message: r2.string(), media: flags & 512 ? r2.object() : void 0, replyMarkup: flags & 64 ? r2.object() : void 0, entities: flags & 128 ? r2.vector(r2.object) : void 0, views: flags & 1024 ? r2.int() : void 0, forwards: flags & 1024 ? r2.int() : void 0, replies: flags & 8388608 ? r2.object() : void 0, editDate: flags & 32768 ? r2.int() : void 0, postAuthor: flags & 65536 ? r2.string() : void 0, groupedId: flags & 131072 ? r2.long() : void 0, reactions: flags & 1048576 ? r2.object() : void 0, restrictionReason: flags & 4194304 ? r2.vector(r2.object) : void 0, ttlPeriod: flags & 33554432 ? r2.int() : void 0, quickReplyShortcutId: flags & 1073741824 ? r2.int() : void 0, effect: flags2 & 4 ? r2.long() : void 0, factcheck: flags2 & 8 ? r2.object() : void 0 };
        },
        721967202: function(r2) {
          var flags = r2.uint();
          return { _: "messageService", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), post: !!(flags & 16384), legacy: !!(flags & 524288), id: r2.int(), fromId: flags & 256 ? r2.object() : void 0, peerId: r2.object(), replyTo: flags & 8 ? r2.object() : void 0, date: r2.int(), action: r2.object(), ttlPeriod: flags & 33554432 ? r2.int() : void 0 };
        },
        1038967584: function(r2) {
          return { _: "messageMediaEmpty" };
        },
        1766936791: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaPhoto", spoiler: !!(flags & 8), photo: flags & 1 ? r2.object() : void 0, ttlSeconds: flags & 4 ? r2.int() : void 0 };
        },
        1457575028: function(r2) {
          return { _: "messageMediaGeo", geo: r2.object() };
        },
        1882335561: function(r2) {
          return { _: "messageMediaContact", phoneNumber: r2.string(), firstName: r2.string(), lastName: r2.string(), vcard: r2.string(), userId: r2.int53() };
        },
        2676290718: function(r2) {
          return { _: "messageMediaUnsupported" };
        },
        3713469397: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaDocument", nopremium: !!(flags & 8), spoiler: !!(flags & 16), video: !!(flags & 64), round: !!(flags & 128), voice: !!(flags & 256), document: flags & 1 ? r2.object() : void 0, altDocuments: flags & 32 ? r2.vector(r2.object) : void 0, ttlSeconds: flags & 4 ? r2.int() : void 0 };
        },
        3723562043: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaWebPage", forceLargeMedia: !!(flags & 1), forceSmallMedia: !!(flags & 2), manual: !!(flags & 8), safe: !!(flags & 16), webpage: r2.object() };
        },
        784356159: function(r2) {
          return { _: "messageMediaVenue", geo: r2.object(), title: r2.string(), address: r2.string(), provider: r2.string(), venueId: r2.string(), venueType: r2.string() };
        },
        4256272392: function(r2) {
          return { _: "messageMediaGame", game: r2.object() };
        },
        4138027219: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaInvoice", shippingAddressRequested: !!(flags & 2), test: !!(flags & 8), title: r2.string(), description: r2.string(), photo: flags & 1 ? r2.object() : void 0, receiptMsgId: flags & 4 ? r2.int() : void 0, currency: r2.string(), totalAmount: r2.long(), startParam: r2.string(), extendedMedia: flags & 16 ? r2.object() : void 0 };
        },
        3108030054: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaGeoLive", geo: r2.object(), heading: flags & 1 ? r2.int() : void 0, period: r2.int(), proximityNotificationRadius: flags & 2 ? r2.int() : void 0 };
        },
        1272375192: function(r2) {
          return { _: "messageMediaPoll", poll: r2.object(), results: r2.object() };
        },
        1065280907: function(r2) {
          return { _: "messageMediaDice", value: r2.int(), emoticon: r2.string() };
        },
        1758159491: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaStory", viaMention: !!(flags & 2), peer: r2.object(), id: r2.int(), story: flags & 1 ? r2.object() : void 0 };
        },
        2852600811: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaGiveaway", onlyNewSubscribers: !!(flags & 1), winnersAreVisible: !!(flags & 4), channels: r2.vector(r2.int53), countriesIso2: flags & 2 ? r2.vector(r2.string) : void 0, prizeDescription: flags & 8 ? r2.string() : void 0, quantity: r2.int(), months: flags & 16 ? r2.int() : void 0, stars: flags & 32 ? r2.long() : void 0, untilDate: r2.int() };
        },
        3467263649: function(r2) {
          var flags = r2.uint();
          return { _: "messageMediaGiveawayResults", onlyNewSubscribers: !!(flags & 1), refunded: !!(flags & 4), channelId: r2.long(), additionalPeersCount: flags & 8 ? r2.int() : void 0, launchMsgId: r2.int(), winnersCount: r2.int(), unclaimedCount: r2.int(), winners: r2.vector(r2.long), months: flags & 16 ? r2.int() : void 0, stars: flags & 32 ? r2.long() : void 0, prizeDescription: flags & 2 ? r2.string() : void 0, untilDate: r2.int() };
        },
        2827297937: function(r2) {
          return { _: "messageMediaPaidMedia", starsAmount: r2.long(), extendedMedia: r2.vector(r2.object) };
        },
        3064919984: function(r2) {
          return { _: "messageActionEmpty" };
        },
        3175599021: function(r2) {
          return { _: "messageActionChatCreate", title: r2.string(), users: r2.vector(r2.int53) };
        },
        3047280218: function(r2) {
          return { _: "messageActionChatEditTitle", title: r2.string() };
        },
        2144015272: function(r2) {
          return { _: "messageActionChatEditPhoto", photo: r2.object() };
        },
        2514746351: function(r2) {
          return { _: "messageActionChatDeletePhoto" };
        },
        365886720: function(r2) {
          return { _: "messageActionChatAddUser", users: r2.vector(r2.int53) };
        },
        2755604684: function(r2) {
          return { _: "messageActionChatDeleteUser", userId: r2.int53() };
        },
        51520707: function(r2) {
          return { _: "messageActionChatJoinedByLink", inviterId: r2.int53() };
        },
        2513611922: function(r2) {
          return { _: "messageActionChannelCreate", title: r2.string() };
        },
        3775102866: function(r2) {
          return { _: "messageActionChatMigrateTo", channelId: r2.int53() };
        },
        3929622761: function(r2) {
          return { _: "messageActionChannelMigrateFrom", title: r2.string(), chatId: r2.int53() };
        },
        2495428845: function(r2) {
          return { _: "messageActionPinMessage" };
        },
        2679813636: function(r2) {
          return { _: "messageActionHistoryClear" };
        },
        2460428406: function(r2) {
          return { _: "messageActionGameScore", gameId: r2.long(), score: r2.int() };
        },
        2402399015: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionPaymentSentMe", recurringInit: !!(flags & 4), recurringUsed: !!(flags & 8), currency: r2.string(), totalAmount: r2.long(), payload: r2.bytes(), info: flags & 1 ? r2.object() : void 0, shippingOptionId: flags & 2 ? r2.string() : void 0, charge: r2.object() };
        },
        2518040406: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionPaymentSent", recurringInit: !!(flags & 4), recurringUsed: !!(flags & 8), currency: r2.string(), totalAmount: r2.long(), invoiceSlug: flags & 1 ? r2.string() : void 0 };
        },
        2162236031: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionPhoneCall", video: !!(flags & 4), callId: r2.long(), reason: flags & 1 ? r2.object() : void 0, duration: flags & 2 ? r2.int() : void 0 };
        },
        1200788123: function(r2) {
          return { _: "messageActionScreenshotTaken" };
        },
        4209418070: function(r2) {
          return { _: "messageActionCustomAction", message: r2.string() };
        },
        3306608249: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionBotAllowed", attachMenu: !!(flags & 2), fromRequest: !!(flags & 8), domain: flags & 1 ? r2.string() : void 0, app: flags & 4 ? r2.object() : void 0 };
        },
        455635795: function(r2) {
          return { _: "messageActionSecureValuesSentMe", values: r2.vector(r2.object), credentials: r2.object() };
        },
        3646710100: function(r2) {
          return { _: "messageActionSecureValuesSent", types: r2.vector(r2.object) };
        },
        4092747638: function(r2) {
          return { _: "messageActionContactSignUp" };
        },
        2564871831: function(r2) {
          return { _: "messageActionGeoProximityReached", fromId: r2.object(), toId: r2.object(), distance: r2.int() };
        },
        2047704898: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionGroupCall", call: r2.object(), duration: flags & 1 ? r2.int() : void 0 };
        },
        1345295095: function(r2) {
          return { _: "messageActionInviteToGroupCall", call: r2.object(), users: r2.vector(r2.int53) };
        },
        1007897979: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionSetMessagesTTL", period: r2.int(), autoSettingFrom: flags & 1 ? r2.long() : void 0 };
        },
        3013637729: function(r2) {
          return { _: "messageActionGroupCallScheduled", call: r2.object(), scheduleDate: r2.int() };
        },
        2860016453: function(r2) {
          return { _: "messageActionSetChatTheme", emoticon: r2.string() };
        },
        3955008459: function(r2) {
          return { _: "messageActionChatJoinedByRequest" };
        },
        1205698681: function(r2) {
          return { _: "messageActionWebViewDataSentMe", text: r2.string(), data: r2.string() };
        },
        3032714421: function(r2) {
          return { _: "messageActionWebViewDataSent", text: r2.string() };
        },
        3359468268: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionGiftPremium", currency: r2.string(), amount: r2.long(), months: r2.int(), cryptoCurrency: flags & 1 ? r2.string() : void 0, cryptoAmount: flags & 1 ? r2.long() : void 0 };
        },
        228168278: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionTopicCreate", title: r2.string(), iconColor: r2.int(), iconEmojiId: flags & 1 ? r2.long() : void 0 };
        },
        3230943264: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionTopicEdit", title: flags & 1 ? r2.string() : void 0, iconEmojiId: flags & 2 ? r2.long() : void 0, closed: flags & 4 ? r2.boolean() : void 0, hidden: flags & 8 ? r2.boolean() : void 0 };
        },
        1474192222: function(r2) {
          return { _: "messageActionSuggestProfilePhoto", photo: r2.object() };
        },
        827428507: function(r2) {
          return { _: "messageActionRequestedPeer", buttonId: r2.int(), peers: r2.vector(r2.object) };
        },
        1348510708: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionSetChatWallPaper", same: !!(flags & 1), forBoth: !!(flags & 2), wallpaper: r2.object() };
        },
        1737240073: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionGiftCode", viaGiveaway: !!(flags & 1), unclaimed: !!(flags & 4), boostPeer: flags & 2 ? r2.object() : void 0, months: r2.int(), slug: r2.string(), currency: flags & 4 ? r2.string() : void 0, amount: flags & 4 ? r2.long() : void 0, cryptoCurrency: flags & 8 ? r2.string() : void 0, cryptoAmount: flags & 8 ? r2.long() : void 0 };
        },
        2819576292: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionGiveawayLaunch", stars: flags & 1 ? r2.long() : void 0 };
        },
        2279797077: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionGiveawayResults", stars: !!(flags & 1), winnersCount: r2.int(), unclaimedCount: r2.int() };
        },
        3422726765: function(r2) {
          return { _: "messageActionBoostApply", boosts: r2.int() };
        },
        2477987912: function(r2) {
          return { _: "messageActionRequestedPeerSentMe", buttonId: r2.int(), peers: r2.vector(r2.object) };
        },
        1102307842: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionPaymentRefunded", peer: r2.object(), currency: r2.string(), totalAmount: r2.long(), payload: flags & 1 ? r2.bytes() : void 0, charge: r2.object() };
        },
        1171632161: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionGiftStars", currency: r2.string(), amount: r2.long(), stars: r2.long(), cryptoCurrency: flags & 1 ? r2.string() : void 0, cryptoAmount: flags & 1 ? r2.long() : void 0, transactionId: flags & 2 ? r2.string() : void 0 };
        },
        2953594786: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionPrizeStars", unclaimed: !!(flags & 1), stars: r2.long(), transactionId: r2.string(), boostPeer: r2.object(), giveawayMsgId: r2.int() };
        },
        2612260676: function(r2) {
          var flags = r2.uint();
          return { _: "messageActionStarGift", nameHidden: !!(flags & 1), saved: !!(flags & 4), converted: !!(flags & 8), gift: r2.object(), message: flags & 2 ? r2.object() : void 0, convertStars: r2.long() };
        },
        3582593222: function(r2) {
          var flags = r2.uint();
          return { _: "dialog", pinned: !!(flags & 4), unreadMark: !!(flags & 8), viewForumAsMessages: !!(flags & 64), peer: r2.object(), topMessage: r2.int(), readInboxMaxId: r2.int(), readOutboxMaxId: r2.int(), unreadCount: r2.int(), unreadMentionsCount: r2.int(), unreadReactionsCount: r2.int(), notifySettings: r2.object(), pts: flags & 1 ? r2.int() : void 0, draft: flags & 2 ? r2.object() : void 0, folderId: flags & 16 ? r2.int() : void 0, ttlPeriod: flags & 32 ? r2.int() : void 0 };
        },
        1908216652: function(r2) {
          var flags = r2.uint();
          return { _: "dialogFolder", pinned: !!(flags & 4), folder: r2.object(), peer: r2.object(), topMessage: r2.int(), unreadMutedPeersCount: r2.int(), unreadUnmutedPeersCount: r2.int(), unreadMutedMessagesCount: r2.int(), unreadUnmutedMessagesCount: r2.int() };
        },
        590459437: function(r2) {
          return { _: "photoEmpty", id: r2.long() };
        },
        4212750949: function(r2) {
          var flags = r2.uint();
          return { _: "photo", hasStickers: !!(flags & 1), id: r2.long(), accessHash: r2.long(), fileReference: r2.bytes(), date: r2.int(), sizes: r2.vector(r2.object), videoSizes: flags & 2 ? r2.vector(r2.object) : void 0, dcId: r2.int() };
        },
        236446268: function(r2) {
          return { _: "photoSizeEmpty", type: r2.string() };
        },
        1976012384: function(r2) {
          return { _: "photoSize", type: r2.string(), w: r2.int(), h: r2.int(), size: r2.int() };
        },
        35527382: function(r2) {
          return { _: "photoCachedSize", type: r2.string(), w: r2.int(), h: r2.int(), bytes: r2.bytes() };
        },
        3769678894: function(r2) {
          return { _: "photoStrippedSize", type: r2.string(), bytes: r2.bytes() };
        },
        4198431637: function(r2) {
          return { _: "photoSizeProgressive", type: r2.string(), w: r2.int(), h: r2.int(), sizes: r2.vector(r2.int) };
        },
        3626061121: function(r2) {
          return { _: "photoPathSize", type: r2.string(), bytes: r2.bytes() };
        },
        286776671: function(r2) {
          return { _: "geoPointEmpty" };
        },
        2997024355: function(r2) {
          var flags = r2.uint();
          return { _: "geoPoint", long: r2.double(), lat: r2.double(), accessHash: r2.long(), accuracyRadius: flags & 1 ? r2.int() : void 0 };
        },
        1577067778: function(r2) {
          var flags = r2.uint();
          return { _: "auth.sentCode", type: r2.object(), phoneCodeHash: r2.string(), nextType: flags & 2 ? r2.object() : void 0, timeout: flags & 4 ? r2.int() : void 0 };
        },
        596704836: function(r2) {
          return { _: "auth.sentCodeSuccess", authorization: r2.object() };
        },
        782418132: function(r2) {
          var flags = r2.uint();
          return { _: "auth.authorization", setupPasswordRequired: !!(flags & 2), otherwiseReloginDays: flags & 2 ? r2.int() : void 0, tmpSessions: flags & 1 ? r2.int() : void 0, futureAuthToken: flags & 4 ? r2.bytes() : void 0, user: r2.object() };
        },
        1148485274: function(r2) {
          var flags = r2.uint();
          return { _: "auth.authorizationSignUpRequired", termsOfService: flags & 1 ? r2.object() : void 0 };
        },
        3023364792: function(r2) {
          return { _: "auth.exportedAuthorization", id: r2.long(), bytes: r2.bytes() };
        },
        3099351820: function(r2) {
          return { _: "inputNotifyPeer", peer: r2.object() };
        },
        423314455: function(r2) {
          return { _: "inputNotifyUsers" };
        },
        1251338318: function(r2) {
          return { _: "inputNotifyChats" };
        },
        2983951486: function(r2) {
          return { _: "inputNotifyBroadcasts" };
        },
        1548122514: function(r2) {
          return { _: "inputNotifyForumTopic", peer: r2.object(), topMsgId: r2.int() };
        },
        3402328802: function(r2) {
          var flags = r2.uint();
          return { _: "inputPeerNotifySettings", showPreviews: flags & 1 ? r2.boolean() : void 0, silent: flags & 2 ? r2.boolean() : void 0, muteUntil: flags & 4 ? r2.int() : void 0, sound: flags & 8 ? r2.object() : void 0, storiesMuted: flags & 64 ? r2.boolean() : void 0, storiesHideSender: flags & 128 ? r2.boolean() : void 0, storiesSound: flags & 256 ? r2.object() : void 0 };
        },
        2573347852: function(r2) {
          var flags = r2.uint();
          return { _: "peerNotifySettings", showPreviews: flags & 1 ? r2.boolean() : void 0, silent: flags & 2 ? r2.boolean() : void 0, muteUntil: flags & 4 ? r2.int() : void 0, iosSound: flags & 8 ? r2.object() : void 0, androidSound: flags & 16 ? r2.object() : void 0, otherSound: flags & 32 ? r2.object() : void 0, storiesMuted: flags & 64 ? r2.boolean() : void 0, storiesHideSender: flags & 128 ? r2.boolean() : void 0, storiesIosSound: flags & 256 ? r2.object() : void 0, storiesAndroidSound: flags & 512 ? r2.object() : void 0, storiesOtherSound: flags & 1024 ? r2.object() : void 0 };
        },
        2899733598: function(r2) {
          var flags = r2.uint();
          return { _: "peerSettings", reportSpam: !!(flags & 1), addContact: !!(flags & 2), blockContact: !!(flags & 4), shareContact: !!(flags & 8), needContactsException: !!(flags & 16), reportGeo: !!(flags & 32), autoarchived: !!(flags & 128), inviteMembers: !!(flags & 256), requestChatBroadcast: !!(flags & 1024), businessBotPaused: !!(flags & 2048), businessBotCanReply: !!(flags & 4096), geoDistance: flags & 64 ? r2.int() : void 0, requestChatTitle: flags & 512 ? r2.string() : void 0, requestChatDate: flags & 512 ? r2.int() : void 0, businessBotId: flags & 8192 ? r2.int53() : void 0, businessBotManageUrl: flags & 8192 ? r2.string() : void 0 };
        },
        2755118061: function(r2) {
          var id2 = r2.long(), flags = r2.uint();
          return { _: "wallPaper", id: id2, creator: !!(flags & 1), default: !!(flags & 2), pattern: !!(flags & 8), dark: !!(flags & 16), accessHash: r2.long(), slug: r2.string(), document: r2.object(), settings: flags & 4 ? r2.object() : void 0 };
        },
        3766501654: function(r2) {
          var id2 = r2.long(), flags = r2.uint();
          return { _: "wallPaperNoFile", id: id2, default: !!(flags & 2), dark: !!(flags & 16), settings: flags & 4 ? r2.object() : void 0 };
        },
        1490799288: function(r2) {
          return { _: "inputReportReasonSpam" };
        },
        505595789: function(r2) {
          return { _: "inputReportReasonViolence" };
        },
        777640226: function(r2) {
          return { _: "inputReportReasonPornography" };
        },
        2918469347: function(r2) {
          return { _: "inputReportReasonChildAbuse" };
        },
        3252986545: function(r2) {
          return { _: "inputReportReasonOther" };
        },
        2609510714: function(r2) {
          return { _: "inputReportReasonCopyright" };
        },
        3688169197: function(r2) {
          return { _: "inputReportReasonGeoIrrelevant" };
        },
        4124956391: function(r2) {
          return { _: "inputReportReasonFake" };
        },
        177124030: function(r2) {
          return { _: "inputReportReasonIllegalDrugs" };
        },
        2663876157: function(r2) {
          return { _: "inputReportReasonPersonalDetails" };
        },
        525919081: function(r2) {
          var flags = r2.uint(), flags2 = r2.uint();
          return { _: "userFull", blocked: !!(flags & 1), phoneCallsAvailable: !!(flags & 16), phoneCallsPrivate: !!(flags & 32), canPinMessage: !!(flags & 128), hasScheduled: !!(flags & 4096), videoCallsAvailable: !!(flags & 8192), voiceMessagesForbidden: !!(flags & 1048576), translationsDisabled: !!(flags & 8388608), storiesPinnedAvailable: !!(flags & 67108864), blockedMyStoriesFrom: !!(flags & 134217728), wallpaperOverridden: !!(flags & 268435456), contactRequirePremium: !!(flags & 536870912), readDatesPrivate: !!(flags & 1073741824), sponsoredEnabled: !!(flags2 & 128), id: r2.int53(), about: flags & 2 ? r2.string() : void 0, settings: r2.object(), personalPhoto: flags & 2097152 ? r2.object() : void 0, profilePhoto: flags & 4 ? r2.object() : void 0, fallbackPhoto: flags & 4194304 ? r2.object() : void 0, notifySettings: r2.object(), botInfo: flags & 8 ? r2.object() : void 0, pinnedMsgId: flags & 64 ? r2.int() : void 0, commonChatsCount: r2.int(), folderId: flags & 2048 ? r2.int() : void 0, ttlPeriod: flags & 16384 ? r2.int() : void 0, themeEmoticon: flags & 32768 ? r2.string() : void 0, privateForwardName: flags & 65536 ? r2.string() : void 0, botGroupAdminRights: flags & 131072 ? r2.object() : void 0, botBroadcastAdminRights: flags & 262144 ? r2.object() : void 0, premiumGifts: flags & 524288 ? r2.vector(r2.object) : void 0, wallpaper: flags & 16777216 ? r2.object() : void 0, stories: flags & 33554432 ? r2.object() : void 0, businessWorkHours: flags2 & 1 ? r2.object() : void 0, businessLocation: flags2 & 2 ? r2.object() : void 0, businessGreetingMessage: flags2 & 4 ? r2.object() : void 0, businessAwayMessage: flags2 & 8 ? r2.object() : void 0, businessIntro: flags2 & 16 ? r2.object() : void 0, birthday: flags2 & 32 ? r2.object() : void 0, personalChannelId: flags2 & 64 ? r2.int53() : void 0, personalChannelMessage: flags2 & 64 ? r2.int() : void 0, stargiftsCount: flags2 & 256 ? r2.int() : void 0 };
        },
        341499403: function(r2) {
          return { _: "contact", userId: r2.int53(), mutual: r2.boolean() };
        },
        3242081360: function(r2) {
          return { _: "importedContact", userId: r2.int53(), clientId: r2.long() };
        },
        383348795: function(r2) {
          return { _: "contactStatus", userId: r2.int53(), status: r2.object() };
        },
        3075189202: function(r2) {
          return { _: "contacts.contactsNotModified" };
        },
        3941105218: function(r2) {
          return { _: "contacts.contacts", contacts: r2.vector(r2.object), savedCount: r2.int(), users: r2.vector(r2.object) };
        },
        2010127419: function(r2) {
          return { _: "contacts.importedContacts", imported: r2.vector(r2.object), popularInvites: r2.vector(r2.object), retryContacts: r2.vector(r2.long), users: r2.vector(r2.object) };
        },
        182326673: function(r2) {
          return { _: "contacts.blocked", blocked: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3781575060: function(r2) {
          return { _: "contacts.blockedSlice", count: r2.int(), blocked: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        364538944: function(r2) {
          return { _: "messages.dialogs", dialogs: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1910543603: function(r2) {
          return { _: "messages.dialogsSlice", count: r2.int(), dialogs: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        4041467286: function(r2) {
          return { _: "messages.dialogsNotModified", count: r2.int() };
        },
        2356252295: function(r2) {
          return { _: "messages.messages", messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        978610270: function(r2) {
          var flags = r2.uint();
          return { _: "messages.messagesSlice", inexact: !!(flags & 2), count: r2.int(), nextRate: flags & 1 ? r2.int() : void 0, offsetIdOffset: flags & 4 ? r2.int() : void 0, messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3346446926: function(r2) {
          var flags = r2.uint();
          return { _: "messages.channelMessages", inexact: !!(flags & 2), pts: r2.int(), count: r2.int(), offsetIdOffset: flags & 4 ? r2.int() : void 0, messages: r2.vector(r2.object), topics: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1951620897: function(r2) {
          return { _: "messages.messagesNotModified", count: r2.int() };
        },
        1694474197: function(r2) {
          return { _: "messages.chats", chats: r2.vector(r2.object) };
        },
        2631405892: function(r2) {
          return { _: "messages.chatsSlice", count: r2.int(), chats: r2.vector(r2.object) };
        },
        3856126364: function(r2) {
          return { _: "messages.chatFull", fullChat: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3025955281: function(r2) {
          return { _: "messages.affectedHistory", pts: r2.int(), ptsCount: r2.int(), offset: r2.int() };
        },
        1474492012: function(r2) {
          return { _: "inputMessagesFilterEmpty" };
        },
        2517214492: function(r2) {
          return { _: "inputMessagesFilterPhotos" };
        },
        2680163941: function(r2) {
          return { _: "inputMessagesFilterVideo" };
        },
        1458172132: function(r2) {
          return { _: "inputMessagesFilterPhotoVideo" };
        },
        2665345416: function(r2) {
          return { _: "inputMessagesFilterDocument" };
        },
        2129714567: function(r2) {
          return { _: "inputMessagesFilterUrl" };
        },
        4291323271: function(r2) {
          return { _: "inputMessagesFilterGif" };
        },
        1358283666: function(r2) {
          return { _: "inputMessagesFilterVoice" };
        },
        928101534: function(r2) {
          return { _: "inputMessagesFilterMusic" };
        },
        975236280: function(r2) {
          return { _: "inputMessagesFilterChatPhotos" };
        },
        2160695144: function(r2) {
          var flags = r2.uint();
          return { _: "inputMessagesFilterPhoneCalls", missed: !!(flags & 1) };
        },
        2054952868: function(r2) {
          return { _: "inputMessagesFilterRoundVoice" };
        },
        3041516115: function(r2) {
          return { _: "inputMessagesFilterRoundVideo" };
        },
        3254314650: function(r2) {
          return { _: "inputMessagesFilterMyMentions" };
        },
        3875695885: function(r2) {
          return { _: "inputMessagesFilterGeo" };
        },
        3764575107: function(r2) {
          return { _: "inputMessagesFilterContacts" };
        },
        464520273: function(r2) {
          return { _: "inputMessagesFilterPinned" };
        },
        522914557: function(r2) {
          return { _: "updateNewMessage", message: r2.object(), pts: r2.int(), ptsCount: r2.int() };
        },
        1318109142: function(r2) {
          return { _: "updateMessageID", id: r2.int(), randomId: r2.long() };
        },
        2718806245: function(r2) {
          return { _: "updateDeleteMessages", messages: r2.vector(r2.int), pts: r2.int(), ptsCount: r2.int() };
        },
        3223225727: function(r2) {
          return { _: "updateUserTyping", userId: r2.int53(), action: r2.object() };
        },
        2202565360: function(r2) {
          return { _: "updateChatUserTyping", chatId: r2.int53(), fromId: r2.object(), action: r2.object() };
        },
        125178264: function(r2) {
          return { _: "updateChatParticipants", participants: r2.object() };
        },
        3854432478: function(r2) {
          return { _: "updateUserStatus", userId: r2.int53(), status: r2.object() };
        },
        2810480932: function(r2) {
          return { _: "updateUserName", userId: r2.int53(), firstName: r2.string(), lastName: r2.string(), usernames: r2.vector(r2.object) };
        },
        2303831023: function(r2) {
          var flags = r2.uint();
          return { _: "updateNewAuthorization", unconfirmed: !!(flags & 1), hash: r2.long(), date: flags & 1 ? r2.int() : void 0, device: flags & 1 ? r2.string() : void 0, location: flags & 1 ? r2.string() : void 0 };
        },
        314359194: function(r2) {
          return { _: "updateNewEncryptedMessage", message: r2.object(), qts: r2.int() };
        },
        386986326: function(r2) {
          return { _: "updateEncryptedChatTyping", chatId: r2.int() };
        },
        3030575245: function(r2) {
          return { _: "updateEncryption", chat: r2.object(), date: r2.int() };
        },
        956179895: function(r2) {
          return { _: "updateEncryptedMessagesRead", chatId: r2.int(), maxDate: r2.int(), date: r2.int() };
        },
        1037718609: function(r2) {
          return { _: "updateChatParticipantAdd", chatId: r2.int53(), userId: r2.int53(), inviterId: r2.int53(), date: r2.int(), version: r2.int() };
        },
        3811523959: function(r2) {
          return { _: "updateChatParticipantDelete", chatId: r2.int53(), userId: r2.int53(), version: r2.int() };
        },
        2388564083: function(r2) {
          return { _: "updateDcOptions", dcOptions: r2.vector(r2.object) };
        },
        3200411887: function(r2) {
          return { _: "updateNotifySettings", peer: r2.object(), notifySettings: r2.object() };
        },
        3957614617: function(r2) {
          var flags = r2.uint();
          return { _: "updateServiceNotification", popup: !!(flags & 1), invertMedia: !!(flags & 4), inboxDate: flags & 2 ? r2.int() : void 0, type: r2.string(), message: r2.string(), media: r2.object(), entities: r2.vector(r2.object) };
        },
        3996854058: function(r2) {
          return { _: "updatePrivacy", key: r2.object(), rules: r2.vector(r2.object) };
        },
        88680979: function(r2) {
          return { _: "updateUserPhone", userId: r2.int53(), phone: r2.string() };
        },
        2627162079: function(r2) {
          var flags = r2.uint();
          return { _: "updateReadHistoryInbox", folderId: flags & 1 ? r2.int() : void 0, peer: r2.object(), maxId: r2.int(), stillUnreadCount: r2.int(), pts: r2.int(), ptsCount: r2.int() };
        },
        791617983: function(r2) {
          return { _: "updateReadHistoryOutbox", peer: r2.object(), maxId: r2.int(), pts: r2.int(), ptsCount: r2.int() };
        },
        2139689491: function(r2) {
          return { _: "updateWebPage", webpage: r2.object(), pts: r2.int(), ptsCount: r2.int() };
        },
        4163006849: function(r2) {
          var flags = r2.uint();
          return { _: "updateReadMessagesContents", messages: r2.vector(r2.int), pts: r2.int(), ptsCount: r2.int(), date: flags & 1 ? r2.int() : void 0 };
        },
        277713951: function(r2) {
          var flags = r2.uint();
          return { _: "updateChannelTooLong", channelId: r2.int53(), pts: flags & 1 ? r2.int() : void 0 };
        },
        1666927625: function(r2) {
          return { _: "updateChannel", channelId: r2.int53() };
        },
        1656358105: function(r2) {
          return { _: "updateNewChannelMessage", message: r2.object(), pts: r2.int(), ptsCount: r2.int() };
        },
        2452516368: function(r2) {
          var flags = r2.uint();
          return { _: "updateReadChannelInbox", folderId: flags & 1 ? r2.int() : void 0, channelId: r2.int53(), maxId: r2.int(), stillUnreadCount: r2.int(), pts: r2.int() };
        },
        3274529554: function(r2) {
          return { _: "updateDeleteChannelMessages", channelId: r2.int53(), messages: r2.vector(r2.int), pts: r2.int(), ptsCount: r2.int() };
        },
        4062620680: function(r2) {
          return { _: "updateChannelMessageViews", channelId: r2.int53(), id: r2.int(), views: r2.int() };
        },
        3620364706: function(r2) {
          return { _: "updateChatParticipantAdmin", chatId: r2.int53(), userId: r2.int53(), isAdmin: r2.boolean(), version: r2.int() };
        },
        1753886890: function(r2) {
          return { _: "updateNewStickerSet", stickerset: r2.object() };
        },
        196268545: function(r2) {
          var flags = r2.uint();
          return { _: "updateStickerSetsOrder", masks: !!(flags & 1), emojis: !!(flags & 2), order: r2.vector(r2.long) };
        },
        834816008: function(r2) {
          var flags = r2.uint();
          return { _: "updateStickerSets", masks: !!(flags & 1), emojis: !!(flags & 2) };
        },
        2473931806: function(r2) {
          return { _: "updateSavedGifs" };
        },
        1232025500: function(r2) {
          var flags = r2.uint();
          return { _: "updateBotInlineQuery", queryId: r2.long(), userId: r2.int53(), query: r2.string(), geo: flags & 1 ? r2.object() : void 0, peerType: flags & 2 ? r2.object() : void 0, offset: r2.string() };
        },
        317794823: function(r2) {
          var flags = r2.uint();
          return { _: "updateBotInlineSend", userId: r2.int53(), query: r2.string(), geo: flags & 1 ? r2.object() : void 0, id: r2.string(), msgId: flags & 2 ? r2.object() : void 0 };
        },
        457133559: function(r2) {
          return { _: "updateEditChannelMessage", message: r2.object(), pts: r2.int(), ptsCount: r2.int() };
        },
        3117401229: function(r2) {
          var flags = r2.uint();
          return { _: "updateBotCallbackQuery", queryId: r2.long(), userId: r2.int53(), peer: r2.object(), msgId: r2.int(), chatInstance: r2.long(), data: flags & 1 ? r2.bytes() : void 0, gameShortName: flags & 2 ? r2.string() : void 0 };
        },
        3825430691: function(r2) {
          return { _: "updateEditMessage", message: r2.object(), pts: r2.int(), ptsCount: r2.int() };
        },
        1763610706: function(r2) {
          var flags = r2.uint();
          return { _: "updateInlineBotCallbackQuery", queryId: r2.long(), userId: r2.int53(), msgId: r2.object(), chatInstance: r2.long(), data: flags & 1 ? r2.bytes() : void 0, gameShortName: flags & 2 ? r2.string() : void 0 };
        },
        3076495785: function(r2) {
          return { _: "updateReadChannelOutbox", channelId: r2.int53(), maxId: r2.int() };
        },
        457829485: function(r2) {
          var flags = r2.uint();
          return { _: "updateDraftMessage", peer: r2.object(), topMsgId: flags & 1 ? r2.int() : void 0, draft: r2.object() };
        },
        1461528386: function(r2) {
          return { _: "updateReadFeaturedStickers" };
        },
        2588027936: function(r2) {
          return { _: "updateRecentStickers" };
        },
        2720652550: function(r2) {
          return { _: "updateConfig" };
        },
        861169551: function(r2) {
          return { _: "updatePtsChanged" };
        },
        791390623: function(r2) {
          return { _: "updateChannelWebPage", channelId: r2.int53(), webpage: r2.object(), pts: r2.int(), ptsCount: r2.int() };
        },
        1852826908: function(r2) {
          var flags = r2.uint();
          return { _: "updateDialogPinned", pinned: !!(flags & 1), folderId: flags & 2 ? r2.int() : void 0, peer: r2.object() };
        },
        4195302562: function(r2) {
          var flags = r2.uint();
          return { _: "updatePinnedDialogs", folderId: flags & 2 ? r2.int() : void 0, order: flags & 1 ? r2.vector(r2.object) : void 0 };
        },
        2199371971: function(r2) {
          return { _: "updateBotWebhookJSON", data: r2.object() };
        },
        2610053286: function(r2) {
          return { _: "updateBotWebhookJSONQuery", queryId: r2.long(), data: r2.object(), timeout: r2.int() };
        },
        3048144253: function(r2) {
          return { _: "updateBotShippingQuery", queryId: r2.long(), userId: r2.int53(), payload: r2.bytes(), shippingAddress: r2.object() };
        },
        2359990934: function(r2) {
          var flags = r2.uint();
          return { _: "updateBotPrecheckoutQuery", queryId: r2.long(), userId: r2.int53(), payload: r2.bytes(), info: flags & 1 ? r2.object() : void 0, shippingOptionId: flags & 2 ? r2.string() : void 0, currency: r2.string(), totalAmount: r2.long() };
        },
        2869914398: function(r2) {
          return { _: "updatePhoneCall", phoneCall: r2.object() };
        },
        1180041828: function(r2) {
          return { _: "updateLangPackTooLong", langCode: r2.string() };
        },
        1442983757: function(r2) {
          return { _: "updateLangPack", difference: r2.object() };
        },
        3843135853: function(r2) {
          return { _: "updateFavedStickers" };
        },
        3928556893: function(r2) {
          var flags = r2.uint();
          return { _: "updateChannelReadMessagesContents", channelId: r2.int53(), topMsgId: flags & 1 ? r2.int() : void 0, messages: r2.vector(r2.int) };
        },
        1887741886: function(r2) {
          return { _: "updateContactsReset" };
        },
        2990524056: function(r2) {
          return { _: "updateChannelAvailableMessages", channelId: r2.int53(), availableMinId: r2.int() };
        },
        3781450179: function(r2) {
          var flags = r2.uint();
          return { _: "updateDialogUnreadMark", unread: !!(flags & 1), peer: r2.object() };
        },
        2896258427: function(r2) {
          var flags = r2.uint();
          return { _: "updateMessagePoll", pollId: r2.long(), poll: flags & 1 ? r2.object() : void 0, results: r2.object() };
        },
        1421875280: function(r2) {
          return { _: "updateChatDefaultBannedRights", peer: r2.object(), defaultBannedRights: r2.object(), version: r2.int() };
        },
        422972864: function(r2) {
          return { _: "updateFolderPeers", folderPeers: r2.vector(r2.object), pts: r2.int(), ptsCount: r2.int() };
        },
        1786671974: function(r2) {
          return { _: "updatePeerSettings", peer: r2.object(), settings: r2.object() };
        },
        3031420848: function(r2) {
          return { _: "updatePeerLocated", peers: r2.vector(r2.object) };
        },
        967122427: function(r2) {
          return { _: "updateNewScheduledMessage", message: r2.object() };
        },
        2424728814: function(r2) {
          return { _: "updateDeleteScheduledMessages", peer: r2.object(), messages: r2.vector(r2.int) };
        },
        2182544291: function(r2) {
          return { _: "updateTheme", theme: r2.object() };
        },
        2267003193: function(r2) {
          return { _: "updateGeoLiveViewed", peer: r2.object(), msgId: r2.int() };
        },
        1448076945: function(r2) {
          return { _: "updateLoginToken" };
        },
        619974263: function(r2) {
          return { _: "updateMessagePollVote", pollId: r2.long(), peer: r2.object(), options: r2.vector(r2.bytes), qts: r2.int() };
        },
        654302845: function(r2) {
          var flags = r2.uint();
          return { _: "updateDialogFilter", id: r2.int(), filter: flags & 1 ? r2.object() : void 0 };
        },
        2782339333: function(r2) {
          return { _: "updateDialogFilterOrder", order: r2.vector(r2.int) };
        },
        889491791: function(r2) {
          return { _: "updateDialogFilters" };
        },
        643940105: function(r2) {
          return { _: "updatePhoneCallSignalingData", phoneCallId: r2.long(), data: r2.bytes() };
        },
        3533318132: function(r2) {
          return { _: "updateChannelMessageForwards", channelId: r2.int53(), id: r2.int(), forwards: r2.int() };
        },
        3601962310: function(r2) {
          var flags = r2.uint();
          return { _: "updateReadChannelDiscussionInbox", channelId: r2.int53(), topMsgId: r2.int(), readMaxId: r2.int(), broadcastId: flags & 1 ? r2.int53() : void 0, broadcastPost: flags & 1 ? r2.int() : void 0 };
        },
        1767677564: function(r2) {
          return { _: "updateReadChannelDiscussionOutbox", channelId: r2.int53(), topMsgId: r2.int(), readMaxId: r2.int() };
        },
        3957356370: function(r2) {
          var flags = r2.uint();
          return { _: "updatePeerBlocked", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), peerId: r2.object() };
        },
        2357774627: function(r2) {
          var flags = r2.uint();
          return { _: "updateChannelUserTyping", channelId: r2.int53(), topMsgId: flags & 1 ? r2.int() : void 0, fromId: r2.object(), action: r2.object() };
        },
        3984976565: function(r2) {
          var flags = r2.uint();
          return { _: "updatePinnedMessages", pinned: !!(flags & 1), peer: r2.object(), messages: r2.vector(r2.int), pts: r2.int(), ptsCount: r2.int() };
        },
        1538885128: function(r2) {
          var flags = r2.uint();
          return { _: "updatePinnedChannelMessages", pinned: !!(flags & 1), channelId: r2.int53(), messages: r2.vector(r2.int), pts: r2.int(), ptsCount: r2.int() };
        },
        4170869326: function(r2) {
          return { _: "updateChat", chatId: r2.int53() };
        },
        4075543374: function(r2) {
          return { _: "updateGroupCallParticipants", call: r2.object(), participants: r2.vector(r2.object), version: r2.int() };
        },
        347227392: function(r2) {
          return { _: "updateGroupCall", chatId: r2.int53(), call: r2.object() };
        },
        3147544997: function(r2) {
          var flags = r2.uint();
          return { _: "updatePeerHistoryTTL", peer: r2.object(), ttlPeriod: flags & 1 ? r2.int() : void 0 };
        },
        3498534458: function(r2) {
          var flags = r2.uint();
          return { _: "updateChatParticipant", chatId: r2.int53(), date: r2.int(), actorId: r2.int53(), userId: r2.int53(), prevParticipant: flags & 1 ? r2.object() : void 0, newParticipant: flags & 2 ? r2.object() : void 0, invite: flags & 4 ? r2.object() : void 0, qts: r2.int() };
        },
        2556246715: function(r2) {
          var flags = r2.uint();
          return { _: "updateChannelParticipant", viaChatlist: !!(flags & 8), channelId: r2.int53(), date: r2.int(), actorId: r2.int53(), userId: r2.int53(), prevParticipant: flags & 1 ? r2.object() : void 0, newParticipant: flags & 2 ? r2.object() : void 0, invite: flags & 4 ? r2.object() : void 0, qts: r2.int() };
        },
        3297184329: function(r2) {
          return { _: "updateBotStopped", userId: r2.int53(), date: r2.int(), stopped: r2.boolean(), qts: r2.int() };
        },
        192428418: function(r2) {
          var flags = r2.uint();
          return { _: "updateGroupCallConnection", presentation: !!(flags & 1), params: r2.object() };
        },
        1299263278: function(r2) {
          return { _: "updateBotCommands", peer: r2.object(), botId: r2.int53(), commands: r2.vector(r2.object) };
        },
        1885586395: function(r2) {
          return { _: "updatePendingJoinRequests", peer: r2.object(), requestsPending: r2.int(), recentRequesters: r2.vector(r2.int53) };
        },
        299870598: function(r2) {
          return { _: "updateBotChatInviteRequester", peer: r2.object(), date: r2.int(), userId: r2.int53(), about: r2.string(), invite: r2.object(), qts: r2.int() };
        },
        1578843320: function(r2) {
          var flags = r2.uint();
          return { _: "updateMessageReactions", peer: r2.object(), msgId: r2.int(), topMsgId: flags & 1 ? r2.int() : void 0, reactions: r2.object() };
        },
        397910539: function(r2) {
          return { _: "updateAttachMenuBots" };
        },
        361936797: function(r2) {
          return { _: "updateWebViewResultSent", queryId: r2.long() };
        },
        347625491: function(r2) {
          return { _: "updateBotMenuButton", botId: r2.int53(), button: r2.object() };
        },
        1960361625: function(r2) {
          return { _: "updateSavedRingtones" };
        },
        8703322: function(r2) {
          var flags = r2.uint();
          return { _: "updateTranscribedAudio", pending: !!(flags & 1), peer: r2.object(), msgId: r2.int(), transcriptionId: r2.long(), text: r2.string() };
        },
        4216080748: function(r2) {
          return { _: "updateReadFeaturedEmojiStickers" };
        },
        674706841: function(r2) {
          return { _: "updateUserEmojiStatus", userId: r2.int53(), emojiStatus: r2.object() };
        },
        821314523: function(r2) {
          return { _: "updateRecentEmojiStatuses" };
        },
        1870160884: function(r2) {
          return { _: "updateRecentReactions" };
        },
        2264715141: function(r2) {
          var flags = r2.uint();
          return { _: "updateMoveStickerSetToTop", masks: !!(flags & 1), emojis: !!(flags & 2), stickerset: r2.long() };
        },
        3584300836: function(r2) {
          return { _: "updateMessageExtendedMedia", peer: r2.object(), msgId: r2.int(), extendedMedia: r2.vector(r2.object) };
        },
        422509539: function(r2) {
          var flags = r2.uint();
          return { _: "updateChannelPinnedTopic", pinned: !!(flags & 1), channelId: r2.int53(), topicId: r2.int() };
        },
        4263085570: function(r2) {
          var flags = r2.uint();
          return { _: "updateChannelPinnedTopics", channelId: r2.int53(), order: flags & 1 ? r2.vector(r2.int) : void 0 };
        },
        542282808: function(r2) {
          return { _: "updateUser", userId: r2.int53() };
        },
        3959795863: function(r2) {
          return { _: "updateAutoSaveSettings" };
        },
        1974712216: function(r2) {
          return { _: "updateStory", peer: r2.object(), story: r2.object() };
        },
        4149121835: function(r2) {
          return { _: "updateReadStories", peer: r2.object(), maxId: r2.int() };
        },
        468923833: function(r2) {
          return { _: "updateStoryID", id: r2.int(), randomId: r2.long() };
        },
        738741697: function(r2) {
          return { _: "updateStoriesStealthMode", stealthMode: r2.object() };
        },
        2103604867: function(r2) {
          return { _: "updateSentStoryReaction", peer: r2.object(), storyId: r2.int(), reaction: r2.object() };
        },
        2421019804: function(r2) {
          return { _: "updateBotChatBoost", peer: r2.object(), boost: r2.object(), qts: r2.int() };
        },
        129403168: function(r2) {
          return { _: "updateChannelViewForumAsMessages", channelId: r2.int53(), enabled: r2.boolean() };
        },
        2923368477: function(r2) {
          var flags = r2.uint();
          return { _: "updatePeerWallpaper", wallpaperOverridden: !!(flags & 2), peer: r2.object(), wallpaper: flags & 1 ? r2.object() : void 0 };
        },
        2887898062: function(r2) {
          return { _: "updateBotMessageReaction", peer: r2.object(), msgId: r2.int(), date: r2.int(), actor: r2.object(), oldReactions: r2.vector(r2.object), newReactions: r2.vector(r2.object), qts: r2.int() };
        },
        164329305: function(r2) {
          return { _: "updateBotMessageReactions", peer: r2.object(), msgId: r2.int(), date: r2.int(), reactions: r2.vector(r2.object), qts: r2.int() };
        },
        2930744948: function(r2) {
          var flags = r2.uint();
          return { _: "updateSavedDialogPinned", pinned: !!(flags & 1), peer: r2.object() };
        },
        1751942566: function(r2) {
          var flags = r2.uint();
          return { _: "updatePinnedSavedDialogs", order: flags & 1 ? r2.vector(r2.object) : void 0 };
        },
        969307186: function(r2) {
          return { _: "updateSavedReactionTags" };
        },
        4049758676: function(r2) {
          return { _: "updateSmsJob", jobId: r2.string() };
        },
        4182182578: function(r2) {
          return { _: "updateQuickReplies", quickReplies: r2.vector(r2.object) };
        },
        4114458391: function(r2) {
          return { _: "updateNewQuickReply", quickReply: r2.object() };
        },
        1407644140: function(r2) {
          return { _: "updateDeleteQuickReply", shortcutId: r2.int() };
        },
        1040518415: function(r2) {
          return { _: "updateQuickReplyMessage", message: r2.object() };
        },
        1450174413: function(r2) {
          return { _: "updateDeleteQuickReplyMessages", shortcutId: r2.int(), messages: r2.vector(r2.int) };
        },
        2330315130: function(r2) {
          return { _: "updateBotBusinessConnect", connection: r2.object(), qts: r2.int() };
        },
        2648388732: function(r2) {
          var flags = r2.uint();
          return { _: "updateBotNewBusinessMessage", connectionId: r2.string(), message: r2.object(), replyToMessage: flags & 1 ? r2.object() : void 0, qts: r2.int() };
        },
        132077692: function(r2) {
          var flags = r2.uint();
          return { _: "updateBotEditBusinessMessage", connectionId: r2.string(), message: r2.object(), replyToMessage: flags & 1 ? r2.object() : void 0, qts: r2.int() };
        },
        2687146030: function(r2) {
          return { _: "updateBotDeleteBusinessMessage", connectionId: r2.string(), peer: r2.object(), messages: r2.vector(r2.int), qts: r2.int() };
        },
        405070859: function(r2) {
          return { _: "updateNewStoryReaction", storyId: r2.int(), peer: r2.object(), reaction: r2.object() };
        },
        3755565557: function(r2) {
          return { _: "updateBroadcastRevenueTransactions", peer: r2.object(), balances: r2.object() };
        },
        263737752: function(r2) {
          return { _: "updateStarsBalance", balance: r2.long() };
        },
        513998247: function(r2) {
          var flags = r2.uint();
          return { _: "updateBusinessBotCallbackQuery", queryId: r2.long(), userId: r2.int53(), connectionId: r2.string(), message: r2.object(), replyToMessage: flags & 4 ? r2.object() : void 0, chatInstance: r2.long(), data: flags & 1 ? r2.bytes() : void 0 };
        },
        2776936473: function(r2) {
          return { _: "updateStarsRevenueStatus", peer: r2.object(), status: r2.object() };
        },
        675009298: function(r2) {
          return { _: "updateBotPurchasedPaidMedia", userId: r2.int53(), payload: r2.string(), qts: r2.int() };
        },
        1372224236: function(r2) {
          return { _: "updatePaidReactionPrivacy", private: r2.boolean() };
        },
        2775329342: function(r2) {
          return { _: "updates.state", pts: r2.int(), qts: r2.int(), date: r2.int(), seq: r2.int(), unreadCount: r2.int() };
        },
        1567990072: function(r2) {
          return { _: "updates.differenceEmpty", date: r2.int(), seq: r2.int() };
        },
        16030880: function(r2) {
          return { _: "updates.difference", newMessages: r2.vector(r2.object), newEncryptedMessages: r2.vector(r2.object), otherUpdates: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), state: r2.object() };
        },
        2835028353: function(r2) {
          return { _: "updates.differenceSlice", newMessages: r2.vector(r2.object), newEncryptedMessages: r2.vector(r2.object), otherUpdates: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), intermediateState: r2.object() };
        },
        1258196845: function(r2) {
          return { _: "updates.differenceTooLong", pts: r2.int() };
        },
        3809980286: function(r2) {
          return { _: "updatesTooLong" };
        },
        826001400: function(r2) {
          var flags = r2.uint();
          return { _: "updateShortMessage", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), id: r2.int(), userId: r2.int53(), message: r2.string(), pts: r2.int(), ptsCount: r2.int(), date: r2.int(), fwdFrom: flags & 4 ? r2.object() : void 0, viaBotId: flags & 2048 ? r2.int53() : void 0, replyTo: flags & 8 ? r2.object() : void 0, entities: flags & 128 ? r2.vector(r2.object) : void 0, ttlPeriod: flags & 33554432 ? r2.int() : void 0 };
        },
        1299050149: function(r2) {
          var flags = r2.uint();
          return { _: "updateShortChatMessage", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), id: r2.int(), fromId: r2.int53(), chatId: r2.int53(), message: r2.string(), pts: r2.int(), ptsCount: r2.int(), date: r2.int(), fwdFrom: flags & 4 ? r2.object() : void 0, viaBotId: flags & 2048 ? r2.int53() : void 0, replyTo: flags & 8 ? r2.object() : void 0, entities: flags & 128 ? r2.vector(r2.object) : void 0, ttlPeriod: flags & 33554432 ? r2.int() : void 0 };
        },
        2027216577: function(r2) {
          return { _: "updateShort", update: r2.object(), date: r2.int() };
        },
        1918567619: function(r2) {
          return { _: "updatesCombined", updates: r2.vector(r2.object), users: r2.vector(r2.object), chats: r2.vector(r2.object), date: r2.int(), seqStart: r2.int(), seq: r2.int() };
        },
        1957577280: function(r2) {
          return { _: "updates", updates: r2.vector(r2.object), users: r2.vector(r2.object), chats: r2.vector(r2.object), date: r2.int(), seq: r2.int() };
        },
        2417352961: function(r2) {
          var flags = r2.uint();
          return { _: "updateShortSentMessage", out: !!(flags & 2), id: r2.int(), pts: r2.int(), ptsCount: r2.int(), date: r2.int(), media: flags & 512 ? r2.object() : void 0, entities: flags & 128 ? r2.vector(r2.object) : void 0, ttlPeriod: flags & 33554432 ? r2.int() : void 0 };
        },
        2378853029: function(r2) {
          return { _: "photos.photos", photos: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        352657236: function(r2) {
          return { _: "photos.photosSlice", count: r2.int(), photos: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        539045032: function(r2) {
          return { _: "photos.photo", photo: r2.object(), users: r2.vector(r2.object) };
        },
        157948117: function(r2) {
          return { _: "upload.file", type: r2.object(), mtime: r2.int(), bytes: r2.bytes() };
        },
        4052539972: function(r2) {
          return { _: "upload.fileCdnRedirect", dcId: r2.int(), fileToken: r2.bytes(), encryptionKey: r2.bytes(), encryptionIv: r2.bytes(), fileHashes: r2.vector(r2.object) };
        },
        414687501: function(r2) {
          var flags = r2.uint();
          return { _: "dcOption", ipv6: !!(flags & 1), mediaOnly: !!(flags & 2), tcpoOnly: !!(flags & 4), cdn: !!(flags & 8), static: !!(flags & 16), thisPortOnly: !!(flags & 32), id: r2.int(), ipAddress: r2.string(), port: r2.int(), secret: flags & 1024 ? r2.bytes() : void 0 };
        },
        3424265246: function(r2) {
          var flags = r2.uint();
          return { _: "config", defaultP2pContacts: !!(flags & 8), preloadFeaturedStickers: !!(flags & 16), revokePmInbox: !!(flags & 64), blockedMode: !!(flags & 256), forceTryIpv6: !!(flags & 16384), date: r2.int(), expires: r2.int(), testMode: r2.boolean(), thisDc: r2.int(), dcOptions: r2.vector(r2.object), dcTxtDomainName: r2.string(), chatSizeMax: r2.int(), megagroupSizeMax: r2.int(), forwardedCountMax: r2.int(), onlineUpdatePeriodMs: r2.int(), offlineBlurTimeoutMs: r2.int(), offlineIdleTimeoutMs: r2.int(), onlineCloudTimeoutMs: r2.int(), notifyCloudDelayMs: r2.int(), notifyDefaultDelayMs: r2.int(), pushChatPeriodMs: r2.int(), pushChatLimit: r2.int(), editTimeLimit: r2.int(), revokeTimeLimit: r2.int(), revokePmTimeLimit: r2.int(), ratingEDecay: r2.int(), stickersRecentLimit: r2.int(), channelsReadMediaPeriod: r2.int(), tmpSessions: flags & 1 ? r2.int() : void 0, callReceiveTimeoutMs: r2.int(), callRingTimeoutMs: r2.int(), callConnectTimeoutMs: r2.int(), callPacketTimeoutMs: r2.int(), meUrlPrefix: r2.string(), autoupdateUrlPrefix: flags & 128 ? r2.string() : void 0, gifSearchUsername: flags & 512 ? r2.string() : void 0, venueSearchUsername: flags & 1024 ? r2.string() : void 0, imgSearchUsername: flags & 2048 ? r2.string() : void 0, staticMapsProvider: flags & 4096 ? r2.string() : void 0, captionLengthMax: r2.int(), messageLengthMax: r2.int(), webfileDcId: r2.int(), suggestedLangCode: flags & 4 ? r2.string() : void 0, langPackVersion: flags & 4 ? r2.int() : void 0, baseLangPackVersion: flags & 4 ? r2.int() : void 0, reactionsDefault: flags & 32768 ? r2.object() : void 0, autologinToken: flags & 65536 ? r2.string() : void 0 };
        },
        2384074613: function(r2) {
          return { _: "nearestDc", country: r2.string(), thisDc: r2.int(), nearestDc: r2.int() };
        },
        3434860080: function(r2) {
          var flags = r2.uint();
          return { _: "help.appUpdate", canNotSkip: !!(flags & 1), id: r2.int(), version: r2.string(), text: r2.string(), entities: r2.vector(r2.object), document: flags & 2 ? r2.object() : void 0, url: flags & 4 ? r2.string() : void 0, sticker: flags & 8 ? r2.object() : void 0 };
        },
        3294258486: function(r2) {
          return { _: "help.noAppUpdate" };
        },
        415997816: function(r2) {
          return { _: "help.inviteText", message: r2.string() };
        },
        2877210784: function(r2) {
          return { _: "encryptedChatEmpty", id: r2.int() };
        },
        1722964307: function(r2) {
          return { _: "encryptedChatWaiting", id: r2.int(), accessHash: r2.long(), date: r2.int(), adminId: r2.int53(), participantId: r2.int53() };
        },
        1223809356: function(r2) {
          var flags = r2.uint();
          return { _: "encryptedChatRequested", folderId: flags & 1 ? r2.int() : void 0, id: r2.int(), accessHash: r2.long(), date: r2.int(), adminId: r2.int53(), participantId: r2.int53(), gA: r2.bytes() };
        },
        1643173063: function(r2) {
          return { _: "encryptedChat", id: r2.int(), accessHash: r2.long(), date: r2.int(), adminId: r2.int53(), participantId: r2.int53(), gAOrB: r2.bytes(), keyFingerprint: r2.long() };
        },
        505183301: function(r2) {
          var flags = r2.uint();
          return { _: "encryptedChatDiscarded", historyDeleted: !!(flags & 1), id: r2.int() };
        },
        4047615457: function(r2) {
          return { _: "inputEncryptedChat", chatId: r2.int(), accessHash: r2.long() };
        },
        3256830334: function(r2) {
          return { _: "encryptedFileEmpty" };
        },
        2818608344: function(r2) {
          return { _: "encryptedFile", id: r2.long(), accessHash: r2.long(), size: r2.int53(), dcId: r2.int(), keyFingerprint: r2.int() };
        },
        406307684: function(r2) {
          return { _: "inputEncryptedFileEmpty" };
        },
        1690108678: function(r2) {
          return { _: "inputEncryptedFileUploaded", id: r2.long(), parts: r2.int(), md5Checksum: r2.string(), keyFingerprint: r2.int() };
        },
        1511503333: function(r2) {
          return { _: "inputEncryptedFile", id: r2.long(), accessHash: r2.long() };
        },
        767652808: function(r2) {
          return { _: "inputEncryptedFileBigUploaded", id: r2.long(), parts: r2.int(), keyFingerprint: r2.int() };
        },
        3977822488: function(r2) {
          return { _: "encryptedMessage", randomId: r2.long(), chatId: r2.int(), date: r2.int(), bytes: r2.bytes(), file: r2.object() };
        },
        594758406: function(r2) {
          return { _: "encryptedMessageService", randomId: r2.long(), chatId: r2.int(), date: r2.int(), bytes: r2.bytes() };
        },
        3236054581: function(r2) {
          return { _: "messages.dhConfigNotModified", random: r2.bytes() };
        },
        740433629: function(r2) {
          return { _: "messages.dhConfig", g: r2.int(), p: r2.bytes(), version: r2.int(), random: r2.bytes() };
        },
        1443858741: function(r2) {
          return { _: "messages.sentEncryptedMessage", date: r2.int() };
        },
        2492727090: function(r2) {
          return { _: "messages.sentEncryptedFile", date: r2.int(), file: r2.object() };
        },
        1928391342: function(r2) {
          return { _: "inputDocumentEmpty" };
        },
        448771445: function(r2) {
          return { _: "inputDocument", id: r2.long(), accessHash: r2.long(), fileReference: r2.bytes() };
        },
        922273905: function(r2) {
          return { _: "documentEmpty", id: r2.long() };
        },
        2413085912: function(r2) {
          var flags = r2.uint();
          return { _: "document", id: r2.long(), accessHash: r2.long(), fileReference: r2.bytes(), date: r2.int(), mimeType: r2.string(), size: r2.int53(), thumbs: flags & 1 ? r2.vector(r2.object) : void 0, videoThumbs: flags & 2 ? r2.vector(r2.object) : void 0, dcId: r2.int(), attributes: r2.vector(r2.object) };
        },
        398898678: function(r2) {
          return { _: "help.support", phoneNumber: r2.string(), user: r2.object() };
        },
        2681474008: function(r2) {
          return { _: "notifyPeer", peer: r2.object() };
        },
        3033021260: function(r2) {
          return { _: "notifyUsers" };
        },
        3221737155: function(r2) {
          return { _: "notifyChats" };
        },
        3591563503: function(r2) {
          return { _: "notifyBroadcasts" };
        },
        577659656: function(r2) {
          return { _: "notifyForumTopic", peer: r2.object(), topMsgId: r2.int() };
        },
        381645902: function(r2) {
          return { _: "sendMessageTypingAction" };
        },
        4250847477: function(r2) {
          return { _: "sendMessageCancelAction" };
        },
        2710034031: function(r2) {
          return { _: "sendMessageRecordVideoAction" };
        },
        3916839660: function(r2) {
          return { _: "sendMessageUploadVideoAction", progress: r2.int() };
        },
        3576656887: function(r2) {
          return { _: "sendMessageRecordAudioAction" };
        },
        4082227115: function(r2) {
          return { _: "sendMessageUploadAudioAction", progress: r2.int() };
        },
        3520285222: function(r2) {
          return { _: "sendMessageUploadPhotoAction", progress: r2.int() };
        },
        2852968932: function(r2) {
          return { _: "sendMessageUploadDocumentAction", progress: r2.int() };
        },
        393186209: function(r2) {
          return { _: "sendMessageGeoLocationAction" };
        },
        1653390447: function(r2) {
          return { _: "sendMessageChooseContactAction" };
        },
        3714748232: function(r2) {
          return { _: "sendMessageGamePlayAction" };
        },
        2297593788: function(r2) {
          return { _: "sendMessageRecordRoundAction" };
        },
        608050278: function(r2) {
          return { _: "sendMessageUploadRoundAction", progress: r2.int() };
        },
        3643548293: function(r2) {
          return { _: "speakingInGroupCallAction" };
        },
        3688534598: function(r2) {
          return { _: "sendMessageHistoryImportAction", progress: r2.int() };
        },
        2958739121: function(r2) {
          return { _: "sendMessageChooseStickerAction" };
        },
        630664139: function(r2) {
          return { _: "sendMessageEmojiInteraction", emoticon: r2.string(), msgId: r2.int(), interaction: r2.object() };
        },
        3060109358: function(r2) {
          return { _: "sendMessageEmojiInteractionSeen", emoticon: r2.string() };
        },
        3004386717: function(r2) {
          return { _: "contacts.found", myResults: r2.vector(r2.object), results: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1335282456: function(r2) {
          return { _: "inputPrivacyKeyStatusTimestamp" };
        },
        3187344422: function(r2) {
          return { _: "inputPrivacyKeyChatInvite" };
        },
        4206550111: function(r2) {
          return { _: "inputPrivacyKeyPhoneCall" };
        },
        3684593874: function(r2) {
          return { _: "inputPrivacyKeyPhoneP2P" };
        },
        2765966344: function(r2) {
          return { _: "inputPrivacyKeyForwards" };
        },
        1461304012: function(r2) {
          return { _: "inputPrivacyKeyProfilePhoto" };
        },
        55761658: function(r2) {
          return { _: "inputPrivacyKeyPhoneNumber" };
        },
        3508640733: function(r2) {
          return { _: "inputPrivacyKeyAddedByPhone" };
        },
        2934349160: function(r2) {
          return { _: "inputPrivacyKeyVoiceMessages" };
        },
        941870144: function(r2) {
          return { _: "inputPrivacyKeyAbout" };
        },
        3596227020: function(r2) {
          return { _: "inputPrivacyKeyBirthday" };
        },
        3157175088: function(r2) {
          return { _: "privacyKeyStatusTimestamp" };
        },
        1343122938: function(r2) {
          return { _: "privacyKeyChatInvite" };
        },
        1030105979: function(r2) {
          return { _: "privacyKeyPhoneCall" };
        },
        961092808: function(r2) {
          return { _: "privacyKeyPhoneP2P" };
        },
        1777096355: function(r2) {
          return { _: "privacyKeyForwards" };
        },
        2517966829: function(r2) {
          return { _: "privacyKeyProfilePhoto" };
        },
        3516589165: function(r2) {
          return { _: "privacyKeyPhoneNumber" };
        },
        1124062251: function(r2) {
          return { _: "privacyKeyAddedByPhone" };
        },
        110621716: function(r2) {
          return { _: "privacyKeyVoiceMessages" };
        },
        2760292193: function(r2) {
          return { _: "privacyKeyAbout" };
        },
        536913176: function(r2) {
          return { _: "privacyKeyBirthday" };
        },
        218751099: function(r2) {
          return { _: "inputPrivacyValueAllowContacts" };
        },
        407582158: function(r2) {
          return { _: "inputPrivacyValueAllowAll" };
        },
        320652927: function(r2) {
          return { _: "inputPrivacyValueAllowUsers", users: r2.vector(r2.object) };
        },
        195371015: function(r2) {
          return { _: "inputPrivacyValueDisallowContacts" };
        },
        3597362889: function(r2) {
          return { _: "inputPrivacyValueDisallowAll" };
        },
        2417034343: function(r2) {
          return { _: "inputPrivacyValueDisallowUsers", users: r2.vector(r2.object) };
        },
        2215004623: function(r2) {
          return { _: "inputPrivacyValueAllowChatParticipants", chats: r2.vector(r2.int53) };
        },
        3914272646: function(r2) {
          return { _: "inputPrivacyValueDisallowChatParticipants", chats: r2.vector(r2.int53) };
        },
        793067081: function(r2) {
          return { _: "inputPrivacyValueAllowCloseFriends" };
        },
        2009975281: function(r2) {
          return { _: "inputPrivacyValueAllowPremium" };
        },
        4294843308: function(r2) {
          return { _: "privacyValueAllowContacts" };
        },
        1698855810: function(r2) {
          return { _: "privacyValueAllowAll" };
        },
        3096469426: function(r2) {
          return { _: "privacyValueAllowUsers", users: r2.vector(r2.int53) };
        },
        4169726490: function(r2) {
          return { _: "privacyValueDisallowContacts" };
        },
        2339628899: function(r2) {
          return { _: "privacyValueDisallowAll" };
        },
        3831632193: function(r2) {
          return { _: "privacyValueDisallowUsers", users: r2.vector(r2.int53) };
        },
        1796427406: function(r2) {
          return { _: "privacyValueAllowChatParticipants", chats: r2.vector(r2.int53) };
        },
        1103656293: function(r2) {
          return { _: "privacyValueDisallowChatParticipants", chats: r2.vector(r2.int53) };
        },
        4159232155: function(r2) {
          return { _: "privacyValueAllowCloseFriends" };
        },
        3974725963: function(r2) {
          return { _: "privacyValueAllowPremium" };
        },
        1352683077: function(r2) {
          return { _: "account.privacyRules", rules: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3100684255: function(r2) {
          return { _: "accountDaysTTL", days: r2.int() };
        },
        1815593308: function(r2) {
          return { _: "documentAttributeImageSize", w: r2.int(), h: r2.int() };
        },
        297109817: function(r2) {
          return { _: "documentAttributeAnimated" };
        },
        1662637586: function(r2) {
          var flags = r2.uint();
          return { _: "documentAttributeSticker", mask: !!(flags & 2), alt: r2.string(), stickerset: r2.object(), maskCoords: flags & 1 ? r2.object() : void 0 };
        },
        1137015880: function(r2) {
          var flags = r2.uint();
          return { _: "documentAttributeVideo", roundMessage: !!(flags & 1), supportsStreaming: !!(flags & 2), nosound: !!(flags & 8), duration: r2.double(), w: r2.int(), h: r2.int(), preloadPrefixSize: flags & 4 ? r2.int() : void 0, videoStartTs: flags & 16 ? r2.double() : void 0, videoCodec: flags & 32 ? r2.string() : void 0 };
        },
        2555574726: function(r2) {
          var flags = r2.uint();
          return { _: "documentAttributeAudio", voice: !!(flags & 1024), duration: r2.int(), title: flags & 1 ? r2.string() : void 0, performer: flags & 2 ? r2.string() : void 0, waveform: flags & 4 ? r2.bytes() : void 0 };
        },
        358154344: function(r2) {
          return { _: "documentAttributeFilename", fileName: r2.string() };
        },
        2550256375: function(r2) {
          return { _: "documentAttributeHasStickers" };
        },
        4245985433: function(r2) {
          var flags = r2.uint();
          return { _: "documentAttributeCustomEmoji", free: !!(flags & 1), textColor: !!(flags & 2), alt: r2.string(), stickerset: r2.object() };
        },
        4050950690: function(r2) {
          return { _: "messages.stickersNotModified" };
        },
        816245886: function(r2) {
          return { _: "messages.stickers", hash: r2.long(), stickers: r2.vector(r2.object) };
        },
        313694676: function(r2) {
          return { _: "stickerPack", emoticon: r2.string(), documents: r2.vector(r2.long) };
        },
        3898999491: function(r2) {
          return { _: "messages.allStickersNotModified" };
        },
        3451637435: function(r2) {
          return { _: "messages.allStickers", hash: r2.long(), sets: r2.vector(r2.object) };
        },
        2228326789: function(r2) {
          return { _: "messages.affectedMessages", pts: r2.int(), ptsCount: r2.int() };
        },
        555358088: function(r2) {
          var flags = r2.uint();
          return { _: "webPageEmpty", id: r2.long(), url: flags & 1 ? r2.string() : void 0 };
        },
        2966502983: function(r2) {
          var flags = r2.uint();
          return { _: "webPagePending", id: r2.long(), url: flags & 1 ? r2.string() : void 0, date: r2.int() };
        },
        3902555570: function(r2) {
          var flags = r2.uint();
          return { _: "webPage", hasLargeMedia: !!(flags & 8192), id: r2.long(), url: r2.string(), displayUrl: r2.string(), hash: r2.int(), type: flags & 1 ? r2.string() : void 0, siteName: flags & 2 ? r2.string() : void 0, title: flags & 4 ? r2.string() : void 0, description: flags & 8 ? r2.string() : void 0, photo: flags & 16 ? r2.object() : void 0, embedUrl: flags & 32 ? r2.string() : void 0, embedType: flags & 32 ? r2.string() : void 0, embedWidth: flags & 64 ? r2.int() : void 0, embedHeight: flags & 64 ? r2.int() : void 0, duration: flags & 128 ? r2.int() : void 0, author: flags & 256 ? r2.string() : void 0, document: flags & 512 ? r2.object() : void 0, cachedPage: flags & 1024 ? r2.object() : void 0, attributes: flags & 4096 ? r2.vector(r2.object) : void 0 };
        },
        1930545681: function(r2) {
          var flags = r2.uint();
          return { _: "webPageNotModified", cachedPageViews: flags & 1 ? r2.int() : void 0 };
        },
        2902578717: function(r2) {
          var flags = r2.uint();
          return { _: "authorization", current: !!(flags & 1), officialApp: !!(flags & 2), passwordPending: !!(flags & 4), encryptedRequestsDisabled: !!(flags & 8), callRequestsDisabled: !!(flags & 16), unconfirmed: !!(flags & 32), hash: r2.long(), deviceModel: r2.string(), platform: r2.string(), systemVersion: r2.string(), apiId: r2.int(), appName: r2.string(), appVersion: r2.string(), dateCreated: r2.int(), dateActive: r2.int(), ip: r2.string(), country: r2.string(), region: r2.string() };
        },
        1275039392: function(r2) {
          return { _: "account.authorizations", authorizationTtlDays: r2.int(), authorizations: r2.vector(r2.object) };
        },
        2507886843: function(r2) {
          var flags = r2.uint();
          return { _: "account.password", hasRecovery: !!(flags & 1), hasSecureValues: !!(flags & 2), hasPassword: !!(flags & 4), currentAlgo: flags & 4 ? r2.object() : void 0, srpB: flags & 4 ? r2.bytes() : void 0, srpId: flags & 4 ? r2.long() : void 0, hint: flags & 8 ? r2.string() : void 0, emailUnconfirmedPattern: flags & 16 ? r2.string() : void 0, newAlgo: r2.object(), newSecureAlgo: r2.object(), secureRandom: r2.bytes(), pendingResetDate: flags & 32 ? r2.int() : void 0, loginEmailPattern: flags & 64 ? r2.string() : void 0 };
        },
        2589733861: function(r2) {
          var flags = r2.uint();
          return { _: "account.passwordSettings", email: flags & 1 ? r2.string() : void 0, secureSettings: flags & 2 ? r2.object() : void 0 };
        },
        3258394569: function(r2) {
          var flags = r2.uint();
          return { _: "account.passwordInputSettings", newAlgo: flags & 1 ? r2.object() : void 0, newPasswordHash: flags & 1 ? r2.bytes() : void 0, hint: flags & 1 ? r2.string() : void 0, email: flags & 2 ? r2.string() : void 0, newSecureSettings: flags & 4 ? r2.object() : void 0 };
        },
        326715557: function(r2) {
          return { _: "auth.passwordRecovery", emailPattern: r2.string() };
        },
        2743383929: function(r2) {
          return { _: "receivedNotifyMessage", id: r2.int(), flags: r2.int() };
        },
        2720841110: function(r2) {
          var flags = r2.uint();
          return { _: "chatInviteExported", revoked: !!(flags & 1), permanent: !!(flags & 32), requestNeeded: !!(flags & 64), link: r2.string(), adminId: r2.int53(), date: r2.int(), startDate: flags & 16 ? r2.int() : void 0, expireDate: flags & 2 ? r2.int() : void 0, usageLimit: flags & 4 ? r2.int() : void 0, usage: flags & 8 ? r2.int() : void 0, requested: flags & 128 ? r2.int() : void 0, subscriptionExpired: flags & 1024 ? r2.int() : void 0, title: flags & 256 ? r2.string() : void 0, subscriptionPricing: flags & 512 ? r2.object() : void 0 };
        },
        3977280183: function(r2) {
          return { _: "chatInvitePublicJoinRequests" };
        },
        1516793212: function(r2) {
          return { _: "chatInviteAlready", chat: r2.object() };
        },
        4268046493: function(r2) {
          var flags = r2.uint();
          return { _: "chatInvite", channel: !!(flags & 1), broadcast: !!(flags & 2), public: !!(flags & 4), megagroup: !!(flags & 8), requestNeeded: !!(flags & 64), verified: !!(flags & 128), scam: !!(flags & 256), fake: !!(flags & 512), canRefulfillSubscription: !!(flags & 2048), title: r2.string(), about: flags & 32 ? r2.string() : void 0, photo: r2.object(), participantsCount: r2.int(), participants: flags & 16 ? r2.vector(r2.object) : void 0, color: r2.int(), subscriptionPricing: flags & 1024 ? r2.object() : void 0, subscriptionFormId: flags & 4096 ? r2.long() : void 0 };
        },
        1634294960: function(r2) {
          return { _: "chatInvitePeek", chat: r2.object(), expires: r2.int() };
        },
        4290128789: function(r2) {
          return { _: "inputStickerSetEmpty" };
        },
        2649203305: function(r2) {
          return { _: "inputStickerSetID", id: r2.long(), accessHash: r2.long() };
        },
        2250033312: function(r2) {
          return { _: "inputStickerSetShortName", shortName: r2.string() };
        },
        42402760: function(r2) {
          return { _: "inputStickerSetAnimatedEmoji" };
        },
        3867103758: function(r2) {
          return { _: "inputStickerSetDice", emoticon: r2.string() };
        },
        215889721: function(r2) {
          return { _: "inputStickerSetAnimatedEmojiAnimations" };
        },
        3364567810: function(r2) {
          return { _: "inputStickerSetPremiumGifts" };
        },
        80008398: function(r2) {
          return { _: "inputStickerSetEmojiGenericAnimations" };
        },
        701560302: function(r2) {
          return { _: "inputStickerSetEmojiDefaultStatuses" };
        },
        1153562857: function(r2) {
          return { _: "inputStickerSetEmojiDefaultTopicIcons" };
        },
        1232373075: function(r2) {
          return { _: "inputStickerSetEmojiChannelDefaultStatuses" };
        },
        768691932: function(r2) {
          var flags = r2.uint();
          return { _: "stickerSet", archived: !!(flags & 2), official: !!(flags & 4), masks: !!(flags & 8), emojis: !!(flags & 128), textColor: !!(flags & 512), channelEmojiStatus: !!(flags & 1024), creator: !!(flags & 2048), installedDate: flags & 1 ? r2.int() : void 0, id: r2.long(), accessHash: r2.long(), title: r2.string(), shortName: r2.string(), thumbs: flags & 16 ? r2.vector(r2.object) : void 0, thumbDcId: flags & 16 ? r2.int() : void 0, thumbVersion: flags & 16 ? r2.int() : void 0, thumbDocumentId: flags & 256 ? r2.long() : void 0, count: r2.int(), hash: r2.int() };
        },
        1846886166: function(r2) {
          return { _: "messages.stickerSet", set: r2.object(), packs: r2.vector(r2.object), keywords: r2.vector(r2.object), documents: r2.vector(r2.object) };
        },
        3556320491: function(r2) {
          return { _: "messages.stickerSetNotModified" };
        },
        3262826695: function(r2) {
          return { _: "botCommand", command: r2.string(), description: r2.string() };
        },
        2185461364: function(r2) {
          var flags = r2.uint();
          return { _: "botInfo", hasPreviewMedias: !!(flags & 64), userId: flags & 1 ? r2.int53() : void 0, description: flags & 2 ? r2.string() : void 0, descriptionPhoto: flags & 16 ? r2.object() : void 0, descriptionDocument: flags & 32 ? r2.object() : void 0, commands: flags & 4 ? r2.vector(r2.object) : void 0, menuButton: flags & 8 ? r2.object() : void 0, privacyPolicyUrl: flags & 128 ? r2.string() : void 0 };
        },
        2734311552: function(r2) {
          return { _: "keyboardButton", text: r2.string() };
        },
        629866245: function(r2) {
          return { _: "keyboardButtonUrl", text: r2.string(), url: r2.string() };
        },
        901503851: function(r2) {
          var flags = r2.uint();
          return { _: "keyboardButtonCallback", requiresPassword: !!(flags & 1), text: r2.string(), data: r2.bytes() };
        },
        2976541737: function(r2) {
          return { _: "keyboardButtonRequestPhone", text: r2.string() };
        },
        4235815743: function(r2) {
          return { _: "keyboardButtonRequestGeoLocation", text: r2.string() };
        },
        2478439349: function(r2) {
          var flags = r2.uint();
          return { _: "keyboardButtonSwitchInline", samePeer: !!(flags & 1), text: r2.string(), query: r2.string(), peerTypes: flags & 2 ? r2.vector(r2.object) : void 0 };
        },
        1358175439: function(r2) {
          return { _: "keyboardButtonGame", text: r2.string() };
        },
        2950250427: function(r2) {
          return { _: "keyboardButtonBuy", text: r2.string() };
        },
        280464681: function(r2) {
          var flags = r2.uint();
          return { _: "keyboardButtonUrlAuth", text: r2.string(), fwdText: flags & 1 ? r2.string() : void 0, url: r2.string(), buttonId: r2.int() };
        },
        3492708308: function(r2) {
          var flags = r2.uint();
          return { _: "inputKeyboardButtonUrlAuth", requestWriteAccess: !!(flags & 1), text: r2.string(), fwdText: flags & 2 ? r2.string() : void 0, url: r2.string(), bot: r2.object() };
        },
        3150401885: function(r2) {
          var flags = r2.uint();
          return { _: "keyboardButtonRequestPoll", quiz: flags & 1 ? r2.boolean() : void 0, text: r2.string() };
        },
        3918005115: function(r2) {
          return { _: "inputKeyboardButtonUserProfile", text: r2.string(), userId: r2.object() };
        },
        814112961: function(r2) {
          return { _: "keyboardButtonUserProfile", text: r2.string(), userId: r2.int53() };
        },
        326529584: function(r2) {
          return { _: "keyboardButtonWebView", text: r2.string(), url: r2.string() };
        },
        2696958044: function(r2) {
          return { _: "keyboardButtonSimpleWebView", text: r2.string(), url: r2.string() };
        },
        1406648280: function(r2) {
          return { _: "keyboardButtonRequestPeer", text: r2.string(), buttonId: r2.int(), peerType: r2.object(), maxQuantity: r2.int() };
        },
        3378916613: function(r2) {
          var flags = r2.uint();
          return { _: "inputKeyboardButtonRequestPeer", nameRequested: !!(flags & 1), usernameRequested: !!(flags & 2), photoRequested: !!(flags & 4), text: r2.string(), buttonId: r2.int(), peerType: r2.object(), maxQuantity: r2.int() };
        },
        1976723854: function(r2) {
          return { _: "keyboardButtonCopy", text: r2.string(), copyText: r2.string() };
        },
        2002815875: function(r2) {
          return { _: "keyboardButtonRow", buttons: r2.vector(r2.object) };
        },
        2688441221: function(r2) {
          var flags = r2.uint();
          return { _: "replyKeyboardHide", selective: !!(flags & 4) };
        },
        2259946248: function(r2) {
          var flags = r2.uint();
          return { _: "replyKeyboardForceReply", singleUse: !!(flags & 2), selective: !!(flags & 4), placeholder: flags & 8 ? r2.string() : void 0 };
        },
        2245892561: function(r2) {
          var flags = r2.uint();
          return { _: "replyKeyboardMarkup", resize: !!(flags & 1), singleUse: !!(flags & 2), selective: !!(flags & 4), persistent: !!(flags & 16), rows: r2.vector(r2.object), placeholder: flags & 8 ? r2.string() : void 0 };
        },
        1218642516: function(r2) {
          return { _: "replyInlineMarkup", rows: r2.vector(r2.object) };
        },
        3146955413: function(r2) {
          return { _: "messageEntityUnknown", offset: r2.int(), length: r2.int() };
        },
        4194588573: function(r2) {
          return { _: "messageEntityMention", offset: r2.int(), length: r2.int() };
        },
        1868782349: function(r2) {
          return { _: "messageEntityHashtag", offset: r2.int(), length: r2.int() };
        },
        1827637959: function(r2) {
          return { _: "messageEntityBotCommand", offset: r2.int(), length: r2.int() };
        },
        1859134776: function(r2) {
          return { _: "messageEntityUrl", offset: r2.int(), length: r2.int() };
        },
        1692693954: function(r2) {
          return { _: "messageEntityEmail", offset: r2.int(), length: r2.int() };
        },
        3177253833: function(r2) {
          return { _: "messageEntityBold", offset: r2.int(), length: r2.int() };
        },
        2188348256: function(r2) {
          return { _: "messageEntityItalic", offset: r2.int(), length: r2.int() };
        },
        681706865: function(r2) {
          return { _: "messageEntityCode", offset: r2.int(), length: r2.int() };
        },
        1938967520: function(r2) {
          return { _: "messageEntityPre", offset: r2.int(), length: r2.int(), language: r2.string() };
        },
        1990644519: function(r2) {
          return { _: "messageEntityTextUrl", offset: r2.int(), length: r2.int(), url: r2.string() };
        },
        3699052864: function(r2) {
          return { _: "messageEntityMentionName", offset: r2.int(), length: r2.int(), userId: r2.int53() };
        },
        546203849: function(r2) {
          return { _: "inputMessageEntityMentionName", offset: r2.int(), length: r2.int(), userId: r2.object() };
        },
        2607407947: function(r2) {
          return { _: "messageEntityPhone", offset: r2.int(), length: r2.int() };
        },
        1280209983: function(r2) {
          return { _: "messageEntityCashtag", offset: r2.int(), length: r2.int() };
        },
        2622389899: function(r2) {
          return { _: "messageEntityUnderline", offset: r2.int(), length: r2.int() };
        },
        3204879316: function(r2) {
          return { _: "messageEntityStrike", offset: r2.int(), length: r2.int() };
        },
        1981704948: function(r2) {
          return { _: "messageEntityBankCard", offset: r2.int(), length: r2.int() };
        },
        852137487: function(r2) {
          return { _: "messageEntitySpoiler", offset: r2.int(), length: r2.int() };
        },
        3369010680: function(r2) {
          return { _: "messageEntityCustomEmoji", offset: r2.int(), length: r2.int(), documentId: r2.long() };
        },
        4056722092: function(r2) {
          var flags = r2.uint();
          return { _: "messageEntityBlockquote", collapsed: !!(flags & 1), offset: r2.int(), length: r2.int() };
        },
        4002160262: function(r2) {
          return { _: "inputChannelEmpty" };
        },
        4082822184: function(r2) {
          return { _: "inputChannel", channelId: r2.int53(), accessHash: r2.long() };
        },
        1536380829: function(r2) {
          return { _: "inputChannelFromMessage", peer: r2.object(), msgId: r2.int(), channelId: r2.int53() };
        },
        2131196633: function(r2) {
          return { _: "contacts.resolvedPeer", peer: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        182649427: function(r2) {
          return { _: "messageRange", minId: r2.int(), maxId: r2.int() };
        },
        1041346555: function(r2) {
          var flags = r2.uint();
          return { _: "updates.channelDifferenceEmpty", final: !!(flags & 1), pts: r2.int(), timeout: flags & 2 ? r2.int() : void 0 };
        },
        2763835134: function(r2) {
          var flags = r2.uint();
          return { _: "updates.channelDifferenceTooLong", final: !!(flags & 1), timeout: flags & 2 ? r2.int() : void 0, dialog: r2.object(), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        543450958: function(r2) {
          var flags = r2.uint();
          return { _: "updates.channelDifference", final: !!(flags & 1), pts: r2.int(), timeout: flags & 2 ? r2.int() : void 0, newMessages: r2.vector(r2.object), otherUpdates: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2496933607: function(r2) {
          return { _: "channelMessagesFilterEmpty" };
        },
        3447183703: function(r2) {
          var flags = r2.uint();
          return { _: "channelMessagesFilter", excludeNewMessages: !!(flags & 2), ranges: r2.vector(r2.object) };
        },
        3409540633: function(r2) {
          var flags = r2.uint();
          return { _: "channelParticipant", userId: r2.int53(), date: r2.int(), subscriptionUntilDate: flags & 1 ? r2.int() : void 0 };
        },
        1331723247: function(r2) {
          var flags = r2.uint();
          return { _: "channelParticipantSelf", viaRequest: !!(flags & 1), userId: r2.int53(), inviterId: r2.int53(), date: r2.int(), subscriptionUntilDate: flags & 2 ? r2.int() : void 0 };
        },
        803602899: function(r2) {
          var flags = r2.uint();
          return { _: "channelParticipantCreator", userId: r2.int53(), adminRights: r2.object(), rank: flags & 1 ? r2.string() : void 0 };
        },
        885242707: function(r2) {
          var flags = r2.uint();
          return { _: "channelParticipantAdmin", canEdit: !!(flags & 1), self: !!(flags & 2), userId: r2.int53(), inviterId: flags & 2 ? r2.int53() : void 0, promotedBy: r2.int53(), date: r2.int(), adminRights: r2.object(), rank: flags & 4 ? r2.string() : void 0 };
        },
        1844969806: function(r2) {
          var flags = r2.uint();
          return { _: "channelParticipantBanned", left: !!(flags & 1), peer: r2.object(), kickedBy: r2.int53(), date: r2.int(), bannedRights: r2.object() };
        },
        453242886: function(r2) {
          return { _: "channelParticipantLeft", peer: r2.object() };
        },
        3728686201: function(r2) {
          return { _: "channelParticipantsRecent" };
        },
        3026225513: function(r2) {
          return { _: "channelParticipantsAdmins" };
        },
        2746567045: function(r2) {
          return { _: "channelParticipantsKicked", q: r2.string() };
        },
        2966521435: function(r2) {
          return { _: "channelParticipantsBots" };
        },
        338142689: function(r2) {
          return { _: "channelParticipantsBanned", q: r2.string() };
        },
        106343499: function(r2) {
          return { _: "channelParticipantsSearch", q: r2.string() };
        },
        3144345741: function(r2) {
          return { _: "channelParticipantsContacts", q: r2.string() };
        },
        3763035371: function(r2) {
          var flags = r2.uint();
          return { _: "channelParticipantsMentions", q: flags & 1 ? r2.string() : void 0, topMsgId: flags & 2 ? r2.int() : void 0 };
        },
        2595290799: function(r2) {
          return { _: "channels.channelParticipants", count: r2.int(), participants: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        4028055529: function(r2) {
          return { _: "channels.channelParticipantsNotModified" };
        },
        3753378583: function(r2) {
          return { _: "channels.channelParticipant", participant: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2013922064: function(r2) {
          var flags = r2.uint();
          return { _: "help.termsOfService", popup: !!(flags & 1), id: r2.object(), text: r2.string(), entities: r2.vector(r2.object), minAgeConfirm: flags & 2 ? r2.int() : void 0 };
        },
        3892468898: function(r2) {
          return { _: "messages.savedGifsNotModified" };
        },
        2225089037: function(r2) {
          return { _: "messages.savedGifs", hash: r2.long(), gifs: r2.vector(r2.object) };
        },
        864077702: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageMediaAuto", invertMedia: !!(flags & 8), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0, replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        1036876423: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageText", noWebpage: !!(flags & 1), invertMedia: !!(flags & 8), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0, replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        2526190213: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageMediaGeo", geoPoint: r2.object(), heading: flags & 1 ? r2.int() : void 0, period: flags & 2 ? r2.int() : void 0, proximityNotificationRadius: flags & 8 ? r2.int() : void 0, replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        1098628881: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageMediaVenue", geoPoint: r2.object(), title: r2.string(), address: r2.string(), provider: r2.string(), venueId: r2.string(), venueType: r2.string(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        2800599037: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageMediaContact", phoneNumber: r2.string(), firstName: r2.string(), lastName: r2.string(), vcard: r2.string(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        1262639204: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageGame", replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        3622273573: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageMediaInvoice", title: r2.string(), description: r2.string(), photo: flags & 1 ? r2.object() : void 0, invoice: r2.object(), payload: r2.bytes(), provider: r2.string(), providerData: r2.object(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        3185362192: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineMessageMediaWebPage", invertMedia: !!(flags & 8), forceLargeMedia: !!(flags & 16), forceSmallMedia: !!(flags & 32), optional: !!(flags & 64), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0, url: r2.string(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        2294256409: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineResult", id: r2.string(), type: r2.string(), title: flags & 2 ? r2.string() : void 0, description: flags & 4 ? r2.string() : void 0, url: flags & 8 ? r2.string() : void 0, thumb: flags & 16 ? r2.object() : void 0, content: flags & 32 ? r2.object() : void 0, sendMessage: r2.object() };
        },
        2832753831: function(r2) {
          return { _: "inputBotInlineResultPhoto", id: r2.string(), type: r2.string(), photo: r2.object(), sendMessage: r2.object() };
        },
        4294507972: function(r2) {
          var flags = r2.uint();
          return { _: "inputBotInlineResultDocument", id: r2.string(), type: r2.string(), title: flags & 2 ? r2.string() : void 0, description: flags & 4 ? r2.string() : void 0, document: r2.object(), sendMessage: r2.object() };
        },
        1336154098: function(r2) {
          return { _: "inputBotInlineResultGame", id: r2.string(), shortName: r2.string(), sendMessage: r2.object() };
        },
        1984755728: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMessageMediaAuto", invertMedia: !!(flags & 8), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0, replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        2357159394: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMessageText", noWebpage: !!(flags & 1), invertMedia: !!(flags & 8), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0, replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        85477117: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMessageMediaGeo", geo: r2.object(), heading: flags & 1 ? r2.int() : void 0, period: flags & 2 ? r2.int() : void 0, proximityNotificationRadius: flags & 8 ? r2.int() : void 0, replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        2324063644: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMessageMediaVenue", geo: r2.object(), title: r2.string(), address: r2.string(), provider: r2.string(), venueId: r2.string(), venueType: r2.string(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        416402882: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMessageMediaContact", phoneNumber: r2.string(), firstName: r2.string(), lastName: r2.string(), vcard: r2.string(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        894081801: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMessageMediaInvoice", shippingAddressRequested: !!(flags & 2), test: !!(flags & 8), title: r2.string(), description: r2.string(), photo: flags & 1 ? r2.object() : void 0, currency: r2.string(), totalAmount: r2.long(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        2157631910: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMessageMediaWebPage", invertMedia: !!(flags & 8), forceLargeMedia: !!(flags & 16), forceSmallMedia: !!(flags & 32), manual: !!(flags & 128), safe: !!(flags & 256), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0, url: r2.string(), replyMarkup: flags & 4 ? r2.object() : void 0 };
        },
        295067450: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineResult", id: r2.string(), type: r2.string(), title: flags & 2 ? r2.string() : void 0, description: flags & 4 ? r2.string() : void 0, url: flags & 8 ? r2.string() : void 0, thumb: flags & 16 ? r2.object() : void 0, content: flags & 32 ? r2.object() : void 0, sendMessage: r2.object() };
        },
        400266251: function(r2) {
          var flags = r2.uint();
          return { _: "botInlineMediaResult", id: r2.string(), type: r2.string(), photo: flags & 1 ? r2.object() : void 0, document: flags & 2 ? r2.object() : void 0, title: flags & 4 ? r2.string() : void 0, description: flags & 8 ? r2.string() : void 0, sendMessage: r2.object() };
        },
        3760321270: function(r2) {
          var flags = r2.uint();
          return { _: "messages.botResults", gallery: !!(flags & 1), queryId: r2.long(), nextOffset: flags & 2 ? r2.string() : void 0, switchPm: flags & 4 ? r2.object() : void 0, switchWebview: flags & 8 ? r2.object() : void 0, results: r2.vector(r2.object), cacheTime: r2.int(), users: r2.vector(r2.object) };
        },
        1571494644: function(r2) {
          return { _: "exportedMessageLink", link: r2.string(), html: r2.string() };
        },
        1313731771: function(r2) {
          var flags = r2.uint();
          return { _: "messageFwdHeader", imported: !!(flags & 128), savedOut: !!(flags & 2048), fromId: flags & 1 ? r2.object() : void 0, fromName: flags & 32 ? r2.string() : void 0, date: r2.int(), channelPost: flags & 4 ? r2.int() : void 0, postAuthor: flags & 8 ? r2.string() : void 0, savedFromPeer: flags & 16 ? r2.object() : void 0, savedFromMsgId: flags & 16 ? r2.int() : void 0, savedFromId: flags & 256 ? r2.object() : void 0, savedFromName: flags & 512 ? r2.string() : void 0, savedDate: flags & 1024 ? r2.int() : void 0, psaType: flags & 64 ? r2.string() : void 0 };
        },
        1923290508: function(r2) {
          return { _: "auth.codeTypeSms" };
        },
        1948046307: function(r2) {
          return { _: "auth.codeTypeCall" };
        },
        577556219: function(r2) {
          return { _: "auth.codeTypeFlashCall" };
        },
        3592083182: function(r2) {
          return { _: "auth.codeTypeMissedCall" };
        },
        116234636: function(r2) {
          return { _: "auth.codeTypeFragmentSms" };
        },
        1035688326: function(r2) {
          return { _: "auth.sentCodeTypeApp", length: r2.int() };
        },
        3221273506: function(r2) {
          return { _: "auth.sentCodeTypeSms", length: r2.int() };
        },
        1398007207: function(r2) {
          return { _: "auth.sentCodeTypeCall", length: r2.int() };
        },
        2869151449: function(r2) {
          return { _: "auth.sentCodeTypeFlashCall", pattern: r2.string() };
        },
        2181063812: function(r2) {
          return { _: "auth.sentCodeTypeMissedCall", prefix: r2.string(), length: r2.int() };
        },
        4098946459: function(r2) {
          var flags = r2.uint();
          return { _: "auth.sentCodeTypeEmailCode", appleSigninAllowed: !!(flags & 1), googleSigninAllowed: !!(flags & 2), emailPattern: r2.string(), length: r2.int(), resetAvailablePeriod: flags & 8 ? r2.int() : void 0, resetPendingDate: flags & 16 ? r2.int() : void 0 };
        },
        2773032426: function(r2) {
          var flags = r2.uint();
          return { _: "auth.sentCodeTypeSetUpEmailRequired", appleSigninAllowed: !!(flags & 1), googleSigninAllowed: !!(flags & 2) };
        },
        3646315577: function(r2) {
          return { _: "auth.sentCodeTypeFragmentSms", url: r2.string(), length: r2.int() };
        },
        10475318: function(r2) {
          var flags = r2.uint();
          return { _: "auth.sentCodeTypeFirebaseSms", nonce: flags & 1 ? r2.bytes() : void 0, playIntegrityProjectId: flags & 4 ? r2.long() : void 0, playIntegrityNonce: flags & 4 ? r2.bytes() : void 0, receipt: flags & 2 ? r2.string() : void 0, pushTimeout: flags & 2 ? r2.int() : void 0, length: r2.int() };
        },
        2752949377: function(r2) {
          var flags = r2.uint();
          return { _: "auth.sentCodeTypeSmsWord", beginning: flags & 1 ? r2.string() : void 0 };
        },
        3010958511: function(r2) {
          var flags = r2.uint();
          return { _: "auth.sentCodeTypeSmsPhrase", beginning: flags & 1 ? r2.string() : void 0 };
        },
        911761060: function(r2) {
          var flags = r2.uint();
          return { _: "messages.botCallbackAnswer", alert: !!(flags & 2), hasUrl: !!(flags & 8), nativeUi: !!(flags & 16), message: flags & 1 ? r2.string() : void 0, url: flags & 4 ? r2.string() : void 0, cacheTime: r2.int() };
        },
        649453030: function(r2) {
          var flags = r2.uint();
          return { _: "messages.messageEditData", caption: !!(flags & 1) };
        },
        2299280777: function(r2) {
          return { _: "inputBotInlineMessageID", dcId: r2.int(), id: r2.long(), accessHash: r2.long() };
        },
        3067680215: function(r2) {
          return { _: "inputBotInlineMessageID64", dcId: r2.int(), ownerId: r2.long(), id: r2.int(), accessHash: r2.long() };
        },
        1008755359: function(r2) {
          return { _: "inlineBotSwitchPM", text: r2.string(), startParam: r2.string() };
        },
        863093588: function(r2) {
          return { _: "messages.peerDialogs", dialogs: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), state: r2.object() };
        },
        3989684315: function(r2) {
          return { _: "topPeer", peer: r2.object(), rating: r2.double() };
        },
        2875595611: function(r2) {
          return { _: "topPeerCategoryBotsPM" };
        },
        344356834: function(r2) {
          return { _: "topPeerCategoryBotsInline" };
        },
        104314861: function(r2) {
          return { _: "topPeerCategoryCorrespondents" };
        },
        3172442442: function(r2) {
          return { _: "topPeerCategoryGroups" };
        },
        371037736: function(r2) {
          return { _: "topPeerCategoryChannels" };
        },
        511092620: function(r2) {
          return { _: "topPeerCategoryPhoneCalls" };
        },
        2822794409: function(r2) {
          return { _: "topPeerCategoryForwardUsers" };
        },
        4226728176: function(r2) {
          return { _: "topPeerCategoryForwardChats" };
        },
        4255022060: function(r2) {
          return { _: "topPeerCategoryBotsApp" };
        },
        4219683473: function(r2) {
          return { _: "topPeerCategoryPeers", category: r2.object(), count: r2.int(), peers: r2.vector(r2.object) };
        },
        3727060725: function(r2) {
          return { _: "contacts.topPeersNotModified" };
        },
        1891070632: function(r2) {
          return { _: "contacts.topPeers", categories: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3039597469: function(r2) {
          return { _: "contacts.topPeersDisabled" };
        },
        453805082: function(r2) {
          var flags = r2.uint();
          return { _: "draftMessageEmpty", date: flags & 1 ? r2.int() : void 0 };
        },
        761606687: function(r2) {
          var flags = r2.uint();
          return { _: "draftMessage", noWebpage: !!(flags & 2), invertMedia: !!(flags & 64), replyTo: flags & 16 ? r2.object() : void 0, message: r2.string(), entities: flags & 8 ? r2.vector(r2.object) : void 0, media: flags & 32 ? r2.object() : void 0, date: r2.int(), effect: flags & 128 ? r2.long() : void 0 };
        },
        3336309862: function(r2) {
          return { _: "messages.featuredStickersNotModified", count: r2.int() };
        },
        3191351558: function(r2) {
          var flags = r2.uint();
          return { _: "messages.featuredStickers", premium: !!(flags & 1), hash: r2.long(), count: r2.int(), sets: r2.vector(r2.object), unread: r2.vector(r2.long) };
        },
        186120336: function(r2) {
          return { _: "messages.recentStickersNotModified" };
        },
        2295561302: function(r2) {
          return { _: "messages.recentStickers", hash: r2.long(), packs: r2.vector(r2.object), stickers: r2.vector(r2.object), dates: r2.vector(r2.int) };
        },
        1338747336: function(r2) {
          return { _: "messages.archivedStickers", count: r2.int(), sets: r2.vector(r2.object) };
        },
        946083368: function(r2) {
          return { _: "messages.stickerSetInstallResultSuccess" };
        },
        904138920: function(r2) {
          return { _: "messages.stickerSetInstallResultArchive", sets: r2.vector(r2.object) };
        },
        1678812626: function(r2) {
          return { _: "stickerSetCovered", set: r2.object(), cover: r2.object() };
        },
        872932635: function(r2) {
          return { _: "stickerSetMultiCovered", set: r2.object(), covers: r2.vector(r2.object) };
        },
        1087454222: function(r2) {
          return { _: "stickerSetFullCovered", set: r2.object(), packs: r2.vector(r2.object), keywords: r2.vector(r2.object), documents: r2.vector(r2.object) };
        },
        2008112412: function(r2) {
          return { _: "stickerSetNoCovered", set: r2.object() };
        },
        2933316530: function(r2) {
          return { _: "maskCoords", n: r2.int(), x: r2.double(), y: r2.double(), zoom: r2.double() };
        },
        1251549527: function(r2) {
          return { _: "inputStickeredMediaPhoto", id: r2.object() };
        },
        70813275: function(r2) {
          return { _: "inputStickeredMediaDocument", id: r2.object() };
        },
        3187238203: function(r2) {
          var flags = r2.uint();
          return { _: "game", id: r2.long(), accessHash: r2.long(), shortName: r2.string(), title: r2.string(), description: r2.string(), photo: r2.object(), document: flags & 1 ? r2.object() : void 0 };
        },
        53231223: function(r2) {
          return { _: "inputGameID", id: r2.long(), accessHash: r2.long() };
        },
        3274827786: function(r2) {
          return { _: "inputGameShortName", botId: r2.object(), shortName: r2.string() };
        },
        1940093419: function(r2) {
          return { _: "highScore", pos: r2.int(), userId: r2.int53(), score: r2.int() };
        },
        2587622809: function(r2) {
          return { _: "messages.highScores", scores: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3695018575: function(r2) {
          return { _: "textEmpty" };
        },
        1950782688: function(r2) {
          return { _: "textPlain", text: r2.string() };
        },
        1730456516: function(r2) {
          return { _: "textBold", text: r2.object() };
        },
        3641877916: function(r2) {
          return { _: "textItalic", text: r2.object() };
        },
        3240501956: function(r2) {
          return { _: "textUnderline", text: r2.object() };
        },
        2616769429: function(r2) {
          return { _: "textStrike", text: r2.object() };
        },
        1816074681: function(r2) {
          return { _: "textFixed", text: r2.object() };
        },
        1009288385: function(r2) {
          return { _: "textUrl", text: r2.object(), url: r2.string(), webpageId: r2.long() };
        },
        3730443734: function(r2) {
          return { _: "textEmail", text: r2.object(), email: r2.string() };
        },
        2120376535: function(r2) {
          return { _: "textConcat", texts: r2.vector(r2.object) };
        },
        3983181060: function(r2) {
          return { _: "textSubscript", text: r2.object() };
        },
        3355139585: function(r2) {
          return { _: "textSuperscript", text: r2.object() };
        },
        55281185: function(r2) {
          return { _: "textMarked", text: r2.object() };
        },
        483104362: function(r2) {
          return { _: "textPhone", text: r2.object(), phone: r2.string() };
        },
        136105807: function(r2) {
          return { _: "textImage", documentId: r2.long(), w: r2.int(), h: r2.int() };
        },
        894777186: function(r2) {
          return { _: "textAnchor", text: r2.object(), name: r2.string() };
        },
        324435594: function(r2) {
          return { _: "pageBlockUnsupported" };
        },
        1890305021: function(r2) {
          return { _: "pageBlockTitle", text: r2.object() };
        },
        2415565343: function(r2) {
          return { _: "pageBlockSubtitle", text: r2.object() };
        },
        3132089824: function(r2) {
          return { _: "pageBlockAuthorDate", author: r2.object(), publishedDate: r2.int() };
        },
        3218105580: function(r2) {
          return { _: "pageBlockHeader", text: r2.object() };
        },
        4046173921: function(r2) {
          return { _: "pageBlockSubheader", text: r2.object() };
        },
        1182402406: function(r2) {
          return { _: "pageBlockParagraph", text: r2.object() };
        },
        3228621118: function(r2) {
          return { _: "pageBlockPreformatted", text: r2.object(), language: r2.string() };
        },
        1216809369: function(r2) {
          return { _: "pageBlockFooter", text: r2.object() };
        },
        3676352904: function(r2) {
          return { _: "pageBlockDivider" };
        },
        3456972720: function(r2) {
          return { _: "pageBlockAnchor", name: r2.string() };
        },
        3840442385: function(r2) {
          return { _: "pageBlockList", items: r2.vector(r2.object) };
        },
        641563686: function(r2) {
          return { _: "pageBlockBlockquote", text: r2.object(), caption: r2.object() };
        },
        1329878739: function(r2) {
          return { _: "pageBlockPullquote", text: r2.object(), caption: r2.object() };
        },
        391759200: function(r2) {
          var flags = r2.uint();
          return { _: "pageBlockPhoto", photoId: r2.long(), caption: r2.object(), url: flags & 1 ? r2.string() : void 0, webpageId: flags & 1 ? r2.long() : void 0 };
        },
        2089805750: function(r2) {
          var flags = r2.uint();
          return { _: "pageBlockVideo", autoplay: !!(flags & 1), loop: !!(flags & 2), videoId: r2.long(), caption: r2.object() };
        },
        972174080: function(r2) {
          return { _: "pageBlockCover", cover: r2.object() };
        },
        2826014149: function(r2) {
          var flags = r2.uint();
          return { _: "pageBlockEmbed", fullWidth: !!(flags & 1), allowScrolling: !!(flags & 8), url: flags & 2 ? r2.string() : void 0, html: flags & 4 ? r2.string() : void 0, posterPhotoId: flags & 16 ? r2.long() : void 0, w: flags & 32 ? r2.int() : void 0, h: flags & 32 ? r2.int() : void 0, caption: r2.object() };
        },
        4065961995: function(r2) {
          return { _: "pageBlockEmbedPost", url: r2.string(), webpageId: r2.long(), authorPhotoId: r2.long(), author: r2.string(), date: r2.int(), blocks: r2.vector(r2.object), caption: r2.object() };
        },
        1705048653: function(r2) {
          return { _: "pageBlockCollage", items: r2.vector(r2.object), caption: r2.object() };
        },
        52401552: function(r2) {
          return { _: "pageBlockSlideshow", items: r2.vector(r2.object), caption: r2.object() };
        },
        4011282869: function(r2) {
          return { _: "pageBlockChannel", channel: r2.object() };
        },
        2151899626: function(r2) {
          return { _: "pageBlockAudio", audioId: r2.long(), caption: r2.object() };
        },
        504660880: function(r2) {
          return { _: "pageBlockKicker", text: r2.object() };
        },
        3209554562: function(r2) {
          var flags = r2.uint();
          return { _: "pageBlockTable", bordered: !!(flags & 1), striped: !!(flags & 2), title: r2.object(), rows: r2.vector(r2.object) };
        },
        2592793057: function(r2) {
          return { _: "pageBlockOrderedList", items: r2.vector(r2.object) };
        },
        1987480557: function(r2) {
          var flags = r2.uint();
          return { _: "pageBlockDetails", open: !!(flags & 1), blocks: r2.vector(r2.object), title: r2.object() };
        },
        370236054: function(r2) {
          return { _: "pageBlockRelatedArticles", title: r2.object(), articles: r2.vector(r2.object) };
        },
        2756656886: function(r2) {
          return { _: "pageBlockMap", geo: r2.object(), zoom: r2.int(), w: r2.int(), h: r2.int(), caption: r2.object() };
        },
        2246320897: function(r2) {
          return { _: "phoneCallDiscardReasonMissed" };
        },
        3767910816: function(r2) {
          return { _: "phoneCallDiscardReasonDisconnect" };
        },
        1471006352: function(r2) {
          return { _: "phoneCallDiscardReasonHangup" };
        },
        4210550985: function(r2) {
          return { _: "phoneCallDiscardReasonBusy" };
        },
        2104790276: function(r2) {
          return { _: "dataJSON", data: r2.string() };
        },
        3408489464: function(r2) {
          return { _: "labeledPrice", label: r2.string(), amount: r2.long() };
        },
        1572428309: function(r2) {
          var flags = r2.uint();
          return { _: "invoice", test: !!(flags & 1), nameRequested: !!(flags & 2), phoneRequested: !!(flags & 4), emailRequested: !!(flags & 8), shippingAddressRequested: !!(flags & 16), flexible: !!(flags & 32), phoneToProvider: !!(flags & 64), emailToProvider: !!(flags & 128), recurring: !!(flags & 512), currency: r2.string(), prices: r2.vector(r2.object), maxTipAmount: flags & 256 ? r2.long() : void 0, suggestedTipAmounts: flags & 256 ? r2.vector(r2.long) : void 0, termsUrl: flags & 1024 ? r2.string() : void 0 };
        },
        3926049406: function(r2) {
          return { _: "paymentCharge", id: r2.string(), providerChargeId: r2.string() };
        },
        512535275: function(r2) {
          return { _: "postAddress", streetLine1: r2.string(), streetLine2: r2.string(), city: r2.string(), state: r2.string(), countryIso2: r2.string(), postCode: r2.string() };
        },
        2426158996: function(r2) {
          var flags = r2.uint();
          return { _: "paymentRequestedInfo", name: flags & 1 ? r2.string() : void 0, phone: flags & 2 ? r2.string() : void 0, email: flags & 4 ? r2.string() : void 0, shippingAddress: flags & 8 ? r2.object() : void 0 };
        },
        3452074527: function(r2) {
          return { _: "paymentSavedCredentialsCard", id: r2.string(), title: r2.string() };
        },
        475467473: function(r2) {
          return { _: "webDocument", url: r2.string(), accessHash: r2.long(), size: r2.int(), mimeType: r2.string(), attributes: r2.vector(r2.object) };
        },
        4190682310: function(r2) {
          return { _: "webDocumentNoProxy", url: r2.string(), size: r2.int(), mimeType: r2.string(), attributes: r2.vector(r2.object) };
        },
        2616017741: function(r2) {
          return { _: "inputWebDocument", url: r2.string(), size: r2.int(), mimeType: r2.string(), attributes: r2.vector(r2.object) };
        },
        3258570374: function(r2) {
          return { _: "inputWebFileLocation", url: r2.string(), accessHash: r2.long() };
        },
        2669814217: function(r2) {
          return { _: "inputWebFileGeoPointLocation", geoPoint: r2.object(), accessHash: r2.long(), w: r2.int(), h: r2.int(), zoom: r2.int(), scale: r2.int() };
        },
        4100974884: function(r2) {
          var flags = r2.uint();
          return { _: "inputWebFileAudioAlbumThumbLocation", small: !!(flags & 4), document: flags & 1 ? r2.object() : void 0, title: flags & 2 ? r2.string() : void 0, performer: flags & 2 ? r2.string() : void 0 };
        },
        568808380: function(r2) {
          return { _: "upload.webFile", size: r2.int(), mimeType: r2.string(), fileType: r2.object(), mtime: r2.int(), bytes: r2.bytes() };
        },
        2684716881: function(r2) {
          var flags = r2.uint();
          return { _: "payments.paymentForm", canSaveCredentials: !!(flags & 4), passwordMissing: !!(flags & 8), formId: r2.long(), botId: r2.int53(), title: r2.string(), description: r2.string(), photo: flags & 32 ? r2.object() : void 0, invoice: r2.object(), providerId: r2.long(), url: r2.string(), nativeProvider: flags & 16 ? r2.string() : void 0, nativeParams: flags & 16 ? r2.object() : void 0, additionalMethods: flags & 64 ? r2.vector(r2.object) : void 0, savedInfo: flags & 1 ? r2.object() : void 0, savedCredentials: flags & 2 ? r2.vector(r2.object) : void 0, users: r2.vector(r2.object) };
        },
        2079764828: function(r2) {
          var flags = r2.uint();
          return { _: "payments.paymentFormStars", formId: r2.long(), botId: r2.int53(), title: r2.string(), description: r2.string(), photo: flags & 32 ? r2.object() : void 0, invoice: r2.object(), users: r2.vector(r2.object) };
        },
        3022376929: function(r2) {
          return { _: "payments.paymentFormStarGift", formId: r2.long(), invoice: r2.object() };
        },
        3510966403: function(r2) {
          var flags = r2.uint();
          return { _: "payments.validatedRequestedInfo", id: flags & 1 ? r2.string() : void 0, shippingOptions: flags & 2 ? r2.vector(r2.object) : void 0 };
        },
        1314881805: function(r2) {
          return { _: "payments.paymentResult", updates: r2.object() };
        },
        3628142905: function(r2) {
          return { _: "payments.paymentVerificationNeeded", url: r2.string() };
        },
        1891958275: function(r2) {
          var flags = r2.uint();
          return { _: "payments.paymentReceipt", date: r2.int(), botId: r2.int53(), providerId: r2.long(), title: r2.string(), description: r2.string(), photo: flags & 4 ? r2.object() : void 0, invoice: r2.object(), info: flags & 1 ? r2.object() : void 0, shipping: flags & 2 ? r2.object() : void 0, tipAmount: flags & 8 ? r2.long() : void 0, currency: r2.string(), totalAmount: r2.long(), credentialsTitle: r2.string(), users: r2.vector(r2.object) };
        },
        3669751866: function(r2) {
          var flags = r2.uint();
          return { _: "payments.paymentReceiptStars", date: r2.int(), botId: r2.int53(), title: r2.string(), description: r2.string(), photo: flags & 4 ? r2.object() : void 0, invoice: r2.object(), currency: r2.string(), totalAmount: r2.long(), transactionId: r2.string(), users: r2.vector(r2.object) };
        },
        4220511292: function(r2) {
          var flags = r2.uint();
          return { _: "payments.savedInfo", hasSavedCredentials: !!(flags & 2), savedInfo: flags & 1 ? r2.object() : void 0 };
        },
        3238965967: function(r2) {
          return { _: "inputPaymentCredentialsSaved", id: r2.string(), tmpPassword: r2.bytes() };
        },
        873977640: function(r2) {
          var flags = r2.uint();
          return { _: "inputPaymentCredentials", save: !!(flags & 1), data: r2.object() };
        },
        178373535: function(r2) {
          return { _: "inputPaymentCredentialsApplePay", paymentData: r2.object() };
        },
        2328045569: function(r2) {
          return { _: "inputPaymentCredentialsGooglePay", paymentToken: r2.object() };
        },
        3680828724: function(r2) {
          return { _: "account.tmpPassword", tmpPassword: r2.bytes(), validUntil: r2.int() };
        },
        3055631583: function(r2) {
          return { _: "shippingOption", id: r2.string(), title: r2.string(), prices: r2.vector(r2.object) };
        },
        853188252: function(r2) {
          var flags = r2.uint();
          return { _: "inputStickerSetItem", document: r2.object(), emoji: r2.string(), maskCoords: flags & 1 ? r2.object() : void 0, keywords: flags & 2 ? r2.string() : void 0 };
        },
        506920429: function(r2) {
          return { _: "inputPhoneCall", id: r2.long(), accessHash: r2.long() };
        },
        1399245077: function(r2) {
          return { _: "phoneCallEmpty", id: r2.long() };
        },
        3307368215: function(r2) {
          var flags = r2.uint();
          return { _: "phoneCallWaiting", video: !!(flags & 64), id: r2.long(), accessHash: r2.long(), date: r2.int(), adminId: r2.int53(), participantId: r2.int53(), protocol: r2.object(), receiveDate: flags & 1 ? r2.int() : void 0 };
        },
        347139340: function(r2) {
          var flags = r2.uint();
          return { _: "phoneCallRequested", video: !!(flags & 64), id: r2.long(), accessHash: r2.long(), date: r2.int(), adminId: r2.int53(), participantId: r2.int53(), gAHash: r2.bytes(), protocol: r2.object() };
        },
        912311057: function(r2) {
          var flags = r2.uint();
          return { _: "phoneCallAccepted", video: !!(flags & 64), id: r2.long(), accessHash: r2.long(), date: r2.int(), adminId: r2.int53(), participantId: r2.int53(), gB: r2.bytes(), protocol: r2.object() };
        },
        810769141: function(r2) {
          var flags = r2.uint();
          return { _: "phoneCall", p2pAllowed: !!(flags & 32), video: !!(flags & 64), id: r2.long(), accessHash: r2.long(), date: r2.int(), adminId: r2.int53(), participantId: r2.int53(), gAOrB: r2.bytes(), keyFingerprint: r2.long(), protocol: r2.object(), connections: r2.vector(r2.object), startDate: r2.int(), customParameters: flags & 128 ? r2.object() : void 0 };
        },
        1355435489: function(r2) {
          var flags = r2.uint();
          return { _: "phoneCallDiscarded", needRating: !!(flags & 4), needDebug: !!(flags & 8), video: !!(flags & 64), id: r2.long(), reason: flags & 1 ? r2.object() : void 0, duration: flags & 2 ? r2.int() : void 0 };
        },
        2629903303: function(r2) {
          var flags = r2.uint();
          return { _: "phoneConnection", tcp: !!(flags & 1), id: r2.long(), ip: r2.string(), ipv6: r2.string(), port: r2.int(), peerTag: r2.bytes() };
        },
        1667228533: function(r2) {
          var flags = r2.uint();
          return { _: "phoneConnectionWebrtc", turn: !!(flags & 1), stun: !!(flags & 2), id: r2.long(), ip: r2.string(), ipv6: r2.string(), port: r2.int(), username: r2.string(), password: r2.string() };
        },
        4236742600: function(r2) {
          var flags = r2.uint();
          return { _: "phoneCallProtocol", udpP2p: !!(flags & 1), udpReflector: !!(flags & 2), minLayer: r2.int(), maxLayer: r2.int(), libraryVersions: r2.vector(r2.string) };
        },
        3968000320: function(r2) {
          return { _: "phone.phoneCall", phoneCall: r2.object(), users: r2.vector(r2.object) };
        },
        4004045934: function(r2) {
          return { _: "upload.cdnFileReuploadNeeded", requestToken: r2.bytes() };
        },
        2845821519: function(r2) {
          return { _: "upload.cdnFile", bytes: r2.bytes() };
        },
        3380800186: function(r2) {
          return { _: "cdnPublicKey", dcId: r2.int(), publicKey: r2.string() };
        },
        1462101002: function(r2) {
          return { _: "cdnConfig", publicKeys: r2.vector(r2.object) };
        },
        3402727926: function(r2) {
          return { _: "langPackString", key: r2.string(), value: r2.string() };
        },
        1816636575: function(r2) {
          var flags = r2.uint();
          return { _: "langPackStringPluralized", key: r2.string(), zeroValue: flags & 1 ? r2.string() : void 0, oneValue: flags & 2 ? r2.string() : void 0, twoValue: flags & 4 ? r2.string() : void 0, fewValue: flags & 8 ? r2.string() : void 0, manyValue: flags & 16 ? r2.string() : void 0, otherValue: r2.string() };
        },
        695856818: function(r2) {
          return { _: "langPackStringDeleted", key: r2.string() };
        },
        4085629430: function(r2) {
          return { _: "langPackDifference", langCode: r2.string(), fromVersion: r2.int(), version: r2.int(), strings: r2.vector(r2.object) };
        },
        4006239459: function(r2) {
          var flags = r2.uint();
          return { _: "langPackLanguage", official: !!(flags & 1), rtl: !!(flags & 4), beta: !!(flags & 8), name: r2.string(), nativeName: r2.string(), langCode: r2.string(), baseLangCode: flags & 2 ? r2.string() : void 0, pluralCode: r2.string(), stringsCount: r2.int(), translatedCount: r2.int(), translationsUrl: r2.string() };
        },
        3873421349: function(r2) {
          return { _: "channelAdminLogEventActionChangeTitle", prevValue: r2.string(), newValue: r2.string() };
        },
        1427671598: function(r2) {
          return { _: "channelAdminLogEventActionChangeAbout", prevValue: r2.string(), newValue: r2.string() };
        },
        1783299128: function(r2) {
          return { _: "channelAdminLogEventActionChangeUsername", prevValue: r2.string(), newValue: r2.string() };
        },
        1129042607: function(r2) {
          return { _: "channelAdminLogEventActionChangePhoto", prevPhoto: r2.object(), newPhoto: r2.object() };
        },
        460916654: function(r2) {
          return { _: "channelAdminLogEventActionToggleInvites", newValue: r2.boolean() };
        },
        648939889: function(r2) {
          return { _: "channelAdminLogEventActionToggleSignatures", newValue: r2.boolean() };
        },
        3924306968: function(r2) {
          return { _: "channelAdminLogEventActionUpdatePinned", message: r2.object() };
        },
        1889215493: function(r2) {
          return { _: "channelAdminLogEventActionEditMessage", prevMessage: r2.object(), newMessage: r2.object() };
        },
        1121994683: function(r2) {
          return { _: "channelAdminLogEventActionDeleteMessage", message: r2.object() };
        },
        405815507: function(r2) {
          return { _: "channelAdminLogEventActionParticipantJoin" };
        },
        4170676210: function(r2) {
          return { _: "channelAdminLogEventActionParticipantLeave" };
        },
        3810276568: function(r2) {
          return { _: "channelAdminLogEventActionParticipantInvite", participant: r2.object() };
        },
        3872931198: function(r2) {
          return { _: "channelAdminLogEventActionParticipantToggleBan", prevParticipant: r2.object(), newParticipant: r2.object() };
        },
        3580323600: function(r2) {
          return { _: "channelAdminLogEventActionParticipantToggleAdmin", prevParticipant: r2.object(), newParticipant: r2.object() };
        },
        2982398631: function(r2) {
          return { _: "channelAdminLogEventActionChangeStickerSet", prevStickerset: r2.object(), newStickerset: r2.object() };
        },
        1599903217: function(r2) {
          return { _: "channelAdminLogEventActionTogglePreHistoryHidden", newValue: r2.boolean() };
        },
        771095562: function(r2) {
          return { _: "channelAdminLogEventActionDefaultBannedRights", prevBannedRights: r2.object(), newBannedRights: r2.object() };
        },
        2399639107: function(r2) {
          return { _: "channelAdminLogEventActionStopPoll", message: r2.object() };
        },
        84703944: function(r2) {
          return { _: "channelAdminLogEventActionChangeLinkedChat", prevValue: r2.int53(), newValue: r2.int53() };
        },
        241923758: function(r2) {
          return { _: "channelAdminLogEventActionChangeLocation", prevValue: r2.object(), newValue: r2.object() };
        },
        1401984889: function(r2) {
          return { _: "channelAdminLogEventActionToggleSlowMode", prevValue: r2.int(), newValue: r2.int() };
        },
        589338437: function(r2) {
          return { _: "channelAdminLogEventActionStartGroupCall", call: r2.object() };
        },
        3684667712: function(r2) {
          return { _: "channelAdminLogEventActionDiscardGroupCall", call: r2.object() };
        },
        4179895506: function(r2) {
          return { _: "channelAdminLogEventActionParticipantMute", participant: r2.object() };
        },
        3863226816: function(r2) {
          return { _: "channelAdminLogEventActionParticipantUnmute", participant: r2.object() };
        },
        1456906823: function(r2) {
          return { _: "channelAdminLogEventActionToggleGroupCallSetting", joinMuted: r2.boolean() };
        },
        4271882584: function(r2) {
          var flags = r2.uint();
          return { _: "channelAdminLogEventActionParticipantJoinByInvite", viaChatlist: !!(flags & 1), invite: r2.object() };
        },
        1515256996: function(r2) {
          return { _: "channelAdminLogEventActionExportedInviteDelete", invite: r2.object() };
        },
        1091179342: function(r2) {
          return { _: "channelAdminLogEventActionExportedInviteRevoke", invite: r2.object() };
        },
        3910056793: function(r2) {
          return { _: "channelAdminLogEventActionExportedInviteEdit", prevInvite: r2.object(), newInvite: r2.object() };
        },
        1048537159: function(r2) {
          return { _: "channelAdminLogEventActionParticipantVolume", participant: r2.object() };
        },
        1855199800: function(r2) {
          return { _: "channelAdminLogEventActionChangeHistoryTTL", prevValue: r2.int(), newValue: r2.int() };
        },
        2947945546: function(r2) {
          return { _: "channelAdminLogEventActionParticipantJoinByRequest", invite: r2.object(), approvedBy: r2.int53() };
        },
        3408578406: function(r2) {
          return { _: "channelAdminLogEventActionToggleNoForwards", newValue: r2.boolean() };
        },
        663693416: function(r2) {
          return { _: "channelAdminLogEventActionSendMessage", message: r2.object() };
        },
        3192786680: function(r2) {
          return { _: "channelAdminLogEventActionChangeAvailableReactions", prevValue: r2.object(), newValue: r2.object() };
        },
        4031755177: function(r2) {
          return { _: "channelAdminLogEventActionChangeUsernames", prevValue: r2.vector(r2.string), newValue: r2.vector(r2.string) };
        },
        46949251: function(r2) {
          return { _: "channelAdminLogEventActionToggleForum", newValue: r2.boolean() };
        },
        1483767080: function(r2) {
          return { _: "channelAdminLogEventActionCreateTopic", topic: r2.object() };
        },
        4033864200: function(r2) {
          return { _: "channelAdminLogEventActionEditTopic", prevTopic: r2.object(), newTopic: r2.object() };
        },
        2920712457: function(r2) {
          return { _: "channelAdminLogEventActionDeleteTopic", topic: r2.object() };
        },
        1569535291: function(r2) {
          var flags = r2.uint();
          return { _: "channelAdminLogEventActionPinTopic", prevTopic: flags & 1 ? r2.object() : void 0, newTopic: flags & 2 ? r2.object() : void 0 };
        },
        1693675004: function(r2) {
          return { _: "channelAdminLogEventActionToggleAntiSpam", newValue: r2.boolean() };
        },
        1469507456: function(r2) {
          return { _: "channelAdminLogEventActionChangePeerColor", prevValue: r2.object(), newValue: r2.object() };
        },
        1581742885: function(r2) {
          return { _: "channelAdminLogEventActionChangeProfilePeerColor", prevValue: r2.object(), newValue: r2.object() };
        },
        834362706: function(r2) {
          return { _: "channelAdminLogEventActionChangeWallpaper", prevValue: r2.object(), newValue: r2.object() };
        },
        1051328177: function(r2) {
          return { _: "channelAdminLogEventActionChangeEmojiStatus", prevValue: r2.object(), newValue: r2.object() };
        },
        1188577451: function(r2) {
          return { _: "channelAdminLogEventActionChangeEmojiStickerSet", prevStickerset: r2.object(), newStickerset: r2.object() };
        },
        1621597305: function(r2) {
          return { _: "channelAdminLogEventActionToggleSignatureProfiles", newValue: r2.boolean() };
        },
        1684286899: function(r2) {
          return { _: "channelAdminLogEventActionParticipantSubExtend", prevParticipant: r2.object(), newParticipant: r2.object() };
        },
        531458253: function(r2) {
          return { _: "channelAdminLogEvent", id: r2.long(), date: r2.int(), userId: r2.int53(), action: r2.object() };
        },
        3985307469: function(r2) {
          return { _: "channels.adminLogResults", events: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3926948580: function(r2) {
          var flags = r2.uint();
          return { _: "channelAdminLogEventsFilter", join: !!(flags & 1), leave: !!(flags & 2), invite: !!(flags & 4), ban: !!(flags & 8), unban: !!(flags & 16), kick: !!(flags & 32), unkick: !!(flags & 64), promote: !!(flags & 128), demote: !!(flags & 256), info: !!(flags & 512), settings: !!(flags & 1024), pinned: !!(flags & 2048), edit: !!(flags & 4096), delete: !!(flags & 8192), groupCall: !!(flags & 16384), invites: !!(flags & 32768), send: !!(flags & 65536), forums: !!(flags & 131072), subExtend: !!(flags & 262144) };
        },
        1558266229: function(r2) {
          return { _: "popularContact", clientId: r2.long(), importers: r2.int() };
        },
        2660214483: function(r2) {
          return { _: "messages.favedStickersNotModified" };
        },
        750063767: function(r2) {
          return { _: "messages.favedStickers", hash: r2.long(), packs: r2.vector(r2.object), stickers: r2.vector(r2.object) };
        },
        1189204285: function(r2) {
          return { _: "recentMeUrlUnknown", url: r2.string() };
        },
        3106671074: function(r2) {
          return { _: "recentMeUrlUser", url: r2.string(), userId: r2.int53() };
        },
        3000660434: function(r2) {
          return { _: "recentMeUrlChat", url: r2.string(), chatId: r2.int53() };
        },
        3947431965: function(r2) {
          return { _: "recentMeUrlChatInvite", url: r2.string(), chatInvite: r2.object() };
        },
        3154794460: function(r2) {
          return { _: "recentMeUrlStickerSet", url: r2.string(), set: r2.object() };
        },
        235081943: function(r2) {
          return { _: "help.recentMeUrls", urls: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        482797855: function(r2) {
          var flags = r2.uint();
          return { _: "inputSingleMedia", media: r2.object(), randomId: r2.long(), message: r2.string(), entities: flags & 1 ? r2.vector(r2.object) : void 0 };
        },
        2801333330: function(r2) {
          return { _: "webAuthorization", hash: r2.long(), botId: r2.int53(), domain: r2.string(), browser: r2.string(), platform: r2.string(), dateCreated: r2.int(), dateActive: r2.int(), ip: r2.string(), region: r2.string() };
        },
        3981887996: function(r2) {
          return { _: "account.webAuthorizations", authorizations: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2792792866: function(r2) {
          return { _: "inputMessageID", id: r2.int() };
        },
        3134751637: function(r2) {
          return { _: "inputMessageReplyTo", id: r2.int() };
        },
        2257003832: function(r2) {
          return { _: "inputMessagePinned" };
        },
        2902071934: function(r2) {
          return { _: "inputMessageCallbackQuery", id: r2.int(), queryId: r2.long() };
        },
        4239064759: function(r2) {
          return { _: "inputDialogPeer", peer: r2.object() };
        },
        1684014375: function(r2) {
          return { _: "inputDialogPeerFolder", folderId: r2.int() };
        },
        3849174789: function(r2) {
          return { _: "dialogPeer", peer: r2.object() };
        },
        1363483106: function(r2) {
          return { _: "dialogPeerFolder", folderId: r2.int() };
        },
        223655517: function(r2) {
          return { _: "messages.foundStickerSetsNotModified" };
        },
        2331024850: function(r2) {
          return { _: "messages.foundStickerSets", hash: r2.long(), sets: r2.vector(r2.object) };
        },
        4087022428: function(r2) {
          return { _: "fileHash", offset: r2.int53(), limit: r2.int(), hash: r2.bytes() };
        },
        1968737087: function(r2) {
          return { _: "inputClientProxy", address: r2.string(), port: r2.int() };
        },
        3811614591: function(r2) {
          return { _: "help.termsOfServiceUpdateEmpty", expires: r2.int() };
        },
        686618977: function(r2) {
          return { _: "help.termsOfServiceUpdate", expires: r2.int(), termsOfService: r2.object() };
        },
        859091184: function(r2) {
          return { _: "inputSecureFileUploaded", id: r2.long(), parts: r2.int(), md5Checksum: r2.string(), fileHash: r2.bytes(), secret: r2.bytes() };
        },
        1399317950: function(r2) {
          return { _: "inputSecureFile", id: r2.long(), accessHash: r2.long() };
        },
        1679398724: function(r2) {
          return { _: "secureFileEmpty" };
        },
        2097791614: function(r2) {
          return { _: "secureFile", id: r2.long(), accessHash: r2.long(), size: r2.int53(), dcId: r2.int(), date: r2.int(), fileHash: r2.bytes(), secret: r2.bytes() };
        },
        2330640067: function(r2) {
          return { _: "secureData", data: r2.bytes(), dataHash: r2.bytes(), secret: r2.bytes() };
        },
        2103482845: function(r2) {
          return { _: "securePlainPhone", phone: r2.string() };
        },
        569137759: function(r2) {
          return { _: "securePlainEmail", email: r2.string() };
        },
        2636808675: function(r2) {
          return { _: "secureValueTypePersonalDetails" };
        },
        1034709504: function(r2) {
          return { _: "secureValueTypePassport" };
        },
        115615172: function(r2) {
          return { _: "secureValueTypeDriverLicense" };
        },
        2698015819: function(r2) {
          return { _: "secureValueTypeIdentityCard" };
        },
        2577698595: function(r2) {
          return { _: "secureValueTypeInternalPassport" };
        },
        3420659238: function(r2) {
          return { _: "secureValueTypeAddress" };
        },
        4231435598: function(r2) {
          return { _: "secureValueTypeUtilityBill" };
        },
        2299755533: function(r2) {
          return { _: "secureValueTypeBankStatement" };
        },
        2340959368: function(r2) {
          return { _: "secureValueTypeRentalAgreement" };
        },
        2581823594: function(r2) {
          return { _: "secureValueTypePassportRegistration" };
        },
        3926060083: function(r2) {
          return { _: "secureValueTypeTemporaryRegistration" };
        },
        3005262555: function(r2) {
          return { _: "secureValueTypePhone" };
        },
        2386339822: function(r2) {
          return { _: "secureValueTypeEmail" };
        },
        411017418: function(r2) {
          var flags = r2.uint();
          return { _: "secureValue", type: r2.object(), data: flags & 1 ? r2.object() : void 0, frontSide: flags & 2 ? r2.object() : void 0, reverseSide: flags & 4 ? r2.object() : void 0, selfie: flags & 8 ? r2.object() : void 0, translation: flags & 64 ? r2.vector(r2.object) : void 0, files: flags & 16 ? r2.vector(r2.object) : void 0, plainData: flags & 32 ? r2.object() : void 0, hash: r2.bytes() };
        },
        3676426407: function(r2) {
          var flags = r2.uint();
          return { _: "inputSecureValue", type: r2.object(), data: flags & 1 ? r2.object() : void 0, frontSide: flags & 2 ? r2.object() : void 0, reverseSide: flags & 4 ? r2.object() : void 0, selfie: flags & 8 ? r2.object() : void 0, translation: flags & 64 ? r2.vector(r2.object) : void 0, files: flags & 16 ? r2.vector(r2.object) : void 0, plainData: flags & 32 ? r2.object() : void 0 };
        },
        3978218928: function(r2) {
          return { _: "secureValueHash", type: r2.object(), hash: r2.bytes() };
        },
        3903065049: function(r2) {
          return { _: "secureValueErrorData", type: r2.object(), dataHash: r2.bytes(), field: r2.string(), text: r2.string() };
        },
        12467706: function(r2) {
          return { _: "secureValueErrorFrontSide", type: r2.object(), fileHash: r2.bytes(), text: r2.string() };
        },
        2257201829: function(r2) {
          return { _: "secureValueErrorReverseSide", type: r2.object(), fileHash: r2.bytes(), text: r2.string() };
        },
        3845639894: function(r2) {
          return { _: "secureValueErrorSelfie", type: r2.object(), fileHash: r2.bytes(), text: r2.string() };
        },
        2054162547: function(r2) {
          return { _: "secureValueErrorFile", type: r2.object(), fileHash: r2.bytes(), text: r2.string() };
        },
        1717706985: function(r2) {
          return { _: "secureValueErrorFiles", type: r2.object(), fileHash: r2.vector(r2.bytes), text: r2.string() };
        },
        2258466191: function(r2) {
          return { _: "secureValueError", type: r2.object(), hash: r2.bytes(), text: r2.string() };
        },
        2702460784: function(r2) {
          return { _: "secureValueErrorTranslationFile", type: r2.object(), fileHash: r2.bytes(), text: r2.string() };
        },
        878931416: function(r2) {
          return { _: "secureValueErrorTranslationFiles", type: r2.object(), fileHash: r2.vector(r2.bytes), text: r2.string() };
        },
        871426631: function(r2) {
          return { _: "secureCredentialsEncrypted", data: r2.bytes(), hash: r2.bytes(), secret: r2.bytes() };
        },
        2905480408: function(r2) {
          var flags = r2.uint();
          return { _: "account.authorizationForm", requiredTypes: r2.vector(r2.object), values: r2.vector(r2.object), errors: r2.vector(r2.object), users: r2.vector(r2.object), privacyPolicyUrl: flags & 1 ? r2.string() : void 0 };
        },
        2166326607: function(r2) {
          return { _: "account.sentEmailCode", emailPattern: r2.string(), length: r2.int() };
        },
        1722786150: function(r2) {
          return { _: "help.deepLinkInfoEmpty" };
        },
        1783556146: function(r2) {
          var flags = r2.uint();
          return { _: "help.deepLinkInfo", updateApp: !!(flags & 1), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0 };
        },
        289586518: function(r2) {
          return { _: "savedPhoneContact", phone: r2.string(), firstName: r2.string(), lastName: r2.string(), date: r2.int() };
        },
        1304052993: function(r2) {
          return { _: "account.takeout", id: r2.long() };
        },
        3562713238: function(r2) {
          return { _: "passwordKdfAlgoUnknown" };
        },
        982592842: function(r2) {
          return { _: "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow", salt1: r2.bytes(), salt2: r2.bytes(), g: r2.int(), p: r2.bytes() };
        },
        4883767: function(r2) {
          return { _: "securePasswordKdfAlgoUnknown" };
        },
        3153255840: function(r2) {
          return { _: "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000", salt: r2.bytes() };
        },
        2252807570: function(r2) {
          return { _: "securePasswordKdfAlgoSHA512", salt: r2.bytes() };
        },
        354925740: function(r2) {
          return { _: "secureSecretSettings", secureAlgo: r2.object(), secureSecret: r2.bytes(), secureSecretId: r2.long() };
        },
        2558588504: function(r2) {
          return { _: "inputCheckPasswordEmpty" };
        },
        3531600002: function(r2) {
          return { _: "inputCheckPasswordSRP", srpId: r2.long(), A: r2.bytes(), M1: r2.bytes() };
        },
        2191366618: function(r2) {
          var flags = r2.uint();
          return { _: "secureRequiredType", nativeNames: !!(flags & 1), selfieRequired: !!(flags & 2), translationRequired: !!(flags & 4), type: r2.object() };
        },
        41187252: function(r2) {
          return { _: "secureRequiredTypeOneOf", types: r2.vector(r2.object) };
        },
        3216634967: function(r2) {
          return { _: "help.passportConfigNotModified" };
        },
        2694370991: function(r2) {
          return { _: "help.passportConfig", hash: r2.int(), countriesLangs: r2.object() };
        },
        488313413: function(r2) {
          return { _: "inputAppEvent", time: r2.double(), type: r2.string(), peer: r2.long(), data: r2.object() };
        },
        3235781593: function(r2) {
          return { _: "jsonObjectValue", key: r2.string(), value: r2.object() };
        },
        1064139624: function(r2) {
          return { _: "jsonNull" };
        },
        3342098026: function(r2) {
          return { _: "jsonBool", value: r2.boolean() };
        },
        736157604: function(r2) {
          return { _: "jsonNumber", value: r2.double() };
        },
        3072226938: function(r2) {
          return { _: "jsonString", value: r2.string() };
        },
        4148447075: function(r2) {
          return { _: "jsonArray", value: r2.vector(r2.object) };
        },
        2579616925: function(r2) {
          return { _: "jsonObject", value: r2.vector(r2.object) };
        },
        878078826: function(r2) {
          var flags = r2.uint();
          return { _: "pageTableCell", header: !!(flags & 1), alignCenter: !!(flags & 8), alignRight: !!(flags & 16), valignMiddle: !!(flags & 32), valignBottom: !!(flags & 64), text: flags & 128 ? r2.object() : void 0, colspan: flags & 2 ? r2.int() : void 0, rowspan: flags & 4 ? r2.int() : void 0 };
        },
        3770729957: function(r2) {
          return { _: "pageTableRow", cells: r2.vector(r2.object) };
        },
        1869903447: function(r2) {
          return { _: "pageCaption", text: r2.object(), credit: r2.object() };
        },
        3106911949: function(r2) {
          return { _: "pageListItemText", text: r2.object() };
        },
        635466748: function(r2) {
          return { _: "pageListItemBlocks", blocks: r2.vector(r2.object) };
        },
        1577484359: function(r2) {
          return { _: "pageListOrderedItemText", num: r2.string(), text: r2.object() };
        },
        2564655414: function(r2) {
          return { _: "pageListOrderedItemBlocks", num: r2.string(), blocks: r2.vector(r2.object) };
        },
        3012615176: function(r2) {
          var flags = r2.uint();
          return { _: "pageRelatedArticle", url: r2.string(), webpageId: r2.long(), title: flags & 1 ? r2.string() : void 0, description: flags & 2 ? r2.string() : void 0, photoId: flags & 4 ? r2.long() : void 0, author: flags & 8 ? r2.string() : void 0, publishedDate: flags & 16 ? r2.int() : void 0 };
        },
        2556788493: function(r2) {
          var flags = r2.uint();
          return { _: "page", part: !!(flags & 1), rtl: !!(flags & 2), v2: !!(flags & 4), url: r2.string(), blocks: r2.vector(r2.object), photos: r2.vector(r2.object), documents: r2.vector(r2.object), views: flags & 8 ? r2.int() : void 0 };
        },
        2349199817: function(r2) {
          return { _: "help.supportName", name: r2.string() };
        },
        4088278765: function(r2) {
          return { _: "help.userInfoEmpty" };
        },
        32192344: function(r2) {
          return { _: "help.userInfo", message: r2.string(), entities: r2.vector(r2.object), author: r2.string(), date: r2.int() };
        },
        4279689930: function(r2) {
          return { _: "pollAnswer", text: r2.object(), option: r2.bytes() };
        },
        1484026161: function(r2) {
          var id2 = r2.long(), flags = r2.uint();
          return { _: "poll", id: id2, closed: !!(flags & 1), publicVoters: !!(flags & 2), multipleChoice: !!(flags & 4), quiz: !!(flags & 8), question: r2.object(), answers: r2.vector(r2.object), closePeriod: flags & 16 ? r2.int() : void 0, closeDate: flags & 32 ? r2.int() : void 0 };
        },
        997055186: function(r2) {
          var flags = r2.uint();
          return { _: "pollAnswerVoters", chosen: !!(flags & 1), correct: !!(flags & 2), option: r2.bytes(), voters: r2.int() };
        },
        2061444128: function(r2) {
          var flags = r2.uint();
          return { _: "pollResults", min: !!(flags & 1), results: flags & 2 ? r2.vector(r2.object) : void 0, totalVoters: flags & 4 ? r2.int() : void 0, recentVoters: flags & 8 ? r2.vector(r2.object) : void 0, solution: flags & 16 ? r2.string() : void 0, solutionEntities: flags & 16 ? r2.vector(r2.object) : void 0 };
        },
        4030849616: function(r2) {
          return { _: "chatOnlines", onlines: r2.int() };
        },
        1202287072: function(r2) {
          return { _: "statsURL", url: r2.string() };
        },
        1605510357: function(r2) {
          var flags = r2.uint();
          return { _: "chatAdminRights", changeInfo: !!(flags & 1), postMessages: !!(flags & 2), editMessages: !!(flags & 4), deleteMessages: !!(flags & 8), banUsers: !!(flags & 16), inviteUsers: !!(flags & 32), pinMessages: !!(flags & 128), addAdmins: !!(flags & 512), anonymous: !!(flags & 1024), manageCall: !!(flags & 2048), other: !!(flags & 4096), manageTopics: !!(flags & 8192), postStories: !!(flags & 16384), editStories: !!(flags & 32768), deleteStories: !!(flags & 65536) };
        },
        2668758040: function(r2) {
          var flags = r2.uint();
          return { _: "chatBannedRights", viewMessages: !!(flags & 1), sendMessages: !!(flags & 2), sendMedia: !!(flags & 4), sendStickers: !!(flags & 8), sendGifs: !!(flags & 16), sendGames: !!(flags & 32), sendInline: !!(flags & 64), embedLinks: !!(flags & 128), sendPolls: !!(flags & 256), changeInfo: !!(flags & 1024), inviteUsers: !!(flags & 32768), pinMessages: !!(flags & 131072), manageTopics: !!(flags & 262144), sendPhotos: !!(flags & 524288), sendVideos: !!(flags & 1048576), sendRoundvideos: !!(flags & 2097152), sendAudios: !!(flags & 4194304), sendVoices: !!(flags & 8388608), sendDocs: !!(flags & 16777216), sendPlain: !!(flags & 33554432), untilDate: r2.int() };
        },
        3861952889: function(r2) {
          return { _: "inputWallPaper", id: r2.long(), accessHash: r2.long() };
        },
        1913199744: function(r2) {
          return { _: "inputWallPaperSlug", slug: r2.string() };
        },
        2524595758: function(r2) {
          return { _: "inputWallPaperNoFile", id: r2.long() };
        },
        471437699: function(r2) {
          return { _: "account.wallPapersNotModified" };
        },
        3452142988: function(r2) {
          return { _: "account.wallPapers", hash: r2.long(), wallpapers: r2.vector(r2.object) };
        },
        2904898936: function(r2) {
          var flags = r2.uint();
          return { _: "codeSettings", allowFlashcall: !!(flags & 1), currentNumber: !!(flags & 2), allowAppHash: !!(flags & 16), allowMissedCall: !!(flags & 32), allowFirebase: !!(flags & 128), unknownNumber: !!(flags & 512), logoutTokens: flags & 64 ? r2.vector(r2.bytes) : void 0, token: flags & 256 ? r2.string() : void 0, appSandbox: flags & 256 ? r2.boolean() : void 0 };
        },
        925826256: function(r2) {
          var flags = r2.uint();
          return { _: "wallPaperSettings", blur: !!(flags & 2), motion: !!(flags & 4), backgroundColor: flags & 1 ? r2.int() : void 0, secondBackgroundColor: flags & 16 ? r2.int() : void 0, thirdBackgroundColor: flags & 32 ? r2.int() : void 0, fourthBackgroundColor: flags & 64 ? r2.int() : void 0, intensity: flags & 8 ? r2.int() : void 0, rotation: flags & 16 ? r2.int() : void 0, emoticon: flags & 128 ? r2.string() : void 0 };
        },
        3131405864: function(r2) {
          var flags = r2.uint();
          return { _: "autoDownloadSettings", disabled: !!(flags & 1), videoPreloadLarge: !!(flags & 2), audioPreloadNext: !!(flags & 4), phonecallsLessData: !!(flags & 8), storiesPreload: !!(flags & 16), photoSizeMax: r2.int(), videoSizeMax: r2.int53(), fileSizeMax: r2.int53(), videoUploadMaxbitrate: r2.int(), smallQueueActiveOperationsMax: r2.int(), largeQueueActiveOperationsMax: r2.int() };
        },
        1674235686: function(r2) {
          return { _: "account.autoDownloadSettings", low: r2.object(), medium: r2.object(), high: r2.object() };
        },
        3585325561: function(r2) {
          return { _: "emojiKeyword", keyword: r2.string(), emoticons: r2.vector(r2.string) };
        },
        594408994: function(r2) {
          return { _: "emojiKeywordDeleted", keyword: r2.string(), emoticons: r2.vector(r2.string) };
        },
        1556570557: function(r2) {
          return { _: "emojiKeywordsDifference", langCode: r2.string(), fromVersion: r2.int(), version: r2.int(), keywords: r2.vector(r2.object) };
        },
        2775937949: function(r2) {
          return { _: "emojiURL", url: r2.string() };
        },
        3019592545: function(r2) {
          return { _: "emojiLanguage", langCode: r2.string() };
        },
        4283715173: function(r2) {
          var flags = r2.uint();
          return { _: "folder", autofillNewBroadcasts: !!(flags & 1), autofillPublicGroups: !!(flags & 2), autofillNewCorrespondents: !!(flags & 4), id: r2.int(), title: r2.string(), photo: flags & 8 ? r2.object() : void 0 };
        },
        4224893590: function(r2) {
          return { _: "inputFolderPeer", peer: r2.object(), folderId: r2.int() };
        },
        3921323624: function(r2) {
          return { _: "folderPeer", peer: r2.object(), folderId: r2.int() };
        },
        3896830975: function(r2) {
          var flags = r2.uint();
          return { _: "messages.searchCounter", inexact: !!(flags & 2), filter: r2.object(), count: r2.int() };
        },
        2463316494: function(r2) {
          var flags = r2.uint();
          return { _: "urlAuthResultRequest", requestWriteAccess: !!(flags & 1), bot: r2.object(), domain: r2.string() };
        },
        2408320590: function(r2) {
          return { _: "urlAuthResultAccepted", url: r2.string() };
        },
        2849430303: function(r2) {
          return { _: "urlAuthResultDefault" };
        },
        3216354699: function(r2) {
          return { _: "channelLocationEmpty" };
        },
        547062491: function(r2) {
          return { _: "channelLocation", geoPoint: r2.object(), address: r2.string() };
        },
        3393592157: function(r2) {
          return { _: "peerLocated", peer: r2.object(), expires: r2.int(), distance: r2.int() };
        },
        4176226379: function(r2) {
          return { _: "peerSelfLocated", expires: r2.int() };
        },
        3497176244: function(r2) {
          return { _: "restrictionReason", platform: r2.string(), reason: r2.string(), text: r2.string() };
        },
        1012306921: function(r2) {
          return { _: "inputTheme", id: r2.long(), accessHash: r2.long() };
        },
        4119399921: function(r2) {
          return { _: "inputThemeSlug", slug: r2.string() };
        },
        2685298646: function(r2) {
          var flags = r2.uint();
          return { _: "theme", creator: !!(flags & 1), default: !!(flags & 2), forChat: !!(flags & 32), id: r2.long(), accessHash: r2.long(), slug: r2.string(), title: r2.string(), document: flags & 4 ? r2.object() : void 0, settings: flags & 8 ? r2.vector(r2.object) : void 0, emoticon: flags & 64 ? r2.string() : void 0, installsCount: flags & 16 ? r2.int() : void 0 };
        },
        4095653410: function(r2) {
          return { _: "account.themesNotModified" };
        },
        2587724909: function(r2) {
          return { _: "account.themes", hash: r2.long(), themes: r2.vector(r2.object) };
        },
        1654593920: function(r2) {
          return { _: "auth.loginToken", expires: r2.int(), token: r2.bytes() };
        },
        110008598: function(r2) {
          return { _: "auth.loginTokenMigrateTo", dcId: r2.int(), token: r2.bytes() };
        },
        957176926: function(r2) {
          return { _: "auth.loginTokenSuccess", authorization: r2.object() };
        },
        1474462241: function(r2) {
          var flags = r2.uint();
          return { _: "account.contentSettings", sensitiveEnabled: !!(flags & 1), sensitiveCanChange: !!(flags & 2) };
        },
        2837970629: function(r2) {
          return { _: "messages.inactiveChats", dates: r2.vector(r2.int), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3282117730: function(r2) {
          return { _: "baseThemeClassic" };
        },
        4225242760: function(r2) {
          return { _: "baseThemeDay" };
        },
        3081969320: function(r2) {
          return { _: "baseThemeNight" };
        },
        1834973166: function(r2) {
          return { _: "baseThemeTinted" };
        },
        1527845466: function(r2) {
          return { _: "baseThemeArctic" };
        },
        2413711439: function(r2) {
          var flags = r2.uint();
          return { _: "inputThemeSettings", messageColorsAnimated: !!(flags & 4), baseTheme: r2.object(), accentColor: r2.int(), outboxAccentColor: flags & 8 ? r2.int() : void 0, messageColors: flags & 1 ? r2.vector(r2.int) : void 0, wallpaper: flags & 2 ? r2.object() : void 0, wallpaperSettings: flags & 2 ? r2.object() : void 0 };
        },
        4200117972: function(r2) {
          var flags = r2.uint();
          return { _: "themeSettings", messageColorsAnimated: !!(flags & 4), baseTheme: r2.object(), accentColor: r2.int(), outboxAccentColor: flags & 8 ? r2.int() : void 0, messageColors: flags & 1 ? r2.vector(r2.int) : void 0, wallpaper: flags & 2 ? r2.object() : void 0 };
        },
        1421174295: function(r2) {
          var flags = r2.uint();
          return { _: "webPageAttributeTheme", documents: flags & 1 ? r2.vector(r2.object) : void 0, settings: flags & 2 ? r2.object() : void 0 };
        },
        781501415: function(r2) {
          var flags = r2.uint();
          return { _: "webPageAttributeStory", peer: r2.object(), id: r2.int(), story: flags & 1 ? r2.object() : void 0 };
        },
        1355547603: function(r2) {
          var flags = r2.uint();
          return { _: "webPageAttributeStickerSet", emojis: !!(flags & 1), textColor: !!(flags & 2), stickers: r2.vector(r2.object) };
        },
        1218005070: function(r2) {
          var flags = r2.uint();
          return { _: "messages.votesList", count: r2.int(), votes: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0 };
        },
        4117234314: function(r2) {
          return { _: "bankCardOpenUrl", url: r2.string(), name: r2.string() };
        },
        1042605427: function(r2) {
          return { _: "payments.bankCardData", title: r2.string(), openUrls: r2.vector(r2.object) };
        },
        1605718587: function(r2) {
          var flags = r2.uint();
          return { _: "dialogFilter", contacts: !!(flags & 1), nonContacts: !!(flags & 2), groups: !!(flags & 4), broadcasts: !!(flags & 8), bots: !!(flags & 16), excludeMuted: !!(flags & 2048), excludeRead: !!(flags & 4096), excludeArchived: !!(flags & 8192), id: r2.int(), title: r2.string(), emoticon: flags & 33554432 ? r2.string() : void 0, color: flags & 134217728 ? r2.int() : void 0, pinnedPeers: r2.vector(r2.object), includePeers: r2.vector(r2.object), excludePeers: r2.vector(r2.object) };
        },
        909284270: function(r2) {
          return { _: "dialogFilterDefault" };
        },
        2682424996: function(r2) {
          var flags = r2.uint();
          return { _: "dialogFilterChatlist", hasMyInvites: !!(flags & 67108864), id: r2.int(), title: r2.string(), emoticon: flags & 33554432 ? r2.string() : void 0, color: flags & 134217728 ? r2.int() : void 0, pinnedPeers: r2.vector(r2.object), includePeers: r2.vector(r2.object) };
        },
        2004110666: function(r2) {
          return { _: "dialogFilterSuggested", filter: r2.object(), description: r2.string() };
        },
        3057118639: function(r2) {
          return { _: "statsDateRangeDays", minDate: r2.int(), maxDate: r2.int() };
        },
        3410210014: function(r2) {
          return { _: "statsAbsValueAndPrev", current: r2.double(), previous: r2.double() };
        },
        3419287520: function(r2) {
          return { _: "statsPercentValue", part: r2.double(), total: r2.double() };
        },
        1244130093: function(r2) {
          return { _: "statsGraphAsync", token: r2.string() };
        },
        3202127906: function(r2) {
          return { _: "statsGraphError", error: r2.string() };
        },
        2393138358: function(r2) {
          var flags = r2.uint();
          return { _: "statsGraph", json: r2.object(), zoomToken: flags & 1 ? r2.string() : void 0 };
        },
        963421692: function(r2) {
          return { _: "stats.broadcastStats", period: r2.object(), followers: r2.object(), viewsPerPost: r2.object(), sharesPerPost: r2.object(), reactionsPerPost: r2.object(), viewsPerStory: r2.object(), sharesPerStory: r2.object(), reactionsPerStory: r2.object(), enabledNotifications: r2.object(), growthGraph: r2.object(), followersGraph: r2.object(), muteGraph: r2.object(), topHoursGraph: r2.object(), interactionsGraph: r2.object(), ivInteractionsGraph: r2.object(), viewsBySourceGraph: r2.object(), newFollowersBySourceGraph: r2.object(), languagesGraph: r2.object(), reactionsByEmotionGraph: r2.object(), storyInteractionsGraph: r2.object(), storyReactionsByEmotionGraph: r2.object(), recentPostsInteractions: r2.vector(r2.object) };
        },
        2566302837: function(r2) {
          return { _: "help.promoDataEmpty", expires: r2.int() };
        },
        2352576831: function(r2) {
          var flags = r2.uint();
          return { _: "help.promoData", proxy: !!(flags & 1), expires: r2.int(), peer: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object), psaType: flags & 2 ? r2.string() : void 0, psaMessage: flags & 4 ? r2.string() : void 0 };
        },
        3727929492: function(r2) {
          var flags = r2.uint();
          return { _: "videoSize", type: r2.string(), w: r2.int(), h: r2.int(), size: r2.int(), videoStartTs: flags & 1 ? r2.double() : void 0 };
        },
        4166795580: function(r2) {
          return { _: "videoSizeEmojiMarkup", emojiId: r2.long(), backgroundColors: r2.vector(r2.int) };
        },
        228623102: function(r2) {
          return { _: "videoSizeStickerMarkup", stickerset: r2.object(), stickerId: r2.long(), backgroundColors: r2.vector(r2.int) };
        },
        2634330011: function(r2) {
          return { _: "statsGroupTopPoster", userId: r2.int53(), messages: r2.int(), avgChars: r2.int() };
        },
        3612888199: function(r2) {
          return { _: "statsGroupTopAdmin", userId: r2.int53(), deleted: r2.int(), kicked: r2.int(), banned: r2.int() };
        },
        1398765469: function(r2) {
          return { _: "statsGroupTopInviter", userId: r2.int53(), invitations: r2.int() };
        },
        4018141462: function(r2) {
          return { _: "stats.megagroupStats", period: r2.object(), members: r2.object(), messages: r2.object(), viewers: r2.object(), posters: r2.object(), growthGraph: r2.object(), membersGraph: r2.object(), newMembersBySourceGraph: r2.object(), languagesGraph: r2.object(), messagesGraph: r2.object(), actionsGraph: r2.object(), topHoursGraph: r2.object(), weekdaysGraph: r2.object(), topPosters: r2.vector(r2.object), topAdmins: r2.vector(r2.object), topInviters: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1934380235: function(r2) {
          var flags = r2.uint();
          return { _: "globalPrivacySettings", archiveAndMuteNewNoncontactPeers: !!(flags & 1), keepArchivedUnmuted: !!(flags & 2), keepArchivedFolders: !!(flags & 4), hideReadMarks: !!(flags & 8), newNoncontactPeersRequirePremium: !!(flags & 16) };
        },
        1107543535: function(r2) {
          var flags = r2.uint();
          return { _: "help.countryCode", countryCode: r2.string(), prefixes: flags & 1 ? r2.vector(r2.string) : void 0, patterns: flags & 2 ? r2.vector(r2.string) : void 0 };
        },
        3280440867: function(r2) {
          var flags = r2.uint();
          return { _: "help.country", hidden: !!(flags & 1), iso2: r2.string(), defaultName: r2.string(), name: flags & 2 ? r2.string() : void 0, countryCodes: r2.vector(r2.object) };
        },
        2479628082: function(r2) {
          return { _: "help.countriesListNotModified" };
        },
        2278585758: function(r2) {
          return { _: "help.countriesList", countries: r2.vector(r2.object), hash: r2.int() };
        },
        1163625789: function(r2) {
          var flags = r2.uint();
          return { _: "messageViews", views: flags & 1 ? r2.int() : void 0, forwards: flags & 2 ? r2.int() : void 0, replies: flags & 4 ? r2.object() : void 0 };
        },
        3066361155: function(r2) {
          return { _: "messages.messageViews", views: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2788431746: function(r2) {
          var flags = r2.uint();
          return { _: "messages.discussionMessage", messages: r2.vector(r2.object), maxId: flags & 1 ? r2.int() : void 0, readInboxMaxId: flags & 2 ? r2.int() : void 0, readOutboxMaxId: flags & 4 ? r2.int() : void 0, unreadCount: r2.int(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2948336091: function(r2) {
          var flags = r2.uint();
          return { _: "messageReplyHeader", replyToScheduled: !!(flags & 4), forumTopic: !!(flags & 8), quote: !!(flags & 512), replyToMsgId: flags & 16 ? r2.int() : void 0, replyToPeerId: flags & 1 ? r2.object() : void 0, replyFrom: flags & 32 ? r2.object() : void 0, replyMedia: flags & 256 ? r2.object() : void 0, replyToTopId: flags & 2 ? r2.int() : void 0, quoteText: flags & 64 ? r2.string() : void 0, quoteEntities: flags & 128 ? r2.vector(r2.object) : void 0, quoteOffset: flags & 1024 ? r2.int() : void 0 };
        },
        240843065: function(r2) {
          return { _: "messageReplyStoryHeader", peer: r2.object(), storyId: r2.int() };
        },
        2211844034: function(r2) {
          var flags = r2.uint();
          return { _: "messageReplies", comments: !!(flags & 1), replies: r2.int(), repliesPts: r2.int(), recentRepliers: flags & 2 ? r2.vector(r2.object) : void 0, channelId: flags & 1 ? r2.int53() : void 0, maxId: flags & 4 ? r2.int() : void 0, readMaxId: flags & 8 ? r2.int() : void 0 };
        },
        3908927508: function(r2) {
          return { _: "peerBlocked", peerId: r2.object(), date: r2.int() };
        },
        2145983508: function(r2) {
          return { _: "stats.messageStats", viewsGraph: r2.object(), reactionsByEmotionGraph: r2.object() };
        },
        2004925620: function(r2) {
          return { _: "groupCallDiscarded", id: r2.long(), accessHash: r2.long(), duration: r2.int() };
        },
        3583468812: function(r2) {
          var flags = r2.uint();
          return { _: "groupCall", joinMuted: !!(flags & 2), canChangeJoinMuted: !!(flags & 4), joinDateAsc: !!(flags & 64), scheduleStartSubscribed: !!(flags & 256), canStartVideo: !!(flags & 512), recordVideoActive: !!(flags & 2048), rtmpStream: !!(flags & 4096), listenersHidden: !!(flags & 8192), id: r2.long(), accessHash: r2.long(), participantsCount: r2.int(), title: flags & 8 ? r2.string() : void 0, streamDcId: flags & 16 ? r2.int() : void 0, recordStartDate: flags & 32 ? r2.int() : void 0, scheduleDate: flags & 128 ? r2.int() : void 0, unmutedVideoCount: flags & 1024 ? r2.int() : void 0, unmutedVideoLimit: r2.int(), version: r2.int() };
        },
        3635053583: function(r2) {
          return { _: "inputGroupCall", id: r2.long(), accessHash: r2.long() };
        },
        3953538814: function(r2) {
          var flags = r2.uint();
          return { _: "groupCallParticipant", muted: !!(flags & 1), left: !!(flags & 2), canSelfUnmute: !!(flags & 4), justJoined: !!(flags & 16), versioned: !!(flags & 32), min: !!(flags & 256), mutedByYou: !!(flags & 512), volumeByAdmin: !!(flags & 1024), self: !!(flags & 4096), videoJoined: !!(flags & 32768), peer: r2.object(), date: r2.int(), activeDate: flags & 8 ? r2.int() : void 0, source: r2.int(), volume: flags & 128 ? r2.int() : void 0, about: flags & 2048 ? r2.string() : void 0, raiseHandRating: flags & 8192 ? r2.long() : void 0, video: flags & 64 ? r2.object() : void 0, presentation: flags & 16384 ? r2.object() : void 0 };
        },
        2658302637: function(r2) {
          return { _: "phone.groupCall", call: r2.object(), participants: r2.vector(r2.object), participantsNextOffset: r2.string(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        4101460406: function(r2) {
          return { _: "phone.groupParticipants", count: r2.int(), participants: r2.vector(r2.object), nextOffset: r2.string(), chats: r2.vector(r2.object), users: r2.vector(r2.object), version: r2.int() };
        },
        813821341: function(r2) {
          return { _: "inlineQueryPeerTypeSameBotPM" };
        },
        2201751468: function(r2) {
          return { _: "inlineQueryPeerTypePM" };
        },
        3613836554: function(r2) {
          return { _: "inlineQueryPeerTypeChat" };
        },
        1589952067: function(r2) {
          return { _: "inlineQueryPeerTypeMegagroup" };
        },
        1664413338: function(r2) {
          return { _: "inlineQueryPeerTypeBroadcast" };
        },
        238759180: function(r2) {
          return { _: "inlineQueryPeerTypeBotPM" };
        },
        375566091: function(r2) {
          return { _: "messages.historyImport", id: r2.long() };
        },
        1578088377: function(r2) {
          var flags = r2.uint();
          return { _: "messages.historyImportParsed", pm: !!(flags & 1), group: !!(flags & 2), title: flags & 4 ? r2.string() : void 0 };
        },
        4019011180: function(r2) {
          return { _: "messages.affectedFoundMessages", pts: r2.int(), ptsCount: r2.int(), offset: r2.int(), messages: r2.vector(r2.int) };
        },
        2354765785: function(r2) {
          var flags = r2.uint();
          return { _: "chatInviteImporter", requested: !!(flags & 1), viaChatlist: !!(flags & 8), userId: r2.int53(), date: r2.int(), about: flags & 4 ? r2.string() : void 0, approvedBy: flags & 2 ? r2.int53() : void 0 };
        },
        3183881676: function(r2) {
          return { _: "messages.exportedChatInvites", count: r2.int(), invites: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        410107472: function(r2) {
          return { _: "messages.exportedChatInvite", invite: r2.object(), users: r2.vector(r2.object) };
        },
        572915951: function(r2) {
          return { _: "messages.exportedChatInviteReplaced", invite: r2.object(), newInvite: r2.object(), users: r2.vector(r2.object) };
        },
        2176233482: function(r2) {
          return { _: "messages.chatInviteImporters", count: r2.int(), importers: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        4075613987: function(r2) {
          return { _: "chatAdminWithInvites", adminId: r2.int53(), invitesCount: r2.int(), revokedInvitesCount: r2.int() };
        },
        3063640791: function(r2) {
          return { _: "messages.chatAdminsWithInvites", admins: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2723014423: function(r2) {
          return { _: "messages.checkedHistoryImportPeer", confirmText: r2.string() };
        },
        2951045695: function(r2) {
          return { _: "phone.joinAsPeers", peers: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        541839704: function(r2) {
          return { _: "phone.exportedGroupCallInvite", link: r2.string() };
        },
        3702593719: function(r2) {
          return { _: "groupCallParticipantVideoSourceGroup", semantics: r2.string(), sources: r2.vector(r2.int) };
        },
        1735736008: function(r2) {
          var flags = r2.uint();
          return { _: "groupCallParticipantVideo", paused: !!(flags & 1), endpoint: r2.string(), sourceGroups: r2.vector(r2.object), audioSource: flags & 2 ? r2.int() : void 0 };
        },
        2248056895: function(r2) {
          return { _: "stickers.suggestedShortName", shortName: r2.string() };
        },
        795652779: function(r2) {
          return { _: "botCommandScopeDefault" };
        },
        1011811544: function(r2) {
          return { _: "botCommandScopeUsers" };
        },
        1877059713: function(r2) {
          return { _: "botCommandScopeChats" };
        },
        3114950762: function(r2) {
          return { _: "botCommandScopeChatAdmins" };
        },
        3684534653: function(r2) {
          return { _: "botCommandScopePeer", peer: r2.object() };
        },
        1071145937: function(r2) {
          return { _: "botCommandScopePeerAdmins", peer: r2.object() };
        },
        169026035: function(r2) {
          return { _: "botCommandScopePeerUser", peer: r2.object(), userId: r2.object() };
        },
        3816265825: function(r2) {
          return { _: "account.resetPasswordFailedWait", retryDate: r2.int() };
        },
        3924819069: function(r2) {
          return { _: "account.resetPasswordRequestedWait", untilDate: r2.int() };
        },
        3911636542: function(r2) {
          return { _: "account.resetPasswordOk" };
        },
        1301522832: function(r2) {
          var flags = r2.uint();
          return { _: "sponsoredMessage", recommended: !!(flags & 32), canReport: !!(flags & 4096), randomId: r2.bytes(), url: r2.string(), title: r2.string(), message: r2.string(), entities: flags & 2 ? r2.vector(r2.object) : void 0, photo: flags & 64 ? r2.object() : void 0, media: flags & 16384 ? r2.object() : void 0, color: flags & 8192 ? r2.object() : void 0, buttonText: r2.string(), sponsorInfo: flags & 128 ? r2.string() : void 0, additionalInfo: flags & 256 ? r2.string() : void 0 };
        },
        3387825543: function(r2) {
          var flags = r2.uint();
          return { _: "messages.sponsoredMessages", postsBetween: flags & 1 ? r2.int() : void 0, messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        406407439: function(r2) {
          return { _: "messages.sponsoredMessagesEmpty" };
        },
        3383776159: function(r2) {
          return { _: "searchResultsCalendarPeriod", date: r2.int(), minMsgId: r2.int(), maxMsgId: r2.int(), count: r2.int() };
        },
        343859772: function(r2) {
          var flags = r2.uint();
          return { _: "messages.searchResultsCalendar", inexact: !!(flags & 1), count: r2.int(), minDate: r2.int(), minMsgId: r2.int(), offsetIdOffset: flags & 2 ? r2.int() : void 0, periods: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2137295719: function(r2) {
          return { _: "searchResultPosition", msgId: r2.int(), date: r2.int(), offset: r2.int() };
        },
        1404185519: function(r2) {
          return { _: "messages.searchResultsPositions", count: r2.int(), positions: r2.vector(r2.object) };
        },
        4103516358: function(r2) {
          return { _: "channels.sendAsPeers", peers: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        997004590: function(r2) {
          return { _: "users.userFull", fullUser: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1753266509: function(r2) {
          return { _: "messages.peerSettings", settings: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3282207583: function(r2) {
          var flags = r2.uint();
          return { _: "auth.loggedOut", futureAuthToken: flags & 1 ? r2.bytes() : void 0 };
        },
        2748435328: function(r2) {
          var flags = r2.uint();
          return { _: "reactionCount", chosenOrder: flags & 1 ? r2.int() : void 0, reaction: r2.object(), count: r2.int() };
        },
        171155211: function(r2) {
          var flags = r2.uint();
          return { _: "messageReactions", min: !!(flags & 1), canSeeList: !!(flags & 4), reactionsAsTags: !!(flags & 8), results: r2.vector(r2.object), recentReactions: flags & 2 ? r2.vector(r2.object) : void 0, topReactors: flags & 16 ? r2.vector(r2.object) : void 0 };
        },
        834488621: function(r2) {
          var flags = r2.uint();
          return { _: "messages.messageReactionsList", count: r2.int(), reactions: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0 };
        },
        3229084673: function(r2) {
          var flags = r2.uint();
          return { _: "availableReaction", inactive: !!(flags & 1), premium: !!(flags & 4), reaction: r2.string(), title: r2.string(), staticIcon: r2.object(), appearAnimation: r2.object(), selectAnimation: r2.object(), activateAnimation: r2.object(), effectAnimation: r2.object(), aroundAnimation: flags & 2 ? r2.object() : void 0, centerIcon: flags & 2 ? r2.object() : void 0 };
        },
        2668042583: function(r2) {
          return { _: "messages.availableReactionsNotModified" };
        },
        1989032621: function(r2) {
          return { _: "messages.availableReactions", hash: r2.int(), reactions: r2.vector(r2.object) };
        },
        2356786748: function(r2) {
          var flags = r2.uint();
          return { _: "messagePeerReaction", big: !!(flags & 1), unread: !!(flags & 2), my: !!(flags & 4), peerId: r2.object(), date: r2.int(), reaction: r2.object() };
        },
        2162903215: function(r2) {
          return { _: "groupCallStreamChannel", channel: r2.int(), scale: r2.int(), lastTimestampMs: r2.long() };
        },
        3504636594: function(r2) {
          return { _: "phone.groupCallStreamChannels", channels: r2.vector(r2.object) };
        },
        767505458: function(r2) {
          return { _: "phone.groupCallStreamRtmpUrl", url: r2.string(), key: r2.string() };
        },
        1165423600: function(r2) {
          return { _: "attachMenuBotIconColor", name: r2.string(), color: r2.int() };
        },
        2997303403: function(r2) {
          var flags = r2.uint();
          return { _: "attachMenuBotIcon", name: r2.string(), icon: r2.object(), colors: flags & 1 ? r2.vector(r2.object) : void 0 };
        },
        3641544190: function(r2) {
          var flags = r2.uint();
          return { _: "attachMenuBot", inactive: !!(flags & 1), hasSettings: !!(flags & 2), requestWriteAccess: !!(flags & 4), showInAttachMenu: !!(flags & 8), showInSideMenu: !!(flags & 16), sideMenuDisclaimerNeeded: !!(flags & 32), botId: r2.int53(), shortName: r2.string(), peerTypes: flags & 8 ? r2.vector(r2.object) : void 0, icons: r2.vector(r2.object) };
        },
        4057500252: function(r2) {
          return { _: "attachMenuBotsNotModified" };
        },
        1011024320: function(r2) {
          return { _: "attachMenuBots", hash: r2.long(), bots: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2478794367: function(r2) {
          return { _: "attachMenuBotsBot", bot: r2.object(), users: r2.vector(r2.object) };
        },
        1294139288: function(r2) {
          var flags = r2.uint();
          return { _: "webViewResultUrl", fullsize: !!(flags & 2), queryId: flags & 1 ? r2.long() : void 0, url: r2.string() };
        },
        211046684: function(r2) {
          var flags = r2.uint();
          return { _: "webViewMessageSent", msgId: flags & 1 ? r2.object() : void 0 };
        },
        1966318984: function(r2) {
          return { _: "botMenuButtonDefault" };
        },
        1113113093: function(r2) {
          return { _: "botMenuButtonCommands" };
        },
        3350559974: function(r2) {
          return { _: "botMenuButton", text: r2.string(), url: r2.string() };
        },
        4227262641: function(r2) {
          return { _: "account.savedRingtonesNotModified" };
        },
        3253284037: function(r2) {
          return { _: "account.savedRingtones", hash: r2.long(), ringtones: r2.vector(r2.object) };
        },
        2548612798: function(r2) {
          return { _: "notificationSoundDefault" };
        },
        1863070943: function(r2) {
          return { _: "notificationSoundNone" };
        },
        2198575844: function(r2) {
          return { _: "notificationSoundLocal", title: r2.string(), data: r2.string() };
        },
        4285300809: function(r2) {
          return { _: "notificationSoundRingtone", id: r2.long() };
        },
        3072737133: function(r2) {
          return { _: "account.savedRingtone" };
        },
        523271863: function(r2) {
          return { _: "account.savedRingtoneConverted", document: r2.object() };
        },
        2104224014: function(r2) {
          return { _: "attachMenuPeerTypeSameBotPM" };
        },
        3274439194: function(r2) {
          return { _: "attachMenuPeerTypeBotPM" };
        },
        4047950623: function(r2) {
          return { _: "attachMenuPeerTypePM" };
        },
        84480319: function(r2) {
          return { _: "attachMenuPeerTypeChat" };
        },
        2080104188: function(r2) {
          return { _: "attachMenuPeerTypeBroadcast" };
        },
        3317000281: function(r2) {
          return { _: "inputInvoiceMessage", peer: r2.object(), msgId: r2.int() };
        },
        3274099439: function(r2) {
          return { _: "inputInvoiceSlug", slug: r2.string() };
        },
        2560125965: function(r2) {
          return { _: "inputInvoicePremiumGiftCode", purpose: r2.object(), option: r2.object() };
        },
        1710230755: function(r2) {
          return { _: "inputInvoiceStars", purpose: r2.object() };
        },
        887591921: function(r2) {
          return { _: "inputInvoiceChatInviteSubscription", hash: r2.string() };
        },
        634962392: function(r2) {
          var flags = r2.uint();
          return { _: "inputInvoiceStarGift", hideName: !!(flags & 1), userId: r2.object(), giftId: r2.long(), message: flags & 2 ? r2.object() : void 0 };
        },
        2932919257: function(r2) {
          return { _: "payments.exportedInvoice", url: r2.string() };
        },
        3485063511: function(r2) {
          var flags = r2.uint();
          return { _: "messages.transcribedAudio", pending: !!(flags & 1), transcriptionId: r2.long(), text: r2.string(), trialRemainsNum: flags & 2 ? r2.int() : void 0, trialRemainsUntilDate: flags & 2 ? r2.int() : void 0 };
        },
        1395946908: function(r2) {
          return { _: "help.premiumPromo", statusText: r2.string(), statusEntities: r2.vector(r2.object), videoSections: r2.vector(r2.string), videos: r2.vector(r2.object), periodOptions: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2792693350: function(r2) {
          var flags = r2.uint();
          return { _: "inputStorePaymentPremiumSubscription", restore: !!(flags & 1), upgrade: !!(flags & 2) };
        },
        1634697192: function(r2) {
          return { _: "inputStorePaymentGiftPremium", userId: r2.object(), currency: r2.string(), amount: r2.long() };
        },
        2743099199: function(r2) {
          var flags = r2.uint();
          return { _: "inputStorePaymentPremiumGiftCode", users: r2.vector(r2.object), boostPeer: flags & 1 ? r2.object() : void 0, currency: r2.string(), amount: r2.long() };
        },
        369444042: function(r2) {
          var flags = r2.uint();
          return { _: "inputStorePaymentPremiumGiveaway", onlyNewSubscribers: !!(flags & 1), winnersAreVisible: !!(flags & 8), boostPeer: r2.object(), additionalPeers: flags & 2 ? r2.vector(r2.object) : void 0, countriesIso2: flags & 4 ? r2.vector(r2.string) : void 0, prizeDescription: flags & 16 ? r2.string() : void 0, randomId: r2.long(), untilDate: r2.int(), currency: r2.string(), amount: r2.long() };
        },
        3722252118: function(r2) {
          return { _: "inputStorePaymentStarsTopup", stars: r2.long(), currency: r2.string(), amount: r2.long() };
        },
        494149367: function(r2) {
          return { _: "inputStorePaymentStarsGift", userId: r2.object(), stars: r2.long(), currency: r2.string(), amount: r2.long() };
        },
        1964968186: function(r2) {
          var flags = r2.uint();
          return { _: "inputStorePaymentStarsGiveaway", onlyNewSubscribers: !!(flags & 1), winnersAreVisible: !!(flags & 8), stars: r2.long(), boostPeer: r2.object(), additionalPeers: flags & 2 ? r2.vector(r2.object) : void 0, countriesIso2: flags & 4 ? r2.vector(r2.string) : void 0, prizeDescription: flags & 16 ? r2.string() : void 0, randomId: r2.long(), untilDate: r2.int(), currency: r2.string(), amount: r2.long(), users: r2.int() };
        },
        1958953753: function(r2) {
          var flags = r2.uint();
          return { _: "premiumGiftOption", months: r2.int(), currency: r2.string(), amount: r2.long(), botUrl: r2.string(), storeProduct: flags & 1 ? r2.string() : void 0 };
        },
        2298016283: function(r2) {
          return { _: "paymentFormMethod", url: r2.string(), title: r2.string() };
        },
        769727150: function(r2) {
          return { _: "emojiStatusEmpty" };
        },
        2459656605: function(r2) {
          return { _: "emojiStatus", documentId: r2.long() };
        },
        4197492935: function(r2) {
          return { _: "emojiStatusUntil", documentId: r2.long(), until: r2.int() };
        },
        3498894917: function(r2) {
          return { _: "account.emojiStatusesNotModified" };
        },
        2428790737: function(r2) {
          return { _: "account.emojiStatuses", hash: r2.long(), statuses: r2.vector(r2.object) };
        },
        2046153753: function(r2) {
          return { _: "reactionEmpty" };
        },
        455247544: function(r2) {
          return { _: "reactionEmoji", emoticon: r2.string() };
        },
        2302016627: function(r2) {
          return { _: "reactionCustomEmoji", documentId: r2.long() };
        },
        1379771627: function(r2) {
          return { _: "reactionPaid" };
        },
        3942396604: function(r2) {
          return { _: "chatReactionsNone" };
        },
        1385335754: function(r2) {
          var flags = r2.uint();
          return { _: "chatReactionsAll", allowCustom: !!(flags & 1) };
        },
        1713193015: function(r2) {
          return { _: "chatReactionsSome", reactions: r2.vector(r2.object) };
        },
        2960120799: function(r2) {
          return { _: "messages.reactionsNotModified" };
        },
        3942512406: function(r2) {
          return { _: "messages.reactions", hash: r2.long(), reactions: r2.vector(r2.object) };
        },
        1128644211: function(r2) {
          return { _: "emailVerifyPurposeLoginSetup", phoneNumber: r2.string(), phoneCodeHash: r2.string() };
        },
        1383932651: function(r2) {
          return { _: "emailVerifyPurposeLoginChange" };
        },
        3153401477: function(r2) {
          return { _: "emailVerifyPurposePassport" };
        },
        2452510121: function(r2) {
          return { _: "emailVerificationCode", code: r2.string() };
        },
        3683688130: function(r2) {
          return { _: "emailVerificationGoogle", token: r2.string() };
        },
        2530243837: function(r2) {
          return { _: "emailVerificationApple", token: r2.string() };
        },
        731303195: function(r2) {
          return { _: "account.emailVerified", email: r2.string() };
        },
        3787132257: function(r2) {
          return { _: "account.emailVerifiedLogin", email: r2.string(), sentCode: r2.object() };
        },
        1596792306: function(r2) {
          var flags = r2.uint();
          return { _: "premiumSubscriptionOption", current: !!(flags & 2), canPurchaseUpgrade: !!(flags & 4), transaction: flags & 8 ? r2.string() : void 0, months: r2.int(), currency: r2.string(), amount: r2.long(), botUrl: r2.string(), storeProduct: flags & 1 ? r2.string() : void 0 };
        },
        3088871476: function(r2) {
          var flags = r2.uint();
          return { _: "sendAsPeer", premiumRequired: !!(flags & 1), peer: r2.object() };
        },
        2908916936: function(r2) {
          var flags = r2.uint();
          return { _: "messageExtendedMediaPreview", w: flags & 1 ? r2.int() : void 0, h: flags & 1 ? r2.int() : void 0, thumb: flags & 2 ? r2.object() : void 0, videoDuration: flags & 4 ? r2.int() : void 0 };
        },
        3997670500: function(r2) {
          return { _: "messageExtendedMedia", media: r2.object() };
        },
        4244550300: function(r2) {
          return { _: "stickerKeyword", documentId: r2.long(), keyword: r2.vector(r2.string) };
        },
        3020371527: function(r2) {
          var flags = r2.uint();
          return { _: "username", editable: !!(flags & 1), active: !!(flags & 2), username: r2.string() };
        },
        37687451: function(r2) {
          return { _: "forumTopicDeleted", id: r2.int() };
        },
        1903173033: function(r2) {
          var flags = r2.uint();
          return { _: "forumTopic", my: !!(flags & 2), closed: !!(flags & 4), pinned: !!(flags & 8), short: !!(flags & 32), hidden: !!(flags & 64), id: r2.int(), date: r2.int(), title: r2.string(), iconColor: r2.int(), iconEmojiId: flags & 1 ? r2.long() : void 0, topMessage: r2.int(), readInboxMaxId: r2.int(), readOutboxMaxId: r2.int(), unreadCount: r2.int(), unreadMentionsCount: r2.int(), unreadReactionsCount: r2.int(), fromId: r2.object(), notifySettings: r2.object(), draft: flags & 16 ? r2.object() : void 0 };
        },
        913709011: function(r2) {
          var flags = r2.uint();
          return { _: "messages.forumTopics", orderByCreateDate: !!(flags & 1), count: r2.int(), topics: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), pts: r2.int() };
        },
        1135897376: function(r2) {
          return { _: "defaultHistoryTTL", period: r2.int() };
        },
        1103040667: function(r2) {
          return { _: "exportedContactToken", url: r2.string(), expires: r2.int() };
        },
        1597737472: function(r2) {
          var flags = r2.uint();
          return { _: "requestPeerTypeUser", bot: flags & 1 ? r2.boolean() : void 0, premium: flags & 2 ? r2.boolean() : void 0 };
        },
        3387977243: function(r2) {
          var flags = r2.uint();
          return { _: "requestPeerTypeChat", creator: !!(flags & 1), botParticipant: !!(flags & 32), hasUsername: flags & 8 ? r2.boolean() : void 0, forum: flags & 16 ? r2.boolean() : void 0, userAdminRights: flags & 2 ? r2.object() : void 0, botAdminRights: flags & 4 ? r2.object() : void 0 };
        },
        865857388: function(r2) {
          var flags = r2.uint();
          return { _: "requestPeerTypeBroadcast", creator: !!(flags & 1), hasUsername: flags & 8 ? r2.boolean() : void 0, userAdminRights: flags & 2 ? r2.object() : void 0, botAdminRights: flags & 4 ? r2.object() : void 0 };
        },
        1209970170: function(r2) {
          return { _: "emojiListNotModified" };
        },
        2048790993: function(r2) {
          return { _: "emojiList", hash: r2.long(), documentId: r2.vector(r2.long) };
        },
        2056961449: function(r2) {
          return { _: "emojiGroup", title: r2.string(), iconEmojiId: r2.long(), emoticons: r2.vector(r2.string) };
        },
        2161274055: function(r2) {
          return { _: "emojiGroupGreeting", title: r2.string(), iconEmojiId: r2.long(), emoticons: r2.vector(r2.string) };
        },
        154914612: function(r2) {
          return { _: "emojiGroupPremium", title: r2.string(), iconEmojiId: r2.long() };
        },
        1874111879: function(r2) {
          return { _: "messages.emojiGroupsNotModified" };
        },
        2283780427: function(r2) {
          return { _: "messages.emojiGroups", hash: r2.int(), groups: r2.vector(r2.object) };
        },
        1964978502: function(r2) {
          return { _: "textWithEntities", text: r2.string(), entities: r2.vector(r2.object) };
        },
        870003448: function(r2) {
          return { _: "messages.translateResult", result: r2.vector(r2.object) };
        },
        3360175310: function(r2) {
          var flags = r2.uint();
          return { _: "autoSaveSettings", photos: !!(flags & 1), videos: !!(flags & 2), videoMaxSize: flags & 4 ? r2.long() : void 0 };
        },
        2170563911: function(r2) {
          return { _: "autoSaveException", peer: r2.object(), settings: r2.object() };
        },
        1279133341: function(r2) {
          return { _: "account.autoSaveSettings", usersSettings: r2.object(), chatsSettings: r2.object(), broadcastsSettings: r2.object(), exceptions: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2094949405: function(r2) {
          return { _: "help.appConfigNotModified" };
        },
        3709368366: function(r2) {
          return { _: "help.appConfig", hash: r2.int(), config: r2.object() };
        },
        2837495162: function(r2) {
          return { _: "inputBotAppID", id: r2.long(), accessHash: r2.long() };
        },
        2425095175: function(r2) {
          return { _: "inputBotAppShortName", botId: r2.object(), shortName: r2.string() };
        },
        1571189943: function(r2) {
          return { _: "botAppNotModified" };
        },
        2516373974: function(r2) {
          var flags = r2.uint();
          return { _: "botApp", id: r2.long(), accessHash: r2.long(), shortName: r2.string(), title: r2.string(), description: r2.string(), photo: r2.object(), document: flags & 1 ? r2.object() : void 0, hash: r2.long() };
        },
        3947933173: function(r2) {
          var flags = r2.uint();
          return { _: "messages.botApp", inactive: !!(flags & 1), requestWriteAccess: !!(flags & 2), hasSettings: !!(flags & 4), app: r2.object() };
        },
        3044185557: function(r2) {
          return { _: "inlineBotWebView", text: r2.string(), url: r2.string() };
        },
        1246753138: function(r2) {
          return { _: "readParticipantDate", userId: r2.int53(), date: r2.int() };
        },
        4091599411: function(r2) {
          return { _: "inputChatlistDialogFilter", filterId: r2.int() };
        },
        206668204: function(r2) {
          r2.uint();
          return { _: "exportedChatlistInvite", title: r2.string(), url: r2.string(), peers: r2.vector(r2.object) };
        },
        283567014: function(r2) {
          return { _: "chatlists.exportedChatlistInvite", filter: r2.object(), invite: r2.object() };
        },
        279670215: function(r2) {
          return { _: "chatlists.exportedInvites", invites: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        4203214425: function(r2) {
          return { _: "chatlists.chatlistInviteAlready", filterId: r2.int(), missingPeers: r2.vector(r2.object), alreadyPeers: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        500007837: function(r2) {
          var flags = r2.uint();
          return { _: "chatlists.chatlistInvite", title: r2.string(), emoticon: flags & 1 ? r2.string() : void 0, peers: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2478671757: function(r2) {
          return { _: "chatlists.chatlistUpdates", missingPeers: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3903288752: function(r2) {
          return { _: "bots.botInfo", name: r2.string(), about: r2.string(), description: r2.string() };
        },
        3066834268: function(r2) {
          return { _: "messagePeerVote", peer: r2.object(), option: r2.bytes(), date: r2.int() };
        },
        1959634180: function(r2) {
          return { _: "messagePeerVoteInputOption", peer: r2.object(), date: r2.int() };
        },
        1177089766: function(r2) {
          return { _: "messagePeerVoteMultiple", peer: r2.object(), options: r2.vector(r2.bytes), date: r2.int() };
        },
        2371443926: function(r2) {
          var flags = r2.uint();
          return { _: "storyViews", hasViewers: !!(flags & 2), viewsCount: r2.int(), forwardsCount: flags & 4 ? r2.int() : void 0, reactions: flags & 8 ? r2.vector(r2.object) : void 0, reactionsCount: flags & 16 ? r2.int() : void 0, recentViewers: flags & 1 ? r2.vector(r2.int53) : void 0 };
        },
        1374088783: function(r2) {
          return { _: "storyItemDeleted", id: r2.int() };
        },
        4289579283: function(r2) {
          var flags = r2.uint();
          return { _: "storyItemSkipped", closeFriends: !!(flags & 256), id: r2.int(), date: r2.int(), expireDate: r2.int() };
        },
        2041735716: function(r2) {
          var flags = r2.uint();
          return { _: "storyItem", pinned: !!(flags & 32), public: !!(flags & 128), closeFriends: !!(flags & 256), min: !!(flags & 512), noforwards: !!(flags & 1024), edited: !!(flags & 2048), contacts: !!(flags & 4096), selectedContacts: !!(flags & 8192), out: !!(flags & 65536), id: r2.int(), date: r2.int(), fromId: flags & 262144 ? r2.object() : void 0, fwdFrom: flags & 131072 ? r2.object() : void 0, expireDate: r2.int(), caption: flags & 1 ? r2.string() : void 0, entities: flags & 2 ? r2.vector(r2.object) : void 0, media: r2.object(), mediaAreas: flags & 16384 ? r2.vector(r2.object) : void 0, privacy: flags & 4 ? r2.vector(r2.object) : void 0, views: flags & 8 ? r2.object() : void 0, sentReaction: flags & 32768 ? r2.object() : void 0 };
        },
        291044926: function(r2) {
          r2.uint();
          return { _: "stories.allStoriesNotModified", state: r2.string(), stealthMode: r2.object() };
        },
        1862033025: function(r2) {
          var flags = r2.uint();
          return { _: "stories.allStories", hasMore: !!(flags & 1), count: r2.int(), state: r2.string(), peerStories: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), stealthMode: r2.object() };
        },
        1673780490: function(r2) {
          var flags = r2.uint();
          return { _: "stories.stories", count: r2.int(), stories: r2.vector(r2.object), pinnedToTop: flags & 1 ? r2.vector(r2.int) : void 0, chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2965236421: function(r2) {
          var flags = r2.uint();
          return { _: "storyView", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), userId: r2.int53(), date: r2.int(), reaction: flags & 4 ? r2.object() : void 0 };
        },
        2424530699: function(r2) {
          var flags = r2.uint();
          return { _: "storyViewPublicForward", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), message: r2.object() };
        },
        3178549065: function(r2) {
          var flags = r2.uint();
          return { _: "storyViewPublicRepost", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), peerId: r2.object(), story: r2.object() };
        },
        1507299269: function(r2) {
          var flags = r2.uint();
          return { _: "stories.storyViewsList", count: r2.int(), viewsCount: r2.int(), forwardsCount: r2.int(), reactionsCount: r2.int(), views: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0 };
        },
        3734957341: function(r2) {
          return { _: "stories.storyViews", views: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        583071445: function(r2) {
          var flags = r2.uint();
          return { _: "inputReplyToMessage", replyToMsgId: r2.int(), topMsgId: flags & 1 ? r2.int() : void 0, replyToPeerId: flags & 2 ? r2.object() : void 0, quoteText: flags & 4 ? r2.string() : void 0, quoteEntities: flags & 8 ? r2.vector(r2.object) : void 0, quoteOffset: flags & 16 ? r2.int() : void 0 };
        },
        1484862010: function(r2) {
          return { _: "inputReplyToStory", peer: r2.object(), storyId: r2.int() };
        },
        1070138683: function(r2) {
          return { _: "exportedStoryLink", link: r2.string() };
        },
        1898850301: function(r2) {
          var flags = r2.uint();
          return { _: "storiesStealthMode", activeUntilDate: flags & 1 ? r2.int() : void 0, cooldownUntilDate: flags & 2 ? r2.int() : void 0 };
        },
        3486113794: function(r2) {
          var flags = r2.uint();
          return { _: "mediaAreaCoordinates", x: r2.double(), y: r2.double(), w: r2.double(), h: r2.double(), rotation: r2.double(), radius: flags & 1 ? r2.double() : void 0 };
        },
        3196246940: function(r2) {
          return { _: "mediaAreaVenue", coordinates: r2.object(), geo: r2.object(), title: r2.string(), address: r2.string(), provider: r2.string(), venueId: r2.string(), venueType: r2.string() };
        },
        2994872703: function(r2) {
          return { _: "inputMediaAreaVenue", coordinates: r2.object(), queryId: r2.long(), resultId: r2.string() };
        },
        3402974509: function(r2) {
          var flags = r2.uint();
          return { _: "mediaAreaGeoPoint", coordinates: r2.object(), geo: r2.object(), address: flags & 1 ? r2.object() : void 0 };
        },
        340088945: function(r2) {
          var flags = r2.uint();
          return { _: "mediaAreaSuggestedReaction", dark: !!(flags & 1), flipped: !!(flags & 2), coordinates: r2.object(), reaction: r2.object() };
        },
        1996756655: function(r2) {
          return { _: "mediaAreaChannelPost", coordinates: r2.object(), channelId: r2.int53(), msgId: r2.int() };
        },
        577893055: function(r2) {
          return { _: "inputMediaAreaChannelPost", coordinates: r2.object(), channel: r2.object(), msgId: r2.int() };
        },
        926421125: function(r2) {
          return { _: "mediaAreaUrl", coordinates: r2.object(), url: r2.string() };
        },
        1235637404: function(r2) {
          return { _: "mediaAreaWeather", coordinates: r2.object(), emoji: r2.string(), temperatureC: r2.double(), color: r2.int() };
        },
        2587224473: function(r2) {
          var flags = r2.uint();
          return { _: "peerStories", peer: r2.object(), maxReadId: flags & 1 ? r2.int() : void 0, stories: r2.vector(r2.object) };
        },
        3404105576: function(r2) {
          return { _: "stories.peerStories", stories: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        4250800829: function(r2) {
          return { _: "messages.webPage", webpage: r2.object(), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        629052971: function(r2) {
          var flags = r2.uint();
          return { _: "premiumGiftCodeOption", users: r2.int(), months: r2.int(), storeProduct: flags & 1 ? r2.string() : void 0, storeQuantity: flags & 2 ? r2.int() : void 0, currency: r2.string(), amount: r2.long() };
        },
        675942550: function(r2) {
          var flags = r2.uint();
          return { _: "payments.checkedGiftCode", viaGiveaway: !!(flags & 4), fromId: flags & 16 ? r2.object() : void 0, giveawayMsgId: flags & 8 ? r2.int() : void 0, toId: flags & 1 ? r2.long() : void 0, date: r2.int(), months: r2.int(), usedDate: flags & 2 ? r2.int() : void 0, chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1130879648: function(r2) {
          var flags = r2.uint();
          return { _: "payments.giveawayInfo", participating: !!(flags & 1), preparingResults: !!(flags & 8), startDate: r2.int(), joinedTooEarlyDate: flags & 2 ? r2.int() : void 0, adminDisallowedChatId: flags & 4 ? r2.long() : void 0, disallowedCountry: flags & 16 ? r2.string() : void 0 };
        },
        3782600303: function(r2) {
          var flags = r2.uint();
          return { _: "payments.giveawayInfoResults", winner: !!(flags & 1), refunded: !!(flags & 2), startDate: r2.int(), giftCodeSlug: flags & 8 ? r2.string() : void 0, starsPrize: flags & 16 ? r2.long() : void 0, finishDate: r2.int(), winnersCount: r2.int(), activatedCount: flags & 4 ? r2.int() : void 0 };
        },
        2991824212: function(r2) {
          return { _: "prepaidGiveaway", id: r2.long(), months: r2.int(), quantity: r2.int(), date: r2.int() };
        },
        2594011104: function(r2) {
          return { _: "prepaidStarsGiveaway", id: r2.long(), stars: r2.long(), quantity: r2.int(), boosts: r2.int(), date: r2.int() };
        },
        1262359766: function(r2) {
          var flags = r2.uint();
          return { _: "boost", gift: !!(flags & 2), giveaway: !!(flags & 4), unclaimed: !!(flags & 8), id: r2.string(), userId: flags & 1 ? r2.int53() : void 0, giveawayMsgId: flags & 4 ? r2.int() : void 0, date: r2.int(), expires: r2.int(), usedGiftSlug: flags & 16 ? r2.string() : void 0, multiplier: flags & 32 ? r2.int() : void 0, stars: flags & 64 ? r2.long() : void 0 };
        },
        2264424764: function(r2) {
          var flags = r2.uint();
          return { _: "premium.boostsList", count: r2.int(), boosts: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0, users: r2.vector(r2.object) };
        },
        3293069660: function(r2) {
          var flags = r2.uint();
          return { _: "myBoost", slot: r2.int(), peer: flags & 1 ? r2.object() : void 0, date: r2.int(), expires: r2.int(), cooldownUntilDate: flags & 2 ? r2.int() : void 0 };
        },
        2598512866: function(r2) {
          return { _: "premium.myBoosts", myBoosts: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1230586490: function(r2) {
          var flags = r2.uint();
          return { _: "premium.boostsStatus", myBoost: !!(flags & 4), level: r2.int(), currentLevelBoosts: r2.int(), boosts: r2.int(), giftBoosts: flags & 16 ? r2.int() : void 0, nextLevelBoosts: flags & 1 ? r2.int() : void 0, premiumAudience: flags & 2 ? r2.object() : void 0, boostUrl: r2.string(), prepaidGiveaways: flags & 8 ? r2.vector(r2.object) : void 0, myBoostSlots: flags & 4 ? r2.vector(r2.int) : void 0 };
        },
        3089555792: function(r2) {
          var flags = r2.uint();
          return { _: "storyFwdHeader", modified: !!(flags & 8), from: flags & 1 ? r2.object() : void 0, fromName: flags & 2 ? r2.string() : void 0, storyId: flags & 4 ? r2.int() : void 0 };
        },
        3875901055: function(r2) {
          return { _: "postInteractionCountersMessage", msgId: r2.int(), views: r2.int(), forwards: r2.int(), reactions: r2.int() };
        },
        2319978023: function(r2) {
          return { _: "postInteractionCountersStory", storyId: r2.int(), views: r2.int(), forwards: r2.int(), reactions: r2.int() };
        },
        1355613820: function(r2) {
          return { _: "stats.storyStats", viewsGraph: r2.object(), reactionsByEmotionGraph: r2.object() };
        },
        32685898: function(r2) {
          return { _: "publicForwardMessage", message: r2.object() };
        },
        3992169936: function(r2) {
          return { _: "publicForwardStory", peer: r2.object(), story: r2.object() };
        },
        2466479648: function(r2) {
          var flags = r2.uint();
          return { _: "stats.publicForwards", count: r2.int(), forwards: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0, chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3041614543: function(r2) {
          var flags = r2.uint();
          return { _: "peerColor", color: flags & 1 ? r2.int() : void 0, backgroundEmojiId: flags & 2 ? r2.long() : void 0 };
        },
        639736408: function(r2) {
          return { _: "help.peerColorSet", colors: r2.vector(r2.int) };
        },
        1987928555: function(r2) {
          return { _: "help.peerColorProfileSet", paletteColors: r2.vector(r2.int), bgColors: r2.vector(r2.int), storyColors: r2.vector(r2.int) };
        },
        2917953214: function(r2) {
          var flags = r2.uint();
          return { _: "help.peerColorOption", hidden: !!(flags & 1), colorId: r2.int(), colors: flags & 2 ? r2.object() : void 0, darkColors: flags & 4 ? r2.object() : void 0, channelMinLevel: flags & 8 ? r2.int() : void 0, groupMinLevel: flags & 16 ? r2.int() : void 0 };
        },
        732034510: function(r2) {
          return { _: "help.peerColorsNotModified" };
        },
        16313608: function(r2) {
          return { _: "help.peerColors", hash: r2.int(), colors: r2.vector(r2.object) };
        },
        1620104917: function(r2) {
          return { _: "storyReaction", peerId: r2.object(), date: r2.int(), reaction: r2.object() };
        },
        3148555843: function(r2) {
          return { _: "storyReactionPublicForward", message: r2.object() };
        },
        3486322451: function(r2) {
          return { _: "storyReactionPublicRepost", peerId: r2.object(), story: r2.object() };
        },
        2858383516: function(r2) {
          var flags = r2.uint();
          return { _: "stories.storyReactionsList", count: r2.int(), reactions: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0 };
        },
        3179793260: function(r2) {
          var flags = r2.uint();
          return { _: "savedDialog", pinned: !!(flags & 4), peer: r2.object(), topMessage: r2.int() };
        },
        4164608545: function(r2) {
          return { _: "messages.savedDialogs", dialogs: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1153080793: function(r2) {
          return { _: "messages.savedDialogsSlice", count: r2.int(), dialogs: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3223285736: function(r2) {
          return { _: "messages.savedDialogsNotModified", count: r2.int() };
        },
        3413112872: function(r2) {
          var flags = r2.uint();
          return { _: "savedReactionTag", reaction: r2.object(), title: flags & 1 ? r2.string() : void 0, count: r2.int() };
        },
        2291882479: function(r2) {
          return { _: "messages.savedReactionTagsNotModified" };
        },
        844731658: function(r2) {
          return { _: "messages.savedReactionTags", tags: r2.vector(r2.object), hash: r2.long() };
        },
        1001931436: function(r2) {
          return { _: "outboxReadDate", date: r2.int() };
        },
        3700114639: function(r2) {
          return { _: "smsjobs.eligibleToJoin", termsUrl: r2.string(), monthlySentSms: r2.int() };
        },
        720277905: function(r2) {
          var flags = r2.uint();
          return { _: "smsjobs.status", allowInternational: !!(flags & 1), recentSent: r2.int(), recentSince: r2.int(), recentRemains: r2.int(), totalSent: r2.int(), totalSince: r2.int(), lastGiftSlug: flags & 2 ? r2.string() : void 0, termsUrl: r2.string() };
        },
        3869372088: function(r2) {
          return { _: "smsJob", jobId: r2.string(), phoneNumber: r2.string(), text: r2.string() };
        },
        302717625: function(r2) {
          return { _: "businessWeeklyOpen", startMinute: r2.int(), endMinute: r2.int() };
        },
        2358423704: function(r2) {
          var flags = r2.uint();
          return { _: "businessWorkHours", openNow: !!(flags & 1), timezoneId: r2.string(), weeklyOpen: r2.vector(r2.object) };
        },
        2891717367: function(r2) {
          var flags = r2.uint();
          return { _: "businessLocation", geoPoint: flags & 1 ? r2.object() : void 0, address: r2.string() };
        },
        1871393450: function(r2) {
          var flags = r2.uint();
          return { _: "inputBusinessRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r2.vector(r2.object) : void 0 };
        },
        554733559: function(r2) {
          var flags = r2.uint();
          return { _: "businessRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r2.vector(r2.int53) : void 0 };
        },
        3384402617: function(r2) {
          return { _: "businessAwayMessageScheduleAlways" };
        },
        3287479553: function(r2) {
          return { _: "businessAwayMessageScheduleOutsideWorkHours" };
        },
        3427638988: function(r2) {
          return { _: "businessAwayMessageScheduleCustom", startDate: r2.int(), endDate: r2.int() };
        },
        26528571: function(r2) {
          return { _: "inputBusinessGreetingMessage", shortcutId: r2.int(), recipients: r2.object(), noActivityDays: r2.int() };
        },
        3843664811: function(r2) {
          return { _: "businessGreetingMessage", shortcutId: r2.int(), recipients: r2.object(), noActivityDays: r2.int() };
        },
        2200008160: function(r2) {
          var flags = r2.uint();
          return { _: "inputBusinessAwayMessage", offlineOnly: !!(flags & 1), shortcutId: r2.int(), schedule: r2.object(), recipients: r2.object() };
        },
        4011158108: function(r2) {
          var flags = r2.uint();
          return { _: "businessAwayMessage", offlineOnly: !!(flags & 1), shortcutId: r2.int(), schedule: r2.object(), recipients: r2.object() };
        },
        4287793653: function(r2) {
          return { _: "timezone", id: r2.string(), name: r2.string(), utcOffset: r2.int() };
        },
        2533820620: function(r2) {
          return { _: "help.timezonesListNotModified" };
        },
        2071260529: function(r2) {
          return { _: "help.timezonesList", timezones: r2.vector(r2.object), hash: r2.int() };
        },
        110563371: function(r2) {
          return { _: "quickReply", shortcutId: r2.int(), shortcut: r2.string(), topMessage: r2.int(), count: r2.int() };
        },
        609840449: function(r2) {
          return { _: "inputQuickReplyShortcut", shortcut: r2.string() };
        },
        18418929: function(r2) {
          return { _: "inputQuickReplyShortcutId", shortcutId: r2.int() };
        },
        3331155605: function(r2) {
          return { _: "messages.quickReplies", quickReplies: r2.vector(r2.object), messages: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1603398491: function(r2) {
          return { _: "messages.quickRepliesNotModified" };
        },
        3171321345: function(r2) {
          var flags = r2.uint();
          return { _: "connectedBot", canReply: !!(flags & 1), botId: r2.int53(), recipients: r2.object() };
        },
        400029819: function(r2) {
          return { _: "account.connectedBots", connectedBots: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        718878489: function(r2) {
          var flags = r2.uint();
          return { _: "messages.dialogFilters", tagsEnabled: !!(flags & 1), filters: r2.vector(r2.object) };
        },
        1821253126: function(r2) {
          var flags = r2.uint();
          return { _: "birthday", day: r2.int(), month: r2.int(), year: flags & 1 ? r2.int() : void 0 };
        },
        2305045428: function(r2) {
          var flags = r2.uint();
          return { _: "botBusinessConnection", canReply: !!(flags & 1), disabled: !!(flags & 2), connectionId: r2.string(), userId: r2.int53(), dcId: r2.int(), date: r2.int() };
        },
        163867085: function(r2) {
          var flags = r2.uint();
          return { _: "inputBusinessIntro", title: r2.string(), description: r2.string(), sticker: flags & 1 ? r2.object() : void 0 };
        },
        1510606445: function(r2) {
          var flags = r2.uint();
          return { _: "businessIntro", title: r2.string(), description: r2.string(), sticker: flags & 1 ? r2.object() : void 0 };
        },
        4211040925: function(r2) {
          return { _: "messages.myStickers", count: r2.int(), sets: r2.vector(r2.object) };
        },
        3818152105: function(r2) {
          return { _: "inputCollectibleUsername", username: r2.string() };
        },
        2732725412: function(r2) {
          return { _: "inputCollectiblePhone", phone: r2.string() };
        },
        1857945489: function(r2) {
          return { _: "fragment.collectibleInfo", purchaseDate: r2.int(), currency: r2.string(), amount: r2.long(), cryptoCurrency: r2.string(), cryptoAmount: r2.long(), url: r2.string() };
        },
        3303379486: function(r2) {
          var flags = r2.uint();
          return { _: "inputBusinessBotRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r2.vector(r2.object) : void 0, excludeUsers: flags & 64 ? r2.vector(r2.object) : void 0 };
        },
        3096245107: function(r2) {
          var flags = r2.uint();
          return { _: "businessBotRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r2.vector(r2.int53) : void 0, excludeUsers: flags & 64 ? r2.vector(r2.int53) : void 0 };
        },
        496600883: function(r2) {
          return { _: "contactBirthday", contactId: r2.int53(), birthday: r2.object() };
        },
        290452237: function(r2) {
          return { _: "contacts.contactBirthdays", contacts: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        1653379620: function(r2) {
          var flags = r2.uint();
          return { _: "missingInvitee", premiumWouldAllowInvite: !!(flags & 1), premiumRequiredForPm: !!(flags & 2), userId: r2.int53() };
        },
        2136862630: function(r2) {
          return { _: "messages.invitedUsers", updates: r2.object(), missingInvitees: r2.vector(r2.object) };
        },
        292003751: function(r2) {
          var flags = r2.uint();
          return { _: "inputBusinessChatLink", message: r2.string(), entities: flags & 1 ? r2.vector(r2.object) : void 0, title: flags & 2 ? r2.string() : void 0 };
        },
        3031328367: function(r2) {
          var flags = r2.uint();
          return { _: "businessChatLink", link: r2.string(), message: r2.string(), entities: flags & 1 ? r2.vector(r2.object) : void 0, title: flags & 2 ? r2.string() : void 0, views: r2.int() };
        },
        3963855569: function(r2) {
          return { _: "account.businessChatLinks", links: r2.vector(r2.object), chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        2586029857: function(r2) {
          var flags = r2.uint();
          return { _: "account.resolvedBusinessChatLinks", peer: r2.object(), message: r2.string(), entities: flags & 1 ? r2.vector(r2.object) : void 0, chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3593466986: function(r2) {
          var flags = r2.uint();
          return { _: "requestedPeerUser", userId: r2.int53(), firstName: flags & 1 ? r2.string() : void 0, lastName: flags & 1 ? r2.string() : void 0, username: flags & 2 ? r2.string() : void 0, photo: flags & 4 ? r2.object() : void 0 };
        },
        1929860175: function(r2) {
          var flags = r2.uint();
          return { _: "requestedPeerChat", chatId: r2.int53(), title: flags & 1 ? r2.string() : void 0, photo: flags & 4 ? r2.object() : void 0 };
        },
        2342781924: function(r2) {
          var flags = r2.uint();
          return { _: "requestedPeerChannel", channelId: r2.int53(), title: flags & 1 ? r2.string() : void 0, username: flags & 2 ? r2.string() : void 0, photo: flags & 4 ? r2.object() : void 0 };
        },
        1124938064: function(r2) {
          return { _: "sponsoredMessageReportOption", text: r2.string(), option: r2.bytes() };
        },
        2221907522: function(r2) {
          return { _: "channels.sponsoredMessageReportResultChooseOption", title: r2.string(), options: r2.vector(r2.object) };
        },
        1044107055: function(r2) {
          return { _: "channels.sponsoredMessageReportResultAdsHidden" };
        },
        2910423113: function(r2) {
          return { _: "channels.sponsoredMessageReportResultReported" };
        },
        1409802903: function(r2) {
          return { _: "stats.broadcastRevenueStats", topHoursGraph: r2.object(), revenueGraph: r2.object(), balances: r2.object(), usdRate: r2.double() };
        },
        3966080823: function(r2) {
          return { _: "stats.broadcastRevenueWithdrawalUrl", url: r2.string() };
        },
        1434332356: function(r2) {
          return { _: "broadcastRevenueTransactionProceeds", amount: r2.long(), fromDate: r2.int(), toDate: r2.int() };
        },
        1515784568: function(r2) {
          var flags = r2.uint();
          return { _: "broadcastRevenueTransactionWithdrawal", pending: !!(flags & 1), failed: !!(flags & 4), amount: r2.long(), date: r2.int(), provider: r2.string(), transactionDate: flags & 2 ? r2.int() : void 0, transactionUrl: flags & 2 ? r2.string() : void 0 };
        },
        1121127726: function(r2) {
          return { _: "broadcastRevenueTransactionRefund", amount: r2.long(), date: r2.int(), provider: r2.string() };
        },
        2266334310: function(r2) {
          return { _: "stats.broadcastRevenueTransactions", count: r2.int(), transactions: r2.vector(r2.object) };
        },
        3133384218: function(r2) {
          return { _: "reactionNotificationsFromContacts" };
        },
        1268654752: function(r2) {
          return { _: "reactionNotificationsFromAll" };
        },
        1457736048: function(r2) {
          var flags = r2.uint();
          return { _: "reactionsNotifySettings", messagesNotifyFrom: flags & 1 ? r2.object() : void 0, storiesNotifyFrom: flags & 2 ? r2.object() : void 0, sound: r2.object(), showPreviews: r2.boolean() };
        },
        3288297959: function(r2) {
          var flags = r2.uint();
          return { _: "broadcastRevenueBalances", withdrawalEnabled: !!(flags & 1), currentBalance: r2.long(), availableBalance: r2.long(), overallRevenue: r2.long() };
        },
        2479088254: function(r2) {
          var flags = r2.uint();
          return { _: "availableEffect", premiumRequired: !!(flags & 4), id: r2.long(), emoticon: r2.string(), staticIconId: flags & 1 ? r2.long() : void 0, effectStickerId: r2.long(), effectAnimationId: flags & 2 ? r2.long() : void 0 };
        },
        3522009691: function(r2) {
          return { _: "messages.availableEffectsNotModified" };
        },
        3185271150: function(r2) {
          return { _: "messages.availableEffects", hash: r2.int(), effects: r2.vector(r2.object), documents: r2.vector(r2.object) };
        },
        3097230543: function(r2) {
          var flags = r2.uint();
          return { _: "factCheck", needCheck: !!(flags & 1), country: flags & 2 ? r2.string() : void 0, text: flags & 2 ? r2.object() : void 0, hash: r2.long() };
        },
        2515714020: function(r2) {
          return { _: "starsTransactionPeerUnsupported" };
        },
        3025646453: function(r2) {
          return { _: "starsTransactionPeerAppStore" };
        },
        2069236235: function(r2) {
          return { _: "starsTransactionPeerPlayMarket" };
        },
        621656824: function(r2) {
          return { _: "starsTransactionPeerPremiumBot" };
        },
        3912227074: function(r2) {
          return { _: "starsTransactionPeerFragment" };
        },
        3624771933: function(r2) {
          return { _: "starsTransactionPeer", peer: r2.object() };
        },
        1617438738: function(r2) {
          return { _: "starsTransactionPeerAds" };
        },
        198776256: function(r2) {
          var flags = r2.uint();
          return { _: "starsTopupOption", extended: !!(flags & 2), stars: r2.long(), storeProduct: flags & 1 ? r2.string() : void 0, currency: r2.string(), amount: r2.long() };
        },
        178185410: function(r2) {
          var flags = r2.uint();
          return { _: "starsTransaction", refund: !!(flags & 8), pending: !!(flags & 16), failed: !!(flags & 64), gift: !!(flags & 1024), reaction: !!(flags & 2048), id: r2.string(), stars: r2.long(), date: r2.int(), peer: r2.object(), title: flags & 1 ? r2.string() : void 0, description: flags & 2 ? r2.string() : void 0, photo: flags & 4 ? r2.object() : void 0, transactionDate: flags & 32 ? r2.int() : void 0, transactionUrl: flags & 32 ? r2.string() : void 0, botPayload: flags & 128 ? r2.bytes() : void 0, msgId: flags & 256 ? r2.int() : void 0, extendedMedia: flags & 512 ? r2.vector(r2.object) : void 0, subscriptionPeriod: flags & 4096 ? r2.int() : void 0, giveawayPostId: flags & 8192 ? r2.int() : void 0, stargift: flags & 16384 ? r2.object() : void 0 };
        },
        3153736044: function(r2) {
          var flags = r2.uint();
          return { _: "payments.starsStatus", balance: r2.long(), subscriptions: flags & 2 ? r2.vector(r2.object) : void 0, subscriptionsNextOffset: flags & 4 ? r2.string() : void 0, subscriptionsMissingBalance: flags & 16 ? r2.long() : void 0, history: flags & 8 ? r2.vector(r2.object) : void 0, nextOffset: flags & 1 ? r2.string() : void 0, chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3900361664: function(r2) {
          return { _: "foundStory", peer: r2.object(), story: r2.object() };
        },
        3806230327: function(r2) {
          var flags = r2.uint();
          return { _: "stories.foundStories", count: r2.int(), stories: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0, chats: r2.vector(r2.object), users: r2.vector(r2.object) };
        },
        3729546643: function(r2) {
          var flags = r2.uint();
          return { _: "geoPointAddress", countryIso2: r2.string(), state: flags & 1 ? r2.string() : void 0, city: flags & 2 ? r2.string() : void 0, street: flags & 4 ? r2.string() : void 0 };
        },
        2033461574: function(r2) {
          var flags = r2.uint();
          return { _: "starsRevenueStatus", withdrawalEnabled: !!(flags & 1), currentBalance: r2.long(), availableBalance: r2.long(), overallRevenue: r2.long(), nextWithdrawalAt: flags & 2 ? r2.int() : void 0 };
        },
        3375085371: function(r2) {
          return { _: "payments.starsRevenueStats", revenueGraph: r2.object(), status: r2.object(), usdRate: r2.double() };
        },
        497778871: function(r2) {
          return { _: "payments.starsRevenueWithdrawalUrl", url: r2.string() };
        },
        961445665: function(r2) {
          return { _: "payments.starsRevenueAdsAccountUrl", url: r2.string() };
        },
        543876817: function(r2) {
          var flags = r2.uint();
          return { _: "inputStarsTransaction", refund: !!(flags & 1), id: r2.string() };
        },
        1577421297: function(r2) {
          var flags = r2.uint();
          return { _: "starsGiftOption", extended: !!(flags & 2), stars: r2.long(), storeProduct: flags & 1 ? r2.string() : void 0, currency: r2.string(), amount: r2.long() };
        },
        428978491: function(r2) {
          var flags = r2.uint();
          return { _: "bots.popularAppBots", nextOffset: flags & 1 ? r2.string() : void 0, users: r2.vector(r2.object) };
        },
        602479523: function(r2) {
          return { _: "botPreviewMedia", date: r2.int(), media: r2.object() };
        },
        212278628: function(r2) {
          return { _: "bots.previewInfo", media: r2.vector(r2.object), langCodes: r2.vector(r2.string) };
        },
        88173912: function(r2) {
          return { _: "starsSubscriptionPricing", period: r2.int(), amount: r2.long() };
        },
        1401868056: function(r2) {
          var flags = r2.uint();
          return { _: "starsSubscription", canceled: !!(flags & 1), canRefulfill: !!(flags & 2), missingBalance: !!(flags & 4), id: r2.string(), peer: r2.object(), untilDate: r2.int(), pricing: r2.object(), chatInviteHash: flags & 8 ? r2.string() : void 0 };
        },
        1269016922: function(r2) {
          var flags = r2.uint();
          return { _: "messageReactor", top: !!(flags & 1), my: !!(flags & 2), anonymous: !!(flags & 4), peerId: flags & 8 ? r2.object() : void 0, count: r2.int() };
        },
        2496562474: function(r2) {
          var flags = r2.uint();
          return { _: "starsGiveawayOption", extended: !!(flags & 1), default: !!(flags & 2), stars: r2.long(), yearlyBoosts: r2.int(), storeProduct: flags & 4 ? r2.string() : void 0, currency: r2.string(), amount: r2.long(), winners: r2.vector(r2.object) };
        },
        1411605001: function(r2) {
          var flags = r2.uint();
          return { _: "starsGiveawayWinnersOption", default: !!(flags & 1), users: r2.int(), perUserStars: r2.long() };
        },
        2929816814: function(r2) {
          var flags = r2.uint();
          return { _: "starGift", limited: !!(flags & 1), id: r2.long(), sticker: r2.object(), stars: r2.long(), availabilityRemains: flags & 1 ? r2.int() : void 0, availabilityTotal: flags & 1 ? r2.int() : void 0, convertStars: r2.long() };
        },
        2743640936: function(r2) {
          return { _: "payments.starGiftsNotModified" };
        },
        2417396202: function(r2) {
          return { _: "payments.starGifts", hash: r2.int(), gifts: r2.vector(r2.object) };
        },
        4003764846: function(r2) {
          var flags = r2.uint();
          return { _: "userStarGift", nameHidden: !!(flags & 1), unsaved: !!(flags & 32), fromId: flags & 2 ? r2.int53() : void 0, date: r2.int(), gift: r2.object(), message: flags & 4 ? r2.object() : void 0, msgId: flags & 8 ? r2.int() : void 0, convertStars: flags & 16 ? r2.long() : void 0 };
        },
        1801827607: function(r2) {
          var flags = r2.uint();
          return { _: "payments.userStarGifts", count: r2.int(), gifts: r2.vector(r2.object), nextOffset: flags & 1 ? r2.string() : void 0, users: r2.vector(r2.object) };
        },
        2030298073: function(r2) {
          return { _: "messageReportOption", text: r2.string(), option: r2.bytes() };
        },
        4041531574: function(r2) {
          return { _: "reportResultChooseOption", title: r2.string(), options: r2.vector(r2.object) };
        },
        1862904881: function(r2) {
          var flags = r2.uint();
          return { _: "reportResultAddComment", optional: !!(flags & 1), option: r2.bytes() };
        },
        2377333835: function(r2) {
          return { _: "reportResultReported" };
        },
        _results: {
          "contacts.getContactIDs": function(r2) {
            return r2.vector(r2.int);
          },
          "messages.receivedQueue": function(r2) {
            return r2.vector(r2.long);
          },
          "photos.deletePhotos": function(r2) {
            return r2.vector(r2.long);
          },
          "phone.checkGroupCall": function(r2) {
            return r2.vector(r2.int);
          },
          "stories.deleteStories": function(r2) {
            return r2.vector(r2.int);
          },
          "stories.togglePinned": function(r2) {
            return r2.vector(r2.int);
          },
          "stories.readStories": function(r2) {
            return r2.vector(r2.int);
          },
          "stories.getPeerMaxIDs": function(r2) {
            return r2.vector(r2.int);
          },
          "mtcute.customMethod": function(r2) {
            return r2.raw();
          }
        },
        85337187: function(r2) {
          return { _: "mt_resPQ", nonce: r2.int128(), serverNonce: r2.int128(), pq: r2.bytes(), serverPublicKeyFingerprints: r2.vector(r2.long) };
        },
        2851430293: function(r2) {
          return { _: "mt_p_q_inner_data_dc", pq: r2.bytes(), p: r2.bytes(), q: r2.bytes(), nonce: r2.int128(), serverNonce: r2.int128(), newNonce: r2.int256(), dc: r2.int() };
        },
        1459478408: function(r2) {
          return { _: "mt_p_q_inner_data_temp_dc", pq: r2.bytes(), p: r2.bytes(), q: r2.bytes(), nonce: r2.int128(), serverNonce: r2.int128(), newNonce: r2.int256(), dc: r2.int(), expiresIn: r2.int() };
        },
        3504867164: function(r2) {
          return { _: "mt_server_DH_params_ok", nonce: r2.int128(), serverNonce: r2.int128(), encryptedAnswer: r2.bytes() };
        },
        3045658042: function(r2) {
          return { _: "mt_server_DH_inner_data", nonce: r2.int128(), serverNonce: r2.int128(), g: r2.int(), dhPrime: r2.bytes(), gA: r2.bytes(), serverTime: r2.int() };
        },
        1715713620: function(r2) {
          return { _: "mt_client_DH_inner_data", nonce: r2.int128(), serverNonce: r2.int128(), retryId: r2.long(), gB: r2.bytes() };
        },
        1003222836: function(r2) {
          return { _: "mt_dh_gen_ok", nonce: r2.int128(), serverNonce: r2.int128(), newNonceHash1: r2.int128() };
        },
        1188831161: function(r2) {
          return { _: "mt_dh_gen_retry", nonce: r2.int128(), serverNonce: r2.int128(), newNonceHash2: r2.int128() };
        },
        2795351554: function(r2) {
          return { _: "mt_dh_gen_fail", nonce: r2.int128(), serverNonce: r2.int128(), newNonceHash3: r2.int128() };
        },
        1973679973: function(r2) {
          return { _: "mt_bind_auth_key_inner", nonce: r2.long(), tempAuthKeyId: r2.long(), permAuthKeyId: r2.long(), tempSessionId: r2.long(), expiresAt: r2.int() };
        },
        558156313: function(r2) {
          return { _: "mt_rpc_error", errorCode: r2.int(), errorMessage: r2.string() };
        },
        1579864942: function(r2) {
          return { _: "mt_rpc_answer_unknown" };
        },
        3447252358: function(r2) {
          return { _: "mt_rpc_answer_dropped_running" };
        },
        2755319991: function(r2) {
          return { _: "mt_rpc_answer_dropped", msgId: r2.long(), seqNo: r2.int(), bytes: r2.int() };
        },
        155834844: function(r2 = this) {
          return { _: "mt_future_salt", validSince: r2.int(), validUntil: r2.int(), salt: r2.long() };
        },
        2924480661: function(r2) {
          return { _: "mt_future_salts", reqMsgId: r2.long(), now: r2.int(), salts: r2.vector(m$1[155834844], 1) };
        },
        880243653: function(r2) {
          return { _: "mt_pong", msgId: r2.long(), pingId: r2.long() };
        },
        3793765884: function(r2) {
          return { _: "mt_destroy_session_ok", sessionId: r2.long() };
        },
        1658015945: function(r2) {
          return { _: "mt_destroy_session_none", sessionId: r2.long() };
        },
        2663516424: function(r2) {
          return { _: "mt_new_session_created", firstMsgId: r2.long(), uniqueId: r2.long(), serverSalt: r2.long() };
        },
        1658238041: function(r2) {
          return { _: "mt_msgs_ack", msgIds: r2.vector(r2.long) };
        },
        2817521681: function(r2) {
          return { _: "mt_bad_msg_notification", badMsgId: r2.long(), badMsgSeqno: r2.int(), errorCode: r2.int() };
        },
        3987424379: function(r2) {
          return { _: "mt_bad_server_salt", badMsgId: r2.long(), badMsgSeqno: r2.int(), errorCode: r2.int(), newServerSalt: r2.long() };
        },
        2105940488: function(r2) {
          return { _: "mt_msg_resend_req", msgIds: r2.vector(r2.long) };
        },
        3664378706: function(r2) {
          return { _: "mt_msgs_state_req", msgIds: r2.vector(r2.long) };
        },
        81704317: function(r2) {
          return { _: "mt_msgs_state_info", reqMsgId: r2.long(), info: r2.bytes() };
        },
        2361446705: function(r2) {
          return { _: "mt_msgs_all_info", msgIds: r2.vector(r2.long), info: r2.bytes() };
        },
        661470918: function(r2) {
          return { _: "mt_msg_detailed_info", msgId: r2.long(), answerMsgId: r2.long(), bytes: r2.int(), status: r2.int() };
        },
        2157819615: function(r2) {
          return { _: "mt_msg_new_detailed_info", answerMsgId: r2.long(), bytes: r2.int(), status: r2.int() };
        },
        4133544404: function(r2) {
          return { _: "mt_destroy_auth_key_ok" };
        },
        178201177: function(r2) {
          return { _: "mt_destroy_auth_key_none" };
        },
        3926956819: function(r2) {
          return { _: "mt_destroy_auth_key_fail" };
        },
        2459514271: function(r2) {
          return { _: "mt_http_wait", maxDelay: r2.int(), waitAfter: r2.int(), maxWait: r2.int() };
        },
        3195965169: function(r2) {
          return { _: "mt_req_pq_multi", nonce: r2.int128() };
        },
        3608339646: function(r2) {
          return { _: "mt_req_DH_params", nonce: r2.int128(), serverNonce: r2.int128(), p: r2.bytes(), q: r2.bytes(), publicKeyFingerprint: r2.long(), encryptedData: r2.bytes() };
        },
        4110704415: function(r2) {
          return { _: "mt_set_client_DH_params", nonce: r2.int128(), serverNonce: r2.int128(), encryptedData: r2.bytes() };
        },
        1491380032: function(r2) {
          return { _: "mt_rpc_drop_answer", reqMsgId: r2.long() };
        },
        3105996036: function(r2) {
          return { _: "mt_get_future_salts", num: r2.int() };
        },
        2059302892: function(r2) {
          return { _: "mt_ping", pingId: r2.long() };
        },
        4081220492: function(r2) {
          return { _: "mt_ping_delay_disconnect", pingId: r2.long(), disconnectDelay: r2.int() };
        },
        3880853798: function(r2) {
          return { _: "mt_destroy_session", sessionId: r2.long() };
        },
        3510849888: function(r2) {
          return { _: "mt_destroy_auth_key" };
        }
      };
      var __tlReaderMap = exports("h", reader.__tlReaderMap = m$1);
      var writer = {};
      Object.defineProperty(writer, "__esModule", { value: true });
      function h(o2, p) {
        var q = o2[p];
        if (q === void 0)
          throw Error("Object " + o2._ + " is missing required property " + p);
        return q;
      }
      var m = {
        "error": function(w, v) {
          w.uint(3300522427);
          w.int(h(v, "code"));
          w.string(h(v, "text"));
        },
        "ipPort": function(w, v) {
          w.uint(3560156531);
          w.int(h(v, "ipv4"));
          w.int(h(v, "port"));
        },
        "ipPortSecret": function(w, v) {
          w.uint(932718150);
          w.int(h(v, "ipv4"));
          w.int(h(v, "port"));
          w.bytes(h(v, "secret"));
        },
        "accessPointRule": function(w, v) {
          w.uint(1182381663);
          w.string(h(v, "phonePrefixRules"));
          w.int(h(v, "dcId"));
          w.vector(w.object, h(v, "ips"), 1);
        },
        "help.configSimple": function(w, v) {
          w.uint(1515793004);
          w.int(h(v, "date"));
          w.int(h(v, "expires"));
          w.vector(w.object, h(v, "rules"), 1);
        },
        "inputPeerPhotoFileLocationLegacy": function(w, v) {
          w.uint(668375447);
          var flags = 0;
          if (v.big === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.long(h(v, "volumeId"));
          w.int(h(v, "localId"));
        },
        "inputStickerSetThumbLegacy": function(w, v) {
          w.uint(230353641);
          w.object(h(v, "stickerset"));
          w.long(h(v, "volumeId"));
          w.int(h(v, "localId"));
        },
        "inputPeerEmpty": function(w) {
          w.uint(2134579434);
        },
        "inputPeerSelf": function(w) {
          w.uint(2107670217);
        },
        "inputPeerChat": function(w, v) {
          w.uint(900291769);
          w.int53(h(v, "chatId"));
        },
        "inputPeerUser": function(w, v) {
          w.uint(3723011404);
          w.int53(h(v, "userId"));
          w.long(h(v, "accessHash"));
        },
        "inputPeerChannel": function(w, v) {
          w.uint(666680316);
          w.int53(h(v, "channelId"));
          w.long(h(v, "accessHash"));
        },
        "inputPeerUserFromMessage": function(w, v) {
          w.uint(2826635804);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int53(h(v, "userId"));
        },
        "inputPeerChannelFromMessage": function(w, v) {
          w.uint(3173648448);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int53(h(v, "channelId"));
        },
        "inputUserEmpty": function(w) {
          w.uint(3112732367);
        },
        "inputUserSelf": function(w) {
          w.uint(4156666175);
        },
        "inputUser": function(w, v) {
          w.uint(4061223110);
          w.int53(h(v, "userId"));
          w.long(h(v, "accessHash"));
        },
        "inputUserFromMessage": function(w, v) {
          w.uint(497305826);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int53(h(v, "userId"));
        },
        "inputPhoneContact": function(w, v) {
          w.uint(4086478836);
          w.long(h(v, "clientId"));
          w.string(h(v, "phone"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
        },
        "inputFile": function(w, v) {
          w.uint(4113560191);
          w.long(h(v, "id"));
          w.int(h(v, "parts"));
          w.string(h(v, "name"));
          w.string(h(v, "md5Checksum"));
        },
        "inputFileBig": function(w, v) {
          w.uint(4199484341);
          w.long(h(v, "id"));
          w.int(h(v, "parts"));
          w.string(h(v, "name"));
        },
        "inputFileStoryDocument": function(w, v) {
          w.uint(1658620744);
          w.object(h(v, "id"));
        },
        "inputMediaEmpty": function(w) {
          w.uint(2523198847);
        },
        "inputMediaUploadedPhoto": function(w, v) {
          w.uint(505969924);
          var flags = 0;
          var _stickers = v.stickers && v.stickers.length;
          if (_stickers)
            flags |= 1;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 2;
          if (v.spoiler === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "file"));
          if (_stickers)
            w.vector(w.object, v.stickers);
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
        },
        "inputMediaPhoto": function(w, v) {
          w.uint(3015312949);
          var flags = 0;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 1;
          if (v.spoiler === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "id"));
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
        },
        "inputMediaGeoPoint": function(w, v) {
          w.uint(4190388548);
          w.object(h(v, "geoPoint"));
        },
        "inputMediaContact": function(w, v) {
          w.uint(4171988475);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
          w.string(h(v, "vcard"));
        },
        "inputMediaUploadedDocument": function(w, v) {
          w.uint(1530447553);
          var flags = 0;
          var _stickers = v.stickers && v.stickers.length;
          if (_stickers)
            flags |= 1;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 2;
          var _thumb = v.thumb !== void 0;
          if (_thumb)
            flags |= 4;
          if (v.nosoundVideo === true)
            flags |= 8;
          if (v.forceFile === true)
            flags |= 16;
          if (v.spoiler === true)
            flags |= 32;
          w.uint(flags);
          w.object(h(v, "file"));
          if (_thumb)
            w.object(v.thumb);
          w.string(h(v, "mimeType"));
          w.vector(w.object, h(v, "attributes"));
          if (_stickers)
            w.vector(w.object, v.stickers);
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
        },
        "inputMediaDocument": function(w, v) {
          w.uint(860303448);
          var flags = 0;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 1;
          var _query = v.query !== void 0;
          if (_query)
            flags |= 2;
          if (v.spoiler === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "id"));
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
          if (_query)
            w.string(v.query);
        },
        "inputMediaVenue": function(w, v) {
          w.uint(3242007569);
          w.object(h(v, "geoPoint"));
          w.string(h(v, "title"));
          w.string(h(v, "address"));
          w.string(h(v, "provider"));
          w.string(h(v, "venueId"));
          w.string(h(v, "venueType"));
        },
        "inputMediaPhotoExternal": function(w, v) {
          w.uint(3854302746);
          var flags = 0;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 1;
          if (v.spoiler === true)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "url"));
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
        },
        "inputMediaDocumentExternal": function(w, v) {
          w.uint(4216511641);
          var flags = 0;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 1;
          if (v.spoiler === true)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "url"));
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
        },
        "inputMediaGame": function(w, v) {
          w.uint(3544138739);
          w.object(h(v, "id"));
        },
        "inputMediaInvoice": function(w, v) {
          w.uint(1080028941);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 1;
          var _startParam = v.startParam !== void 0;
          if (_startParam)
            flags |= 2;
          var _extendedMedia = v.extendedMedia !== void 0;
          if (_extendedMedia)
            flags |= 4;
          var _provider = v.provider !== void 0;
          if (_provider)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          w.object(h(v, "invoice"));
          w.bytes(h(v, "payload"));
          if (_provider)
            w.string(v.provider);
          w.object(h(v, "providerData"));
          if (_startParam)
            w.string(v.startParam);
          if (_extendedMedia)
            w.object(v.extendedMedia);
        },
        "inputMediaGeoLive": function(w, v) {
          w.uint(2535434307);
          var flags = 0;
          if (v.stopped === true)
            flags |= 1;
          var _period = v.period !== void 0;
          if (_period)
            flags |= 2;
          var _heading = v.heading !== void 0;
          if (_heading)
            flags |= 4;
          var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
          if (_proximityNotificationRadius)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "geoPoint"));
          if (_heading)
            w.int(v.heading);
          if (_period)
            w.int(v.period);
          if (_proximityNotificationRadius)
            w.int(v.proximityNotificationRadius);
        },
        "inputMediaPoll": function(w, v) {
          w.uint(261416433);
          var flags = 0;
          var _correctAnswers = v.correctAnswers && v.correctAnswers.length;
          if (_correctAnswers)
            flags |= 1;
          var _solution = v.solution !== void 0;
          var _solutionEntities = v.solutionEntities && v.solutionEntities.length;
          var _flags_1 = _solution || _solutionEntities;
          if (_flags_1)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "poll"));
          if (_correctAnswers)
            w.vector(w.bytes, v.correctAnswers);
          if (_flags_1)
            w.string(v.solution);
          if (_flags_1)
            w.vector(w.object, v.solutionEntities);
        },
        "inputMediaDice": function(w, v) {
          w.uint(3866083195);
          w.string(h(v, "emoticon"));
        },
        "inputMediaStory": function(w, v) {
          w.uint(2315114360);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
        },
        "inputMediaWebPage": function(w, v) {
          w.uint(3256584265);
          var flags = 0;
          if (v.forceLargeMedia === true)
            flags |= 1;
          if (v.forceSmallMedia === true)
            flags |= 2;
          if (v.optional === true)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "url"));
        },
        "inputMediaPaidMedia": function(w, v) {
          w.uint(3289396102);
          var flags = 0;
          var _payload = v.payload !== void 0;
          if (_payload)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "starsAmount"));
          w.vector(w.object, h(v, "extendedMedia"));
          if (_payload)
            w.string(v.payload);
        },
        "inputChatPhotoEmpty": function(w) {
          w.uint(480546647);
        },
        "inputChatUploadedPhoto": function(w, v) {
          w.uint(3184373440);
          var flags = 0;
          var _file = v.file !== void 0;
          if (_file)
            flags |= 1;
          var _video = v.video !== void 0;
          if (_video)
            flags |= 2;
          var _videoStartTs = v.videoStartTs !== void 0;
          if (_videoStartTs)
            flags |= 4;
          var _videoEmojiMarkup = v.videoEmojiMarkup !== void 0;
          if (_videoEmojiMarkup)
            flags |= 8;
          w.uint(flags);
          if (_file)
            w.object(v.file);
          if (_video)
            w.object(v.video);
          if (_videoStartTs)
            w.double(v.videoStartTs);
          if (_videoEmojiMarkup)
            w.object(v.videoEmojiMarkup);
        },
        "inputChatPhoto": function(w, v) {
          w.uint(2303962423);
          w.object(h(v, "id"));
        },
        "inputGeoPointEmpty": function(w) {
          w.uint(3837862870);
        },
        "inputGeoPoint": function(w, v) {
          w.uint(1210199983);
          var flags = 0;
          var _accuracyRadius = v.accuracyRadius !== void 0;
          if (_accuracyRadius)
            flags |= 1;
          w.uint(flags);
          w.double(h(v, "lat"));
          w.double(h(v, "long"));
          if (_accuracyRadius)
            w.int(v.accuracyRadius);
        },
        "inputPhotoEmpty": function(w) {
          w.uint(483901197);
        },
        "inputPhoto": function(w, v) {
          w.uint(1001634122);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.bytes(h(v, "fileReference"));
        },
        "inputFileLocation": function(w, v) {
          w.uint(3755650017);
          w.long(h(v, "volumeId"));
          w.int(h(v, "localId"));
          w.long(h(v, "secret"));
          w.bytes(h(v, "fileReference"));
        },
        "inputEncryptedFileLocation": function(w, v) {
          w.uint(4112735573);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputDocumentFileLocation": function(w, v) {
          w.uint(3134223748);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.bytes(h(v, "fileReference"));
          w.string(h(v, "thumbSize"));
        },
        "inputSecureFileLocation": function(w, v) {
          w.uint(3418877480);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputTakeoutFileLocation": function(w) {
          w.uint(700340377);
        },
        "inputPhotoFileLocation": function(w, v) {
          w.uint(1075322878);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.bytes(h(v, "fileReference"));
          w.string(h(v, "thumbSize"));
        },
        "inputPhotoLegacyFileLocation": function(w, v) {
          w.uint(3627312883);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.bytes(h(v, "fileReference"));
          w.long(h(v, "volumeId"));
          w.int(h(v, "localId"));
          w.long(h(v, "secret"));
        },
        "inputPeerPhotoFileLocation": function(w, v) {
          w.uint(925204121);
          var flags = 0;
          if (v.big === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.long(h(v, "photoId"));
        },
        "inputStickerSetThumb": function(w, v) {
          w.uint(2642736091);
          w.object(h(v, "stickerset"));
          w.int(h(v, "thumbVersion"));
        },
        "inputGroupCallStream": function(w, v) {
          w.uint(93890858);
          var flags = 0;
          var _videoChannel = v.videoChannel !== void 0;
          var _videoQuality = v.videoQuality !== void 0;
          var _flags_0 = _videoChannel || _videoQuality;
          if (_flags_0)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "call"));
          w.long(h(v, "timeMs"));
          w.int(h(v, "scale"));
          if (_flags_0)
            w.int(v.videoChannel);
          if (_flags_0)
            w.int(v.videoQuality);
        },
        "peerUser": function(w, v) {
          w.uint(1498486562);
          w.int53(h(v, "userId"));
        },
        "peerChat": function(w, v) {
          w.uint(918946202);
          w.int53(h(v, "chatId"));
        },
        "peerChannel": function(w, v) {
          w.uint(2728736542);
          w.int53(h(v, "channelId"));
        },
        "storage.fileUnknown": function(w) {
          w.uint(2861972229);
        },
        "storage.filePartial": function(w) {
          w.uint(1086091090);
        },
        "storage.fileJpeg": function(w) {
          w.uint(8322574);
        },
        "storage.fileGif": function(w) {
          w.uint(3403786975);
        },
        "storage.filePng": function(w) {
          w.uint(172975040);
        },
        "storage.filePdf": function(w) {
          w.uint(2921222285);
        },
        "storage.fileMp3": function(w) {
          w.uint(1384777335);
        },
        "storage.fileMov": function(w) {
          w.uint(1258941372);
        },
        "storage.fileMp4": function(w) {
          w.uint(3016663268);
        },
        "storage.fileWebp": function(w) {
          w.uint(276907596);
        },
        "userEmpty": function(w, v) {
          w.uint(3552332666);
          w.int53(h(v, "id"));
        },
        "user": function(w, v) {
          w.uint(2201046986);
          var flags = 0;
          var _accessHash = v.accessHash !== void 0;
          if (_accessHash)
            flags |= 1;
          var _firstName = v.firstName !== void 0;
          if (_firstName)
            flags |= 2;
          var _lastName = v.lastName !== void 0;
          if (_lastName)
            flags |= 4;
          var _username = v.username !== void 0;
          if (_username)
            flags |= 8;
          var _phone = v.phone !== void 0;
          if (_phone)
            flags |= 16;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 32;
          var _status = v.status !== void 0;
          if (_status)
            flags |= 64;
          if (v.self === true)
            flags |= 1024;
          if (v.contact === true)
            flags |= 2048;
          if (v.mutualContact === true)
            flags |= 4096;
          if (v.deleted === true)
            flags |= 8192;
          var _botInfoVersion = v.botInfoVersion !== void 0;
          var _flags_14 = v.bot === true || _botInfoVersion;
          if (_flags_14)
            flags |= 16384;
          if (v.botChatHistory === true)
            flags |= 32768;
          if (v.botNochats === true)
            flags |= 65536;
          if (v.verified === true)
            flags |= 131072;
          var _restrictionReason = v.restrictionReason && v.restrictionReason.length;
          var _flags_18 = v.restricted === true || _restrictionReason;
          if (_flags_18)
            flags |= 262144;
          var _botInlinePlaceholder = v.botInlinePlaceholder !== void 0;
          if (_botInlinePlaceholder)
            flags |= 524288;
          if (v.min === true)
            flags |= 1048576;
          if (v.botInlineGeo === true)
            flags |= 2097152;
          var _langCode = v.langCode !== void 0;
          if (_langCode)
            flags |= 4194304;
          if (v.support === true)
            flags |= 8388608;
          if (v.scam === true)
            flags |= 16777216;
          if (v.applyMinPhoto === true)
            flags |= 33554432;
          if (v.fake === true)
            flags |= 67108864;
          if (v.botAttachMenu === true)
            flags |= 134217728;
          if (v.premium === true)
            flags |= 268435456;
          if (v.attachMenuEnabled === true)
            flags |= 536870912;
          var _emojiStatus = v.emojiStatus !== void 0;
          if (_emojiStatus)
            flags |= 1073741824;
          w.uint(flags);
          var flags2 = 0;
          var _usernames = v.usernames && v.usernames.length;
          if (_usernames)
            flags2 |= 1;
          if (v.botCanEdit === true)
            flags2 |= 2;
          if (v.closeFriend === true)
            flags2 |= 4;
          if (v.storiesHidden === true)
            flags2 |= 8;
          if (v.storiesUnavailable === true)
            flags2 |= 16;
          var _storiesMaxId = v.storiesMaxId !== void 0;
          if (_storiesMaxId)
            flags2 |= 32;
          var _color = v.color !== void 0;
          if (_color)
            flags2 |= 256;
          var _profileColor = v.profileColor !== void 0;
          if (_profileColor)
            flags2 |= 512;
          if (v.contactRequirePremium === true)
            flags2 |= 1024;
          if (v.botBusiness === true)
            flags2 |= 2048;
          var _botActiveUsers = v.botActiveUsers !== void 0;
          if (_botActiveUsers)
            flags2 |= 4096;
          if (v.botHasMainApp === true)
            flags2 |= 8192;
          w.uint(flags2);
          w.int53(h(v, "id"));
          if (_accessHash)
            w.long(v.accessHash);
          if (_firstName)
            w.string(v.firstName);
          if (_lastName)
            w.string(v.lastName);
          if (_username)
            w.string(v.username);
          if (_phone)
            w.string(v.phone);
          if (_photo)
            w.object(v.photo);
          if (_status)
            w.object(v.status);
          if (_flags_14)
            w.int(v.botInfoVersion);
          if (_flags_18)
            w.vector(w.object, v.restrictionReason);
          if (_botInlinePlaceholder)
            w.string(v.botInlinePlaceholder);
          if (_langCode)
            w.string(v.langCode);
          if (_emojiStatus)
            w.object(v.emojiStatus);
          if (_usernames)
            w.vector(w.object, v.usernames);
          if (_storiesMaxId)
            w.int(v.storiesMaxId);
          if (_color)
            w.object(v.color);
          if (_profileColor)
            w.object(v.profileColor);
          if (_botActiveUsers)
            w.int(v.botActiveUsers);
        },
        "userProfilePhotoEmpty": function(w) {
          w.uint(1326562017);
        },
        "userProfilePhoto": function(w, v) {
          w.uint(2194798342);
          var flags = 0;
          if (v.hasVideo === true)
            flags |= 1;
          var _strippedThumb = v.strippedThumb !== void 0;
          if (_strippedThumb)
            flags |= 2;
          if (v.personal === true)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "photoId"));
          if (_strippedThumb)
            w.bytes(v.strippedThumb);
          w.int(h(v, "dcId"));
        },
        "userStatusEmpty": function(w) {
          w.uint(164646985);
        },
        "userStatusOnline": function(w, v) {
          w.uint(3988339017);
          w.int(h(v, "expires"));
        },
        "userStatusOffline": function(w, v) {
          w.uint(9203775);
          w.int(h(v, "wasOnline"));
        },
        "userStatusRecently": function(w, v) {
          w.uint(2065268168);
          var flags = 0;
          if (v.byMe === true)
            flags |= 1;
          w.uint(flags);
        },
        "userStatusLastWeek": function(w, v) {
          w.uint(1410997530);
          var flags = 0;
          if (v.byMe === true)
            flags |= 1;
          w.uint(flags);
        },
        "userStatusLastMonth": function(w, v) {
          w.uint(1703516023);
          var flags = 0;
          if (v.byMe === true)
            flags |= 1;
          w.uint(flags);
        },
        "chatEmpty": function(w, v) {
          w.uint(693512293);
          w.int53(h(v, "id"));
        },
        "chat": function(w, v) {
          w.uint(1103884886);
          var flags = 0;
          if (v.creator === true)
            flags |= 1;
          if (v.left === true)
            flags |= 4;
          if (v.deactivated === true)
            flags |= 32;
          var _migratedTo = v.migratedTo !== void 0;
          if (_migratedTo)
            flags |= 64;
          var _adminRights = v.adminRights !== void 0;
          if (_adminRights)
            flags |= 16384;
          var _defaultBannedRights = v.defaultBannedRights !== void 0;
          if (_defaultBannedRights)
            flags |= 262144;
          if (v.callActive === true)
            flags |= 8388608;
          if (v.callNotEmpty === true)
            flags |= 16777216;
          if (v.noforwards === true)
            flags |= 33554432;
          w.uint(flags);
          w.int53(h(v, "id"));
          w.string(h(v, "title"));
          w.object(h(v, "photo"));
          w.int(h(v, "participantsCount"));
          w.int(h(v, "date"));
          w.int(h(v, "version"));
          if (_migratedTo)
            w.object(v.migratedTo);
          if (_adminRights)
            w.object(v.adminRights);
          if (_defaultBannedRights)
            w.object(v.defaultBannedRights);
        },
        "chatForbidden": function(w, v) {
          w.uint(1704108455);
          w.int53(h(v, "id"));
          w.string(h(v, "title"));
        },
        "channel": function(w, v) {
          w.uint(4265900221);
          var flags = 0;
          if (v.creator === true)
            flags |= 1;
          if (v.left === true)
            flags |= 4;
          if (v.broadcast === true)
            flags |= 32;
          var _username = v.username !== void 0;
          if (_username)
            flags |= 64;
          if (v.verified === true)
            flags |= 128;
          if (v.megagroup === true)
            flags |= 256;
          var _restrictionReason = v.restrictionReason && v.restrictionReason.length;
          var _flags_9 = v.restricted === true || _restrictionReason;
          if (_flags_9)
            flags |= 512;
          if (v.signatures === true)
            flags |= 2048;
          if (v.min === true)
            flags |= 4096;
          var _accessHash = v.accessHash !== void 0;
          if (_accessHash)
            flags |= 8192;
          var _adminRights = v.adminRights !== void 0;
          if (_adminRights)
            flags |= 16384;
          var _bannedRights = v.bannedRights !== void 0;
          if (_bannedRights)
            flags |= 32768;
          var _participantsCount = v.participantsCount !== void 0;
          if (_participantsCount)
            flags |= 131072;
          var _defaultBannedRights = v.defaultBannedRights !== void 0;
          if (_defaultBannedRights)
            flags |= 262144;
          if (v.scam === true)
            flags |= 524288;
          if (v.hasLink === true)
            flags |= 1048576;
          if (v.hasGeo === true)
            flags |= 2097152;
          if (v.slowmodeEnabled === true)
            flags |= 4194304;
          if (v.callActive === true)
            flags |= 8388608;
          if (v.callNotEmpty === true)
            flags |= 16777216;
          if (v.fake === true)
            flags |= 33554432;
          if (v.gigagroup === true)
            flags |= 67108864;
          if (v.noforwards === true)
            flags |= 134217728;
          if (v.joinToSend === true)
            flags |= 268435456;
          if (v.joinRequest === true)
            flags |= 536870912;
          if (v.forum === true)
            flags |= 1073741824;
          w.uint(flags);
          var flags2 = 0;
          var _usernames = v.usernames && v.usernames.length;
          if (_usernames)
            flags2 |= 1;
          if (v.storiesHidden === true)
            flags2 |= 2;
          if (v.storiesHiddenMin === true)
            flags2 |= 4;
          if (v.storiesUnavailable === true)
            flags2 |= 8;
          var _storiesMaxId = v.storiesMaxId !== void 0;
          if (_storiesMaxId)
            flags2 |= 16;
          var _color = v.color !== void 0;
          if (_color)
            flags2 |= 128;
          var _profileColor = v.profileColor !== void 0;
          if (_profileColor)
            flags2 |= 256;
          var _emojiStatus = v.emojiStatus !== void 0;
          if (_emojiStatus)
            flags2 |= 512;
          var _level = v.level !== void 0;
          if (_level)
            flags2 |= 1024;
          var _subscriptionUntilDate = v.subscriptionUntilDate !== void 0;
          if (_subscriptionUntilDate)
            flags2 |= 2048;
          if (v.signatureProfiles === true)
            flags2 |= 4096;
          w.uint(flags2);
          w.int53(h(v, "id"));
          if (_accessHash)
            w.long(v.accessHash);
          w.string(h(v, "title"));
          if (_username)
            w.string(v.username);
          w.object(h(v, "photo"));
          w.int(h(v, "date"));
          if (_flags_9)
            w.vector(w.object, v.restrictionReason);
          if (_adminRights)
            w.object(v.adminRights);
          if (_bannedRights)
            w.object(v.bannedRights);
          if (_defaultBannedRights)
            w.object(v.defaultBannedRights);
          if (_participantsCount)
            w.int(v.participantsCount);
          if (_usernames)
            w.vector(w.object, v.usernames);
          if (_storiesMaxId)
            w.int(v.storiesMaxId);
          if (_color)
            w.object(v.color);
          if (_profileColor)
            w.object(v.profileColor);
          if (_emojiStatus)
            w.object(v.emojiStatus);
          if (_level)
            w.int(v.level);
          if (_subscriptionUntilDate)
            w.int(v.subscriptionUntilDate);
        },
        "channelForbidden": function(w, v) {
          w.uint(399807445);
          var flags = 0;
          if (v.broadcast === true)
            flags |= 32;
          if (v.megagroup === true)
            flags |= 256;
          var _untilDate = v.untilDate !== void 0;
          if (_untilDate)
            flags |= 65536;
          w.uint(flags);
          w.int53(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.string(h(v, "title"));
          if (_untilDate)
            w.int(v.untilDate);
        },
        "chatFull": function(w, v) {
          w.uint(640893467);
          var flags = 0;
          var _chatPhoto = v.chatPhoto !== void 0;
          if (_chatPhoto)
            flags |= 4;
          var _botInfo = v.botInfo && v.botInfo.length;
          if (_botInfo)
            flags |= 8;
          var _pinnedMsgId = v.pinnedMsgId !== void 0;
          if (_pinnedMsgId)
            flags |= 64;
          if (v.canSetUsername === true)
            flags |= 128;
          if (v.hasScheduled === true)
            flags |= 256;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 2048;
          var _call = v.call !== void 0;
          if (_call)
            flags |= 4096;
          var _exportedInvite = v.exportedInvite !== void 0;
          if (_exportedInvite)
            flags |= 8192;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 16384;
          var _groupcallDefaultJoinAs = v.groupcallDefaultJoinAs !== void 0;
          if (_groupcallDefaultJoinAs)
            flags |= 32768;
          var _themeEmoticon = v.themeEmoticon !== void 0;
          if (_themeEmoticon)
            flags |= 65536;
          var _requestsPending = v.requestsPending !== void 0;
          var _recentRequesters = v.recentRequesters && v.recentRequesters.length;
          var _flags_17 = _requestsPending || _recentRequesters;
          if (_flags_17)
            flags |= 131072;
          var _availableReactions = v.availableReactions !== void 0;
          if (_availableReactions)
            flags |= 262144;
          if (v.translationsDisabled === true)
            flags |= 524288;
          var _reactionsLimit = v.reactionsLimit !== void 0;
          if (_reactionsLimit)
            flags |= 1048576;
          w.uint(flags);
          w.int53(h(v, "id"));
          w.string(h(v, "about"));
          w.object(h(v, "participants"));
          if (_chatPhoto)
            w.object(v.chatPhoto);
          w.object(h(v, "notifySettings"));
          if (_exportedInvite)
            w.object(v.exportedInvite);
          if (_botInfo)
            w.vector(w.object, v.botInfo);
          if (_pinnedMsgId)
            w.int(v.pinnedMsgId);
          if (_folderId)
            w.int(v.folderId);
          if (_call)
            w.object(v.call);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
          if (_groupcallDefaultJoinAs)
            w.object(v.groupcallDefaultJoinAs);
          if (_themeEmoticon)
            w.string(v.themeEmoticon);
          if (_flags_17)
            w.int(v.requestsPending);
          if (_flags_17)
            w.vector(w.long, v.recentRequesters);
          if (_availableReactions)
            w.object(v.availableReactions);
          if (_reactionsLimit)
            w.int(v.reactionsLimit);
        },
        "channelFull": function(w, v) {
          w.uint(3148559501);
          var flags = 0;
          var _participantsCount = v.participantsCount !== void 0;
          if (_participantsCount)
            flags |= 1;
          var _adminsCount = v.adminsCount !== void 0;
          if (_adminsCount)
            flags |= 2;
          var _kickedCount = v.kickedCount !== void 0;
          var _bannedCount = v.bannedCount !== void 0;
          var _flags_2 = _kickedCount || _bannedCount;
          if (_flags_2)
            flags |= 4;
          if (v.canViewParticipants === true)
            flags |= 8;
          var _migratedFromChatId = v.migratedFromChatId !== void 0;
          var _migratedFromMaxId = v.migratedFromMaxId !== void 0;
          var _flags_4 = _migratedFromChatId || _migratedFromMaxId;
          if (_flags_4)
            flags |= 16;
          var _pinnedMsgId = v.pinnedMsgId !== void 0;
          if (_pinnedMsgId)
            flags |= 32;
          if (v.canSetUsername === true)
            flags |= 64;
          if (v.canSetStickers === true)
            flags |= 128;
          var _stickerset = v.stickerset !== void 0;
          if (_stickerset)
            flags |= 256;
          var _availableMinId = v.availableMinId !== void 0;
          if (_availableMinId)
            flags |= 512;
          if (v.hiddenPrehistory === true)
            flags |= 1024;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 2048;
          var _statsDc = v.statsDc !== void 0;
          if (_statsDc)
            flags |= 4096;
          var _onlineCount = v.onlineCount !== void 0;
          if (_onlineCount)
            flags |= 8192;
          var _linkedChatId = v.linkedChatId !== void 0;
          if (_linkedChatId)
            flags |= 16384;
          var _location = v.location !== void 0;
          if (_location)
            flags |= 32768;
          if (v.canSetLocation === true)
            flags |= 65536;
          var _slowmodeSeconds = v.slowmodeSeconds !== void 0;
          if (_slowmodeSeconds)
            flags |= 131072;
          var _slowmodeNextSendDate = v.slowmodeNextSendDate !== void 0;
          if (_slowmodeNextSendDate)
            flags |= 262144;
          if (v.hasScheduled === true)
            flags |= 524288;
          if (v.canViewStats === true)
            flags |= 1048576;
          var _call = v.call !== void 0;
          if (_call)
            flags |= 2097152;
          if (v.blocked === true)
            flags |= 4194304;
          var _exportedInvite = v.exportedInvite !== void 0;
          if (_exportedInvite)
            flags |= 8388608;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 16777216;
          var _pendingSuggestions = v.pendingSuggestions && v.pendingSuggestions.length;
          if (_pendingSuggestions)
            flags |= 33554432;
          var _groupcallDefaultJoinAs = v.groupcallDefaultJoinAs !== void 0;
          if (_groupcallDefaultJoinAs)
            flags |= 67108864;
          var _themeEmoticon = v.themeEmoticon !== void 0;
          if (_themeEmoticon)
            flags |= 134217728;
          var _requestsPending = v.requestsPending !== void 0;
          var _recentRequesters = v.recentRequesters && v.recentRequesters.length;
          var _flags_28 = _requestsPending || _recentRequesters;
          if (_flags_28)
            flags |= 268435456;
          var _defaultSendAs = v.defaultSendAs !== void 0;
          if (_defaultSendAs)
            flags |= 536870912;
          var _availableReactions = v.availableReactions !== void 0;
          if (_availableReactions)
            flags |= 1073741824;
          w.uint(flags);
          var flags2 = 0;
          if (v.canDeleteChannel === true)
            flags2 |= 1;
          if (v.antispam === true)
            flags2 |= 2;
          if (v.participantsHidden === true)
            flags2 |= 4;
          if (v.translationsDisabled === true)
            flags2 |= 8;
          var _stories = v.stories !== void 0;
          if (_stories)
            flags2 |= 16;
          if (v.storiesPinnedAvailable === true)
            flags2 |= 32;
          if (v.viewForumAsMessages === true)
            flags2 |= 64;
          var _wallpaper = v.wallpaper !== void 0;
          if (_wallpaper)
            flags2 |= 128;
          var _boostsApplied = v.boostsApplied !== void 0;
          if (_boostsApplied)
            flags2 |= 256;
          var _boostsUnrestrict = v.boostsUnrestrict !== void 0;
          if (_boostsUnrestrict)
            flags2 |= 512;
          var _emojiset = v.emojiset !== void 0;
          if (_emojiset)
            flags2 |= 1024;
          if (v.restrictedSponsored === true)
            flags2 |= 2048;
          if (v.canViewRevenue === true)
            flags2 |= 4096;
          var _reactionsLimit = v.reactionsLimit !== void 0;
          if (_reactionsLimit)
            flags2 |= 8192;
          if (v.paidMediaAllowed === true)
            flags2 |= 16384;
          if (v.canViewStarsRevenue === true)
            flags2 |= 32768;
          if (v.paidReactionsAvailable === true)
            flags2 |= 65536;
          w.uint(flags2);
          w.int53(h(v, "id"));
          w.string(h(v, "about"));
          if (_participantsCount)
            w.int(v.participantsCount);
          if (_adminsCount)
            w.int(v.adminsCount);
          if (_flags_2)
            w.int(v.kickedCount);
          if (_flags_2)
            w.int(v.bannedCount);
          if (_onlineCount)
            w.int(v.onlineCount);
          w.int(h(v, "readInboxMaxId"));
          w.int(h(v, "readOutboxMaxId"));
          w.int(h(v, "unreadCount"));
          w.object(h(v, "chatPhoto"));
          w.object(h(v, "notifySettings"));
          if (_exportedInvite)
            w.object(v.exportedInvite);
          w.vector(w.object, h(v, "botInfo"));
          if (_flags_4)
            w.long(v.migratedFromChatId);
          if (_flags_4)
            w.int(v.migratedFromMaxId);
          if (_pinnedMsgId)
            w.int(v.pinnedMsgId);
          if (_stickerset)
            w.object(v.stickerset);
          if (_availableMinId)
            w.int(v.availableMinId);
          if (_folderId)
            w.int(v.folderId);
          if (_linkedChatId)
            w.int53(v.linkedChatId);
          if (_location)
            w.object(v.location);
          if (_slowmodeSeconds)
            w.int(v.slowmodeSeconds);
          if (_slowmodeNextSendDate)
            w.int(v.slowmodeNextSendDate);
          if (_statsDc)
            w.int(v.statsDc);
          w.int(h(v, "pts"));
          if (_call)
            w.object(v.call);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
          if (_pendingSuggestions)
            w.vector(w.string, v.pendingSuggestions);
          if (_groupcallDefaultJoinAs)
            w.object(v.groupcallDefaultJoinAs);
          if (_themeEmoticon)
            w.string(v.themeEmoticon);
          if (_flags_28)
            w.int(v.requestsPending);
          if (_flags_28)
            w.vector(w.long, v.recentRequesters);
          if (_defaultSendAs)
            w.object(v.defaultSendAs);
          if (_availableReactions)
            w.object(v.availableReactions);
          if (_reactionsLimit)
            w.int(v.reactionsLimit);
          if (_stories)
            w.object(v.stories);
          if (_wallpaper)
            w.object(v.wallpaper);
          if (_boostsApplied)
            w.int(v.boostsApplied);
          if (_boostsUnrestrict)
            w.int(v.boostsUnrestrict);
          if (_emojiset)
            w.object(v.emojiset);
        },
        "chatParticipant": function(w, v) {
          w.uint(3224190983);
          w.int53(h(v, "userId"));
          w.int53(h(v, "inviterId"));
          w.int(h(v, "date"));
        },
        "chatParticipantCreator": function(w, v) {
          w.uint(3832270564);
          w.int53(h(v, "userId"));
        },
        "chatParticipantAdmin": function(w, v) {
          w.uint(2694004571);
          w.int53(h(v, "userId"));
          w.int53(h(v, "inviterId"));
          w.int(h(v, "date"));
        },
        "chatParticipantsForbidden": function(w, v) {
          w.uint(2271466465);
          var flags = 0;
          var _selfParticipant = v.selfParticipant !== void 0;
          if (_selfParticipant)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "chatId"));
          if (_selfParticipant)
            w.object(v.selfParticipant);
        },
        "chatParticipants": function(w, v) {
          w.uint(1018991608);
          w.int53(h(v, "chatId"));
          w.vector(w.object, h(v, "participants"));
          w.int(h(v, "version"));
        },
        "chatPhotoEmpty": function(w) {
          w.uint(935395612);
        },
        "chatPhoto": function(w, v) {
          w.uint(476978193);
          var flags = 0;
          if (v.hasVideo === true)
            flags |= 1;
          var _strippedThumb = v.strippedThumb !== void 0;
          if (_strippedThumb)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "photoId"));
          if (_strippedThumb)
            w.bytes(v.strippedThumb);
          w.int(h(v, "dcId"));
        },
        "messageEmpty": function(w, v) {
          w.uint(2426849924);
          var flags = 0;
          var _peerId = v.peerId !== void 0;
          if (_peerId)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "id"));
          if (_peerId)
            w.object(v.peerId);
        },
        "message": function(w, v) {
          w.uint(2486456898);
          var flags = 0;
          if (v.out === true)
            flags |= 2;
          var _fwdFrom = v.fwdFrom !== void 0;
          if (_fwdFrom)
            flags |= 4;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 8;
          if (v.mentioned === true)
            flags |= 16;
          if (v.mediaUnread === true)
            flags |= 32;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 64;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 128;
          var _fromId = v.fromId !== void 0;
          if (_fromId)
            flags |= 256;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 512;
          var _views = v.views !== void 0;
          var _forwards = v.forwards !== void 0;
          var _flags_10 = _views || _forwards;
          if (_flags_10)
            flags |= 1024;
          var _viaBotId = v.viaBotId !== void 0;
          if (_viaBotId)
            flags |= 2048;
          if (v.silent === true)
            flags |= 8192;
          if (v.post === true)
            flags |= 16384;
          var _editDate = v.editDate !== void 0;
          if (_editDate)
            flags |= 32768;
          var _postAuthor = v.postAuthor !== void 0;
          if (_postAuthor)
            flags |= 65536;
          var _groupedId = v.groupedId !== void 0;
          if (_groupedId)
            flags |= 131072;
          if (v.fromScheduled === true)
            flags |= 262144;
          if (v.legacy === true)
            flags |= 524288;
          var _reactions = v.reactions !== void 0;
          if (_reactions)
            flags |= 1048576;
          if (v.editHide === true)
            flags |= 2097152;
          var _restrictionReason = v.restrictionReason && v.restrictionReason.length;
          if (_restrictionReason)
            flags |= 4194304;
          var _replies = v.replies !== void 0;
          if (_replies)
            flags |= 8388608;
          if (v.pinned === true)
            flags |= 16777216;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 33554432;
          if (v.noforwards === true)
            flags |= 67108864;
          if (v.invertMedia === true)
            flags |= 134217728;
          var _savedPeerId = v.savedPeerId !== void 0;
          if (_savedPeerId)
            flags |= 268435456;
          var _fromBoostsApplied = v.fromBoostsApplied !== void 0;
          if (_fromBoostsApplied)
            flags |= 536870912;
          var _quickReplyShortcutId = v.quickReplyShortcutId !== void 0;
          if (_quickReplyShortcutId)
            flags |= 1073741824;
          w.uint(flags);
          var flags2 = 0;
          var _viaBusinessBotId = v.viaBusinessBotId !== void 0;
          if (_viaBusinessBotId)
            flags2 |= 1;
          if (v.offline === true)
            flags2 |= 2;
          var _effect = v.effect !== void 0;
          if (_effect)
            flags2 |= 4;
          var _factcheck = v.factcheck !== void 0;
          if (_factcheck)
            flags2 |= 8;
          w.uint(flags2);
          w.int(h(v, "id"));
          if (_fromId)
            w.object(v.fromId);
          if (_fromBoostsApplied)
            w.int(v.fromBoostsApplied);
          w.object(h(v, "peerId"));
          if (_savedPeerId)
            w.object(v.savedPeerId);
          if (_fwdFrom)
            w.object(v.fwdFrom);
          if (_viaBotId)
            w.int53(v.viaBotId);
          if (_viaBusinessBotId)
            w.int53(v.viaBusinessBotId);
          if (_replyTo)
            w.object(v.replyTo);
          w.int(h(v, "date"));
          w.string(h(v, "message"));
          if (_media)
            w.object(v.media);
          if (_replyMarkup)
            w.object(v.replyMarkup);
          if (_entities)
            w.vector(w.object, v.entities);
          if (_flags_10)
            w.int(v.views);
          if (_flags_10)
            w.int(v.forwards);
          if (_replies)
            w.object(v.replies);
          if (_editDate)
            w.int(v.editDate);
          if (_postAuthor)
            w.string(v.postAuthor);
          if (_groupedId)
            w.long(v.groupedId);
          if (_reactions)
            w.object(v.reactions);
          if (_restrictionReason)
            w.vector(w.object, v.restrictionReason);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
          if (_quickReplyShortcutId)
            w.int(v.quickReplyShortcutId);
          if (_effect)
            w.long(v.effect);
          if (_factcheck)
            w.object(v.factcheck);
        },
        "messageService": function(w, v) {
          w.uint(721967202);
          var flags = 0;
          if (v.out === true)
            flags |= 2;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 8;
          if (v.mentioned === true)
            flags |= 16;
          if (v.mediaUnread === true)
            flags |= 32;
          var _fromId = v.fromId !== void 0;
          if (_fromId)
            flags |= 256;
          if (v.silent === true)
            flags |= 8192;
          if (v.post === true)
            flags |= 16384;
          if (v.legacy === true)
            flags |= 524288;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 33554432;
          w.uint(flags);
          w.int(h(v, "id"));
          if (_fromId)
            w.object(v.fromId);
          w.object(h(v, "peerId"));
          if (_replyTo)
            w.object(v.replyTo);
          w.int(h(v, "date"));
          w.object(h(v, "action"));
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "messageMediaEmpty": function(w) {
          w.uint(1038967584);
        },
        "messageMediaPhoto": function(w, v) {
          w.uint(1766936791);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 1;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 4;
          if (v.spoiler === true)
            flags |= 8;
          w.uint(flags);
          if (_photo)
            w.object(v.photo);
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
        },
        "messageMediaGeo": function(w, v) {
          w.uint(1457575028);
          w.object(h(v, "geo"));
        },
        "messageMediaContact": function(w, v) {
          w.uint(1882335561);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
          w.string(h(v, "vcard"));
          w.int53(h(v, "userId"));
        },
        "messageMediaUnsupported": function(w) {
          w.uint(2676290718);
        },
        "messageMediaDocument": function(w, v) {
          w.uint(3713469397);
          var flags = 0;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 1;
          var _ttlSeconds = v.ttlSeconds !== void 0;
          if (_ttlSeconds)
            flags |= 4;
          if (v.nopremium === true)
            flags |= 8;
          if (v.spoiler === true)
            flags |= 16;
          var _altDocuments = v.altDocuments && v.altDocuments.length;
          if (_altDocuments)
            flags |= 32;
          if (v.video === true)
            flags |= 64;
          if (v.round === true)
            flags |= 128;
          if (v.voice === true)
            flags |= 256;
          w.uint(flags);
          if (_document)
            w.object(v.document);
          if (_altDocuments)
            w.vector(w.object, v.altDocuments);
          if (_ttlSeconds)
            w.int(v.ttlSeconds);
        },
        "messageMediaWebPage": function(w, v) {
          w.uint(3723562043);
          var flags = 0;
          if (v.forceLargeMedia === true)
            flags |= 1;
          if (v.forceSmallMedia === true)
            flags |= 2;
          if (v.manual === true)
            flags |= 8;
          if (v.safe === true)
            flags |= 16;
          w.uint(flags);
          w.object(h(v, "webpage"));
        },
        "messageMediaVenue": function(w, v) {
          w.uint(784356159);
          w.object(h(v, "geo"));
          w.string(h(v, "title"));
          w.string(h(v, "address"));
          w.string(h(v, "provider"));
          w.string(h(v, "venueId"));
          w.string(h(v, "venueType"));
        },
        "messageMediaGame": function(w, v) {
          w.uint(4256272392);
          w.object(h(v, "game"));
        },
        "messageMediaInvoice": function(w, v) {
          w.uint(4138027219);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 1;
          if (v.shippingAddressRequested === true)
            flags |= 2;
          var _receiptMsgId = v.receiptMsgId !== void 0;
          if (_receiptMsgId)
            flags |= 4;
          if (v.test === true)
            flags |= 8;
          var _extendedMedia = v.extendedMedia !== void 0;
          if (_extendedMedia)
            flags |= 16;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          if (_receiptMsgId)
            w.int(v.receiptMsgId);
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
          w.string(h(v, "startParam"));
          if (_extendedMedia)
            w.object(v.extendedMedia);
        },
        "messageMediaGeoLive": function(w, v) {
          w.uint(3108030054);
          var flags = 0;
          var _heading = v.heading !== void 0;
          if (_heading)
            flags |= 1;
          var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
          if (_proximityNotificationRadius)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "geo"));
          if (_heading)
            w.int(v.heading);
          w.int(h(v, "period"));
          if (_proximityNotificationRadius)
            w.int(v.proximityNotificationRadius);
        },
        "messageMediaPoll": function(w, v) {
          w.uint(1272375192);
          w.object(h(v, "poll"));
          w.object(h(v, "results"));
        },
        "messageMediaDice": function(w, v) {
          w.uint(1065280907);
          w.int(h(v, "value"));
          w.string(h(v, "emoticon"));
        },
        "messageMediaStory": function(w, v) {
          w.uint(1758159491);
          var flags = 0;
          var _story = v.story !== void 0;
          if (_story)
            flags |= 1;
          if (v.viaMention === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          if (_story)
            w.object(v.story);
        },
        "messageMediaGiveaway": function(w, v) {
          w.uint(2852600811);
          var flags = 0;
          if (v.onlyNewSubscribers === true)
            flags |= 1;
          var _countriesIso2 = v.countriesIso2 && v.countriesIso2.length;
          if (_countriesIso2)
            flags |= 2;
          if (v.winnersAreVisible === true)
            flags |= 4;
          var _prizeDescription = v.prizeDescription !== void 0;
          if (_prizeDescription)
            flags |= 8;
          var _months = v.months !== void 0;
          if (_months)
            flags |= 16;
          var _stars = v.stars !== void 0;
          if (_stars)
            flags |= 32;
          w.uint(flags);
          w.vector(w.int53, h(v, "channels"));
          if (_countriesIso2)
            w.vector(w.string, v.countriesIso2);
          if (_prizeDescription)
            w.string(v.prizeDescription);
          w.int(h(v, "quantity"));
          if (_months)
            w.int(v.months);
          if (_stars)
            w.long(v.stars);
          w.int(h(v, "untilDate"));
        },
        "messageMediaGiveawayResults": function(w, v) {
          w.uint(3467263649);
          var flags = 0;
          if (v.onlyNewSubscribers === true)
            flags |= 1;
          var _prizeDescription = v.prizeDescription !== void 0;
          if (_prizeDescription)
            flags |= 2;
          if (v.refunded === true)
            flags |= 4;
          var _additionalPeersCount = v.additionalPeersCount !== void 0;
          if (_additionalPeersCount)
            flags |= 8;
          var _months = v.months !== void 0;
          if (_months)
            flags |= 16;
          var _stars = v.stars !== void 0;
          if (_stars)
            flags |= 32;
          w.uint(flags);
          w.long(h(v, "channelId"));
          if (_additionalPeersCount)
            w.int(v.additionalPeersCount);
          w.int(h(v, "launchMsgId"));
          w.int(h(v, "winnersCount"));
          w.int(h(v, "unclaimedCount"));
          w.vector(w.long, h(v, "winners"));
          if (_months)
            w.int(v.months);
          if (_stars)
            w.long(v.stars);
          if (_prizeDescription)
            w.string(v.prizeDescription);
          w.int(h(v, "untilDate"));
        },
        "messageMediaPaidMedia": function(w, v) {
          w.uint(2827297937);
          w.long(h(v, "starsAmount"));
          w.vector(w.object, h(v, "extendedMedia"));
        },
        "messageActionEmpty": function(w) {
          w.uint(3064919984);
        },
        "messageActionChatCreate": function(w, v) {
          w.uint(3175599021);
          w.string(h(v, "title"));
          w.vector(w.int53, h(v, "users"));
        },
        "messageActionChatEditTitle": function(w, v) {
          w.uint(3047280218);
          w.string(h(v, "title"));
        },
        "messageActionChatEditPhoto": function(w, v) {
          w.uint(2144015272);
          w.object(h(v, "photo"));
        },
        "messageActionChatDeletePhoto": function(w) {
          w.uint(2514746351);
        },
        "messageActionChatAddUser": function(w, v) {
          w.uint(365886720);
          w.vector(w.int53, h(v, "users"));
        },
        "messageActionChatDeleteUser": function(w, v) {
          w.uint(2755604684);
          w.int53(h(v, "userId"));
        },
        "messageActionChatJoinedByLink": function(w, v) {
          w.uint(51520707);
          w.int53(h(v, "inviterId"));
        },
        "messageActionChannelCreate": function(w, v) {
          w.uint(2513611922);
          w.string(h(v, "title"));
        },
        "messageActionChatMigrateTo": function(w, v) {
          w.uint(3775102866);
          w.int53(h(v, "channelId"));
        },
        "messageActionChannelMigrateFrom": function(w, v) {
          w.uint(3929622761);
          w.string(h(v, "title"));
          w.int53(h(v, "chatId"));
        },
        "messageActionPinMessage": function(w) {
          w.uint(2495428845);
        },
        "messageActionHistoryClear": function(w) {
          w.uint(2679813636);
        },
        "messageActionGameScore": function(w, v) {
          w.uint(2460428406);
          w.long(h(v, "gameId"));
          w.int(h(v, "score"));
        },
        "messageActionPaymentSentMe": function(w, v) {
          w.uint(2402399015);
          var flags = 0;
          var _info = v.info !== void 0;
          if (_info)
            flags |= 1;
          var _shippingOptionId = v.shippingOptionId !== void 0;
          if (_shippingOptionId)
            flags |= 2;
          if (v.recurringInit === true)
            flags |= 4;
          if (v.recurringUsed === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
          w.bytes(h(v, "payload"));
          if (_info)
            w.object(v.info);
          if (_shippingOptionId)
            w.string(v.shippingOptionId);
          w.object(h(v, "charge"));
        },
        "messageActionPaymentSent": function(w, v) {
          w.uint(2518040406);
          var flags = 0;
          var _invoiceSlug = v.invoiceSlug !== void 0;
          if (_invoiceSlug)
            flags |= 1;
          if (v.recurringInit === true)
            flags |= 4;
          if (v.recurringUsed === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
          if (_invoiceSlug)
            w.string(v.invoiceSlug);
        },
        "messageActionPhoneCall": function(w, v) {
          w.uint(2162236031);
          var flags = 0;
          var _reason = v.reason !== void 0;
          if (_reason)
            flags |= 1;
          var _duration = v.duration !== void 0;
          if (_duration)
            flags |= 2;
          if (v.video === true)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "callId"));
          if (_reason)
            w.object(v.reason);
          if (_duration)
            w.int(v.duration);
        },
        "messageActionScreenshotTaken": function(w) {
          w.uint(1200788123);
        },
        "messageActionCustomAction": function(w, v) {
          w.uint(4209418070);
          w.string(h(v, "message"));
        },
        "messageActionBotAllowed": function(w, v) {
          w.uint(3306608249);
          var flags = 0;
          var _domain = v.domain !== void 0;
          if (_domain)
            flags |= 1;
          if (v.attachMenu === true)
            flags |= 2;
          var _app = v.app !== void 0;
          if (_app)
            flags |= 4;
          if (v.fromRequest === true)
            flags |= 8;
          w.uint(flags);
          if (_domain)
            w.string(v.domain);
          if (_app)
            w.object(v.app);
        },
        "messageActionSecureValuesSentMe": function(w, v) {
          w.uint(455635795);
          w.vector(w.object, h(v, "values"));
          w.object(h(v, "credentials"));
        },
        "messageActionSecureValuesSent": function(w, v) {
          w.uint(3646710100);
          w.vector(w.object, h(v, "types"));
        },
        "messageActionContactSignUp": function(w) {
          w.uint(4092747638);
        },
        "messageActionGeoProximityReached": function(w, v) {
          w.uint(2564871831);
          w.object(h(v, "fromId"));
          w.object(h(v, "toId"));
          w.int(h(v, "distance"));
        },
        "messageActionGroupCall": function(w, v) {
          w.uint(2047704898);
          var flags = 0;
          var _duration = v.duration !== void 0;
          if (_duration)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "call"));
          if (_duration)
            w.int(v.duration);
        },
        "messageActionInviteToGroupCall": function(w, v) {
          w.uint(1345295095);
          w.object(h(v, "call"));
          w.vector(w.int53, h(v, "users"));
        },
        "messageActionSetMessagesTTL": function(w, v) {
          w.uint(1007897979);
          var flags = 0;
          var _autoSettingFrom = v.autoSettingFrom !== void 0;
          if (_autoSettingFrom)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "period"));
          if (_autoSettingFrom)
            w.long(v.autoSettingFrom);
        },
        "messageActionGroupCallScheduled": function(w, v) {
          w.uint(3013637729);
          w.object(h(v, "call"));
          w.int(h(v, "scheduleDate"));
        },
        "messageActionSetChatTheme": function(w, v) {
          w.uint(2860016453);
          w.string(h(v, "emoticon"));
        },
        "messageActionChatJoinedByRequest": function(w) {
          w.uint(3955008459);
        },
        "messageActionWebViewDataSentMe": function(w, v) {
          w.uint(1205698681);
          w.string(h(v, "text"));
          w.string(h(v, "data"));
        },
        "messageActionWebViewDataSent": function(w, v) {
          w.uint(3032714421);
          w.string(h(v, "text"));
        },
        "messageActionGiftPremium": function(w, v) {
          w.uint(3359468268);
          var flags = 0;
          var _cryptoCurrency = v.cryptoCurrency !== void 0;
          var _cryptoAmount = v.cryptoAmount !== void 0;
          var _flags_0 = _cryptoCurrency || _cryptoAmount;
          if (_flags_0)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
          w.int(h(v, "months"));
          if (_flags_0)
            w.string(v.cryptoCurrency);
          if (_flags_0)
            w.long(v.cryptoAmount);
        },
        "messageActionTopicCreate": function(w, v) {
          w.uint(228168278);
          var flags = 0;
          var _iconEmojiId = v.iconEmojiId !== void 0;
          if (_iconEmojiId)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "title"));
          w.int(h(v, "iconColor"));
          if (_iconEmojiId)
            w.long(v.iconEmojiId);
        },
        "messageActionTopicEdit": function(w, v) {
          w.uint(3230943264);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _iconEmojiId = v.iconEmojiId !== void 0;
          if (_iconEmojiId)
            flags |= 2;
          var _closed = v.closed !== void 0;
          if (_closed)
            flags |= 4;
          var _hidden = v.hidden !== void 0;
          if (_hidden)
            flags |= 8;
          w.uint(flags);
          if (_title)
            w.string(v.title);
          if (_iconEmojiId)
            w.long(v.iconEmojiId);
          if (_closed)
            w.boolean(v.closed);
          if (_hidden)
            w.boolean(v.hidden);
        },
        "messageActionSuggestProfilePhoto": function(w, v) {
          w.uint(1474192222);
          w.object(h(v, "photo"));
        },
        "messageActionRequestedPeer": function(w, v) {
          w.uint(827428507);
          w.int(h(v, "buttonId"));
          w.vector(w.object, h(v, "peers"));
        },
        "messageActionSetChatWallPaper": function(w, v) {
          w.uint(1348510708);
          var flags = 0;
          if (v.same === true)
            flags |= 1;
          if (v.forBoth === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "wallpaper"));
        },
        "messageActionGiftCode": function(w, v) {
          w.uint(1737240073);
          var flags = 0;
          if (v.viaGiveaway === true)
            flags |= 1;
          var _boostPeer = v.boostPeer !== void 0;
          if (_boostPeer)
            flags |= 2;
          var _currency = v.currency !== void 0;
          var _amount = v.amount !== void 0;
          var _flags_2 = v.unclaimed === true || _currency || _amount;
          if (_flags_2)
            flags |= 4;
          var _cryptoCurrency = v.cryptoCurrency !== void 0;
          var _cryptoAmount = v.cryptoAmount !== void 0;
          var _flags_3 = _cryptoCurrency || _cryptoAmount;
          if (_flags_3)
            flags |= 8;
          w.uint(flags);
          if (_boostPeer)
            w.object(v.boostPeer);
          w.int(h(v, "months"));
          w.string(h(v, "slug"));
          if (_flags_2)
            w.string(v.currency);
          if (_flags_2)
            w.long(v.amount);
          if (_flags_3)
            w.string(v.cryptoCurrency);
          if (_flags_3)
            w.long(v.cryptoAmount);
        },
        "messageActionGiveawayLaunch": function(w, v) {
          w.uint(2819576292);
          var flags = 0;
          var _stars = v.stars !== void 0;
          if (_stars)
            flags |= 1;
          w.uint(flags);
          if (_stars)
            w.long(v.stars);
        },
        "messageActionGiveawayResults": function(w, v) {
          w.uint(2279797077);
          var flags = 0;
          if (v.stars === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "winnersCount"));
          w.int(h(v, "unclaimedCount"));
        },
        "messageActionBoostApply": function(w, v) {
          w.uint(3422726765);
          w.int(h(v, "boosts"));
        },
        "messageActionRequestedPeerSentMe": function(w, v) {
          w.uint(2477987912);
          w.int(h(v, "buttonId"));
          w.vector(w.object, h(v, "peers"));
        },
        "messageActionPaymentRefunded": function(w, v) {
          w.uint(1102307842);
          var flags = 0;
          var _payload = v.payload !== void 0;
          if (_payload)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
          if (_payload)
            w.bytes(v.payload);
          w.object(h(v, "charge"));
        },
        "messageActionGiftStars": function(w, v) {
          w.uint(1171632161);
          var flags = 0;
          var _cryptoCurrency = v.cryptoCurrency !== void 0;
          var _cryptoAmount = v.cryptoAmount !== void 0;
          var _flags_0 = _cryptoCurrency || _cryptoAmount;
          if (_flags_0)
            flags |= 1;
          var _transactionId = v.transactionId !== void 0;
          if (_transactionId)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
          w.long(h(v, "stars"));
          if (_flags_0)
            w.string(v.cryptoCurrency);
          if (_flags_0)
            w.long(v.cryptoAmount);
          if (_transactionId)
            w.string(v.transactionId);
        },
        "messageActionPrizeStars": function(w, v) {
          w.uint(2953594786);
          var flags = 0;
          if (v.unclaimed === true)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "stars"));
          w.string(h(v, "transactionId"));
          w.object(h(v, "boostPeer"));
          w.int(h(v, "giveawayMsgId"));
        },
        "messageActionStarGift": function(w, v) {
          w.uint(2612260676);
          var flags = 0;
          if (v.nameHidden === true)
            flags |= 1;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 2;
          if (v.saved === true)
            flags |= 4;
          if (v.converted === true)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "gift"));
          if (_message)
            w.object(v.message);
          w.long(h(v, "convertStars"));
        },
        "dialog": function(w, v) {
          w.uint(3582593222);
          var flags = 0;
          var _pts = v.pts !== void 0;
          if (_pts)
            flags |= 1;
          var _draft = v.draft !== void 0;
          if (_draft)
            flags |= 2;
          if (v.pinned === true)
            flags |= 4;
          if (v.unreadMark === true)
            flags |= 8;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 16;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 32;
          if (v.viewForumAsMessages === true)
            flags |= 64;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "topMessage"));
          w.int(h(v, "readInboxMaxId"));
          w.int(h(v, "readOutboxMaxId"));
          w.int(h(v, "unreadCount"));
          w.int(h(v, "unreadMentionsCount"));
          w.int(h(v, "unreadReactionsCount"));
          w.object(h(v, "notifySettings"));
          if (_pts)
            w.int(v.pts);
          if (_draft)
            w.object(v.draft);
          if (_folderId)
            w.int(v.folderId);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "dialogFolder": function(w, v) {
          w.uint(1908216652);
          var flags = 0;
          if (v.pinned === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "folder"));
          w.object(h(v, "peer"));
          w.int(h(v, "topMessage"));
          w.int(h(v, "unreadMutedPeersCount"));
          w.int(h(v, "unreadUnmutedPeersCount"));
          w.int(h(v, "unreadMutedMessagesCount"));
          w.int(h(v, "unreadUnmutedMessagesCount"));
        },
        "photoEmpty": function(w, v) {
          w.uint(590459437);
          w.long(h(v, "id"));
        },
        "photo": function(w, v) {
          w.uint(4212750949);
          var flags = 0;
          if (v.hasStickers === true)
            flags |= 1;
          var _videoSizes = v.videoSizes && v.videoSizes.length;
          if (_videoSizes)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.bytes(h(v, "fileReference"));
          w.int(h(v, "date"));
          w.vector(w.object, h(v, "sizes"));
          if (_videoSizes)
            w.vector(w.object, v.videoSizes);
          w.int(h(v, "dcId"));
        },
        "photoSizeEmpty": function(w, v) {
          w.uint(236446268);
          w.string(h(v, "type"));
        },
        "photoSize": function(w, v) {
          w.uint(1976012384);
          w.string(h(v, "type"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
          w.int(h(v, "size"));
        },
        "photoCachedSize": function(w, v) {
          w.uint(35527382);
          w.string(h(v, "type"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
          w.bytes(h(v, "bytes"));
        },
        "photoStrippedSize": function(w, v) {
          w.uint(3769678894);
          w.string(h(v, "type"));
          w.bytes(h(v, "bytes"));
        },
        "photoSizeProgressive": function(w, v) {
          w.uint(4198431637);
          w.string(h(v, "type"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
          w.vector(w.int, h(v, "sizes"));
        },
        "photoPathSize": function(w, v) {
          w.uint(3626061121);
          w.string(h(v, "type"));
          w.bytes(h(v, "bytes"));
        },
        "geoPointEmpty": function(w) {
          w.uint(286776671);
        },
        "geoPoint": function(w, v) {
          w.uint(2997024355);
          var flags = 0;
          var _accuracyRadius = v.accuracyRadius !== void 0;
          if (_accuracyRadius)
            flags |= 1;
          w.uint(flags);
          w.double(h(v, "long"));
          w.double(h(v, "lat"));
          w.long(h(v, "accessHash"));
          if (_accuracyRadius)
            w.int(v.accuracyRadius);
        },
        "auth.sentCode": function(w, v) {
          w.uint(1577067778);
          var flags = 0;
          var _nextType = v.nextType !== void 0;
          if (_nextType)
            flags |= 2;
          var _timeout = v.timeout !== void 0;
          if (_timeout)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "type"));
          w.string(h(v, "phoneCodeHash"));
          if (_nextType)
            w.object(v.nextType);
          if (_timeout)
            w.int(v.timeout);
        },
        "auth.sentCodeSuccess": function(w, v) {
          w.uint(596704836);
          w.object(h(v, "authorization"));
        },
        "auth.authorization": function(w, v) {
          w.uint(782418132);
          var flags = 0;
          var _tmpSessions = v.tmpSessions !== void 0;
          if (_tmpSessions)
            flags |= 1;
          var _otherwiseReloginDays = v.otherwiseReloginDays !== void 0;
          var _flags_1 = v.setupPasswordRequired === true || _otherwiseReloginDays;
          if (_flags_1)
            flags |= 2;
          var _futureAuthToken = v.futureAuthToken !== void 0;
          if (_futureAuthToken)
            flags |= 4;
          w.uint(flags);
          if (_flags_1)
            w.int(v.otherwiseReloginDays);
          if (_tmpSessions)
            w.int(v.tmpSessions);
          if (_futureAuthToken)
            w.bytes(v.futureAuthToken);
          w.object(h(v, "user"));
        },
        "auth.authorizationSignUpRequired": function(w, v) {
          w.uint(1148485274);
          var flags = 0;
          var _termsOfService = v.termsOfService !== void 0;
          if (_termsOfService)
            flags |= 1;
          w.uint(flags);
          if (_termsOfService)
            w.object(v.termsOfService);
        },
        "auth.exportedAuthorization": function(w, v) {
          w.uint(3023364792);
          w.long(h(v, "id"));
          w.bytes(h(v, "bytes"));
        },
        "inputNotifyPeer": function(w, v) {
          w.uint(3099351820);
          w.object(h(v, "peer"));
        },
        "inputNotifyUsers": function(w) {
          w.uint(423314455);
        },
        "inputNotifyChats": function(w) {
          w.uint(1251338318);
        },
        "inputNotifyBroadcasts": function(w) {
          w.uint(2983951486);
        },
        "inputNotifyForumTopic": function(w, v) {
          w.uint(1548122514);
          w.object(h(v, "peer"));
          w.int(h(v, "topMsgId"));
        },
        "inputPeerNotifySettings": function(w, v) {
          w.uint(3402328802);
          var flags = 0;
          var _showPreviews = v.showPreviews !== void 0;
          if (_showPreviews)
            flags |= 1;
          var _silent = v.silent !== void 0;
          if (_silent)
            flags |= 2;
          var _muteUntil = v.muteUntil !== void 0;
          if (_muteUntil)
            flags |= 4;
          var _sound = v.sound !== void 0;
          if (_sound)
            flags |= 8;
          var _storiesMuted = v.storiesMuted !== void 0;
          if (_storiesMuted)
            flags |= 64;
          var _storiesHideSender = v.storiesHideSender !== void 0;
          if (_storiesHideSender)
            flags |= 128;
          var _storiesSound = v.storiesSound !== void 0;
          if (_storiesSound)
            flags |= 256;
          w.uint(flags);
          if (_showPreviews)
            w.boolean(v.showPreviews);
          if (_silent)
            w.boolean(v.silent);
          if (_muteUntil)
            w.int(v.muteUntil);
          if (_sound)
            w.object(v.sound);
          if (_storiesMuted)
            w.boolean(v.storiesMuted);
          if (_storiesHideSender)
            w.boolean(v.storiesHideSender);
          if (_storiesSound)
            w.object(v.storiesSound);
        },
        "peerNotifySettings": function(w, v) {
          w.uint(2573347852);
          var flags = 0;
          var _showPreviews = v.showPreviews !== void 0;
          if (_showPreviews)
            flags |= 1;
          var _silent = v.silent !== void 0;
          if (_silent)
            flags |= 2;
          var _muteUntil = v.muteUntil !== void 0;
          if (_muteUntil)
            flags |= 4;
          var _iosSound = v.iosSound !== void 0;
          if (_iosSound)
            flags |= 8;
          var _androidSound = v.androidSound !== void 0;
          if (_androidSound)
            flags |= 16;
          var _otherSound = v.otherSound !== void 0;
          if (_otherSound)
            flags |= 32;
          var _storiesMuted = v.storiesMuted !== void 0;
          if (_storiesMuted)
            flags |= 64;
          var _storiesHideSender = v.storiesHideSender !== void 0;
          if (_storiesHideSender)
            flags |= 128;
          var _storiesIosSound = v.storiesIosSound !== void 0;
          if (_storiesIosSound)
            flags |= 256;
          var _storiesAndroidSound = v.storiesAndroidSound !== void 0;
          if (_storiesAndroidSound)
            flags |= 512;
          var _storiesOtherSound = v.storiesOtherSound !== void 0;
          if (_storiesOtherSound)
            flags |= 1024;
          w.uint(flags);
          if (_showPreviews)
            w.boolean(v.showPreviews);
          if (_silent)
            w.boolean(v.silent);
          if (_muteUntil)
            w.int(v.muteUntil);
          if (_iosSound)
            w.object(v.iosSound);
          if (_androidSound)
            w.object(v.androidSound);
          if (_otherSound)
            w.object(v.otherSound);
          if (_storiesMuted)
            w.boolean(v.storiesMuted);
          if (_storiesHideSender)
            w.boolean(v.storiesHideSender);
          if (_storiesIosSound)
            w.object(v.storiesIosSound);
          if (_storiesAndroidSound)
            w.object(v.storiesAndroidSound);
          if (_storiesOtherSound)
            w.object(v.storiesOtherSound);
        },
        "peerSettings": function(w, v) {
          w.uint(2899733598);
          var flags = 0;
          if (v.reportSpam === true)
            flags |= 1;
          if (v.addContact === true)
            flags |= 2;
          if (v.blockContact === true)
            flags |= 4;
          if (v.shareContact === true)
            flags |= 8;
          if (v.needContactsException === true)
            flags |= 16;
          if (v.reportGeo === true)
            flags |= 32;
          var _geoDistance = v.geoDistance !== void 0;
          if (_geoDistance)
            flags |= 64;
          if (v.autoarchived === true)
            flags |= 128;
          if (v.inviteMembers === true)
            flags |= 256;
          var _requestChatTitle = v.requestChatTitle !== void 0;
          var _requestChatDate = v.requestChatDate !== void 0;
          var _flags_9 = _requestChatTitle || _requestChatDate;
          if (_flags_9)
            flags |= 512;
          if (v.requestChatBroadcast === true)
            flags |= 1024;
          if (v.businessBotPaused === true)
            flags |= 2048;
          if (v.businessBotCanReply === true)
            flags |= 4096;
          var _businessBotId = v.businessBotId !== void 0;
          var _businessBotManageUrl = v.businessBotManageUrl !== void 0;
          var _flags_13 = _businessBotId || _businessBotManageUrl;
          if (_flags_13)
            flags |= 8192;
          w.uint(flags);
          if (_geoDistance)
            w.int(v.geoDistance);
          if (_flags_9)
            w.string(v.requestChatTitle);
          if (_flags_9)
            w.int(v.requestChatDate);
          if (_flags_13)
            w.int53(v.businessBotId);
          if (_flags_13)
            w.string(v.businessBotManageUrl);
        },
        "wallPaper": function(w, v) {
          w.uint(2755118061);
          w.long(h(v, "id"));
          var flags = 0;
          if (v.creator === true)
            flags |= 1;
          if (v.default === true)
            flags |= 2;
          var _settings = v.settings !== void 0;
          if (_settings)
            flags |= 4;
          if (v.pattern === true)
            flags |= 8;
          if (v.dark === true)
            flags |= 16;
          w.uint(flags);
          w.long(h(v, "accessHash"));
          w.string(h(v, "slug"));
          w.object(h(v, "document"));
          if (_settings)
            w.object(v.settings);
        },
        "wallPaperNoFile": function(w, v) {
          w.uint(3766501654);
          w.long(h(v, "id"));
          var flags = 0;
          if (v.default === true)
            flags |= 2;
          var _settings = v.settings !== void 0;
          if (_settings)
            flags |= 4;
          if (v.dark === true)
            flags |= 16;
          w.uint(flags);
          if (_settings)
            w.object(v.settings);
        },
        "inputReportReasonSpam": function(w) {
          w.uint(1490799288);
        },
        "inputReportReasonViolence": function(w) {
          w.uint(505595789);
        },
        "inputReportReasonPornography": function(w) {
          w.uint(777640226);
        },
        "inputReportReasonChildAbuse": function(w) {
          w.uint(2918469347);
        },
        "inputReportReasonOther": function(w) {
          w.uint(3252986545);
        },
        "inputReportReasonCopyright": function(w) {
          w.uint(2609510714);
        },
        "inputReportReasonGeoIrrelevant": function(w) {
          w.uint(3688169197);
        },
        "inputReportReasonFake": function(w) {
          w.uint(4124956391);
        },
        "inputReportReasonIllegalDrugs": function(w) {
          w.uint(177124030);
        },
        "inputReportReasonPersonalDetails": function(w) {
          w.uint(2663876157);
        },
        "userFull": function(w, v) {
          w.uint(525919081);
          var flags = 0;
          if (v.blocked === true)
            flags |= 1;
          var _about = v.about !== void 0;
          if (_about)
            flags |= 2;
          var _profilePhoto = v.profilePhoto !== void 0;
          if (_profilePhoto)
            flags |= 4;
          var _botInfo = v.botInfo !== void 0;
          if (_botInfo)
            flags |= 8;
          if (v.phoneCallsAvailable === true)
            flags |= 16;
          if (v.phoneCallsPrivate === true)
            flags |= 32;
          var _pinnedMsgId = v.pinnedMsgId !== void 0;
          if (_pinnedMsgId)
            flags |= 64;
          if (v.canPinMessage === true)
            flags |= 128;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 2048;
          if (v.hasScheduled === true)
            flags |= 4096;
          if (v.videoCallsAvailable === true)
            flags |= 8192;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 16384;
          var _themeEmoticon = v.themeEmoticon !== void 0;
          if (_themeEmoticon)
            flags |= 32768;
          var _privateForwardName = v.privateForwardName !== void 0;
          if (_privateForwardName)
            flags |= 65536;
          var _botGroupAdminRights = v.botGroupAdminRights !== void 0;
          if (_botGroupAdminRights)
            flags |= 131072;
          var _botBroadcastAdminRights = v.botBroadcastAdminRights !== void 0;
          if (_botBroadcastAdminRights)
            flags |= 262144;
          var _premiumGifts = v.premiumGifts && v.premiumGifts.length;
          if (_premiumGifts)
            flags |= 524288;
          if (v.voiceMessagesForbidden === true)
            flags |= 1048576;
          var _personalPhoto = v.personalPhoto !== void 0;
          if (_personalPhoto)
            flags |= 2097152;
          var _fallbackPhoto = v.fallbackPhoto !== void 0;
          if (_fallbackPhoto)
            flags |= 4194304;
          if (v.translationsDisabled === true)
            flags |= 8388608;
          var _wallpaper = v.wallpaper !== void 0;
          if (_wallpaper)
            flags |= 16777216;
          var _stories = v.stories !== void 0;
          if (_stories)
            flags |= 33554432;
          if (v.storiesPinnedAvailable === true)
            flags |= 67108864;
          if (v.blockedMyStoriesFrom === true)
            flags |= 134217728;
          if (v.wallpaperOverridden === true)
            flags |= 268435456;
          if (v.contactRequirePremium === true)
            flags |= 536870912;
          if (v.readDatesPrivate === true)
            flags |= 1073741824;
          w.uint(flags);
          var flags2 = 0;
          var _businessWorkHours = v.businessWorkHours !== void 0;
          if (_businessWorkHours)
            flags2 |= 1;
          var _businessLocation = v.businessLocation !== void 0;
          if (_businessLocation)
            flags2 |= 2;
          var _businessGreetingMessage = v.businessGreetingMessage !== void 0;
          if (_businessGreetingMessage)
            flags2 |= 4;
          var _businessAwayMessage = v.businessAwayMessage !== void 0;
          if (_businessAwayMessage)
            flags2 |= 8;
          var _businessIntro = v.businessIntro !== void 0;
          if (_businessIntro)
            flags2 |= 16;
          var _birthday = v.birthday !== void 0;
          if (_birthday)
            flags2 |= 32;
          var _personalChannelId = v.personalChannelId !== void 0;
          var _personalChannelMessage = v.personalChannelMessage !== void 0;
          var _flags2_6 = _personalChannelId || _personalChannelMessage;
          if (_flags2_6)
            flags2 |= 64;
          if (v.sponsoredEnabled === true)
            flags2 |= 128;
          var _stargiftsCount = v.stargiftsCount !== void 0;
          if (_stargiftsCount)
            flags2 |= 256;
          w.uint(flags2);
          w.int53(h(v, "id"));
          if (_about)
            w.string(v.about);
          w.object(h(v, "settings"));
          if (_personalPhoto)
            w.object(v.personalPhoto);
          if (_profilePhoto)
            w.object(v.profilePhoto);
          if (_fallbackPhoto)
            w.object(v.fallbackPhoto);
          w.object(h(v, "notifySettings"));
          if (_botInfo)
            w.object(v.botInfo);
          if (_pinnedMsgId)
            w.int(v.pinnedMsgId);
          w.int(h(v, "commonChatsCount"));
          if (_folderId)
            w.int(v.folderId);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
          if (_themeEmoticon)
            w.string(v.themeEmoticon);
          if (_privateForwardName)
            w.string(v.privateForwardName);
          if (_botGroupAdminRights)
            w.object(v.botGroupAdminRights);
          if (_botBroadcastAdminRights)
            w.object(v.botBroadcastAdminRights);
          if (_premiumGifts)
            w.vector(w.object, v.premiumGifts);
          if (_wallpaper)
            w.object(v.wallpaper);
          if (_stories)
            w.object(v.stories);
          if (_businessWorkHours)
            w.object(v.businessWorkHours);
          if (_businessLocation)
            w.object(v.businessLocation);
          if (_businessGreetingMessage)
            w.object(v.businessGreetingMessage);
          if (_businessAwayMessage)
            w.object(v.businessAwayMessage);
          if (_businessIntro)
            w.object(v.businessIntro);
          if (_birthday)
            w.object(v.birthday);
          if (_flags2_6)
            w.int53(v.personalChannelId);
          if (_flags2_6)
            w.int(v.personalChannelMessage);
          if (_stargiftsCount)
            w.int(v.stargiftsCount);
        },
        "contact": function(w, v) {
          w.uint(341499403);
          w.int53(h(v, "userId"));
          w.boolean(h(v, "mutual"));
        },
        "importedContact": function(w, v) {
          w.uint(3242081360);
          w.int53(h(v, "userId"));
          w.long(h(v, "clientId"));
        },
        "contactStatus": function(w, v) {
          w.uint(383348795);
          w.int53(h(v, "userId"));
          w.object(h(v, "status"));
        },
        "contacts.contactsNotModified": function(w) {
          w.uint(3075189202);
        },
        "contacts.contacts": function(w, v) {
          w.uint(3941105218);
          w.vector(w.object, h(v, "contacts"));
          w.int(h(v, "savedCount"));
          w.vector(w.object, h(v, "users"));
        },
        "contacts.importedContacts": function(w, v) {
          w.uint(2010127419);
          w.vector(w.object, h(v, "imported"));
          w.vector(w.object, h(v, "popularInvites"));
          w.vector(w.long, h(v, "retryContacts"));
          w.vector(w.object, h(v, "users"));
        },
        "contacts.blocked": function(w, v) {
          w.uint(182326673);
          w.vector(w.object, h(v, "blocked"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "contacts.blockedSlice": function(w, v) {
          w.uint(3781575060);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "blocked"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.dialogs": function(w, v) {
          w.uint(364538944);
          w.vector(w.object, h(v, "dialogs"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.dialogsSlice": function(w, v) {
          w.uint(1910543603);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "dialogs"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.dialogsNotModified": function(w, v) {
          w.uint(4041467286);
          w.int(h(v, "count"));
        },
        "messages.messages": function(w, v) {
          w.uint(2356252295);
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.messagesSlice": function(w, v) {
          w.uint(978610270);
          var flags = 0;
          var _nextRate = v.nextRate !== void 0;
          if (_nextRate)
            flags |= 1;
          if (v.inexact === true)
            flags |= 2;
          var _offsetIdOffset = v.offsetIdOffset !== void 0;
          if (_offsetIdOffset)
            flags |= 4;
          w.uint(flags);
          w.int(h(v, "count"));
          if (_nextRate)
            w.int(v.nextRate);
          if (_offsetIdOffset)
            w.int(v.offsetIdOffset);
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.channelMessages": function(w, v) {
          w.uint(3346446926);
          var flags = 0;
          if (v.inexact === true)
            flags |= 2;
          var _offsetIdOffset = v.offsetIdOffset !== void 0;
          if (_offsetIdOffset)
            flags |= 4;
          w.uint(flags);
          w.int(h(v, "pts"));
          w.int(h(v, "count"));
          if (_offsetIdOffset)
            w.int(v.offsetIdOffset);
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "topics"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.messagesNotModified": function(w, v) {
          w.uint(1951620897);
          w.int(h(v, "count"));
        },
        "messages.chats": function(w, v) {
          w.uint(1694474197);
          w.vector(w.object, h(v, "chats"));
        },
        "messages.chatsSlice": function(w, v) {
          w.uint(2631405892);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "chats"));
        },
        "messages.chatFull": function(w, v) {
          w.uint(3856126364);
          w.object(h(v, "fullChat"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.affectedHistory": function(w, v) {
          w.uint(3025955281);
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
          w.int(h(v, "offset"));
        },
        "inputMessagesFilterEmpty": function(w) {
          w.uint(1474492012);
        },
        "inputMessagesFilterPhotos": function(w) {
          w.uint(2517214492);
        },
        "inputMessagesFilterVideo": function(w) {
          w.uint(2680163941);
        },
        "inputMessagesFilterPhotoVideo": function(w) {
          w.uint(1458172132);
        },
        "inputMessagesFilterDocument": function(w) {
          w.uint(2665345416);
        },
        "inputMessagesFilterUrl": function(w) {
          w.uint(2129714567);
        },
        "inputMessagesFilterGif": function(w) {
          w.uint(4291323271);
        },
        "inputMessagesFilterVoice": function(w) {
          w.uint(1358283666);
        },
        "inputMessagesFilterMusic": function(w) {
          w.uint(928101534);
        },
        "inputMessagesFilterChatPhotos": function(w) {
          w.uint(975236280);
        },
        "inputMessagesFilterPhoneCalls": function(w, v) {
          w.uint(2160695144);
          var flags = 0;
          if (v.missed === true)
            flags |= 1;
          w.uint(flags);
        },
        "inputMessagesFilterRoundVoice": function(w) {
          w.uint(2054952868);
        },
        "inputMessagesFilterRoundVideo": function(w) {
          w.uint(3041516115);
        },
        "inputMessagesFilterMyMentions": function(w) {
          w.uint(3254314650);
        },
        "inputMessagesFilterGeo": function(w) {
          w.uint(3875695885);
        },
        "inputMessagesFilterContacts": function(w) {
          w.uint(3764575107);
        },
        "inputMessagesFilterPinned": function(w) {
          w.uint(464520273);
        },
        "updateNewMessage": function(w, v) {
          w.uint(522914557);
          w.object(h(v, "message"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateMessageID": function(w, v) {
          w.uint(1318109142);
          w.int(h(v, "id"));
          w.long(h(v, "randomId"));
        },
        "updateDeleteMessages": function(w, v) {
          w.uint(2718806245);
          w.vector(w.int, h(v, "messages"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateUserTyping": function(w, v) {
          w.uint(3223225727);
          w.int53(h(v, "userId"));
          w.object(h(v, "action"));
        },
        "updateChatUserTyping": function(w, v) {
          w.uint(2202565360);
          w.int53(h(v, "chatId"));
          w.object(h(v, "fromId"));
          w.object(h(v, "action"));
        },
        "updateChatParticipants": function(w, v) {
          w.uint(125178264);
          w.object(h(v, "participants"));
        },
        "updateUserStatus": function(w, v) {
          w.uint(3854432478);
          w.int53(h(v, "userId"));
          w.object(h(v, "status"));
        },
        "updateUserName": function(w, v) {
          w.uint(2810480932);
          w.int53(h(v, "userId"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
          w.vector(w.object, h(v, "usernames"));
        },
        "updateNewAuthorization": function(w, v) {
          w.uint(2303831023);
          var flags = 0;
          var _date = v.date !== void 0;
          var _device = v.device !== void 0;
          var _location = v.location !== void 0;
          var _flags_0 = v.unconfirmed === true || _date || _device || _location;
          if (_flags_0)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "hash"));
          if (_flags_0)
            w.int(v.date);
          if (_flags_0)
            w.string(v.device);
          if (_flags_0)
            w.string(v.location);
        },
        "updateNewEncryptedMessage": function(w, v) {
          w.uint(314359194);
          w.object(h(v, "message"));
          w.int(h(v, "qts"));
        },
        "updateEncryptedChatTyping": function(w, v) {
          w.uint(386986326);
          w.int(h(v, "chatId"));
        },
        "updateEncryption": function(w, v) {
          w.uint(3030575245);
          w.object(h(v, "chat"));
          w.int(h(v, "date"));
        },
        "updateEncryptedMessagesRead": function(w, v) {
          w.uint(956179895);
          w.int(h(v, "chatId"));
          w.int(h(v, "maxDate"));
          w.int(h(v, "date"));
        },
        "updateChatParticipantAdd": function(w, v) {
          w.uint(1037718609);
          w.int53(h(v, "chatId"));
          w.int53(h(v, "userId"));
          w.int53(h(v, "inviterId"));
          w.int(h(v, "date"));
          w.int(h(v, "version"));
        },
        "updateChatParticipantDelete": function(w, v) {
          w.uint(3811523959);
          w.int53(h(v, "chatId"));
          w.int53(h(v, "userId"));
          w.int(h(v, "version"));
        },
        "updateDcOptions": function(w, v) {
          w.uint(2388564083);
          w.vector(w.object, h(v, "dcOptions"));
        },
        "updateNotifySettings": function(w, v) {
          w.uint(3200411887);
          w.object(h(v, "peer"));
          w.object(h(v, "notifySettings"));
        },
        "updateServiceNotification": function(w, v) {
          w.uint(3957614617);
          var flags = 0;
          if (v.popup === true)
            flags |= 1;
          var _inboxDate = v.inboxDate !== void 0;
          if (_inboxDate)
            flags |= 2;
          if (v.invertMedia === true)
            flags |= 4;
          w.uint(flags);
          if (_inboxDate)
            w.int(v.inboxDate);
          w.string(h(v, "type"));
          w.string(h(v, "message"));
          w.object(h(v, "media"));
          w.vector(w.object, h(v, "entities"));
        },
        "updatePrivacy": function(w, v) {
          w.uint(3996854058);
          w.object(h(v, "key"));
          w.vector(w.object, h(v, "rules"));
        },
        "updateUserPhone": function(w, v) {
          w.uint(88680979);
          w.int53(h(v, "userId"));
          w.string(h(v, "phone"));
        },
        "updateReadHistoryInbox": function(w, v) {
          w.uint(2627162079);
          var flags = 0;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 1;
          w.uint(flags);
          if (_folderId)
            w.int(v.folderId);
          w.object(h(v, "peer"));
          w.int(h(v, "maxId"));
          w.int(h(v, "stillUnreadCount"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateReadHistoryOutbox": function(w, v) {
          w.uint(791617983);
          w.object(h(v, "peer"));
          w.int(h(v, "maxId"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateWebPage": function(w, v) {
          w.uint(2139689491);
          w.object(h(v, "webpage"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateReadMessagesContents": function(w, v) {
          w.uint(4163006849);
          var flags = 0;
          var _date = v.date !== void 0;
          if (_date)
            flags |= 1;
          w.uint(flags);
          w.vector(w.int, h(v, "messages"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
          if (_date)
            w.int(v.date);
        },
        "updateChannelTooLong": function(w, v) {
          w.uint(277713951);
          var flags = 0;
          var _pts = v.pts !== void 0;
          if (_pts)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          if (_pts)
            w.int(v.pts);
        },
        "updateChannel": function(w, v) {
          w.uint(1666927625);
          w.int53(h(v, "channelId"));
        },
        "updateNewChannelMessage": function(w, v) {
          w.uint(1656358105);
          w.object(h(v, "message"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateReadChannelInbox": function(w, v) {
          w.uint(2452516368);
          var flags = 0;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 1;
          w.uint(flags);
          if (_folderId)
            w.int(v.folderId);
          w.int53(h(v, "channelId"));
          w.int(h(v, "maxId"));
          w.int(h(v, "stillUnreadCount"));
          w.int(h(v, "pts"));
        },
        "updateDeleteChannelMessages": function(w, v) {
          w.uint(3274529554);
          w.int53(h(v, "channelId"));
          w.vector(w.int, h(v, "messages"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateChannelMessageViews": function(w, v) {
          w.uint(4062620680);
          w.int53(h(v, "channelId"));
          w.int(h(v, "id"));
          w.int(h(v, "views"));
        },
        "updateChatParticipantAdmin": function(w, v) {
          w.uint(3620364706);
          w.int53(h(v, "chatId"));
          w.int53(h(v, "userId"));
          w.boolean(h(v, "isAdmin"));
          w.int(h(v, "version"));
        },
        "updateNewStickerSet": function(w, v) {
          w.uint(1753886890);
          w.object(h(v, "stickerset"));
        },
        "updateStickerSetsOrder": function(w, v) {
          w.uint(196268545);
          var flags = 0;
          if (v.masks === true)
            flags |= 1;
          if (v.emojis === true)
            flags |= 2;
          w.uint(flags);
          w.vector(w.long, h(v, "order"));
        },
        "updateStickerSets": function(w, v) {
          w.uint(834816008);
          var flags = 0;
          if (v.masks === true)
            flags |= 1;
          if (v.emojis === true)
            flags |= 2;
          w.uint(flags);
        },
        "updateSavedGifs": function(w) {
          w.uint(2473931806);
        },
        "updateBotInlineQuery": function(w, v) {
          w.uint(1232025500);
          var flags = 0;
          var _geo = v.geo !== void 0;
          if (_geo)
            flags |= 1;
          var _peerType = v.peerType !== void 0;
          if (_peerType)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "queryId"));
          w.int53(h(v, "userId"));
          w.string(h(v, "query"));
          if (_geo)
            w.object(v.geo);
          if (_peerType)
            w.object(v.peerType);
          w.string(h(v, "offset"));
        },
        "updateBotInlineSend": function(w, v) {
          w.uint(317794823);
          var flags = 0;
          var _geo = v.geo !== void 0;
          if (_geo)
            flags |= 1;
          var _msgId = v.msgId !== void 0;
          if (_msgId)
            flags |= 2;
          w.uint(flags);
          w.int53(h(v, "userId"));
          w.string(h(v, "query"));
          if (_geo)
            w.object(v.geo);
          w.string(h(v, "id"));
          if (_msgId)
            w.object(v.msgId);
        },
        "updateEditChannelMessage": function(w, v) {
          w.uint(457133559);
          w.object(h(v, "message"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateBotCallbackQuery": function(w, v) {
          w.uint(3117401229);
          var flags = 0;
          var _data = v.data !== void 0;
          if (_data)
            flags |= 1;
          var _gameShortName = v.gameShortName !== void 0;
          if (_gameShortName)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "queryId"));
          w.int53(h(v, "userId"));
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.long(h(v, "chatInstance"));
          if (_data)
            w.bytes(v.data);
          if (_gameShortName)
            w.string(v.gameShortName);
        },
        "updateEditMessage": function(w, v) {
          w.uint(3825430691);
          w.object(h(v, "message"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateInlineBotCallbackQuery": function(w, v) {
          w.uint(1763610706);
          var flags = 0;
          var _data = v.data !== void 0;
          if (_data)
            flags |= 1;
          var _gameShortName = v.gameShortName !== void 0;
          if (_gameShortName)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "queryId"));
          w.int53(h(v, "userId"));
          w.object(h(v, "msgId"));
          w.long(h(v, "chatInstance"));
          if (_data)
            w.bytes(v.data);
          if (_gameShortName)
            w.string(v.gameShortName);
        },
        "updateReadChannelOutbox": function(w, v) {
          w.uint(3076495785);
          w.int53(h(v, "channelId"));
          w.int(h(v, "maxId"));
        },
        "updateDraftMessage": function(w, v) {
          w.uint(457829485);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_topMsgId)
            w.int(v.topMsgId);
          w.object(h(v, "draft"));
        },
        "updateReadFeaturedStickers": function(w) {
          w.uint(1461528386);
        },
        "updateRecentStickers": function(w) {
          w.uint(2588027936);
        },
        "updateConfig": function(w) {
          w.uint(2720652550);
        },
        "updatePtsChanged": function(w) {
          w.uint(861169551);
        },
        "updateChannelWebPage": function(w, v) {
          w.uint(791390623);
          w.int53(h(v, "channelId"));
          w.object(h(v, "webpage"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateDialogPinned": function(w, v) {
          w.uint(1852826908);
          var flags = 0;
          if (v.pinned === true)
            flags |= 1;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 2;
          w.uint(flags);
          if (_folderId)
            w.int(v.folderId);
          w.object(h(v, "peer"));
        },
        "updatePinnedDialogs": function(w, v) {
          w.uint(4195302562);
          var flags = 0;
          var _order = v.order && v.order.length;
          if (_order)
            flags |= 1;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 2;
          w.uint(flags);
          if (_folderId)
            w.int(v.folderId);
          if (_order)
            w.vector(w.object, v.order);
        },
        "updateBotWebhookJSON": function(w, v) {
          w.uint(2199371971);
          w.object(h(v, "data"));
        },
        "updateBotWebhookJSONQuery": function(w, v) {
          w.uint(2610053286);
          w.long(h(v, "queryId"));
          w.object(h(v, "data"));
          w.int(h(v, "timeout"));
        },
        "updateBotShippingQuery": function(w, v) {
          w.uint(3048144253);
          w.long(h(v, "queryId"));
          w.int53(h(v, "userId"));
          w.bytes(h(v, "payload"));
          w.object(h(v, "shippingAddress"));
        },
        "updateBotPrecheckoutQuery": function(w, v) {
          w.uint(2359990934);
          var flags = 0;
          var _info = v.info !== void 0;
          if (_info)
            flags |= 1;
          var _shippingOptionId = v.shippingOptionId !== void 0;
          if (_shippingOptionId)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "queryId"));
          w.int53(h(v, "userId"));
          w.bytes(h(v, "payload"));
          if (_info)
            w.object(v.info);
          if (_shippingOptionId)
            w.string(v.shippingOptionId);
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
        },
        "updatePhoneCall": function(w, v) {
          w.uint(2869914398);
          w.object(h(v, "phoneCall"));
        },
        "updateLangPackTooLong": function(w, v) {
          w.uint(1180041828);
          w.string(h(v, "langCode"));
        },
        "updateLangPack": function(w, v) {
          w.uint(1442983757);
          w.object(h(v, "difference"));
        },
        "updateFavedStickers": function(w) {
          w.uint(3843135853);
        },
        "updateChannelReadMessagesContents": function(w, v) {
          w.uint(3928556893);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          if (_topMsgId)
            w.int(v.topMsgId);
          w.vector(w.int, h(v, "messages"));
        },
        "updateContactsReset": function(w) {
          w.uint(1887741886);
        },
        "updateChannelAvailableMessages": function(w, v) {
          w.uint(2990524056);
          w.int53(h(v, "channelId"));
          w.int(h(v, "availableMinId"));
        },
        "updateDialogUnreadMark": function(w, v) {
          w.uint(3781450179);
          var flags = 0;
          if (v.unread === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "updateMessagePoll": function(w, v) {
          w.uint(2896258427);
          var flags = 0;
          var _poll = v.poll !== void 0;
          if (_poll)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "pollId"));
          if (_poll)
            w.object(v.poll);
          w.object(h(v, "results"));
        },
        "updateChatDefaultBannedRights": function(w, v) {
          w.uint(1421875280);
          w.object(h(v, "peer"));
          w.object(h(v, "defaultBannedRights"));
          w.int(h(v, "version"));
        },
        "updateFolderPeers": function(w, v) {
          w.uint(422972864);
          w.vector(w.object, h(v, "folderPeers"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updatePeerSettings": function(w, v) {
          w.uint(1786671974);
          w.object(h(v, "peer"));
          w.object(h(v, "settings"));
        },
        "updatePeerLocated": function(w, v) {
          w.uint(3031420848);
          w.vector(w.object, h(v, "peers"));
        },
        "updateNewScheduledMessage": function(w, v) {
          w.uint(967122427);
          w.object(h(v, "message"));
        },
        "updateDeleteScheduledMessages": function(w, v) {
          w.uint(2424728814);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "messages"));
        },
        "updateTheme": function(w, v) {
          w.uint(2182544291);
          w.object(h(v, "theme"));
        },
        "updateGeoLiveViewed": function(w, v) {
          w.uint(2267003193);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "updateLoginToken": function(w) {
          w.uint(1448076945);
        },
        "updateMessagePollVote": function(w, v) {
          w.uint(619974263);
          w.long(h(v, "pollId"));
          w.object(h(v, "peer"));
          w.vector(w.bytes, h(v, "options"));
          w.int(h(v, "qts"));
        },
        "updateDialogFilter": function(w, v) {
          w.uint(654302845);
          var flags = 0;
          var _filter = v.filter !== void 0;
          if (_filter)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "id"));
          if (_filter)
            w.object(v.filter);
        },
        "updateDialogFilterOrder": function(w, v) {
          w.uint(2782339333);
          w.vector(w.int, h(v, "order"));
        },
        "updateDialogFilters": function(w) {
          w.uint(889491791);
        },
        "updatePhoneCallSignalingData": function(w, v) {
          w.uint(643940105);
          w.long(h(v, "phoneCallId"));
          w.bytes(h(v, "data"));
        },
        "updateChannelMessageForwards": function(w, v) {
          w.uint(3533318132);
          w.int53(h(v, "channelId"));
          w.int(h(v, "id"));
          w.int(h(v, "forwards"));
        },
        "updateReadChannelDiscussionInbox": function(w, v) {
          w.uint(3601962310);
          var flags = 0;
          var _broadcastId = v.broadcastId !== void 0;
          var _broadcastPost = v.broadcastPost !== void 0;
          var _flags_0 = _broadcastId || _broadcastPost;
          if (_flags_0)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          w.int(h(v, "topMsgId"));
          w.int(h(v, "readMaxId"));
          if (_flags_0)
            w.int53(v.broadcastId);
          if (_flags_0)
            w.int(v.broadcastPost);
        },
        "updateReadChannelDiscussionOutbox": function(w, v) {
          w.uint(1767677564);
          w.int53(h(v, "channelId"));
          w.int(h(v, "topMsgId"));
          w.int(h(v, "readMaxId"));
        },
        "updatePeerBlocked": function(w, v) {
          w.uint(3957356370);
          var flags = 0;
          if (v.blocked === true)
            flags |= 1;
          if (v.blockedMyStoriesFrom === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peerId"));
        },
        "updateChannelUserTyping": function(w, v) {
          w.uint(2357774627);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          if (_topMsgId)
            w.int(v.topMsgId);
          w.object(h(v, "fromId"));
          w.object(h(v, "action"));
        },
        "updatePinnedMessages": function(w, v) {
          w.uint(3984976565);
          var flags = 0;
          if (v.pinned === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "messages"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updatePinnedChannelMessages": function(w, v) {
          w.uint(1538885128);
          var flags = 0;
          if (v.pinned === true)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          w.vector(w.int, h(v, "messages"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "updateChat": function(w, v) {
          w.uint(4170869326);
          w.int53(h(v, "chatId"));
        },
        "updateGroupCallParticipants": function(w, v) {
          w.uint(4075543374);
          w.object(h(v, "call"));
          w.vector(w.object, h(v, "participants"));
          w.int(h(v, "version"));
        },
        "updateGroupCall": function(w, v) {
          w.uint(347227392);
          w.int53(h(v, "chatId"));
          w.object(h(v, "call"));
        },
        "updatePeerHistoryTTL": function(w, v) {
          w.uint(3147544997);
          var flags = 0;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "updateChatParticipant": function(w, v) {
          w.uint(3498534458);
          var flags = 0;
          var _prevParticipant = v.prevParticipant !== void 0;
          if (_prevParticipant)
            flags |= 1;
          var _newParticipant = v.newParticipant !== void 0;
          if (_newParticipant)
            flags |= 2;
          var _invite = v.invite !== void 0;
          if (_invite)
            flags |= 4;
          w.uint(flags);
          w.int53(h(v, "chatId"));
          w.int(h(v, "date"));
          w.int53(h(v, "actorId"));
          w.int53(h(v, "userId"));
          if (_prevParticipant)
            w.object(v.prevParticipant);
          if (_newParticipant)
            w.object(v.newParticipant);
          if (_invite)
            w.object(v.invite);
          w.int(h(v, "qts"));
        },
        "updateChannelParticipant": function(w, v) {
          w.uint(2556246715);
          var flags = 0;
          var _prevParticipant = v.prevParticipant !== void 0;
          if (_prevParticipant)
            flags |= 1;
          var _newParticipant = v.newParticipant !== void 0;
          if (_newParticipant)
            flags |= 2;
          var _invite = v.invite !== void 0;
          if (_invite)
            flags |= 4;
          if (v.viaChatlist === true)
            flags |= 8;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          w.int(h(v, "date"));
          w.int53(h(v, "actorId"));
          w.int53(h(v, "userId"));
          if (_prevParticipant)
            w.object(v.prevParticipant);
          if (_newParticipant)
            w.object(v.newParticipant);
          if (_invite)
            w.object(v.invite);
          w.int(h(v, "qts"));
        },
        "updateBotStopped": function(w, v) {
          w.uint(3297184329);
          w.int53(h(v, "userId"));
          w.int(h(v, "date"));
          w.boolean(h(v, "stopped"));
          w.int(h(v, "qts"));
        },
        "updateGroupCallConnection": function(w, v) {
          w.uint(192428418);
          var flags = 0;
          if (v.presentation === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "params"));
        },
        "updateBotCommands": function(w, v) {
          w.uint(1299263278);
          w.object(h(v, "peer"));
          w.int53(h(v, "botId"));
          w.vector(w.object, h(v, "commands"));
        },
        "updatePendingJoinRequests": function(w, v) {
          w.uint(1885586395);
          w.object(h(v, "peer"));
          w.int(h(v, "requestsPending"));
          w.vector(w.int53, h(v, "recentRequesters"));
        },
        "updateBotChatInviteRequester": function(w, v) {
          w.uint(299870598);
          w.object(h(v, "peer"));
          w.int(h(v, "date"));
          w.int53(h(v, "userId"));
          w.string(h(v, "about"));
          w.object(h(v, "invite"));
          w.int(h(v, "qts"));
        },
        "updateMessageReactions": function(w, v) {
          w.uint(1578843320);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          if (_topMsgId)
            w.int(v.topMsgId);
          w.object(h(v, "reactions"));
        },
        "updateAttachMenuBots": function(w) {
          w.uint(397910539);
        },
        "updateWebViewResultSent": function(w, v) {
          w.uint(361936797);
          w.long(h(v, "queryId"));
        },
        "updateBotMenuButton": function(w, v) {
          w.uint(347625491);
          w.int53(h(v, "botId"));
          w.object(h(v, "button"));
        },
        "updateSavedRingtones": function(w) {
          w.uint(1960361625);
        },
        "updateTranscribedAudio": function(w, v) {
          w.uint(8703322);
          var flags = 0;
          if (v.pending === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.long(h(v, "transcriptionId"));
          w.string(h(v, "text"));
        },
        "updateReadFeaturedEmojiStickers": function(w) {
          w.uint(4216080748);
        },
        "updateUserEmojiStatus": function(w, v) {
          w.uint(674706841);
          w.int53(h(v, "userId"));
          w.object(h(v, "emojiStatus"));
        },
        "updateRecentEmojiStatuses": function(w) {
          w.uint(821314523);
        },
        "updateRecentReactions": function(w) {
          w.uint(1870160884);
        },
        "updateMoveStickerSetToTop": function(w, v) {
          w.uint(2264715141);
          var flags = 0;
          if (v.masks === true)
            flags |= 1;
          if (v.emojis === true)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "stickerset"));
        },
        "updateMessageExtendedMedia": function(w, v) {
          w.uint(3584300836);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.vector(w.object, h(v, "extendedMedia"));
        },
        "updateChannelPinnedTopic": function(w, v) {
          w.uint(422509539);
          var flags = 0;
          if (v.pinned === true)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          w.int(h(v, "topicId"));
        },
        "updateChannelPinnedTopics": function(w, v) {
          w.uint(4263085570);
          var flags = 0;
          var _order = v.order && v.order.length;
          if (_order)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          if (_order)
            w.vector(w.int, v.order);
        },
        "updateUser": function(w, v) {
          w.uint(542282808);
          w.int53(h(v, "userId"));
        },
        "updateAutoSaveSettings": function(w) {
          w.uint(3959795863);
        },
        "updateStory": function(w, v) {
          w.uint(1974712216);
          w.object(h(v, "peer"));
          w.object(h(v, "story"));
        },
        "updateReadStories": function(w, v) {
          w.uint(4149121835);
          w.object(h(v, "peer"));
          w.int(h(v, "maxId"));
        },
        "updateStoryID": function(w, v) {
          w.uint(468923833);
          w.int(h(v, "id"));
          w.long(h(v, "randomId"));
        },
        "updateStoriesStealthMode": function(w, v) {
          w.uint(738741697);
          w.object(h(v, "stealthMode"));
        },
        "updateSentStoryReaction": function(w, v) {
          w.uint(2103604867);
          w.object(h(v, "peer"));
          w.int(h(v, "storyId"));
          w.object(h(v, "reaction"));
        },
        "updateBotChatBoost": function(w, v) {
          w.uint(2421019804);
          w.object(h(v, "peer"));
          w.object(h(v, "boost"));
          w.int(h(v, "qts"));
        },
        "updateChannelViewForumAsMessages": function(w, v) {
          w.uint(129403168);
          w.int53(h(v, "channelId"));
          w.boolean(h(v, "enabled"));
        },
        "updatePeerWallpaper": function(w, v) {
          w.uint(2923368477);
          var flags = 0;
          var _wallpaper = v.wallpaper !== void 0;
          if (_wallpaper)
            flags |= 1;
          if (v.wallpaperOverridden === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_wallpaper)
            w.object(v.wallpaper);
        },
        "updateBotMessageReaction": function(w, v) {
          w.uint(2887898062);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int(h(v, "date"));
          w.object(h(v, "actor"));
          w.vector(w.object, h(v, "oldReactions"));
          w.vector(w.object, h(v, "newReactions"));
          w.int(h(v, "qts"));
        },
        "updateBotMessageReactions": function(w, v) {
          w.uint(164329305);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int(h(v, "date"));
          w.vector(w.object, h(v, "reactions"));
          w.int(h(v, "qts"));
        },
        "updateSavedDialogPinned": function(w, v) {
          w.uint(2930744948);
          var flags = 0;
          if (v.pinned === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "updatePinnedSavedDialogs": function(w, v) {
          w.uint(1751942566);
          var flags = 0;
          var _order = v.order && v.order.length;
          if (_order)
            flags |= 1;
          w.uint(flags);
          if (_order)
            w.vector(w.object, v.order);
        },
        "updateSavedReactionTags": function(w) {
          w.uint(969307186);
        },
        "updateSmsJob": function(w, v) {
          w.uint(4049758676);
          w.string(h(v, "jobId"));
        },
        "updateQuickReplies": function(w, v) {
          w.uint(4182182578);
          w.vector(w.object, h(v, "quickReplies"));
        },
        "updateNewQuickReply": function(w, v) {
          w.uint(4114458391);
          w.object(h(v, "quickReply"));
        },
        "updateDeleteQuickReply": function(w, v) {
          w.uint(1407644140);
          w.int(h(v, "shortcutId"));
        },
        "updateQuickReplyMessage": function(w, v) {
          w.uint(1040518415);
          w.object(h(v, "message"));
        },
        "updateDeleteQuickReplyMessages": function(w, v) {
          w.uint(1450174413);
          w.int(h(v, "shortcutId"));
          w.vector(w.int, h(v, "messages"));
        },
        "updateBotBusinessConnect": function(w, v) {
          w.uint(2330315130);
          w.object(h(v, "connection"));
          w.int(h(v, "qts"));
        },
        "updateBotNewBusinessMessage": function(w, v) {
          w.uint(2648388732);
          var flags = 0;
          var _replyToMessage = v.replyToMessage !== void 0;
          if (_replyToMessage)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "connectionId"));
          w.object(h(v, "message"));
          if (_replyToMessage)
            w.object(v.replyToMessage);
          w.int(h(v, "qts"));
        },
        "updateBotEditBusinessMessage": function(w, v) {
          w.uint(132077692);
          var flags = 0;
          var _replyToMessage = v.replyToMessage !== void 0;
          if (_replyToMessage)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "connectionId"));
          w.object(h(v, "message"));
          if (_replyToMessage)
            w.object(v.replyToMessage);
          w.int(h(v, "qts"));
        },
        "updateBotDeleteBusinessMessage": function(w, v) {
          w.uint(2687146030);
          w.string(h(v, "connectionId"));
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "messages"));
          w.int(h(v, "qts"));
        },
        "updateNewStoryReaction": function(w, v) {
          w.uint(405070859);
          w.int(h(v, "storyId"));
          w.object(h(v, "peer"));
          w.object(h(v, "reaction"));
        },
        "updateBroadcastRevenueTransactions": function(w, v) {
          w.uint(3755565557);
          w.object(h(v, "peer"));
          w.object(h(v, "balances"));
        },
        "updateStarsBalance": function(w, v) {
          w.uint(263737752);
          w.long(h(v, "balance"));
        },
        "updateBusinessBotCallbackQuery": function(w, v) {
          w.uint(513998247);
          var flags = 0;
          var _data = v.data !== void 0;
          if (_data)
            flags |= 1;
          var _replyToMessage = v.replyToMessage !== void 0;
          if (_replyToMessage)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "queryId"));
          w.int53(h(v, "userId"));
          w.string(h(v, "connectionId"));
          w.object(h(v, "message"));
          if (_replyToMessage)
            w.object(v.replyToMessage);
          w.long(h(v, "chatInstance"));
          if (_data)
            w.bytes(v.data);
        },
        "updateStarsRevenueStatus": function(w, v) {
          w.uint(2776936473);
          w.object(h(v, "peer"));
          w.object(h(v, "status"));
        },
        "updateBotPurchasedPaidMedia": function(w, v) {
          w.uint(675009298);
          w.int53(h(v, "userId"));
          w.string(h(v, "payload"));
          w.int(h(v, "qts"));
        },
        "updatePaidReactionPrivacy": function(w, v) {
          w.uint(1372224236);
          w.boolean(h(v, "private"));
        },
        "updates.state": function(w, v) {
          w.uint(2775329342);
          w.int(h(v, "pts"));
          w.int(h(v, "qts"));
          w.int(h(v, "date"));
          w.int(h(v, "seq"));
          w.int(h(v, "unreadCount"));
        },
        "updates.differenceEmpty": function(w, v) {
          w.uint(1567990072);
          w.int(h(v, "date"));
          w.int(h(v, "seq"));
        },
        "updates.difference": function(w, v) {
          w.uint(16030880);
          w.vector(w.object, h(v, "newMessages"));
          w.vector(w.object, h(v, "newEncryptedMessages"));
          w.vector(w.object, h(v, "otherUpdates"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          w.object(h(v, "state"));
        },
        "updates.differenceSlice": function(w, v) {
          w.uint(2835028353);
          w.vector(w.object, h(v, "newMessages"));
          w.vector(w.object, h(v, "newEncryptedMessages"));
          w.vector(w.object, h(v, "otherUpdates"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          w.object(h(v, "intermediateState"));
        },
        "updates.differenceTooLong": function(w, v) {
          w.uint(1258196845);
          w.int(h(v, "pts"));
        },
        "updatesTooLong": function(w) {
          w.uint(3809980286);
        },
        "updateShortMessage": function(w, v) {
          w.uint(826001400);
          var flags = 0;
          if (v.out === true)
            flags |= 2;
          var _fwdFrom = v.fwdFrom !== void 0;
          if (_fwdFrom)
            flags |= 4;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 8;
          if (v.mentioned === true)
            flags |= 16;
          if (v.mediaUnread === true)
            flags |= 32;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 128;
          var _viaBotId = v.viaBotId !== void 0;
          if (_viaBotId)
            flags |= 2048;
          if (v.silent === true)
            flags |= 8192;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 33554432;
          w.uint(flags);
          w.int(h(v, "id"));
          w.int53(h(v, "userId"));
          w.string(h(v, "message"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
          w.int(h(v, "date"));
          if (_fwdFrom)
            w.object(v.fwdFrom);
          if (_viaBotId)
            w.int53(v.viaBotId);
          if (_replyTo)
            w.object(v.replyTo);
          if (_entities)
            w.vector(w.object, v.entities);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "updateShortChatMessage": function(w, v) {
          w.uint(1299050149);
          var flags = 0;
          if (v.out === true)
            flags |= 2;
          var _fwdFrom = v.fwdFrom !== void 0;
          if (_fwdFrom)
            flags |= 4;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 8;
          if (v.mentioned === true)
            flags |= 16;
          if (v.mediaUnread === true)
            flags |= 32;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 128;
          var _viaBotId = v.viaBotId !== void 0;
          if (_viaBotId)
            flags |= 2048;
          if (v.silent === true)
            flags |= 8192;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 33554432;
          w.uint(flags);
          w.int(h(v, "id"));
          w.int53(h(v, "fromId"));
          w.int53(h(v, "chatId"));
          w.string(h(v, "message"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
          w.int(h(v, "date"));
          if (_fwdFrom)
            w.object(v.fwdFrom);
          if (_viaBotId)
            w.int53(v.viaBotId);
          if (_replyTo)
            w.object(v.replyTo);
          if (_entities)
            w.vector(w.object, v.entities);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "updateShort": function(w, v) {
          w.uint(2027216577);
          w.object(h(v, "update"));
          w.int(h(v, "date"));
        },
        "updatesCombined": function(w, v) {
          w.uint(1918567619);
          w.vector(w.object, h(v, "updates"));
          w.vector(w.object, h(v, "users"));
          w.vector(w.object, h(v, "chats"));
          w.int(h(v, "date"));
          w.int(h(v, "seqStart"));
          w.int(h(v, "seq"));
        },
        "updates": function(w, v) {
          w.uint(1957577280);
          w.vector(w.object, h(v, "updates"));
          w.vector(w.object, h(v, "users"));
          w.vector(w.object, h(v, "chats"));
          w.int(h(v, "date"));
          w.int(h(v, "seq"));
        },
        "updateShortSentMessage": function(w, v) {
          w.uint(2417352961);
          var flags = 0;
          if (v.out === true)
            flags |= 2;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 128;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 512;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 33554432;
          w.uint(flags);
          w.int(h(v, "id"));
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
          w.int(h(v, "date"));
          if (_media)
            w.object(v.media);
          if (_entities)
            w.vector(w.object, v.entities);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "photos.photos": function(w, v) {
          w.uint(2378853029);
          w.vector(w.object, h(v, "photos"));
          w.vector(w.object, h(v, "users"));
        },
        "photos.photosSlice": function(w, v) {
          w.uint(352657236);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "photos"));
          w.vector(w.object, h(v, "users"));
        },
        "photos.photo": function(w, v) {
          w.uint(539045032);
          w.object(h(v, "photo"));
          w.vector(w.object, h(v, "users"));
        },
        "upload.file": function(w, v) {
          w.uint(157948117);
          w.object(h(v, "type"));
          w.int(h(v, "mtime"));
          w.bytes(h(v, "bytes"));
        },
        "upload.fileCdnRedirect": function(w, v) {
          w.uint(4052539972);
          w.int(h(v, "dcId"));
          w.bytes(h(v, "fileToken"));
          w.bytes(h(v, "encryptionKey"));
          w.bytes(h(v, "encryptionIv"));
          w.vector(w.object, h(v, "fileHashes"));
        },
        "dcOption": function(w, v) {
          w.uint(414687501);
          var flags = 0;
          if (v.ipv6 === true)
            flags |= 1;
          if (v.mediaOnly === true)
            flags |= 2;
          if (v.tcpoOnly === true)
            flags |= 4;
          if (v.cdn === true)
            flags |= 8;
          if (v.static === true)
            flags |= 16;
          if (v.thisPortOnly === true)
            flags |= 32;
          var _secret = v.secret !== void 0;
          if (_secret)
            flags |= 1024;
          w.uint(flags);
          w.int(h(v, "id"));
          w.string(h(v, "ipAddress"));
          w.int(h(v, "port"));
          if (_secret)
            w.bytes(v.secret);
        },
        "config": function(w, v) {
          w.uint(3424265246);
          var flags = 0;
          var _tmpSessions = v.tmpSessions !== void 0;
          if (_tmpSessions)
            flags |= 1;
          var _suggestedLangCode = v.suggestedLangCode !== void 0;
          var _langPackVersion = v.langPackVersion !== void 0;
          var _baseLangPackVersion = v.baseLangPackVersion !== void 0;
          var _flags_2 = _suggestedLangCode || _langPackVersion || _baseLangPackVersion;
          if (_flags_2)
            flags |= 4;
          if (v.defaultP2pContacts === true)
            flags |= 8;
          if (v.preloadFeaturedStickers === true)
            flags |= 16;
          if (v.revokePmInbox === true)
            flags |= 64;
          var _autoupdateUrlPrefix = v.autoupdateUrlPrefix !== void 0;
          if (_autoupdateUrlPrefix)
            flags |= 128;
          if (v.blockedMode === true)
            flags |= 256;
          var _gifSearchUsername = v.gifSearchUsername !== void 0;
          if (_gifSearchUsername)
            flags |= 512;
          var _venueSearchUsername = v.venueSearchUsername !== void 0;
          if (_venueSearchUsername)
            flags |= 1024;
          var _imgSearchUsername = v.imgSearchUsername !== void 0;
          if (_imgSearchUsername)
            flags |= 2048;
          var _staticMapsProvider = v.staticMapsProvider !== void 0;
          if (_staticMapsProvider)
            flags |= 4096;
          if (v.forceTryIpv6 === true)
            flags |= 16384;
          var _reactionsDefault = v.reactionsDefault !== void 0;
          if (_reactionsDefault)
            flags |= 32768;
          var _autologinToken = v.autologinToken !== void 0;
          if (_autologinToken)
            flags |= 65536;
          w.uint(flags);
          w.int(h(v, "date"));
          w.int(h(v, "expires"));
          w.boolean(h(v, "testMode"));
          w.int(h(v, "thisDc"));
          w.vector(w.object, h(v, "dcOptions"));
          w.string(h(v, "dcTxtDomainName"));
          w.int(h(v, "chatSizeMax"));
          w.int(h(v, "megagroupSizeMax"));
          w.int(h(v, "forwardedCountMax"));
          w.int(h(v, "onlineUpdatePeriodMs"));
          w.int(h(v, "offlineBlurTimeoutMs"));
          w.int(h(v, "offlineIdleTimeoutMs"));
          w.int(h(v, "onlineCloudTimeoutMs"));
          w.int(h(v, "notifyCloudDelayMs"));
          w.int(h(v, "notifyDefaultDelayMs"));
          w.int(h(v, "pushChatPeriodMs"));
          w.int(h(v, "pushChatLimit"));
          w.int(h(v, "editTimeLimit"));
          w.int(h(v, "revokeTimeLimit"));
          w.int(h(v, "revokePmTimeLimit"));
          w.int(h(v, "ratingEDecay"));
          w.int(h(v, "stickersRecentLimit"));
          w.int(h(v, "channelsReadMediaPeriod"));
          if (_tmpSessions)
            w.int(v.tmpSessions);
          w.int(h(v, "callReceiveTimeoutMs"));
          w.int(h(v, "callRingTimeoutMs"));
          w.int(h(v, "callConnectTimeoutMs"));
          w.int(h(v, "callPacketTimeoutMs"));
          w.string(h(v, "meUrlPrefix"));
          if (_autoupdateUrlPrefix)
            w.string(v.autoupdateUrlPrefix);
          if (_gifSearchUsername)
            w.string(v.gifSearchUsername);
          if (_venueSearchUsername)
            w.string(v.venueSearchUsername);
          if (_imgSearchUsername)
            w.string(v.imgSearchUsername);
          if (_staticMapsProvider)
            w.string(v.staticMapsProvider);
          w.int(h(v, "captionLengthMax"));
          w.int(h(v, "messageLengthMax"));
          w.int(h(v, "webfileDcId"));
          if (_flags_2)
            w.string(v.suggestedLangCode);
          if (_flags_2)
            w.int(v.langPackVersion);
          if (_flags_2)
            w.int(v.baseLangPackVersion);
          if (_reactionsDefault)
            w.object(v.reactionsDefault);
          if (_autologinToken)
            w.string(v.autologinToken);
        },
        "nearestDc": function(w, v) {
          w.uint(2384074613);
          w.string(h(v, "country"));
          w.int(h(v, "thisDc"));
          w.int(h(v, "nearestDc"));
        },
        "help.appUpdate": function(w, v) {
          w.uint(3434860080);
          var flags = 0;
          if (v.canNotSkip === true)
            flags |= 1;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 2;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 4;
          var _sticker = v.sticker !== void 0;
          if (_sticker)
            flags |= 8;
          w.uint(flags);
          w.int(h(v, "id"));
          w.string(h(v, "version"));
          w.string(h(v, "text"));
          w.vector(w.object, h(v, "entities"));
          if (_document)
            w.object(v.document);
          if (_url)
            w.string(v.url);
          if (_sticker)
            w.object(v.sticker);
        },
        "help.noAppUpdate": function(w) {
          w.uint(3294258486);
        },
        "help.inviteText": function(w, v) {
          w.uint(415997816);
          w.string(h(v, "message"));
        },
        "encryptedChatEmpty": function(w, v) {
          w.uint(2877210784);
          w.int(h(v, "id"));
        },
        "encryptedChatWaiting": function(w, v) {
          w.uint(1722964307);
          w.int(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "date"));
          w.int53(h(v, "adminId"));
          w.int53(h(v, "participantId"));
        },
        "encryptedChatRequested": function(w, v) {
          w.uint(1223809356);
          var flags = 0;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 1;
          w.uint(flags);
          if (_folderId)
            w.int(v.folderId);
          w.int(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "date"));
          w.int53(h(v, "adminId"));
          w.int53(h(v, "participantId"));
          w.bytes(h(v, "gA"));
        },
        "encryptedChat": function(w, v) {
          w.uint(1643173063);
          w.int(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "date"));
          w.int53(h(v, "adminId"));
          w.int53(h(v, "participantId"));
          w.bytes(h(v, "gAOrB"));
          w.long(h(v, "keyFingerprint"));
        },
        "encryptedChatDiscarded": function(w, v) {
          w.uint(505183301);
          var flags = 0;
          if (v.historyDeleted === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "id"));
        },
        "inputEncryptedChat": function(w, v) {
          w.uint(4047615457);
          w.int(h(v, "chatId"));
          w.long(h(v, "accessHash"));
        },
        "encryptedFileEmpty": function(w) {
          w.uint(3256830334);
        },
        "encryptedFile": function(w, v) {
          w.uint(2818608344);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int53(h(v, "size"));
          w.int(h(v, "dcId"));
          w.int(h(v, "keyFingerprint"));
        },
        "inputEncryptedFileEmpty": function(w) {
          w.uint(406307684);
        },
        "inputEncryptedFileUploaded": function(w, v) {
          w.uint(1690108678);
          w.long(h(v, "id"));
          w.int(h(v, "parts"));
          w.string(h(v, "md5Checksum"));
          w.int(h(v, "keyFingerprint"));
        },
        "inputEncryptedFile": function(w, v) {
          w.uint(1511503333);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputEncryptedFileBigUploaded": function(w, v) {
          w.uint(767652808);
          w.long(h(v, "id"));
          w.int(h(v, "parts"));
          w.int(h(v, "keyFingerprint"));
        },
        "encryptedMessage": function(w, v) {
          w.uint(3977822488);
          w.long(h(v, "randomId"));
          w.int(h(v, "chatId"));
          w.int(h(v, "date"));
          w.bytes(h(v, "bytes"));
          w.object(h(v, "file"));
        },
        "encryptedMessageService": function(w, v) {
          w.uint(594758406);
          w.long(h(v, "randomId"));
          w.int(h(v, "chatId"));
          w.int(h(v, "date"));
          w.bytes(h(v, "bytes"));
        },
        "messages.dhConfigNotModified": function(w, v) {
          w.uint(3236054581);
          w.bytes(h(v, "random"));
        },
        "messages.dhConfig": function(w, v) {
          w.uint(740433629);
          w.int(h(v, "g"));
          w.bytes(h(v, "p"));
          w.int(h(v, "version"));
          w.bytes(h(v, "random"));
        },
        "messages.sentEncryptedMessage": function(w, v) {
          w.uint(1443858741);
          w.int(h(v, "date"));
        },
        "messages.sentEncryptedFile": function(w, v) {
          w.uint(2492727090);
          w.int(h(v, "date"));
          w.object(h(v, "file"));
        },
        "inputDocumentEmpty": function(w) {
          w.uint(1928391342);
        },
        "inputDocument": function(w, v) {
          w.uint(448771445);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.bytes(h(v, "fileReference"));
        },
        "documentEmpty": function(w, v) {
          w.uint(922273905);
          w.long(h(v, "id"));
        },
        "document": function(w, v) {
          w.uint(2413085912);
          var flags = 0;
          var _thumbs = v.thumbs && v.thumbs.length;
          if (_thumbs)
            flags |= 1;
          var _videoThumbs = v.videoThumbs && v.videoThumbs.length;
          if (_videoThumbs)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.bytes(h(v, "fileReference"));
          w.int(h(v, "date"));
          w.string(h(v, "mimeType"));
          w.int53(h(v, "size"));
          if (_thumbs)
            w.vector(w.object, v.thumbs);
          if (_videoThumbs)
            w.vector(w.object, v.videoThumbs);
          w.int(h(v, "dcId"));
          w.vector(w.object, h(v, "attributes"));
        },
        "help.support": function(w, v) {
          w.uint(398898678);
          w.string(h(v, "phoneNumber"));
          w.object(h(v, "user"));
        },
        "notifyPeer": function(w, v) {
          w.uint(2681474008);
          w.object(h(v, "peer"));
        },
        "notifyUsers": function(w) {
          w.uint(3033021260);
        },
        "notifyChats": function(w) {
          w.uint(3221737155);
        },
        "notifyBroadcasts": function(w) {
          w.uint(3591563503);
        },
        "notifyForumTopic": function(w, v) {
          w.uint(577659656);
          w.object(h(v, "peer"));
          w.int(h(v, "topMsgId"));
        },
        "sendMessageTypingAction": function(w) {
          w.uint(381645902);
        },
        "sendMessageCancelAction": function(w) {
          w.uint(4250847477);
        },
        "sendMessageRecordVideoAction": function(w) {
          w.uint(2710034031);
        },
        "sendMessageUploadVideoAction": function(w, v) {
          w.uint(3916839660);
          w.int(h(v, "progress"));
        },
        "sendMessageRecordAudioAction": function(w) {
          w.uint(3576656887);
        },
        "sendMessageUploadAudioAction": function(w, v) {
          w.uint(4082227115);
          w.int(h(v, "progress"));
        },
        "sendMessageUploadPhotoAction": function(w, v) {
          w.uint(3520285222);
          w.int(h(v, "progress"));
        },
        "sendMessageUploadDocumentAction": function(w, v) {
          w.uint(2852968932);
          w.int(h(v, "progress"));
        },
        "sendMessageGeoLocationAction": function(w) {
          w.uint(393186209);
        },
        "sendMessageChooseContactAction": function(w) {
          w.uint(1653390447);
        },
        "sendMessageGamePlayAction": function(w) {
          w.uint(3714748232);
        },
        "sendMessageRecordRoundAction": function(w) {
          w.uint(2297593788);
        },
        "sendMessageUploadRoundAction": function(w, v) {
          w.uint(608050278);
          w.int(h(v, "progress"));
        },
        "speakingInGroupCallAction": function(w) {
          w.uint(3643548293);
        },
        "sendMessageHistoryImportAction": function(w, v) {
          w.uint(3688534598);
          w.int(h(v, "progress"));
        },
        "sendMessageChooseStickerAction": function(w) {
          w.uint(2958739121);
        },
        "sendMessageEmojiInteraction": function(w, v) {
          w.uint(630664139);
          w.string(h(v, "emoticon"));
          w.int(h(v, "msgId"));
          w.object(h(v, "interaction"));
        },
        "sendMessageEmojiInteractionSeen": function(w, v) {
          w.uint(3060109358);
          w.string(h(v, "emoticon"));
        },
        "contacts.found": function(w, v) {
          w.uint(3004386717);
          w.vector(w.object, h(v, "myResults"));
          w.vector(w.object, h(v, "results"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "inputPrivacyKeyStatusTimestamp": function(w) {
          w.uint(1335282456);
        },
        "inputPrivacyKeyChatInvite": function(w) {
          w.uint(3187344422);
        },
        "inputPrivacyKeyPhoneCall": function(w) {
          w.uint(4206550111);
        },
        "inputPrivacyKeyPhoneP2P": function(w) {
          w.uint(3684593874);
        },
        "inputPrivacyKeyForwards": function(w) {
          w.uint(2765966344);
        },
        "inputPrivacyKeyProfilePhoto": function(w) {
          w.uint(1461304012);
        },
        "inputPrivacyKeyPhoneNumber": function(w) {
          w.uint(55761658);
        },
        "inputPrivacyKeyAddedByPhone": function(w) {
          w.uint(3508640733);
        },
        "inputPrivacyKeyVoiceMessages": function(w) {
          w.uint(2934349160);
        },
        "inputPrivacyKeyAbout": function(w) {
          w.uint(941870144);
        },
        "inputPrivacyKeyBirthday": function(w) {
          w.uint(3596227020);
        },
        "privacyKeyStatusTimestamp": function(w) {
          w.uint(3157175088);
        },
        "privacyKeyChatInvite": function(w) {
          w.uint(1343122938);
        },
        "privacyKeyPhoneCall": function(w) {
          w.uint(1030105979);
        },
        "privacyKeyPhoneP2P": function(w) {
          w.uint(961092808);
        },
        "privacyKeyForwards": function(w) {
          w.uint(1777096355);
        },
        "privacyKeyProfilePhoto": function(w) {
          w.uint(2517966829);
        },
        "privacyKeyPhoneNumber": function(w) {
          w.uint(3516589165);
        },
        "privacyKeyAddedByPhone": function(w) {
          w.uint(1124062251);
        },
        "privacyKeyVoiceMessages": function(w) {
          w.uint(110621716);
        },
        "privacyKeyAbout": function(w) {
          w.uint(2760292193);
        },
        "privacyKeyBirthday": function(w) {
          w.uint(536913176);
        },
        "inputPrivacyValueAllowContacts": function(w) {
          w.uint(218751099);
        },
        "inputPrivacyValueAllowAll": function(w) {
          w.uint(407582158);
        },
        "inputPrivacyValueAllowUsers": function(w, v) {
          w.uint(320652927);
          w.vector(w.object, h(v, "users"));
        },
        "inputPrivacyValueDisallowContacts": function(w) {
          w.uint(195371015);
        },
        "inputPrivacyValueDisallowAll": function(w) {
          w.uint(3597362889);
        },
        "inputPrivacyValueDisallowUsers": function(w, v) {
          w.uint(2417034343);
          w.vector(w.object, h(v, "users"));
        },
        "inputPrivacyValueAllowChatParticipants": function(w, v) {
          w.uint(2215004623);
          w.vector(w.int53, h(v, "chats"));
        },
        "inputPrivacyValueDisallowChatParticipants": function(w, v) {
          w.uint(3914272646);
          w.vector(w.int53, h(v, "chats"));
        },
        "inputPrivacyValueAllowCloseFriends": function(w) {
          w.uint(793067081);
        },
        "inputPrivacyValueAllowPremium": function(w) {
          w.uint(2009975281);
        },
        "privacyValueAllowContacts": function(w) {
          w.uint(4294843308);
        },
        "privacyValueAllowAll": function(w) {
          w.uint(1698855810);
        },
        "privacyValueAllowUsers": function(w, v) {
          w.uint(3096469426);
          w.vector(w.int53, h(v, "users"));
        },
        "privacyValueDisallowContacts": function(w) {
          w.uint(4169726490);
        },
        "privacyValueDisallowAll": function(w) {
          w.uint(2339628899);
        },
        "privacyValueDisallowUsers": function(w, v) {
          w.uint(3831632193);
          w.vector(w.int53, h(v, "users"));
        },
        "privacyValueAllowChatParticipants": function(w, v) {
          w.uint(1796427406);
          w.vector(w.int53, h(v, "chats"));
        },
        "privacyValueDisallowChatParticipants": function(w, v) {
          w.uint(1103656293);
          w.vector(w.int53, h(v, "chats"));
        },
        "privacyValueAllowCloseFriends": function(w) {
          w.uint(4159232155);
        },
        "privacyValueAllowPremium": function(w) {
          w.uint(3974725963);
        },
        "account.privacyRules": function(w, v) {
          w.uint(1352683077);
          w.vector(w.object, h(v, "rules"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "accountDaysTTL": function(w, v) {
          w.uint(3100684255);
          w.int(h(v, "days"));
        },
        "documentAttributeImageSize": function(w, v) {
          w.uint(1815593308);
          w.int(h(v, "w"));
          w.int(h(v, "h"));
        },
        "documentAttributeAnimated": function(w) {
          w.uint(297109817);
        },
        "documentAttributeSticker": function(w, v) {
          w.uint(1662637586);
          var flags = 0;
          var _maskCoords = v.maskCoords !== void 0;
          if (_maskCoords)
            flags |= 1;
          if (v.mask === true)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "alt"));
          w.object(h(v, "stickerset"));
          if (_maskCoords)
            w.object(v.maskCoords);
        },
        "documentAttributeVideo": function(w, v) {
          w.uint(1137015880);
          var flags = 0;
          if (v.roundMessage === true)
            flags |= 1;
          if (v.supportsStreaming === true)
            flags |= 2;
          var _preloadPrefixSize = v.preloadPrefixSize !== void 0;
          if (_preloadPrefixSize)
            flags |= 4;
          if (v.nosound === true)
            flags |= 8;
          var _videoStartTs = v.videoStartTs !== void 0;
          if (_videoStartTs)
            flags |= 16;
          var _videoCodec = v.videoCodec !== void 0;
          if (_videoCodec)
            flags |= 32;
          w.uint(flags);
          w.double(h(v, "duration"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
          if (_preloadPrefixSize)
            w.int(v.preloadPrefixSize);
          if (_videoStartTs)
            w.double(v.videoStartTs);
          if (_videoCodec)
            w.string(v.videoCodec);
        },
        "documentAttributeAudio": function(w, v) {
          w.uint(2555574726);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _performer = v.performer !== void 0;
          if (_performer)
            flags |= 2;
          var _waveform = v.waveform !== void 0;
          if (_waveform)
            flags |= 4;
          if (v.voice === true)
            flags |= 1024;
          w.uint(flags);
          w.int(h(v, "duration"));
          if (_title)
            w.string(v.title);
          if (_performer)
            w.string(v.performer);
          if (_waveform)
            w.bytes(v.waveform);
        },
        "documentAttributeFilename": function(w, v) {
          w.uint(358154344);
          w.string(h(v, "fileName"));
        },
        "documentAttributeHasStickers": function(w) {
          w.uint(2550256375);
        },
        "documentAttributeCustomEmoji": function(w, v) {
          w.uint(4245985433);
          var flags = 0;
          if (v.free === true)
            flags |= 1;
          if (v.textColor === true)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "alt"));
          w.object(h(v, "stickerset"));
        },
        "messages.stickersNotModified": function(w) {
          w.uint(4050950690);
        },
        "messages.stickers": function(w, v) {
          w.uint(816245886);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "stickers"));
        },
        "stickerPack": function(w, v) {
          w.uint(313694676);
          w.string(h(v, "emoticon"));
          w.vector(w.long, h(v, "documents"));
        },
        "messages.allStickersNotModified": function(w) {
          w.uint(3898999491);
        },
        "messages.allStickers": function(w, v) {
          w.uint(3451637435);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "sets"));
        },
        "messages.affectedMessages": function(w, v) {
          w.uint(2228326789);
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
        },
        "webPageEmpty": function(w, v) {
          w.uint(555358088);
          var flags = 0;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "id"));
          if (_url)
            w.string(v.url);
        },
        "webPagePending": function(w, v) {
          w.uint(2966502983);
          var flags = 0;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "id"));
          if (_url)
            w.string(v.url);
          w.int(h(v, "date"));
        },
        "webPage": function(w, v) {
          w.uint(3902555570);
          var flags = 0;
          var _type = v.type !== void 0;
          if (_type)
            flags |= 1;
          var _siteName = v.siteName !== void 0;
          if (_siteName)
            flags |= 2;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 4;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 8;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 16;
          var _embedUrl = v.embedUrl !== void 0;
          var _embedType = v.embedType !== void 0;
          var _flags_5 = _embedUrl || _embedType;
          if (_flags_5)
            flags |= 32;
          var _embedWidth = v.embedWidth !== void 0;
          var _embedHeight = v.embedHeight !== void 0;
          var _flags_6 = _embedWidth || _embedHeight;
          if (_flags_6)
            flags |= 64;
          var _duration = v.duration !== void 0;
          if (_duration)
            flags |= 128;
          var _author = v.author !== void 0;
          if (_author)
            flags |= 256;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 512;
          var _cachedPage = v.cachedPage !== void 0;
          if (_cachedPage)
            flags |= 1024;
          var _attributes = v.attributes && v.attributes.length;
          if (_attributes)
            flags |= 4096;
          if (v.hasLargeMedia === true)
            flags |= 8192;
          w.uint(flags);
          w.long(h(v, "id"));
          w.string(h(v, "url"));
          w.string(h(v, "displayUrl"));
          w.int(h(v, "hash"));
          if (_type)
            w.string(v.type);
          if (_siteName)
            w.string(v.siteName);
          if (_title)
            w.string(v.title);
          if (_description)
            w.string(v.description);
          if (_photo)
            w.object(v.photo);
          if (_flags_5)
            w.string(v.embedUrl);
          if (_flags_5)
            w.string(v.embedType);
          if (_flags_6)
            w.int(v.embedWidth);
          if (_flags_6)
            w.int(v.embedHeight);
          if (_duration)
            w.int(v.duration);
          if (_author)
            w.string(v.author);
          if (_document)
            w.object(v.document);
          if (_cachedPage)
            w.object(v.cachedPage);
          if (_attributes)
            w.vector(w.object, v.attributes);
        },
        "webPageNotModified": function(w, v) {
          w.uint(1930545681);
          var flags = 0;
          var _cachedPageViews = v.cachedPageViews !== void 0;
          if (_cachedPageViews)
            flags |= 1;
          w.uint(flags);
          if (_cachedPageViews)
            w.int(v.cachedPageViews);
        },
        "authorization": function(w, v) {
          w.uint(2902578717);
          var flags = 0;
          if (v.current === true)
            flags |= 1;
          if (v.officialApp === true)
            flags |= 2;
          if (v.passwordPending === true)
            flags |= 4;
          if (v.encryptedRequestsDisabled === true)
            flags |= 8;
          if (v.callRequestsDisabled === true)
            flags |= 16;
          if (v.unconfirmed === true)
            flags |= 32;
          w.uint(flags);
          w.long(h(v, "hash"));
          w.string(h(v, "deviceModel"));
          w.string(h(v, "platform"));
          w.string(h(v, "systemVersion"));
          w.int(h(v, "apiId"));
          w.string(h(v, "appName"));
          w.string(h(v, "appVersion"));
          w.int(h(v, "dateCreated"));
          w.int(h(v, "dateActive"));
          w.string(h(v, "ip"));
          w.string(h(v, "country"));
          w.string(h(v, "region"));
        },
        "account.authorizations": function(w, v) {
          w.uint(1275039392);
          w.int(h(v, "authorizationTtlDays"));
          w.vector(w.object, h(v, "authorizations"));
        },
        "account.password": function(w, v) {
          w.uint(2507886843);
          var flags = 0;
          if (v.hasRecovery === true)
            flags |= 1;
          if (v.hasSecureValues === true)
            flags |= 2;
          var _currentAlgo = v.currentAlgo !== void 0;
          var _srpB = v.srpB !== void 0;
          var _srpId = v.srpId !== void 0;
          var _flags_2 = v.hasPassword === true || _currentAlgo || _srpB || _srpId;
          if (_flags_2)
            flags |= 4;
          var _hint = v.hint !== void 0;
          if (_hint)
            flags |= 8;
          var _emailUnconfirmedPattern = v.emailUnconfirmedPattern !== void 0;
          if (_emailUnconfirmedPattern)
            flags |= 16;
          var _pendingResetDate = v.pendingResetDate !== void 0;
          if (_pendingResetDate)
            flags |= 32;
          var _loginEmailPattern = v.loginEmailPattern !== void 0;
          if (_loginEmailPattern)
            flags |= 64;
          w.uint(flags);
          if (_flags_2)
            w.object(v.currentAlgo);
          if (_flags_2)
            w.bytes(v.srpB);
          if (_flags_2)
            w.long(v.srpId);
          if (_hint)
            w.string(v.hint);
          if (_emailUnconfirmedPattern)
            w.string(v.emailUnconfirmedPattern);
          w.object(h(v, "newAlgo"));
          w.object(h(v, "newSecureAlgo"));
          w.bytes(h(v, "secureRandom"));
          if (_pendingResetDate)
            w.int(v.pendingResetDate);
          if (_loginEmailPattern)
            w.string(v.loginEmailPattern);
        },
        "account.passwordSettings": function(w, v) {
          w.uint(2589733861);
          var flags = 0;
          var _email = v.email !== void 0;
          if (_email)
            flags |= 1;
          var _secureSettings = v.secureSettings !== void 0;
          if (_secureSettings)
            flags |= 2;
          w.uint(flags);
          if (_email)
            w.string(v.email);
          if (_secureSettings)
            w.object(v.secureSettings);
        },
        "account.passwordInputSettings": function(w, v) {
          w.uint(3258394569);
          var flags = 0;
          var _newAlgo = v.newAlgo !== void 0;
          var _newPasswordHash = v.newPasswordHash !== void 0;
          var _hint = v.hint !== void 0;
          var _flags_0 = _newAlgo || _newPasswordHash || _hint;
          if (_flags_0)
            flags |= 1;
          var _email = v.email !== void 0;
          if (_email)
            flags |= 2;
          var _newSecureSettings = v.newSecureSettings !== void 0;
          if (_newSecureSettings)
            flags |= 4;
          w.uint(flags);
          if (_flags_0)
            w.object(v.newAlgo);
          if (_flags_0)
            w.bytes(v.newPasswordHash);
          if (_flags_0)
            w.string(v.hint);
          if (_email)
            w.string(v.email);
          if (_newSecureSettings)
            w.object(v.newSecureSettings);
        },
        "auth.passwordRecovery": function(w, v) {
          w.uint(326715557);
          w.string(h(v, "emailPattern"));
        },
        "receivedNotifyMessage": function(w, v) {
          w.uint(2743383929);
          w.int(h(v, "id"));
          w.int(h(v, "flags"));
        },
        "chatInviteExported": function(w, v) {
          w.uint(2720841110);
          var flags = 0;
          if (v.revoked === true)
            flags |= 1;
          var _expireDate = v.expireDate !== void 0;
          if (_expireDate)
            flags |= 2;
          var _usageLimit = v.usageLimit !== void 0;
          if (_usageLimit)
            flags |= 4;
          var _usage = v.usage !== void 0;
          if (_usage)
            flags |= 8;
          var _startDate = v.startDate !== void 0;
          if (_startDate)
            flags |= 16;
          if (v.permanent === true)
            flags |= 32;
          if (v.requestNeeded === true)
            flags |= 64;
          var _requested = v.requested !== void 0;
          if (_requested)
            flags |= 128;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 256;
          var _subscriptionPricing = v.subscriptionPricing !== void 0;
          if (_subscriptionPricing)
            flags |= 512;
          var _subscriptionExpired = v.subscriptionExpired !== void 0;
          if (_subscriptionExpired)
            flags |= 1024;
          w.uint(flags);
          w.string(h(v, "link"));
          w.int53(h(v, "adminId"));
          w.int(h(v, "date"));
          if (_startDate)
            w.int(v.startDate);
          if (_expireDate)
            w.int(v.expireDate);
          if (_usageLimit)
            w.int(v.usageLimit);
          if (_usage)
            w.int(v.usage);
          if (_requested)
            w.int(v.requested);
          if (_subscriptionExpired)
            w.int(v.subscriptionExpired);
          if (_title)
            w.string(v.title);
          if (_subscriptionPricing)
            w.object(v.subscriptionPricing);
        },
        "chatInvitePublicJoinRequests": function(w) {
          w.uint(3977280183);
        },
        "chatInviteAlready": function(w, v) {
          w.uint(1516793212);
          w.object(h(v, "chat"));
        },
        "chatInvite": function(w, v) {
          w.uint(4268046493);
          var flags = 0;
          if (v.channel === true)
            flags |= 1;
          if (v.broadcast === true)
            flags |= 2;
          if (v.public === true)
            flags |= 4;
          if (v.megagroup === true)
            flags |= 8;
          var _participants = v.participants && v.participants.length;
          if (_participants)
            flags |= 16;
          var _about = v.about !== void 0;
          if (_about)
            flags |= 32;
          if (v.requestNeeded === true)
            flags |= 64;
          if (v.verified === true)
            flags |= 128;
          if (v.scam === true)
            flags |= 256;
          if (v.fake === true)
            flags |= 512;
          var _subscriptionPricing = v.subscriptionPricing !== void 0;
          if (_subscriptionPricing)
            flags |= 1024;
          if (v.canRefulfillSubscription === true)
            flags |= 2048;
          var _subscriptionFormId = v.subscriptionFormId !== void 0;
          if (_subscriptionFormId)
            flags |= 4096;
          w.uint(flags);
          w.string(h(v, "title"));
          if (_about)
            w.string(v.about);
          w.object(h(v, "photo"));
          w.int(h(v, "participantsCount"));
          if (_participants)
            w.vector(w.object, v.participants);
          w.int(h(v, "color"));
          if (_subscriptionPricing)
            w.object(v.subscriptionPricing);
          if (_subscriptionFormId)
            w.long(v.subscriptionFormId);
        },
        "chatInvitePeek": function(w, v) {
          w.uint(1634294960);
          w.object(h(v, "chat"));
          w.int(h(v, "expires"));
        },
        "inputStickerSetEmpty": function(w) {
          w.uint(4290128789);
        },
        "inputStickerSetID": function(w, v) {
          w.uint(2649203305);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputStickerSetShortName": function(w, v) {
          w.uint(2250033312);
          w.string(h(v, "shortName"));
        },
        "inputStickerSetAnimatedEmoji": function(w) {
          w.uint(42402760);
        },
        "inputStickerSetDice": function(w, v) {
          w.uint(3867103758);
          w.string(h(v, "emoticon"));
        },
        "inputStickerSetAnimatedEmojiAnimations": function(w) {
          w.uint(215889721);
        },
        "inputStickerSetPremiumGifts": function(w) {
          w.uint(3364567810);
        },
        "inputStickerSetEmojiGenericAnimations": function(w) {
          w.uint(80008398);
        },
        "inputStickerSetEmojiDefaultStatuses": function(w) {
          w.uint(701560302);
        },
        "inputStickerSetEmojiDefaultTopicIcons": function(w) {
          w.uint(1153562857);
        },
        "inputStickerSetEmojiChannelDefaultStatuses": function(w) {
          w.uint(1232373075);
        },
        "stickerSet": function(w, v) {
          w.uint(768691932);
          var flags = 0;
          var _installedDate = v.installedDate !== void 0;
          if (_installedDate)
            flags |= 1;
          if (v.archived === true)
            flags |= 2;
          if (v.official === true)
            flags |= 4;
          if (v.masks === true)
            flags |= 8;
          var _thumbs = v.thumbs && v.thumbs.length;
          var _thumbDcId = v.thumbDcId !== void 0;
          var _thumbVersion = v.thumbVersion !== void 0;
          var _flags_4 = _thumbs || _thumbDcId || _thumbVersion;
          if (_flags_4)
            flags |= 16;
          if (v.emojis === true)
            flags |= 128;
          var _thumbDocumentId = v.thumbDocumentId !== void 0;
          if (_thumbDocumentId)
            flags |= 256;
          if (v.textColor === true)
            flags |= 512;
          if (v.channelEmojiStatus === true)
            flags |= 1024;
          if (v.creator === true)
            flags |= 2048;
          w.uint(flags);
          if (_installedDate)
            w.int(v.installedDate);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.string(h(v, "title"));
          w.string(h(v, "shortName"));
          if (_flags_4)
            w.vector(w.object, v.thumbs);
          if (_flags_4)
            w.int(v.thumbDcId);
          if (_flags_4)
            w.int(v.thumbVersion);
          if (_thumbDocumentId)
            w.long(v.thumbDocumentId);
          w.int(h(v, "count"));
          w.int(h(v, "hash"));
        },
        "messages.stickerSet": function(w, v) {
          w.uint(1846886166);
          w.object(h(v, "set"));
          w.vector(w.object, h(v, "packs"));
          w.vector(w.object, h(v, "keywords"));
          w.vector(w.object, h(v, "documents"));
        },
        "messages.stickerSetNotModified": function(w) {
          w.uint(3556320491);
        },
        "botCommand": function(w, v) {
          w.uint(3262826695);
          w.string(h(v, "command"));
          w.string(h(v, "description"));
        },
        "botInfo": function(w, v) {
          w.uint(2185461364);
          var flags = 0;
          var _userId = v.userId !== void 0;
          if (_userId)
            flags |= 1;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 2;
          var _commands = v.commands && v.commands.length;
          if (_commands)
            flags |= 4;
          var _menuButton = v.menuButton !== void 0;
          if (_menuButton)
            flags |= 8;
          var _descriptionPhoto = v.descriptionPhoto !== void 0;
          if (_descriptionPhoto)
            flags |= 16;
          var _descriptionDocument = v.descriptionDocument !== void 0;
          if (_descriptionDocument)
            flags |= 32;
          if (v.hasPreviewMedias === true)
            flags |= 64;
          var _privacyPolicyUrl = v.privacyPolicyUrl !== void 0;
          if (_privacyPolicyUrl)
            flags |= 128;
          w.uint(flags);
          if (_userId)
            w.int53(v.userId);
          if (_description)
            w.string(v.description);
          if (_descriptionPhoto)
            w.object(v.descriptionPhoto);
          if (_descriptionDocument)
            w.object(v.descriptionDocument);
          if (_commands)
            w.vector(w.object, v.commands);
          if (_menuButton)
            w.object(v.menuButton);
          if (_privacyPolicyUrl)
            w.string(v.privacyPolicyUrl);
        },
        "keyboardButton": function(w, v) {
          w.uint(2734311552);
          w.string(h(v, "text"));
        },
        "keyboardButtonUrl": function(w, v) {
          w.uint(629866245);
          w.string(h(v, "text"));
          w.string(h(v, "url"));
        },
        "keyboardButtonCallback": function(w, v) {
          w.uint(901503851);
          var flags = 0;
          if (v.requiresPassword === true)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "text"));
          w.bytes(h(v, "data"));
        },
        "keyboardButtonRequestPhone": function(w, v) {
          w.uint(2976541737);
          w.string(h(v, "text"));
        },
        "keyboardButtonRequestGeoLocation": function(w, v) {
          w.uint(4235815743);
          w.string(h(v, "text"));
        },
        "keyboardButtonSwitchInline": function(w, v) {
          w.uint(2478439349);
          var flags = 0;
          if (v.samePeer === true)
            flags |= 1;
          var _peerTypes = v.peerTypes && v.peerTypes.length;
          if (_peerTypes)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "text"));
          w.string(h(v, "query"));
          if (_peerTypes)
            w.vector(w.object, v.peerTypes);
        },
        "keyboardButtonGame": function(w, v) {
          w.uint(1358175439);
          w.string(h(v, "text"));
        },
        "keyboardButtonBuy": function(w, v) {
          w.uint(2950250427);
          w.string(h(v, "text"));
        },
        "keyboardButtonUrlAuth": function(w, v) {
          w.uint(280464681);
          var flags = 0;
          var _fwdText = v.fwdText !== void 0;
          if (_fwdText)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "text"));
          if (_fwdText)
            w.string(v.fwdText);
          w.string(h(v, "url"));
          w.int(h(v, "buttonId"));
        },
        "inputKeyboardButtonUrlAuth": function(w, v) {
          w.uint(3492708308);
          var flags = 0;
          if (v.requestWriteAccess === true)
            flags |= 1;
          var _fwdText = v.fwdText !== void 0;
          if (_fwdText)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "text"));
          if (_fwdText)
            w.string(v.fwdText);
          w.string(h(v, "url"));
          w.object(h(v, "bot"));
        },
        "keyboardButtonRequestPoll": function(w, v) {
          w.uint(3150401885);
          var flags = 0;
          var _quiz = v.quiz !== void 0;
          if (_quiz)
            flags |= 1;
          w.uint(flags);
          if (_quiz)
            w.boolean(v.quiz);
          w.string(h(v, "text"));
        },
        "inputKeyboardButtonUserProfile": function(w, v) {
          w.uint(3918005115);
          w.string(h(v, "text"));
          w.object(h(v, "userId"));
        },
        "keyboardButtonUserProfile": function(w, v) {
          w.uint(814112961);
          w.string(h(v, "text"));
          w.int53(h(v, "userId"));
        },
        "keyboardButtonWebView": function(w, v) {
          w.uint(326529584);
          w.string(h(v, "text"));
          w.string(h(v, "url"));
        },
        "keyboardButtonSimpleWebView": function(w, v) {
          w.uint(2696958044);
          w.string(h(v, "text"));
          w.string(h(v, "url"));
        },
        "keyboardButtonRequestPeer": function(w, v) {
          w.uint(1406648280);
          w.string(h(v, "text"));
          w.int(h(v, "buttonId"));
          w.object(h(v, "peerType"));
          w.int(h(v, "maxQuantity"));
        },
        "inputKeyboardButtonRequestPeer": function(w, v) {
          w.uint(3378916613);
          var flags = 0;
          if (v.nameRequested === true)
            flags |= 1;
          if (v.usernameRequested === true)
            flags |= 2;
          if (v.photoRequested === true)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "text"));
          w.int(h(v, "buttonId"));
          w.object(h(v, "peerType"));
          w.int(h(v, "maxQuantity"));
        },
        "keyboardButtonCopy": function(w, v) {
          w.uint(1976723854);
          w.string(h(v, "text"));
          w.string(h(v, "copyText"));
        },
        "keyboardButtonRow": function(w, v) {
          w.uint(2002815875);
          w.vector(w.object, h(v, "buttons"));
        },
        "replyKeyboardHide": function(w, v) {
          w.uint(2688441221);
          var flags = 0;
          if (v.selective === true)
            flags |= 4;
          w.uint(flags);
        },
        "replyKeyboardForceReply": function(w, v) {
          w.uint(2259946248);
          var flags = 0;
          if (v.singleUse === true)
            flags |= 2;
          if (v.selective === true)
            flags |= 4;
          var _placeholder = v.placeholder !== void 0;
          if (_placeholder)
            flags |= 8;
          w.uint(flags);
          if (_placeholder)
            w.string(v.placeholder);
        },
        "replyKeyboardMarkup": function(w, v) {
          w.uint(2245892561);
          var flags = 0;
          if (v.resize === true)
            flags |= 1;
          if (v.singleUse === true)
            flags |= 2;
          if (v.selective === true)
            flags |= 4;
          var _placeholder = v.placeholder !== void 0;
          if (_placeholder)
            flags |= 8;
          if (v.persistent === true)
            flags |= 16;
          w.uint(flags);
          w.vector(w.object, h(v, "rows"));
          if (_placeholder)
            w.string(v.placeholder);
        },
        "replyInlineMarkup": function(w, v) {
          w.uint(1218642516);
          w.vector(w.object, h(v, "rows"));
        },
        "messageEntityUnknown": function(w, v) {
          w.uint(3146955413);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityMention": function(w, v) {
          w.uint(4194588573);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityHashtag": function(w, v) {
          w.uint(1868782349);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityBotCommand": function(w, v) {
          w.uint(1827637959);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityUrl": function(w, v) {
          w.uint(1859134776);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityEmail": function(w, v) {
          w.uint(1692693954);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityBold": function(w, v) {
          w.uint(3177253833);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityItalic": function(w, v) {
          w.uint(2188348256);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityCode": function(w, v) {
          w.uint(681706865);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityPre": function(w, v) {
          w.uint(1938967520);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
          w.string(h(v, "language"));
        },
        "messageEntityTextUrl": function(w, v) {
          w.uint(1990644519);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
          w.string(h(v, "url"));
        },
        "messageEntityMentionName": function(w, v) {
          w.uint(3699052864);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
          w.int53(h(v, "userId"));
        },
        "inputMessageEntityMentionName": function(w, v) {
          w.uint(546203849);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
          w.object(h(v, "userId"));
        },
        "messageEntityPhone": function(w, v) {
          w.uint(2607407947);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityCashtag": function(w, v) {
          w.uint(1280209983);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityUnderline": function(w, v) {
          w.uint(2622389899);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityStrike": function(w, v) {
          w.uint(3204879316);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityBankCard": function(w, v) {
          w.uint(1981704948);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntitySpoiler": function(w, v) {
          w.uint(852137487);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "messageEntityCustomEmoji": function(w, v) {
          w.uint(3369010680);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
          w.long(h(v, "documentId"));
        },
        "messageEntityBlockquote": function(w, v) {
          w.uint(4056722092);
          var flags = 0;
          if (v.collapsed === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "offset"));
          w.int(h(v, "length"));
        },
        "inputChannelEmpty": function(w) {
          w.uint(4002160262);
        },
        "inputChannel": function(w, v) {
          w.uint(4082822184);
          w.int53(h(v, "channelId"));
          w.long(h(v, "accessHash"));
        },
        "inputChannelFromMessage": function(w, v) {
          w.uint(1536380829);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int53(h(v, "channelId"));
        },
        "contacts.resolvedPeer": function(w, v) {
          w.uint(2131196633);
          w.object(h(v, "peer"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messageRange": function(w, v) {
          w.uint(182649427);
          w.int(h(v, "minId"));
          w.int(h(v, "maxId"));
        },
        "updates.channelDifferenceEmpty": function(w, v) {
          w.uint(1041346555);
          var flags = 0;
          if (v.final === true)
            flags |= 1;
          var _timeout = v.timeout !== void 0;
          if (_timeout)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "pts"));
          if (_timeout)
            w.int(v.timeout);
        },
        "updates.channelDifferenceTooLong": function(w, v) {
          w.uint(2763835134);
          var flags = 0;
          if (v.final === true)
            flags |= 1;
          var _timeout = v.timeout !== void 0;
          if (_timeout)
            flags |= 2;
          w.uint(flags);
          if (_timeout)
            w.int(v.timeout);
          w.object(h(v, "dialog"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "updates.channelDifference": function(w, v) {
          w.uint(543450958);
          var flags = 0;
          if (v.final === true)
            flags |= 1;
          var _timeout = v.timeout !== void 0;
          if (_timeout)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "pts"));
          if (_timeout)
            w.int(v.timeout);
          w.vector(w.object, h(v, "newMessages"));
          w.vector(w.object, h(v, "otherUpdates"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "channelMessagesFilterEmpty": function(w) {
          w.uint(2496933607);
        },
        "channelMessagesFilter": function(w, v) {
          w.uint(3447183703);
          var flags = 0;
          if (v.excludeNewMessages === true)
            flags |= 2;
          w.uint(flags);
          w.vector(w.object, h(v, "ranges"));
        },
        "channelParticipant": function(w, v) {
          w.uint(3409540633);
          var flags = 0;
          var _subscriptionUntilDate = v.subscriptionUntilDate !== void 0;
          if (_subscriptionUntilDate)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "userId"));
          w.int(h(v, "date"));
          if (_subscriptionUntilDate)
            w.int(v.subscriptionUntilDate);
        },
        "channelParticipantSelf": function(w, v) {
          w.uint(1331723247);
          var flags = 0;
          if (v.viaRequest === true)
            flags |= 1;
          var _subscriptionUntilDate = v.subscriptionUntilDate !== void 0;
          if (_subscriptionUntilDate)
            flags |= 2;
          w.uint(flags);
          w.int53(h(v, "userId"));
          w.int53(h(v, "inviterId"));
          w.int(h(v, "date"));
          if (_subscriptionUntilDate)
            w.int(v.subscriptionUntilDate);
        },
        "channelParticipantCreator": function(w, v) {
          w.uint(803602899);
          var flags = 0;
          var _rank = v.rank !== void 0;
          if (_rank)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "userId"));
          w.object(h(v, "adminRights"));
          if (_rank)
            w.string(v.rank);
        },
        "channelParticipantAdmin": function(w, v) {
          w.uint(885242707);
          var flags = 0;
          if (v.canEdit === true)
            flags |= 1;
          var _inviterId = v.inviterId !== void 0;
          var _flags_1 = v.self === true || _inviterId;
          if (_flags_1)
            flags |= 2;
          var _rank = v.rank !== void 0;
          if (_rank)
            flags |= 4;
          w.uint(flags);
          w.int53(h(v, "userId"));
          if (_flags_1)
            w.int53(v.inviterId);
          w.int53(h(v, "promotedBy"));
          w.int(h(v, "date"));
          w.object(h(v, "adminRights"));
          if (_rank)
            w.string(v.rank);
        },
        "channelParticipantBanned": function(w, v) {
          w.uint(1844969806);
          var flags = 0;
          if (v.left === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int53(h(v, "kickedBy"));
          w.int(h(v, "date"));
          w.object(h(v, "bannedRights"));
        },
        "channelParticipantLeft": function(w, v) {
          w.uint(453242886);
          w.object(h(v, "peer"));
        },
        "channelParticipantsRecent": function(w) {
          w.uint(3728686201);
        },
        "channelParticipantsAdmins": function(w) {
          w.uint(3026225513);
        },
        "channelParticipantsKicked": function(w, v) {
          w.uint(2746567045);
          w.string(h(v, "q"));
        },
        "channelParticipantsBots": function(w) {
          w.uint(2966521435);
        },
        "channelParticipantsBanned": function(w, v) {
          w.uint(338142689);
          w.string(h(v, "q"));
        },
        "channelParticipantsSearch": function(w, v) {
          w.uint(106343499);
          w.string(h(v, "q"));
        },
        "channelParticipantsContacts": function(w, v) {
          w.uint(3144345741);
          w.string(h(v, "q"));
        },
        "channelParticipantsMentions": function(w, v) {
          w.uint(3763035371);
          var flags = 0;
          var _q = v.q !== void 0;
          if (_q)
            flags |= 1;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 2;
          w.uint(flags);
          if (_q)
            w.string(v.q);
          if (_topMsgId)
            w.int(v.topMsgId);
        },
        "channels.channelParticipants": function(w, v) {
          w.uint(2595290799);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "participants"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "channels.channelParticipantsNotModified": function(w) {
          w.uint(4028055529);
        },
        "channels.channelParticipant": function(w, v) {
          w.uint(3753378583);
          w.object(h(v, "participant"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "help.termsOfService": function(w, v) {
          w.uint(2013922064);
          var flags = 0;
          if (v.popup === true)
            flags |= 1;
          var _minAgeConfirm = v.minAgeConfirm !== void 0;
          if (_minAgeConfirm)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "id"));
          w.string(h(v, "text"));
          w.vector(w.object, h(v, "entities"));
          if (_minAgeConfirm)
            w.int(v.minAgeConfirm);
        },
        "messages.savedGifsNotModified": function(w) {
          w.uint(3892468898);
        },
        "messages.savedGifs": function(w, v) {
          w.uint(2225089037);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "gifs"));
        },
        "inputBotInlineMessageMediaAuto": function(w, v) {
          w.uint(864077702);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          if (v.invertMedia === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineMessageText": function(w, v) {
          w.uint(1036876423);
          var flags = 0;
          if (v.noWebpage === true)
            flags |= 1;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          if (v.invertMedia === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineMessageMediaGeo": function(w, v) {
          w.uint(2526190213);
          var flags = 0;
          var _heading = v.heading !== void 0;
          if (_heading)
            flags |= 1;
          var _period = v.period !== void 0;
          if (_period)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
          if (_proximityNotificationRadius)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "geoPoint"));
          if (_heading)
            w.int(v.heading);
          if (_period)
            w.int(v.period);
          if (_proximityNotificationRadius)
            w.int(v.proximityNotificationRadius);
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineMessageMediaVenue": function(w, v) {
          w.uint(1098628881);
          var flags = 0;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "geoPoint"));
          w.string(h(v, "title"));
          w.string(h(v, "address"));
          w.string(h(v, "provider"));
          w.string(h(v, "venueId"));
          w.string(h(v, "venueType"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineMessageMediaContact": function(w, v) {
          w.uint(2800599037);
          var flags = 0;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
          w.string(h(v, "vcard"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineMessageGame": function(w, v) {
          w.uint(1262639204);
          var flags = 0;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          w.uint(flags);
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineMessageMediaInvoice": function(w, v) {
          w.uint(3622273573);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 1;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          w.object(h(v, "invoice"));
          w.bytes(h(v, "payload"));
          w.string(h(v, "provider"));
          w.object(h(v, "providerData"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineMessageMediaWebPage": function(w, v) {
          w.uint(3185362192);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          if (v.invertMedia === true)
            flags |= 8;
          if (v.forceLargeMedia === true)
            flags |= 16;
          if (v.forceSmallMedia === true)
            flags |= 32;
          if (v.optional === true)
            flags |= 64;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          w.string(h(v, "url"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "inputBotInlineResult": function(w, v) {
          w.uint(2294256409);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 4;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 8;
          var _thumb = v.thumb !== void 0;
          if (_thumb)
            flags |= 16;
          var _content = v.content !== void 0;
          if (_content)
            flags |= 32;
          w.uint(flags);
          w.string(h(v, "id"));
          w.string(h(v, "type"));
          if (_title)
            w.string(v.title);
          if (_description)
            w.string(v.description);
          if (_url)
            w.string(v.url);
          if (_thumb)
            w.object(v.thumb);
          if (_content)
            w.object(v.content);
          w.object(h(v, "sendMessage"));
        },
        "inputBotInlineResultPhoto": function(w, v) {
          w.uint(2832753831);
          w.string(h(v, "id"));
          w.string(h(v, "type"));
          w.object(h(v, "photo"));
          w.object(h(v, "sendMessage"));
        },
        "inputBotInlineResultDocument": function(w, v) {
          w.uint(4294507972);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "id"));
          w.string(h(v, "type"));
          if (_title)
            w.string(v.title);
          if (_description)
            w.string(v.description);
          w.object(h(v, "document"));
          w.object(h(v, "sendMessage"));
        },
        "inputBotInlineResultGame": function(w, v) {
          w.uint(1336154098);
          w.string(h(v, "id"));
          w.string(h(v, "shortName"));
          w.object(h(v, "sendMessage"));
        },
        "botInlineMessageMediaAuto": function(w, v) {
          w.uint(1984755728);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          if (v.invertMedia === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "botInlineMessageText": function(w, v) {
          w.uint(2357159394);
          var flags = 0;
          if (v.noWebpage === true)
            flags |= 1;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          if (v.invertMedia === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "botInlineMessageMediaGeo": function(w, v) {
          w.uint(85477117);
          var flags = 0;
          var _heading = v.heading !== void 0;
          if (_heading)
            flags |= 1;
          var _period = v.period !== void 0;
          if (_period)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
          if (_proximityNotificationRadius)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "geo"));
          if (_heading)
            w.int(v.heading);
          if (_period)
            w.int(v.period);
          if (_proximityNotificationRadius)
            w.int(v.proximityNotificationRadius);
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "botInlineMessageMediaVenue": function(w, v) {
          w.uint(2324063644);
          var flags = 0;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "geo"));
          w.string(h(v, "title"));
          w.string(h(v, "address"));
          w.string(h(v, "provider"));
          w.string(h(v, "venueId"));
          w.string(h(v, "venueType"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "botInlineMessageMediaContact": function(w, v) {
          w.uint(416402882);
          var flags = 0;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
          w.string(h(v, "vcard"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "botInlineMessageMediaInvoice": function(w, v) {
          w.uint(894081801);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 1;
          if (v.shippingAddressRequested === true)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          if (v.test === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "botInlineMessageMediaWebPage": function(w, v) {
          w.uint(2157631910);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          if (v.invertMedia === true)
            flags |= 8;
          if (v.forceLargeMedia === true)
            flags |= 16;
          if (v.forceSmallMedia === true)
            flags |= 32;
          if (v.manual === true)
            flags |= 128;
          if (v.safe === true)
            flags |= 256;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          w.string(h(v, "url"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
        },
        "botInlineResult": function(w, v) {
          w.uint(295067450);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 4;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 8;
          var _thumb = v.thumb !== void 0;
          if (_thumb)
            flags |= 16;
          var _content = v.content !== void 0;
          if (_content)
            flags |= 32;
          w.uint(flags);
          w.string(h(v, "id"));
          w.string(h(v, "type"));
          if (_title)
            w.string(v.title);
          if (_description)
            w.string(v.description);
          if (_url)
            w.string(v.url);
          if (_thumb)
            w.object(v.thumb);
          if (_content)
            w.object(v.content);
          w.object(h(v, "sendMessage"));
        },
        "botInlineMediaResult": function(w, v) {
          w.uint(400266251);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 1;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 2;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 4;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "id"));
          w.string(h(v, "type"));
          if (_photo)
            w.object(v.photo);
          if (_document)
            w.object(v.document);
          if (_title)
            w.string(v.title);
          if (_description)
            w.string(v.description);
          w.object(h(v, "sendMessage"));
        },
        "messages.botResults": function(w, v) {
          w.uint(3760321270);
          var flags = 0;
          if (v.gallery === true)
            flags |= 1;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 2;
          var _switchPm = v.switchPm !== void 0;
          if (_switchPm)
            flags |= 4;
          var _switchWebview = v.switchWebview !== void 0;
          if (_switchWebview)
            flags |= 8;
          w.uint(flags);
          w.long(h(v, "queryId"));
          if (_nextOffset)
            w.string(v.nextOffset);
          if (_switchPm)
            w.object(v.switchPm);
          if (_switchWebview)
            w.object(v.switchWebview);
          w.vector(w.object, h(v, "results"));
          w.int(h(v, "cacheTime"));
          w.vector(w.object, h(v, "users"));
        },
        "exportedMessageLink": function(w, v) {
          w.uint(1571494644);
          w.string(h(v, "link"));
          w.string(h(v, "html"));
        },
        "messageFwdHeader": function(w, v) {
          w.uint(1313731771);
          var flags = 0;
          var _fromId = v.fromId !== void 0;
          if (_fromId)
            flags |= 1;
          var _channelPost = v.channelPost !== void 0;
          if (_channelPost)
            flags |= 4;
          var _postAuthor = v.postAuthor !== void 0;
          if (_postAuthor)
            flags |= 8;
          var _savedFromPeer = v.savedFromPeer !== void 0;
          var _savedFromMsgId = v.savedFromMsgId !== void 0;
          var _flags_4 = _savedFromPeer || _savedFromMsgId;
          if (_flags_4)
            flags |= 16;
          var _fromName = v.fromName !== void 0;
          if (_fromName)
            flags |= 32;
          var _psaType = v.psaType !== void 0;
          if (_psaType)
            flags |= 64;
          if (v.imported === true)
            flags |= 128;
          var _savedFromId = v.savedFromId !== void 0;
          if (_savedFromId)
            flags |= 256;
          var _savedFromName = v.savedFromName !== void 0;
          if (_savedFromName)
            flags |= 512;
          var _savedDate = v.savedDate !== void 0;
          if (_savedDate)
            flags |= 1024;
          if (v.savedOut === true)
            flags |= 2048;
          w.uint(flags);
          if (_fromId)
            w.object(v.fromId);
          if (_fromName)
            w.string(v.fromName);
          w.int(h(v, "date"));
          if (_channelPost)
            w.int(v.channelPost);
          if (_postAuthor)
            w.string(v.postAuthor);
          if (_flags_4)
            w.object(v.savedFromPeer);
          if (_flags_4)
            w.int(v.savedFromMsgId);
          if (_savedFromId)
            w.object(v.savedFromId);
          if (_savedFromName)
            w.string(v.savedFromName);
          if (_savedDate)
            w.int(v.savedDate);
          if (_psaType)
            w.string(v.psaType);
        },
        "auth.codeTypeSms": function(w) {
          w.uint(1923290508);
        },
        "auth.codeTypeCall": function(w) {
          w.uint(1948046307);
        },
        "auth.codeTypeFlashCall": function(w) {
          w.uint(577556219);
        },
        "auth.codeTypeMissedCall": function(w) {
          w.uint(3592083182);
        },
        "auth.codeTypeFragmentSms": function(w) {
          w.uint(116234636);
        },
        "auth.sentCodeTypeApp": function(w, v) {
          w.uint(1035688326);
          w.int(h(v, "length"));
        },
        "auth.sentCodeTypeSms": function(w, v) {
          w.uint(3221273506);
          w.int(h(v, "length"));
        },
        "auth.sentCodeTypeCall": function(w, v) {
          w.uint(1398007207);
          w.int(h(v, "length"));
        },
        "auth.sentCodeTypeFlashCall": function(w, v) {
          w.uint(2869151449);
          w.string(h(v, "pattern"));
        },
        "auth.sentCodeTypeMissedCall": function(w, v) {
          w.uint(2181063812);
          w.string(h(v, "prefix"));
          w.int(h(v, "length"));
        },
        "auth.sentCodeTypeEmailCode": function(w, v) {
          w.uint(4098946459);
          var flags = 0;
          if (v.appleSigninAllowed === true)
            flags |= 1;
          if (v.googleSigninAllowed === true)
            flags |= 2;
          var _resetAvailablePeriod = v.resetAvailablePeriod !== void 0;
          if (_resetAvailablePeriod)
            flags |= 8;
          var _resetPendingDate = v.resetPendingDate !== void 0;
          if (_resetPendingDate)
            flags |= 16;
          w.uint(flags);
          w.string(h(v, "emailPattern"));
          w.int(h(v, "length"));
          if (_resetAvailablePeriod)
            w.int(v.resetAvailablePeriod);
          if (_resetPendingDate)
            w.int(v.resetPendingDate);
        },
        "auth.sentCodeTypeSetUpEmailRequired": function(w, v) {
          w.uint(2773032426);
          var flags = 0;
          if (v.appleSigninAllowed === true)
            flags |= 1;
          if (v.googleSigninAllowed === true)
            flags |= 2;
          w.uint(flags);
        },
        "auth.sentCodeTypeFragmentSms": function(w, v) {
          w.uint(3646315577);
          w.string(h(v, "url"));
          w.int(h(v, "length"));
        },
        "auth.sentCodeTypeFirebaseSms": function(w, v) {
          w.uint(10475318);
          var flags = 0;
          var _nonce = v.nonce !== void 0;
          if (_nonce)
            flags |= 1;
          var _receipt = v.receipt !== void 0;
          var _pushTimeout = v.pushTimeout !== void 0;
          var _flags_1 = _receipt || _pushTimeout;
          if (_flags_1)
            flags |= 2;
          var _playIntegrityProjectId = v.playIntegrityProjectId !== void 0;
          var _playIntegrityNonce = v.playIntegrityNonce !== void 0;
          var _flags_2 = _playIntegrityProjectId || _playIntegrityNonce;
          if (_flags_2)
            flags |= 4;
          w.uint(flags);
          if (_nonce)
            w.bytes(v.nonce);
          if (_flags_2)
            w.long(v.playIntegrityProjectId);
          if (_flags_2)
            w.bytes(v.playIntegrityNonce);
          if (_flags_1)
            w.string(v.receipt);
          if (_flags_1)
            w.int(v.pushTimeout);
          w.int(h(v, "length"));
        },
        "auth.sentCodeTypeSmsWord": function(w, v) {
          w.uint(2752949377);
          var flags = 0;
          var _beginning = v.beginning !== void 0;
          if (_beginning)
            flags |= 1;
          w.uint(flags);
          if (_beginning)
            w.string(v.beginning);
        },
        "auth.sentCodeTypeSmsPhrase": function(w, v) {
          w.uint(3010958511);
          var flags = 0;
          var _beginning = v.beginning !== void 0;
          if (_beginning)
            flags |= 1;
          w.uint(flags);
          if (_beginning)
            w.string(v.beginning);
        },
        "messages.botCallbackAnswer": function(w, v) {
          w.uint(911761060);
          var flags = 0;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 1;
          if (v.alert === true)
            flags |= 2;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 4;
          if (v.hasUrl === true)
            flags |= 8;
          if (v.nativeUi === true)
            flags |= 16;
          w.uint(flags);
          if (_message)
            w.string(v.message);
          if (_url)
            w.string(v.url);
          w.int(h(v, "cacheTime"));
        },
        "messages.messageEditData": function(w, v) {
          w.uint(649453030);
          var flags = 0;
          if (v.caption === true)
            flags |= 1;
          w.uint(flags);
        },
        "inputBotInlineMessageID": function(w, v) {
          w.uint(2299280777);
          w.int(h(v, "dcId"));
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputBotInlineMessageID64": function(w, v) {
          w.uint(3067680215);
          w.int(h(v, "dcId"));
          w.long(h(v, "ownerId"));
          w.int(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inlineBotSwitchPM": function(w, v) {
          w.uint(1008755359);
          w.string(h(v, "text"));
          w.string(h(v, "startParam"));
        },
        "messages.peerDialogs": function(w, v) {
          w.uint(863093588);
          w.vector(w.object, h(v, "dialogs"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          w.object(h(v, "state"));
        },
        "topPeer": function(w, v) {
          w.uint(3989684315);
          w.object(h(v, "peer"));
          w.double(h(v, "rating"));
        },
        "topPeerCategoryBotsPM": function(w) {
          w.uint(2875595611);
        },
        "topPeerCategoryBotsInline": function(w) {
          w.uint(344356834);
        },
        "topPeerCategoryCorrespondents": function(w) {
          w.uint(104314861);
        },
        "topPeerCategoryGroups": function(w) {
          w.uint(3172442442);
        },
        "topPeerCategoryChannels": function(w) {
          w.uint(371037736);
        },
        "topPeerCategoryPhoneCalls": function(w) {
          w.uint(511092620);
        },
        "topPeerCategoryForwardUsers": function(w) {
          w.uint(2822794409);
        },
        "topPeerCategoryForwardChats": function(w) {
          w.uint(4226728176);
        },
        "topPeerCategoryBotsApp": function(w) {
          w.uint(4255022060);
        },
        "topPeerCategoryPeers": function(w, v) {
          w.uint(4219683473);
          w.object(h(v, "category"));
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "peers"));
        },
        "contacts.topPeersNotModified": function(w) {
          w.uint(3727060725);
        },
        "contacts.topPeers": function(w, v) {
          w.uint(1891070632);
          w.vector(w.object, h(v, "categories"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "contacts.topPeersDisabled": function(w) {
          w.uint(3039597469);
        },
        "draftMessageEmpty": function(w, v) {
          w.uint(453805082);
          var flags = 0;
          var _date = v.date !== void 0;
          if (_date)
            flags |= 1;
          w.uint(flags);
          if (_date)
            w.int(v.date);
        },
        "draftMessage": function(w, v) {
          w.uint(761606687);
          var flags = 0;
          if (v.noWebpage === true)
            flags |= 2;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 8;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 16;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 32;
          if (v.invertMedia === true)
            flags |= 64;
          var _effect = v.effect !== void 0;
          if (_effect)
            flags |= 128;
          w.uint(flags);
          if (_replyTo)
            w.object(v.replyTo);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_media)
            w.object(v.media);
          w.int(h(v, "date"));
          if (_effect)
            w.long(v.effect);
        },
        "messages.featuredStickersNotModified": function(w, v) {
          w.uint(3336309862);
          w.int(h(v, "count"));
        },
        "messages.featuredStickers": function(w, v) {
          w.uint(3191351558);
          var flags = 0;
          if (v.premium === true)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "hash"));
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "sets"));
          w.vector(w.long, h(v, "unread"));
        },
        "messages.recentStickersNotModified": function(w) {
          w.uint(186120336);
        },
        "messages.recentStickers": function(w, v) {
          w.uint(2295561302);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "packs"));
          w.vector(w.object, h(v, "stickers"));
          w.vector(w.int, h(v, "dates"));
        },
        "messages.archivedStickers": function(w, v) {
          w.uint(1338747336);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "sets"));
        },
        "messages.stickerSetInstallResultSuccess": function(w) {
          w.uint(946083368);
        },
        "messages.stickerSetInstallResultArchive": function(w, v) {
          w.uint(904138920);
          w.vector(w.object, h(v, "sets"));
        },
        "stickerSetCovered": function(w, v) {
          w.uint(1678812626);
          w.object(h(v, "set"));
          w.object(h(v, "cover"));
        },
        "stickerSetMultiCovered": function(w, v) {
          w.uint(872932635);
          w.object(h(v, "set"));
          w.vector(w.object, h(v, "covers"));
        },
        "stickerSetFullCovered": function(w, v) {
          w.uint(1087454222);
          w.object(h(v, "set"));
          w.vector(w.object, h(v, "packs"));
          w.vector(w.object, h(v, "keywords"));
          w.vector(w.object, h(v, "documents"));
        },
        "stickerSetNoCovered": function(w, v) {
          w.uint(2008112412);
          w.object(h(v, "set"));
        },
        "maskCoords": function(w, v) {
          w.uint(2933316530);
          w.int(h(v, "n"));
          w.double(h(v, "x"));
          w.double(h(v, "y"));
          w.double(h(v, "zoom"));
        },
        "inputStickeredMediaPhoto": function(w, v) {
          w.uint(1251549527);
          w.object(h(v, "id"));
        },
        "inputStickeredMediaDocument": function(w, v) {
          w.uint(70813275);
          w.object(h(v, "id"));
        },
        "game": function(w, v) {
          w.uint(3187238203);
          var flags = 0;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.string(h(v, "shortName"));
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          w.object(h(v, "photo"));
          if (_document)
            w.object(v.document);
        },
        "inputGameID": function(w, v) {
          w.uint(53231223);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputGameShortName": function(w, v) {
          w.uint(3274827786);
          w.object(h(v, "botId"));
          w.string(h(v, "shortName"));
        },
        "highScore": function(w, v) {
          w.uint(1940093419);
          w.int(h(v, "pos"));
          w.int53(h(v, "userId"));
          w.int(h(v, "score"));
        },
        "messages.highScores": function(w, v) {
          w.uint(2587622809);
          w.vector(w.object, h(v, "scores"));
          w.vector(w.object, h(v, "users"));
        },
        "textEmpty": function(w) {
          w.uint(3695018575);
        },
        "textPlain": function(w, v) {
          w.uint(1950782688);
          w.string(h(v, "text"));
        },
        "textBold": function(w, v) {
          w.uint(1730456516);
          w.object(h(v, "text"));
        },
        "textItalic": function(w, v) {
          w.uint(3641877916);
          w.object(h(v, "text"));
        },
        "textUnderline": function(w, v) {
          w.uint(3240501956);
          w.object(h(v, "text"));
        },
        "textStrike": function(w, v) {
          w.uint(2616769429);
          w.object(h(v, "text"));
        },
        "textFixed": function(w, v) {
          w.uint(1816074681);
          w.object(h(v, "text"));
        },
        "textUrl": function(w, v) {
          w.uint(1009288385);
          w.object(h(v, "text"));
          w.string(h(v, "url"));
          w.long(h(v, "webpageId"));
        },
        "textEmail": function(w, v) {
          w.uint(3730443734);
          w.object(h(v, "text"));
          w.string(h(v, "email"));
        },
        "textConcat": function(w, v) {
          w.uint(2120376535);
          w.vector(w.object, h(v, "texts"));
        },
        "textSubscript": function(w, v) {
          w.uint(3983181060);
          w.object(h(v, "text"));
        },
        "textSuperscript": function(w, v) {
          w.uint(3355139585);
          w.object(h(v, "text"));
        },
        "textMarked": function(w, v) {
          w.uint(55281185);
          w.object(h(v, "text"));
        },
        "textPhone": function(w, v) {
          w.uint(483104362);
          w.object(h(v, "text"));
          w.string(h(v, "phone"));
        },
        "textImage": function(w, v) {
          w.uint(136105807);
          w.long(h(v, "documentId"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
        },
        "textAnchor": function(w, v) {
          w.uint(894777186);
          w.object(h(v, "text"));
          w.string(h(v, "name"));
        },
        "pageBlockUnsupported": function(w) {
          w.uint(324435594);
        },
        "pageBlockTitle": function(w, v) {
          w.uint(1890305021);
          w.object(h(v, "text"));
        },
        "pageBlockSubtitle": function(w, v) {
          w.uint(2415565343);
          w.object(h(v, "text"));
        },
        "pageBlockAuthorDate": function(w, v) {
          w.uint(3132089824);
          w.object(h(v, "author"));
          w.int(h(v, "publishedDate"));
        },
        "pageBlockHeader": function(w, v) {
          w.uint(3218105580);
          w.object(h(v, "text"));
        },
        "pageBlockSubheader": function(w, v) {
          w.uint(4046173921);
          w.object(h(v, "text"));
        },
        "pageBlockParagraph": function(w, v) {
          w.uint(1182402406);
          w.object(h(v, "text"));
        },
        "pageBlockPreformatted": function(w, v) {
          w.uint(3228621118);
          w.object(h(v, "text"));
          w.string(h(v, "language"));
        },
        "pageBlockFooter": function(w, v) {
          w.uint(1216809369);
          w.object(h(v, "text"));
        },
        "pageBlockDivider": function(w) {
          w.uint(3676352904);
        },
        "pageBlockAnchor": function(w, v) {
          w.uint(3456972720);
          w.string(h(v, "name"));
        },
        "pageBlockList": function(w, v) {
          w.uint(3840442385);
          w.vector(w.object, h(v, "items"));
        },
        "pageBlockBlockquote": function(w, v) {
          w.uint(641563686);
          w.object(h(v, "text"));
          w.object(h(v, "caption"));
        },
        "pageBlockPullquote": function(w, v) {
          w.uint(1329878739);
          w.object(h(v, "text"));
          w.object(h(v, "caption"));
        },
        "pageBlockPhoto": function(w, v) {
          w.uint(391759200);
          var flags = 0;
          var _url = v.url !== void 0;
          var _webpageId = v.webpageId !== void 0;
          var _flags_0 = _url || _webpageId;
          if (_flags_0)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "photoId"));
          w.object(h(v, "caption"));
          if (_flags_0)
            w.string(v.url);
          if (_flags_0)
            w.long(v.webpageId);
        },
        "pageBlockVideo": function(w, v) {
          w.uint(2089805750);
          var flags = 0;
          if (v.autoplay === true)
            flags |= 1;
          if (v.loop === true)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "videoId"));
          w.object(h(v, "caption"));
        },
        "pageBlockCover": function(w, v) {
          w.uint(972174080);
          w.object(h(v, "cover"));
        },
        "pageBlockEmbed": function(w, v) {
          w.uint(2826014149);
          var flags = 0;
          if (v.fullWidth === true)
            flags |= 1;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 2;
          var _html = v.html !== void 0;
          if (_html)
            flags |= 4;
          if (v.allowScrolling === true)
            flags |= 8;
          var _posterPhotoId = v.posterPhotoId !== void 0;
          if (_posterPhotoId)
            flags |= 16;
          var _w = v.w !== void 0;
          var _h = v.h !== void 0;
          var _flags_5 = _w || _h;
          if (_flags_5)
            flags |= 32;
          w.uint(flags);
          if (_url)
            w.string(v.url);
          if (_html)
            w.string(v.html);
          if (_posterPhotoId)
            w.long(v.posterPhotoId);
          if (_flags_5)
            w.int(v.w);
          if (_flags_5)
            w.int(v.h);
          w.object(h(v, "caption"));
        },
        "pageBlockEmbedPost": function(w, v) {
          w.uint(4065961995);
          w.string(h(v, "url"));
          w.long(h(v, "webpageId"));
          w.long(h(v, "authorPhotoId"));
          w.string(h(v, "author"));
          w.int(h(v, "date"));
          w.vector(w.object, h(v, "blocks"));
          w.object(h(v, "caption"));
        },
        "pageBlockCollage": function(w, v) {
          w.uint(1705048653);
          w.vector(w.object, h(v, "items"));
          w.object(h(v, "caption"));
        },
        "pageBlockSlideshow": function(w, v) {
          w.uint(52401552);
          w.vector(w.object, h(v, "items"));
          w.object(h(v, "caption"));
        },
        "pageBlockChannel": function(w, v) {
          w.uint(4011282869);
          w.object(h(v, "channel"));
        },
        "pageBlockAudio": function(w, v) {
          w.uint(2151899626);
          w.long(h(v, "audioId"));
          w.object(h(v, "caption"));
        },
        "pageBlockKicker": function(w, v) {
          w.uint(504660880);
          w.object(h(v, "text"));
        },
        "pageBlockTable": function(w, v) {
          w.uint(3209554562);
          var flags = 0;
          if (v.bordered === true)
            flags |= 1;
          if (v.striped === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "title"));
          w.vector(w.object, h(v, "rows"));
        },
        "pageBlockOrderedList": function(w, v) {
          w.uint(2592793057);
          w.vector(w.object, h(v, "items"));
        },
        "pageBlockDetails": function(w, v) {
          w.uint(1987480557);
          var flags = 0;
          if (v.open === true)
            flags |= 1;
          w.uint(flags);
          w.vector(w.object, h(v, "blocks"));
          w.object(h(v, "title"));
        },
        "pageBlockRelatedArticles": function(w, v) {
          w.uint(370236054);
          w.object(h(v, "title"));
          w.vector(w.object, h(v, "articles"));
        },
        "pageBlockMap": function(w, v) {
          w.uint(2756656886);
          w.object(h(v, "geo"));
          w.int(h(v, "zoom"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
          w.object(h(v, "caption"));
        },
        "phoneCallDiscardReasonMissed": function(w) {
          w.uint(2246320897);
        },
        "phoneCallDiscardReasonDisconnect": function(w) {
          w.uint(3767910816);
        },
        "phoneCallDiscardReasonHangup": function(w) {
          w.uint(1471006352);
        },
        "phoneCallDiscardReasonBusy": function(w) {
          w.uint(4210550985);
        },
        "dataJSON": function(w, v) {
          w.uint(2104790276);
          w.string(h(v, "data"));
        },
        "labeledPrice": function(w, v) {
          w.uint(3408489464);
          w.string(h(v, "label"));
          w.long(h(v, "amount"));
        },
        "invoice": function(w, v) {
          w.uint(1572428309);
          var flags = 0;
          if (v.test === true)
            flags |= 1;
          if (v.nameRequested === true)
            flags |= 2;
          if (v.phoneRequested === true)
            flags |= 4;
          if (v.emailRequested === true)
            flags |= 8;
          if (v.shippingAddressRequested === true)
            flags |= 16;
          if (v.flexible === true)
            flags |= 32;
          if (v.phoneToProvider === true)
            flags |= 64;
          if (v.emailToProvider === true)
            flags |= 128;
          var _maxTipAmount = v.maxTipAmount !== void 0;
          var _suggestedTipAmounts = v.suggestedTipAmounts && v.suggestedTipAmounts.length;
          var _flags_8 = _maxTipAmount || _suggestedTipAmounts;
          if (_flags_8)
            flags |= 256;
          if (v.recurring === true)
            flags |= 512;
          var _termsUrl = v.termsUrl !== void 0;
          if (_termsUrl)
            flags |= 1024;
          w.uint(flags);
          w.string(h(v, "currency"));
          w.vector(w.object, h(v, "prices"));
          if (_flags_8)
            w.long(v.maxTipAmount);
          if (_flags_8)
            w.vector(w.long, v.suggestedTipAmounts);
          if (_termsUrl)
            w.string(v.termsUrl);
        },
        "paymentCharge": function(w, v) {
          w.uint(3926049406);
          w.string(h(v, "id"));
          w.string(h(v, "providerChargeId"));
        },
        "postAddress": function(w, v) {
          w.uint(512535275);
          w.string(h(v, "streetLine1"));
          w.string(h(v, "streetLine2"));
          w.string(h(v, "city"));
          w.string(h(v, "state"));
          w.string(h(v, "countryIso2"));
          w.string(h(v, "postCode"));
        },
        "paymentRequestedInfo": function(w, v) {
          w.uint(2426158996);
          var flags = 0;
          var _name = v.name !== void 0;
          if (_name)
            flags |= 1;
          var _phone = v.phone !== void 0;
          if (_phone)
            flags |= 2;
          var _email = v.email !== void 0;
          if (_email)
            flags |= 4;
          var _shippingAddress = v.shippingAddress !== void 0;
          if (_shippingAddress)
            flags |= 8;
          w.uint(flags);
          if (_name)
            w.string(v.name);
          if (_phone)
            w.string(v.phone);
          if (_email)
            w.string(v.email);
          if (_shippingAddress)
            w.object(v.shippingAddress);
        },
        "paymentSavedCredentialsCard": function(w, v) {
          w.uint(3452074527);
          w.string(h(v, "id"));
          w.string(h(v, "title"));
        },
        "webDocument": function(w, v) {
          w.uint(475467473);
          w.string(h(v, "url"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "size"));
          w.string(h(v, "mimeType"));
          w.vector(w.object, h(v, "attributes"));
        },
        "webDocumentNoProxy": function(w, v) {
          w.uint(4190682310);
          w.string(h(v, "url"));
          w.int(h(v, "size"));
          w.string(h(v, "mimeType"));
          w.vector(w.object, h(v, "attributes"));
        },
        "inputWebDocument": function(w, v) {
          w.uint(2616017741);
          w.string(h(v, "url"));
          w.int(h(v, "size"));
          w.string(h(v, "mimeType"));
          w.vector(w.object, h(v, "attributes"));
        },
        "inputWebFileLocation": function(w, v) {
          w.uint(3258570374);
          w.string(h(v, "url"));
          w.long(h(v, "accessHash"));
        },
        "inputWebFileGeoPointLocation": function(w, v) {
          w.uint(2669814217);
          w.object(h(v, "geoPoint"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
          w.int(h(v, "zoom"));
          w.int(h(v, "scale"));
        },
        "inputWebFileAudioAlbumThumbLocation": function(w, v) {
          w.uint(4100974884);
          var flags = 0;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 1;
          var _title = v.title !== void 0;
          var _performer = v.performer !== void 0;
          var _flags_1 = _title || _performer;
          if (_flags_1)
            flags |= 2;
          if (v.small === true)
            flags |= 4;
          w.uint(flags);
          if (_document)
            w.object(v.document);
          if (_flags_1)
            w.string(v.title);
          if (_flags_1)
            w.string(v.performer);
        },
        "upload.webFile": function(w, v) {
          w.uint(568808380);
          w.int(h(v, "size"));
          w.string(h(v, "mimeType"));
          w.object(h(v, "fileType"));
          w.int(h(v, "mtime"));
          w.bytes(h(v, "bytes"));
        },
        "payments.paymentForm": function(w, v) {
          w.uint(2684716881);
          var flags = 0;
          var _savedInfo = v.savedInfo !== void 0;
          if (_savedInfo)
            flags |= 1;
          var _savedCredentials = v.savedCredentials && v.savedCredentials.length;
          if (_savedCredentials)
            flags |= 2;
          if (v.canSaveCredentials === true)
            flags |= 4;
          if (v.passwordMissing === true)
            flags |= 8;
          var _nativeProvider = v.nativeProvider !== void 0;
          var _nativeParams = v.nativeParams !== void 0;
          var _flags_4 = _nativeProvider || _nativeParams;
          if (_flags_4)
            flags |= 16;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 32;
          var _additionalMethods = v.additionalMethods && v.additionalMethods.length;
          if (_additionalMethods)
            flags |= 64;
          w.uint(flags);
          w.long(h(v, "formId"));
          w.int53(h(v, "botId"));
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          w.object(h(v, "invoice"));
          w.long(h(v, "providerId"));
          w.string(h(v, "url"));
          if (_flags_4)
            w.string(v.nativeProvider);
          if (_flags_4)
            w.object(v.nativeParams);
          if (_additionalMethods)
            w.vector(w.object, v.additionalMethods);
          if (_savedInfo)
            w.object(v.savedInfo);
          if (_savedCredentials)
            w.vector(w.object, v.savedCredentials);
          w.vector(w.object, h(v, "users"));
        },
        "payments.paymentFormStars": function(w, v) {
          w.uint(2079764828);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 32;
          w.uint(flags);
          w.long(h(v, "formId"));
          w.int53(h(v, "botId"));
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          w.object(h(v, "invoice"));
          w.vector(w.object, h(v, "users"));
        },
        "payments.paymentFormStarGift": function(w, v) {
          w.uint(3022376929);
          w.long(h(v, "formId"));
          w.object(h(v, "invoice"));
        },
        "payments.validatedRequestedInfo": function(w, v) {
          w.uint(3510966403);
          var flags = 0;
          var _id = v.id !== void 0;
          if (_id)
            flags |= 1;
          var _shippingOptions = v.shippingOptions && v.shippingOptions.length;
          if (_shippingOptions)
            flags |= 2;
          w.uint(flags);
          if (_id)
            w.string(v.id);
          if (_shippingOptions)
            w.vector(w.object, v.shippingOptions);
        },
        "payments.paymentResult": function(w, v) {
          w.uint(1314881805);
          w.object(h(v, "updates"));
        },
        "payments.paymentVerificationNeeded": function(w, v) {
          w.uint(3628142905);
          w.string(h(v, "url"));
        },
        "payments.paymentReceipt": function(w, v) {
          w.uint(1891958275);
          var flags = 0;
          var _info = v.info !== void 0;
          if (_info)
            flags |= 1;
          var _shipping = v.shipping !== void 0;
          if (_shipping)
            flags |= 2;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 4;
          var _tipAmount = v.tipAmount !== void 0;
          if (_tipAmount)
            flags |= 8;
          w.uint(flags);
          w.int(h(v, "date"));
          w.int53(h(v, "botId"));
          w.long(h(v, "providerId"));
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          w.object(h(v, "invoice"));
          if (_info)
            w.object(v.info);
          if (_shipping)
            w.object(v.shipping);
          if (_tipAmount)
            w.long(v.tipAmount);
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
          w.string(h(v, "credentialsTitle"));
          w.vector(w.object, h(v, "users"));
        },
        "payments.paymentReceiptStars": function(w, v) {
          w.uint(3669751866);
          var flags = 0;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 4;
          w.uint(flags);
          w.int(h(v, "date"));
          w.int53(h(v, "botId"));
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_photo)
            w.object(v.photo);
          w.object(h(v, "invoice"));
          w.string(h(v, "currency"));
          w.long(h(v, "totalAmount"));
          w.string(h(v, "transactionId"));
          w.vector(w.object, h(v, "users"));
        },
        "payments.savedInfo": function(w, v) {
          w.uint(4220511292);
          var flags = 0;
          var _savedInfo = v.savedInfo !== void 0;
          if (_savedInfo)
            flags |= 1;
          if (v.hasSavedCredentials === true)
            flags |= 2;
          w.uint(flags);
          if (_savedInfo)
            w.object(v.savedInfo);
        },
        "inputPaymentCredentialsSaved": function(w, v) {
          w.uint(3238965967);
          w.string(h(v, "id"));
          w.bytes(h(v, "tmpPassword"));
        },
        "inputPaymentCredentials": function(w, v) {
          w.uint(873977640);
          var flags = 0;
          if (v.save === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "data"));
        },
        "inputPaymentCredentialsApplePay": function(w, v) {
          w.uint(178373535);
          w.object(h(v, "paymentData"));
        },
        "inputPaymentCredentialsGooglePay": function(w, v) {
          w.uint(2328045569);
          w.object(h(v, "paymentToken"));
        },
        "account.tmpPassword": function(w, v) {
          w.uint(3680828724);
          w.bytes(h(v, "tmpPassword"));
          w.int(h(v, "validUntil"));
        },
        "shippingOption": function(w, v) {
          w.uint(3055631583);
          w.string(h(v, "id"));
          w.string(h(v, "title"));
          w.vector(w.object, h(v, "prices"));
        },
        "inputStickerSetItem": function(w, v) {
          w.uint(853188252);
          var flags = 0;
          var _maskCoords = v.maskCoords !== void 0;
          if (_maskCoords)
            flags |= 1;
          var _keywords = v.keywords !== void 0;
          if (_keywords)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "document"));
          w.string(h(v, "emoji"));
          if (_maskCoords)
            w.object(v.maskCoords);
          if (_keywords)
            w.string(v.keywords);
        },
        "inputPhoneCall": function(w, v) {
          w.uint(506920429);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "phoneCallEmpty": function(w, v) {
          w.uint(1399245077);
          w.long(h(v, "id"));
        },
        "phoneCallWaiting": function(w, v) {
          w.uint(3307368215);
          var flags = 0;
          var _receiveDate = v.receiveDate !== void 0;
          if (_receiveDate)
            flags |= 1;
          if (v.video === true)
            flags |= 64;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "date"));
          w.int53(h(v, "adminId"));
          w.int53(h(v, "participantId"));
          w.object(h(v, "protocol"));
          if (_receiveDate)
            w.int(v.receiveDate);
        },
        "phoneCallRequested": function(w, v) {
          w.uint(347139340);
          var flags = 0;
          if (v.video === true)
            flags |= 64;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "date"));
          w.int53(h(v, "adminId"));
          w.int53(h(v, "participantId"));
          w.bytes(h(v, "gAHash"));
          w.object(h(v, "protocol"));
        },
        "phoneCallAccepted": function(w, v) {
          w.uint(912311057);
          var flags = 0;
          if (v.video === true)
            flags |= 64;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "date"));
          w.int53(h(v, "adminId"));
          w.int53(h(v, "participantId"));
          w.bytes(h(v, "gB"));
          w.object(h(v, "protocol"));
        },
        "phoneCall": function(w, v) {
          w.uint(810769141);
          var flags = 0;
          if (v.p2pAllowed === true)
            flags |= 32;
          if (v.video === true)
            flags |= 64;
          var _customParameters = v.customParameters !== void 0;
          if (_customParameters)
            flags |= 128;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "date"));
          w.int53(h(v, "adminId"));
          w.int53(h(v, "participantId"));
          w.bytes(h(v, "gAOrB"));
          w.long(h(v, "keyFingerprint"));
          w.object(h(v, "protocol"));
          w.vector(w.object, h(v, "connections"));
          w.int(h(v, "startDate"));
          if (_customParameters)
            w.object(v.customParameters);
        },
        "phoneCallDiscarded": function(w, v) {
          w.uint(1355435489);
          var flags = 0;
          var _reason = v.reason !== void 0;
          if (_reason)
            flags |= 1;
          var _duration = v.duration !== void 0;
          if (_duration)
            flags |= 2;
          if (v.needRating === true)
            flags |= 4;
          if (v.needDebug === true)
            flags |= 8;
          if (v.video === true)
            flags |= 64;
          w.uint(flags);
          w.long(h(v, "id"));
          if (_reason)
            w.object(v.reason);
          if (_duration)
            w.int(v.duration);
        },
        "phoneConnection": function(w, v) {
          w.uint(2629903303);
          var flags = 0;
          if (v.tcp === true)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "id"));
          w.string(h(v, "ip"));
          w.string(h(v, "ipv6"));
          w.int(h(v, "port"));
          w.bytes(h(v, "peerTag"));
        },
        "phoneConnectionWebrtc": function(w, v) {
          w.uint(1667228533);
          var flags = 0;
          if (v.turn === true)
            flags |= 1;
          if (v.stun === true)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "id"));
          w.string(h(v, "ip"));
          w.string(h(v, "ipv6"));
          w.int(h(v, "port"));
          w.string(h(v, "username"));
          w.string(h(v, "password"));
        },
        "phoneCallProtocol": function(w, v) {
          w.uint(4236742600);
          var flags = 0;
          if (v.udpP2p === true)
            flags |= 1;
          if (v.udpReflector === true)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "minLayer"));
          w.int(h(v, "maxLayer"));
          w.vector(w.string, h(v, "libraryVersions"));
        },
        "phone.phoneCall": function(w, v) {
          w.uint(3968000320);
          w.object(h(v, "phoneCall"));
          w.vector(w.object, h(v, "users"));
        },
        "upload.cdnFileReuploadNeeded": function(w, v) {
          w.uint(4004045934);
          w.bytes(h(v, "requestToken"));
        },
        "upload.cdnFile": function(w, v) {
          w.uint(2845821519);
          w.bytes(h(v, "bytes"));
        },
        "cdnPublicKey": function(w, v) {
          w.uint(3380800186);
          w.int(h(v, "dcId"));
          w.string(h(v, "publicKey"));
        },
        "cdnConfig": function(w, v) {
          w.uint(1462101002);
          w.vector(w.object, h(v, "publicKeys"));
        },
        "langPackString": function(w, v) {
          w.uint(3402727926);
          w.string(h(v, "key"));
          w.string(h(v, "value"));
        },
        "langPackStringPluralized": function(w, v) {
          w.uint(1816636575);
          var flags = 0;
          var _zeroValue = v.zeroValue !== void 0;
          if (_zeroValue)
            flags |= 1;
          var _oneValue = v.oneValue !== void 0;
          if (_oneValue)
            flags |= 2;
          var _twoValue = v.twoValue !== void 0;
          if (_twoValue)
            flags |= 4;
          var _fewValue = v.fewValue !== void 0;
          if (_fewValue)
            flags |= 8;
          var _manyValue = v.manyValue !== void 0;
          if (_manyValue)
            flags |= 16;
          w.uint(flags);
          w.string(h(v, "key"));
          if (_zeroValue)
            w.string(v.zeroValue);
          if (_oneValue)
            w.string(v.oneValue);
          if (_twoValue)
            w.string(v.twoValue);
          if (_fewValue)
            w.string(v.fewValue);
          if (_manyValue)
            w.string(v.manyValue);
          w.string(h(v, "otherValue"));
        },
        "langPackStringDeleted": function(w, v) {
          w.uint(695856818);
          w.string(h(v, "key"));
        },
        "langPackDifference": function(w, v) {
          w.uint(4085629430);
          w.string(h(v, "langCode"));
          w.int(h(v, "fromVersion"));
          w.int(h(v, "version"));
          w.vector(w.object, h(v, "strings"));
        },
        "langPackLanguage": function(w, v) {
          w.uint(4006239459);
          var flags = 0;
          if (v.official === true)
            flags |= 1;
          var _baseLangCode = v.baseLangCode !== void 0;
          if (_baseLangCode)
            flags |= 2;
          if (v.rtl === true)
            flags |= 4;
          if (v.beta === true)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "name"));
          w.string(h(v, "nativeName"));
          w.string(h(v, "langCode"));
          if (_baseLangCode)
            w.string(v.baseLangCode);
          w.string(h(v, "pluralCode"));
          w.int(h(v, "stringsCount"));
          w.int(h(v, "translatedCount"));
          w.string(h(v, "translationsUrl"));
        },
        "channelAdminLogEventActionChangeTitle": function(w, v) {
          w.uint(3873421349);
          w.string(h(v, "prevValue"));
          w.string(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeAbout": function(w, v) {
          w.uint(1427671598);
          w.string(h(v, "prevValue"));
          w.string(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeUsername": function(w, v) {
          w.uint(1783299128);
          w.string(h(v, "prevValue"));
          w.string(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangePhoto": function(w, v) {
          w.uint(1129042607);
          w.object(h(v, "prevPhoto"));
          w.object(h(v, "newPhoto"));
        },
        "channelAdminLogEventActionToggleInvites": function(w, v) {
          w.uint(460916654);
          w.boolean(h(v, "newValue"));
        },
        "channelAdminLogEventActionToggleSignatures": function(w, v) {
          w.uint(648939889);
          w.boolean(h(v, "newValue"));
        },
        "channelAdminLogEventActionUpdatePinned": function(w, v) {
          w.uint(3924306968);
          w.object(h(v, "message"));
        },
        "channelAdminLogEventActionEditMessage": function(w, v) {
          w.uint(1889215493);
          w.object(h(v, "prevMessage"));
          w.object(h(v, "newMessage"));
        },
        "channelAdminLogEventActionDeleteMessage": function(w, v) {
          w.uint(1121994683);
          w.object(h(v, "message"));
        },
        "channelAdminLogEventActionParticipantJoin": function(w) {
          w.uint(405815507);
        },
        "channelAdminLogEventActionParticipantLeave": function(w) {
          w.uint(4170676210);
        },
        "channelAdminLogEventActionParticipantInvite": function(w, v) {
          w.uint(3810276568);
          w.object(h(v, "participant"));
        },
        "channelAdminLogEventActionParticipantToggleBan": function(w, v) {
          w.uint(3872931198);
          w.object(h(v, "prevParticipant"));
          w.object(h(v, "newParticipant"));
        },
        "channelAdminLogEventActionParticipantToggleAdmin": function(w, v) {
          w.uint(3580323600);
          w.object(h(v, "prevParticipant"));
          w.object(h(v, "newParticipant"));
        },
        "channelAdminLogEventActionChangeStickerSet": function(w, v) {
          w.uint(2982398631);
          w.object(h(v, "prevStickerset"));
          w.object(h(v, "newStickerset"));
        },
        "channelAdminLogEventActionTogglePreHistoryHidden": function(w, v) {
          w.uint(1599903217);
          w.boolean(h(v, "newValue"));
        },
        "channelAdminLogEventActionDefaultBannedRights": function(w, v) {
          w.uint(771095562);
          w.object(h(v, "prevBannedRights"));
          w.object(h(v, "newBannedRights"));
        },
        "channelAdminLogEventActionStopPoll": function(w, v) {
          w.uint(2399639107);
          w.object(h(v, "message"));
        },
        "channelAdminLogEventActionChangeLinkedChat": function(w, v) {
          w.uint(84703944);
          w.int53(h(v, "prevValue"));
          w.int53(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeLocation": function(w, v) {
          w.uint(241923758);
          w.object(h(v, "prevValue"));
          w.object(h(v, "newValue"));
        },
        "channelAdminLogEventActionToggleSlowMode": function(w, v) {
          w.uint(1401984889);
          w.int(h(v, "prevValue"));
          w.int(h(v, "newValue"));
        },
        "channelAdminLogEventActionStartGroupCall": function(w, v) {
          w.uint(589338437);
          w.object(h(v, "call"));
        },
        "channelAdminLogEventActionDiscardGroupCall": function(w, v) {
          w.uint(3684667712);
          w.object(h(v, "call"));
        },
        "channelAdminLogEventActionParticipantMute": function(w, v) {
          w.uint(4179895506);
          w.object(h(v, "participant"));
        },
        "channelAdminLogEventActionParticipantUnmute": function(w, v) {
          w.uint(3863226816);
          w.object(h(v, "participant"));
        },
        "channelAdminLogEventActionToggleGroupCallSetting": function(w, v) {
          w.uint(1456906823);
          w.boolean(h(v, "joinMuted"));
        },
        "channelAdminLogEventActionParticipantJoinByInvite": function(w, v) {
          w.uint(4271882584);
          var flags = 0;
          if (v.viaChatlist === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "invite"));
        },
        "channelAdminLogEventActionExportedInviteDelete": function(w, v) {
          w.uint(1515256996);
          w.object(h(v, "invite"));
        },
        "channelAdminLogEventActionExportedInviteRevoke": function(w, v) {
          w.uint(1091179342);
          w.object(h(v, "invite"));
        },
        "channelAdminLogEventActionExportedInviteEdit": function(w, v) {
          w.uint(3910056793);
          w.object(h(v, "prevInvite"));
          w.object(h(v, "newInvite"));
        },
        "channelAdminLogEventActionParticipantVolume": function(w, v) {
          w.uint(1048537159);
          w.object(h(v, "participant"));
        },
        "channelAdminLogEventActionChangeHistoryTTL": function(w, v) {
          w.uint(1855199800);
          w.int(h(v, "prevValue"));
          w.int(h(v, "newValue"));
        },
        "channelAdminLogEventActionParticipantJoinByRequest": function(w, v) {
          w.uint(2947945546);
          w.object(h(v, "invite"));
          w.int53(h(v, "approvedBy"));
        },
        "channelAdminLogEventActionToggleNoForwards": function(w, v) {
          w.uint(3408578406);
          w.boolean(h(v, "newValue"));
        },
        "channelAdminLogEventActionSendMessage": function(w, v) {
          w.uint(663693416);
          w.object(h(v, "message"));
        },
        "channelAdminLogEventActionChangeAvailableReactions": function(w, v) {
          w.uint(3192786680);
          w.object(h(v, "prevValue"));
          w.object(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeUsernames": function(w, v) {
          w.uint(4031755177);
          w.vector(w.string, h(v, "prevValue"));
          w.vector(w.string, h(v, "newValue"));
        },
        "channelAdminLogEventActionToggleForum": function(w, v) {
          w.uint(46949251);
          w.boolean(h(v, "newValue"));
        },
        "channelAdminLogEventActionCreateTopic": function(w, v) {
          w.uint(1483767080);
          w.object(h(v, "topic"));
        },
        "channelAdminLogEventActionEditTopic": function(w, v) {
          w.uint(4033864200);
          w.object(h(v, "prevTopic"));
          w.object(h(v, "newTopic"));
        },
        "channelAdminLogEventActionDeleteTopic": function(w, v) {
          w.uint(2920712457);
          w.object(h(v, "topic"));
        },
        "channelAdminLogEventActionPinTopic": function(w, v) {
          w.uint(1569535291);
          var flags = 0;
          var _prevTopic = v.prevTopic !== void 0;
          if (_prevTopic)
            flags |= 1;
          var _newTopic = v.newTopic !== void 0;
          if (_newTopic)
            flags |= 2;
          w.uint(flags);
          if (_prevTopic)
            w.object(v.prevTopic);
          if (_newTopic)
            w.object(v.newTopic);
        },
        "channelAdminLogEventActionToggleAntiSpam": function(w, v) {
          w.uint(1693675004);
          w.boolean(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangePeerColor": function(w, v) {
          w.uint(1469507456);
          w.object(h(v, "prevValue"));
          w.object(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeProfilePeerColor": function(w, v) {
          w.uint(1581742885);
          w.object(h(v, "prevValue"));
          w.object(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeWallpaper": function(w, v) {
          w.uint(834362706);
          w.object(h(v, "prevValue"));
          w.object(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeEmojiStatus": function(w, v) {
          w.uint(1051328177);
          w.object(h(v, "prevValue"));
          w.object(h(v, "newValue"));
        },
        "channelAdminLogEventActionChangeEmojiStickerSet": function(w, v) {
          w.uint(1188577451);
          w.object(h(v, "prevStickerset"));
          w.object(h(v, "newStickerset"));
        },
        "channelAdminLogEventActionToggleSignatureProfiles": function(w, v) {
          w.uint(1621597305);
          w.boolean(h(v, "newValue"));
        },
        "channelAdminLogEventActionParticipantSubExtend": function(w, v) {
          w.uint(1684286899);
          w.object(h(v, "prevParticipant"));
          w.object(h(v, "newParticipant"));
        },
        "channelAdminLogEvent": function(w, v) {
          w.uint(531458253);
          w.long(h(v, "id"));
          w.int(h(v, "date"));
          w.int53(h(v, "userId"));
          w.object(h(v, "action"));
        },
        "channels.adminLogResults": function(w, v) {
          w.uint(3985307469);
          w.vector(w.object, h(v, "events"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "channelAdminLogEventsFilter": function(w, v) {
          w.uint(3926948580);
          var flags = 0;
          if (v.join === true)
            flags |= 1;
          if (v.leave === true)
            flags |= 2;
          if (v.invite === true)
            flags |= 4;
          if (v.ban === true)
            flags |= 8;
          if (v.unban === true)
            flags |= 16;
          if (v.kick === true)
            flags |= 32;
          if (v.unkick === true)
            flags |= 64;
          if (v.promote === true)
            flags |= 128;
          if (v.demote === true)
            flags |= 256;
          if (v.info === true)
            flags |= 512;
          if (v.settings === true)
            flags |= 1024;
          if (v.pinned === true)
            flags |= 2048;
          if (v.edit === true)
            flags |= 4096;
          if (v.delete === true)
            flags |= 8192;
          if (v.groupCall === true)
            flags |= 16384;
          if (v.invites === true)
            flags |= 32768;
          if (v.send === true)
            flags |= 65536;
          if (v.forums === true)
            flags |= 131072;
          if (v.subExtend === true)
            flags |= 262144;
          w.uint(flags);
        },
        "popularContact": function(w, v) {
          w.uint(1558266229);
          w.long(h(v, "clientId"));
          w.int(h(v, "importers"));
        },
        "messages.favedStickersNotModified": function(w) {
          w.uint(2660214483);
        },
        "messages.favedStickers": function(w, v) {
          w.uint(750063767);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "packs"));
          w.vector(w.object, h(v, "stickers"));
        },
        "recentMeUrlUnknown": function(w, v) {
          w.uint(1189204285);
          w.string(h(v, "url"));
        },
        "recentMeUrlUser": function(w, v) {
          w.uint(3106671074);
          w.string(h(v, "url"));
          w.int53(h(v, "userId"));
        },
        "recentMeUrlChat": function(w, v) {
          w.uint(3000660434);
          w.string(h(v, "url"));
          w.int53(h(v, "chatId"));
        },
        "recentMeUrlChatInvite": function(w, v) {
          w.uint(3947431965);
          w.string(h(v, "url"));
          w.object(h(v, "chatInvite"));
        },
        "recentMeUrlStickerSet": function(w, v) {
          w.uint(3154794460);
          w.string(h(v, "url"));
          w.object(h(v, "set"));
        },
        "help.recentMeUrls": function(w, v) {
          w.uint(235081943);
          w.vector(w.object, h(v, "urls"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "inputSingleMedia": function(w, v) {
          w.uint(482797855);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "media"));
          w.long(h(v, "randomId"));
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
        },
        "webAuthorization": function(w, v) {
          w.uint(2801333330);
          w.long(h(v, "hash"));
          w.int53(h(v, "botId"));
          w.string(h(v, "domain"));
          w.string(h(v, "browser"));
          w.string(h(v, "platform"));
          w.int(h(v, "dateCreated"));
          w.int(h(v, "dateActive"));
          w.string(h(v, "ip"));
          w.string(h(v, "region"));
        },
        "account.webAuthorizations": function(w, v) {
          w.uint(3981887996);
          w.vector(w.object, h(v, "authorizations"));
          w.vector(w.object, h(v, "users"));
        },
        "inputMessageID": function(w, v) {
          w.uint(2792792866);
          w.int(h(v, "id"));
        },
        "inputMessageReplyTo": function(w, v) {
          w.uint(3134751637);
          w.int(h(v, "id"));
        },
        "inputMessagePinned": function(w) {
          w.uint(2257003832);
        },
        "inputMessageCallbackQuery": function(w, v) {
          w.uint(2902071934);
          w.int(h(v, "id"));
          w.long(h(v, "queryId"));
        },
        "inputDialogPeer": function(w, v) {
          w.uint(4239064759);
          w.object(h(v, "peer"));
        },
        "inputDialogPeerFolder": function(w, v) {
          w.uint(1684014375);
          w.int(h(v, "folderId"));
        },
        "dialogPeer": function(w, v) {
          w.uint(3849174789);
          w.object(h(v, "peer"));
        },
        "dialogPeerFolder": function(w, v) {
          w.uint(1363483106);
          w.int(h(v, "folderId"));
        },
        "messages.foundStickerSetsNotModified": function(w) {
          w.uint(223655517);
        },
        "messages.foundStickerSets": function(w, v) {
          w.uint(2331024850);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "sets"));
        },
        "fileHash": function(w, v) {
          w.uint(4087022428);
          w.int53(h(v, "offset"));
          w.int(h(v, "limit"));
          w.bytes(h(v, "hash"));
        },
        "inputClientProxy": function(w, v) {
          w.uint(1968737087);
          w.string(h(v, "address"));
          w.int(h(v, "port"));
        },
        "help.termsOfServiceUpdateEmpty": function(w, v) {
          w.uint(3811614591);
          w.int(h(v, "expires"));
        },
        "help.termsOfServiceUpdate": function(w, v) {
          w.uint(686618977);
          w.int(h(v, "expires"));
          w.object(h(v, "termsOfService"));
        },
        "inputSecureFileUploaded": function(w, v) {
          w.uint(859091184);
          w.long(h(v, "id"));
          w.int(h(v, "parts"));
          w.string(h(v, "md5Checksum"));
          w.bytes(h(v, "fileHash"));
          w.bytes(h(v, "secret"));
        },
        "inputSecureFile": function(w, v) {
          w.uint(1399317950);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "secureFileEmpty": function(w) {
          w.uint(1679398724);
        },
        "secureFile": function(w, v) {
          w.uint(2097791614);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int53(h(v, "size"));
          w.int(h(v, "dcId"));
          w.int(h(v, "date"));
          w.bytes(h(v, "fileHash"));
          w.bytes(h(v, "secret"));
        },
        "secureData": function(w, v) {
          w.uint(2330640067);
          w.bytes(h(v, "data"));
          w.bytes(h(v, "dataHash"));
          w.bytes(h(v, "secret"));
        },
        "securePlainPhone": function(w, v) {
          w.uint(2103482845);
          w.string(h(v, "phone"));
        },
        "securePlainEmail": function(w, v) {
          w.uint(569137759);
          w.string(h(v, "email"));
        },
        "secureValueTypePersonalDetails": function(w) {
          w.uint(2636808675);
        },
        "secureValueTypePassport": function(w) {
          w.uint(1034709504);
        },
        "secureValueTypeDriverLicense": function(w) {
          w.uint(115615172);
        },
        "secureValueTypeIdentityCard": function(w) {
          w.uint(2698015819);
        },
        "secureValueTypeInternalPassport": function(w) {
          w.uint(2577698595);
        },
        "secureValueTypeAddress": function(w) {
          w.uint(3420659238);
        },
        "secureValueTypeUtilityBill": function(w) {
          w.uint(4231435598);
        },
        "secureValueTypeBankStatement": function(w) {
          w.uint(2299755533);
        },
        "secureValueTypeRentalAgreement": function(w) {
          w.uint(2340959368);
        },
        "secureValueTypePassportRegistration": function(w) {
          w.uint(2581823594);
        },
        "secureValueTypeTemporaryRegistration": function(w) {
          w.uint(3926060083);
        },
        "secureValueTypePhone": function(w) {
          w.uint(3005262555);
        },
        "secureValueTypeEmail": function(w) {
          w.uint(2386339822);
        },
        "secureValue": function(w, v) {
          w.uint(411017418);
          var flags = 0;
          var _data = v.data !== void 0;
          if (_data)
            flags |= 1;
          var _frontSide = v.frontSide !== void 0;
          if (_frontSide)
            flags |= 2;
          var _reverseSide = v.reverseSide !== void 0;
          if (_reverseSide)
            flags |= 4;
          var _selfie = v.selfie !== void 0;
          if (_selfie)
            flags |= 8;
          var _files = v.files && v.files.length;
          if (_files)
            flags |= 16;
          var _plainData = v.plainData !== void 0;
          if (_plainData)
            flags |= 32;
          var _translation = v.translation && v.translation.length;
          if (_translation)
            flags |= 64;
          w.uint(flags);
          w.object(h(v, "type"));
          if (_data)
            w.object(v.data);
          if (_frontSide)
            w.object(v.frontSide);
          if (_reverseSide)
            w.object(v.reverseSide);
          if (_selfie)
            w.object(v.selfie);
          if (_translation)
            w.vector(w.object, v.translation);
          if (_files)
            w.vector(w.object, v.files);
          if (_plainData)
            w.object(v.plainData);
          w.bytes(h(v, "hash"));
        },
        "inputSecureValue": function(w, v) {
          w.uint(3676426407);
          var flags = 0;
          var _data = v.data !== void 0;
          if (_data)
            flags |= 1;
          var _frontSide = v.frontSide !== void 0;
          if (_frontSide)
            flags |= 2;
          var _reverseSide = v.reverseSide !== void 0;
          if (_reverseSide)
            flags |= 4;
          var _selfie = v.selfie !== void 0;
          if (_selfie)
            flags |= 8;
          var _files = v.files && v.files.length;
          if (_files)
            flags |= 16;
          var _plainData = v.plainData !== void 0;
          if (_plainData)
            flags |= 32;
          var _translation = v.translation && v.translation.length;
          if (_translation)
            flags |= 64;
          w.uint(flags);
          w.object(h(v, "type"));
          if (_data)
            w.object(v.data);
          if (_frontSide)
            w.object(v.frontSide);
          if (_reverseSide)
            w.object(v.reverseSide);
          if (_selfie)
            w.object(v.selfie);
          if (_translation)
            w.vector(w.object, v.translation);
          if (_files)
            w.vector(w.object, v.files);
          if (_plainData)
            w.object(v.plainData);
        },
        "secureValueHash": function(w, v) {
          w.uint(3978218928);
          w.object(h(v, "type"));
          w.bytes(h(v, "hash"));
        },
        "secureValueErrorData": function(w, v) {
          w.uint(3903065049);
          w.object(h(v, "type"));
          w.bytes(h(v, "dataHash"));
          w.string(h(v, "field"));
          w.string(h(v, "text"));
        },
        "secureValueErrorFrontSide": function(w, v) {
          w.uint(12467706);
          w.object(h(v, "type"));
          w.bytes(h(v, "fileHash"));
          w.string(h(v, "text"));
        },
        "secureValueErrorReverseSide": function(w, v) {
          w.uint(2257201829);
          w.object(h(v, "type"));
          w.bytes(h(v, "fileHash"));
          w.string(h(v, "text"));
        },
        "secureValueErrorSelfie": function(w, v) {
          w.uint(3845639894);
          w.object(h(v, "type"));
          w.bytes(h(v, "fileHash"));
          w.string(h(v, "text"));
        },
        "secureValueErrorFile": function(w, v) {
          w.uint(2054162547);
          w.object(h(v, "type"));
          w.bytes(h(v, "fileHash"));
          w.string(h(v, "text"));
        },
        "secureValueErrorFiles": function(w, v) {
          w.uint(1717706985);
          w.object(h(v, "type"));
          w.vector(w.bytes, h(v, "fileHash"));
          w.string(h(v, "text"));
        },
        "secureValueError": function(w, v) {
          w.uint(2258466191);
          w.object(h(v, "type"));
          w.bytes(h(v, "hash"));
          w.string(h(v, "text"));
        },
        "secureValueErrorTranslationFile": function(w, v) {
          w.uint(2702460784);
          w.object(h(v, "type"));
          w.bytes(h(v, "fileHash"));
          w.string(h(v, "text"));
        },
        "secureValueErrorTranslationFiles": function(w, v) {
          w.uint(878931416);
          w.object(h(v, "type"));
          w.vector(w.bytes, h(v, "fileHash"));
          w.string(h(v, "text"));
        },
        "secureCredentialsEncrypted": function(w, v) {
          w.uint(871426631);
          w.bytes(h(v, "data"));
          w.bytes(h(v, "hash"));
          w.bytes(h(v, "secret"));
        },
        "account.authorizationForm": function(w, v) {
          w.uint(2905480408);
          var flags = 0;
          var _privacyPolicyUrl = v.privacyPolicyUrl !== void 0;
          if (_privacyPolicyUrl)
            flags |= 1;
          w.uint(flags);
          w.vector(w.object, h(v, "requiredTypes"));
          w.vector(w.object, h(v, "values"));
          w.vector(w.object, h(v, "errors"));
          w.vector(w.object, h(v, "users"));
          if (_privacyPolicyUrl)
            w.string(v.privacyPolicyUrl);
        },
        "account.sentEmailCode": function(w, v) {
          w.uint(2166326607);
          w.string(h(v, "emailPattern"));
          w.int(h(v, "length"));
        },
        "help.deepLinkInfoEmpty": function(w) {
          w.uint(1722786150);
        },
        "help.deepLinkInfo": function(w, v) {
          w.uint(1783556146);
          var flags = 0;
          if (v.updateApp === true)
            flags |= 1;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
        },
        "savedPhoneContact": function(w, v) {
          w.uint(289586518);
          w.string(h(v, "phone"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
          w.int(h(v, "date"));
        },
        "account.takeout": function(w, v) {
          w.uint(1304052993);
          w.long(h(v, "id"));
        },
        "passwordKdfAlgoUnknown": function(w) {
          w.uint(3562713238);
        },
        "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow": function(w, v) {
          w.uint(982592842);
          w.bytes(h(v, "salt1"));
          w.bytes(h(v, "salt2"));
          w.int(h(v, "g"));
          w.bytes(h(v, "p"));
        },
        "securePasswordKdfAlgoUnknown": function(w) {
          w.uint(4883767);
        },
        "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000": function(w, v) {
          w.uint(3153255840);
          w.bytes(h(v, "salt"));
        },
        "securePasswordKdfAlgoSHA512": function(w, v) {
          w.uint(2252807570);
          w.bytes(h(v, "salt"));
        },
        "secureSecretSettings": function(w, v) {
          w.uint(354925740);
          w.object(h(v, "secureAlgo"));
          w.bytes(h(v, "secureSecret"));
          w.long(h(v, "secureSecretId"));
        },
        "inputCheckPasswordEmpty": function(w) {
          w.uint(2558588504);
        },
        "inputCheckPasswordSRP": function(w, v) {
          w.uint(3531600002);
          w.long(h(v, "srpId"));
          w.bytes(h(v, "A"));
          w.bytes(h(v, "M1"));
        },
        "secureRequiredType": function(w, v) {
          w.uint(2191366618);
          var flags = 0;
          if (v.nativeNames === true)
            flags |= 1;
          if (v.selfieRequired === true)
            flags |= 2;
          if (v.translationRequired === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "type"));
        },
        "secureRequiredTypeOneOf": function(w, v) {
          w.uint(41187252);
          w.vector(w.object, h(v, "types"));
        },
        "help.passportConfigNotModified": function(w) {
          w.uint(3216634967);
        },
        "help.passportConfig": function(w, v) {
          w.uint(2694370991);
          w.int(h(v, "hash"));
          w.object(h(v, "countriesLangs"));
        },
        "inputAppEvent": function(w, v) {
          w.uint(488313413);
          w.double(h(v, "time"));
          w.string(h(v, "type"));
          w.long(h(v, "peer"));
          w.object(h(v, "data"));
        },
        "jsonObjectValue": function(w, v) {
          w.uint(3235781593);
          w.string(h(v, "key"));
          w.object(h(v, "value"));
        },
        "jsonNull": function(w) {
          w.uint(1064139624);
        },
        "jsonBool": function(w, v) {
          w.uint(3342098026);
          w.boolean(h(v, "value"));
        },
        "jsonNumber": function(w, v) {
          w.uint(736157604);
          w.double(h(v, "value"));
        },
        "jsonString": function(w, v) {
          w.uint(3072226938);
          w.string(h(v, "value"));
        },
        "jsonArray": function(w, v) {
          w.uint(4148447075);
          w.vector(w.object, h(v, "value"));
        },
        "jsonObject": function(w, v) {
          w.uint(2579616925);
          w.vector(w.object, h(v, "value"));
        },
        "pageTableCell": function(w, v) {
          w.uint(878078826);
          var flags = 0;
          if (v.header === true)
            flags |= 1;
          var _colspan = v.colspan !== void 0;
          if (_colspan)
            flags |= 2;
          var _rowspan = v.rowspan !== void 0;
          if (_rowspan)
            flags |= 4;
          if (v.alignCenter === true)
            flags |= 8;
          if (v.alignRight === true)
            flags |= 16;
          if (v.valignMiddle === true)
            flags |= 32;
          if (v.valignBottom === true)
            flags |= 64;
          var _text = v.text !== void 0;
          if (_text)
            flags |= 128;
          w.uint(flags);
          if (_text)
            w.object(v.text);
          if (_colspan)
            w.int(v.colspan);
          if (_rowspan)
            w.int(v.rowspan);
        },
        "pageTableRow": function(w, v) {
          w.uint(3770729957);
          w.vector(w.object, h(v, "cells"));
        },
        "pageCaption": function(w, v) {
          w.uint(1869903447);
          w.object(h(v, "text"));
          w.object(h(v, "credit"));
        },
        "pageListItemText": function(w, v) {
          w.uint(3106911949);
          w.object(h(v, "text"));
        },
        "pageListItemBlocks": function(w, v) {
          w.uint(635466748);
          w.vector(w.object, h(v, "blocks"));
        },
        "pageListOrderedItemText": function(w, v) {
          w.uint(1577484359);
          w.string(h(v, "num"));
          w.object(h(v, "text"));
        },
        "pageListOrderedItemBlocks": function(w, v) {
          w.uint(2564655414);
          w.string(h(v, "num"));
          w.vector(w.object, h(v, "blocks"));
        },
        "pageRelatedArticle": function(w, v) {
          w.uint(3012615176);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 2;
          var _photoId = v.photoId !== void 0;
          if (_photoId)
            flags |= 4;
          var _author = v.author !== void 0;
          if (_author)
            flags |= 8;
          var _publishedDate = v.publishedDate !== void 0;
          if (_publishedDate)
            flags |= 16;
          w.uint(flags);
          w.string(h(v, "url"));
          w.long(h(v, "webpageId"));
          if (_title)
            w.string(v.title);
          if (_description)
            w.string(v.description);
          if (_photoId)
            w.long(v.photoId);
          if (_author)
            w.string(v.author);
          if (_publishedDate)
            w.int(v.publishedDate);
        },
        "page": function(w, v) {
          w.uint(2556788493);
          var flags = 0;
          if (v.part === true)
            flags |= 1;
          if (v.rtl === true)
            flags |= 2;
          if (v.v2 === true)
            flags |= 4;
          var _views = v.views !== void 0;
          if (_views)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "url"));
          w.vector(w.object, h(v, "blocks"));
          w.vector(w.object, h(v, "photos"));
          w.vector(w.object, h(v, "documents"));
          if (_views)
            w.int(v.views);
        },
        "help.supportName": function(w, v) {
          w.uint(2349199817);
          w.string(h(v, "name"));
        },
        "help.userInfoEmpty": function(w) {
          w.uint(4088278765);
        },
        "help.userInfo": function(w, v) {
          w.uint(32192344);
          w.string(h(v, "message"));
          w.vector(w.object, h(v, "entities"));
          w.string(h(v, "author"));
          w.int(h(v, "date"));
        },
        "pollAnswer": function(w, v) {
          w.uint(4279689930);
          w.object(h(v, "text"));
          w.bytes(h(v, "option"));
        },
        "poll": function(w, v) {
          w.uint(1484026161);
          w.long(h(v, "id"));
          var flags = 0;
          if (v.closed === true)
            flags |= 1;
          if (v.publicVoters === true)
            flags |= 2;
          if (v.multipleChoice === true)
            flags |= 4;
          if (v.quiz === true)
            flags |= 8;
          var _closePeriod = v.closePeriod !== void 0;
          if (_closePeriod)
            flags |= 16;
          var _closeDate = v.closeDate !== void 0;
          if (_closeDate)
            flags |= 32;
          w.uint(flags);
          w.object(h(v, "question"));
          w.vector(w.object, h(v, "answers"));
          if (_closePeriod)
            w.int(v.closePeriod);
          if (_closeDate)
            w.int(v.closeDate);
        },
        "pollAnswerVoters": function(w, v) {
          w.uint(997055186);
          var flags = 0;
          if (v.chosen === true)
            flags |= 1;
          if (v.correct === true)
            flags |= 2;
          w.uint(flags);
          w.bytes(h(v, "option"));
          w.int(h(v, "voters"));
        },
        "pollResults": function(w, v) {
          w.uint(2061444128);
          var flags = 0;
          if (v.min === true)
            flags |= 1;
          var _results = v.results && v.results.length;
          if (_results)
            flags |= 2;
          var _totalVoters = v.totalVoters !== void 0;
          if (_totalVoters)
            flags |= 4;
          var _recentVoters = v.recentVoters && v.recentVoters.length;
          if (_recentVoters)
            flags |= 8;
          var _solution = v.solution !== void 0;
          var _solutionEntities = v.solutionEntities && v.solutionEntities.length;
          var _flags_4 = _solution || _solutionEntities;
          if (_flags_4)
            flags |= 16;
          w.uint(flags);
          if (_results)
            w.vector(w.object, v.results);
          if (_totalVoters)
            w.int(v.totalVoters);
          if (_recentVoters)
            w.vector(w.object, v.recentVoters);
          if (_flags_4)
            w.string(v.solution);
          if (_flags_4)
            w.vector(w.object, v.solutionEntities);
        },
        "chatOnlines": function(w, v) {
          w.uint(4030849616);
          w.int(h(v, "onlines"));
        },
        "statsURL": function(w, v) {
          w.uint(1202287072);
          w.string(h(v, "url"));
        },
        "chatAdminRights": function(w, v) {
          w.uint(1605510357);
          var flags = 0;
          if (v.changeInfo === true)
            flags |= 1;
          if (v.postMessages === true)
            flags |= 2;
          if (v.editMessages === true)
            flags |= 4;
          if (v.deleteMessages === true)
            flags |= 8;
          if (v.banUsers === true)
            flags |= 16;
          if (v.inviteUsers === true)
            flags |= 32;
          if (v.pinMessages === true)
            flags |= 128;
          if (v.addAdmins === true)
            flags |= 512;
          if (v.anonymous === true)
            flags |= 1024;
          if (v.manageCall === true)
            flags |= 2048;
          if (v.other === true)
            flags |= 4096;
          if (v.manageTopics === true)
            flags |= 8192;
          if (v.postStories === true)
            flags |= 16384;
          if (v.editStories === true)
            flags |= 32768;
          if (v.deleteStories === true)
            flags |= 65536;
          w.uint(flags);
        },
        "chatBannedRights": function(w, v) {
          w.uint(2668758040);
          var flags = 0;
          if (v.viewMessages === true)
            flags |= 1;
          if (v.sendMessages === true)
            flags |= 2;
          if (v.sendMedia === true)
            flags |= 4;
          if (v.sendStickers === true)
            flags |= 8;
          if (v.sendGifs === true)
            flags |= 16;
          if (v.sendGames === true)
            flags |= 32;
          if (v.sendInline === true)
            flags |= 64;
          if (v.embedLinks === true)
            flags |= 128;
          if (v.sendPolls === true)
            flags |= 256;
          if (v.changeInfo === true)
            flags |= 1024;
          if (v.inviteUsers === true)
            flags |= 32768;
          if (v.pinMessages === true)
            flags |= 131072;
          if (v.manageTopics === true)
            flags |= 262144;
          if (v.sendPhotos === true)
            flags |= 524288;
          if (v.sendVideos === true)
            flags |= 1048576;
          if (v.sendRoundvideos === true)
            flags |= 2097152;
          if (v.sendAudios === true)
            flags |= 4194304;
          if (v.sendVoices === true)
            flags |= 8388608;
          if (v.sendDocs === true)
            flags |= 16777216;
          if (v.sendPlain === true)
            flags |= 33554432;
          w.uint(flags);
          w.int(h(v, "untilDate"));
        },
        "inputWallPaper": function(w, v) {
          w.uint(3861952889);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputWallPaperSlug": function(w, v) {
          w.uint(1913199744);
          w.string(h(v, "slug"));
        },
        "inputWallPaperNoFile": function(w, v) {
          w.uint(2524595758);
          w.long(h(v, "id"));
        },
        "account.wallPapersNotModified": function(w) {
          w.uint(471437699);
        },
        "account.wallPapers": function(w, v) {
          w.uint(3452142988);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "wallpapers"));
        },
        "codeSettings": function(w, v) {
          w.uint(2904898936);
          var flags = 0;
          if (v.allowFlashcall === true)
            flags |= 1;
          if (v.currentNumber === true)
            flags |= 2;
          if (v.allowAppHash === true)
            flags |= 16;
          if (v.allowMissedCall === true)
            flags |= 32;
          var _logoutTokens = v.logoutTokens && v.logoutTokens.length;
          if (_logoutTokens)
            flags |= 64;
          if (v.allowFirebase === true)
            flags |= 128;
          var _token = v.token !== void 0;
          var _appSandbox = v.appSandbox !== void 0;
          var _flags_8 = _token || _appSandbox;
          if (_flags_8)
            flags |= 256;
          if (v.unknownNumber === true)
            flags |= 512;
          w.uint(flags);
          if (_logoutTokens)
            w.vector(w.bytes, v.logoutTokens);
          if (_flags_8)
            w.string(v.token);
          if (_flags_8)
            w.boolean(v.appSandbox);
        },
        "wallPaperSettings": function(w, v) {
          w.uint(925826256);
          var flags = 0;
          var _backgroundColor = v.backgroundColor !== void 0;
          if (_backgroundColor)
            flags |= 1;
          if (v.blur === true)
            flags |= 2;
          if (v.motion === true)
            flags |= 4;
          var _intensity = v.intensity !== void 0;
          if (_intensity)
            flags |= 8;
          var _secondBackgroundColor = v.secondBackgroundColor !== void 0;
          var _rotation = v.rotation !== void 0;
          var _flags_4 = _secondBackgroundColor || _rotation;
          if (_flags_4)
            flags |= 16;
          var _thirdBackgroundColor = v.thirdBackgroundColor !== void 0;
          if (_thirdBackgroundColor)
            flags |= 32;
          var _fourthBackgroundColor = v.fourthBackgroundColor !== void 0;
          if (_fourthBackgroundColor)
            flags |= 64;
          var _emoticon = v.emoticon !== void 0;
          if (_emoticon)
            flags |= 128;
          w.uint(flags);
          if (_backgroundColor)
            w.int(v.backgroundColor);
          if (_flags_4)
            w.int(v.secondBackgroundColor);
          if (_thirdBackgroundColor)
            w.int(v.thirdBackgroundColor);
          if (_fourthBackgroundColor)
            w.int(v.fourthBackgroundColor);
          if (_intensity)
            w.int(v.intensity);
          if (_flags_4)
            w.int(v.rotation);
          if (_emoticon)
            w.string(v.emoticon);
        },
        "autoDownloadSettings": function(w, v) {
          w.uint(3131405864);
          var flags = 0;
          if (v.disabled === true)
            flags |= 1;
          if (v.videoPreloadLarge === true)
            flags |= 2;
          if (v.audioPreloadNext === true)
            flags |= 4;
          if (v.phonecallsLessData === true)
            flags |= 8;
          if (v.storiesPreload === true)
            flags |= 16;
          w.uint(flags);
          w.int(h(v, "photoSizeMax"));
          w.int53(h(v, "videoSizeMax"));
          w.int53(h(v, "fileSizeMax"));
          w.int(h(v, "videoUploadMaxbitrate"));
          w.int(h(v, "smallQueueActiveOperationsMax"));
          w.int(h(v, "largeQueueActiveOperationsMax"));
        },
        "account.autoDownloadSettings": function(w, v) {
          w.uint(1674235686);
          w.object(h(v, "low"));
          w.object(h(v, "medium"));
          w.object(h(v, "high"));
        },
        "emojiKeyword": function(w, v) {
          w.uint(3585325561);
          w.string(h(v, "keyword"));
          w.vector(w.string, h(v, "emoticons"));
        },
        "emojiKeywordDeleted": function(w, v) {
          w.uint(594408994);
          w.string(h(v, "keyword"));
          w.vector(w.string, h(v, "emoticons"));
        },
        "emojiKeywordsDifference": function(w, v) {
          w.uint(1556570557);
          w.string(h(v, "langCode"));
          w.int(h(v, "fromVersion"));
          w.int(h(v, "version"));
          w.vector(w.object, h(v, "keywords"));
        },
        "emojiURL": function(w, v) {
          w.uint(2775937949);
          w.string(h(v, "url"));
        },
        "emojiLanguage": function(w, v) {
          w.uint(3019592545);
          w.string(h(v, "langCode"));
        },
        "folder": function(w, v) {
          w.uint(4283715173);
          var flags = 0;
          if (v.autofillNewBroadcasts === true)
            flags |= 1;
          if (v.autofillPublicGroups === true)
            flags |= 2;
          if (v.autofillNewCorrespondents === true)
            flags |= 4;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 8;
          w.uint(flags);
          w.int(h(v, "id"));
          w.string(h(v, "title"));
          if (_photo)
            w.object(v.photo);
        },
        "inputFolderPeer": function(w, v) {
          w.uint(4224893590);
          w.object(h(v, "peer"));
          w.int(h(v, "folderId"));
        },
        "folderPeer": function(w, v) {
          w.uint(3921323624);
          w.object(h(v, "peer"));
          w.int(h(v, "folderId"));
        },
        "messages.searchCounter": function(w, v) {
          w.uint(3896830975);
          var flags = 0;
          if (v.inexact === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "filter"));
          w.int(h(v, "count"));
        },
        "urlAuthResultRequest": function(w, v) {
          w.uint(2463316494);
          var flags = 0;
          if (v.requestWriteAccess === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "bot"));
          w.string(h(v, "domain"));
        },
        "urlAuthResultAccepted": function(w, v) {
          w.uint(2408320590);
          w.string(h(v, "url"));
        },
        "urlAuthResultDefault": function(w) {
          w.uint(2849430303);
        },
        "channelLocationEmpty": function(w) {
          w.uint(3216354699);
        },
        "channelLocation": function(w, v) {
          w.uint(547062491);
          w.object(h(v, "geoPoint"));
          w.string(h(v, "address"));
        },
        "peerLocated": function(w, v) {
          w.uint(3393592157);
          w.object(h(v, "peer"));
          w.int(h(v, "expires"));
          w.int(h(v, "distance"));
        },
        "peerSelfLocated": function(w, v) {
          w.uint(4176226379);
          w.int(h(v, "expires"));
        },
        "restrictionReason": function(w, v) {
          w.uint(3497176244);
          w.string(h(v, "platform"));
          w.string(h(v, "reason"));
          w.string(h(v, "text"));
        },
        "inputTheme": function(w, v) {
          w.uint(1012306921);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputThemeSlug": function(w, v) {
          w.uint(4119399921);
          w.string(h(v, "slug"));
        },
        "theme": function(w, v) {
          w.uint(2685298646);
          var flags = 0;
          if (v.creator === true)
            flags |= 1;
          if (v.default === true)
            flags |= 2;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 4;
          var _settings = v.settings && v.settings.length;
          if (_settings)
            flags |= 8;
          var _installsCount = v.installsCount !== void 0;
          if (_installsCount)
            flags |= 16;
          if (v.forChat === true)
            flags |= 32;
          var _emoticon = v.emoticon !== void 0;
          if (_emoticon)
            flags |= 64;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.string(h(v, "slug"));
          w.string(h(v, "title"));
          if (_document)
            w.object(v.document);
          if (_settings)
            w.vector(w.object, v.settings);
          if (_emoticon)
            w.string(v.emoticon);
          if (_installsCount)
            w.int(v.installsCount);
        },
        "account.themesNotModified": function(w) {
          w.uint(4095653410);
        },
        "account.themes": function(w, v) {
          w.uint(2587724909);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "themes"));
        },
        "auth.loginToken": function(w, v) {
          w.uint(1654593920);
          w.int(h(v, "expires"));
          w.bytes(h(v, "token"));
        },
        "auth.loginTokenMigrateTo": function(w, v) {
          w.uint(110008598);
          w.int(h(v, "dcId"));
          w.bytes(h(v, "token"));
        },
        "auth.loginTokenSuccess": function(w, v) {
          w.uint(957176926);
          w.object(h(v, "authorization"));
        },
        "account.contentSettings": function(w, v) {
          w.uint(1474462241);
          var flags = 0;
          if (v.sensitiveEnabled === true)
            flags |= 1;
          if (v.sensitiveCanChange === true)
            flags |= 2;
          w.uint(flags);
        },
        "messages.inactiveChats": function(w, v) {
          w.uint(2837970629);
          w.vector(w.int, h(v, "dates"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "baseThemeClassic": function(w) {
          w.uint(3282117730);
        },
        "baseThemeDay": function(w) {
          w.uint(4225242760);
        },
        "baseThemeNight": function(w) {
          w.uint(3081969320);
        },
        "baseThemeTinted": function(w) {
          w.uint(1834973166);
        },
        "baseThemeArctic": function(w) {
          w.uint(1527845466);
        },
        "inputThemeSettings": function(w, v) {
          w.uint(2413711439);
          var flags = 0;
          var _messageColors = v.messageColors && v.messageColors.length;
          if (_messageColors)
            flags |= 1;
          var _wallpaper = v.wallpaper !== void 0;
          var _wallpaperSettings = v.wallpaperSettings !== void 0;
          var _flags_1 = _wallpaper || _wallpaperSettings;
          if (_flags_1)
            flags |= 2;
          if (v.messageColorsAnimated === true)
            flags |= 4;
          var _outboxAccentColor = v.outboxAccentColor !== void 0;
          if (_outboxAccentColor)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "baseTheme"));
          w.int(h(v, "accentColor"));
          if (_outboxAccentColor)
            w.int(v.outboxAccentColor);
          if (_messageColors)
            w.vector(w.int, v.messageColors);
          if (_flags_1)
            w.object(v.wallpaper);
          if (_flags_1)
            w.object(v.wallpaperSettings);
        },
        "themeSettings": function(w, v) {
          w.uint(4200117972);
          var flags = 0;
          var _messageColors = v.messageColors && v.messageColors.length;
          if (_messageColors)
            flags |= 1;
          var _wallpaper = v.wallpaper !== void 0;
          if (_wallpaper)
            flags |= 2;
          if (v.messageColorsAnimated === true)
            flags |= 4;
          var _outboxAccentColor = v.outboxAccentColor !== void 0;
          if (_outboxAccentColor)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "baseTheme"));
          w.int(h(v, "accentColor"));
          if (_outboxAccentColor)
            w.int(v.outboxAccentColor);
          if (_messageColors)
            w.vector(w.int, v.messageColors);
          if (_wallpaper)
            w.object(v.wallpaper);
        },
        "webPageAttributeTheme": function(w, v) {
          w.uint(1421174295);
          var flags = 0;
          var _documents = v.documents && v.documents.length;
          if (_documents)
            flags |= 1;
          var _settings = v.settings !== void 0;
          if (_settings)
            flags |= 2;
          w.uint(flags);
          if (_documents)
            w.vector(w.object, v.documents);
          if (_settings)
            w.object(v.settings);
        },
        "webPageAttributeStory": function(w, v) {
          w.uint(781501415);
          var flags = 0;
          var _story = v.story !== void 0;
          if (_story)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          if (_story)
            w.object(v.story);
        },
        "webPageAttributeStickerSet": function(w, v) {
          w.uint(1355547603);
          var flags = 0;
          if (v.emojis === true)
            flags |= 1;
          if (v.textColor === true)
            flags |= 2;
          w.uint(flags);
          w.vector(w.object, h(v, "stickers"));
        },
        "messages.votesList": function(w, v) {
          w.uint(1218005070);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "votes"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          if (_nextOffset)
            w.string(v.nextOffset);
        },
        "bankCardOpenUrl": function(w, v) {
          w.uint(4117234314);
          w.string(h(v, "url"));
          w.string(h(v, "name"));
        },
        "payments.bankCardData": function(w, v) {
          w.uint(1042605427);
          w.string(h(v, "title"));
          w.vector(w.object, h(v, "openUrls"));
        },
        "dialogFilter": function(w, v) {
          w.uint(1605718587);
          var flags = 0;
          if (v.contacts === true)
            flags |= 1;
          if (v.nonContacts === true)
            flags |= 2;
          if (v.groups === true)
            flags |= 4;
          if (v.broadcasts === true)
            flags |= 8;
          if (v.bots === true)
            flags |= 16;
          if (v.excludeMuted === true)
            flags |= 2048;
          if (v.excludeRead === true)
            flags |= 4096;
          if (v.excludeArchived === true)
            flags |= 8192;
          var _emoticon = v.emoticon !== void 0;
          if (_emoticon)
            flags |= 33554432;
          var _color = v.color !== void 0;
          if (_color)
            flags |= 134217728;
          w.uint(flags);
          w.int(h(v, "id"));
          w.string(h(v, "title"));
          if (_emoticon)
            w.string(v.emoticon);
          if (_color)
            w.int(v.color);
          w.vector(w.object, h(v, "pinnedPeers"));
          w.vector(w.object, h(v, "includePeers"));
          w.vector(w.object, h(v, "excludePeers"));
        },
        "dialogFilterDefault": function(w) {
          w.uint(909284270);
        },
        "dialogFilterChatlist": function(w, v) {
          w.uint(2682424996);
          var flags = 0;
          var _emoticon = v.emoticon !== void 0;
          if (_emoticon)
            flags |= 33554432;
          if (v.hasMyInvites === true)
            flags |= 67108864;
          var _color = v.color !== void 0;
          if (_color)
            flags |= 134217728;
          w.uint(flags);
          w.int(h(v, "id"));
          w.string(h(v, "title"));
          if (_emoticon)
            w.string(v.emoticon);
          if (_color)
            w.int(v.color);
          w.vector(w.object, h(v, "pinnedPeers"));
          w.vector(w.object, h(v, "includePeers"));
        },
        "dialogFilterSuggested": function(w, v) {
          w.uint(2004110666);
          w.object(h(v, "filter"));
          w.string(h(v, "description"));
        },
        "statsDateRangeDays": function(w, v) {
          w.uint(3057118639);
          w.int(h(v, "minDate"));
          w.int(h(v, "maxDate"));
        },
        "statsAbsValueAndPrev": function(w, v) {
          w.uint(3410210014);
          w.double(h(v, "current"));
          w.double(h(v, "previous"));
        },
        "statsPercentValue": function(w, v) {
          w.uint(3419287520);
          w.double(h(v, "part"));
          w.double(h(v, "total"));
        },
        "statsGraphAsync": function(w, v) {
          w.uint(1244130093);
          w.string(h(v, "token"));
        },
        "statsGraphError": function(w, v) {
          w.uint(3202127906);
          w.string(h(v, "error"));
        },
        "statsGraph": function(w, v) {
          w.uint(2393138358);
          var flags = 0;
          var _zoomToken = v.zoomToken !== void 0;
          if (_zoomToken)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "json"));
          if (_zoomToken)
            w.string(v.zoomToken);
        },
        "stats.broadcastStats": function(w, v) {
          w.uint(963421692);
          w.object(h(v, "period"));
          w.object(h(v, "followers"));
          w.object(h(v, "viewsPerPost"));
          w.object(h(v, "sharesPerPost"));
          w.object(h(v, "reactionsPerPost"));
          w.object(h(v, "viewsPerStory"));
          w.object(h(v, "sharesPerStory"));
          w.object(h(v, "reactionsPerStory"));
          w.object(h(v, "enabledNotifications"));
          w.object(h(v, "growthGraph"));
          w.object(h(v, "followersGraph"));
          w.object(h(v, "muteGraph"));
          w.object(h(v, "topHoursGraph"));
          w.object(h(v, "interactionsGraph"));
          w.object(h(v, "ivInteractionsGraph"));
          w.object(h(v, "viewsBySourceGraph"));
          w.object(h(v, "newFollowersBySourceGraph"));
          w.object(h(v, "languagesGraph"));
          w.object(h(v, "reactionsByEmotionGraph"));
          w.object(h(v, "storyInteractionsGraph"));
          w.object(h(v, "storyReactionsByEmotionGraph"));
          w.vector(w.object, h(v, "recentPostsInteractions"));
        },
        "help.promoDataEmpty": function(w, v) {
          w.uint(2566302837);
          w.int(h(v, "expires"));
        },
        "help.promoData": function(w, v) {
          w.uint(2352576831);
          var flags = 0;
          if (v.proxy === true)
            flags |= 1;
          var _psaType = v.psaType !== void 0;
          if (_psaType)
            flags |= 2;
          var _psaMessage = v.psaMessage !== void 0;
          if (_psaMessage)
            flags |= 4;
          w.uint(flags);
          w.int(h(v, "expires"));
          w.object(h(v, "peer"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          if (_psaType)
            w.string(v.psaType);
          if (_psaMessage)
            w.string(v.psaMessage);
        },
        "videoSize": function(w, v) {
          w.uint(3727929492);
          var flags = 0;
          var _videoStartTs = v.videoStartTs !== void 0;
          if (_videoStartTs)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "type"));
          w.int(h(v, "w"));
          w.int(h(v, "h"));
          w.int(h(v, "size"));
          if (_videoStartTs)
            w.double(v.videoStartTs);
        },
        "videoSizeEmojiMarkup": function(w, v) {
          w.uint(4166795580);
          w.long(h(v, "emojiId"));
          w.vector(w.int, h(v, "backgroundColors"));
        },
        "videoSizeStickerMarkup": function(w, v) {
          w.uint(228623102);
          w.object(h(v, "stickerset"));
          w.long(h(v, "stickerId"));
          w.vector(w.int, h(v, "backgroundColors"));
        },
        "statsGroupTopPoster": function(w, v) {
          w.uint(2634330011);
          w.int53(h(v, "userId"));
          w.int(h(v, "messages"));
          w.int(h(v, "avgChars"));
        },
        "statsGroupTopAdmin": function(w, v) {
          w.uint(3612888199);
          w.int53(h(v, "userId"));
          w.int(h(v, "deleted"));
          w.int(h(v, "kicked"));
          w.int(h(v, "banned"));
        },
        "statsGroupTopInviter": function(w, v) {
          w.uint(1398765469);
          w.int53(h(v, "userId"));
          w.int(h(v, "invitations"));
        },
        "stats.megagroupStats": function(w, v) {
          w.uint(4018141462);
          w.object(h(v, "period"));
          w.object(h(v, "members"));
          w.object(h(v, "messages"));
          w.object(h(v, "viewers"));
          w.object(h(v, "posters"));
          w.object(h(v, "growthGraph"));
          w.object(h(v, "membersGraph"));
          w.object(h(v, "newMembersBySourceGraph"));
          w.object(h(v, "languagesGraph"));
          w.object(h(v, "messagesGraph"));
          w.object(h(v, "actionsGraph"));
          w.object(h(v, "topHoursGraph"));
          w.object(h(v, "weekdaysGraph"));
          w.vector(w.object, h(v, "topPosters"));
          w.vector(w.object, h(v, "topAdmins"));
          w.vector(w.object, h(v, "topInviters"));
          w.vector(w.object, h(v, "users"));
        },
        "globalPrivacySettings": function(w, v) {
          w.uint(1934380235);
          var flags = 0;
          if (v.archiveAndMuteNewNoncontactPeers === true)
            flags |= 1;
          if (v.keepArchivedUnmuted === true)
            flags |= 2;
          if (v.keepArchivedFolders === true)
            flags |= 4;
          if (v.hideReadMarks === true)
            flags |= 8;
          if (v.newNoncontactPeersRequirePremium === true)
            flags |= 16;
          w.uint(flags);
        },
        "help.countryCode": function(w, v) {
          w.uint(1107543535);
          var flags = 0;
          var _prefixes = v.prefixes && v.prefixes.length;
          if (_prefixes)
            flags |= 1;
          var _patterns = v.patterns && v.patterns.length;
          if (_patterns)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "countryCode"));
          if (_prefixes)
            w.vector(w.string, v.prefixes);
          if (_patterns)
            w.vector(w.string, v.patterns);
        },
        "help.country": function(w, v) {
          w.uint(3280440867);
          var flags = 0;
          if (v.hidden === true)
            flags |= 1;
          var _name = v.name !== void 0;
          if (_name)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "iso2"));
          w.string(h(v, "defaultName"));
          if (_name)
            w.string(v.name);
          w.vector(w.object, h(v, "countryCodes"));
        },
        "help.countriesListNotModified": function(w) {
          w.uint(2479628082);
        },
        "help.countriesList": function(w, v) {
          w.uint(2278585758);
          w.vector(w.object, h(v, "countries"));
          w.int(h(v, "hash"));
        },
        "messageViews": function(w, v) {
          w.uint(1163625789);
          var flags = 0;
          var _views = v.views !== void 0;
          if (_views)
            flags |= 1;
          var _forwards = v.forwards !== void 0;
          if (_forwards)
            flags |= 2;
          var _replies = v.replies !== void 0;
          if (_replies)
            flags |= 4;
          w.uint(flags);
          if (_views)
            w.int(v.views);
          if (_forwards)
            w.int(v.forwards);
          if (_replies)
            w.object(v.replies);
        },
        "messages.messageViews": function(w, v) {
          w.uint(3066361155);
          w.vector(w.object, h(v, "views"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.discussionMessage": function(w, v) {
          w.uint(2788431746);
          var flags = 0;
          var _maxId = v.maxId !== void 0;
          if (_maxId)
            flags |= 1;
          var _readInboxMaxId = v.readInboxMaxId !== void 0;
          if (_readInboxMaxId)
            flags |= 2;
          var _readOutboxMaxId = v.readOutboxMaxId !== void 0;
          if (_readOutboxMaxId)
            flags |= 4;
          w.uint(flags);
          w.vector(w.object, h(v, "messages"));
          if (_maxId)
            w.int(v.maxId);
          if (_readInboxMaxId)
            w.int(v.readInboxMaxId);
          if (_readOutboxMaxId)
            w.int(v.readOutboxMaxId);
          w.int(h(v, "unreadCount"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messageReplyHeader": function(w, v) {
          w.uint(2948336091);
          var flags = 0;
          var _replyToPeerId = v.replyToPeerId !== void 0;
          if (_replyToPeerId)
            flags |= 1;
          var _replyToTopId = v.replyToTopId !== void 0;
          if (_replyToTopId)
            flags |= 2;
          if (v.replyToScheduled === true)
            flags |= 4;
          if (v.forumTopic === true)
            flags |= 8;
          var _replyToMsgId = v.replyToMsgId !== void 0;
          if (_replyToMsgId)
            flags |= 16;
          var _replyFrom = v.replyFrom !== void 0;
          if (_replyFrom)
            flags |= 32;
          var _quoteText = v.quoteText !== void 0;
          if (_quoteText)
            flags |= 64;
          var _quoteEntities = v.quoteEntities && v.quoteEntities.length;
          if (_quoteEntities)
            flags |= 128;
          var _replyMedia = v.replyMedia !== void 0;
          if (_replyMedia)
            flags |= 256;
          if (v.quote === true)
            flags |= 512;
          var _quoteOffset = v.quoteOffset !== void 0;
          if (_quoteOffset)
            flags |= 1024;
          w.uint(flags);
          if (_replyToMsgId)
            w.int(v.replyToMsgId);
          if (_replyToPeerId)
            w.object(v.replyToPeerId);
          if (_replyFrom)
            w.object(v.replyFrom);
          if (_replyMedia)
            w.object(v.replyMedia);
          if (_replyToTopId)
            w.int(v.replyToTopId);
          if (_quoteText)
            w.string(v.quoteText);
          if (_quoteEntities)
            w.vector(w.object, v.quoteEntities);
          if (_quoteOffset)
            w.int(v.quoteOffset);
        },
        "messageReplyStoryHeader": function(w, v) {
          w.uint(240843065);
          w.object(h(v, "peer"));
          w.int(h(v, "storyId"));
        },
        "messageReplies": function(w, v) {
          w.uint(2211844034);
          var flags = 0;
          var _channelId = v.channelId !== void 0;
          var _flags_0 = v.comments === true || _channelId;
          if (_flags_0)
            flags |= 1;
          var _recentRepliers = v.recentRepliers && v.recentRepliers.length;
          if (_recentRepliers)
            flags |= 2;
          var _maxId = v.maxId !== void 0;
          if (_maxId)
            flags |= 4;
          var _readMaxId = v.readMaxId !== void 0;
          if (_readMaxId)
            flags |= 8;
          w.uint(flags);
          w.int(h(v, "replies"));
          w.int(h(v, "repliesPts"));
          if (_recentRepliers)
            w.vector(w.object, v.recentRepliers);
          if (_flags_0)
            w.int53(v.channelId);
          if (_maxId)
            w.int(v.maxId);
          if (_readMaxId)
            w.int(v.readMaxId);
        },
        "peerBlocked": function(w, v) {
          w.uint(3908927508);
          w.object(h(v, "peerId"));
          w.int(h(v, "date"));
        },
        "stats.messageStats": function(w, v) {
          w.uint(2145983508);
          w.object(h(v, "viewsGraph"));
          w.object(h(v, "reactionsByEmotionGraph"));
        },
        "groupCallDiscarded": function(w, v) {
          w.uint(2004925620);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "duration"));
        },
        "groupCall": function(w, v) {
          w.uint(3583468812);
          var flags = 0;
          if (v.joinMuted === true)
            flags |= 2;
          if (v.canChangeJoinMuted === true)
            flags |= 4;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 8;
          var _streamDcId = v.streamDcId !== void 0;
          if (_streamDcId)
            flags |= 16;
          var _recordStartDate = v.recordStartDate !== void 0;
          if (_recordStartDate)
            flags |= 32;
          if (v.joinDateAsc === true)
            flags |= 64;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 128;
          if (v.scheduleStartSubscribed === true)
            flags |= 256;
          if (v.canStartVideo === true)
            flags |= 512;
          var _unmutedVideoCount = v.unmutedVideoCount !== void 0;
          if (_unmutedVideoCount)
            flags |= 1024;
          if (v.recordVideoActive === true)
            flags |= 2048;
          if (v.rtmpStream === true)
            flags |= 4096;
          if (v.listenersHidden === true)
            flags |= 8192;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.int(h(v, "participantsCount"));
          if (_title)
            w.string(v.title);
          if (_streamDcId)
            w.int(v.streamDcId);
          if (_recordStartDate)
            w.int(v.recordStartDate);
          if (_scheduleDate)
            w.int(v.scheduleDate);
          if (_unmutedVideoCount)
            w.int(v.unmutedVideoCount);
          w.int(h(v, "unmutedVideoLimit"));
          w.int(h(v, "version"));
        },
        "inputGroupCall": function(w, v) {
          w.uint(3635053583);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "groupCallParticipant": function(w, v) {
          w.uint(3953538814);
          var flags = 0;
          if (v.muted === true)
            flags |= 1;
          if (v.left === true)
            flags |= 2;
          if (v.canSelfUnmute === true)
            flags |= 4;
          var _activeDate = v.activeDate !== void 0;
          if (_activeDate)
            flags |= 8;
          if (v.justJoined === true)
            flags |= 16;
          if (v.versioned === true)
            flags |= 32;
          var _video = v.video !== void 0;
          if (_video)
            flags |= 64;
          var _volume = v.volume !== void 0;
          if (_volume)
            flags |= 128;
          if (v.min === true)
            flags |= 256;
          if (v.mutedByYou === true)
            flags |= 512;
          if (v.volumeByAdmin === true)
            flags |= 1024;
          var _about = v.about !== void 0;
          if (_about)
            flags |= 2048;
          if (v.self === true)
            flags |= 4096;
          var _raiseHandRating = v.raiseHandRating !== void 0;
          if (_raiseHandRating)
            flags |= 8192;
          var _presentation = v.presentation !== void 0;
          if (_presentation)
            flags |= 16384;
          if (v.videoJoined === true)
            flags |= 32768;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "date"));
          if (_activeDate)
            w.int(v.activeDate);
          w.int(h(v, "source"));
          if (_volume)
            w.int(v.volume);
          if (_about)
            w.string(v.about);
          if (_raiseHandRating)
            w.long(v.raiseHandRating);
          if (_video)
            w.object(v.video);
          if (_presentation)
            w.object(v.presentation);
        },
        "phone.groupCall": function(w, v) {
          w.uint(2658302637);
          w.object(h(v, "call"));
          w.vector(w.object, h(v, "participants"));
          w.string(h(v, "participantsNextOffset"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "phone.groupParticipants": function(w, v) {
          w.uint(4101460406);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "participants"));
          w.string(h(v, "nextOffset"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          w.int(h(v, "version"));
        },
        "inlineQueryPeerTypeSameBotPM": function(w) {
          w.uint(813821341);
        },
        "inlineQueryPeerTypePM": function(w) {
          w.uint(2201751468);
        },
        "inlineQueryPeerTypeChat": function(w) {
          w.uint(3613836554);
        },
        "inlineQueryPeerTypeMegagroup": function(w) {
          w.uint(1589952067);
        },
        "inlineQueryPeerTypeBroadcast": function(w) {
          w.uint(1664413338);
        },
        "inlineQueryPeerTypeBotPM": function(w) {
          w.uint(238759180);
        },
        "messages.historyImport": function(w, v) {
          w.uint(375566091);
          w.long(h(v, "id"));
        },
        "messages.historyImportParsed": function(w, v) {
          w.uint(1578088377);
          var flags = 0;
          if (v.pm === true)
            flags |= 1;
          if (v.group === true)
            flags |= 2;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 4;
          w.uint(flags);
          if (_title)
            w.string(v.title);
        },
        "messages.affectedFoundMessages": function(w, v) {
          w.uint(4019011180);
          w.int(h(v, "pts"));
          w.int(h(v, "ptsCount"));
          w.int(h(v, "offset"));
          w.vector(w.int, h(v, "messages"));
        },
        "chatInviteImporter": function(w, v) {
          w.uint(2354765785);
          var flags = 0;
          if (v.requested === true)
            flags |= 1;
          var _approvedBy = v.approvedBy !== void 0;
          if (_approvedBy)
            flags |= 2;
          var _about = v.about !== void 0;
          if (_about)
            flags |= 4;
          if (v.viaChatlist === true)
            flags |= 8;
          w.uint(flags);
          w.int53(h(v, "userId"));
          w.int(h(v, "date"));
          if (_about)
            w.string(v.about);
          if (_approvedBy)
            w.int53(v.approvedBy);
        },
        "messages.exportedChatInvites": function(w, v) {
          w.uint(3183881676);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "invites"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.exportedChatInvite": function(w, v) {
          w.uint(410107472);
          w.object(h(v, "invite"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.exportedChatInviteReplaced": function(w, v) {
          w.uint(572915951);
          w.object(h(v, "invite"));
          w.object(h(v, "newInvite"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.chatInviteImporters": function(w, v) {
          w.uint(2176233482);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "importers"));
          w.vector(w.object, h(v, "users"));
        },
        "chatAdminWithInvites": function(w, v) {
          w.uint(4075613987);
          w.int53(h(v, "adminId"));
          w.int(h(v, "invitesCount"));
          w.int(h(v, "revokedInvitesCount"));
        },
        "messages.chatAdminsWithInvites": function(w, v) {
          w.uint(3063640791);
          w.vector(w.object, h(v, "admins"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.checkedHistoryImportPeer": function(w, v) {
          w.uint(2723014423);
          w.string(h(v, "confirmText"));
        },
        "phone.joinAsPeers": function(w, v) {
          w.uint(2951045695);
          w.vector(w.object, h(v, "peers"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "phone.exportedGroupCallInvite": function(w, v) {
          w.uint(541839704);
          w.string(h(v, "link"));
        },
        "groupCallParticipantVideoSourceGroup": function(w, v) {
          w.uint(3702593719);
          w.string(h(v, "semantics"));
          w.vector(w.int, h(v, "sources"));
        },
        "groupCallParticipantVideo": function(w, v) {
          w.uint(1735736008);
          var flags = 0;
          if (v.paused === true)
            flags |= 1;
          var _audioSource = v.audioSource !== void 0;
          if (_audioSource)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "endpoint"));
          w.vector(w.object, h(v, "sourceGroups"));
          if (_audioSource)
            w.int(v.audioSource);
        },
        "stickers.suggestedShortName": function(w, v) {
          w.uint(2248056895);
          w.string(h(v, "shortName"));
        },
        "botCommandScopeDefault": function(w) {
          w.uint(795652779);
        },
        "botCommandScopeUsers": function(w) {
          w.uint(1011811544);
        },
        "botCommandScopeChats": function(w) {
          w.uint(1877059713);
        },
        "botCommandScopeChatAdmins": function(w) {
          w.uint(3114950762);
        },
        "botCommandScopePeer": function(w, v) {
          w.uint(3684534653);
          w.object(h(v, "peer"));
        },
        "botCommandScopePeerAdmins": function(w, v) {
          w.uint(1071145937);
          w.object(h(v, "peer"));
        },
        "botCommandScopePeerUser": function(w, v) {
          w.uint(169026035);
          w.object(h(v, "peer"));
          w.object(h(v, "userId"));
        },
        "account.resetPasswordFailedWait": function(w, v) {
          w.uint(3816265825);
          w.int(h(v, "retryDate"));
        },
        "account.resetPasswordRequestedWait": function(w, v) {
          w.uint(3924819069);
          w.int(h(v, "untilDate"));
        },
        "account.resetPasswordOk": function(w) {
          w.uint(3911636542);
        },
        "sponsoredMessage": function(w, v) {
          w.uint(1301522832);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          if (v.recommended === true)
            flags |= 32;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 64;
          var _sponsorInfo = v.sponsorInfo !== void 0;
          if (_sponsorInfo)
            flags |= 128;
          var _additionalInfo = v.additionalInfo !== void 0;
          if (_additionalInfo)
            flags |= 256;
          if (v.canReport === true)
            flags |= 4096;
          var _color = v.color !== void 0;
          if (_color)
            flags |= 8192;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 16384;
          w.uint(flags);
          w.bytes(h(v, "randomId"));
          w.string(h(v, "url"));
          w.string(h(v, "title"));
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_photo)
            w.object(v.photo);
          if (_media)
            w.object(v.media);
          if (_color)
            w.object(v.color);
          w.string(h(v, "buttonText"));
          if (_sponsorInfo)
            w.string(v.sponsorInfo);
          if (_additionalInfo)
            w.string(v.additionalInfo);
        },
        "messages.sponsoredMessages": function(w, v) {
          w.uint(3387825543);
          var flags = 0;
          var _postsBetween = v.postsBetween !== void 0;
          if (_postsBetween)
            flags |= 1;
          w.uint(flags);
          if (_postsBetween)
            w.int(v.postsBetween);
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.sponsoredMessagesEmpty": function(w) {
          w.uint(406407439);
        },
        "searchResultsCalendarPeriod": function(w, v) {
          w.uint(3383776159);
          w.int(h(v, "date"));
          w.int(h(v, "minMsgId"));
          w.int(h(v, "maxMsgId"));
          w.int(h(v, "count"));
        },
        "messages.searchResultsCalendar": function(w, v) {
          w.uint(343859772);
          var flags = 0;
          if (v.inexact === true)
            flags |= 1;
          var _offsetIdOffset = v.offsetIdOffset !== void 0;
          if (_offsetIdOffset)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "count"));
          w.int(h(v, "minDate"));
          w.int(h(v, "minMsgId"));
          if (_offsetIdOffset)
            w.int(v.offsetIdOffset);
          w.vector(w.object, h(v, "periods"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "searchResultPosition": function(w, v) {
          w.uint(2137295719);
          w.int(h(v, "msgId"));
          w.int(h(v, "date"));
          w.int(h(v, "offset"));
        },
        "messages.searchResultsPositions": function(w, v) {
          w.uint(1404185519);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "positions"));
        },
        "channels.sendAsPeers": function(w, v) {
          w.uint(4103516358);
          w.vector(w.object, h(v, "peers"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "users.userFull": function(w, v) {
          w.uint(997004590);
          w.object(h(v, "fullUser"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.peerSettings": function(w, v) {
          w.uint(1753266509);
          w.object(h(v, "settings"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "auth.loggedOut": function(w, v) {
          w.uint(3282207583);
          var flags = 0;
          var _futureAuthToken = v.futureAuthToken !== void 0;
          if (_futureAuthToken)
            flags |= 1;
          w.uint(flags);
          if (_futureAuthToken)
            w.bytes(v.futureAuthToken);
        },
        "reactionCount": function(w, v) {
          w.uint(2748435328);
          var flags = 0;
          var _chosenOrder = v.chosenOrder !== void 0;
          if (_chosenOrder)
            flags |= 1;
          w.uint(flags);
          if (_chosenOrder)
            w.int(v.chosenOrder);
          w.object(h(v, "reaction"));
          w.int(h(v, "count"));
        },
        "messageReactions": function(w, v) {
          w.uint(171155211);
          var flags = 0;
          if (v.min === true)
            flags |= 1;
          var _recentReactions = v.recentReactions && v.recentReactions.length;
          if (_recentReactions)
            flags |= 2;
          if (v.canSeeList === true)
            flags |= 4;
          if (v.reactionsAsTags === true)
            flags |= 8;
          var _topReactors = v.topReactors && v.topReactors.length;
          if (_topReactors)
            flags |= 16;
          w.uint(flags);
          w.vector(w.object, h(v, "results"));
          if (_recentReactions)
            w.vector(w.object, v.recentReactions);
          if (_topReactors)
            w.vector(w.object, v.topReactors);
        },
        "messages.messageReactionsList": function(w, v) {
          w.uint(834488621);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "reactions"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          if (_nextOffset)
            w.string(v.nextOffset);
        },
        "availableReaction": function(w, v) {
          w.uint(3229084673);
          var flags = 0;
          if (v.inactive === true)
            flags |= 1;
          var _aroundAnimation = v.aroundAnimation !== void 0;
          var _centerIcon = v.centerIcon !== void 0;
          var _flags_1 = _aroundAnimation || _centerIcon;
          if (_flags_1)
            flags |= 2;
          if (v.premium === true)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "reaction"));
          w.string(h(v, "title"));
          w.object(h(v, "staticIcon"));
          w.object(h(v, "appearAnimation"));
          w.object(h(v, "selectAnimation"));
          w.object(h(v, "activateAnimation"));
          w.object(h(v, "effectAnimation"));
          if (_flags_1)
            w.object(v.aroundAnimation);
          if (_flags_1)
            w.object(v.centerIcon);
        },
        "messages.availableReactionsNotModified": function(w) {
          w.uint(2668042583);
        },
        "messages.availableReactions": function(w, v) {
          w.uint(1989032621);
          w.int(h(v, "hash"));
          w.vector(w.object, h(v, "reactions"));
        },
        "messagePeerReaction": function(w, v) {
          w.uint(2356786748);
          var flags = 0;
          if (v.big === true)
            flags |= 1;
          if (v.unread === true)
            flags |= 2;
          if (v.my === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peerId"));
          w.int(h(v, "date"));
          w.object(h(v, "reaction"));
        },
        "groupCallStreamChannel": function(w, v) {
          w.uint(2162903215);
          w.int(h(v, "channel"));
          w.int(h(v, "scale"));
          w.long(h(v, "lastTimestampMs"));
        },
        "phone.groupCallStreamChannels": function(w, v) {
          w.uint(3504636594);
          w.vector(w.object, h(v, "channels"));
        },
        "phone.groupCallStreamRtmpUrl": function(w, v) {
          w.uint(767505458);
          w.string(h(v, "url"));
          w.string(h(v, "key"));
        },
        "attachMenuBotIconColor": function(w, v) {
          w.uint(1165423600);
          w.string(h(v, "name"));
          w.int(h(v, "color"));
        },
        "attachMenuBotIcon": function(w, v) {
          w.uint(2997303403);
          var flags = 0;
          var _colors = v.colors && v.colors.length;
          if (_colors)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "name"));
          w.object(h(v, "icon"));
          if (_colors)
            w.vector(w.object, v.colors);
        },
        "attachMenuBot": function(w, v) {
          w.uint(3641544190);
          var flags = 0;
          if (v.inactive === true)
            flags |= 1;
          if (v.hasSettings === true)
            flags |= 2;
          if (v.requestWriteAccess === true)
            flags |= 4;
          var _peerTypes = v.peerTypes && v.peerTypes.length;
          var _flags_3 = v.showInAttachMenu === true || _peerTypes;
          if (_flags_3)
            flags |= 8;
          if (v.showInSideMenu === true)
            flags |= 16;
          if (v.sideMenuDisclaimerNeeded === true)
            flags |= 32;
          w.uint(flags);
          w.int53(h(v, "botId"));
          w.string(h(v, "shortName"));
          if (_flags_3)
            w.vector(w.object, v.peerTypes);
          w.vector(w.object, h(v, "icons"));
        },
        "attachMenuBotsNotModified": function(w) {
          w.uint(4057500252);
        },
        "attachMenuBots": function(w, v) {
          w.uint(1011024320);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "bots"));
          w.vector(w.object, h(v, "users"));
        },
        "attachMenuBotsBot": function(w, v) {
          w.uint(2478794367);
          w.object(h(v, "bot"));
          w.vector(w.object, h(v, "users"));
        },
        "webViewResultUrl": function(w, v) {
          w.uint(1294139288);
          var flags = 0;
          var _queryId = v.queryId !== void 0;
          if (_queryId)
            flags |= 1;
          if (v.fullsize === true)
            flags |= 2;
          w.uint(flags);
          if (_queryId)
            w.long(v.queryId);
          w.string(h(v, "url"));
        },
        "webViewMessageSent": function(w, v) {
          w.uint(211046684);
          var flags = 0;
          var _msgId = v.msgId !== void 0;
          if (_msgId)
            flags |= 1;
          w.uint(flags);
          if (_msgId)
            w.object(v.msgId);
        },
        "botMenuButtonDefault": function(w) {
          w.uint(1966318984);
        },
        "botMenuButtonCommands": function(w) {
          w.uint(1113113093);
        },
        "botMenuButton": function(w, v) {
          w.uint(3350559974);
          w.string(h(v, "text"));
          w.string(h(v, "url"));
        },
        "account.savedRingtonesNotModified": function(w) {
          w.uint(4227262641);
        },
        "account.savedRingtones": function(w, v) {
          w.uint(3253284037);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "ringtones"));
        },
        "notificationSoundDefault": function(w) {
          w.uint(2548612798);
        },
        "notificationSoundNone": function(w) {
          w.uint(1863070943);
        },
        "notificationSoundLocal": function(w, v) {
          w.uint(2198575844);
          w.string(h(v, "title"));
          w.string(h(v, "data"));
        },
        "notificationSoundRingtone": function(w, v) {
          w.uint(4285300809);
          w.long(h(v, "id"));
        },
        "account.savedRingtone": function(w) {
          w.uint(3072737133);
        },
        "account.savedRingtoneConverted": function(w, v) {
          w.uint(523271863);
          w.object(h(v, "document"));
        },
        "attachMenuPeerTypeSameBotPM": function(w) {
          w.uint(2104224014);
        },
        "attachMenuPeerTypeBotPM": function(w) {
          w.uint(3274439194);
        },
        "attachMenuPeerTypePM": function(w) {
          w.uint(4047950623);
        },
        "attachMenuPeerTypeChat": function(w) {
          w.uint(84480319);
        },
        "attachMenuPeerTypeBroadcast": function(w) {
          w.uint(2080104188);
        },
        "inputInvoiceMessage": function(w, v) {
          w.uint(3317000281);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "inputInvoiceSlug": function(w, v) {
          w.uint(3274099439);
          w.string(h(v, "slug"));
        },
        "inputInvoicePremiumGiftCode": function(w, v) {
          w.uint(2560125965);
          w.object(h(v, "purpose"));
          w.object(h(v, "option"));
        },
        "inputInvoiceStars": function(w, v) {
          w.uint(1710230755);
          w.object(h(v, "purpose"));
        },
        "inputInvoiceChatInviteSubscription": function(w, v) {
          w.uint(887591921);
          w.string(h(v, "hash"));
        },
        "inputInvoiceStarGift": function(w, v) {
          w.uint(634962392);
          var flags = 0;
          if (v.hideName === true)
            flags |= 1;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "userId"));
          w.long(h(v, "giftId"));
          if (_message)
            w.object(v.message);
        },
        "payments.exportedInvoice": function(w, v) {
          w.uint(2932919257);
          w.string(h(v, "url"));
        },
        "messages.transcribedAudio": function(w, v) {
          w.uint(3485063511);
          var flags = 0;
          if (v.pending === true)
            flags |= 1;
          var _trialRemainsNum = v.trialRemainsNum !== void 0;
          var _trialRemainsUntilDate = v.trialRemainsUntilDate !== void 0;
          var _flags_1 = _trialRemainsNum || _trialRemainsUntilDate;
          if (_flags_1)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "transcriptionId"));
          w.string(h(v, "text"));
          if (_flags_1)
            w.int(v.trialRemainsNum);
          if (_flags_1)
            w.int(v.trialRemainsUntilDate);
        },
        "help.premiumPromo": function(w, v) {
          w.uint(1395946908);
          w.string(h(v, "statusText"));
          w.vector(w.object, h(v, "statusEntities"));
          w.vector(w.string, h(v, "videoSections"));
          w.vector(w.object, h(v, "videos"));
          w.vector(w.object, h(v, "periodOptions"));
          w.vector(w.object, h(v, "users"));
        },
        "inputStorePaymentPremiumSubscription": function(w, v) {
          w.uint(2792693350);
          var flags = 0;
          if (v.restore === true)
            flags |= 1;
          if (v.upgrade === true)
            flags |= 2;
          w.uint(flags);
        },
        "inputStorePaymentGiftPremium": function(w, v) {
          w.uint(1634697192);
          w.object(h(v, "userId"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "inputStorePaymentPremiumGiftCode": function(w, v) {
          w.uint(2743099199);
          var flags = 0;
          var _boostPeer = v.boostPeer !== void 0;
          if (_boostPeer)
            flags |= 1;
          w.uint(flags);
          w.vector(w.object, h(v, "users"));
          if (_boostPeer)
            w.object(v.boostPeer);
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "inputStorePaymentPremiumGiveaway": function(w, v) {
          w.uint(369444042);
          var flags = 0;
          if (v.onlyNewSubscribers === true)
            flags |= 1;
          var _additionalPeers = v.additionalPeers && v.additionalPeers.length;
          if (_additionalPeers)
            flags |= 2;
          var _countriesIso2 = v.countriesIso2 && v.countriesIso2.length;
          if (_countriesIso2)
            flags |= 4;
          if (v.winnersAreVisible === true)
            flags |= 8;
          var _prizeDescription = v.prizeDescription !== void 0;
          if (_prizeDescription)
            flags |= 16;
          w.uint(flags);
          w.object(h(v, "boostPeer"));
          if (_additionalPeers)
            w.vector(w.object, v.additionalPeers);
          if (_countriesIso2)
            w.vector(w.string, v.countriesIso2);
          if (_prizeDescription)
            w.string(v.prizeDescription);
          w.long(h(v, "randomId"));
          w.int(h(v, "untilDate"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "inputStorePaymentStarsTopup": function(w, v) {
          w.uint(3722252118);
          w.long(h(v, "stars"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "inputStorePaymentStarsGift": function(w, v) {
          w.uint(494149367);
          w.object(h(v, "userId"));
          w.long(h(v, "stars"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "inputStorePaymentStarsGiveaway": function(w, v) {
          w.uint(1964968186);
          var flags = 0;
          if (v.onlyNewSubscribers === true)
            flags |= 1;
          var _additionalPeers = v.additionalPeers && v.additionalPeers.length;
          if (_additionalPeers)
            flags |= 2;
          var _countriesIso2 = v.countriesIso2 && v.countriesIso2.length;
          if (_countriesIso2)
            flags |= 4;
          if (v.winnersAreVisible === true)
            flags |= 8;
          var _prizeDescription = v.prizeDescription !== void 0;
          if (_prizeDescription)
            flags |= 16;
          w.uint(flags);
          w.long(h(v, "stars"));
          w.object(h(v, "boostPeer"));
          if (_additionalPeers)
            w.vector(w.object, v.additionalPeers);
          if (_countriesIso2)
            w.vector(w.string, v.countriesIso2);
          if (_prizeDescription)
            w.string(v.prizeDescription);
          w.long(h(v, "randomId"));
          w.int(h(v, "untilDate"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
          w.int(h(v, "users"));
        },
        "premiumGiftOption": function(w, v) {
          w.uint(1958953753);
          var flags = 0;
          var _storeProduct = v.storeProduct !== void 0;
          if (_storeProduct)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "months"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
          w.string(h(v, "botUrl"));
          if (_storeProduct)
            w.string(v.storeProduct);
        },
        "paymentFormMethod": function(w, v) {
          w.uint(2298016283);
          w.string(h(v, "url"));
          w.string(h(v, "title"));
        },
        "emojiStatusEmpty": function(w) {
          w.uint(769727150);
        },
        "emojiStatus": function(w, v) {
          w.uint(2459656605);
          w.long(h(v, "documentId"));
        },
        "emojiStatusUntil": function(w, v) {
          w.uint(4197492935);
          w.long(h(v, "documentId"));
          w.int(h(v, "until"));
        },
        "account.emojiStatusesNotModified": function(w) {
          w.uint(3498894917);
        },
        "account.emojiStatuses": function(w, v) {
          w.uint(2428790737);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "statuses"));
        },
        "reactionEmpty": function(w) {
          w.uint(2046153753);
        },
        "reactionEmoji": function(w, v) {
          w.uint(455247544);
          w.string(h(v, "emoticon"));
        },
        "reactionCustomEmoji": function(w, v) {
          w.uint(2302016627);
          w.long(h(v, "documentId"));
        },
        "reactionPaid": function(w) {
          w.uint(1379771627);
        },
        "chatReactionsNone": function(w) {
          w.uint(3942396604);
        },
        "chatReactionsAll": function(w, v) {
          w.uint(1385335754);
          var flags = 0;
          if (v.allowCustom === true)
            flags |= 1;
          w.uint(flags);
        },
        "chatReactionsSome": function(w, v) {
          w.uint(1713193015);
          w.vector(w.object, h(v, "reactions"));
        },
        "messages.reactionsNotModified": function(w) {
          w.uint(2960120799);
        },
        "messages.reactions": function(w, v) {
          w.uint(3942512406);
          w.long(h(v, "hash"));
          w.vector(w.object, h(v, "reactions"));
        },
        "emailVerifyPurposeLoginSetup": function(w, v) {
          w.uint(1128644211);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
        },
        "emailVerifyPurposeLoginChange": function(w) {
          w.uint(1383932651);
        },
        "emailVerifyPurposePassport": function(w) {
          w.uint(3153401477);
        },
        "emailVerificationCode": function(w, v) {
          w.uint(2452510121);
          w.string(h(v, "code"));
        },
        "emailVerificationGoogle": function(w, v) {
          w.uint(3683688130);
          w.string(h(v, "token"));
        },
        "emailVerificationApple": function(w, v) {
          w.uint(2530243837);
          w.string(h(v, "token"));
        },
        "account.emailVerified": function(w, v) {
          w.uint(731303195);
          w.string(h(v, "email"));
        },
        "account.emailVerifiedLogin": function(w, v) {
          w.uint(3787132257);
          w.string(h(v, "email"));
          w.object(h(v, "sentCode"));
        },
        "premiumSubscriptionOption": function(w, v) {
          w.uint(1596792306);
          var flags = 0;
          var _storeProduct = v.storeProduct !== void 0;
          if (_storeProduct)
            flags |= 1;
          if (v.current === true)
            flags |= 2;
          if (v.canPurchaseUpgrade === true)
            flags |= 4;
          var _transaction = v.transaction !== void 0;
          if (_transaction)
            flags |= 8;
          w.uint(flags);
          if (_transaction)
            w.string(v.transaction);
          w.int(h(v, "months"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
          w.string(h(v, "botUrl"));
          if (_storeProduct)
            w.string(v.storeProduct);
        },
        "sendAsPeer": function(w, v) {
          w.uint(3088871476);
          var flags = 0;
          if (v.premiumRequired === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "messageExtendedMediaPreview": function(w, v) {
          w.uint(2908916936);
          var flags = 0;
          var _w = v.w !== void 0;
          var _h = v.h !== void 0;
          var _flags_0 = _w || _h;
          if (_flags_0)
            flags |= 1;
          var _thumb = v.thumb !== void 0;
          if (_thumb)
            flags |= 2;
          var _videoDuration = v.videoDuration !== void 0;
          if (_videoDuration)
            flags |= 4;
          w.uint(flags);
          if (_flags_0)
            w.int(v.w);
          if (_flags_0)
            w.int(v.h);
          if (_thumb)
            w.object(v.thumb);
          if (_videoDuration)
            w.int(v.videoDuration);
        },
        "messageExtendedMedia": function(w, v) {
          w.uint(3997670500);
          w.object(h(v, "media"));
        },
        "stickerKeyword": function(w, v) {
          w.uint(4244550300);
          w.long(h(v, "documentId"));
          w.vector(w.string, h(v, "keyword"));
        },
        "username": function(w, v) {
          w.uint(3020371527);
          var flags = 0;
          if (v.editable === true)
            flags |= 1;
          if (v.active === true)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "username"));
        },
        "forumTopicDeleted": function(w, v) {
          w.uint(37687451);
          w.int(h(v, "id"));
        },
        "forumTopic": function(w, v) {
          w.uint(1903173033);
          var flags = 0;
          var _iconEmojiId = v.iconEmojiId !== void 0;
          if (_iconEmojiId)
            flags |= 1;
          if (v.my === true)
            flags |= 2;
          if (v.closed === true)
            flags |= 4;
          if (v.pinned === true)
            flags |= 8;
          var _draft = v.draft !== void 0;
          if (_draft)
            flags |= 16;
          if (v.short === true)
            flags |= 32;
          if (v.hidden === true)
            flags |= 64;
          w.uint(flags);
          w.int(h(v, "id"));
          w.int(h(v, "date"));
          w.string(h(v, "title"));
          w.int(h(v, "iconColor"));
          if (_iconEmojiId)
            w.long(v.iconEmojiId);
          w.int(h(v, "topMessage"));
          w.int(h(v, "readInboxMaxId"));
          w.int(h(v, "readOutboxMaxId"));
          w.int(h(v, "unreadCount"));
          w.int(h(v, "unreadMentionsCount"));
          w.int(h(v, "unreadReactionsCount"));
          w.object(h(v, "fromId"));
          w.object(h(v, "notifySettings"));
          if (_draft)
            w.object(v.draft);
        },
        "messages.forumTopics": function(w, v) {
          w.uint(913709011);
          var flags = 0;
          if (v.orderByCreateDate === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "topics"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          w.int(h(v, "pts"));
        },
        "defaultHistoryTTL": function(w, v) {
          w.uint(1135897376);
          w.int(h(v, "period"));
        },
        "exportedContactToken": function(w, v) {
          w.uint(1103040667);
          w.string(h(v, "url"));
          w.int(h(v, "expires"));
        },
        "requestPeerTypeUser": function(w, v) {
          w.uint(1597737472);
          var flags = 0;
          var _bot = v.bot !== void 0;
          if (_bot)
            flags |= 1;
          var _premium = v.premium !== void 0;
          if (_premium)
            flags |= 2;
          w.uint(flags);
          if (_bot)
            w.boolean(v.bot);
          if (_premium)
            w.boolean(v.premium);
        },
        "requestPeerTypeChat": function(w, v) {
          w.uint(3387977243);
          var flags = 0;
          if (v.creator === true)
            flags |= 1;
          var _userAdminRights = v.userAdminRights !== void 0;
          if (_userAdminRights)
            flags |= 2;
          var _botAdminRights = v.botAdminRights !== void 0;
          if (_botAdminRights)
            flags |= 4;
          var _hasUsername = v.hasUsername !== void 0;
          if (_hasUsername)
            flags |= 8;
          var _forum = v.forum !== void 0;
          if (_forum)
            flags |= 16;
          if (v.botParticipant === true)
            flags |= 32;
          w.uint(flags);
          if (_hasUsername)
            w.boolean(v.hasUsername);
          if (_forum)
            w.boolean(v.forum);
          if (_userAdminRights)
            w.object(v.userAdminRights);
          if (_botAdminRights)
            w.object(v.botAdminRights);
        },
        "requestPeerTypeBroadcast": function(w, v) {
          w.uint(865857388);
          var flags = 0;
          if (v.creator === true)
            flags |= 1;
          var _userAdminRights = v.userAdminRights !== void 0;
          if (_userAdminRights)
            flags |= 2;
          var _botAdminRights = v.botAdminRights !== void 0;
          if (_botAdminRights)
            flags |= 4;
          var _hasUsername = v.hasUsername !== void 0;
          if (_hasUsername)
            flags |= 8;
          w.uint(flags);
          if (_hasUsername)
            w.boolean(v.hasUsername);
          if (_userAdminRights)
            w.object(v.userAdminRights);
          if (_botAdminRights)
            w.object(v.botAdminRights);
        },
        "emojiListNotModified": function(w) {
          w.uint(1209970170);
        },
        "emojiList": function(w, v) {
          w.uint(2048790993);
          w.long(h(v, "hash"));
          w.vector(w.long, h(v, "documentId"));
        },
        "emojiGroup": function(w, v) {
          w.uint(2056961449);
          w.string(h(v, "title"));
          w.long(h(v, "iconEmojiId"));
          w.vector(w.string, h(v, "emoticons"));
        },
        "emojiGroupGreeting": function(w, v) {
          w.uint(2161274055);
          w.string(h(v, "title"));
          w.long(h(v, "iconEmojiId"));
          w.vector(w.string, h(v, "emoticons"));
        },
        "emojiGroupPremium": function(w, v) {
          w.uint(154914612);
          w.string(h(v, "title"));
          w.long(h(v, "iconEmojiId"));
        },
        "messages.emojiGroupsNotModified": function(w) {
          w.uint(1874111879);
        },
        "messages.emojiGroups": function(w, v) {
          w.uint(2283780427);
          w.int(h(v, "hash"));
          w.vector(w.object, h(v, "groups"));
        },
        "textWithEntities": function(w, v) {
          w.uint(1964978502);
          w.string(h(v, "text"));
          w.vector(w.object, h(v, "entities"));
        },
        "messages.translateResult": function(w, v) {
          w.uint(870003448);
          w.vector(w.object, h(v, "result"));
        },
        "autoSaveSettings": function(w, v) {
          w.uint(3360175310);
          var flags = 0;
          if (v.photos === true)
            flags |= 1;
          if (v.videos === true)
            flags |= 2;
          var _videoMaxSize = v.videoMaxSize !== void 0;
          if (_videoMaxSize)
            flags |= 4;
          w.uint(flags);
          if (_videoMaxSize)
            w.long(v.videoMaxSize);
        },
        "autoSaveException": function(w, v) {
          w.uint(2170563911);
          w.object(h(v, "peer"));
          w.object(h(v, "settings"));
        },
        "account.autoSaveSettings": function(w, v) {
          w.uint(1279133341);
          w.object(h(v, "usersSettings"));
          w.object(h(v, "chatsSettings"));
          w.object(h(v, "broadcastsSettings"));
          w.vector(w.object, h(v, "exceptions"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "help.appConfigNotModified": function(w) {
          w.uint(2094949405);
        },
        "help.appConfig": function(w, v) {
          w.uint(3709368366);
          w.int(h(v, "hash"));
          w.object(h(v, "config"));
        },
        "inputBotAppID": function(w, v) {
          w.uint(2837495162);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
        },
        "inputBotAppShortName": function(w, v) {
          w.uint(2425095175);
          w.object(h(v, "botId"));
          w.string(h(v, "shortName"));
        },
        "botAppNotModified": function(w) {
          w.uint(1571189943);
        },
        "botApp": function(w, v) {
          w.uint(2516373974);
          var flags = 0;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "id"));
          w.long(h(v, "accessHash"));
          w.string(h(v, "shortName"));
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          w.object(h(v, "photo"));
          if (_document)
            w.object(v.document);
          w.long(h(v, "hash"));
        },
        "messages.botApp": function(w, v) {
          w.uint(3947933173);
          var flags = 0;
          if (v.inactive === true)
            flags |= 1;
          if (v.requestWriteAccess === true)
            flags |= 2;
          if (v.hasSettings === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "app"));
        },
        "inlineBotWebView": function(w, v) {
          w.uint(3044185557);
          w.string(h(v, "text"));
          w.string(h(v, "url"));
        },
        "readParticipantDate": function(w, v) {
          w.uint(1246753138);
          w.int53(h(v, "userId"));
          w.int(h(v, "date"));
        },
        "inputChatlistDialogFilter": function(w, v) {
          w.uint(4091599411);
          w.int(h(v, "filterId"));
        },
        "exportedChatlistInvite": function(w, v) {
          w.uint(206668204);
          var flags = 0;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "url"));
          w.vector(w.object, h(v, "peers"));
        },
        "chatlists.exportedChatlistInvite": function(w, v) {
          w.uint(283567014);
          w.object(h(v, "filter"));
          w.object(h(v, "invite"));
        },
        "chatlists.exportedInvites": function(w, v) {
          w.uint(279670215);
          w.vector(w.object, h(v, "invites"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "chatlists.chatlistInviteAlready": function(w, v) {
          w.uint(4203214425);
          w.int(h(v, "filterId"));
          w.vector(w.object, h(v, "missingPeers"));
          w.vector(w.object, h(v, "alreadyPeers"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "chatlists.chatlistInvite": function(w, v) {
          w.uint(500007837);
          var flags = 0;
          var _emoticon = v.emoticon !== void 0;
          if (_emoticon)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "title"));
          if (_emoticon)
            w.string(v.emoticon);
          w.vector(w.object, h(v, "peers"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "chatlists.chatlistUpdates": function(w, v) {
          w.uint(2478671757);
          w.vector(w.object, h(v, "missingPeers"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "bots.botInfo": function(w, v) {
          w.uint(3903288752);
          w.string(h(v, "name"));
          w.string(h(v, "about"));
          w.string(h(v, "description"));
        },
        "messagePeerVote": function(w, v) {
          w.uint(3066834268);
          w.object(h(v, "peer"));
          w.bytes(h(v, "option"));
          w.int(h(v, "date"));
        },
        "messagePeerVoteInputOption": function(w, v) {
          w.uint(1959634180);
          w.object(h(v, "peer"));
          w.int(h(v, "date"));
        },
        "messagePeerVoteMultiple": function(w, v) {
          w.uint(1177089766);
          w.object(h(v, "peer"));
          w.vector(w.bytes, h(v, "options"));
          w.int(h(v, "date"));
        },
        "storyViews": function(w, v) {
          w.uint(2371443926);
          var flags = 0;
          var _recentViewers = v.recentViewers && v.recentViewers.length;
          if (_recentViewers)
            flags |= 1;
          if (v.hasViewers === true)
            flags |= 2;
          var _forwardsCount = v.forwardsCount !== void 0;
          if (_forwardsCount)
            flags |= 4;
          var _reactions = v.reactions && v.reactions.length;
          if (_reactions)
            flags |= 8;
          var _reactionsCount = v.reactionsCount !== void 0;
          if (_reactionsCount)
            flags |= 16;
          w.uint(flags);
          w.int(h(v, "viewsCount"));
          if (_forwardsCount)
            w.int(v.forwardsCount);
          if (_reactions)
            w.vector(w.object, v.reactions);
          if (_reactionsCount)
            w.int(v.reactionsCount);
          if (_recentViewers)
            w.vector(w.int53, v.recentViewers);
        },
        "storyItemDeleted": function(w, v) {
          w.uint(1374088783);
          w.int(h(v, "id"));
        },
        "storyItemSkipped": function(w, v) {
          w.uint(4289579283);
          var flags = 0;
          if (v.closeFriends === true)
            flags |= 256;
          w.uint(flags);
          w.int(h(v, "id"));
          w.int(h(v, "date"));
          w.int(h(v, "expireDate"));
        },
        "storyItem": function(w, v) {
          w.uint(2041735716);
          var flags = 0;
          var _caption = v.caption !== void 0;
          if (_caption)
            flags |= 1;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          var _privacy = v.privacy && v.privacy.length;
          if (_privacy)
            flags |= 4;
          var _views = v.views !== void 0;
          if (_views)
            flags |= 8;
          if (v.pinned === true)
            flags |= 32;
          if (v.public === true)
            flags |= 128;
          if (v.closeFriends === true)
            flags |= 256;
          if (v.min === true)
            flags |= 512;
          if (v.noforwards === true)
            flags |= 1024;
          if (v.edited === true)
            flags |= 2048;
          if (v.contacts === true)
            flags |= 4096;
          if (v.selectedContacts === true)
            flags |= 8192;
          var _mediaAreas = v.mediaAreas && v.mediaAreas.length;
          if (_mediaAreas)
            flags |= 16384;
          var _sentReaction = v.sentReaction !== void 0;
          if (_sentReaction)
            flags |= 32768;
          if (v.out === true)
            flags |= 65536;
          var _fwdFrom = v.fwdFrom !== void 0;
          if (_fwdFrom)
            flags |= 131072;
          var _fromId = v.fromId !== void 0;
          if (_fromId)
            flags |= 262144;
          w.uint(flags);
          w.int(h(v, "id"));
          w.int(h(v, "date"));
          if (_fromId)
            w.object(v.fromId);
          if (_fwdFrom)
            w.object(v.fwdFrom);
          w.int(h(v, "expireDate"));
          if (_caption)
            w.string(v.caption);
          if (_entities)
            w.vector(w.object, v.entities);
          w.object(h(v, "media"));
          if (_mediaAreas)
            w.vector(w.object, v.mediaAreas);
          if (_privacy)
            w.vector(w.object, v.privacy);
          if (_views)
            w.object(v.views);
          if (_sentReaction)
            w.object(v.sentReaction);
        },
        "stories.allStoriesNotModified": function(w, v) {
          w.uint(291044926);
          var flags = 0;
          w.uint(flags);
          w.string(h(v, "state"));
          w.object(h(v, "stealthMode"));
        },
        "stories.allStories": function(w, v) {
          w.uint(1862033025);
          var flags = 0;
          if (v.hasMore === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.string(h(v, "state"));
          w.vector(w.object, h(v, "peerStories"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          w.object(h(v, "stealthMode"));
        },
        "stories.stories": function(w, v) {
          w.uint(1673780490);
          var flags = 0;
          var _pinnedToTop = v.pinnedToTop && v.pinnedToTop.length;
          if (_pinnedToTop)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "stories"));
          if (_pinnedToTop)
            w.vector(w.int, v.pinnedToTop);
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "storyView": function(w, v) {
          w.uint(2965236421);
          var flags = 0;
          if (v.blocked === true)
            flags |= 1;
          if (v.blockedMyStoriesFrom === true)
            flags |= 2;
          var _reaction = v.reaction !== void 0;
          if (_reaction)
            flags |= 4;
          w.uint(flags);
          w.int53(h(v, "userId"));
          w.int(h(v, "date"));
          if (_reaction)
            w.object(v.reaction);
        },
        "storyViewPublicForward": function(w, v) {
          w.uint(2424530699);
          var flags = 0;
          if (v.blocked === true)
            flags |= 1;
          if (v.blockedMyStoriesFrom === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "message"));
        },
        "storyViewPublicRepost": function(w, v) {
          w.uint(3178549065);
          var flags = 0;
          if (v.blocked === true)
            flags |= 1;
          if (v.blockedMyStoriesFrom === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peerId"));
          w.object(h(v, "story"));
        },
        "stories.storyViewsList": function(w, v) {
          w.uint(1507299269);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.int(h(v, "viewsCount"));
          w.int(h(v, "forwardsCount"));
          w.int(h(v, "reactionsCount"));
          w.vector(w.object, h(v, "views"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          if (_nextOffset)
            w.string(v.nextOffset);
        },
        "stories.storyViews": function(w, v) {
          w.uint(3734957341);
          w.vector(w.object, h(v, "views"));
          w.vector(w.object, h(v, "users"));
        },
        "inputReplyToMessage": function(w, v) {
          w.uint(583071445);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          var _replyToPeerId = v.replyToPeerId !== void 0;
          if (_replyToPeerId)
            flags |= 2;
          var _quoteText = v.quoteText !== void 0;
          if (_quoteText)
            flags |= 4;
          var _quoteEntities = v.quoteEntities && v.quoteEntities.length;
          if (_quoteEntities)
            flags |= 8;
          var _quoteOffset = v.quoteOffset !== void 0;
          if (_quoteOffset)
            flags |= 16;
          w.uint(flags);
          w.int(h(v, "replyToMsgId"));
          if (_topMsgId)
            w.int(v.topMsgId);
          if (_replyToPeerId)
            w.object(v.replyToPeerId);
          if (_quoteText)
            w.string(v.quoteText);
          if (_quoteEntities)
            w.vector(w.object, v.quoteEntities);
          if (_quoteOffset)
            w.int(v.quoteOffset);
        },
        "inputReplyToStory": function(w, v) {
          w.uint(1484862010);
          w.object(h(v, "peer"));
          w.int(h(v, "storyId"));
        },
        "exportedStoryLink": function(w, v) {
          w.uint(1070138683);
          w.string(h(v, "link"));
        },
        "storiesStealthMode": function(w, v) {
          w.uint(1898850301);
          var flags = 0;
          var _activeUntilDate = v.activeUntilDate !== void 0;
          if (_activeUntilDate)
            flags |= 1;
          var _cooldownUntilDate = v.cooldownUntilDate !== void 0;
          if (_cooldownUntilDate)
            flags |= 2;
          w.uint(flags);
          if (_activeUntilDate)
            w.int(v.activeUntilDate);
          if (_cooldownUntilDate)
            w.int(v.cooldownUntilDate);
        },
        "mediaAreaCoordinates": function(w, v) {
          w.uint(3486113794);
          var flags = 0;
          var _radius = v.radius !== void 0;
          if (_radius)
            flags |= 1;
          w.uint(flags);
          w.double(h(v, "x"));
          w.double(h(v, "y"));
          w.double(h(v, "w"));
          w.double(h(v, "h"));
          w.double(h(v, "rotation"));
          if (_radius)
            w.double(v.radius);
        },
        "mediaAreaVenue": function(w, v) {
          w.uint(3196246940);
          w.object(h(v, "coordinates"));
          w.object(h(v, "geo"));
          w.string(h(v, "title"));
          w.string(h(v, "address"));
          w.string(h(v, "provider"));
          w.string(h(v, "venueId"));
          w.string(h(v, "venueType"));
        },
        "inputMediaAreaVenue": function(w, v) {
          w.uint(2994872703);
          w.object(h(v, "coordinates"));
          w.long(h(v, "queryId"));
          w.string(h(v, "resultId"));
        },
        "mediaAreaGeoPoint": function(w, v) {
          w.uint(3402974509);
          var flags = 0;
          var _address = v.address !== void 0;
          if (_address)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "coordinates"));
          w.object(h(v, "geo"));
          if (_address)
            w.object(v.address);
        },
        "mediaAreaSuggestedReaction": function(w, v) {
          w.uint(340088945);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          if (v.flipped === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "coordinates"));
          w.object(h(v, "reaction"));
        },
        "mediaAreaChannelPost": function(w, v) {
          w.uint(1996756655);
          w.object(h(v, "coordinates"));
          w.int53(h(v, "channelId"));
          w.int(h(v, "msgId"));
        },
        "inputMediaAreaChannelPost": function(w, v) {
          w.uint(577893055);
          w.object(h(v, "coordinates"));
          w.object(h(v, "channel"));
          w.int(h(v, "msgId"));
        },
        "mediaAreaUrl": function(w, v) {
          w.uint(926421125);
          w.object(h(v, "coordinates"));
          w.string(h(v, "url"));
        },
        "mediaAreaWeather": function(w, v) {
          w.uint(1235637404);
          w.object(h(v, "coordinates"));
          w.string(h(v, "emoji"));
          w.double(h(v, "temperatureC"));
          w.int(h(v, "color"));
        },
        "peerStories": function(w, v) {
          w.uint(2587224473);
          var flags = 0;
          var _maxReadId = v.maxReadId !== void 0;
          if (_maxReadId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_maxReadId)
            w.int(v.maxReadId);
          w.vector(w.object, h(v, "stories"));
        },
        "stories.peerStories": function(w, v) {
          w.uint(3404105576);
          w.object(h(v, "stories"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.webPage": function(w, v) {
          w.uint(4250800829);
          w.object(h(v, "webpage"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "premiumGiftCodeOption": function(w, v) {
          w.uint(629052971);
          var flags = 0;
          var _storeProduct = v.storeProduct !== void 0;
          if (_storeProduct)
            flags |= 1;
          var _storeQuantity = v.storeQuantity !== void 0;
          if (_storeQuantity)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "users"));
          w.int(h(v, "months"));
          if (_storeProduct)
            w.string(v.storeProduct);
          if (_storeQuantity)
            w.int(v.storeQuantity);
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "payments.checkedGiftCode": function(w, v) {
          w.uint(675942550);
          var flags = 0;
          var _toId = v.toId !== void 0;
          if (_toId)
            flags |= 1;
          var _usedDate = v.usedDate !== void 0;
          if (_usedDate)
            flags |= 2;
          if (v.viaGiveaway === true)
            flags |= 4;
          var _giveawayMsgId = v.giveawayMsgId !== void 0;
          if (_giveawayMsgId)
            flags |= 8;
          var _fromId = v.fromId !== void 0;
          if (_fromId)
            flags |= 16;
          w.uint(flags);
          if (_fromId)
            w.object(v.fromId);
          if (_giveawayMsgId)
            w.int(v.giveawayMsgId);
          if (_toId)
            w.long(v.toId);
          w.int(h(v, "date"));
          w.int(h(v, "months"));
          if (_usedDate)
            w.int(v.usedDate);
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "payments.giveawayInfo": function(w, v) {
          w.uint(1130879648);
          var flags = 0;
          if (v.participating === true)
            flags |= 1;
          var _joinedTooEarlyDate = v.joinedTooEarlyDate !== void 0;
          if (_joinedTooEarlyDate)
            flags |= 2;
          var _adminDisallowedChatId = v.adminDisallowedChatId !== void 0;
          if (_adminDisallowedChatId)
            flags |= 4;
          if (v.preparingResults === true)
            flags |= 8;
          var _disallowedCountry = v.disallowedCountry !== void 0;
          if (_disallowedCountry)
            flags |= 16;
          w.uint(flags);
          w.int(h(v, "startDate"));
          if (_joinedTooEarlyDate)
            w.int(v.joinedTooEarlyDate);
          if (_adminDisallowedChatId)
            w.long(v.adminDisallowedChatId);
          if (_disallowedCountry)
            w.string(v.disallowedCountry);
        },
        "payments.giveawayInfoResults": function(w, v) {
          w.uint(3782600303);
          var flags = 0;
          if (v.winner === true)
            flags |= 1;
          if (v.refunded === true)
            flags |= 2;
          var _activatedCount = v.activatedCount !== void 0;
          if (_activatedCount)
            flags |= 4;
          var _giftCodeSlug = v.giftCodeSlug !== void 0;
          if (_giftCodeSlug)
            flags |= 8;
          var _starsPrize = v.starsPrize !== void 0;
          if (_starsPrize)
            flags |= 16;
          w.uint(flags);
          w.int(h(v, "startDate"));
          if (_giftCodeSlug)
            w.string(v.giftCodeSlug);
          if (_starsPrize)
            w.long(v.starsPrize);
          w.int(h(v, "finishDate"));
          w.int(h(v, "winnersCount"));
          if (_activatedCount)
            w.int(v.activatedCount);
        },
        "prepaidGiveaway": function(w, v) {
          w.uint(2991824212);
          w.long(h(v, "id"));
          w.int(h(v, "months"));
          w.int(h(v, "quantity"));
          w.int(h(v, "date"));
        },
        "prepaidStarsGiveaway": function(w, v) {
          w.uint(2594011104);
          w.long(h(v, "id"));
          w.long(h(v, "stars"));
          w.int(h(v, "quantity"));
          w.int(h(v, "boosts"));
          w.int(h(v, "date"));
        },
        "boost": function(w, v) {
          w.uint(1262359766);
          var flags = 0;
          var _userId = v.userId !== void 0;
          if (_userId)
            flags |= 1;
          if (v.gift === true)
            flags |= 2;
          var _giveawayMsgId = v.giveawayMsgId !== void 0;
          var _flags_2 = v.giveaway === true || _giveawayMsgId;
          if (_flags_2)
            flags |= 4;
          if (v.unclaimed === true)
            flags |= 8;
          var _usedGiftSlug = v.usedGiftSlug !== void 0;
          if (_usedGiftSlug)
            flags |= 16;
          var _multiplier = v.multiplier !== void 0;
          if (_multiplier)
            flags |= 32;
          var _stars = v.stars !== void 0;
          if (_stars)
            flags |= 64;
          w.uint(flags);
          w.string(h(v, "id"));
          if (_userId)
            w.int53(v.userId);
          if (_flags_2)
            w.int(v.giveawayMsgId);
          w.int(h(v, "date"));
          w.int(h(v, "expires"));
          if (_usedGiftSlug)
            w.string(v.usedGiftSlug);
          if (_multiplier)
            w.int(v.multiplier);
          if (_stars)
            w.long(v.stars);
        },
        "premium.boostsList": function(w, v) {
          w.uint(2264424764);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "boosts"));
          if (_nextOffset)
            w.string(v.nextOffset);
          w.vector(w.object, h(v, "users"));
        },
        "myBoost": function(w, v) {
          w.uint(3293069660);
          var flags = 0;
          var _peer = v.peer !== void 0;
          if (_peer)
            flags |= 1;
          var _cooldownUntilDate = v.cooldownUntilDate !== void 0;
          if (_cooldownUntilDate)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "slot"));
          if (_peer)
            w.object(v.peer);
          w.int(h(v, "date"));
          w.int(h(v, "expires"));
          if (_cooldownUntilDate)
            w.int(v.cooldownUntilDate);
        },
        "premium.myBoosts": function(w, v) {
          w.uint(2598512866);
          w.vector(w.object, h(v, "myBoosts"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "premium.boostsStatus": function(w, v) {
          w.uint(1230586490);
          var flags = 0;
          var _nextLevelBoosts = v.nextLevelBoosts !== void 0;
          if (_nextLevelBoosts)
            flags |= 1;
          var _premiumAudience = v.premiumAudience !== void 0;
          if (_premiumAudience)
            flags |= 2;
          var _myBoostSlots = v.myBoostSlots && v.myBoostSlots.length;
          var _flags_2 = v.myBoost === true || _myBoostSlots;
          if (_flags_2)
            flags |= 4;
          var _prepaidGiveaways = v.prepaidGiveaways && v.prepaidGiveaways.length;
          if (_prepaidGiveaways)
            flags |= 8;
          var _giftBoosts = v.giftBoosts !== void 0;
          if (_giftBoosts)
            flags |= 16;
          w.uint(flags);
          w.int(h(v, "level"));
          w.int(h(v, "currentLevelBoosts"));
          w.int(h(v, "boosts"));
          if (_giftBoosts)
            w.int(v.giftBoosts);
          if (_nextLevelBoosts)
            w.int(v.nextLevelBoosts);
          if (_premiumAudience)
            w.object(v.premiumAudience);
          w.string(h(v, "boostUrl"));
          if (_prepaidGiveaways)
            w.vector(w.object, v.prepaidGiveaways);
          if (_flags_2)
            w.vector(w.int, v.myBoostSlots);
        },
        "storyFwdHeader": function(w, v) {
          w.uint(3089555792);
          var flags = 0;
          var _from = v.from !== void 0;
          if (_from)
            flags |= 1;
          var _fromName = v.fromName !== void 0;
          if (_fromName)
            flags |= 2;
          var _storyId = v.storyId !== void 0;
          if (_storyId)
            flags |= 4;
          if (v.modified === true)
            flags |= 8;
          w.uint(flags);
          if (_from)
            w.object(v.from);
          if (_fromName)
            w.string(v.fromName);
          if (_storyId)
            w.int(v.storyId);
        },
        "postInteractionCountersMessage": function(w, v) {
          w.uint(3875901055);
          w.int(h(v, "msgId"));
          w.int(h(v, "views"));
          w.int(h(v, "forwards"));
          w.int(h(v, "reactions"));
        },
        "postInteractionCountersStory": function(w, v) {
          w.uint(2319978023);
          w.int(h(v, "storyId"));
          w.int(h(v, "views"));
          w.int(h(v, "forwards"));
          w.int(h(v, "reactions"));
        },
        "stats.storyStats": function(w, v) {
          w.uint(1355613820);
          w.object(h(v, "viewsGraph"));
          w.object(h(v, "reactionsByEmotionGraph"));
        },
        "publicForwardMessage": function(w, v) {
          w.uint(32685898);
          w.object(h(v, "message"));
        },
        "publicForwardStory": function(w, v) {
          w.uint(3992169936);
          w.object(h(v, "peer"));
          w.object(h(v, "story"));
        },
        "stats.publicForwards": function(w, v) {
          w.uint(2466479648);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "forwards"));
          if (_nextOffset)
            w.string(v.nextOffset);
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "peerColor": function(w, v) {
          w.uint(3041614543);
          var flags = 0;
          var _color = v.color !== void 0;
          if (_color)
            flags |= 1;
          var _backgroundEmojiId = v.backgroundEmojiId !== void 0;
          if (_backgroundEmojiId)
            flags |= 2;
          w.uint(flags);
          if (_color)
            w.int(v.color);
          if (_backgroundEmojiId)
            w.long(v.backgroundEmojiId);
        },
        "help.peerColorSet": function(w, v) {
          w.uint(639736408);
          w.vector(w.int, h(v, "colors"));
        },
        "help.peerColorProfileSet": function(w, v) {
          w.uint(1987928555);
          w.vector(w.int, h(v, "paletteColors"));
          w.vector(w.int, h(v, "bgColors"));
          w.vector(w.int, h(v, "storyColors"));
        },
        "help.peerColorOption": function(w, v) {
          w.uint(2917953214);
          var flags = 0;
          if (v.hidden === true)
            flags |= 1;
          var _colors = v.colors !== void 0;
          if (_colors)
            flags |= 2;
          var _darkColors = v.darkColors !== void 0;
          if (_darkColors)
            flags |= 4;
          var _channelMinLevel = v.channelMinLevel !== void 0;
          if (_channelMinLevel)
            flags |= 8;
          var _groupMinLevel = v.groupMinLevel !== void 0;
          if (_groupMinLevel)
            flags |= 16;
          w.uint(flags);
          w.int(h(v, "colorId"));
          if (_colors)
            w.object(v.colors);
          if (_darkColors)
            w.object(v.darkColors);
          if (_channelMinLevel)
            w.int(v.channelMinLevel);
          if (_groupMinLevel)
            w.int(v.groupMinLevel);
        },
        "help.peerColorsNotModified": function(w) {
          w.uint(732034510);
        },
        "help.peerColors": function(w, v) {
          w.uint(16313608);
          w.int(h(v, "hash"));
          w.vector(w.object, h(v, "colors"));
        },
        "storyReaction": function(w, v) {
          w.uint(1620104917);
          w.object(h(v, "peerId"));
          w.int(h(v, "date"));
          w.object(h(v, "reaction"));
        },
        "storyReactionPublicForward": function(w, v) {
          w.uint(3148555843);
          w.object(h(v, "message"));
        },
        "storyReactionPublicRepost": function(w, v) {
          w.uint(3486322451);
          w.object(h(v, "peerId"));
          w.object(h(v, "story"));
        },
        "stories.storyReactionsList": function(w, v) {
          w.uint(2858383516);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "reactions"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
          if (_nextOffset)
            w.string(v.nextOffset);
        },
        "savedDialog": function(w, v) {
          w.uint(3179793260);
          var flags = 0;
          if (v.pinned === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "topMessage"));
        },
        "messages.savedDialogs": function(w, v) {
          w.uint(4164608545);
          w.vector(w.object, h(v, "dialogs"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.savedDialogsSlice": function(w, v) {
          w.uint(1153080793);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "dialogs"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.savedDialogsNotModified": function(w, v) {
          w.uint(3223285736);
          w.int(h(v, "count"));
        },
        "savedReactionTag": function(w, v) {
          w.uint(3413112872);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "reaction"));
          if (_title)
            w.string(v.title);
          w.int(h(v, "count"));
        },
        "messages.savedReactionTagsNotModified": function(w) {
          w.uint(2291882479);
        },
        "messages.savedReactionTags": function(w, v) {
          w.uint(844731658);
          w.vector(w.object, h(v, "tags"));
          w.long(h(v, "hash"));
        },
        "outboxReadDate": function(w, v) {
          w.uint(1001931436);
          w.int(h(v, "date"));
        },
        "smsjobs.eligibleToJoin": function(w, v) {
          w.uint(3700114639);
          w.string(h(v, "termsUrl"));
          w.int(h(v, "monthlySentSms"));
        },
        "smsjobs.status": function(w, v) {
          w.uint(720277905);
          var flags = 0;
          if (v.allowInternational === true)
            flags |= 1;
          var _lastGiftSlug = v.lastGiftSlug !== void 0;
          if (_lastGiftSlug)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "recentSent"));
          w.int(h(v, "recentSince"));
          w.int(h(v, "recentRemains"));
          w.int(h(v, "totalSent"));
          w.int(h(v, "totalSince"));
          if (_lastGiftSlug)
            w.string(v.lastGiftSlug);
          w.string(h(v, "termsUrl"));
        },
        "smsJob": function(w, v) {
          w.uint(3869372088);
          w.string(h(v, "jobId"));
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "text"));
        },
        "businessWeeklyOpen": function(w, v) {
          w.uint(302717625);
          w.int(h(v, "startMinute"));
          w.int(h(v, "endMinute"));
        },
        "businessWorkHours": function(w, v) {
          w.uint(2358423704);
          var flags = 0;
          if (v.openNow === true)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "timezoneId"));
          w.vector(w.object, h(v, "weeklyOpen"));
        },
        "businessLocation": function(w, v) {
          w.uint(2891717367);
          var flags = 0;
          var _geoPoint = v.geoPoint !== void 0;
          if (_geoPoint)
            flags |= 1;
          w.uint(flags);
          if (_geoPoint)
            w.object(v.geoPoint);
          w.string(h(v, "address"));
        },
        "inputBusinessRecipients": function(w, v) {
          w.uint(1871393450);
          var flags = 0;
          if (v.existingChats === true)
            flags |= 1;
          if (v.newChats === true)
            flags |= 2;
          if (v.contacts === true)
            flags |= 4;
          if (v.nonContacts === true)
            flags |= 8;
          var _users = v.users && v.users.length;
          if (_users)
            flags |= 16;
          if (v.excludeSelected === true)
            flags |= 32;
          w.uint(flags);
          if (_users)
            w.vector(w.object, v.users);
        },
        "businessRecipients": function(w, v) {
          w.uint(554733559);
          var flags = 0;
          if (v.existingChats === true)
            flags |= 1;
          if (v.newChats === true)
            flags |= 2;
          if (v.contacts === true)
            flags |= 4;
          if (v.nonContacts === true)
            flags |= 8;
          var _users = v.users && v.users.length;
          if (_users)
            flags |= 16;
          if (v.excludeSelected === true)
            flags |= 32;
          w.uint(flags);
          if (_users)
            w.vector(w.int53, v.users);
        },
        "businessAwayMessageScheduleAlways": function(w) {
          w.uint(3384402617);
        },
        "businessAwayMessageScheduleOutsideWorkHours": function(w) {
          w.uint(3287479553);
        },
        "businessAwayMessageScheduleCustom": function(w, v) {
          w.uint(3427638988);
          w.int(h(v, "startDate"));
          w.int(h(v, "endDate"));
        },
        "inputBusinessGreetingMessage": function(w, v) {
          w.uint(26528571);
          w.int(h(v, "shortcutId"));
          w.object(h(v, "recipients"));
          w.int(h(v, "noActivityDays"));
        },
        "businessGreetingMessage": function(w, v) {
          w.uint(3843664811);
          w.int(h(v, "shortcutId"));
          w.object(h(v, "recipients"));
          w.int(h(v, "noActivityDays"));
        },
        "inputBusinessAwayMessage": function(w, v) {
          w.uint(2200008160);
          var flags = 0;
          if (v.offlineOnly === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "shortcutId"));
          w.object(h(v, "schedule"));
          w.object(h(v, "recipients"));
        },
        "businessAwayMessage": function(w, v) {
          w.uint(4011158108);
          var flags = 0;
          if (v.offlineOnly === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "shortcutId"));
          w.object(h(v, "schedule"));
          w.object(h(v, "recipients"));
        },
        "timezone": function(w, v) {
          w.uint(4287793653);
          w.string(h(v, "id"));
          w.string(h(v, "name"));
          w.int(h(v, "utcOffset"));
        },
        "help.timezonesListNotModified": function(w) {
          w.uint(2533820620);
        },
        "help.timezonesList": function(w, v) {
          w.uint(2071260529);
          w.vector(w.object, h(v, "timezones"));
          w.int(h(v, "hash"));
        },
        "quickReply": function(w, v) {
          w.uint(110563371);
          w.int(h(v, "shortcutId"));
          w.string(h(v, "shortcut"));
          w.int(h(v, "topMessage"));
          w.int(h(v, "count"));
        },
        "inputQuickReplyShortcut": function(w, v) {
          w.uint(609840449);
          w.string(h(v, "shortcut"));
        },
        "inputQuickReplyShortcutId": function(w, v) {
          w.uint(18418929);
          w.int(h(v, "shortcutId"));
        },
        "messages.quickReplies": function(w, v) {
          w.uint(3331155605);
          w.vector(w.object, h(v, "quickReplies"));
          w.vector(w.object, h(v, "messages"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.quickRepliesNotModified": function(w) {
          w.uint(1603398491);
        },
        "connectedBot": function(w, v) {
          w.uint(3171321345);
          var flags = 0;
          if (v.canReply === true)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "botId"));
          w.object(h(v, "recipients"));
        },
        "account.connectedBots": function(w, v) {
          w.uint(400029819);
          w.vector(w.object, h(v, "connectedBots"));
          w.vector(w.object, h(v, "users"));
        },
        "messages.dialogFilters": function(w, v) {
          w.uint(718878489);
          var flags = 0;
          if (v.tagsEnabled === true)
            flags |= 1;
          w.uint(flags);
          w.vector(w.object, h(v, "filters"));
        },
        "birthday": function(w, v) {
          w.uint(1821253126);
          var flags = 0;
          var _year = v.year !== void 0;
          if (_year)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "day"));
          w.int(h(v, "month"));
          if (_year)
            w.int(v.year);
        },
        "botBusinessConnection": function(w, v) {
          w.uint(2305045428);
          var flags = 0;
          if (v.canReply === true)
            flags |= 1;
          if (v.disabled === true)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "connectionId"));
          w.int53(h(v, "userId"));
          w.int(h(v, "dcId"));
          w.int(h(v, "date"));
        },
        "inputBusinessIntro": function(w, v) {
          w.uint(163867085);
          var flags = 0;
          var _sticker = v.sticker !== void 0;
          if (_sticker)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_sticker)
            w.object(v.sticker);
        },
        "businessIntro": function(w, v) {
          w.uint(1510606445);
          var flags = 0;
          var _sticker = v.sticker !== void 0;
          if (_sticker)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "description"));
          if (_sticker)
            w.object(v.sticker);
        },
        "messages.myStickers": function(w, v) {
          w.uint(4211040925);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "sets"));
        },
        "inputCollectibleUsername": function(w, v) {
          w.uint(3818152105);
          w.string(h(v, "username"));
        },
        "inputCollectiblePhone": function(w, v) {
          w.uint(2732725412);
          w.string(h(v, "phone"));
        },
        "fragment.collectibleInfo": function(w, v) {
          w.uint(1857945489);
          w.int(h(v, "purchaseDate"));
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
          w.string(h(v, "cryptoCurrency"));
          w.long(h(v, "cryptoAmount"));
          w.string(h(v, "url"));
        },
        "inputBusinessBotRecipients": function(w, v) {
          w.uint(3303379486);
          var flags = 0;
          if (v.existingChats === true)
            flags |= 1;
          if (v.newChats === true)
            flags |= 2;
          if (v.contacts === true)
            flags |= 4;
          if (v.nonContacts === true)
            flags |= 8;
          var _users = v.users && v.users.length;
          if (_users)
            flags |= 16;
          if (v.excludeSelected === true)
            flags |= 32;
          var _excludeUsers = v.excludeUsers && v.excludeUsers.length;
          if (_excludeUsers)
            flags |= 64;
          w.uint(flags);
          if (_users)
            w.vector(w.object, v.users);
          if (_excludeUsers)
            w.vector(w.object, v.excludeUsers);
        },
        "businessBotRecipients": function(w, v) {
          w.uint(3096245107);
          var flags = 0;
          if (v.existingChats === true)
            flags |= 1;
          if (v.newChats === true)
            flags |= 2;
          if (v.contacts === true)
            flags |= 4;
          if (v.nonContacts === true)
            flags |= 8;
          var _users = v.users && v.users.length;
          if (_users)
            flags |= 16;
          if (v.excludeSelected === true)
            flags |= 32;
          var _excludeUsers = v.excludeUsers && v.excludeUsers.length;
          if (_excludeUsers)
            flags |= 64;
          w.uint(flags);
          if (_users)
            w.vector(w.int53, v.users);
          if (_excludeUsers)
            w.vector(w.int53, v.excludeUsers);
        },
        "contactBirthday": function(w, v) {
          w.uint(496600883);
          w.int53(h(v, "contactId"));
          w.object(h(v, "birthday"));
        },
        "contacts.contactBirthdays": function(w, v) {
          w.uint(290452237);
          w.vector(w.object, h(v, "contacts"));
          w.vector(w.object, h(v, "users"));
        },
        "missingInvitee": function(w, v) {
          w.uint(1653379620);
          var flags = 0;
          if (v.premiumWouldAllowInvite === true)
            flags |= 1;
          if (v.premiumRequiredForPm === true)
            flags |= 2;
          w.uint(flags);
          w.int53(h(v, "userId"));
        },
        "messages.invitedUsers": function(w, v) {
          w.uint(2136862630);
          w.object(h(v, "updates"));
          w.vector(w.object, h(v, "missingInvitees"));
        },
        "inputBusinessChatLink": function(w, v) {
          w.uint(292003751);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 1;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_title)
            w.string(v.title);
        },
        "businessChatLink": function(w, v) {
          w.uint(3031328367);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 1;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "link"));
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_title)
            w.string(v.title);
          w.int(h(v, "views"));
        },
        "account.businessChatLinks": function(w, v) {
          w.uint(3963855569);
          w.vector(w.object, h(v, "links"));
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "account.resolvedBusinessChatLinks": function(w, v) {
          w.uint(2586029857);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "requestedPeerUser": function(w, v) {
          w.uint(3593466986);
          var flags = 0;
          var _firstName = v.firstName !== void 0;
          var _lastName = v.lastName !== void 0;
          var _flags_0 = _firstName || _lastName;
          if (_flags_0)
            flags |= 1;
          var _username = v.username !== void 0;
          if (_username)
            flags |= 2;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 4;
          w.uint(flags);
          w.int53(h(v, "userId"));
          if (_flags_0)
            w.string(v.firstName);
          if (_flags_0)
            w.string(v.lastName);
          if (_username)
            w.string(v.username);
          if (_photo)
            w.object(v.photo);
        },
        "requestedPeerChat": function(w, v) {
          w.uint(1929860175);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 4;
          w.uint(flags);
          w.int53(h(v, "chatId"));
          if (_title)
            w.string(v.title);
          if (_photo)
            w.object(v.photo);
        },
        "requestedPeerChannel": function(w, v) {
          w.uint(2342781924);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _username = v.username !== void 0;
          if (_username)
            flags |= 2;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 4;
          w.uint(flags);
          w.int53(h(v, "channelId"));
          if (_title)
            w.string(v.title);
          if (_username)
            w.string(v.username);
          if (_photo)
            w.object(v.photo);
        },
        "sponsoredMessageReportOption": function(w, v) {
          w.uint(1124938064);
          w.string(h(v, "text"));
          w.bytes(h(v, "option"));
        },
        "channels.sponsoredMessageReportResultChooseOption": function(w, v) {
          w.uint(2221907522);
          w.string(h(v, "title"));
          w.vector(w.object, h(v, "options"));
        },
        "channels.sponsoredMessageReportResultAdsHidden": function(w) {
          w.uint(1044107055);
        },
        "channels.sponsoredMessageReportResultReported": function(w) {
          w.uint(2910423113);
        },
        "stats.broadcastRevenueStats": function(w, v) {
          w.uint(1409802903);
          w.object(h(v, "topHoursGraph"));
          w.object(h(v, "revenueGraph"));
          w.object(h(v, "balances"));
          w.double(h(v, "usdRate"));
        },
        "stats.broadcastRevenueWithdrawalUrl": function(w, v) {
          w.uint(3966080823);
          w.string(h(v, "url"));
        },
        "broadcastRevenueTransactionProceeds": function(w, v) {
          w.uint(1434332356);
          w.long(h(v, "amount"));
          w.int(h(v, "fromDate"));
          w.int(h(v, "toDate"));
        },
        "broadcastRevenueTransactionWithdrawal": function(w, v) {
          w.uint(1515784568);
          var flags = 0;
          if (v.pending === true)
            flags |= 1;
          var _transactionDate = v.transactionDate !== void 0;
          var _transactionUrl = v.transactionUrl !== void 0;
          var _flags_1 = _transactionDate || _transactionUrl;
          if (_flags_1)
            flags |= 2;
          if (v.failed === true)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "amount"));
          w.int(h(v, "date"));
          w.string(h(v, "provider"));
          if (_flags_1)
            w.int(v.transactionDate);
          if (_flags_1)
            w.string(v.transactionUrl);
        },
        "broadcastRevenueTransactionRefund": function(w, v) {
          w.uint(1121127726);
          w.long(h(v, "amount"));
          w.int(h(v, "date"));
          w.string(h(v, "provider"));
        },
        "stats.broadcastRevenueTransactions": function(w, v) {
          w.uint(2266334310);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "transactions"));
        },
        "reactionNotificationsFromContacts": function(w) {
          w.uint(3133384218);
        },
        "reactionNotificationsFromAll": function(w) {
          w.uint(1268654752);
        },
        "reactionsNotifySettings": function(w, v) {
          w.uint(1457736048);
          var flags = 0;
          var _messagesNotifyFrom = v.messagesNotifyFrom !== void 0;
          if (_messagesNotifyFrom)
            flags |= 1;
          var _storiesNotifyFrom = v.storiesNotifyFrom !== void 0;
          if (_storiesNotifyFrom)
            flags |= 2;
          w.uint(flags);
          if (_messagesNotifyFrom)
            w.object(v.messagesNotifyFrom);
          if (_storiesNotifyFrom)
            w.object(v.storiesNotifyFrom);
          w.object(h(v, "sound"));
          w.boolean(h(v, "showPreviews"));
        },
        "broadcastRevenueBalances": function(w, v) {
          w.uint(3288297959);
          var flags = 0;
          if (v.withdrawalEnabled === true)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "currentBalance"));
          w.long(h(v, "availableBalance"));
          w.long(h(v, "overallRevenue"));
        },
        "availableEffect": function(w, v) {
          w.uint(2479088254);
          var flags = 0;
          var _staticIconId = v.staticIconId !== void 0;
          if (_staticIconId)
            flags |= 1;
          var _effectAnimationId = v.effectAnimationId !== void 0;
          if (_effectAnimationId)
            flags |= 2;
          if (v.premiumRequired === true)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "id"));
          w.string(h(v, "emoticon"));
          if (_staticIconId)
            w.long(v.staticIconId);
          w.long(h(v, "effectStickerId"));
          if (_effectAnimationId)
            w.long(v.effectAnimationId);
        },
        "messages.availableEffectsNotModified": function(w) {
          w.uint(3522009691);
        },
        "messages.availableEffects": function(w, v) {
          w.uint(3185271150);
          w.int(h(v, "hash"));
          w.vector(w.object, h(v, "effects"));
          w.vector(w.object, h(v, "documents"));
        },
        "factCheck": function(w, v) {
          w.uint(3097230543);
          var flags = 0;
          if (v.needCheck === true)
            flags |= 1;
          var _country = v.country !== void 0;
          var _text = v.text !== void 0;
          var _flags_1 = _country || _text;
          if (_flags_1)
            flags |= 2;
          w.uint(flags);
          if (_flags_1)
            w.string(v.country);
          if (_flags_1)
            w.object(v.text);
          w.long(h(v, "hash"));
        },
        "starsTransactionPeerUnsupported": function(w) {
          w.uint(2515714020);
        },
        "starsTransactionPeerAppStore": function(w) {
          w.uint(3025646453);
        },
        "starsTransactionPeerPlayMarket": function(w) {
          w.uint(2069236235);
        },
        "starsTransactionPeerPremiumBot": function(w) {
          w.uint(621656824);
        },
        "starsTransactionPeerFragment": function(w) {
          w.uint(3912227074);
        },
        "starsTransactionPeer": function(w, v) {
          w.uint(3624771933);
          w.object(h(v, "peer"));
        },
        "starsTransactionPeerAds": function(w) {
          w.uint(1617438738);
        },
        "starsTopupOption": function(w, v) {
          w.uint(198776256);
          var flags = 0;
          var _storeProduct = v.storeProduct !== void 0;
          if (_storeProduct)
            flags |= 1;
          if (v.extended === true)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "stars"));
          if (_storeProduct)
            w.string(v.storeProduct);
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "starsTransaction": function(w, v) {
          w.uint(178185410);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 2;
          var _photo = v.photo !== void 0;
          if (_photo)
            flags |= 4;
          if (v.refund === true)
            flags |= 8;
          if (v.pending === true)
            flags |= 16;
          var _transactionDate = v.transactionDate !== void 0;
          var _transactionUrl = v.transactionUrl !== void 0;
          var _flags_5 = _transactionDate || _transactionUrl;
          if (_flags_5)
            flags |= 32;
          if (v.failed === true)
            flags |= 64;
          var _botPayload = v.botPayload !== void 0;
          if (_botPayload)
            flags |= 128;
          var _msgId = v.msgId !== void 0;
          if (_msgId)
            flags |= 256;
          var _extendedMedia = v.extendedMedia && v.extendedMedia.length;
          if (_extendedMedia)
            flags |= 512;
          if (v.gift === true)
            flags |= 1024;
          if (v.reaction === true)
            flags |= 2048;
          var _subscriptionPeriod = v.subscriptionPeriod !== void 0;
          if (_subscriptionPeriod)
            flags |= 4096;
          var _giveawayPostId = v.giveawayPostId !== void 0;
          if (_giveawayPostId)
            flags |= 8192;
          var _stargift = v.stargift !== void 0;
          if (_stargift)
            flags |= 16384;
          w.uint(flags);
          w.string(h(v, "id"));
          w.long(h(v, "stars"));
          w.int(h(v, "date"));
          w.object(h(v, "peer"));
          if (_title)
            w.string(v.title);
          if (_description)
            w.string(v.description);
          if (_photo)
            w.object(v.photo);
          if (_flags_5)
            w.int(v.transactionDate);
          if (_flags_5)
            w.string(v.transactionUrl);
          if (_botPayload)
            w.bytes(v.botPayload);
          if (_msgId)
            w.int(v.msgId);
          if (_extendedMedia)
            w.vector(w.object, v.extendedMedia);
          if (_subscriptionPeriod)
            w.int(v.subscriptionPeriod);
          if (_giveawayPostId)
            w.int(v.giveawayPostId);
          if (_stargift)
            w.object(v.stargift);
        },
        "payments.starsStatus": function(w, v) {
          w.uint(3153736044);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          var _subscriptions = v.subscriptions && v.subscriptions.length;
          if (_subscriptions)
            flags |= 2;
          var _subscriptionsNextOffset = v.subscriptionsNextOffset !== void 0;
          if (_subscriptionsNextOffset)
            flags |= 4;
          var _history = v.history && v.history.length;
          if (_history)
            flags |= 8;
          var _subscriptionsMissingBalance = v.subscriptionsMissingBalance !== void 0;
          if (_subscriptionsMissingBalance)
            flags |= 16;
          w.uint(flags);
          w.long(h(v, "balance"));
          if (_subscriptions)
            w.vector(w.object, v.subscriptions);
          if (_subscriptionsNextOffset)
            w.string(v.subscriptionsNextOffset);
          if (_subscriptionsMissingBalance)
            w.long(v.subscriptionsMissingBalance);
          if (_history)
            w.vector(w.object, v.history);
          if (_nextOffset)
            w.string(v.nextOffset);
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "foundStory": function(w, v) {
          w.uint(3900361664);
          w.object(h(v, "peer"));
          w.object(h(v, "story"));
        },
        "stories.foundStories": function(w, v) {
          w.uint(3806230327);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "stories"));
          if (_nextOffset)
            w.string(v.nextOffset);
          w.vector(w.object, h(v, "chats"));
          w.vector(w.object, h(v, "users"));
        },
        "geoPointAddress": function(w, v) {
          w.uint(3729546643);
          var flags = 0;
          var _state = v.state !== void 0;
          if (_state)
            flags |= 1;
          var _city = v.city !== void 0;
          if (_city)
            flags |= 2;
          var _street = v.street !== void 0;
          if (_street)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "countryIso2"));
          if (_state)
            w.string(v.state);
          if (_city)
            w.string(v.city);
          if (_street)
            w.string(v.street);
        },
        "starsRevenueStatus": function(w, v) {
          w.uint(2033461574);
          var flags = 0;
          if (v.withdrawalEnabled === true)
            flags |= 1;
          var _nextWithdrawalAt = v.nextWithdrawalAt !== void 0;
          if (_nextWithdrawalAt)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "currentBalance"));
          w.long(h(v, "availableBalance"));
          w.long(h(v, "overallRevenue"));
          if (_nextWithdrawalAt)
            w.int(v.nextWithdrawalAt);
        },
        "payments.starsRevenueStats": function(w, v) {
          w.uint(3375085371);
          w.object(h(v, "revenueGraph"));
          w.object(h(v, "status"));
          w.double(h(v, "usdRate"));
        },
        "payments.starsRevenueWithdrawalUrl": function(w, v) {
          w.uint(497778871);
          w.string(h(v, "url"));
        },
        "payments.starsRevenueAdsAccountUrl": function(w, v) {
          w.uint(961445665);
          w.string(h(v, "url"));
        },
        "inputStarsTransaction": function(w, v) {
          w.uint(543876817);
          var flags = 0;
          if (v.refund === true)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "id"));
        },
        "starsGiftOption": function(w, v) {
          w.uint(1577421297);
          var flags = 0;
          var _storeProduct = v.storeProduct !== void 0;
          if (_storeProduct)
            flags |= 1;
          if (v.extended === true)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "stars"));
          if (_storeProduct)
            w.string(v.storeProduct);
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
        },
        "bots.popularAppBots": function(w, v) {
          w.uint(428978491);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          if (_nextOffset)
            w.string(v.nextOffset);
          w.vector(w.object, h(v, "users"));
        },
        "botPreviewMedia": function(w, v) {
          w.uint(602479523);
          w.int(h(v, "date"));
          w.object(h(v, "media"));
        },
        "bots.previewInfo": function(w, v) {
          w.uint(212278628);
          w.vector(w.object, h(v, "media"));
          w.vector(w.string, h(v, "langCodes"));
        },
        "starsSubscriptionPricing": function(w, v) {
          w.uint(88173912);
          w.int(h(v, "period"));
          w.long(h(v, "amount"));
        },
        "starsSubscription": function(w, v) {
          w.uint(1401868056);
          var flags = 0;
          if (v.canceled === true)
            flags |= 1;
          if (v.canRefulfill === true)
            flags |= 2;
          if (v.missingBalance === true)
            flags |= 4;
          var _chatInviteHash = v.chatInviteHash !== void 0;
          if (_chatInviteHash)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "id"));
          w.object(h(v, "peer"));
          w.int(h(v, "untilDate"));
          w.object(h(v, "pricing"));
          if (_chatInviteHash)
            w.string(v.chatInviteHash);
        },
        "messageReactor": function(w, v) {
          w.uint(1269016922);
          var flags = 0;
          if (v.top === true)
            flags |= 1;
          if (v.my === true)
            flags |= 2;
          if (v.anonymous === true)
            flags |= 4;
          var _peerId = v.peerId !== void 0;
          if (_peerId)
            flags |= 8;
          w.uint(flags);
          if (_peerId)
            w.object(v.peerId);
          w.int(h(v, "count"));
        },
        "starsGiveawayOption": function(w, v) {
          w.uint(2496562474);
          var flags = 0;
          if (v.extended === true)
            flags |= 1;
          if (v.default === true)
            flags |= 2;
          var _storeProduct = v.storeProduct !== void 0;
          if (_storeProduct)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "stars"));
          w.int(h(v, "yearlyBoosts"));
          if (_storeProduct)
            w.string(v.storeProduct);
          w.string(h(v, "currency"));
          w.long(h(v, "amount"));
          w.vector(w.object, h(v, "winners"));
        },
        "starsGiveawayWinnersOption": function(w, v) {
          w.uint(1411605001);
          var flags = 0;
          if (v.default === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "users"));
          w.long(h(v, "perUserStars"));
        },
        "starGift": function(w, v) {
          w.uint(2929816814);
          var flags = 0;
          var _availabilityRemains = v.availabilityRemains !== void 0;
          var _availabilityTotal = v.availabilityTotal !== void 0;
          var _flags_0 = v.limited === true || _availabilityRemains || _availabilityTotal;
          if (_flags_0)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "id"));
          w.object(h(v, "sticker"));
          w.long(h(v, "stars"));
          if (_flags_0)
            w.int(v.availabilityRemains);
          if (_flags_0)
            w.int(v.availabilityTotal);
          w.long(h(v, "convertStars"));
        },
        "payments.starGiftsNotModified": function(w) {
          w.uint(2743640936);
        },
        "payments.starGifts": function(w, v) {
          w.uint(2417396202);
          w.int(h(v, "hash"));
          w.vector(w.object, h(v, "gifts"));
        },
        "userStarGift": function(w, v) {
          w.uint(4003764846);
          var flags = 0;
          if (v.nameHidden === true)
            flags |= 1;
          var _fromId = v.fromId !== void 0;
          if (_fromId)
            flags |= 2;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 4;
          var _msgId = v.msgId !== void 0;
          if (_msgId)
            flags |= 8;
          var _convertStars = v.convertStars !== void 0;
          if (_convertStars)
            flags |= 16;
          if (v.unsaved === true)
            flags |= 32;
          w.uint(flags);
          if (_fromId)
            w.int53(v.fromId);
          w.int(h(v, "date"));
          w.object(h(v, "gift"));
          if (_message)
            w.object(v.message);
          if (_msgId)
            w.int(v.msgId);
          if (_convertStars)
            w.long(v.convertStars);
        },
        "payments.userStarGifts": function(w, v) {
          w.uint(1801827607);
          var flags = 0;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "count"));
          w.vector(w.object, h(v, "gifts"));
          if (_nextOffset)
            w.string(v.nextOffset);
          w.vector(w.object, h(v, "users"));
        },
        "messageReportOption": function(w, v) {
          w.uint(2030298073);
          w.string(h(v, "text"));
          w.bytes(h(v, "option"));
        },
        "reportResultChooseOption": function(w, v) {
          w.uint(4041531574);
          w.string(h(v, "title"));
          w.vector(w.object, h(v, "options"));
        },
        "reportResultAddComment": function(w, v) {
          w.uint(1862904881);
          var flags = 0;
          if (v.optional === true)
            flags |= 1;
          w.uint(flags);
          w.bytes(h(v, "option"));
        },
        "reportResultReported": function(w) {
          w.uint(2377333835);
        },
        "test.useConfigSimple": function(w) {
          w.uint(4189565501);
        },
        "test.parseInputAppEvent": function(w) {
          w.uint(3138226161);
        },
        "invokeWithBusinessConnectionPrefix": function(w, v) {
          w.uint(3710427022);
          w.string(h(v, "connectionId"));
        },
        "invokeWithGooglePlayIntegrityPrefix": function(w, v) {
          w.uint(502868356);
          w.string(h(v, "nonce"));
          w.string(h(v, "token"));
        },
        "invokeWithApnsSecretPrefix": function(w, v) {
          w.uint(229528824);
          w.string(h(v, "nonce"));
          w.string(h(v, "secret"));
        },
        "invokeAfterMsg": function(w, v) {
          w.uint(3416209197);
          w.long(h(v, "msgId"));
          w.object(h(v, "query"));
        },
        "invokeAfterMsgs": function(w, v) {
          w.uint(1036301552);
          w.vector(w.long, h(v, "msgIds"));
          w.object(h(v, "query"));
        },
        "initConnection": function(w, v) {
          w.uint(3251461801);
          var flags = 0;
          var _proxy = v.proxy !== void 0;
          if (_proxy)
            flags |= 1;
          var _params = v.params !== void 0;
          if (_params)
            flags |= 2;
          w.uint(flags);
          w.int(h(v, "apiId"));
          w.string(h(v, "deviceModel"));
          w.string(h(v, "systemVersion"));
          w.string(h(v, "appVersion"));
          w.string(h(v, "systemLangCode"));
          w.string(h(v, "langPack"));
          w.string(h(v, "langCode"));
          if (_proxy)
            w.object(v.proxy);
          if (_params)
            w.object(v.params);
          w.object(h(v, "query"));
        },
        "invokeWithLayer": function(w, v) {
          w.uint(3667594509);
          w.int(h(v, "layer"));
          w.object(h(v, "query"));
        },
        "invokeWithoutUpdates": function(w, v) {
          w.uint(3214170551);
          w.object(h(v, "query"));
        },
        "invokeWithMessagesRange": function(w, v) {
          w.uint(911373810);
          w.object(h(v, "range"));
          w.object(h(v, "query"));
        },
        "invokeWithTakeout": function(w, v) {
          w.uint(2896821550);
          w.long(h(v, "takeoutId"));
          w.object(h(v, "query"));
        },
        "invokeWithBusinessConnection": function(w, v) {
          w.uint(3710427022);
          w.string(h(v, "connectionId"));
          w.object(h(v, "query"));
        },
        "invokeWithGooglePlayIntegrity": function(w, v) {
          w.uint(502868356);
          w.string(h(v, "nonce"));
          w.string(h(v, "token"));
          w.object(h(v, "query"));
        },
        "invokeWithApnsSecret": function(w, v) {
          w.uint(229528824);
          w.string(h(v, "nonce"));
          w.string(h(v, "secret"));
          w.object(h(v, "query"));
        },
        "auth.sendCode": function(w, v) {
          w.uint(2792825935);
          w.string(h(v, "phoneNumber"));
          w.int(h(v, "apiId"));
          w.string(h(v, "apiHash"));
          w.object(h(v, "settings"));
        },
        "auth.signUp": function(w, v) {
          w.uint(2865215255);
          var flags = 0;
          if (v.noJoinedNotifications === true)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
        },
        "auth.signIn": function(w, v) {
          w.uint(2371004753);
          var flags = 0;
          var _phoneCode = v.phoneCode !== void 0;
          if (_phoneCode)
            flags |= 1;
          var _emailVerification = v.emailVerification !== void 0;
          if (_emailVerification)
            flags |= 2;
          w.uint(flags);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
          if (_phoneCode)
            w.string(v.phoneCode);
          if (_emailVerification)
            w.object(v.emailVerification);
        },
        "auth.logOut": function(w) {
          w.uint(1047706137);
        },
        "auth.resetAuthorizations": function(w) {
          w.uint(2678787354);
        },
        "auth.exportAuthorization": function(w, v) {
          w.uint(3854565325);
          w.int(h(v, "dcId"));
        },
        "auth.importAuthorization": function(w, v) {
          w.uint(2776268205);
          w.long(h(v, "id"));
          w.bytes(h(v, "bytes"));
        },
        "auth.bindTempAuthKey": function(w, v) {
          w.uint(3453233669);
          w.long(h(v, "permAuthKeyId"));
          w.long(h(v, "nonce"));
          w.int(h(v, "expiresAt"));
          w.bytes(h(v, "encryptedMessage"));
        },
        "auth.importBotAuthorization": function(w, v) {
          w.uint(1738800940);
          w.int(h(v, "flags"));
          w.int(h(v, "apiId"));
          w.string(h(v, "apiHash"));
          w.string(h(v, "botAuthToken"));
        },
        "auth.checkPassword": function(w, v) {
          w.uint(3515567382);
          w.object(h(v, "password"));
        },
        "auth.requestPasswordRecovery": function(w) {
          w.uint(3633822822);
        },
        "auth.recoverPassword": function(w, v) {
          w.uint(923364464);
          var flags = 0;
          var _newSettings = v.newSettings !== void 0;
          if (_newSettings)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "code"));
          if (_newSettings)
            w.object(v.newSettings);
        },
        "auth.resendCode": function(w, v) {
          w.uint(3403969827);
          var flags = 0;
          var _reason = v.reason !== void 0;
          if (_reason)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
          if (_reason)
            w.string(v.reason);
        },
        "auth.cancelCode": function(w, v) {
          w.uint(520357240);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
        },
        "auth.dropTempAuthKeys": function(w, v) {
          w.uint(2387124616);
          w.vector(w.long, h(v, "exceptAuthKeys"));
        },
        "auth.exportLoginToken": function(w, v) {
          w.uint(3084944894);
          w.int(h(v, "apiId"));
          w.string(h(v, "apiHash"));
          w.vector(w.long, h(v, "exceptIds"));
        },
        "auth.importLoginToken": function(w, v) {
          w.uint(2511101156);
          w.bytes(h(v, "token"));
        },
        "auth.acceptLoginToken": function(w, v) {
          w.uint(3902057805);
          w.bytes(h(v, "token"));
        },
        "auth.checkRecoveryPassword": function(w, v) {
          w.uint(221691769);
          w.string(h(v, "code"));
        },
        "auth.importWebTokenAuthorization": function(w, v) {
          w.uint(767062953);
          w.int(h(v, "apiId"));
          w.string(h(v, "apiHash"));
          w.string(h(v, "webAuthToken"));
        },
        "auth.requestFirebaseSms": function(w, v) {
          w.uint(2386109982);
          var flags = 0;
          var _safetyNetToken = v.safetyNetToken !== void 0;
          if (_safetyNetToken)
            flags |= 1;
          var _iosPushSecret = v.iosPushSecret !== void 0;
          if (_iosPushSecret)
            flags |= 2;
          var _playIntegrityToken = v.playIntegrityToken !== void 0;
          if (_playIntegrityToken)
            flags |= 4;
          w.uint(flags);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
          if (_safetyNetToken)
            w.string(v.safetyNetToken);
          if (_playIntegrityToken)
            w.string(v.playIntegrityToken);
          if (_iosPushSecret)
            w.string(v.iosPushSecret);
        },
        "auth.resetLoginEmail": function(w, v) {
          w.uint(2123760019);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
        },
        "auth.reportMissingCode": function(w, v) {
          w.uint(3416125430);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
          w.string(h(v, "mnc"));
        },
        "account.registerDevice": function(w, v) {
          w.uint(3968205178);
          var flags = 0;
          if (v.noMuted === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "tokenType"));
          w.string(h(v, "token"));
          w.boolean(h(v, "appSandbox"));
          w.bytes(h(v, "secret"));
          w.vector(w.int53, h(v, "otherUids"));
        },
        "account.unregisterDevice": function(w, v) {
          w.uint(1779249670);
          w.int(h(v, "tokenType"));
          w.string(h(v, "token"));
          w.vector(w.int53, h(v, "otherUids"));
        },
        "account.updateNotifySettings": function(w, v) {
          w.uint(2227067795);
          w.object(h(v, "peer"));
          w.object(h(v, "settings"));
        },
        "account.getNotifySettings": function(w, v) {
          w.uint(313765169);
          w.object(h(v, "peer"));
        },
        "account.resetNotifySettings": function(w) {
          w.uint(3682473799);
        },
        "account.updateProfile": function(w, v) {
          w.uint(2018596725);
          var flags = 0;
          var _firstName = v.firstName !== void 0;
          if (_firstName)
            flags |= 1;
          var _lastName = v.lastName !== void 0;
          if (_lastName)
            flags |= 2;
          var _about = v.about !== void 0;
          if (_about)
            flags |= 4;
          w.uint(flags);
          if (_firstName)
            w.string(v.firstName);
          if (_lastName)
            w.string(v.lastName);
          if (_about)
            w.string(v.about);
        },
        "account.updateStatus": function(w, v) {
          w.uint(1713919532);
          w.boolean(h(v, "offline"));
        },
        "account.getWallPapers": function(w, v) {
          w.uint(127302966);
          w.long(h(v, "hash"));
        },
        "account.reportPeer": function(w, v) {
          w.uint(3317316998);
          w.object(h(v, "peer"));
          w.object(h(v, "reason"));
          w.string(h(v, "message"));
        },
        "account.checkUsername": function(w, v) {
          w.uint(655677548);
          w.string(h(v, "username"));
        },
        "account.updateUsername": function(w, v) {
          w.uint(1040964988);
          w.string(h(v, "username"));
        },
        "account.getPrivacy": function(w, v) {
          w.uint(3671837008);
          w.object(h(v, "key"));
        },
        "account.setPrivacy": function(w, v) {
          w.uint(3388480744);
          w.object(h(v, "key"));
          w.vector(w.object, h(v, "rules"));
        },
        "account.deleteAccount": function(w, v) {
          w.uint(2730545012);
          var flags = 0;
          var _password = v.password !== void 0;
          if (_password)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "reason"));
          if (_password)
            w.object(v.password);
        },
        "account.getAccountTTL": function(w) {
          w.uint(150761757);
        },
        "account.setAccountTTL": function(w, v) {
          w.uint(608323678);
          w.object(h(v, "ttl"));
        },
        "account.sendChangePhoneCode": function(w, v) {
          w.uint(2186758885);
          w.string(h(v, "phoneNumber"));
          w.object(h(v, "settings"));
        },
        "account.changePhone": function(w, v) {
          w.uint(1891839707);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
          w.string(h(v, "phoneCode"));
        },
        "account.updateDeviceLocked": function(w, v) {
          w.uint(954152242);
          w.int(h(v, "period"));
        },
        "account.getAuthorizations": function(w) {
          w.uint(3810574680);
        },
        "account.resetAuthorization": function(w, v) {
          w.uint(3749180348);
          w.long(h(v, "hash"));
        },
        "account.getPassword": function(w) {
          w.uint(1418342645);
        },
        "account.getPasswordSettings": function(w, v) {
          w.uint(2631199481);
          w.object(h(v, "password"));
        },
        "account.updatePasswordSettings": function(w, v) {
          w.uint(2778402863);
          w.object(h(v, "password"));
          w.object(h(v, "newSettings"));
        },
        "account.sendConfirmPhoneCode": function(w, v) {
          w.uint(457157256);
          w.string(h(v, "hash"));
          w.object(h(v, "settings"));
        },
        "account.confirmPhone": function(w, v) {
          w.uint(1596029123);
          w.string(h(v, "phoneCodeHash"));
          w.string(h(v, "phoneCode"));
        },
        "account.getTmpPassword": function(w, v) {
          w.uint(1151208273);
          w.object(h(v, "password"));
          w.int(h(v, "period"));
        },
        "account.getWebAuthorizations": function(w) {
          w.uint(405695855);
        },
        "account.resetWebAuthorization": function(w, v) {
          w.uint(755087855);
          w.long(h(v, "hash"));
        },
        "account.resetWebAuthorizations": function(w) {
          w.uint(1747789204);
        },
        "account.getAllSecureValues": function(w) {
          w.uint(2995305597);
        },
        "account.getSecureValue": function(w, v) {
          w.uint(1936088002);
          w.vector(w.object, h(v, "types"));
        },
        "account.saveSecureValue": function(w, v) {
          w.uint(2308956957);
          w.object(h(v, "value"));
          w.long(h(v, "secureSecretId"));
        },
        "account.deleteSecureValue": function(w, v) {
          w.uint(3095444555);
          w.vector(w.object, h(v, "types"));
        },
        "account.getAuthorizationForm": function(w, v) {
          w.uint(2838059386);
          w.int53(h(v, "botId"));
          w.string(h(v, "scope"));
          w.string(h(v, "publicKey"));
        },
        "account.acceptAuthorization": function(w, v) {
          w.uint(4092415091);
          w.int53(h(v, "botId"));
          w.string(h(v, "scope"));
          w.string(h(v, "publicKey"));
          w.vector(w.object, h(v, "valueHashes"));
          w.object(h(v, "credentials"));
        },
        "account.sendVerifyPhoneCode": function(w, v) {
          w.uint(2778945273);
          w.string(h(v, "phoneNumber"));
          w.object(h(v, "settings"));
        },
        "account.verifyPhone": function(w, v) {
          w.uint(1305716726);
          w.string(h(v, "phoneNumber"));
          w.string(h(v, "phoneCodeHash"));
          w.string(h(v, "phoneCode"));
        },
        "account.sendVerifyEmailCode": function(w, v) {
          w.uint(2564831163);
          w.object(h(v, "purpose"));
          w.string(h(v, "email"));
        },
        "account.verifyEmail": function(w, v) {
          w.uint(53322959);
          w.object(h(v, "purpose"));
          w.object(h(v, "verification"));
        },
        "account.initTakeoutSession": function(w, v) {
          w.uint(239835e4);
          var flags = 0;
          if (v.contacts === true)
            flags |= 1;
          if (v.messageUsers === true)
            flags |= 2;
          if (v.messageChats === true)
            flags |= 4;
          if (v.messageMegagroups === true)
            flags |= 8;
          if (v.messageChannels === true)
            flags |= 16;
          var _fileMaxSize = v.fileMaxSize !== void 0;
          var _flags_5 = v.files === true || _fileMaxSize;
          if (_flags_5)
            flags |= 32;
          w.uint(flags);
          if (_flags_5)
            w.int53(v.fileMaxSize);
        },
        "account.finishTakeoutSession": function(w, v) {
          w.uint(489050862);
          var flags = 0;
          if (v.success === true)
            flags |= 1;
          w.uint(flags);
        },
        "account.confirmPasswordEmail": function(w, v) {
          w.uint(2413762848);
          w.string(h(v, "code"));
        },
        "account.resendPasswordEmail": function(w) {
          w.uint(2055154197);
        },
        "account.cancelPasswordEmail": function(w) {
          w.uint(3251361206);
        },
        "account.getContactSignUpNotification": function(w) {
          w.uint(2668087080);
        },
        "account.setContactSignUpNotification": function(w, v) {
          w.uint(3488890721);
          w.boolean(h(v, "silent"));
        },
        "account.getNotifyExceptions": function(w, v) {
          w.uint(1398240377);
          var flags = 0;
          var _peer = v.peer !== void 0;
          if (_peer)
            flags |= 1;
          if (v.compareSound === true)
            flags |= 2;
          if (v.compareStories === true)
            flags |= 4;
          w.uint(flags);
          if (_peer)
            w.object(v.peer);
        },
        "account.getWallPaper": function(w, v) {
          w.uint(4237155306);
          w.object(h(v, "wallpaper"));
        },
        "account.uploadWallPaper": function(w, v) {
          w.uint(3818557187);
          var flags = 0;
          if (v.forChat === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "file"));
          w.string(h(v, "mimeType"));
          w.object(h(v, "settings"));
        },
        "account.saveWallPaper": function(w, v) {
          w.uint(1817860919);
          w.object(h(v, "wallpaper"));
          w.boolean(h(v, "unsave"));
          w.object(h(v, "settings"));
        },
        "account.installWallPaper": function(w, v) {
          w.uint(4276967273);
          w.object(h(v, "wallpaper"));
          w.object(h(v, "settings"));
        },
        "account.resetWallPapers": function(w) {
          w.uint(3141244932);
        },
        "account.getAutoDownloadSettings": function(w) {
          w.uint(1457130303);
        },
        "account.saveAutoDownloadSettings": function(w, v) {
          w.uint(1995661875);
          var flags = 0;
          if (v.low === true)
            flags |= 1;
          if (v.high === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "settings"));
        },
        "account.uploadTheme": function(w, v) {
          w.uint(473805619);
          var flags = 0;
          var _thumb = v.thumb !== void 0;
          if (_thumb)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "file"));
          if (_thumb)
            w.object(v.thumb);
          w.string(h(v, "fileName"));
          w.string(h(v, "mimeType"));
        },
        "account.createTheme": function(w, v) {
          w.uint(1697530880);
          var flags = 0;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 4;
          var _settings = v.settings && v.settings.length;
          if (_settings)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "slug"));
          w.string(h(v, "title"));
          if (_document)
            w.object(v.document);
          if (_settings)
            w.vector(w.object, v.settings);
        },
        "account.updateTheme": function(w, v) {
          w.uint(737414348);
          var flags = 0;
          var _slug = v.slug !== void 0;
          if (_slug)
            flags |= 1;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          var _document = v.document !== void 0;
          if (_document)
            flags |= 4;
          var _settings = v.settings && v.settings.length;
          if (_settings)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "format"));
          w.object(h(v, "theme"));
          if (_slug)
            w.string(v.slug);
          if (_title)
            w.string(v.title);
          if (_document)
            w.object(v.document);
          if (_settings)
            w.vector(w.object, v.settings);
        },
        "account.saveTheme": function(w, v) {
          w.uint(4065792108);
          w.object(h(v, "theme"));
          w.boolean(h(v, "unsave"));
        },
        "account.installTheme": function(w, v) {
          w.uint(3341269819);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          var _theme = v.theme !== void 0;
          if (_theme)
            flags |= 2;
          var _format = v.format !== void 0;
          if (_format)
            flags |= 4;
          var _baseTheme = v.baseTheme !== void 0;
          if (_baseTheme)
            flags |= 8;
          w.uint(flags);
          if (_theme)
            w.object(v.theme);
          if (_format)
            w.string(v.format);
          if (_baseTheme)
            w.object(v.baseTheme);
        },
        "account.getTheme": function(w, v) {
          w.uint(978872812);
          w.string(h(v, "format"));
          w.object(h(v, "theme"));
        },
        "account.getThemes": function(w, v) {
          w.uint(1913054296);
          w.string(h(v, "format"));
          w.long(h(v, "hash"));
        },
        "account.setContentSettings": function(w, v) {
          w.uint(3044323691);
          var flags = 0;
          if (v.sensitiveEnabled === true)
            flags |= 1;
          w.uint(flags);
        },
        "account.getContentSettings": function(w) {
          w.uint(2342210990);
        },
        "account.getMultiWallPapers": function(w, v) {
          w.uint(1705865692);
          w.vector(w.object, h(v, "wallpapers"));
        },
        "account.getGlobalPrivacySettings": function(w) {
          w.uint(3945483510);
        },
        "account.setGlobalPrivacySettings": function(w, v) {
          w.uint(517647042);
          w.object(h(v, "settings"));
        },
        "account.reportProfilePhoto": function(w, v) {
          w.uint(4203529973);
          w.object(h(v, "peer"));
          w.object(h(v, "photoId"));
          w.object(h(v, "reason"));
          w.string(h(v, "message"));
        },
        "account.resetPassword": function(w) {
          w.uint(2466827803);
        },
        "account.declinePasswordReset": function(w) {
          w.uint(1284770294);
        },
        "account.getChatThemes": function(w, v) {
          w.uint(3594051209);
          w.long(h(v, "hash"));
        },
        "account.setAuthorizationTTL": function(w, v) {
          w.uint(3213466272);
          w.int(h(v, "authorizationTtlDays"));
        },
        "account.changeAuthorizationSettings": function(w, v) {
          w.uint(1089766498);
          var flags = 0;
          var _encryptedRequestsDisabled = v.encryptedRequestsDisabled !== void 0;
          if (_encryptedRequestsDisabled)
            flags |= 1;
          var _callRequestsDisabled = v.callRequestsDisabled !== void 0;
          if (_callRequestsDisabled)
            flags |= 2;
          if (v.confirmed === true)
            flags |= 8;
          w.uint(flags);
          w.long(h(v, "hash"));
          if (_encryptedRequestsDisabled)
            w.boolean(v.encryptedRequestsDisabled);
          if (_callRequestsDisabled)
            w.boolean(v.callRequestsDisabled);
        },
        "account.getSavedRingtones": function(w, v) {
          w.uint(3784319624);
          w.long(h(v, "hash"));
        },
        "account.saveRingtone": function(w, v) {
          w.uint(1038768899);
          w.object(h(v, "id"));
          w.boolean(h(v, "unsave"));
        },
        "account.uploadRingtone": function(w, v) {
          w.uint(2199552930);
          w.object(h(v, "file"));
          w.string(h(v, "fileName"));
          w.string(h(v, "mimeType"));
        },
        "account.updateEmojiStatus": function(w, v) {
          w.uint(4224966251);
          w.object(h(v, "emojiStatus"));
        },
        "account.getDefaultEmojiStatuses": function(w, v) {
          w.uint(3598005126);
          w.long(h(v, "hash"));
        },
        "account.getRecentEmojiStatuses": function(w, v) {
          w.uint(257392901);
          w.long(h(v, "hash"));
        },
        "account.clearRecentEmojiStatuses": function(w) {
          w.uint(404757166);
        },
        "account.reorderUsernames": function(w, v) {
          w.uint(4015001259);
          w.vector(w.string, h(v, "order"));
        },
        "account.toggleUsername": function(w, v) {
          w.uint(1490465654);
          w.string(h(v, "username"));
          w.boolean(h(v, "active"));
        },
        "account.getDefaultProfilePhotoEmojis": function(w, v) {
          w.uint(3799319336);
          w.long(h(v, "hash"));
        },
        "account.getDefaultGroupPhotoEmojis": function(w, v) {
          w.uint(2438488238);
          w.long(h(v, "hash"));
        },
        "account.getAutoSaveSettings": function(w) {
          w.uint(2915810522);
        },
        "account.saveAutoSaveSettings": function(w, v) {
          w.uint(3600515937);
          var flags = 0;
          if (v.users === true)
            flags |= 1;
          if (v.chats === true)
            flags |= 2;
          if (v.broadcasts === true)
            flags |= 4;
          var _peer = v.peer !== void 0;
          if (_peer)
            flags |= 8;
          w.uint(flags);
          if (_peer)
            w.object(v.peer);
          w.object(h(v, "settings"));
        },
        "account.deleteAutoSaveExceptions": function(w) {
          w.uint(1404829728);
        },
        "account.invalidateSignInCodes": function(w, v) {
          w.uint(3398101178);
          w.vector(w.string, h(v, "codes"));
        },
        "account.updateColor": function(w, v) {
          w.uint(2096079197);
          var flags = 0;
          var _backgroundEmojiId = v.backgroundEmojiId !== void 0;
          if (_backgroundEmojiId)
            flags |= 1;
          if (v.forProfile === true)
            flags |= 2;
          var _color = v.color !== void 0;
          if (_color)
            flags |= 4;
          w.uint(flags);
          if (_color)
            w.int(v.color);
          if (_backgroundEmojiId)
            w.long(v.backgroundEmojiId);
        },
        "account.getDefaultBackgroundEmojis": function(w, v) {
          w.uint(2785720782);
          w.long(h(v, "hash"));
        },
        "account.getChannelDefaultEmojiStatuses": function(w, v) {
          w.uint(1999087573);
          w.long(h(v, "hash"));
        },
        "account.getChannelRestrictedStatusEmojis": function(w, v) {
          w.uint(900325589);
          w.long(h(v, "hash"));
        },
        "account.updateBusinessWorkHours": function(w, v) {
          w.uint(1258348646);
          var flags = 0;
          var _businessWorkHours = v.businessWorkHours !== void 0;
          if (_businessWorkHours)
            flags |= 1;
          w.uint(flags);
          if (_businessWorkHours)
            w.object(v.businessWorkHours);
        },
        "account.updateBusinessLocation": function(w, v) {
          w.uint(2657817370);
          var flags = 0;
          var _address = v.address !== void 0;
          if (_address)
            flags |= 1;
          var _geoPoint = v.geoPoint !== void 0;
          if (_geoPoint)
            flags |= 2;
          w.uint(flags);
          if (_geoPoint)
            w.object(v.geoPoint);
          if (_address)
            w.string(v.address);
        },
        "account.updateBusinessGreetingMessage": function(w, v) {
          w.uint(1724755908);
          var flags = 0;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 1;
          w.uint(flags);
          if (_message)
            w.object(v.message);
        },
        "account.updateBusinessAwayMessage": function(w, v) {
          w.uint(2724888485);
          var flags = 0;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 1;
          w.uint(flags);
          if (_message)
            w.object(v.message);
        },
        "account.updateConnectedBot": function(w, v) {
          w.uint(1138250269);
          var flags = 0;
          if (v.canReply === true)
            flags |= 1;
          if (v.deleted === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "bot"));
          w.object(h(v, "recipients"));
        },
        "account.getConnectedBots": function(w) {
          w.uint(1319421967);
        },
        "account.getBotBusinessConnection": function(w, v) {
          w.uint(1990746736);
          w.string(h(v, "connectionId"));
        },
        "account.updateBusinessIntro": function(w, v) {
          w.uint(2786381876);
          var flags = 0;
          var _intro = v.intro !== void 0;
          if (_intro)
            flags |= 1;
          w.uint(flags);
          if (_intro)
            w.object(v.intro);
        },
        "account.toggleConnectedBotPaused": function(w, v) {
          w.uint(1684934807);
          w.object(h(v, "peer"));
          w.boolean(h(v, "paused"));
        },
        "account.disablePeerConnectedBot": function(w, v) {
          w.uint(1581481689);
          w.object(h(v, "peer"));
        },
        "account.updateBirthday": function(w, v) {
          w.uint(3429764113);
          var flags = 0;
          var _birthday = v.birthday !== void 0;
          if (_birthday)
            flags |= 1;
          w.uint(flags);
          if (_birthday)
            w.object(v.birthday);
        },
        "account.createBusinessChatLink": function(w, v) {
          w.uint(2287068814);
          w.object(h(v, "link"));
        },
        "account.editBusinessChatLink": function(w, v) {
          w.uint(2352222383);
          w.string(h(v, "slug"));
          w.object(h(v, "link"));
        },
        "account.deleteBusinessChatLink": function(w, v) {
          w.uint(1611085428);
          w.string(h(v, "slug"));
        },
        "account.getBusinessChatLinks": function(w) {
          w.uint(1869667809);
        },
        "account.resolveBusinessChatLink": function(w, v) {
          w.uint(1418913262);
          w.string(h(v, "slug"));
        },
        "account.updatePersonalChannel": function(w, v) {
          w.uint(3645048288);
          w.object(h(v, "channel"));
        },
        "account.toggleSponsoredMessages": function(w, v) {
          w.uint(3118048141);
          w.boolean(h(v, "enabled"));
        },
        "account.getReactionsNotifySettings": function(w) {
          w.uint(115172684);
        },
        "account.setReactionsNotifySettings": function(w, v) {
          w.uint(829220168);
          w.object(h(v, "settings"));
        },
        "users.getUsers": function(w, v) {
          w.uint(227648840);
          w.vector(w.object, h(v, "id"));
        },
        "users.getFullUser": function(w, v) {
          w.uint(3054459160);
          w.object(h(v, "id"));
        },
        "users.setSecureValueErrors": function(w, v) {
          w.uint(2429064373);
          w.object(h(v, "id"));
          w.vector(w.object, h(v, "errors"));
        },
        "users.getIsPremiumRequiredToContact": function(w, v) {
          w.uint(2787289616);
          w.vector(w.object, h(v, "id"));
        },
        "contacts.getContactIDs": function(w, v) {
          w.uint(2061264541);
          w.long(h(v, "hash"));
        },
        "contacts.getStatuses": function(w) {
          w.uint(3299038190);
        },
        "contacts.getContacts": function(w, v) {
          w.uint(1574346258);
          w.long(h(v, "hash"));
        },
        "contacts.importContacts": function(w, v) {
          w.uint(746589157);
          w.vector(w.object, h(v, "contacts"));
        },
        "contacts.deleteContacts": function(w, v) {
          w.uint(157945344);
          w.vector(w.object, h(v, "id"));
        },
        "contacts.deleteByPhones": function(w, v) {
          w.uint(269745566);
          w.vector(w.string, h(v, "phones"));
        },
        "contacts.block": function(w, v) {
          w.uint(774801204);
          var flags = 0;
          if (v.myStoriesFrom === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "id"));
        },
        "contacts.unblock": function(w, v) {
          w.uint(3041973032);
          var flags = 0;
          if (v.myStoriesFrom === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "id"));
        },
        "contacts.getBlocked": function(w, v) {
          w.uint(2592509824);
          var flags = 0;
          if (v.myStoriesFrom === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "contacts.search": function(w, v) {
          w.uint(301470424);
          w.string(h(v, "q"));
          w.int(h(v, "limit"));
        },
        "contacts.resolveUsername": function(w, v) {
          w.uint(4181511075);
          w.string(h(v, "username"));
        },
        "contacts.getTopPeers": function(w, v) {
          w.uint(2536798390);
          var flags = 0;
          if (v.correspondents === true)
            flags |= 1;
          if (v.botsPm === true)
            flags |= 2;
          if (v.botsInline === true)
            flags |= 4;
          if (v.phoneCalls === true)
            flags |= 8;
          if (v.forwardUsers === true)
            flags |= 16;
          if (v.forwardChats === true)
            flags |= 32;
          if (v.groups === true)
            flags |= 1024;
          if (v.channels === true)
            flags |= 32768;
          if (v.botsApp === true)
            flags |= 65536;
          w.uint(flags);
          w.int(h(v, "offset"));
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "contacts.resetTopPeerRating": function(w, v) {
          w.uint(451113900);
          w.object(h(v, "category"));
          w.object(h(v, "peer"));
        },
        "contacts.resetSaved": function(w) {
          w.uint(2274703345);
        },
        "contacts.getSaved": function(w) {
          w.uint(2196890527);
        },
        "contacts.toggleTopPeers": function(w, v) {
          w.uint(2232729050);
          w.boolean(h(v, "enabled"));
        },
        "contacts.addContact": function(w, v) {
          w.uint(3908330448);
          var flags = 0;
          if (v.addPhonePrivacyException === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "id"));
          w.string(h(v, "firstName"));
          w.string(h(v, "lastName"));
          w.string(h(v, "phone"));
        },
        "contacts.acceptContact": function(w, v) {
          w.uint(4164002319);
          w.object(h(v, "id"));
        },
        "contacts.getLocated": function(w, v) {
          w.uint(3544759364);
          var flags = 0;
          var _selfExpires = v.selfExpires !== void 0;
          if (_selfExpires)
            flags |= 1;
          if (v.background === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "geoPoint"));
          if (_selfExpires)
            w.int(v.selfExpires);
        },
        "contacts.blockFromReplies": function(w, v) {
          w.uint(698914348);
          var flags = 0;
          if (v.deleteMessage === true)
            flags |= 1;
          if (v.deleteHistory === true)
            flags |= 2;
          if (v.reportSpam === true)
            flags |= 4;
          w.uint(flags);
          w.int(h(v, "msgId"));
        },
        "contacts.resolvePhone": function(w, v) {
          w.uint(2331591492);
          w.string(h(v, "phone"));
        },
        "contacts.exportContactToken": function(w) {
          w.uint(4167385127);
        },
        "contacts.importContactToken": function(w, v) {
          w.uint(318789512);
          w.string(h(v, "token"));
        },
        "contacts.editCloseFriends": function(w, v) {
          w.uint(3127313904);
          w.vector(w.int53, h(v, "id"));
        },
        "contacts.setBlocked": function(w, v) {
          w.uint(2496027766);
          var flags = 0;
          if (v.myStoriesFrom === true)
            flags |= 1;
          w.uint(flags);
          w.vector(w.object, h(v, "id"));
          w.int(h(v, "limit"));
        },
        "contacts.getBirthdays": function(w) {
          w.uint(3673008228);
        },
        "messages.getMessages": function(w, v) {
          w.uint(1673946374);
          w.vector(w.object, h(v, "id"));
        },
        "messages.getDialogs": function(w, v) {
          w.uint(2700397391);
          var flags = 0;
          if (v.excludePinned === true)
            flags |= 1;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 2;
          w.uint(flags);
          if (_folderId)
            w.int(v.folderId);
          w.int(h(v, "offsetDate"));
          w.int(h(v, "offsetId"));
          w.object(h(v, "offsetPeer"));
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "messages.getHistory": function(w, v) {
          w.uint(1143203525);
          w.object(h(v, "peer"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "offsetDate"));
          w.int(h(v, "addOffset"));
          w.int(h(v, "limit"));
          w.int(h(v, "maxId"));
          w.int(h(v, "minId"));
          w.long(h(v, "hash"));
        },
        "messages.search": function(w, v) {
          w.uint(703497338);
          var flags = 0;
          var _fromId = v.fromId !== void 0;
          if (_fromId)
            flags |= 1;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 2;
          var _savedPeerId = v.savedPeerId !== void 0;
          if (_savedPeerId)
            flags |= 4;
          var _savedReaction = v.savedReaction && v.savedReaction.length;
          if (_savedReaction)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.string(h(v, "q"));
          if (_fromId)
            w.object(v.fromId);
          if (_savedPeerId)
            w.object(v.savedPeerId);
          if (_savedReaction)
            w.vector(w.object, v.savedReaction);
          if (_topMsgId)
            w.int(v.topMsgId);
          w.object(h(v, "filter"));
          w.int(h(v, "minDate"));
          w.int(h(v, "maxDate"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "addOffset"));
          w.int(h(v, "limit"));
          w.int(h(v, "maxId"));
          w.int(h(v, "minId"));
          w.long(h(v, "hash"));
        },
        "messages.readHistory": function(w, v) {
          w.uint(238054714);
          w.object(h(v, "peer"));
          w.int(h(v, "maxId"));
        },
        "messages.deleteHistory": function(w, v) {
          w.uint(2962199082);
          var flags = 0;
          if (v.justClear === true)
            flags |= 1;
          if (v.revoke === true)
            flags |= 2;
          var _minDate = v.minDate !== void 0;
          if (_minDate)
            flags |= 4;
          var _maxDate = v.maxDate !== void 0;
          if (_maxDate)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "maxId"));
          if (_minDate)
            w.int(v.minDate);
          if (_maxDate)
            w.int(v.maxDate);
        },
        "messages.deleteMessages": function(w, v) {
          w.uint(3851326930);
          var flags = 0;
          if (v.revoke === true)
            flags |= 1;
          w.uint(flags);
          w.vector(w.int, h(v, "id"));
        },
        "messages.receivedMessages": function(w, v) {
          w.uint(94983360);
          w.int(h(v, "maxId"));
        },
        "messages.setTyping": function(w, v) {
          w.uint(1486110434);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_topMsgId)
            w.int(v.topMsgId);
          w.object(h(v, "action"));
        },
        "messages.sendMessage": function(w, v) {
          w.uint(2554304325);
          var flags = 0;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 1;
          if (v.noWebpage === true)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 8;
          if (v.silent === true)
            flags |= 32;
          if (v.background === true)
            flags |= 64;
          if (v.clearDraft === true)
            flags |= 128;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 1024;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 8192;
          if (v.noforwards === true)
            flags |= 16384;
          if (v.updateStickersetsOrder === true)
            flags |= 32768;
          if (v.invertMedia === true)
            flags |= 65536;
          var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
          if (_quickReplyShortcut)
            flags |= 131072;
          var _effect = v.effect !== void 0;
          if (_effect)
            flags |= 262144;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_replyTo)
            w.object(v.replyTo);
          w.string(h(v, "message"));
          w.long(h(v, "randomId"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
          if (_entities)
            w.vector(w.object, v.entities);
          if (_scheduleDate)
            w.int(v.scheduleDate);
          if (_sendAs)
            w.object(v.sendAs);
          if (_quickReplyShortcut)
            w.object(v.quickReplyShortcut);
          if (_effect)
            w.long(v.effect);
        },
        "messages.sendMedia": function(w, v) {
          w.uint(2018673486);
          var flags = 0;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 1;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 8;
          if (v.silent === true)
            flags |= 32;
          if (v.background === true)
            flags |= 64;
          if (v.clearDraft === true)
            flags |= 128;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 1024;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 8192;
          if (v.noforwards === true)
            flags |= 16384;
          if (v.updateStickersetsOrder === true)
            flags |= 32768;
          if (v.invertMedia === true)
            flags |= 65536;
          var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
          if (_quickReplyShortcut)
            flags |= 131072;
          var _effect = v.effect !== void 0;
          if (_effect)
            flags |= 262144;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_replyTo)
            w.object(v.replyTo);
          w.object(h(v, "media"));
          w.string(h(v, "message"));
          w.long(h(v, "randomId"));
          if (_replyMarkup)
            w.object(v.replyMarkup);
          if (_entities)
            w.vector(w.object, v.entities);
          if (_scheduleDate)
            w.int(v.scheduleDate);
          if (_sendAs)
            w.object(v.sendAs);
          if (_quickReplyShortcut)
            w.object(v.quickReplyShortcut);
          if (_effect)
            w.long(v.effect);
        },
        "messages.forwardMessages": function(w, v) {
          w.uint(3573781e3);
          var flags = 0;
          if (v.silent === true)
            flags |= 32;
          if (v.background === true)
            flags |= 64;
          if (v.withMyScore === true)
            flags |= 256;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 512;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 1024;
          if (v.dropAuthor === true)
            flags |= 2048;
          if (v.dropMediaCaptions === true)
            flags |= 4096;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 8192;
          if (v.noforwards === true)
            flags |= 16384;
          var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
          if (_quickReplyShortcut)
            flags |= 131072;
          w.uint(flags);
          w.object(h(v, "fromPeer"));
          w.vector(w.int, h(v, "id"));
          w.vector(w.long, h(v, "randomId"));
          w.object(h(v, "toPeer"));
          if (_topMsgId)
            w.int(v.topMsgId);
          if (_scheduleDate)
            w.int(v.scheduleDate);
          if (_sendAs)
            w.object(v.sendAs);
          if (_quickReplyShortcut)
            w.object(v.quickReplyShortcut);
        },
        "messages.reportSpam": function(w, v) {
          w.uint(3474297563);
          w.object(h(v, "peer"));
        },
        "messages.getPeerSettings": function(w, v) {
          w.uint(4024018594);
          w.object(h(v, "peer"));
        },
        "messages.report": function(w, v) {
          w.uint(4235767707);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
          w.bytes(h(v, "option"));
          w.string(h(v, "message"));
        },
        "messages.getChats": function(w, v) {
          w.uint(1240027791);
          w.vector(w.int53, h(v, "id"));
        },
        "messages.getFullChat": function(w, v) {
          w.uint(2930772788);
          w.int53(h(v, "chatId"));
        },
        "messages.editChatTitle": function(w, v) {
          w.uint(1937260541);
          w.int53(h(v, "chatId"));
          w.string(h(v, "title"));
        },
        "messages.editChatPhoto": function(w, v) {
          w.uint(903730804);
          w.int53(h(v, "chatId"));
          w.object(h(v, "photo"));
        },
        "messages.addChatUser": function(w, v) {
          w.uint(3418804487);
          w.int53(h(v, "chatId"));
          w.object(h(v, "userId"));
          w.int(h(v, "fwdLimit"));
        },
        "messages.deleteChatUser": function(w, v) {
          w.uint(2719505579);
          var flags = 0;
          if (v.revokeHistory === true)
            flags |= 1;
          w.uint(flags);
          w.int53(h(v, "chatId"));
          w.object(h(v, "userId"));
        },
        "messages.createChat": function(w, v) {
          w.uint(2463030740);
          var flags = 0;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 1;
          w.uint(flags);
          w.vector(w.object, h(v, "users"));
          w.string(h(v, "title"));
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "messages.getDhConfig": function(w, v) {
          w.uint(651135312);
          w.int(h(v, "version"));
          w.int(h(v, "randomLength"));
        },
        "messages.requestEncryption": function(w, v) {
          w.uint(4132286275);
          w.object(h(v, "userId"));
          w.int(h(v, "randomId"));
          w.bytes(h(v, "gA"));
        },
        "messages.acceptEncryption": function(w, v) {
          w.uint(1035731989);
          w.object(h(v, "peer"));
          w.bytes(h(v, "gB"));
          w.long(h(v, "keyFingerprint"));
        },
        "messages.discardEncryption": function(w, v) {
          w.uint(4086541984);
          var flags = 0;
          if (v.deleteHistory === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "chatId"));
        },
        "messages.setEncryptedTyping": function(w, v) {
          w.uint(2031374829);
          w.object(h(v, "peer"));
          w.boolean(h(v, "typing"));
        },
        "messages.readEncryptedHistory": function(w, v) {
          w.uint(2135648522);
          w.object(h(v, "peer"));
          w.int(h(v, "maxDate"));
        },
        "messages.sendEncrypted": function(w, v) {
          w.uint(1157265941);
          var flags = 0;
          if (v.silent === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.long(h(v, "randomId"));
          w.bytes(h(v, "data"));
        },
        "messages.sendEncryptedFile": function(w, v) {
          w.uint(1431914525);
          var flags = 0;
          if (v.silent === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.long(h(v, "randomId"));
          w.bytes(h(v, "data"));
          w.object(h(v, "file"));
        },
        "messages.sendEncryptedService": function(w, v) {
          w.uint(852769188);
          w.object(h(v, "peer"));
          w.long(h(v, "randomId"));
          w.bytes(h(v, "data"));
        },
        "messages.receivedQueue": function(w, v) {
          w.uint(1436924774);
          w.int(h(v, "maxQts"));
        },
        "messages.reportEncryptedSpam": function(w, v) {
          w.uint(1259113487);
          w.object(h(v, "peer"));
        },
        "messages.readMessageContents": function(w, v) {
          w.uint(916930423);
          w.vector(w.int, h(v, "id"));
        },
        "messages.getStickers": function(w, v) {
          w.uint(3584414625);
          w.string(h(v, "emoticon"));
          w.long(h(v, "hash"));
        },
        "messages.getAllStickers": function(w, v) {
          w.uint(3097534888);
          w.long(h(v, "hash"));
        },
        "messages.getWebPagePreview": function(w, v) {
          w.uint(2338894028);
          var flags = 0;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 8;
          w.uint(flags);
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
        },
        "messages.exportChatInvite": function(w, v) {
          w.uint(2757090960);
          var flags = 0;
          var _expireDate = v.expireDate !== void 0;
          if (_expireDate)
            flags |= 1;
          var _usageLimit = v.usageLimit !== void 0;
          if (_usageLimit)
            flags |= 2;
          if (v.legacyRevokePermanent === true)
            flags |= 4;
          if (v.requestNeeded === true)
            flags |= 8;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 16;
          var _subscriptionPricing = v.subscriptionPricing !== void 0;
          if (_subscriptionPricing)
            flags |= 32;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_expireDate)
            w.int(v.expireDate);
          if (_usageLimit)
            w.int(v.usageLimit);
          if (_title)
            w.string(v.title);
          if (_subscriptionPricing)
            w.object(v.subscriptionPricing);
        },
        "messages.checkChatInvite": function(w, v) {
          w.uint(1051570619);
          w.string(h(v, "hash"));
        },
        "messages.importChatInvite": function(w, v) {
          w.uint(1817183516);
          w.string(h(v, "hash"));
        },
        "messages.getStickerSet": function(w, v) {
          w.uint(3365989492);
          w.object(h(v, "stickerset"));
          w.int(h(v, "hash"));
        },
        "messages.installStickerSet": function(w, v) {
          w.uint(3348096096);
          w.object(h(v, "stickerset"));
          w.boolean(h(v, "archived"));
        },
        "messages.uninstallStickerSet": function(w, v) {
          w.uint(4184757726);
          w.object(h(v, "stickerset"));
        },
        "messages.startBot": function(w, v) {
          w.uint(3873403768);
          w.object(h(v, "bot"));
          w.object(h(v, "peer"));
          w.long(h(v, "randomId"));
          w.string(h(v, "startParam"));
        },
        "messages.getMessagesViews": function(w, v) {
          w.uint(1468322785);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
          w.boolean(h(v, "increment"));
        },
        "messages.editChatAdmin": function(w, v) {
          w.uint(2824589762);
          w.int53(h(v, "chatId"));
          w.object(h(v, "userId"));
          w.boolean(h(v, "isAdmin"));
        },
        "messages.migrateChat": function(w, v) {
          w.uint(2726777625);
          w.int53(h(v, "chatId"));
        },
        "messages.searchGlobal": function(w, v) {
          w.uint(1271290010);
          var flags = 0;
          var _folderId = v.folderId !== void 0;
          if (_folderId)
            flags |= 1;
          if (v.broadcastsOnly === true)
            flags |= 2;
          w.uint(flags);
          if (_folderId)
            w.int(v.folderId);
          w.string(h(v, "q"));
          w.object(h(v, "filter"));
          w.int(h(v, "minDate"));
          w.int(h(v, "maxDate"));
          w.int(h(v, "offsetRate"));
          w.object(h(v, "offsetPeer"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "limit"));
        },
        "messages.reorderStickerSets": function(w, v) {
          w.uint(2016638777);
          var flags = 0;
          if (v.masks === true)
            flags |= 1;
          if (v.emojis === true)
            flags |= 2;
          w.uint(flags);
          w.vector(w.long, h(v, "order"));
        },
        "messages.getDocumentByHash": function(w, v) {
          w.uint(2985428511);
          w.bytes(h(v, "sha256"));
          w.int53(h(v, "size"));
          w.string(h(v, "mimeType"));
        },
        "messages.getSavedGifs": function(w, v) {
          w.uint(1559270965);
          w.long(h(v, "hash"));
        },
        "messages.saveGif": function(w, v) {
          w.uint(846868683);
          w.object(h(v, "id"));
          w.boolean(h(v, "unsave"));
        },
        "messages.getInlineBotResults": function(w, v) {
          w.uint(1364105629);
          var flags = 0;
          var _geoPoint = v.geoPoint !== void 0;
          if (_geoPoint)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "bot"));
          w.object(h(v, "peer"));
          if (_geoPoint)
            w.object(v.geoPoint);
          w.string(h(v, "query"));
          w.string(h(v, "offset"));
        },
        "messages.setInlineBotResults": function(w, v) {
          w.uint(3138561049);
          var flags = 0;
          if (v.gallery === true)
            flags |= 1;
          if (v.private === true)
            flags |= 2;
          var _nextOffset = v.nextOffset !== void 0;
          if (_nextOffset)
            flags |= 4;
          var _switchPm = v.switchPm !== void 0;
          if (_switchPm)
            flags |= 8;
          var _switchWebview = v.switchWebview !== void 0;
          if (_switchWebview)
            flags |= 16;
          w.uint(flags);
          w.long(h(v, "queryId"));
          w.vector(w.object, h(v, "results"));
          w.int(h(v, "cacheTime"));
          if (_nextOffset)
            w.string(v.nextOffset);
          if (_switchPm)
            w.object(v.switchPm);
          if (_switchWebview)
            w.object(v.switchWebview);
        },
        "messages.sendInlineBotResult": function(w, v) {
          w.uint(1052698730);
          var flags = 0;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 1;
          if (v.silent === true)
            flags |= 32;
          if (v.background === true)
            flags |= 64;
          if (v.clearDraft === true)
            flags |= 128;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 1024;
          if (v.hideVia === true)
            flags |= 2048;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 8192;
          var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
          if (_quickReplyShortcut)
            flags |= 131072;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_replyTo)
            w.object(v.replyTo);
          w.long(h(v, "randomId"));
          w.long(h(v, "queryId"));
          w.string(h(v, "id"));
          if (_scheduleDate)
            w.int(v.scheduleDate);
          if (_sendAs)
            w.object(v.sendAs);
          if (_quickReplyShortcut)
            w.object(v.quickReplyShortcut);
        },
        "messages.getMessageEditData": function(w, v) {
          w.uint(4255550774);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
        },
        "messages.editMessage": function(w, v) {
          w.uint(3755032581);
          var flags = 0;
          if (v.noWebpage === true)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 8;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 2048;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 16384;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 32768;
          if (v.invertMedia === true)
            flags |= 65536;
          var _quickReplyShortcutId = v.quickReplyShortcutId !== void 0;
          if (_quickReplyShortcutId)
            flags |= 131072;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          if (_message)
            w.string(v.message);
          if (_media)
            w.object(v.media);
          if (_replyMarkup)
            w.object(v.replyMarkup);
          if (_entities)
            w.vector(w.object, v.entities);
          if (_scheduleDate)
            w.int(v.scheduleDate);
          if (_quickReplyShortcutId)
            w.int(v.quickReplyShortcutId);
        },
        "messages.editInlineBotMessage": function(w, v) {
          w.uint(2203418042);
          var flags = 0;
          if (v.noWebpage === true)
            flags |= 2;
          var _replyMarkup = v.replyMarkup !== void 0;
          if (_replyMarkup)
            flags |= 4;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 8;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 2048;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 16384;
          if (v.invertMedia === true)
            flags |= 65536;
          w.uint(flags);
          w.object(h(v, "id"));
          if (_message)
            w.string(v.message);
          if (_media)
            w.object(v.media);
          if (_replyMarkup)
            w.object(v.replyMarkup);
          if (_entities)
            w.vector(w.object, v.entities);
        },
        "messages.getBotCallbackAnswer": function(w, v) {
          w.uint(2470627847);
          var flags = 0;
          var _data = v.data !== void 0;
          if (_data)
            flags |= 1;
          if (v.game === true)
            flags |= 2;
          var _password = v.password !== void 0;
          if (_password)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          if (_data)
            w.bytes(v.data);
          if (_password)
            w.object(v.password);
        },
        "messages.setBotCallbackAnswer": function(w, v) {
          w.uint(3582923530);
          var flags = 0;
          var _message = v.message !== void 0;
          if (_message)
            flags |= 1;
          if (v.alert === true)
            flags |= 2;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "queryId"));
          if (_message)
            w.string(v.message);
          if (_url)
            w.string(v.url);
          w.int(h(v, "cacheTime"));
        },
        "messages.getPeerDialogs": function(w, v) {
          w.uint(3832593661);
          w.vector(w.object, h(v, "peers"));
        },
        "messages.saveDraft": function(w, v) {
          w.uint(3547514318);
          var flags = 0;
          if (v.noWebpage === true)
            flags |= 2;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 8;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 16;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 32;
          if (v.invertMedia === true)
            flags |= 64;
          var _effect = v.effect !== void 0;
          if (_effect)
            flags |= 128;
          w.uint(flags);
          if (_replyTo)
            w.object(v.replyTo);
          w.object(h(v, "peer"));
          w.string(h(v, "message"));
          if (_entities)
            w.vector(w.object, v.entities);
          if (_media)
            w.object(v.media);
          if (_effect)
            w.long(v.effect);
        },
        "messages.getAllDrafts": function(w) {
          w.uint(1782549861);
        },
        "messages.getFeaturedStickers": function(w, v) {
          w.uint(1685588756);
          w.long(h(v, "hash"));
        },
        "messages.readFeaturedStickers": function(w, v) {
          w.uint(1527873830);
          w.vector(w.long, h(v, "id"));
        },
        "messages.getRecentStickers": function(w, v) {
          w.uint(2645114939);
          var flags = 0;
          if (v.attached === true)
            flags |= 1;
          w.uint(flags);
          w.long(h(v, "hash"));
        },
        "messages.saveRecentSticker": function(w, v) {
          w.uint(958863608);
          var flags = 0;
          if (v.attached === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "id"));
          w.boolean(h(v, "unsave"));
        },
        "messages.clearRecentStickers": function(w, v) {
          w.uint(2308530221);
          var flags = 0;
          if (v.attached === true)
            flags |= 1;
          w.uint(flags);
        },
        "messages.getArchivedStickers": function(w, v) {
          w.uint(1475442322);
          var flags = 0;
          if (v.masks === true)
            flags |= 1;
          if (v.emojis === true)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "offsetId"));
          w.int(h(v, "limit"));
        },
        "messages.getMaskStickers": function(w, v) {
          w.uint(1678738104);
          w.long(h(v, "hash"));
        },
        "messages.getAttachedStickers": function(w, v) {
          w.uint(3428542412);
          w.object(h(v, "media"));
        },
        "messages.setGameScore": function(w, v) {
          w.uint(2398678208);
          var flags = 0;
          if (v.editMessage === true)
            flags |= 1;
          if (v.force === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          w.object(h(v, "userId"));
          w.int(h(v, "score"));
        },
        "messages.setInlineGameScore": function(w, v) {
          w.uint(363700068);
          var flags = 0;
          if (v.editMessage === true)
            flags |= 1;
          if (v.force === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "id"));
          w.object(h(v, "userId"));
          w.int(h(v, "score"));
        },
        "messages.getGameHighScores": function(w, v) {
          w.uint(3894568093);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          w.object(h(v, "userId"));
        },
        "messages.getInlineGameHighScores": function(w, v) {
          w.uint(258170395);
          w.object(h(v, "id"));
          w.object(h(v, "userId"));
        },
        "messages.getCommonChats": function(w, v) {
          w.uint(3826032900);
          w.object(h(v, "userId"));
          w.int53(h(v, "maxId"));
          w.int(h(v, "limit"));
        },
        "messages.getWebPage": function(w, v) {
          w.uint(2375455395);
          w.string(h(v, "url"));
          w.int(h(v, "hash"));
        },
        "messages.toggleDialogPin": function(w, v) {
          w.uint(2805064279);
          var flags = 0;
          if (v.pinned === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "messages.reorderPinnedDialogs": function(w, v) {
          w.uint(991616823);
          var flags = 0;
          if (v.force === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "folderId"));
          w.vector(w.object, h(v, "order"));
        },
        "messages.getPinnedDialogs": function(w, v) {
          w.uint(3602468338);
          w.int(h(v, "folderId"));
        },
        "messages.setBotShippingResults": function(w, v) {
          w.uint(3858133754);
          var flags = 0;
          var _error = v.error !== void 0;
          if (_error)
            flags |= 1;
          var _shippingOptions = v.shippingOptions && v.shippingOptions.length;
          if (_shippingOptions)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "queryId"));
          if (_error)
            w.string(v.error);
          if (_shippingOptions)
            w.vector(w.object, v.shippingOptions);
        },
        "messages.setBotPrecheckoutResults": function(w, v) {
          w.uint(163765653);
          var flags = 0;
          var _error = v.error !== void 0;
          if (_error)
            flags |= 1;
          if (v.success === true)
            flags |= 2;
          w.uint(flags);
          w.long(h(v, "queryId"));
          if (_error)
            w.string(v.error);
        },
        "messages.uploadMedia": function(w, v) {
          w.uint(345405816);
          var flags = 0;
          var _businessConnectionId = v.businessConnectionId !== void 0;
          if (_businessConnectionId)
            flags |= 1;
          w.uint(flags);
          if (_businessConnectionId)
            w.string(v.businessConnectionId);
          w.object(h(v, "peer"));
          w.object(h(v, "media"));
        },
        "messages.sendScreenshotNotification": function(w, v) {
          w.uint(2705348631);
          w.object(h(v, "peer"));
          w.object(h(v, "replyTo"));
          w.long(h(v, "randomId"));
        },
        "messages.getFavedStickers": function(w, v) {
          w.uint(82946729);
          w.long(h(v, "hash"));
        },
        "messages.faveSticker": function(w, v) {
          w.uint(3120547163);
          w.object(h(v, "id"));
          w.boolean(h(v, "unfave"));
        },
        "messages.getUnreadMentions": function(w, v) {
          w.uint(4043827088);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_topMsgId)
            w.int(v.topMsgId);
          w.int(h(v, "offsetId"));
          w.int(h(v, "addOffset"));
          w.int(h(v, "limit"));
          w.int(h(v, "maxId"));
          w.int(h(v, "minId"));
        },
        "messages.readMentions": function(w, v) {
          w.uint(921026381);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_topMsgId)
            w.int(v.topMsgId);
        },
        "messages.getRecentLocations": function(w, v) {
          w.uint(1881817312);
          w.object(h(v, "peer"));
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "messages.sendMultiMedia": function(w, v) {
          w.uint(934757205);
          var flags = 0;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 1;
          if (v.silent === true)
            flags |= 32;
          if (v.background === true)
            flags |= 64;
          if (v.clearDraft === true)
            flags |= 128;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 1024;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 8192;
          if (v.noforwards === true)
            flags |= 16384;
          if (v.updateStickersetsOrder === true)
            flags |= 32768;
          if (v.invertMedia === true)
            flags |= 65536;
          var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
          if (_quickReplyShortcut)
            flags |= 131072;
          var _effect = v.effect !== void 0;
          if (_effect)
            flags |= 262144;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_replyTo)
            w.object(v.replyTo);
          w.vector(w.object, h(v, "multiMedia"));
          if (_scheduleDate)
            w.int(v.scheduleDate);
          if (_sendAs)
            w.object(v.sendAs);
          if (_quickReplyShortcut)
            w.object(v.quickReplyShortcut);
          if (_effect)
            w.long(v.effect);
        },
        "messages.uploadEncryptedFile": function(w, v) {
          w.uint(1347929239);
          w.object(h(v, "peer"));
          w.object(h(v, "file"));
        },
        "messages.searchStickerSets": function(w, v) {
          w.uint(896555914);
          var flags = 0;
          if (v.excludeFeatured === true)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "q"));
          w.long(h(v, "hash"));
        },
        "messages.getSplitRanges": function(w) {
          w.uint(486505992);
        },
        "messages.markDialogUnread": function(w, v) {
          w.uint(3263617423);
          var flags = 0;
          if (v.unread === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "messages.getDialogUnreadMarks": function(w) {
          w.uint(585256482);
        },
        "messages.clearAllDrafts": function(w) {
          w.uint(2119757468);
        },
        "messages.updatePinnedMessage": function(w, v) {
          w.uint(3534419948);
          var flags = 0;
          if (v.silent === true)
            flags |= 1;
          if (v.unpin === true)
            flags |= 2;
          if (v.pmOneside === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
        },
        "messages.sendVote": function(w, v) {
          w.uint(283795844);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.vector(w.bytes, h(v, "options"));
        },
        "messages.getPollResults": function(w, v) {
          w.uint(1941660731);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "messages.getOnlines": function(w, v) {
          w.uint(1848369232);
          w.object(h(v, "peer"));
        },
        "messages.editChatAbout": function(w, v) {
          w.uint(3740665751);
          w.object(h(v, "peer"));
          w.string(h(v, "about"));
        },
        "messages.editChatDefaultBannedRights": function(w, v) {
          w.uint(2777049921);
          w.object(h(v, "peer"));
          w.object(h(v, "bannedRights"));
        },
        "messages.getEmojiKeywords": function(w, v) {
          w.uint(899735650);
          w.string(h(v, "langCode"));
        },
        "messages.getEmojiKeywordsDifference": function(w, v) {
          w.uint(352892591);
          w.string(h(v, "langCode"));
          w.int(h(v, "fromVersion"));
        },
        "messages.getEmojiKeywordsLanguages": function(w, v) {
          w.uint(1318675378);
          w.vector(w.string, h(v, "langCodes"));
        },
        "messages.getEmojiURL": function(w, v) {
          w.uint(3585149990);
          w.string(h(v, "langCode"));
        },
        "messages.getSearchCounters": function(w, v) {
          w.uint(465367808);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          var _savedPeerId = v.savedPeerId !== void 0;
          if (_savedPeerId)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_savedPeerId)
            w.object(v.savedPeerId);
          if (_topMsgId)
            w.int(v.topMsgId);
          w.vector(w.object, h(v, "filters"));
        },
        "messages.requestUrlAuth": function(w, v) {
          w.uint(428848198);
          var flags = 0;
          var _peer = v.peer !== void 0;
          var _msgId = v.msgId !== void 0;
          var _buttonId = v.buttonId !== void 0;
          var _flags_1 = _peer || _msgId || _buttonId;
          if (_flags_1)
            flags |= 2;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 4;
          w.uint(flags);
          if (_flags_1)
            w.object(v.peer);
          if (_flags_1)
            w.int(v.msgId);
          if (_flags_1)
            w.int(v.buttonId);
          if (_url)
            w.string(v.url);
        },
        "messages.acceptUrlAuth": function(w, v) {
          w.uint(2972479781);
          var flags = 0;
          if (v.writeAllowed === true)
            flags |= 1;
          var _peer = v.peer !== void 0;
          var _msgId = v.msgId !== void 0;
          var _buttonId = v.buttonId !== void 0;
          var _flags_1 = _peer || _msgId || _buttonId;
          if (_flags_1)
            flags |= 2;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 4;
          w.uint(flags);
          if (_flags_1)
            w.object(v.peer);
          if (_flags_1)
            w.int(v.msgId);
          if (_flags_1)
            w.int(v.buttonId);
          if (_url)
            w.string(v.url);
        },
        "messages.hidePeerSettingsBar": function(w, v) {
          w.uint(1336717624);
          w.object(h(v, "peer"));
        },
        "messages.getScheduledHistory": function(w, v) {
          w.uint(4111889931);
          w.object(h(v, "peer"));
          w.long(h(v, "hash"));
        },
        "messages.getScheduledMessages": function(w, v) {
          w.uint(3183150180);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "messages.sendScheduledMessages": function(w, v) {
          w.uint(3174597898);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "messages.deleteScheduledMessages": function(w, v) {
          w.uint(1504586518);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "messages.getPollVotes": function(w, v) {
          w.uint(3094231054);
          var flags = 0;
          var _option = v.option !== void 0;
          if (_option)
            flags |= 1;
          var _offset = v.offset !== void 0;
          if (_offset)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          if (_option)
            w.bytes(v.option);
          if (_offset)
            w.string(v.offset);
          w.int(h(v, "limit"));
        },
        "messages.toggleStickerSets": function(w, v) {
          w.uint(3037016042);
          var flags = 0;
          if (v.uninstall === true)
            flags |= 1;
          if (v.archive === true)
            flags |= 2;
          if (v.unarchive === true)
            flags |= 4;
          w.uint(flags);
          w.vector(w.object, h(v, "stickersets"));
        },
        "messages.getDialogFilters": function(w) {
          w.uint(4023684233);
        },
        "messages.getSuggestedDialogFilters": function(w) {
          w.uint(2728186924);
        },
        "messages.updateDialogFilter": function(w, v) {
          w.uint(450142282);
          var flags = 0;
          var _filter = v.filter !== void 0;
          if (_filter)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "id"));
          if (_filter)
            w.object(v.filter);
        },
        "messages.updateDialogFiltersOrder": function(w, v) {
          w.uint(3311649252);
          w.vector(w.int, h(v, "order"));
        },
        "messages.getOldFeaturedStickers": function(w, v) {
          w.uint(2127598753);
          w.int(h(v, "offset"));
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "messages.getReplies": function(w, v) {
          w.uint(584962828);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "offsetDate"));
          w.int(h(v, "addOffset"));
          w.int(h(v, "limit"));
          w.int(h(v, "maxId"));
          w.int(h(v, "minId"));
          w.long(h(v, "hash"));
        },
        "messages.getDiscussionMessage": function(w, v) {
          w.uint(1147761405);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "messages.readDiscussion": function(w, v) {
          w.uint(4147227124);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int(h(v, "readMaxId"));
        },
        "messages.unpinAllMessages": function(w, v) {
          w.uint(3995253160);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_topMsgId)
            w.int(v.topMsgId);
        },
        "messages.deleteChat": function(w, v) {
          w.uint(1540419152);
          w.int53(h(v, "chatId"));
        },
        "messages.deletePhoneCallHistory": function(w, v) {
          w.uint(4190888969);
          var flags = 0;
          if (v.revoke === true)
            flags |= 1;
          w.uint(flags);
        },
        "messages.checkHistoryImport": function(w, v) {
          w.uint(1140726259);
          w.string(h(v, "importHead"));
        },
        "messages.initHistoryImport": function(w, v) {
          w.uint(873008187);
          w.object(h(v, "peer"));
          w.object(h(v, "file"));
          w.int(h(v, "mediaCount"));
        },
        "messages.uploadImportedMedia": function(w, v) {
          w.uint(713433234);
          w.object(h(v, "peer"));
          w.long(h(v, "importId"));
          w.string(h(v, "fileName"));
          w.object(h(v, "media"));
        },
        "messages.startHistoryImport": function(w, v) {
          w.uint(3023958852);
          w.object(h(v, "peer"));
          w.long(h(v, "importId"));
        },
        "messages.getExportedChatInvites": function(w, v) {
          w.uint(2729812982);
          var flags = 0;
          var _offsetDate = v.offsetDate !== void 0;
          var _offsetLink = v.offsetLink !== void 0;
          var _flags_2 = _offsetDate || _offsetLink;
          if (_flags_2)
            flags |= 4;
          if (v.revoked === true)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "adminId"));
          if (_flags_2)
            w.int(v.offsetDate);
          if (_flags_2)
            w.string(v.offsetLink);
          w.int(h(v, "limit"));
        },
        "messages.getExportedChatInvite": function(w, v) {
          w.uint(1937010524);
          w.object(h(v, "peer"));
          w.string(h(v, "link"));
        },
        "messages.editExportedChatInvite": function(w, v) {
          w.uint(3184144245);
          var flags = 0;
          var _expireDate = v.expireDate !== void 0;
          if (_expireDate)
            flags |= 1;
          var _usageLimit = v.usageLimit !== void 0;
          if (_usageLimit)
            flags |= 2;
          if (v.revoked === true)
            flags |= 4;
          var _requestNeeded = v.requestNeeded !== void 0;
          if (_requestNeeded)
            flags |= 8;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 16;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.string(h(v, "link"));
          if (_expireDate)
            w.int(v.expireDate);
          if (_usageLimit)
            w.int(v.usageLimit);
          if (_requestNeeded)
            w.boolean(v.requestNeeded);
          if (_title)
            w.string(v.title);
        },
        "messages.deleteRevokedExportedChatInvites": function(w, v) {
          w.uint(1452833749);
          w.object(h(v, "peer"));
          w.object(h(v, "adminId"));
        },
        "messages.deleteExportedChatInvite": function(w, v) {
          w.uint(3563365419);
          w.object(h(v, "peer"));
          w.string(h(v, "link"));
        },
        "messages.getAdminsWithInvites": function(w, v) {
          w.uint(958457583);
          w.object(h(v, "peer"));
        },
        "messages.getChatInviteImporters": function(w, v) {
          w.uint(3741637966);
          var flags = 0;
          if (v.requested === true)
            flags |= 1;
          var _link = v.link !== void 0;
          if (_link)
            flags |= 2;
          var _q = v.q !== void 0;
          if (_q)
            flags |= 4;
          if (v.subscriptionExpired === true)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_link)
            w.string(v.link);
          if (_q)
            w.string(v.q);
          w.int(h(v, "offsetDate"));
          w.object(h(v, "offsetUser"));
          w.int(h(v, "limit"));
        },
        "messages.setHistoryTTL": function(w, v) {
          w.uint(3087949796);
          w.object(h(v, "peer"));
          w.int(h(v, "period"));
        },
        "messages.checkHistoryImportPeer": function(w, v) {
          w.uint(1573261059);
          w.object(h(v, "peer"));
        },
        "messages.setChatTheme": function(w, v) {
          w.uint(3862683967);
          w.object(h(v, "peer"));
          w.string(h(v, "emoticon"));
        },
        "messages.getMessageReadParticipants": function(w, v) {
          w.uint(834782287);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "messages.getSearchResultsCalendar": function(w, v) {
          w.uint(1789130429);
          var flags = 0;
          var _savedPeerId = v.savedPeerId !== void 0;
          if (_savedPeerId)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_savedPeerId)
            w.object(v.savedPeerId);
          w.object(h(v, "filter"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "offsetDate"));
        },
        "messages.getSearchResultsPositions": function(w, v) {
          w.uint(2625580816);
          var flags = 0;
          var _savedPeerId = v.savedPeerId !== void 0;
          if (_savedPeerId)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_savedPeerId)
            w.object(v.savedPeerId);
          w.object(h(v, "filter"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "limit"));
        },
        "messages.hideChatJoinRequest": function(w, v) {
          w.uint(2145904661);
          var flags = 0;
          if (v.approved === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "userId"));
        },
        "messages.hideAllChatJoinRequests": function(w, v) {
          w.uint(3766875370);
          var flags = 0;
          if (v.approved === true)
            flags |= 1;
          var _link = v.link !== void 0;
          if (_link)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_link)
            w.string(v.link);
        },
        "messages.toggleNoForwards": function(w, v) {
          w.uint(2971578274);
          w.object(h(v, "peer"));
          w.boolean(h(v, "enabled"));
        },
        "messages.saveDefaultSendAs": function(w, v) {
          w.uint(3439189910);
          w.object(h(v, "peer"));
          w.object(h(v, "sendAs"));
        },
        "messages.sendReaction": function(w, v) {
          w.uint(3540875476);
          var flags = 0;
          var _reaction = v.reaction && v.reaction.length;
          if (_reaction)
            flags |= 1;
          if (v.big === true)
            flags |= 2;
          if (v.addToRecent === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          if (_reaction)
            w.vector(w.object, v.reaction);
        },
        "messages.getMessagesReactions": function(w, v) {
          w.uint(2344259814);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "messages.getMessageReactionsList": function(w, v) {
          w.uint(1176190792);
          var flags = 0;
          var _reaction = v.reaction !== void 0;
          if (_reaction)
            flags |= 1;
          var _offset = v.offset !== void 0;
          if (_offset)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          if (_reaction)
            w.object(v.reaction);
          if (_offset)
            w.string(v.offset);
          w.int(h(v, "limit"));
        },
        "messages.setChatAvailableReactions": function(w, v) {
          w.uint(2253071745);
          var flags = 0;
          var _reactionsLimit = v.reactionsLimit !== void 0;
          if (_reactionsLimit)
            flags |= 1;
          var _paidEnabled = v.paidEnabled !== void 0;
          if (_paidEnabled)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "availableReactions"));
          if (_reactionsLimit)
            w.int(v.reactionsLimit);
          if (_paidEnabled)
            w.boolean(v.paidEnabled);
        },
        "messages.getAvailableReactions": function(w, v) {
          w.uint(417243308);
          w.int(h(v, "hash"));
        },
        "messages.setDefaultReaction": function(w, v) {
          w.uint(1330094102);
          w.object(h(v, "reaction"));
        },
        "messages.translateText": function(w, v) {
          w.uint(1662529584);
          var flags = 0;
          var _peer = v.peer !== void 0;
          var _id = v.id && v.id.length;
          var _flags_0 = _peer || _id;
          if (_flags_0)
            flags |= 1;
          var _text = v.text && v.text.length;
          if (_text)
            flags |= 2;
          w.uint(flags);
          if (_flags_0)
            w.object(v.peer);
          if (_flags_0)
            w.vector(w.int, v.id);
          if (_text)
            w.vector(w.object, v.text);
          w.string(h(v, "toLang"));
        },
        "messages.getUnreadReactions": function(w, v) {
          w.uint(841173339);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_topMsgId)
            w.int(v.topMsgId);
          w.int(h(v, "offsetId"));
          w.int(h(v, "addOffset"));
          w.int(h(v, "limit"));
          w.int(h(v, "maxId"));
          w.int(h(v, "minId"));
        },
        "messages.readReactions": function(w, v) {
          w.uint(1420459918);
          var flags = 0;
          var _topMsgId = v.topMsgId !== void 0;
          if (_topMsgId)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_topMsgId)
            w.int(v.topMsgId);
        },
        "messages.searchSentMedia": function(w, v) {
          w.uint(276705696);
          w.string(h(v, "q"));
          w.object(h(v, "filter"));
          w.int(h(v, "limit"));
        },
        "messages.getAttachMenuBots": function(w, v) {
          w.uint(385663691);
          w.long(h(v, "hash"));
        },
        "messages.getAttachMenuBot": function(w, v) {
          w.uint(1998676370);
          w.object(h(v, "bot"));
        },
        "messages.toggleBotInAttachMenu": function(w, v) {
          w.uint(1777704297);
          var flags = 0;
          if (v.writeAllowed === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "bot"));
          w.boolean(h(v, "enabled"));
        },
        "messages.requestWebView": function(w, v) {
          w.uint(647873217);
          var flags = 0;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 1;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 2;
          var _themeParams = v.themeParams !== void 0;
          if (_themeParams)
            flags |= 4;
          var _startParam = v.startParam !== void 0;
          if (_startParam)
            flags |= 8;
          if (v.fromBotMenu === true)
            flags |= 16;
          if (v.silent === true)
            flags |= 32;
          if (v.compact === true)
            flags |= 128;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 8192;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "bot"));
          if (_url)
            w.string(v.url);
          if (_startParam)
            w.string(v.startParam);
          if (_themeParams)
            w.object(v.themeParams);
          w.string(h(v, "platform"));
          if (_replyTo)
            w.object(v.replyTo);
          if (_sendAs)
            w.object(v.sendAs);
        },
        "messages.prolongWebView": function(w, v) {
          w.uint(2966952579);
          var flags = 0;
          var _replyTo = v.replyTo !== void 0;
          if (_replyTo)
            flags |= 1;
          if (v.silent === true)
            flags |= 32;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 8192;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "bot"));
          w.long(h(v, "queryId"));
          if (_replyTo)
            w.object(v.replyTo);
          if (_sendAs)
            w.object(v.sendAs);
        },
        "messages.requestSimpleWebView": function(w, v) {
          w.uint(1094336115);
          var flags = 0;
          var _themeParams = v.themeParams !== void 0;
          if (_themeParams)
            flags |= 1;
          if (v.fromSwitchWebview === true)
            flags |= 2;
          if (v.fromSideMenu === true)
            flags |= 4;
          var _url = v.url !== void 0;
          if (_url)
            flags |= 8;
          var _startParam = v.startParam !== void 0;
          if (_startParam)
            flags |= 16;
          if (v.compact === true)
            flags |= 128;
          w.uint(flags);
          w.object(h(v, "bot"));
          if (_url)
            w.string(v.url);
          if (_startParam)
            w.string(v.startParam);
          if (_themeParams)
            w.object(v.themeParams);
          w.string(h(v, "platform"));
        },
        "messages.sendWebViewResultMessage": function(w, v) {
          w.uint(172168437);
          w.string(h(v, "botQueryId"));
          w.object(h(v, "result"));
        },
        "messages.sendWebViewData": function(w, v) {
          w.uint(3691135688);
          w.object(h(v, "bot"));
          w.long(h(v, "randomId"));
          w.string(h(v, "buttonText"));
          w.string(h(v, "data"));
        },
        "messages.transcribeAudio": function(w, v) {
          w.uint(647928393);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "messages.rateTranscribedAudio": function(w, v) {
          w.uint(2132608815);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.long(h(v, "transcriptionId"));
          w.boolean(h(v, "good"));
        },
        "messages.getCustomEmojiDocuments": function(w, v) {
          w.uint(3651866452);
          w.vector(w.long, h(v, "documentId"));
        },
        "messages.getEmojiStickers": function(w, v) {
          w.uint(4227637647);
          w.long(h(v, "hash"));
        },
        "messages.getFeaturedEmojiStickers": function(w, v) {
          w.uint(248473398);
          w.long(h(v, "hash"));
        },
        "messages.reportReaction": function(w, v) {
          w.uint(1063567478);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          w.object(h(v, "reactionPeer"));
        },
        "messages.getTopReactions": function(w, v) {
          w.uint(3145803194);
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "messages.getRecentReactions": function(w, v) {
          w.uint(960896434);
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "messages.clearRecentReactions": function(w) {
          w.uint(2650730420);
        },
        "messages.getExtendedMedia": function(w, v) {
          w.uint(2230847508);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "messages.setDefaultHistoryTTL": function(w, v) {
          w.uint(2662667333);
          w.int(h(v, "period"));
        },
        "messages.getDefaultHistoryTTL": function(w) {
          w.uint(1703637384);
        },
        "messages.sendBotRequestedPeer": function(w, v) {
          w.uint(2444415072);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int(h(v, "buttonId"));
          w.vector(w.object, h(v, "requestedPeers"));
        },
        "messages.getEmojiGroups": function(w, v) {
          w.uint(1955122779);
          w.int(h(v, "hash"));
        },
        "messages.getEmojiStatusGroups": function(w, v) {
          w.uint(785209037);
          w.int(h(v, "hash"));
        },
        "messages.getEmojiProfilePhotoGroups": function(w, v) {
          w.uint(564480243);
          w.int(h(v, "hash"));
        },
        "messages.searchCustomEmoji": function(w, v) {
          w.uint(739360983);
          w.string(h(v, "emoticon"));
          w.long(h(v, "hash"));
        },
        "messages.togglePeerTranslations": function(w, v) {
          w.uint(3833378169);
          var flags = 0;
          if (v.disabled === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "messages.getBotApp": function(w, v) {
          w.uint(889046467);
          w.object(h(v, "app"));
          w.long(h(v, "hash"));
        },
        "messages.requestAppWebView": function(w, v) {
          w.uint(1398901710);
          var flags = 0;
          if (v.writeAllowed === true)
            flags |= 1;
          var _startParam = v.startParam !== void 0;
          if (_startParam)
            flags |= 2;
          var _themeParams = v.themeParams !== void 0;
          if (_themeParams)
            flags |= 4;
          if (v.compact === true)
            flags |= 128;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "app"));
          if (_startParam)
            w.string(v.startParam);
          if (_themeParams)
            w.object(v.themeParams);
          w.string(h(v, "platform"));
        },
        "messages.setChatWallPaper": function(w, v) {
          w.uint(2415577825);
          var flags = 0;
          var _wallpaper = v.wallpaper !== void 0;
          if (_wallpaper)
            flags |= 1;
          var _id = v.id !== void 0;
          if (_id)
            flags |= 2;
          var _settings = v.settings !== void 0;
          if (_settings)
            flags |= 4;
          if (v.forBoth === true)
            flags |= 8;
          if (v.revert === true)
            flags |= 16;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_wallpaper)
            w.object(v.wallpaper);
          if (_settings)
            w.object(v.settings);
          if (_id)
            w.int(v.id);
        },
        "messages.searchEmojiStickerSets": function(w, v) {
          w.uint(2461288780);
          var flags = 0;
          if (v.excludeFeatured === true)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "q"));
          w.long(h(v, "hash"));
        },
        "messages.getSavedDialogs": function(w, v) {
          w.uint(1401016858);
          var flags = 0;
          if (v.excludePinned === true)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "offsetDate"));
          w.int(h(v, "offsetId"));
          w.object(h(v, "offsetPeer"));
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "messages.getSavedHistory": function(w, v) {
          w.uint(1033519437);
          w.object(h(v, "peer"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "offsetDate"));
          w.int(h(v, "addOffset"));
          w.int(h(v, "limit"));
          w.int(h(v, "maxId"));
          w.int(h(v, "minId"));
          w.long(h(v, "hash"));
        },
        "messages.deleteSavedHistory": function(w, v) {
          w.uint(1855459371);
          var flags = 0;
          var _minDate = v.minDate !== void 0;
          if (_minDate)
            flags |= 4;
          var _maxDate = v.maxDate !== void 0;
          if (_maxDate)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "maxId"));
          if (_minDate)
            w.int(v.minDate);
          if (_maxDate)
            w.int(v.maxDate);
        },
        "messages.getPinnedSavedDialogs": function(w) {
          w.uint(3594360032);
        },
        "messages.toggleSavedDialogPin": function(w, v) {
          w.uint(2894183390);
          var flags = 0;
          if (v.pinned === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "messages.reorderPinnedSavedDialogs": function(w, v) {
          w.uint(2339464583);
          var flags = 0;
          if (v.force === true)
            flags |= 1;
          w.uint(flags);
          w.vector(w.object, h(v, "order"));
        },
        "messages.getSavedReactionTags": function(w, v) {
          w.uint(909631579);
          var flags = 0;
          var _peer = v.peer !== void 0;
          if (_peer)
            flags |= 1;
          w.uint(flags);
          if (_peer)
            w.object(v.peer);
          w.long(h(v, "hash"));
        },
        "messages.updateSavedReactionTag": function(w, v) {
          w.uint(1613331948);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "reaction"));
          if (_title)
            w.string(v.title);
        },
        "messages.getDefaultTagReactions": function(w, v) {
          w.uint(3187225640);
          w.long(h(v, "hash"));
        },
        "messages.getOutboxReadDate": function(w, v) {
          w.uint(2353790557);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "messages.getQuickReplies": function(w, v) {
          w.uint(3565417128);
          w.long(h(v, "hash"));
        },
        "messages.reorderQuickReplies": function(w, v) {
          w.uint(1613961479);
          w.vector(w.int, h(v, "order"));
        },
        "messages.checkQuickReplyShortcut": function(w, v) {
          w.uint(4057005011);
          w.string(h(v, "shortcut"));
        },
        "messages.editQuickReplyShortcut": function(w, v) {
          w.uint(1543519471);
          w.int(h(v, "shortcutId"));
          w.string(h(v, "shortcut"));
        },
        "messages.deleteQuickReplyShortcut": function(w, v) {
          w.uint(1019234112);
          w.int(h(v, "shortcutId"));
        },
        "messages.getQuickReplyMessages": function(w, v) {
          w.uint(2493814211);
          var flags = 0;
          var _id = v.id && v.id.length;
          if (_id)
            flags |= 1;
          w.uint(flags);
          w.int(h(v, "shortcutId"));
          if (_id)
            w.vector(w.int, v.id);
          w.long(h(v, "hash"));
        },
        "messages.sendQuickReplyMessages": function(w, v) {
          w.uint(1819610593);
          w.object(h(v, "peer"));
          w.int(h(v, "shortcutId"));
          w.vector(w.int, h(v, "id"));
          w.vector(w.long, h(v, "randomId"));
        },
        "messages.deleteQuickReplyMessages": function(w, v) {
          w.uint(3775260944);
          w.int(h(v, "shortcutId"));
          w.vector(w.int, h(v, "id"));
        },
        "messages.toggleDialogFilterTags": function(w, v) {
          w.uint(4247640649);
          w.boolean(h(v, "enabled"));
        },
        "messages.getMyStickers": function(w, v) {
          w.uint(3501580796);
          w.long(h(v, "offsetId"));
          w.int(h(v, "limit"));
        },
        "messages.getEmojiStickerGroups": function(w, v) {
          w.uint(500711669);
          w.int(h(v, "hash"));
        },
        "messages.getAvailableEffects": function(w, v) {
          w.uint(3735161401);
          w.int(h(v, "hash"));
        },
        "messages.editFactCheck": function(w, v) {
          w.uint(92925557);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.object(h(v, "text"));
        },
        "messages.deleteFactCheck": function(w, v) {
          w.uint(3520762892);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "messages.getFactCheck": function(w, v) {
          w.uint(3117270510);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "msgId"));
        },
        "messages.requestMainWebView": function(w, v) {
          w.uint(3386908283);
          var flags = 0;
          var _themeParams = v.themeParams !== void 0;
          if (_themeParams)
            flags |= 1;
          var _startParam = v.startParam !== void 0;
          if (_startParam)
            flags |= 2;
          if (v.compact === true)
            flags |= 128;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "bot"));
          if (_startParam)
            w.string(v.startParam);
          if (_themeParams)
            w.object(v.themeParams);
          w.string(h(v, "platform"));
        },
        "messages.sendPaidReaction": function(w, v) {
          w.uint(2648090235);
          var flags = 0;
          var _private = v.private !== void 0;
          if (_private)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.int(h(v, "count"));
          w.long(h(v, "randomId"));
          if (_private)
            w.boolean(v.private);
        },
        "messages.togglePaidReactionPrivacy": function(w, v) {
          w.uint(2224739223);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
          w.boolean(h(v, "private"));
        },
        "messages.getPaidReactionPrivacy": function(w) {
          w.uint(1193563562);
        },
        "updates.getState": function(w) {
          w.uint(3990128682);
        },
        "updates.getDifference": function(w, v) {
          w.uint(432207715);
          var flags = 0;
          var _ptsTotalLimit = v.ptsTotalLimit !== void 0;
          if (_ptsTotalLimit)
            flags |= 1;
          var _ptsLimit = v.ptsLimit !== void 0;
          if (_ptsLimit)
            flags |= 2;
          var _qtsLimit = v.qtsLimit !== void 0;
          if (_qtsLimit)
            flags |= 4;
          w.uint(flags);
          w.int(h(v, "pts"));
          if (_ptsLimit)
            w.int(v.ptsLimit);
          if (_ptsTotalLimit)
            w.int(v.ptsTotalLimit);
          w.int(h(v, "date"));
          w.int(h(v, "qts"));
          if (_qtsLimit)
            w.int(v.qtsLimit);
        },
        "updates.getChannelDifference": function(w, v) {
          w.uint(51854712);
          var flags = 0;
          if (v.force === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.object(h(v, "filter"));
          w.int(h(v, "pts"));
          w.int(h(v, "limit"));
        },
        "photos.updateProfilePhoto": function(w, v) {
          w.uint(166207545);
          var flags = 0;
          if (v.fallback === true)
            flags |= 1;
          var _bot = v.bot !== void 0;
          if (_bot)
            flags |= 2;
          w.uint(flags);
          if (_bot)
            w.object(v.bot);
          w.object(h(v, "id"));
        },
        "photos.uploadProfilePhoto": function(w, v) {
          w.uint(59286453);
          var flags = 0;
          var _file = v.file !== void 0;
          if (_file)
            flags |= 1;
          var _video = v.video !== void 0;
          if (_video)
            flags |= 2;
          var _videoStartTs = v.videoStartTs !== void 0;
          if (_videoStartTs)
            flags |= 4;
          if (v.fallback === true)
            flags |= 8;
          var _videoEmojiMarkup = v.videoEmojiMarkup !== void 0;
          if (_videoEmojiMarkup)
            flags |= 16;
          var _bot = v.bot !== void 0;
          if (_bot)
            flags |= 32;
          w.uint(flags);
          if (_bot)
            w.object(v.bot);
          if (_file)
            w.object(v.file);
          if (_video)
            w.object(v.video);
          if (_videoStartTs)
            w.double(v.videoStartTs);
          if (_videoEmojiMarkup)
            w.object(v.videoEmojiMarkup);
        },
        "photos.deletePhotos": function(w, v) {
          w.uint(2278522671);
          w.vector(w.object, h(v, "id"));
        },
        "photos.getUserPhotos": function(w, v) {
          w.uint(2446144168);
          w.object(h(v, "userId"));
          w.int(h(v, "offset"));
          w.long(h(v, "maxId"));
          w.int(h(v, "limit"));
        },
        "photos.uploadContactProfilePhoto": function(w, v) {
          w.uint(3779873393);
          var flags = 0;
          var _file = v.file !== void 0;
          if (_file)
            flags |= 1;
          var _video = v.video !== void 0;
          if (_video)
            flags |= 2;
          var _videoStartTs = v.videoStartTs !== void 0;
          if (_videoStartTs)
            flags |= 4;
          if (v.suggest === true)
            flags |= 8;
          if (v.save === true)
            flags |= 16;
          var _videoEmojiMarkup = v.videoEmojiMarkup !== void 0;
          if (_videoEmojiMarkup)
            flags |= 32;
          w.uint(flags);
          w.object(h(v, "userId"));
          if (_file)
            w.object(v.file);
          if (_video)
            w.object(v.video);
          if (_videoStartTs)
            w.double(v.videoStartTs);
          if (_videoEmojiMarkup)
            w.object(v.videoEmojiMarkup);
        },
        "upload.saveFilePart": function(w, v) {
          w.uint(3003426337);
          w.long(h(v, "fileId"));
          w.int(h(v, "filePart"));
          w.bytes(h(v, "bytes"));
        },
        "upload.getFile": function(w, v) {
          w.uint(3193124286);
          var flags = 0;
          if (v.precise === true)
            flags |= 1;
          if (v.cdnSupported === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "location"));
          w.int53(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "upload.saveBigFilePart": function(w, v) {
          w.uint(3732629309);
          w.long(h(v, "fileId"));
          w.int(h(v, "filePart"));
          w.int(h(v, "fileTotalParts"));
          w.bytes(h(v, "bytes"));
        },
        "upload.getWebFile": function(w, v) {
          w.uint(619086221);
          w.object(h(v, "location"));
          w.int(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "upload.getCdnFile": function(w, v) {
          w.uint(962554330);
          w.bytes(h(v, "fileToken"));
          w.int53(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "upload.reuploadCdnFile": function(w, v) {
          w.uint(2603046056);
          w.bytes(h(v, "fileToken"));
          w.bytes(h(v, "requestToken"));
        },
        "upload.getCdnFileHashes": function(w, v) {
          w.uint(2447130417);
          w.bytes(h(v, "fileToken"));
          w.int53(h(v, "offset"));
        },
        "upload.getFileHashes": function(w, v) {
          w.uint(2438371370);
          w.object(h(v, "location"));
          w.int53(h(v, "offset"));
        },
        "help.getConfig": function(w) {
          w.uint(3304659051);
        },
        "help.getNearestDc": function(w) {
          w.uint(531836966);
        },
        "help.getAppUpdate": function(w, v) {
          w.uint(1378703997);
          w.string(h(v, "source"));
        },
        "help.getInviteText": function(w) {
          w.uint(1295590211);
        },
        "help.getSupport": function(w) {
          w.uint(2631862477);
        },
        "help.setBotUpdatesStatus": function(w, v) {
          w.uint(3961704397);
          w.int(h(v, "pendingUpdatesCount"));
          w.string(h(v, "message"));
        },
        "help.getCdnConfig": function(w) {
          w.uint(1375900482);
        },
        "help.getRecentMeUrls": function(w, v) {
          w.uint(1036054804);
          w.string(h(v, "referer"));
        },
        "help.getTermsOfServiceUpdate": function(w) {
          w.uint(749019089);
        },
        "help.acceptTermsOfService": function(w, v) {
          w.uint(4000511898);
          w.object(h(v, "id"));
        },
        "help.getDeepLinkInfo": function(w, v) {
          w.uint(1072547679);
          w.string(h(v, "path"));
        },
        "help.getAppConfig": function(w, v) {
          w.uint(1642330196);
          w.int(h(v, "hash"));
        },
        "help.saveAppLog": function(w, v) {
          w.uint(1862465352);
          w.vector(w.object, h(v, "events"));
        },
        "help.getPassportConfig": function(w, v) {
          w.uint(3328290056);
          w.int(h(v, "hash"));
        },
        "help.getSupportName": function(w) {
          w.uint(3546343212);
        },
        "help.getUserInfo": function(w, v) {
          w.uint(59377875);
          w.object(h(v, "userId"));
        },
        "help.editUserInfo": function(w, v) {
          w.uint(1723407216);
          w.object(h(v, "userId"));
          w.string(h(v, "message"));
          w.vector(w.object, h(v, "entities"));
        },
        "help.getPromoData": function(w) {
          w.uint(3231151137);
        },
        "help.hidePromoData": function(w, v) {
          w.uint(505748629);
          w.object(h(v, "peer"));
        },
        "help.dismissSuggestion": function(w, v) {
          w.uint(4111317665);
          w.object(h(v, "peer"));
          w.string(h(v, "suggestion"));
        },
        "help.getCountriesList": function(w, v) {
          w.uint(1935116200);
          w.string(h(v, "langCode"));
          w.int(h(v, "hash"));
        },
        "help.getPremiumPromo": function(w) {
          w.uint(3088815060);
        },
        "help.getPeerColors": function(w, v) {
          w.uint(3665884207);
          w.int(h(v, "hash"));
        },
        "help.getPeerProfileColors": function(w, v) {
          w.uint(2882513405);
          w.int(h(v, "hash"));
        },
        "help.getTimezonesList": function(w, v) {
          w.uint(1236468288);
          w.int(h(v, "hash"));
        },
        "channels.readHistory": function(w, v) {
          w.uint(3423619383);
          w.object(h(v, "channel"));
          w.int(h(v, "maxId"));
        },
        "channels.deleteMessages": function(w, v) {
          w.uint(2227305806);
          w.object(h(v, "channel"));
          w.vector(w.int, h(v, "id"));
        },
        "channels.reportSpam": function(w, v) {
          w.uint(4098523925);
          w.object(h(v, "channel"));
          w.object(h(v, "participant"));
          w.vector(w.int, h(v, "id"));
        },
        "channels.getMessages": function(w, v) {
          w.uint(2911672867);
          w.object(h(v, "channel"));
          w.vector(w.object, h(v, "id"));
        },
        "channels.getParticipants": function(w, v) {
          w.uint(2010044880);
          w.object(h(v, "channel"));
          w.object(h(v, "filter"));
          w.int(h(v, "offset"));
          w.int(h(v, "limit"));
          w.long(h(v, "hash"));
        },
        "channels.getParticipant": function(w, v) {
          w.uint(2695589062);
          w.object(h(v, "channel"));
          w.object(h(v, "participant"));
        },
        "channels.getChannels": function(w, v) {
          w.uint(176122811);
          w.vector(w.object, h(v, "id"));
        },
        "channels.getFullChannel": function(w, v) {
          w.uint(141781513);
          w.object(h(v, "channel"));
        },
        "channels.createChannel": function(w, v) {
          w.uint(2432722695);
          var flags = 0;
          if (v.broadcast === true)
            flags |= 1;
          if (v.megagroup === true)
            flags |= 2;
          var _geoPoint = v.geoPoint !== void 0;
          var _address = v.address !== void 0;
          var _flags_2 = _geoPoint || _address;
          if (_flags_2)
            flags |= 4;
          if (v.forImport === true)
            flags |= 8;
          var _ttlPeriod = v.ttlPeriod !== void 0;
          if (_ttlPeriod)
            flags |= 16;
          if (v.forum === true)
            flags |= 32;
          w.uint(flags);
          w.string(h(v, "title"));
          w.string(h(v, "about"));
          if (_flags_2)
            w.object(v.geoPoint);
          if (_flags_2)
            w.string(v.address);
          if (_ttlPeriod)
            w.int(v.ttlPeriod);
        },
        "channels.editAdmin": function(w, v) {
          w.uint(3543959810);
          w.object(h(v, "channel"));
          w.object(h(v, "userId"));
          w.object(h(v, "adminRights"));
          w.string(h(v, "rank"));
        },
        "channels.editTitle": function(w, v) {
          w.uint(1450044624);
          w.object(h(v, "channel"));
          w.string(h(v, "title"));
        },
        "channels.editPhoto": function(w, v) {
          w.uint(4046346185);
          w.object(h(v, "channel"));
          w.object(h(v, "photo"));
        },
        "channels.checkUsername": function(w, v) {
          w.uint(283557164);
          w.object(h(v, "channel"));
          w.string(h(v, "username"));
        },
        "channels.updateUsername": function(w, v) {
          w.uint(890549214);
          w.object(h(v, "channel"));
          w.string(h(v, "username"));
        },
        "channels.joinChannel": function(w, v) {
          w.uint(615851205);
          w.object(h(v, "channel"));
        },
        "channels.leaveChannel": function(w, v) {
          w.uint(4164332181);
          w.object(h(v, "channel"));
        },
        "channels.inviteToChannel": function(w, v) {
          w.uint(3387112788);
          w.object(h(v, "channel"));
          w.vector(w.object, h(v, "users"));
        },
        "channels.deleteChannel": function(w, v) {
          w.uint(3222347747);
          w.object(h(v, "channel"));
        },
        "channels.exportMessageLink": function(w, v) {
          w.uint(3862932971);
          var flags = 0;
          if (v.grouped === true)
            flags |= 1;
          if (v.thread === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.int(h(v, "id"));
        },
        "channels.toggleSignatures": function(w, v) {
          w.uint(1099781276);
          var flags = 0;
          if (v.signaturesEnabled === true)
            flags |= 1;
          if (v.profilesEnabled === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "channel"));
        },
        "channels.getAdminedPublicChannels": function(w, v) {
          w.uint(4172297903);
          var flags = 0;
          if (v.byLocation === true)
            flags |= 1;
          if (v.checkLimit === true)
            flags |= 2;
          if (v.forPersonal === true)
            flags |= 4;
          w.uint(flags);
        },
        "channels.editBanned": function(w, v) {
          w.uint(2531708289);
          w.object(h(v, "channel"));
          w.object(h(v, "participant"));
          w.object(h(v, "bannedRights"));
        },
        "channels.getAdminLog": function(w, v) {
          w.uint(870184064);
          var flags = 0;
          var _eventsFilter = v.eventsFilter !== void 0;
          if (_eventsFilter)
            flags |= 1;
          var _admins = v.admins && v.admins.length;
          if (_admins)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.string(h(v, "q"));
          if (_eventsFilter)
            w.object(v.eventsFilter);
          if (_admins)
            w.vector(w.object, v.admins);
          w.long(h(v, "maxId"));
          w.long(h(v, "minId"));
          w.int(h(v, "limit"));
        },
        "channels.setStickers": function(w, v) {
          w.uint(3935085817);
          w.object(h(v, "channel"));
          w.object(h(v, "stickerset"));
        },
        "channels.readMessageContents": function(w, v) {
          w.uint(3937786936);
          w.object(h(v, "channel"));
          w.vector(w.int, h(v, "id"));
        },
        "channels.deleteHistory": function(w, v) {
          w.uint(2611648071);
          var flags = 0;
          if (v.forEveryone === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.int(h(v, "maxId"));
        },
        "channels.togglePreHistoryHidden": function(w, v) {
          w.uint(3938171212);
          w.object(h(v, "channel"));
          w.boolean(h(v, "enabled"));
        },
        "channels.getLeftChannels": function(w, v) {
          w.uint(2202135744);
          w.int(h(v, "offset"));
        },
        "channels.getGroupsForDiscussion": function(w) {
          w.uint(4124758904);
        },
        "channels.setDiscussionGroup": function(w, v) {
          w.uint(1079520178);
          w.object(h(v, "broadcast"));
          w.object(h(v, "group"));
        },
        "channels.editCreator": function(w, v) {
          w.uint(2402864415);
          w.object(h(v, "channel"));
          w.object(h(v, "userId"));
          w.object(h(v, "password"));
        },
        "channels.editLocation": function(w, v) {
          w.uint(1491484525);
          w.object(h(v, "channel"));
          w.object(h(v, "geoPoint"));
          w.string(h(v, "address"));
        },
        "channels.toggleSlowMode": function(w, v) {
          w.uint(3990134512);
          w.object(h(v, "channel"));
          w.int(h(v, "seconds"));
        },
        "channels.getInactiveChannels": function(w) {
          w.uint(300429806);
        },
        "channels.convertToGigagroup": function(w, v) {
          w.uint(187239529);
          w.object(h(v, "channel"));
        },
        "channels.viewSponsoredMessage": function(w, v) {
          w.uint(3199130516);
          w.object(h(v, "channel"));
          w.bytes(h(v, "randomId"));
        },
        "channels.getSponsoredMessages": function(w, v) {
          w.uint(3961589695);
          w.object(h(v, "channel"));
        },
        "channels.getSendAs": function(w, v) {
          w.uint(231174382);
          w.object(h(v, "peer"));
        },
        "channels.deleteParticipantHistory": function(w, v) {
          w.uint(913655003);
          w.object(h(v, "channel"));
          w.object(h(v, "participant"));
        },
        "channels.toggleJoinToSend": function(w, v) {
          w.uint(3838547328);
          w.object(h(v, "channel"));
          w.boolean(h(v, "enabled"));
        },
        "channels.toggleJoinRequest": function(w, v) {
          w.uint(1277789622);
          w.object(h(v, "channel"));
          w.boolean(h(v, "enabled"));
        },
        "channels.reorderUsernames": function(w, v) {
          w.uint(3025988893);
          w.object(h(v, "channel"));
          w.vector(w.string, h(v, "order"));
        },
        "channels.toggleUsername": function(w, v) {
          w.uint(1358053637);
          w.object(h(v, "channel"));
          w.string(h(v, "username"));
          w.boolean(h(v, "active"));
        },
        "channels.deactivateAllUsernames": function(w, v) {
          w.uint(170155475);
          w.object(h(v, "channel"));
        },
        "channels.toggleForum": function(w, v) {
          w.uint(2754186025);
          w.object(h(v, "channel"));
          w.boolean(h(v, "enabled"));
        },
        "channels.createForumTopic": function(w, v) {
          w.uint(4094427684);
          var flags = 0;
          var _iconColor = v.iconColor !== void 0;
          if (_iconColor)
            flags |= 1;
          var _sendAs = v.sendAs !== void 0;
          if (_sendAs)
            flags |= 4;
          var _iconEmojiId = v.iconEmojiId !== void 0;
          if (_iconEmojiId)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.string(h(v, "title"));
          if (_iconColor)
            w.int(v.iconColor);
          if (_iconEmojiId)
            w.long(v.iconEmojiId);
          w.long(h(v, "randomId"));
          if (_sendAs)
            w.object(v.sendAs);
        },
        "channels.getForumTopics": function(w, v) {
          w.uint(233136337);
          var flags = 0;
          var _q = v.q !== void 0;
          if (_q)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
          if (_q)
            w.string(v.q);
          w.int(h(v, "offsetDate"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "offsetTopic"));
          w.int(h(v, "limit"));
        },
        "channels.getForumTopicsByID": function(w, v) {
          w.uint(2961383097);
          w.object(h(v, "channel"));
          w.vector(w.int, h(v, "topics"));
        },
        "channels.editForumTopic": function(w, v) {
          w.uint(4108296581);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _iconEmojiId = v.iconEmojiId !== void 0;
          if (_iconEmojiId)
            flags |= 2;
          var _closed = v.closed !== void 0;
          if (_closed)
            flags |= 4;
          var _hidden = v.hidden !== void 0;
          if (_hidden)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.int(h(v, "topicId"));
          if (_title)
            w.string(v.title);
          if (_iconEmojiId)
            w.long(v.iconEmojiId);
          if (_closed)
            w.boolean(v.closed);
          if (_hidden)
            w.boolean(v.hidden);
        },
        "channels.updatePinnedForumTopic": function(w, v) {
          w.uint(1814925350);
          w.object(h(v, "channel"));
          w.int(h(v, "topicId"));
          w.boolean(h(v, "pinned"));
        },
        "channels.deleteTopicHistory": function(w, v) {
          w.uint(876830509);
          w.object(h(v, "channel"));
          w.int(h(v, "topMsgId"));
        },
        "channels.reorderPinnedForumTopics": function(w, v) {
          w.uint(693150095);
          var flags = 0;
          if (v.force === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.vector(w.int, h(v, "order"));
        },
        "channels.toggleAntiSpam": function(w, v) {
          w.uint(1760814315);
          w.object(h(v, "channel"));
          w.boolean(h(v, "enabled"));
        },
        "channels.reportAntiSpamFalsePositive": function(w, v) {
          w.uint(2823857811);
          w.object(h(v, "channel"));
          w.int(h(v, "msgId"));
        },
        "channels.toggleParticipantsHidden": function(w, v) {
          w.uint(1785624660);
          w.object(h(v, "channel"));
          w.boolean(h(v, "enabled"));
        },
        "channels.clickSponsoredMessage": function(w, v) {
          w.uint(21257589);
          var flags = 0;
          if (v.media === true)
            flags |= 1;
          if (v.fullscreen === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.bytes(h(v, "randomId"));
        },
        "channels.updateColor": function(w, v) {
          w.uint(3635033713);
          var flags = 0;
          var _backgroundEmojiId = v.backgroundEmojiId !== void 0;
          if (_backgroundEmojiId)
            flags |= 1;
          if (v.forProfile === true)
            flags |= 2;
          var _color = v.color !== void 0;
          if (_color)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "channel"));
          if (_color)
            w.int(v.color);
          if (_backgroundEmojiId)
            w.long(v.backgroundEmojiId);
        },
        "channels.toggleViewForumAsMessages": function(w, v) {
          w.uint(2537077525);
          w.object(h(v, "channel"));
          w.boolean(h(v, "enabled"));
        },
        "channels.getChannelRecommendations": function(w, v) {
          w.uint(631707458);
          var flags = 0;
          var _channel = v.channel !== void 0;
          if (_channel)
            flags |= 1;
          w.uint(flags);
          if (_channel)
            w.object(v.channel);
        },
        "channels.updateEmojiStatus": function(w, v) {
          w.uint(4040418984);
          w.object(h(v, "channel"));
          w.object(h(v, "emojiStatus"));
        },
        "channels.setBoostsToUnblockRestrictions": function(w, v) {
          w.uint(2906234094);
          w.object(h(v, "channel"));
          w.int(h(v, "boosts"));
        },
        "channels.setEmojiStickers": function(w, v) {
          w.uint(1020866743);
          w.object(h(v, "channel"));
          w.object(h(v, "stickerset"));
        },
        "channels.reportSponsoredMessage": function(w, v) {
          w.uint(2945447609);
          w.object(h(v, "channel"));
          w.bytes(h(v, "randomId"));
          w.bytes(h(v, "option"));
        },
        "channels.restrictSponsoredMessages": function(w, v) {
          w.uint(2598966553);
          w.object(h(v, "channel"));
          w.boolean(h(v, "restricted"));
        },
        "channels.searchPosts": function(w, v) {
          w.uint(3516897403);
          w.string(h(v, "hashtag"));
          w.int(h(v, "offsetRate"));
          w.object(h(v, "offsetPeer"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "limit"));
        },
        "bots.sendCustomRequest": function(w, v) {
          w.uint(2854709741);
          w.string(h(v, "customMethod"));
          w.object(h(v, "params"));
        },
        "bots.answerWebhookJSONQuery": function(w, v) {
          w.uint(3860938573);
          w.long(h(v, "queryId"));
          w.object(h(v, "data"));
        },
        "bots.setBotCommands": function(w, v) {
          w.uint(85399130);
          w.object(h(v, "scope"));
          w.string(h(v, "langCode"));
          w.vector(w.object, h(v, "commands"));
        },
        "bots.resetBotCommands": function(w, v) {
          w.uint(1032708345);
          w.object(h(v, "scope"));
          w.string(h(v, "langCode"));
        },
        "bots.getBotCommands": function(w, v) {
          w.uint(3813412310);
          w.object(h(v, "scope"));
          w.string(h(v, "langCode"));
        },
        "bots.setBotMenuButton": function(w, v) {
          w.uint(1157944655);
          w.object(h(v, "userId"));
          w.object(h(v, "button"));
        },
        "bots.getBotMenuButton": function(w, v) {
          w.uint(2623597352);
          w.object(h(v, "userId"));
        },
        "bots.setBotBroadcastDefaultAdminRights": function(w, v) {
          w.uint(2021942497);
          w.object(h(v, "adminRights"));
        },
        "bots.setBotGroupDefaultAdminRights": function(w, v) {
          w.uint(2455685610);
          w.object(h(v, "adminRights"));
        },
        "bots.setBotInfo": function(w, v) {
          w.uint(282013987);
          var flags = 0;
          var _about = v.about !== void 0;
          if (_about)
            flags |= 1;
          var _description = v.description !== void 0;
          if (_description)
            flags |= 2;
          var _bot = v.bot !== void 0;
          if (_bot)
            flags |= 4;
          var _name = v.name !== void 0;
          if (_name)
            flags |= 8;
          w.uint(flags);
          if (_bot)
            w.object(v.bot);
          w.string(h(v, "langCode"));
          if (_name)
            w.string(v.name);
          if (_about)
            w.string(v.about);
          if (_description)
            w.string(v.description);
        },
        "bots.getBotInfo": function(w, v) {
          w.uint(3705214205);
          var flags = 0;
          var _bot = v.bot !== void 0;
          if (_bot)
            flags |= 1;
          w.uint(flags);
          if (_bot)
            w.object(v.bot);
          w.string(h(v, "langCode"));
        },
        "bots.reorderUsernames": function(w, v) {
          w.uint(2533994946);
          w.object(h(v, "bot"));
          w.vector(w.string, h(v, "order"));
        },
        "bots.toggleUsername": function(w, v) {
          w.uint(87861619);
          w.object(h(v, "bot"));
          w.string(h(v, "username"));
          w.boolean(h(v, "active"));
        },
        "bots.canSendMessage": function(w, v) {
          w.uint(324662502);
          w.object(h(v, "bot"));
        },
        "bots.allowSendMessage": function(w, v) {
          w.uint(4046644207);
          w.object(h(v, "bot"));
        },
        "bots.invokeWebViewCustomMethod": function(w, v) {
          w.uint(142591463);
          w.object(h(v, "bot"));
          w.string(h(v, "customMethod"));
          w.object(h(v, "params"));
        },
        "bots.getPopularAppBots": function(w, v) {
          w.uint(3260088722);
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "bots.addPreviewMedia": function(w, v) {
          w.uint(397326170);
          w.object(h(v, "bot"));
          w.string(h(v, "langCode"));
          w.object(h(v, "media"));
        },
        "bots.editPreviewMedia": function(w, v) {
          w.uint(2233819247);
          w.object(h(v, "bot"));
          w.string(h(v, "langCode"));
          w.object(h(v, "media"));
          w.object(h(v, "newMedia"));
        },
        "bots.deletePreviewMedia": function(w, v) {
          w.uint(755054003);
          w.object(h(v, "bot"));
          w.string(h(v, "langCode"));
          w.vector(w.object, h(v, "media"));
        },
        "bots.reorderPreviewMedias": function(w, v) {
          w.uint(3056071594);
          w.object(h(v, "bot"));
          w.string(h(v, "langCode"));
          w.vector(w.object, h(v, "order"));
        },
        "bots.getPreviewInfo": function(w, v) {
          w.uint(1111143341);
          w.object(h(v, "bot"));
          w.string(h(v, "langCode"));
        },
        "bots.getPreviewMedias": function(w, v) {
          w.uint(2728745293);
          w.object(h(v, "bot"));
        },
        "payments.getPaymentForm": function(w, v) {
          w.uint(924093883);
          var flags = 0;
          var _themeParams = v.themeParams !== void 0;
          if (_themeParams)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "invoice"));
          if (_themeParams)
            w.object(v.themeParams);
        },
        "payments.getPaymentReceipt": function(w, v) {
          w.uint(611897804);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "payments.validateRequestedInfo": function(w, v) {
          w.uint(3066622251);
          var flags = 0;
          if (v.save === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "invoice"));
          w.object(h(v, "info"));
        },
        "payments.sendPaymentForm": function(w, v) {
          w.uint(755192367);
          var flags = 0;
          var _requestedInfoId = v.requestedInfoId !== void 0;
          if (_requestedInfoId)
            flags |= 1;
          var _shippingOptionId = v.shippingOptionId !== void 0;
          if (_shippingOptionId)
            flags |= 2;
          var _tipAmount = v.tipAmount !== void 0;
          if (_tipAmount)
            flags |= 4;
          w.uint(flags);
          w.long(h(v, "formId"));
          w.object(h(v, "invoice"));
          if (_requestedInfoId)
            w.string(v.requestedInfoId);
          if (_shippingOptionId)
            w.string(v.shippingOptionId);
          w.object(h(v, "credentials"));
          if (_tipAmount)
            w.long(v.tipAmount);
        },
        "payments.getSavedInfo": function(w) {
          w.uint(578650699);
        },
        "payments.clearSavedInfo": function(w, v) {
          w.uint(3627905217);
          var flags = 0;
          if (v.credentials === true)
            flags |= 1;
          if (v.info === true)
            flags |= 2;
          w.uint(flags);
        },
        "payments.getBankCardData": function(w, v) {
          w.uint(779736953);
          w.string(h(v, "number"));
        },
        "payments.exportInvoice": function(w, v) {
          w.uint(261206117);
          w.object(h(v, "invoiceMedia"));
        },
        "payments.assignAppStoreTransaction": function(w, v) {
          w.uint(2163045501);
          w.bytes(h(v, "receipt"));
          w.object(h(v, "purpose"));
        },
        "payments.assignPlayMarketTransaction": function(w, v) {
          w.uint(3757920467);
          w.object(h(v, "receipt"));
          w.object(h(v, "purpose"));
        },
        "payments.canPurchasePremium": function(w, v) {
          w.uint(2680266422);
          w.object(h(v, "purpose"));
        },
        "payments.getPremiumGiftCodeOptions": function(w, v) {
          w.uint(660060756);
          var flags = 0;
          var _boostPeer = v.boostPeer !== void 0;
          if (_boostPeer)
            flags |= 1;
          w.uint(flags);
          if (_boostPeer)
            w.object(v.boostPeer);
        },
        "payments.checkGiftCode": function(w, v) {
          w.uint(2387719361);
          w.string(h(v, "slug"));
        },
        "payments.applyGiftCode": function(w, v) {
          w.uint(4142032980);
          w.string(h(v, "slug"));
        },
        "payments.getGiveawayInfo": function(w, v) {
          w.uint(4095972389);
          w.object(h(v, "peer"));
          w.int(h(v, "msgId"));
        },
        "payments.launchPrepaidGiveaway": function(w, v) {
          w.uint(1609928480);
          w.object(h(v, "peer"));
          w.long(h(v, "giveawayId"));
          w.object(h(v, "purpose"));
        },
        "payments.getStarsTopupOptions": function(w) {
          w.uint(3222194131);
        },
        "payments.getStarsStatus": function(w, v) {
          w.uint(273665959);
          w.object(h(v, "peer"));
        },
        "payments.getStarsTransactions": function(w, v) {
          w.uint(1775912279);
          var flags = 0;
          if (v.inbound === true)
            flags |= 1;
          if (v.outbound === true)
            flags |= 2;
          if (v.ascending === true)
            flags |= 4;
          var _subscriptionId = v.subscriptionId !== void 0;
          if (_subscriptionId)
            flags |= 8;
          w.uint(flags);
          if (_subscriptionId)
            w.string(v.subscriptionId);
          w.object(h(v, "peer"));
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "payments.sendStarsForm": function(w, v) {
          w.uint(2040056084);
          w.long(h(v, "formId"));
          w.object(h(v, "invoice"));
        },
        "payments.refundStarsCharge": function(w, v) {
          w.uint(632196938);
          w.object(h(v, "userId"));
          w.string(h(v, "chargeId"));
        },
        "payments.getStarsRevenueStats": function(w, v) {
          w.uint(3642751702);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
        },
        "payments.getStarsRevenueWithdrawalUrl": function(w, v) {
          w.uint(331081907);
          w.object(h(v, "peer"));
          w.long(h(v, "stars"));
          w.object(h(v, "password"));
        },
        "payments.getStarsRevenueAdsAccountUrl": function(w, v) {
          w.uint(3520589765);
          w.object(h(v, "peer"));
        },
        "payments.getStarsTransactionsByID": function(w, v) {
          w.uint(662973742);
          w.object(h(v, "peer"));
          w.vector(w.object, h(v, "id"));
        },
        "payments.getStarsGiftOptions": function(w, v) {
          w.uint(3553192904);
          var flags = 0;
          var _userId = v.userId !== void 0;
          if (_userId)
            flags |= 1;
          w.uint(flags);
          if (_userId)
            w.object(v.userId);
        },
        "payments.getStarsSubscriptions": function(w, v) {
          w.uint(52761285);
          var flags = 0;
          if (v.missingBalance === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.string(h(v, "offset"));
        },
        "payments.changeStarsSubscription": function(w, v) {
          w.uint(3346466936);
          var flags = 0;
          var _canceled = v.canceled !== void 0;
          if (_canceled)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.string(h(v, "subscriptionId"));
          if (_canceled)
            w.boolean(v.canceled);
        },
        "payments.fulfillStarsSubscription": function(w, v) {
          w.uint(3428576179);
          w.object(h(v, "peer"));
          w.string(h(v, "subscriptionId"));
        },
        "payments.getStarsGiveawayOptions": function(w) {
          w.uint(3172924734);
        },
        "payments.getStarGifts": function(w, v) {
          w.uint(3293984144);
          w.int(h(v, "hash"));
        },
        "payments.getUserStarGifts": function(w, v) {
          w.uint(1584580577);
          w.object(h(v, "userId"));
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "payments.saveStarGift": function(w, v) {
          w.uint(2276257934);
          var flags = 0;
          if (v.unsave === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "userId"));
          w.int(h(v, "msgId"));
        },
        "payments.convertStarGift": function(w, v) {
          w.uint(69328935);
          w.object(h(v, "userId"));
          w.int(h(v, "msgId"));
        },
        "stickers.createStickerSet": function(w, v) {
          w.uint(2418125671);
          var flags = 0;
          if (v.masks === true)
            flags |= 1;
          var _thumb = v.thumb !== void 0;
          if (_thumb)
            flags |= 4;
          var _software = v.software !== void 0;
          if (_software)
            flags |= 8;
          if (v.emojis === true)
            flags |= 32;
          if (v.textColor === true)
            flags |= 64;
          w.uint(flags);
          w.object(h(v, "userId"));
          w.string(h(v, "title"));
          w.string(h(v, "shortName"));
          if (_thumb)
            w.object(v.thumb);
          w.vector(w.object, h(v, "stickers"));
          if (_software)
            w.string(v.software);
        },
        "stickers.removeStickerFromSet": function(w, v) {
          w.uint(4151709521);
          w.object(h(v, "sticker"));
        },
        "stickers.changeStickerPosition": function(w, v) {
          w.uint(4290172106);
          w.object(h(v, "sticker"));
          w.int(h(v, "position"));
        },
        "stickers.addStickerToSet": function(w, v) {
          w.uint(2253651646);
          w.object(h(v, "stickerset"));
          w.object(h(v, "sticker"));
        },
        "stickers.setStickerSetThumb": function(w, v) {
          w.uint(2808763282);
          var flags = 0;
          var _thumb = v.thumb !== void 0;
          if (_thumb)
            flags |= 1;
          var _thumbDocumentId = v.thumbDocumentId !== void 0;
          if (_thumbDocumentId)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "stickerset"));
          if (_thumb)
            w.object(v.thumb);
          if (_thumbDocumentId)
            w.long(v.thumbDocumentId);
        },
        "stickers.checkShortName": function(w, v) {
          w.uint(676017721);
          w.string(h(v, "shortName"));
        },
        "stickers.suggestShortName": function(w, v) {
          w.uint(1303364867);
          w.string(h(v, "title"));
        },
        "stickers.changeSticker": function(w, v) {
          w.uint(4115889852);
          var flags = 0;
          var _emoji = v.emoji !== void 0;
          if (_emoji)
            flags |= 1;
          var _maskCoords = v.maskCoords !== void 0;
          if (_maskCoords)
            flags |= 2;
          var _keywords = v.keywords !== void 0;
          if (_keywords)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "sticker"));
          if (_emoji)
            w.string(v.emoji);
          if (_maskCoords)
            w.object(v.maskCoords);
          if (_keywords)
            w.string(v.keywords);
        },
        "stickers.renameStickerSet": function(w, v) {
          w.uint(306912256);
          w.object(h(v, "stickerset"));
          w.string(h(v, "title"));
        },
        "stickers.deleteStickerSet": function(w, v) {
          w.uint(2272281492);
          w.object(h(v, "stickerset"));
        },
        "stickers.replaceSticker": function(w, v) {
          w.uint(1184253338);
          w.object(h(v, "sticker"));
          w.object(h(v, "newSticker"));
        },
        "phone.getCallConfig": function(w) {
          w.uint(1430593449);
        },
        "phone.requestCall": function(w, v) {
          w.uint(1124046573);
          var flags = 0;
          if (v.video === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "userId"));
          w.int(h(v, "randomId"));
          w.bytes(h(v, "gAHash"));
          w.object(h(v, "protocol"));
        },
        "phone.acceptCall": function(w, v) {
          w.uint(1003664544);
          w.object(h(v, "peer"));
          w.bytes(h(v, "gB"));
          w.object(h(v, "protocol"));
        },
        "phone.confirmCall": function(w, v) {
          w.uint(788404002);
          w.object(h(v, "peer"));
          w.bytes(h(v, "gA"));
          w.long(h(v, "keyFingerprint"));
          w.object(h(v, "protocol"));
        },
        "phone.receivedCall": function(w, v) {
          w.uint(399855457);
          w.object(h(v, "peer"));
        },
        "phone.discardCall": function(w, v) {
          w.uint(2999697856);
          var flags = 0;
          if (v.video === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "duration"));
          w.object(h(v, "reason"));
          w.long(h(v, "connectionId"));
        },
        "phone.setCallRating": function(w, v) {
          w.uint(1508562471);
          var flags = 0;
          if (v.userInitiative === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "rating"));
          w.string(h(v, "comment"));
        },
        "phone.saveCallDebug": function(w, v) {
          w.uint(662363518);
          w.object(h(v, "peer"));
          w.object(h(v, "debug"));
        },
        "phone.sendSignalingData": function(w, v) {
          w.uint(4286223235);
          w.object(h(v, "peer"));
          w.bytes(h(v, "data"));
        },
        "phone.createGroupCall": function(w, v) {
          w.uint(1221445336);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 1;
          var _scheduleDate = v.scheduleDate !== void 0;
          if (_scheduleDate)
            flags |= 2;
          if (v.rtmpStream === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "randomId"));
          if (_title)
            w.string(v.title);
          if (_scheduleDate)
            w.int(v.scheduleDate);
        },
        "phone.joinGroupCall": function(w, v) {
          w.uint(2972909435);
          var flags = 0;
          if (v.muted === true)
            flags |= 1;
          var _inviteHash = v.inviteHash !== void 0;
          if (_inviteHash)
            flags |= 2;
          if (v.videoStopped === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "call"));
          w.object(h(v, "joinAs"));
          if (_inviteHash)
            w.string(v.inviteHash);
          w.object(h(v, "params"));
        },
        "phone.leaveGroupCall": function(w, v) {
          w.uint(1342404601);
          w.object(h(v, "call"));
          w.int(h(v, "source"));
        },
        "phone.inviteToGroupCall": function(w, v) {
          w.uint(2067345760);
          w.object(h(v, "call"));
          w.vector(w.object, h(v, "users"));
        },
        "phone.discardGroupCall": function(w, v) {
          w.uint(2054648117);
          w.object(h(v, "call"));
        },
        "phone.toggleGroupCallSettings": function(w, v) {
          w.uint(1958458429);
          var flags = 0;
          var _joinMuted = v.joinMuted !== void 0;
          if (_joinMuted)
            flags |= 1;
          if (v.resetInviteHash === true)
            flags |= 2;
          w.uint(flags);
          w.object(h(v, "call"));
          if (_joinMuted)
            w.boolean(v.joinMuted);
        },
        "phone.getGroupCall": function(w, v) {
          w.uint(68699611);
          w.object(h(v, "call"));
          w.int(h(v, "limit"));
        },
        "phone.getGroupParticipants": function(w, v) {
          w.uint(3310934187);
          w.object(h(v, "call"));
          w.vector(w.object, h(v, "ids"));
          w.vector(w.int, h(v, "sources"));
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "phone.checkGroupCall": function(w, v) {
          w.uint(3046963575);
          w.object(h(v, "call"));
          w.vector(w.int, h(v, "sources"));
        },
        "phone.toggleGroupCallRecord": function(w, v) {
          w.uint(4045981448);
          var flags = 0;
          if (v.start === true)
            flags |= 1;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          var _videoPortrait = v.videoPortrait !== void 0;
          var _flags_2 = v.video === true || _videoPortrait;
          if (_flags_2)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "call"));
          if (_title)
            w.string(v.title);
          if (_flags_2)
            w.boolean(v.videoPortrait);
        },
        "phone.editGroupCallParticipant": function(w, v) {
          w.uint(2770811583);
          var flags = 0;
          var _muted = v.muted !== void 0;
          if (_muted)
            flags |= 1;
          var _volume = v.volume !== void 0;
          if (_volume)
            flags |= 2;
          var _raiseHand = v.raiseHand !== void 0;
          if (_raiseHand)
            flags |= 4;
          var _videoStopped = v.videoStopped !== void 0;
          if (_videoStopped)
            flags |= 8;
          var _videoPaused = v.videoPaused !== void 0;
          if (_videoPaused)
            flags |= 16;
          var _presentationPaused = v.presentationPaused !== void 0;
          if (_presentationPaused)
            flags |= 32;
          w.uint(flags);
          w.object(h(v, "call"));
          w.object(h(v, "participant"));
          if (_muted)
            w.boolean(v.muted);
          if (_volume)
            w.int(v.volume);
          if (_raiseHand)
            w.boolean(v.raiseHand);
          if (_videoStopped)
            w.boolean(v.videoStopped);
          if (_videoPaused)
            w.boolean(v.videoPaused);
          if (_presentationPaused)
            w.boolean(v.presentationPaused);
        },
        "phone.editGroupCallTitle": function(w, v) {
          w.uint(480685066);
          w.object(h(v, "call"));
          w.string(h(v, "title"));
        },
        "phone.getGroupCallJoinAs": function(w, v) {
          w.uint(4017889594);
          w.object(h(v, "peer"));
        },
        "phone.exportGroupCallInvite": function(w, v) {
          w.uint(3869926527);
          var flags = 0;
          if (v.canSelfUnmute === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "call"));
        },
        "phone.toggleGroupCallStartSubscription": function(w, v) {
          w.uint(563885286);
          w.object(h(v, "call"));
          w.boolean(h(v, "subscribed"));
        },
        "phone.startScheduledGroupCall": function(w, v) {
          w.uint(1451287362);
          w.object(h(v, "call"));
        },
        "phone.saveDefaultGroupCallJoinAs": function(w, v) {
          w.uint(1465786252);
          w.object(h(v, "peer"));
          w.object(h(v, "joinAs"));
        },
        "phone.joinGroupCallPresentation": function(w, v) {
          w.uint(3421137860);
          w.object(h(v, "call"));
          w.object(h(v, "params"));
        },
        "phone.leaveGroupCallPresentation": function(w, v) {
          w.uint(475058500);
          w.object(h(v, "call"));
        },
        "phone.getGroupCallStreamChannels": function(w, v) {
          w.uint(447879488);
          w.object(h(v, "call"));
        },
        "phone.getGroupCallStreamRtmpUrl": function(w, v) {
          w.uint(3736316863);
          w.object(h(v, "peer"));
          w.boolean(h(v, "revoke"));
        },
        "phone.saveCallLog": function(w, v) {
          w.uint(1092913030);
          w.object(h(v, "peer"));
          w.object(h(v, "file"));
        },
        "langpack.getLangPack": function(w, v) {
          w.uint(4075959050);
          w.string(h(v, "langPack"));
          w.string(h(v, "langCode"));
        },
        "langpack.getStrings": function(w, v) {
          w.uint(4025104387);
          w.string(h(v, "langPack"));
          w.string(h(v, "langCode"));
          w.vector(w.string, h(v, "keys"));
        },
        "langpack.getDifference": function(w, v) {
          w.uint(3449309861);
          w.string(h(v, "langPack"));
          w.string(h(v, "langCode"));
          w.int(h(v, "fromVersion"));
        },
        "langpack.getLanguages": function(w, v) {
          w.uint(1120311183);
          w.string(h(v, "langPack"));
        },
        "langpack.getLanguage": function(w, v) {
          w.uint(1784243458);
          w.string(h(v, "langPack"));
          w.string(h(v, "langCode"));
        },
        "folders.editPeerFolders": function(w, v) {
          w.uint(1749536939);
          w.vector(w.object, h(v, "folderPeers"));
        },
        "stats.getBroadcastStats": function(w, v) {
          w.uint(2873246746);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
        },
        "stats.loadAsyncGraph": function(w, v) {
          w.uint(1646092192);
          var flags = 0;
          var _x = v.x !== void 0;
          if (_x)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "token"));
          if (_x)
            w.long(v.x);
        },
        "stats.getMegagroupStats": function(w, v) {
          w.uint(3705636359);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
        },
        "stats.getMessagePublicForwards": function(w, v) {
          w.uint(1595212100);
          w.object(h(v, "channel"));
          w.int(h(v, "msgId"));
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "stats.getMessageStats": function(w, v) {
          w.uint(3068175349);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
          w.int(h(v, "msgId"));
        },
        "stats.getStoryStats": function(w, v) {
          w.uint(927985472);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
        },
        "stats.getStoryPublicForwards": function(w, v) {
          w.uint(2789441270);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "stats.getBroadcastRevenueStats": function(w, v) {
          w.uint(1977595505);
          var flags = 0;
          if (v.dark === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "channel"));
        },
        "stats.getBroadcastRevenueWithdrawalUrl": function(w, v) {
          w.uint(711323507);
          w.object(h(v, "channel"));
          w.object(h(v, "password"));
        },
        "stats.getBroadcastRevenueTransactions": function(w, v) {
          w.uint(6891535);
          w.object(h(v, "channel"));
          w.int(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "chatlists.exportChatlistInvite": function(w, v) {
          w.uint(2222081934);
          w.object(h(v, "chatlist"));
          w.string(h(v, "title"));
          w.vector(w.object, h(v, "peers"));
        },
        "chatlists.deleteExportedInvite": function(w, v) {
          w.uint(1906072670);
          w.object(h(v, "chatlist"));
          w.string(h(v, "slug"));
        },
        "chatlists.editExportedInvite": function(w, v) {
          w.uint(1698543165);
          var flags = 0;
          var _title = v.title !== void 0;
          if (_title)
            flags |= 2;
          var _peers = v.peers && v.peers.length;
          if (_peers)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "chatlist"));
          w.string(h(v, "slug"));
          if (_title)
            w.string(v.title);
          if (_peers)
            w.vector(w.object, v.peers);
        },
        "chatlists.getExportedInvites": function(w, v) {
          w.uint(3456359043);
          w.object(h(v, "chatlist"));
        },
        "chatlists.checkChatlistInvite": function(w, v) {
          w.uint(1103171583);
          w.string(h(v, "slug"));
        },
        "chatlists.joinChatlistInvite": function(w, v) {
          w.uint(2796675994);
          w.string(h(v, "slug"));
          w.vector(w.object, h(v, "peers"));
        },
        "chatlists.getChatlistUpdates": function(w, v) {
          w.uint(2302776609);
          w.object(h(v, "chatlist"));
        },
        "chatlists.joinChatlistUpdates": function(w, v) {
          w.uint(3767138549);
          w.object(h(v, "chatlist"));
          w.vector(w.object, h(v, "peers"));
        },
        "chatlists.hideChatlistUpdates": function(w, v) {
          w.uint(1726252795);
          w.object(h(v, "chatlist"));
        },
        "chatlists.getLeaveChatlistSuggestions": function(w, v) {
          w.uint(4257011476);
          w.object(h(v, "chatlist"));
        },
        "chatlists.leaveChatlist": function(w, v) {
          w.uint(1962598714);
          w.object(h(v, "chatlist"));
          w.vector(w.object, h(v, "peers"));
        },
        "stories.canSendStory": function(w, v) {
          w.uint(3353337821);
          w.object(h(v, "peer"));
        },
        "stories.sendStory": function(w, v) {
          w.uint(3840305483);
          var flags = 0;
          var _caption = v.caption !== void 0;
          if (_caption)
            flags |= 1;
          var _entities = v.entities && v.entities.length;
          if (_entities)
            flags |= 2;
          if (v.pinned === true)
            flags |= 4;
          var _period = v.period !== void 0;
          if (_period)
            flags |= 8;
          if (v.noforwards === true)
            flags |= 16;
          var _mediaAreas = v.mediaAreas && v.mediaAreas.length;
          if (_mediaAreas)
            flags |= 32;
          var _fwdFromId = v.fwdFromId !== void 0;
          var _fwdFromStory = v.fwdFromStory !== void 0;
          var _flags_6 = _fwdFromId || _fwdFromStory;
          if (_flags_6)
            flags |= 64;
          if (v.fwdModified === true)
            flags |= 128;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.object(h(v, "media"));
          if (_mediaAreas)
            w.vector(w.object, v.mediaAreas);
          if (_caption)
            w.string(v.caption);
          if (_entities)
            w.vector(w.object, v.entities);
          w.vector(w.object, h(v, "privacyRules"));
          w.long(h(v, "randomId"));
          if (_period)
            w.int(v.period);
          if (_flags_6)
            w.object(v.fwdFromId);
          if (_flags_6)
            w.int(v.fwdFromStory);
        },
        "stories.editStory": function(w, v) {
          w.uint(3045308998);
          var flags = 0;
          var _media = v.media !== void 0;
          if (_media)
            flags |= 1;
          var _caption = v.caption !== void 0;
          var _entities = v.entities && v.entities.length;
          var _flags_1 = _caption || _entities;
          if (_flags_1)
            flags |= 2;
          var _privacyRules = v.privacyRules && v.privacyRules.length;
          if (_privacyRules)
            flags |= 4;
          var _mediaAreas = v.mediaAreas && v.mediaAreas.length;
          if (_mediaAreas)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          if (_media)
            w.object(v.media);
          if (_mediaAreas)
            w.vector(w.object, v.mediaAreas);
          if (_flags_1)
            w.string(v.caption);
          if (_flags_1)
            w.vector(w.object, v.entities);
          if (_privacyRules)
            w.vector(w.object, v.privacyRules);
        },
        "stories.deleteStories": function(w, v) {
          w.uint(2925124447);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "stories.togglePinned": function(w, v) {
          w.uint(2591400431);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
          w.boolean(h(v, "pinned"));
        },
        "stories.getAllStories": function(w, v) {
          w.uint(4004566565);
          var flags = 0;
          var _state = v.state !== void 0;
          if (_state)
            flags |= 1;
          if (v.next === true)
            flags |= 2;
          if (v.hidden === true)
            flags |= 4;
          w.uint(flags);
          if (_state)
            w.string(v.state);
        },
        "stories.getPinnedStories": function(w, v) {
          w.uint(1478600156);
          w.object(h(v, "peer"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "limit"));
        },
        "stories.getStoriesArchive": function(w, v) {
          w.uint(3023380502);
          w.object(h(v, "peer"));
          w.int(h(v, "offsetId"));
          w.int(h(v, "limit"));
        },
        "stories.getStoriesByID": function(w, v) {
          w.uint(1467271796);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "stories.toggleAllStoriesHidden": function(w, v) {
          w.uint(2082822084);
          w.boolean(h(v, "hidden"));
        },
        "stories.readStories": function(w, v) {
          w.uint(2773932744);
          w.object(h(v, "peer"));
          w.int(h(v, "maxId"));
        },
        "stories.incrementStoryViews": function(w, v) {
          w.uint(2986511099);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "stories.getStoryViewsList": function(w, v) {
          w.uint(2127707223);
          var flags = 0;
          if (v.justContacts === true)
            flags |= 1;
          var _q = v.q !== void 0;
          if (_q)
            flags |= 2;
          if (v.reactionsFirst === true)
            flags |= 4;
          if (v.forwardsFirst === true)
            flags |= 8;
          w.uint(flags);
          w.object(h(v, "peer"));
          if (_q)
            w.string(v.q);
          w.int(h(v, "id"));
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "stories.getStoriesViews": function(w, v) {
          w.uint(685862088);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "stories.exportStoryLink": function(w, v) {
          w.uint(2072899360);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
        },
        "stories.report": function(w, v) {
          w.uint(433646405);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
          w.bytes(h(v, "option"));
          w.string(h(v, "message"));
        },
        "stories.activateStealthMode": function(w, v) {
          w.uint(1471926630);
          var flags = 0;
          if (v.past === true)
            flags |= 1;
          if (v.future === true)
            flags |= 2;
          w.uint(flags);
        },
        "stories.sendReaction": function(w, v) {
          w.uint(2144810674);
          var flags = 0;
          if (v.addToRecent === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "storyId"));
          w.object(h(v, "reaction"));
        },
        "stories.getPeerStories": function(w, v) {
          w.uint(743103056);
          w.object(h(v, "peer"));
        },
        "stories.getAllReadPeerStories": function(w) {
          w.uint(2606426105);
        },
        "stories.getPeerMaxIDs": function(w, v) {
          w.uint(1398375363);
          w.vector(w.object, h(v, "id"));
        },
        "stories.getChatsToSend": function(w) {
          w.uint(2775223136);
        },
        "stories.togglePeerStoriesHidden": function(w, v) {
          w.uint(3171161540);
          w.object(h(v, "peer"));
          w.boolean(h(v, "hidden"));
        },
        "stories.getStoryReactionsList": function(w, v) {
          w.uint(3115485215);
          var flags = 0;
          var _reaction = v.reaction !== void 0;
          if (_reaction)
            flags |= 1;
          var _offset = v.offset !== void 0;
          if (_offset)
            flags |= 2;
          if (v.forwardsFirst === true)
            flags |= 4;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.int(h(v, "id"));
          if (_reaction)
            w.object(v.reaction);
          if (_offset)
            w.string(v.offset);
          w.int(h(v, "limit"));
        },
        "stories.togglePinnedToTop": function(w, v) {
          w.uint(187268763);
          w.object(h(v, "peer"));
          w.vector(w.int, h(v, "id"));
        },
        "stories.searchPosts": function(w, v) {
          w.uint(1827279210);
          var flags = 0;
          var _hashtag = v.hashtag !== void 0;
          if (_hashtag)
            flags |= 1;
          var _area = v.area !== void 0;
          if (_area)
            flags |= 2;
          w.uint(flags);
          if (_hashtag)
            w.string(v.hashtag);
          if (_area)
            w.object(v.area);
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "premium.getBoostsList": function(w, v) {
          w.uint(1626764896);
          var flags = 0;
          if (v.gifts === true)
            flags |= 1;
          w.uint(flags);
          w.object(h(v, "peer"));
          w.string(h(v, "offset"));
          w.int(h(v, "limit"));
        },
        "premium.getMyBoosts": function(w) {
          w.uint(199719754);
        },
        "premium.applyBoost": function(w, v) {
          w.uint(1803396934);
          var flags = 0;
          var _slots = v.slots && v.slots.length;
          if (_slots)
            flags |= 1;
          w.uint(flags);
          if (_slots)
            w.vector(w.int, v.slots);
          w.object(h(v, "peer"));
        },
        "premium.getBoostsStatus": function(w, v) {
          w.uint(70197089);
          w.object(h(v, "peer"));
        },
        "premium.getUserBoosts": function(w, v) {
          w.uint(965037343);
          w.object(h(v, "peer"));
          w.object(h(v, "userId"));
        },
        "smsjobs.isEligibleToJoin": function(w) {
          w.uint(249313744);
        },
        "smsjobs.join": function(w) {
          w.uint(2806959661);
        },
        "smsjobs.leave": function(w) {
          w.uint(2560142707);
        },
        "smsjobs.updateSettings": function(w, v) {
          w.uint(155164863);
          var flags = 0;
          if (v.allowInternational === true)
            flags |= 1;
          w.uint(flags);
        },
        "smsjobs.getStatus": function(w) {
          w.uint(279353576);
        },
        "smsjobs.getSmsJob": function(w, v) {
          w.uint(2005766191);
          w.string(h(v, "jobId"));
        },
        "smsjobs.finishJob": function(w, v) {
          w.uint(1327415076);
          var flags = 0;
          var _error = v.error !== void 0;
          if (_error)
            flags |= 1;
          w.uint(flags);
          w.string(h(v, "jobId"));
          if (_error)
            w.string(v.error);
        },
        "fragment.getCollectibleInfo": function(w, v) {
          w.uint(3189671354);
          w.object(h(v, "collectible"));
        },
        "mtcute.customMethod": function(w, v) {
          w.raw(h(v, "bytes"));
        },
        "mt_resPQ": function(w, v) {
          w.uint(85337187);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.bytes(h(v, "pq"));
          w.vector(w.long, h(v, "serverPublicKeyFingerprints"));
        },
        "mt_p_q_inner_data_dc": function(w, v) {
          w.uint(2851430293);
          w.bytes(h(v, "pq"));
          w.bytes(h(v, "p"));
          w.bytes(h(v, "q"));
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.int256(h(v, "newNonce"));
          w.int(h(v, "dc"));
        },
        "mt_p_q_inner_data_temp_dc": function(w, v) {
          w.uint(1459478408);
          w.bytes(h(v, "pq"));
          w.bytes(h(v, "p"));
          w.bytes(h(v, "q"));
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.int256(h(v, "newNonce"));
          w.int(h(v, "dc"));
          w.int(h(v, "expiresIn"));
        },
        "mt_server_DH_params_ok": function(w, v) {
          w.uint(3504867164);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.bytes(h(v, "encryptedAnswer"));
        },
        "mt_server_DH_inner_data": function(w, v) {
          w.uint(3045658042);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.int(h(v, "g"));
          w.bytes(h(v, "dhPrime"));
          w.bytes(h(v, "gA"));
          w.int(h(v, "serverTime"));
        },
        "mt_client_DH_inner_data": function(w, v) {
          w.uint(1715713620);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.long(h(v, "retryId"));
          w.bytes(h(v, "gB"));
        },
        "mt_dh_gen_ok": function(w, v) {
          w.uint(1003222836);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.int128(h(v, "newNonceHash1"));
        },
        "mt_dh_gen_retry": function(w, v) {
          w.uint(1188831161);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.int128(h(v, "newNonceHash2"));
        },
        "mt_dh_gen_fail": function(w, v) {
          w.uint(2795351554);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.int128(h(v, "newNonceHash3"));
        },
        "mt_bind_auth_key_inner": function(w, v) {
          w.uint(1973679973);
          w.long(h(v, "nonce"));
          w.long(h(v, "tempAuthKeyId"));
          w.long(h(v, "permAuthKeyId"));
          w.long(h(v, "tempSessionId"));
          w.int(h(v, "expiresAt"));
        },
        "mt_rpc_error": function(w, v) {
          w.uint(558156313);
          w.int(h(v, "errorCode"));
          w.string(h(v, "errorMessage"));
        },
        "mt_rpc_answer_unknown": function(w) {
          w.uint(1579864942);
        },
        "mt_rpc_answer_dropped_running": function(w) {
          w.uint(3447252358);
        },
        "mt_rpc_answer_dropped": function(w, v) {
          w.uint(2755319991);
          w.long(h(v, "msgId"));
          w.int(h(v, "seqNo"));
          w.int(h(v, "bytes"));
        },
        "mt_future_salt": function(w, v) {
          w.uint(155834844);
          w.int(h(v, "validSince"));
          w.int(h(v, "validUntil"));
          w.long(h(v, "salt"));
        },
        "mt_future_salts": function(w, v) {
          w.uint(2924480661);
          w.long(h(v, "reqMsgId"));
          w.int(h(v, "now"));
          w.vector(m._bare[155834844], h(v, "salts"), 1);
        },
        "mt_pong": function(w, v) {
          w.uint(880243653);
          w.long(h(v, "msgId"));
          w.long(h(v, "pingId"));
        },
        "mt_destroy_session_ok": function(w, v) {
          w.uint(3793765884);
          w.long(h(v, "sessionId"));
        },
        "mt_destroy_session_none": function(w, v) {
          w.uint(1658015945);
          w.long(h(v, "sessionId"));
        },
        "mt_new_session_created": function(w, v) {
          w.uint(2663516424);
          w.long(h(v, "firstMsgId"));
          w.long(h(v, "uniqueId"));
          w.long(h(v, "serverSalt"));
        },
        "mt_msgs_ack": function(w, v) {
          w.uint(1658238041);
          w.vector(w.long, h(v, "msgIds"));
        },
        "mt_bad_msg_notification": function(w, v) {
          w.uint(2817521681);
          w.long(h(v, "badMsgId"));
          w.int(h(v, "badMsgSeqno"));
          w.int(h(v, "errorCode"));
        },
        "mt_bad_server_salt": function(w, v) {
          w.uint(3987424379);
          w.long(h(v, "badMsgId"));
          w.int(h(v, "badMsgSeqno"));
          w.int(h(v, "errorCode"));
          w.long(h(v, "newServerSalt"));
        },
        "mt_msg_resend_req": function(w, v) {
          w.uint(2105940488);
          w.vector(w.long, h(v, "msgIds"));
        },
        "mt_msgs_state_req": function(w, v) {
          w.uint(3664378706);
          w.vector(w.long, h(v, "msgIds"));
        },
        "mt_msgs_state_info": function(w, v) {
          w.uint(81704317);
          w.long(h(v, "reqMsgId"));
          w.bytes(h(v, "info"));
        },
        "mt_msgs_all_info": function(w, v) {
          w.uint(2361446705);
          w.vector(w.long, h(v, "msgIds"));
          w.bytes(h(v, "info"));
        },
        "mt_msg_detailed_info": function(w, v) {
          w.uint(661470918);
          w.long(h(v, "msgId"));
          w.long(h(v, "answerMsgId"));
          w.int(h(v, "bytes"));
          w.int(h(v, "status"));
        },
        "mt_msg_new_detailed_info": function(w, v) {
          w.uint(2157819615);
          w.long(h(v, "answerMsgId"));
          w.int(h(v, "bytes"));
          w.int(h(v, "status"));
        },
        "mt_destroy_auth_key_ok": function(w) {
          w.uint(4133544404);
        },
        "mt_destroy_auth_key_none": function(w) {
          w.uint(178201177);
        },
        "mt_destroy_auth_key_fail": function(w) {
          w.uint(3926956819);
        },
        "mt_http_wait": function(w, v) {
          w.uint(2459514271);
          w.int(h(v, "maxDelay"));
          w.int(h(v, "waitAfter"));
          w.int(h(v, "maxWait"));
        },
        "mt_req_pq_multi": function(w, v) {
          w.uint(3195965169);
          w.int128(h(v, "nonce"));
        },
        "mt_req_DH_params": function(w, v) {
          w.uint(3608339646);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.bytes(h(v, "p"));
          w.bytes(h(v, "q"));
          w.long(h(v, "publicKeyFingerprint"));
          w.bytes(h(v, "encryptedData"));
        },
        "mt_set_client_DH_params": function(w, v) {
          w.uint(4110704415);
          w.int128(h(v, "nonce"));
          w.int128(h(v, "serverNonce"));
          w.bytes(h(v, "encryptedData"));
        },
        "mt_rpc_drop_answer": function(w, v) {
          w.uint(1491380032);
          w.long(h(v, "reqMsgId"));
        },
        "mt_get_future_salts": function(w, v) {
          w.uint(3105996036);
          w.int(h(v, "num"));
        },
        "mt_ping": function(w, v) {
          w.uint(2059302892);
          w.long(h(v, "pingId"));
        },
        "mt_ping_delay_disconnect": function(w, v) {
          w.uint(4081220492);
          w.long(h(v, "pingId"));
          w.int(h(v, "disconnectDelay"));
        },
        "mt_destroy_session": function(w, v) {
          w.uint(3880853798);
          w.long(h(v, "sessionId"));
        },
        "mt_destroy_auth_key": function(w) {
          w.uint(3510849888);
        },
        _bare: {
          155834844: function(w = this, v) {
            w.int(h(v, "validSince"));
            w.int(h(v, "validUntil"));
            w.long(h(v, "salt"));
          }
        },
        _staticSize: {
          "ipPort": 12,
          "inputPeerEmpty": 4,
          "inputPeerSelf": 4,
          "inputPeerChat": 12,
          "inputPeerUser": 20,
          "inputPeerChannel": 20,
          "inputUserEmpty": 4,
          "inputUserSelf": 4,
          "inputUser": 20,
          "inputMediaEmpty": 4,
          "inputChatPhotoEmpty": 4,
          "inputGeoPointEmpty": 4,
          "inputPhotoEmpty": 4,
          "inputEncryptedFileLocation": 20,
          "inputSecureFileLocation": 20,
          "inputTakeoutFileLocation": 4,
          "peerUser": 12,
          "peerChat": 12,
          "peerChannel": 12,
          "storage.fileUnknown": 4,
          "storage.filePartial": 4,
          "storage.fileJpeg": 4,
          "storage.fileGif": 4,
          "storage.filePng": 4,
          "storage.filePdf": 4,
          "storage.fileMp3": 4,
          "storage.fileMov": 4,
          "storage.fileMp4": 4,
          "storage.fileWebp": 4,
          "userEmpty": 12,
          "userProfilePhotoEmpty": 4,
          "userStatusEmpty": 4,
          "userStatusOnline": 8,
          "userStatusOffline": 8,
          "userStatusRecently": 8,
          "userStatusLastWeek": 8,
          "userStatusLastMonth": 8,
          "chatEmpty": 12,
          "chatParticipant": 24,
          "chatParticipantCreator": 12,
          "chatParticipantAdmin": 24,
          "chatPhotoEmpty": 4,
          "messageMediaEmpty": 4,
          "messageMediaUnsupported": 4,
          "messageActionEmpty": 4,
          "messageActionChatDeletePhoto": 4,
          "messageActionChatDeleteUser": 12,
          "messageActionChatJoinedByLink": 12,
          "messageActionChatMigrateTo": 12,
          "messageActionPinMessage": 4,
          "messageActionHistoryClear": 4,
          "messageActionGameScore": 16,
          "messageActionScreenshotTaken": 4,
          "messageActionContactSignUp": 4,
          "messageActionGeoProximityReached": 32,
          "messageActionChatJoinedByRequest": 4,
          "messageActionGiveawayResults": 16,
          "messageActionBoostApply": 8,
          "photoEmpty": 12,
          "geoPointEmpty": 4,
          "inputNotifyUsers": 4,
          "inputNotifyChats": 4,
          "inputNotifyBroadcasts": 4,
          "inputReportReasonSpam": 4,
          "inputReportReasonViolence": 4,
          "inputReportReasonPornography": 4,
          "inputReportReasonChildAbuse": 4,
          "inputReportReasonOther": 4,
          "inputReportReasonCopyright": 4,
          "inputReportReasonGeoIrrelevant": 4,
          "inputReportReasonFake": 4,
          "inputReportReasonIllegalDrugs": 4,
          "inputReportReasonPersonalDetails": 4,
          "contact": 16,
          "importedContact": 20,
          "contacts.contactsNotModified": 4,
          "messages.dialogsNotModified": 8,
          "messages.messagesNotModified": 8,
          "messages.affectedHistory": 16,
          "inputMessagesFilterEmpty": 4,
          "inputMessagesFilterPhotos": 4,
          "inputMessagesFilterVideo": 4,
          "inputMessagesFilterPhotoVideo": 4,
          "inputMessagesFilterDocument": 4,
          "inputMessagesFilterUrl": 4,
          "inputMessagesFilterGif": 4,
          "inputMessagesFilterVoice": 4,
          "inputMessagesFilterMusic": 4,
          "inputMessagesFilterChatPhotos": 4,
          "inputMessagesFilterPhoneCalls": 8,
          "inputMessagesFilterRoundVoice": 4,
          "inputMessagesFilterRoundVideo": 4,
          "inputMessagesFilterMyMentions": 4,
          "inputMessagesFilterGeo": 4,
          "inputMessagesFilterContacts": 4,
          "inputMessagesFilterPinned": 4,
          "updateMessageID": 16,
          "updateEncryptedChatTyping": 8,
          "updateEncryptedMessagesRead": 16,
          "updateChatParticipantAdd": 36,
          "updateChatParticipantDelete": 24,
          "updateReadHistoryOutbox": 28,
          "updateChannel": 12,
          "updateChannelMessageViews": 20,
          "updateChatParticipantAdmin": 28,
          "updateStickerSets": 8,
          "updateSavedGifs": 4,
          "updateReadChannelOutbox": 16,
          "updateReadFeaturedStickers": 4,
          "updateRecentStickers": 4,
          "updateConfig": 4,
          "updatePtsChanged": 4,
          "updateFavedStickers": 4,
          "updateContactsReset": 4,
          "updateChannelAvailableMessages": 16,
          "updateGeoLiveViewed": 20,
          "updateLoginToken": 4,
          "updateDialogFilters": 4,
          "updateChannelMessageForwards": 20,
          "updateReadChannelDiscussionOutbox": 20,
          "updatePeerBlocked": 20,
          "updateChat": 12,
          "updateBotStopped": 24,
          "updateAttachMenuBots": 4,
          "updateWebViewResultSent": 12,
          "updateSavedRingtones": 4,
          "updateReadFeaturedEmojiStickers": 4,
          "updateRecentEmojiStatuses": 4,
          "updateRecentReactions": 4,
          "updateMoveStickerSetToTop": 16,
          "updateChannelPinnedTopic": 20,
          "updateUser": 12,
          "updateAutoSaveSettings": 4,
          "updateReadStories": 20,
          "updateStoryID": 16,
          "updateChannelViewForumAsMessages": 16,
          "updateSavedReactionTags": 4,
          "updateDeleteQuickReply": 8,
          "updateStarsBalance": 12,
          "updatePaidReactionPrivacy": 8,
          "updates.state": 24,
          "updates.differenceEmpty": 12,
          "updates.differenceTooLong": 8,
          "updatesTooLong": 4,
          "help.noAppUpdate": 4,
          "encryptedChatEmpty": 8,
          "encryptedChatWaiting": 36,
          "encryptedChatDiscarded": 12,
          "inputEncryptedChat": 16,
          "encryptedFileEmpty": 4,
          "encryptedFile": 36,
          "inputEncryptedFileEmpty": 4,
          "inputEncryptedFile": 20,
          "inputEncryptedFileBigUploaded": 20,
          "messages.sentEncryptedMessage": 8,
          "inputDocumentEmpty": 4,
          "documentEmpty": 12,
          "notifyPeer": 16,
          "notifyUsers": 4,
          "notifyChats": 4,
          "notifyBroadcasts": 4,
          "notifyForumTopic": 20,
          "sendMessageTypingAction": 4,
          "sendMessageCancelAction": 4,
          "sendMessageRecordVideoAction": 4,
          "sendMessageUploadVideoAction": 8,
          "sendMessageRecordAudioAction": 4,
          "sendMessageUploadAudioAction": 8,
          "sendMessageUploadPhotoAction": 8,
          "sendMessageUploadDocumentAction": 8,
          "sendMessageGeoLocationAction": 4,
          "sendMessageChooseContactAction": 4,
          "sendMessageGamePlayAction": 4,
          "sendMessageRecordRoundAction": 4,
          "sendMessageUploadRoundAction": 8,
          "speakingInGroupCallAction": 4,
          "sendMessageHistoryImportAction": 8,
          "sendMessageChooseStickerAction": 4,
          "inputPrivacyKeyStatusTimestamp": 4,
          "inputPrivacyKeyChatInvite": 4,
          "inputPrivacyKeyPhoneCall": 4,
          "inputPrivacyKeyPhoneP2P": 4,
          "inputPrivacyKeyForwards": 4,
          "inputPrivacyKeyProfilePhoto": 4,
          "inputPrivacyKeyPhoneNumber": 4,
          "inputPrivacyKeyAddedByPhone": 4,
          "inputPrivacyKeyVoiceMessages": 4,
          "inputPrivacyKeyAbout": 4,
          "inputPrivacyKeyBirthday": 4,
          "privacyKeyStatusTimestamp": 4,
          "privacyKeyChatInvite": 4,
          "privacyKeyPhoneCall": 4,
          "privacyKeyPhoneP2P": 4,
          "privacyKeyForwards": 4,
          "privacyKeyProfilePhoto": 4,
          "privacyKeyPhoneNumber": 4,
          "privacyKeyAddedByPhone": 4,
          "privacyKeyVoiceMessages": 4,
          "privacyKeyAbout": 4,
          "privacyKeyBirthday": 4,
          "inputPrivacyValueAllowContacts": 4,
          "inputPrivacyValueAllowAll": 4,
          "inputPrivacyValueDisallowContacts": 4,
          "inputPrivacyValueDisallowAll": 4,
          "inputPrivacyValueAllowCloseFriends": 4,
          "inputPrivacyValueAllowPremium": 4,
          "privacyValueAllowContacts": 4,
          "privacyValueAllowAll": 4,
          "privacyValueDisallowContacts": 4,
          "privacyValueDisallowAll": 4,
          "privacyValueAllowCloseFriends": 4,
          "privacyValueAllowPremium": 4,
          "accountDaysTTL": 8,
          "documentAttributeImageSize": 12,
          "documentAttributeAnimated": 4,
          "documentAttributeHasStickers": 4,
          "messages.stickersNotModified": 4,
          "messages.allStickersNotModified": 4,
          "messages.affectedMessages": 12,
          "receivedNotifyMessage": 12,
          "chatInvitePublicJoinRequests": 4,
          "inputStickerSetEmpty": 4,
          "inputStickerSetID": 20,
          "inputStickerSetAnimatedEmoji": 4,
          "inputStickerSetAnimatedEmojiAnimations": 4,
          "inputStickerSetPremiumGifts": 4,
          "inputStickerSetEmojiGenericAnimations": 4,
          "inputStickerSetEmojiDefaultStatuses": 4,
          "inputStickerSetEmojiDefaultTopicIcons": 4,
          "inputStickerSetEmojiChannelDefaultStatuses": 4,
          "messages.stickerSetNotModified": 4,
          "replyKeyboardHide": 8,
          "messageEntityUnknown": 12,
          "messageEntityMention": 12,
          "messageEntityHashtag": 12,
          "messageEntityBotCommand": 12,
          "messageEntityUrl": 12,
          "messageEntityEmail": 12,
          "messageEntityBold": 12,
          "messageEntityItalic": 12,
          "messageEntityCode": 12,
          "messageEntityMentionName": 20,
          "messageEntityPhone": 12,
          "messageEntityCashtag": 12,
          "messageEntityUnderline": 12,
          "messageEntityStrike": 12,
          "messageEntityBankCard": 12,
          "messageEntitySpoiler": 12,
          "messageEntityCustomEmoji": 20,
          "messageEntityBlockquote": 16,
          "inputChannelEmpty": 4,
          "inputChannel": 20,
          "messageRange": 12,
          "channelMessagesFilterEmpty": 4,
          "channelParticipantLeft": 16,
          "channelParticipantsRecent": 4,
          "channelParticipantsAdmins": 4,
          "channelParticipantsBots": 4,
          "channels.channelParticipantsNotModified": 4,
          "messages.savedGifsNotModified": 4,
          "auth.codeTypeSms": 4,
          "auth.codeTypeCall": 4,
          "auth.codeTypeFlashCall": 4,
          "auth.codeTypeMissedCall": 4,
          "auth.codeTypeFragmentSms": 4,
          "auth.sentCodeTypeApp": 8,
          "auth.sentCodeTypeSms": 8,
          "auth.sentCodeTypeCall": 8,
          "auth.sentCodeTypeSetUpEmailRequired": 8,
          "messages.messageEditData": 8,
          "inputBotInlineMessageID": 24,
          "inputBotInlineMessageID64": 28,
          "topPeer": 24,
          "topPeerCategoryBotsPM": 4,
          "topPeerCategoryBotsInline": 4,
          "topPeerCategoryCorrespondents": 4,
          "topPeerCategoryGroups": 4,
          "topPeerCategoryChannels": 4,
          "topPeerCategoryPhoneCalls": 4,
          "topPeerCategoryForwardUsers": 4,
          "topPeerCategoryForwardChats": 4,
          "topPeerCategoryBotsApp": 4,
          "contacts.topPeersNotModified": 4,
          "contacts.topPeersDisabled": 4,
          "messages.featuredStickersNotModified": 8,
          "messages.recentStickersNotModified": 4,
          "messages.stickerSetInstallResultSuccess": 4,
          "maskCoords": 32,
          "inputGameID": 20,
          "highScore": 20,
          "textEmpty": 4,
          "textImage": 20,
          "pageBlockUnsupported": 4,
          "pageBlockDivider": 4,
          "phoneCallDiscardReasonMissed": 4,
          "phoneCallDiscardReasonDisconnect": 4,
          "phoneCallDiscardReasonHangup": 4,
          "phoneCallDiscardReasonBusy": 4,
          "inputPhoneCall": 20,
          "phoneCallEmpty": 12,
          "channelAdminLogEventActionToggleInvites": 8,
          "channelAdminLogEventActionToggleSignatures": 8,
          "channelAdminLogEventActionParticipantJoin": 4,
          "channelAdminLogEventActionParticipantLeave": 4,
          "channelAdminLogEventActionTogglePreHistoryHidden": 8,
          "channelAdminLogEventActionChangeLinkedChat": 20,
          "channelAdminLogEventActionToggleSlowMode": 12,
          "channelAdminLogEventActionToggleGroupCallSetting": 8,
          "channelAdminLogEventActionChangeHistoryTTL": 12,
          "channelAdminLogEventActionToggleNoForwards": 8,
          "channelAdminLogEventActionToggleForum": 8,
          "channelAdminLogEventActionToggleAntiSpam": 8,
          "channelAdminLogEventActionToggleSignatureProfiles": 8,
          "channelAdminLogEventsFilter": 8,
          "popularContact": 16,
          "messages.favedStickersNotModified": 4,
          "inputMessageID": 8,
          "inputMessageReplyTo": 8,
          "inputMessagePinned": 4,
          "inputMessageCallbackQuery": 16,
          "inputDialogPeerFolder": 8,
          "dialogPeer": 16,
          "dialogPeerFolder": 8,
          "messages.foundStickerSetsNotModified": 4,
          "help.termsOfServiceUpdateEmpty": 8,
          "inputSecureFile": 20,
          "secureFileEmpty": 4,
          "secureValueTypePersonalDetails": 4,
          "secureValueTypePassport": 4,
          "secureValueTypeDriverLicense": 4,
          "secureValueTypeIdentityCard": 4,
          "secureValueTypeInternalPassport": 4,
          "secureValueTypeAddress": 4,
          "secureValueTypeUtilityBill": 4,
          "secureValueTypeBankStatement": 4,
          "secureValueTypeRentalAgreement": 4,
          "secureValueTypePassportRegistration": 4,
          "secureValueTypeTemporaryRegistration": 4,
          "secureValueTypePhone": 4,
          "secureValueTypeEmail": 4,
          "help.deepLinkInfoEmpty": 4,
          "account.takeout": 12,
          "passwordKdfAlgoUnknown": 4,
          "securePasswordKdfAlgoUnknown": 4,
          "inputCheckPasswordEmpty": 4,
          "secureRequiredType": 12,
          "help.passportConfigNotModified": 4,
          "jsonNull": 4,
          "jsonBool": 8,
          "jsonNumber": 12,
          "help.userInfoEmpty": 4,
          "chatOnlines": 8,
          "chatAdminRights": 8,
          "chatBannedRights": 12,
          "inputWallPaper": 20,
          "inputWallPaperNoFile": 12,
          "account.wallPapersNotModified": 4,
          "autoDownloadSettings": 40,
          "account.autoDownloadSettings": 124,
          "folderPeer": 20,
          "urlAuthResultDefault": 4,
          "channelLocationEmpty": 4,
          "peerLocated": 24,
          "peerSelfLocated": 8,
          "inputTheme": 20,
          "account.themesNotModified": 4,
          "account.contentSettings": 8,
          "baseThemeClassic": 4,
          "baseThemeDay": 4,
          "baseThemeNight": 4,
          "baseThemeTinted": 4,
          "baseThemeArctic": 4,
          "dialogFilterDefault": 4,
          "statsDateRangeDays": 12,
          "statsAbsValueAndPrev": 20,
          "statsPercentValue": 20,
          "help.promoDataEmpty": 8,
          "statsGroupTopPoster": 20,
          "statsGroupTopAdmin": 24,
          "statsGroupTopInviter": 16,
          "globalPrivacySettings": 8,
          "help.countriesListNotModified": 4,
          "messageReplyStoryHeader": 20,
          "peerBlocked": 20,
          "groupCallDiscarded": 24,
          "inputGroupCall": 20,
          "inlineQueryPeerTypeSameBotPM": 4,
          "inlineQueryPeerTypePM": 4,
          "inlineQueryPeerTypeChat": 4,
          "inlineQueryPeerTypeMegagroup": 4,
          "inlineQueryPeerTypeBroadcast": 4,
          "inlineQueryPeerTypeBotPM": 4,
          "messages.historyImport": 12,
          "chatAdminWithInvites": 20,
          "botCommandScopeDefault": 4,
          "botCommandScopeUsers": 4,
          "botCommandScopeChats": 4,
          "botCommandScopeChatAdmins": 4,
          "account.resetPasswordFailedWait": 8,
          "account.resetPasswordRequestedWait": 8,
          "account.resetPasswordOk": 4,
          "messages.sponsoredMessagesEmpty": 4,
          "searchResultsCalendarPeriod": 20,
          "searchResultPosition": 16,
          "messages.availableReactionsNotModified": 4,
          "groupCallStreamChannel": 20,
          "attachMenuBotsNotModified": 4,
          "botMenuButtonDefault": 4,
          "botMenuButtonCommands": 4,
          "account.savedRingtonesNotModified": 4,
          "notificationSoundDefault": 4,
          "notificationSoundNone": 4,
          "notificationSoundRingtone": 12,
          "account.savedRingtone": 4,
          "attachMenuPeerTypeSameBotPM": 4,
          "attachMenuPeerTypeBotPM": 4,
          "attachMenuPeerTypePM": 4,
          "attachMenuPeerTypeChat": 4,
          "attachMenuPeerTypeBroadcast": 4,
          "inputStorePaymentPremiumSubscription": 8,
          "emojiStatusEmpty": 4,
          "emojiStatus": 12,
          "emojiStatusUntil": 16,
          "account.emojiStatusesNotModified": 4,
          "reactionEmpty": 4,
          "reactionCustomEmoji": 12,
          "reactionPaid": 4,
          "chatReactionsNone": 4,
          "chatReactionsAll": 8,
          "messages.reactionsNotModified": 4,
          "emailVerifyPurposeLoginChange": 4,
          "emailVerifyPurposePassport": 4,
          "sendAsPeer": 20,
          "forumTopicDeleted": 8,
          "defaultHistoryTTL": 8,
          "emojiListNotModified": 4,
          "messages.emojiGroupsNotModified": 4,
          "help.appConfigNotModified": 4,
          "inputBotAppID": 20,
          "botAppNotModified": 4,
          "readParticipantDate": 16,
          "inputChatlistDialogFilter": 8,
          "messagePeerVoteInputOption": 20,
          "storyItemDeleted": 8,
          "storyItemSkipped": 20,
          "prepaidGiveaway": 24,
          "prepaidStarsGiveaway": 32,
          "postInteractionCountersMessage": 20,
          "postInteractionCountersStory": 20,
          "help.peerColorsNotModified": 4,
          "savedDialog": 24,
          "messages.savedDialogsNotModified": 8,
          "messages.savedReactionTagsNotModified": 4,
          "outboxReadDate": 8,
          "businessWeeklyOpen": 12,
          "businessAwayMessageScheduleAlways": 4,
          "businessAwayMessageScheduleOutsideWorkHours": 4,
          "businessAwayMessageScheduleCustom": 12,
          "help.timezonesListNotModified": 4,
          "inputQuickReplyShortcutId": 8,
          "messages.quickRepliesNotModified": 4,
          "missingInvitee": 16,
          "channels.sponsoredMessageReportResultAdsHidden": 4,
          "channels.sponsoredMessageReportResultReported": 4,
          "broadcastRevenueTransactionProceeds": 20,
          "reactionNotificationsFromContacts": 4,
          "reactionNotificationsFromAll": 4,
          "broadcastRevenueBalances": 32,
          "messages.availableEffectsNotModified": 4,
          "starsTransactionPeerUnsupported": 4,
          "starsTransactionPeerAppStore": 4,
          "starsTransactionPeerPlayMarket": 4,
          "starsTransactionPeerPremiumBot": 4,
          "starsTransactionPeerFragment": 4,
          "starsTransactionPeer": 16,
          "starsTransactionPeerAds": 4,
          "starsSubscriptionPricing": 16,
          "starsGiveawayWinnersOption": 20,
          "payments.starGiftsNotModified": 4,
          "reportResultReported": 4,
          "test.useConfigSimple": 4,
          "test.parseInputAppEvent": 4,
          "auth.logOut": 4,
          "auth.resetAuthorizations": 4,
          "auth.exportAuthorization": 8,
          "auth.requestPasswordRecovery": 4,
          "account.resetNotifySettings": 4,
          "account.updateStatus": 8,
          "account.getWallPapers": 12,
          "account.getPrivacy": 8,
          "account.getAccountTTL": 4,
          "account.setAccountTTL": 12,
          "account.updateDeviceLocked": 8,
          "account.getAuthorizations": 4,
          "account.resetAuthorization": 12,
          "account.getPassword": 4,
          "account.getWebAuthorizations": 4,
          "account.resetWebAuthorization": 12,
          "account.resetWebAuthorizations": 4,
          "account.getAllSecureValues": 4,
          "account.finishTakeoutSession": 8,
          "account.resendPasswordEmail": 4,
          "account.cancelPasswordEmail": 4,
          "account.getContactSignUpNotification": 4,
          "account.setContactSignUpNotification": 8,
          "account.resetWallPapers": 4,
          "account.getAutoDownloadSettings": 4,
          "account.saveAutoDownloadSettings": 48,
          "account.setContentSettings": 8,
          "account.getContentSettings": 4,
          "account.getGlobalPrivacySettings": 4,
          "account.setGlobalPrivacySettings": 12,
          "account.resetPassword": 4,
          "account.declinePasswordReset": 4,
          "account.getChatThemes": 12,
          "account.setAuthorizationTTL": 8,
          "account.getSavedRingtones": 12,
          "account.getDefaultEmojiStatuses": 12,
          "account.getRecentEmojiStatuses": 12,
          "account.clearRecentEmojiStatuses": 4,
          "account.getDefaultProfilePhotoEmojis": 12,
          "account.getDefaultGroupPhotoEmojis": 12,
          "account.getAutoSaveSettings": 4,
          "account.deleteAutoSaveExceptions": 4,
          "account.getDefaultBackgroundEmojis": 12,
          "account.getChannelDefaultEmojiStatuses": 12,
          "account.getChannelRestrictedStatusEmojis": 12,
          "account.getConnectedBots": 4,
          "account.getBusinessChatLinks": 4,
          "account.toggleSponsoredMessages": 8,
          "account.getReactionsNotifySettings": 4,
          "contacts.getContactIDs": 12,
          "contacts.getStatuses": 4,
          "contacts.getContacts": 12,
          "contacts.getBlocked": 16,
          "contacts.getTopPeers": 24,
          "contacts.resetSaved": 4,
          "contacts.getSaved": 4,
          "contacts.toggleTopPeers": 8,
          "contacts.blockFromReplies": 12,
          "contacts.exportContactToken": 4,
          "contacts.getBirthdays": 4,
          "messages.receivedMessages": 8,
          "messages.getFullChat": 12,
          "messages.getDhConfig": 12,
          "messages.discardEncryption": 12,
          "messages.setEncryptedTyping": 24,
          "messages.readEncryptedHistory": 24,
          "messages.receivedQueue": 8,
          "messages.reportEncryptedSpam": 20,
          "messages.getAllStickers": 12,
          "messages.migrateChat": 12,
          "messages.getSavedGifs": 12,
          "messages.getAllDrafts": 4,
          "messages.getFeaturedStickers": 12,
          "messages.getRecentStickers": 16,
          "messages.clearRecentStickers": 8,
          "messages.getArchivedStickers": 20,
          "messages.getMaskStickers": 12,
          "messages.getPinnedDialogs": 8,
          "messages.getFavedStickers": 12,
          "messages.getSplitRanges": 4,
          "messages.getDialogUnreadMarks": 4,
          "messages.clearAllDrafts": 4,
          "messages.getDialogFilters": 4,
          "messages.getSuggestedDialogFilters": 4,
          "messages.getOldFeaturedStickers": 20,
          "messages.deleteChat": 12,
          "messages.deletePhoneCallHistory": 8,
          "messages.getAvailableReactions": 8,
          "messages.getAttachMenuBots": 12,
          "messages.getEmojiStickers": 12,
          "messages.getFeaturedEmojiStickers": 12,
          "messages.getTopReactions": 16,
          "messages.getRecentReactions": 16,
          "messages.clearRecentReactions": 4,
          "messages.setDefaultHistoryTTL": 8,
          "messages.getDefaultHistoryTTL": 4,
          "messages.getEmojiGroups": 8,
          "messages.getEmojiStatusGroups": 8,
          "messages.getEmojiProfilePhotoGroups": 8,
          "messages.getPinnedSavedDialogs": 4,
          "messages.getDefaultTagReactions": 12,
          "messages.getQuickReplies": 12,
          "messages.deleteQuickReplyShortcut": 8,
          "messages.toggleDialogFilterTags": 8,
          "messages.getMyStickers": 16,
          "messages.getEmojiStickerGroups": 8,
          "messages.getAvailableEffects": 8,
          "messages.getPaidReactionPrivacy": 4,
          "updates.getState": 4,
          "help.getConfig": 4,
          "help.getNearestDc": 4,
          "help.getInviteText": 4,
          "help.getSupport": 4,
          "help.getCdnConfig": 4,
          "help.getTermsOfServiceUpdate": 4,
          "help.getAppConfig": 8,
          "help.getPassportConfig": 8,
          "help.getSupportName": 4,
          "help.getPromoData": 4,
          "help.getPremiumPromo": 4,
          "help.getPeerColors": 8,
          "help.getPeerProfileColors": 8,
          "help.getTimezonesList": 8,
          "channels.getAdminedPublicChannels": 8,
          "channels.getLeftChannels": 8,
          "channels.getGroupsForDiscussion": 4,
          "channels.getInactiveChannels": 4,
          "bots.setBotBroadcastDefaultAdminRights": 12,
          "bots.setBotGroupDefaultAdminRights": 12,
          "payments.getSavedInfo": 4,
          "payments.clearSavedInfo": 8,
          "payments.getStarsTopupOptions": 4,
          "payments.getStarsGiveawayOptions": 4,
          "payments.getStarGifts": 8,
          "phone.getCallConfig": 4,
          "phone.receivedCall": 24,
          "phone.discardCall": 44,
          "phone.leaveGroupCall": 28,
          "phone.discardGroupCall": 24,
          "phone.getGroupCall": 28,
          "phone.exportGroupCallInvite": 28,
          "phone.toggleGroupCallStartSubscription": 28,
          "phone.startScheduledGroupCall": 24,
          "phone.leaveGroupCallPresentation": 24,
          "phone.getGroupCallStreamChannels": 24,
          "chatlists.getExportedInvites": 12,
          "chatlists.getChatlistUpdates": 12,
          "chatlists.hideChatlistUpdates": 12,
          "chatlists.getLeaveChatlistSuggestions": 12,
          "stories.toggleAllStoriesHidden": 8,
          "stories.activateStealthMode": 8,
          "stories.getAllReadPeerStories": 4,
          "stories.getChatsToSend": 4,
          "premium.getMyBoosts": 4,
          "smsjobs.isEligibleToJoin": 4,
          "smsjobs.join": 4,
          "smsjobs.leave": 4,
          "smsjobs.updateSettings": 8,
          "smsjobs.getStatus": 4,
          "mt_dh_gen_ok": 52,
          "mt_dh_gen_retry": 52,
          "mt_dh_gen_fail": 52,
          "mt_bind_auth_key_inner": 40,
          "mt_rpc_answer_unknown": 4,
          "mt_rpc_answer_dropped_running": 4,
          "mt_rpc_answer_dropped": 20,
          "mt_future_salt": 20,
          "mt_pong": 20,
          "mt_destroy_session_ok": 12,
          "mt_destroy_session_none": 12,
          "mt_new_session_created": 28,
          "mt_bad_msg_notification": 20,
          "mt_bad_server_salt": 28,
          "mt_msg_detailed_info": 28,
          "mt_msg_new_detailed_info": 20,
          "mt_destroy_auth_key_ok": 4,
          "mt_destroy_auth_key_none": 4,
          "mt_destroy_auth_key_fail": 4,
          "mt_http_wait": 16,
          "mt_req_pq_multi": 20,
          "mt_rpc_drop_answer": 12,
          "mt_get_future_salts": 8,
          "mt_ping": 12,
          "mt_ping_delay_disconnect": 16,
          "mt_destroy_session": 12,
          "mt_destroy_auth_key": 4,
          "messageActionGroupCallScheduled": 28,
          "updateChatDefaultBannedRights": 32,
          "updateBroadcastRevenueTransactions": 48,
          "channelParticipantBanned": 44,
          "channelAdminLogEventActionDefaultBannedRights": 28,
          "channelAdminLogEventActionStartGroupCall": 24,
          "channelAdminLogEventActionDiscardGroupCall": 24
        }
      };
      var __tlWriterMap = exports("_", writer.__tlWriterMap = m);
      /**
       * @license
       * Copyright 2009 The Closure Library Authors
       * Copyright 2020 Daniel Wirtz / The long.js Authors.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       *
       * SPDX-License-Identifier: Apache-2.0
       */
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch (e2) {
      }
      function Long(low2, high, unsigned) {
        this.low = low2 | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long.prototype.__isLong__;
      Object.defineProperty(Long.prototype, "__isLong__", { value: true });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      function ctz32(value) {
        var c = Math.clz32(value & -value);
        return value ? 31 - c : c;
      }
      Long.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? UZERO : ZERO$1;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -9223372036854776e3)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL$2 | 0, value / TWO_PWR_32_DBL$2 | 0, unsigned);
      }
      Long.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
      }
      Long.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return unsigned ? UZERO : ZERO$1;
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO$1;
        for (var i = 0; i < str.length; i += 8) {
          var size2 = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size2), radix);
          if (size2 < 8) {
            var power = fromNumber(pow_dbl(radix, size2));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number")
          return fromNumber(val, unsigned);
        if (typeof val === "string")
          return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL$2 = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL$2 * TWO_PWR_32_DBL$2;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO$1 = fromInt(0);
      Long.ZERO = ZERO$1;
      var UZERO = fromInt(0, true);
      Long.UZERO = UZERO;
      var ONE$1 = fromInt(1);
      Long.ONE = ONE$1;
      var UONE = fromInt(1, true);
      Long.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber2() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL$2 + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL$2 + (this.low >>> 0);
      };
      LongPrototype.toString = function toString2(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE$1);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add2(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply2(multiplier) {
        if (this.isZero())
          return this;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low2 = wasm["mul"](
            this.low,
            this.high,
            multiplier.low,
            multiplier.high
          );
          return fromBits(low2, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero())
          return this.unsigned ? UZERO : ZERO$1;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO$1;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO$1;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low2 = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low2, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO$1;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE$1) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE$1;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO$1)) {
                return divisor.isNegative() ? ONE$1 : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO$1;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO$1;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE$1;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low2 = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low2, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32)
          return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi2 = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi2 & 255,
          hi2 >>> 8 & 255,
          hi2 >>> 16 & 255,
          hi2 >>> 24
        ];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi2 = this.high, lo = this.low;
        return [
          hi2 >>> 24,
          hi2 >>> 16 & 255,
          hi2 >>> 8 & 255,
          hi2 & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      Long.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
      };
      Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long(
          bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
          bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
          unsigned
        );
      };
      Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long(
          bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
          bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
          unsigned
        );
      };
      const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
      const _TlBinaryReader = class _TlBinaryReader {
        /**
         * @param objectsMap  Readers map
         * @param data  Buffer to read from
         * @param start  Position to start reading from
         */
        constructor(objectsMap, data2, start2 = 0) {
          __publicField(this, "dataView");
          __publicField(this, "uint8View");
          __publicField(this, "pos", 0);
          this.objectsMap = objectsMap;
          if (ArrayBuffer.isView(data2)) {
            this.pos = start2;
            this.dataView = new DataView(data2.buffer, data2.byteOffset, data2.byteLength);
            this.uint8View = new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
          } else {
            this.pos = start2;
            this.dataView = new DataView(data2);
            this.uint8View = new Uint8Array(data2);
          }
        }
        /**
         * Create a new reader without objects map for manual usage
         *
         * @param data  Buffer to read from
         * @param start  Position to start reading from
         */
        static manual(data2, start2 = 0) {
          return new _TlBinaryReader(void 0, data2, start2);
        }
        /**
         * Deserialize a single object
         *
         * @param objectsMap  Readers map
         * @param data  Buffer to read from
         * @param start  Position to start reading from
         */
        static deserializeObject(objectsMap, data2, start2 = 0) {
          return new _TlBinaryReader(objectsMap, data2, start2).object();
        }
        int() {
          const res = this.dataView.getInt32(this.pos, true);
          this.pos += 4;
          return res;
        }
        uint() {
          const res = this.dataView.getUint32(this.pos, true);
          this.pos += 4;
          return res;
        }
        /**
         * Get the next {@link uint} without advancing the reader cursor
         */
        peekUint() {
          return this.dataView.getUint32(this.pos, true);
        }
        int53() {
          const res = (this.dataView.getInt32(this.pos, true) >>> 0) + TWO_PWR_32_DBL$1 * this.dataView.getInt32(this.pos + 4, true);
          this.pos += 8;
          return res;
        }
        long(unsigned = false) {
          const lo = this.dataView.getInt32(this.pos, true);
          const hi2 = this.dataView.getInt32(this.pos + 4, true);
          this.pos += 8;
          return new Long(lo, hi2, unsigned);
        }
        float() {
          const res = this.dataView.getFloat32(this.pos, true);
          this.pos += 4;
          return res;
        }
        double() {
          const res = this.dataView.getFloat64(this.pos, true);
          this.pos += 8;
          return res;
        }
        boolean() {
          const val = this.uint();
          if (val === 3162085175)
            return false;
          if (val === 2574415285)
            return true;
          throw new Error(`Expected either boolTrue or boolFalse, got 0x${val.toString(16)}`);
        }
        /**
         * Read raw bytes of the given length
         * @param bytes  Length of the buffer to read
         */
        raw(bytes = -1) {
          if (bytes === -1)
            bytes = this.uint8View.length - this.pos;
          return this.uint8View.subarray(this.pos, this.pos += bytes);
        }
        int128() {
          return this.uint8View.subarray(this.pos, this.pos += 16);
        }
        int256() {
          return this.uint8View.subarray(this.pos, this.pos += 32);
        }
        bytes() {
          const firstByte = this.uint8View[this.pos++];
          let length;
          let padding;
          if (firstByte === 254) {
            length = this.uint8View[this.pos++] | this.uint8View[this.pos++] << 8 | this.uint8View[this.pos++] << 16;
            padding = length % 4;
          } else {
            length = firstByte;
            padding = (length + 1) % 4;
          }
          const data2 = this.raw(length);
          if (padding > 0)
            this.pos += 4 - padding;
          return data2;
        }
        string() {
          return _TlBinaryReader.platform.utf8Decode(this.bytes());
        }
        object(id2 = this.uint()) {
          if (id2 === 481674261) {
            return this.vector(this.object, true);
          }
          if (id2 === 3162085175)
            return false;
          if (id2 === 2574415285)
            return true;
          if (id2 === 1072550713)
            return true;
          if (id2 === 1450380236)
            return null;
          const reader2 = this.objectsMap[id2];
          if (!reader2) {
            this.seek(-4);
            const pos = this.pos;
            const error = new TypeError(`Unknown object id: 0x${id2.toString(16)}`);
            this.pos = pos;
            throw error;
          }
          return reader2(this);
        }
        vector(reader2 = this.object, bare = false) {
          if (!bare) {
            const uint = this.uint();
            if (uint !== 481674261) {
              throw new Error(
                `Invalid object code, expected 0x1cb5c415 (vector), got 0x${uint.toString(16)} at ${this.pos - 4}`
              );
            }
          }
          const length = this.uint();
          const ret = [];
          for (let i = 0; i < length; i++)
            ret.push(reader2.call(this));
          return ret;
        }
        /**
         * Advance the reader cursor by the given amount of bytes
         *
         * @param delta  Amount of bytes to advance (can be negative)
         */
        seek(delta) {
          this.seekTo(this.pos + delta);
        }
        /**
         * Seek to the given position
         *
         * @param pos  Position to seek to
         */
        seekTo(pos) {
          if (pos >= this.uint8View.length || pos < 0) {
            throw new RangeError("New position is out of range");
          }
          this.pos = pos;
        }
      };
      __publicField(_TlBinaryReader, "platform");
      let TlBinaryReader = _TlBinaryReader;
      exports("v", TlBinaryReader);
      const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
      class TlSerializationCounter {
        /**
         * @param objectMap  Writers map
         */
        constructor(objectMap) {
          __publicField(this, "count", 0);
          this.objectMap = objectMap;
        }
        /**
         * Count bytes required to serialize the given object.
         *
         * @param objectMap  Writers map
         * @param obj  Object to count bytes for
         */
        static countNeededBytes(objectMap, obj) {
          const cnt = new TlSerializationCounter(objectMap);
          cnt.object(obj);
          return cnt.count;
        }
        /**
         * Count overhead in bytes for the given number of bytes when
         * encoded as `bytes` TL type.
         *
         * @param size  Number of bytes
         */
        static countBytesOverhead(size2) {
          let res = 0;
          let padding;
          if (size2 <= 253) {
            res += 1;
            padding = (size2 + 1) % 4;
          } else {
            res += 4;
            padding = size2 % 4;
          }
          if (padding > 0)
            res += 4 - padding;
          return res;
        }
        boolean() {
          this.count += 4;
        }
        double() {
          this.count += 8;
        }
        float() {
          this.count += 4;
        }
        int128() {
          this.count += 16;
        }
        int256() {
          this.count += 32;
        }
        int() {
          this.count += 4;
        }
        uint() {
          this.count += 4;
        }
        int53() {
          this.count += 8;
        }
        long() {
          this.count += 8;
        }
        null() {
          this.count += 4;
        }
        raw(val) {
          this.count += val.byteLength;
        }
        bytes(val) {
          this.count += TlSerializationCounter.countBytesOverhead(val.length) + val.length;
        }
        string(val) {
          const length = TlBinaryWriter.platform.utf8ByteLength(val);
          this.count += TlSerializationCounter.countBytesOverhead(length) + length;
        }
        object(obj) {
          if (!this.objectMap[obj._])
            throw new Error(`Unknown object ${obj._}`);
          this.objectMap[obj._](this, obj);
        }
        vector(fn, items) {
          this.count += 8;
          items.forEach((it) => fn.call(this, it));
        }
      }
      exports("x", TlSerializationCounter);
      const _TlBinaryWriter = class _TlBinaryWriter {
        /**
         * @param objectMap  Writers map
         * @param buffer  Buffer to write to
         * @param start  Position to start writing at
         */
        constructor(objectMap, data2, start2 = 0) {
          __publicField(this, "dataView");
          __publicField(this, "uint8View");
          /**
           * Current position in the buffer.
           */
          __publicField(this, "pos");
          this.objectMap = objectMap;
          if (ArrayBuffer.isView(data2)) {
            this.pos = start2;
            this.dataView = new DataView(data2.buffer, data2.byteOffset, data2.byteLength);
            this.uint8View = new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
          } else {
            this.pos = start2;
            this.dataView = new DataView(data2);
            this.uint8View = new Uint8Array(data2);
          }
        }
        /**
         * Create a new writer with the given size.
         *
         * @param objectMap  Writers map
         * @param size  Size of the writer's buffer
         */
        static alloc(objectMap, size2) {
          return new _TlBinaryWriter(objectMap, new ArrayBuffer(size2));
        }
        /**
         * Create a new writer without objects map for manual usage
         *
         * @param buffer  Buffer to write to, or its size
         * @param start  Position to start writing at
         */
        static manual(buffer, start2 = 0) {
          if (typeof buffer === "number")
            buffer = new ArrayBuffer(buffer);
          return new _TlBinaryWriter(void 0, buffer, start2);
        }
        /**
         * Serialize a single object
         *
         * @param objectMap  Writers map
         * @param obj  Object to serialize
         * @param knownSize  In case the size is known, pass it here
         */
        static serializeObject(objectMap, obj, knownSize = -1) {
          if (knownSize === -1) {
            knownSize = objectMap._staticSize[obj._] || TlSerializationCounter.countNeededBytes(objectMap, obj);
          }
          const writer2 = _TlBinaryWriter.alloc(objectMap, knownSize);
          writer2.object(obj);
          return writer2.uint8View;
        }
        int(val) {
          this.dataView.setInt32(this.pos, val, true);
          this.pos += 4;
        }
        uint(val) {
          this.dataView.setUint32(this.pos, val, true);
          this.pos += 4;
        }
        int53(val) {
          this.dataView.setInt32(this.pos, val % TWO_PWR_32_DBL | 0, true);
          if (val < 0) {
            this.dataView.setInt32(this.pos + 4, val / TWO_PWR_32_DBL - 1 | 0, true);
          } else {
            this.dataView.setInt32(this.pos + 4, val / TWO_PWR_32_DBL | 0, true);
          }
          this.pos += 8;
        }
        null() {
          this.uint(1450380236);
        }
        long(val) {
          this.dataView.setInt32(this.pos, val.low, true);
          this.dataView.setInt32(this.pos + 4, val.high, true);
          this.pos += 8;
        }
        float(val) {
          this.dataView.setFloat32(this.pos, val, true);
          this.pos += 4;
        }
        double(val) {
          this.dataView.setFloat64(this.pos, val, true);
          this.pos += 8;
        }
        boolean(val) {
          this.dataView.setInt32(this.pos, val ? 2574415285 : 3162085175, true);
          this.pos += 4;
        }
        /**
         * Write raw bytes to the buffer
         * @param val  Buffer to write
         */
        raw(val) {
          this.uint8View.set(val, this.pos);
          this.pos += val.byteLength;
        }
        int128(val) {
          if (val.byteLength !== 16)
            throw new Error("Invalid int128 length");
          this.raw(val);
        }
        int256(val) {
          if (val.byteLength !== 32)
            throw new Error("Invalid int256 length");
          this.raw(val);
        }
        bytes(val) {
          const length = val.byteLength;
          let padding;
          if (length <= 253) {
            this.uint8View[this.pos++] = length;
            padding = (length + 1) % 4;
          } else {
            this.uint8View[this.pos++] = 254;
            this.uint8View[this.pos++] = length & 255;
            this.uint8View[this.pos++] = length >> 8 & 255;
            this.uint8View[this.pos++] = length >> 16 & 255;
            padding = length % 4;
          }
          this.uint8View.set(val, this.pos);
          this.pos += length;
          if (padding > 0) {
            padding = 4 - padding;
            while (padding--)
              this.uint8View[this.pos++] = 0;
          }
        }
        string(val) {
          this.bytes(_TlBinaryWriter.platform.utf8Encode(val));
        }
        // hot path, avoid additional runtime checks
        object(obj) {
          const fn = this.objectMap[obj._];
          if (!fn)
            throw new Error(`Unknown object ${obj._}`);
          fn(this, obj);
        }
        vector(fn, val, bare) {
          if (!bare)
            this.uint(481674261);
          this.uint(val.length);
          val.forEach((it) => fn.call(this, it, bare));
        }
        /**
         * Get the resulting buffer
         */
        result() {
          return this.uint8View.subarray(0, this.pos);
        }
      };
      __publicField(_TlBinaryWriter, "platform");
      let TlBinaryWriter = _TlBinaryWriter;
      exports("w", TlBinaryWriter);
      const platformKey = typeof Symbol !== "undefined" ? Symbol.for("mtcute.platform") : "__MTCUTE_PLATFORM__";
      let _platform = (_a2 = globalThis == null ? void 0 : globalThis[platformKey]) != null ? _a2 : null;
      function setPlatform(platform2) {
        if (_platform) {
          if (_platform.constructor !== platform2.constructor) {
            throw new MtUnsupportedError("Platform may not be changed at runtime!");
          }
          return;
        }
        _platform = platform2;
        TlBinaryReader.platform = platform2;
        TlBinaryWriter.platform = platform2;
        globalThis[platformKey] = platform2;
      }
      function getPlatform() {
        if (!_platform) {
          throw new MtUnsupportedError("Platform is not set! Have you instantiated the client?");
        }
        return _platform;
      }
      const setTimeoutWrap = (...args) => setTimeout(...args);
      const setIntervalWrap = (...args) => setInterval(...args);
      let setImmediateWrap;
      if (typeof setImmediate !== "undefined") {
        setImmediateWrap = (...args) => setImmediate(...args);
      } else {
        setImmediateWrap = (fn, ...args) => setTimeout(fn, 0, ...args);
      }
      const setImmediateWrapExported = setImmediateWrap;
      const clearTimeoutWrap = (...args) => clearTimeout(...args);
      const clearIntervalWrap = (...args) => clearInterval(...args);
      let clearImmediateWrap;
      if (typeof clearImmediate !== "undefined") {
        clearImmediateWrap = (...args) => clearImmediate(...args);
      } else {
        clearImmediateWrap = (timer) => clearTimeout(timer);
      }
      const clearImmediateWrapExported = clearImmediateWrap;
      const timers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        clearImmediate: clearImmediateWrapExported,
        clearInterval: clearIntervalWrap,
        clearTimeout: clearTimeoutWrap,
        setImmediate: setImmediateWrapExported,
        setInterval: setIntervalWrap,
        setTimeout: setTimeoutWrap
      }, Symbol.toStringTag, { value: "Module" }));
      exports("b1", timers);
      function buffersEqual(a, b) {
        if (a.length !== b.length)
          return false;
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
      function cloneBuffer(buf, start2 = 0, end = buf.length) {
        const ret = new Uint8Array(end - start2);
        ret.set(buf.subarray(start2, end));
        return ret;
      }
      function concatBuffers(buffers) {
        if (buffers.length === 1)
          return buffers[0];
        if (typeof Buffer !== "undefined") {
          return Buffer.concat(buffers);
        }
        let length = 0;
        for(let   buf of buffers) {
          length += buf.length;
        }
        const ret = new Uint8Array(length);
        let offset = 0;
        for(let   buf of buffers) {
          ret.set(buf, offset);
          offset += buf.length;
        }
        return ret;
      }
      function dataViewFromBuffer(buf) {
        return new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      function bufferToReversed(buf, start2 = 0, end = buf.length) {
        const len = end - start2;
        const ret = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          ret[i] = buf[end - i - 1];
        }
        return ret;
      }
      function determinePartSize(fileSize) {
        if (fileSize <= 262078465)
          return 128;
        if (fileSize <= 786432e3)
          return 256;
        if (fileSize <= 2097152e3)
          return 512;
        throw new MtArgumentError("File is too large");
      }
      function isProbablyPlainText(buf) {
        return !buf.some(
          (it) => !(it >= 32 && it < 127 || it === 13 || it === 10 || it === 9)
        );
      }
      function JPEG_HEADER() {
        return getPlatform().hexDecode(
          "ffd8ffe000104a46494600010100000100010000ffdb004300281c1e231e19282321232d2b28303c64413c37373c7b585d4964918099968f808c8aa0b4e6c3a0aadaad8a8cc8ffcbdaeef5ffffff9bc1fffffffaffe6fdfff8ffdb0043012b2d2d3c353c76414176f8a58ca5f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8ffc00011080000000003012200021101031101ffc4001f0000010501010101010100000000000000000102030405060708090a0bffc400b5100002010303020403050504040000017d01020300041105122131410613516107227114328191a1082342b1c11552d1f02433627282090a161718191a25262728292a3435363738393a434445464748494a535455565758595a636465666768696a737475767778797a838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae1e2e3e4e5e6e7e8e9eaf1f2f3f4f5f6f7f8f9faffc4001f0100030101010101010101010000000000000102030405060708090a0bffc400b51100020102040403040705040400010277000102031104052131061241510761711322328108144291a1b1c109233352f0156272d10a162434e125f11718191a262728292a35363738393a434445464748494a535455565758595a636465666768696a737475767778797a82838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae2e3e4e5e6e7e8e9eaf2f3f4f5f6f7f8f9faffda000c03010002110311003f00"
        );
      }
      let JPEG_HEADER_BYTES = null;
      const JPEG_FOOTER = new Uint8Array([255, 217]);
      function strippedPhotoToJpg(stripped) {
        if (stripped.length < 3 || stripped[0] !== 1) {
          throw new MtArgumentError("Invalid stripped JPEG");
        }
        if (JPEG_HEADER_BYTES === null) {
          JPEG_HEADER_BYTES = JPEG_HEADER();
        }
        const result = concatBuffers([JPEG_HEADER_BYTES, stripped.slice(3), JPEG_FOOTER]);
        result[164] = stripped[1];
        result[166] = stripped[2];
        return result;
      }
      const SVG_LOOKUP = "AACAAAAHAAALMAAAQASTAVAAAZaacaaaahaaalmaaaqastava.az0123456789-,";
      function inflateSvgPath(encoded) {
        let path2 = "M";
        const len = encoded.length;
        for (let i = 0; i < len; i++) {
          const num2 = encoded[i];
          if (num2 >= 192) {
            path2 += SVG_LOOKUP[num2 - 192];
          } else {
            if (num2 >= 128) {
              path2 += ",";
            } else if (num2 >= 64) {
              path2 += "-";
            }
            path2 += num2 & 63;
          }
        }
        path2 += "z";
        return path2;
      }
      function svgPathToFile(path2, size2) {
        var _a3, _b2;
        return getPlatform().utf8Encode(
          `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"viewBox="0 0 ${(_a3 = size2 == null ? void 0 : size2.w) != null ? _a3 : 512} ${(_b2 = size2 == null ? void 0 : size2.h) != null ? _b2 : 512}" xml:space="preserve"><path d="${path2}"/></svg>`
        );
      }
      function extractFileName(path2) {
        if (path2.startsWith("file:"))
          path2 = path2.slice(5);
        return path2.split(/[\\/]/).pop().split("?")[0];
      }
      function parseInlineMessageId(id2) {
        const buf = getPlatform().base64Decode(id2, true);
        const reader2 = TlBinaryReader.manual(buf);
        if (buf.length === 20) {
          return {
            _: "inputBotInlineMessageID",
            dcId: reader2.int(),
            id: reader2.long(),
            accessHash: reader2.long()
          };
        }
        return {
          _: "inputBotInlineMessageID64",
          dcId: reader2.int(),
          ownerId: reader2.long(),
          id: reader2.int(),
          accessHash: reader2.long()
        };
      }
      function encodeInlineMessageId(id2) {
        let writer2;
        switch (id2._) {
          case "inputBotInlineMessageID":
            writer2 = TlBinaryWriter.manual(20);
            writer2.int(id2.dcId);
            writer2.long(id2.id);
            writer2.long(id2.accessHash);
            break;
          case "inputBotInlineMessageID64":
            writer2 = TlBinaryWriter.manual(24);
            writer2.int(id2.dcId);
            writer2.long(id2.ownerId);
            writer2.int(id2.id);
            writer2.long(id2.accessHash);
            break;
          default:
            assertNever$1();
        }
        return getPlatform().base64Encode(writer2.result(), true);
      }
      function normalizeInlineId(id2) {
        if (typeof id2 === "string") {
          return parseInlineMessageId(id2);
        }
        return id2;
      }
      function normalizePhoneNumber(phone) {
        phone = phone.trim().replace(/[+()\s-]/g, "");
        if (!phone.match(/^\d+$/))
          throw new MtArgumentError("Invalid phone number");
        return phone;
      }
      function resolveMaybeDynamic(val) {
        return __async(this, null, function* () {
          return val instanceof Function ? yield val() : yield val;
        });
      }
      function makeArrayWithTotal(arr, total) {
        const a = arr;
        a.total = total;
        return a;
      }
      function makeArrayPaginated(arr, total, next2) {
        const a = arr;
        a.total = total;
        a.next = next2;
        return a;
      }
      function normalizeDate(date2) {
        return date2 ? ~~((typeof date2 === "number" ? date2 : date2.getTime()) / 1e3) : void 0;
      }
      function normalizeMessageId(msg) {
        if (!msg)
          return void 0;
        return typeof msg === "number" ? msg : msg.id;
      }
      class MtPeerNotFoundError extends MtcuteError {
      }
      exports("co", MtPeerNotFoundError);
      class MtMessageNotFoundError extends MtcuteError {
        constructor(peerId, messageId, context) {
          super(`Message${context ? ` ${context}` : ""} ${messageId} not found in ${peerId}`);
          this.peerId = peerId;
          this.messageId = messageId;
          this.context = context;
        }
      }
      exports("cn", MtMessageNotFoundError);
      class MtInvalidPeerTypeError extends MtcuteError {
        constructor(peer, expected) {
          super(`Provided identifier ${JSON.stringify(peer)} is not a ${expected}`);
        }
      }
      exports("cm", MtInvalidPeerTypeError);
      class MtEmptyError extends MtcuteError {
        constructor() {
          super("Property is not available on an empty object");
        }
      }
      exports("cl", MtEmptyError);
      const INVITE_LINK_REGEX = exports("I", /^(?:https?:\/\/)?(?:www\.)?t(?:elegram)?\.(?:org|me|dog)\/(?:joinchat\/|\+)([\w-]+)$/i);
      function toInputPeer(res) {
        if (tl.tl.isAnyInputPeer(res))
          return res;
        switch (res._) {
          case "inputChannelEmpty":
          case "inputUserEmpty":
            return { _: "inputPeerEmpty" };
          case "inputUser":
            return {
              _: "inputPeerUser",
              userId: res.userId,
              accessHash: res.accessHash
            };
          case "inputUserSelf":
            return { _: "inputPeerSelf" };
          case "inputChannel":
            return {
              _: "inputPeerChannel",
              channelId: res.channelId,
              accessHash: res.accessHash
            };
          case "inputChannelFromMessage":
            return {
              _: "inputPeerChannelFromMessage",
              channelId: res.channelId,
              msgId: res.msgId,
              peer: res.peer
            };
          case "inputUserFromMessage":
            return {
              _: "inputPeerUserFromMessage",
              userId: res.userId,
              msgId: res.msgId,
              peer: res.peer
            };
          default:
            assertNever$1();
        }
      }
      function toInputUser(res, input) {
        if (tl.tl.isAnyInputUser(res))
          return res;
        switch (res._) {
          case "inputPeerSelf":
            return { _: "inputUserSelf" };
          case "inputPeerUser":
            return {
              _: "inputUser",
              userId: res.userId,
              accessHash: res.accessHash
            };
          case "inputPeerUserFromMessage":
            return {
              _: "inputUserFromMessage",
              userId: res.userId,
              msgId: res.msgId,
              peer: res.peer
            };
        }
        throw new MtInvalidPeerTypeError(input != null ? input : res, "user");
      }
      function toInputChannel(res, input) {
        if (tl.tl.isAnyInputChannel(res))
          return res;
        switch (res._) {
          case "inputPeerChannel":
            return {
              _: "inputChannel",
              channelId: res.channelId,
              accessHash: res.accessHash
            };
          case "inputPeerChannelFromMessage":
            return {
              _: "inputChannelFromMessage",
              channelId: res.channelId,
              msgId: res.msgId,
              peer: res.peer
            };
        }
        throw new MtInvalidPeerTypeError(input != null ? input : res, "channel");
      }
      function isInputPeerUser(obj) {
        switch (obj._) {
          case "inputPeerUser":
          case "inputPeerUserFromMessage":
          case "inputPeerSelf":
            return true;
        }
        return false;
      }
      function isInputPeerChannel(obj) {
        switch (obj._) {
          case "inputPeerChannel":
          case "inputPeerChannelFromMessage":
            return true;
        }
        return false;
      }
      function isInputPeerChat(obj) {
        return obj._ === "inputPeerChat";
      }
      function inputPeerToPeer(inp) {
        switch (inp._) {
          case "inputPeerUser":
          case "inputPeerUserFromMessage":
            return { _: "peerUser", userId: inp.userId };
          case "inputPeerChannel":
          case "inputPeerChannelFromMessage":
            return { _: "peerChannel", channelId: inp.channelId };
          case "inputPeerChat":
            return { _: "peerChat", chatId: inp.chatId };
          default:
            throw new MtInvalidPeerTypeError(inp, `Cannot convert ${inp._} to peer`);
        }
      }
      function extractUsernames(obj) {
        var _a3;
        if ((_a3 = obj.usernames) == null ? void 0 : _a3.length)
          return obj.usernames.map((x) => x.username.toLowerCase());
        if (obj.username)
          return [obj.username.toLowerCase()];
        return [];
      }
      const MIN_INITIAL_CAPACITY = 8;
      function arraycopy(src, srcPos, dest, destPos, length) {
        for (let i = 0; i < length; i++) {
          dest[destPos + i] = src[srcPos + i];
        }
      }
      class Deque {
        constructor(maxLength = Infinity, minCapacity = maxLength === Infinity ? MIN_INITIAL_CAPACITY : maxLength) {
          // another implementation variant would be to use
          // blocks of fixed size instead of a single array
          // to avoid copying stuff around
          __publicField(this, "_elements");
          __publicField(this, "_head", 0);
          __publicField(this, "_tail", 0);
          __publicField(this, "_capacity");
          this.maxLength = maxLength;
          let capacity = minCapacity;
          if (capacity < MIN_INITIAL_CAPACITY) {
            capacity = MIN_INITIAL_CAPACITY;
          }
          if (capacity !== MIN_INITIAL_CAPACITY) {
            capacity |= capacity >>> 1;
            capacity |= capacity >>> 2;
            capacity |= capacity >>> 4;
            capacity |= capacity >>> 8;
            capacity |= capacity >>> 16;
            capacity += 1;
            if (capacity < 0) {
              capacity >>>= 1;
            }
          }
          this._elements = new Array(capacity);
          this._capacity = capacity;
        }
        _resize() {
          const p = this._head;
          const n2 = this._capacity;
          const r2 = n2 - p;
          const newCapacity = n2 << 1;
          if (newCapacity < 0)
            throw new Error("Deque is too big");
          const arr = new Array(newCapacity);
          arraycopy(this._elements, p, arr, 0, r2);
          arraycopy(this._elements, 0, arr, r2, p);
          this._elements = arr;
          this._head = 0;
          this._tail = n2;
          this._capacity = newCapacity;
        }
        pushBack(item2) {
          if (item2 === void 0)
            throw new Error("item can not be undefined");
          this._elements[this._tail] = item2;
          if ((this._tail = this._tail + 1 & this._capacity - 1) === this._head) {
            this._resize();
          }
          if (this.length > this.maxLength) {
            this.popFront();
          }
        }
        pushFront(item2) {
          if (item2 === void 0)
            throw new Error("item can not be undefined");
          this._elements[this._head = this._head - 1 & this._capacity - 1] = item2;
          if (this._head === this._tail) {
            this._resize();
          }
          if (this.length > this.maxLength) {
            this.popBack();
          }
        }
        popFront() {
          const h2 = this._head;
          const res = this._elements[h2];
          if (res === void 0)
            return void 0;
          this._elements[h2] = void 0;
          this._head = h2 + 1 & this._capacity - 1;
          return res;
        }
        popBack() {
          const t2 = this._tail - 1 & this._capacity - 1;
          const res = this._elements[t2];
          if (res === void 0)
            return void 0;
          this._elements[t2] = void 0;
          this._tail = t2;
          return res;
        }
        peekFront() {
          return this._elements[this._head];
        }
        peekBack() {
          return this._elements[this._tail - 1 & this._capacity - 1];
        }
        get length() {
          return this._tail - this._head & this._capacity - 1;
        }
        toArray() {
          const sz = this.length;
          if (sz === 0)
            return [];
          const arr = new Array(sz);
          if (this._head < this._tail) {
            arraycopy(this._elements, this._head, arr, 0, sz);
          } else {
            const headPortion = this._capacity - this._head;
            arraycopy(this._elements, this._head, arr, 0, headPortion);
            arraycopy(this._elements, 0, arr, headPortion, this._tail);
          }
          return arr;
        }
        _delete(i) {
          const els = this._elements;
          const mask = this._capacity - 1;
          const h2 = this._head;
          const t2 = this._tail;
          const front = i - h2 & mask;
          const back = t2 - i & mask;
          if (front < back) {
            if (h2 <= i) {
              arraycopy(els, h2, els, h2 + 1, front);
            } else {
              arraycopy(els, 0, els, 1, i);
              els[0] = els[mask];
              arraycopy(els, h2, els, h2 + 1, mask - h2);
            }
            els[h2] = void 0;
            this._head = h2 + 1 & mask;
          } else if (i < t2) {
            arraycopy(els, i + 1, els, i, back);
            this._tail = t2 - 1;
          } else {
            arraycopy(els, i + 1, els, i, mask - i);
            els[mask] = els[0];
            arraycopy(els, 1, els, 0, t2);
            this._tail = t2 - 1 & mask;
          }
        }
        remove(item2) {
          const mask = this._capacity - 1;
          let i = this._head;
          let val;
          while ((val = this._elements[i]) !== void 0) {
            if (item2 === val) {
              this._delete(i);
              return;
            }
            i = i + 1 & mask;
          }
        }
        removeBy(pred) {
          const mask = this._capacity - 1;
          let i = this._head;
          let val;
          while ((val = this._elements[i]) !== void 0) {
            if (pred(val)) {
              this._delete(i);
              return;
            }
            i = i + 1 & mask;
          }
        }
        at(idx) {
          return this._elements[this._head + idx & this._capacity - 1];
        }
        *iter() {
          const sz = this.length;
          if (sz === 0)
            return;
          if (this._head < this._tail) {
            for (let i = 0; i < sz; i++) {
              yield this._elements[this._head + i];
            }
          } else {
            const headPortion = this._capacity - this._head;
            for (let i = 0; i < headPortion; i++) {
              yield this._elements[this._head + i];
            }
            for (let i = 0; i < this._tail; i++) {
              yield this._elements[i];
            }
          }
        }
        clear() {
          this._elements = new Array(this._capacity);
          this._head = this._tail = 0;
        }
      }
      exports("D", Deque);
      class AsyncLock {
        constructor() {
          __publicField(this, "_queue", new Deque());
        }
        acquire() {
          return __async(this, null, function* () {
            let info;
            while (info = this._queue.peekFront()) {
              yield info[0];
            }
            let unlock;
            const prom = new Promise((resolve) => {
              unlock = resolve;
            });
            this._queue.pushBack([prom, unlock]);
          });
        }
        release() {
          if (!this._queue.length)
            throw new Error("Nothing to release");
          this._queue.popFront()[1]();
        }
        with(func) {
          let err = null;
          return this.acquire().then(() => func()).catch((e2) => void (err = e2)).then(() => {
            this.release();
            if (err)
              throw err;
          });
        }
      }
      exports("A", AsyncLock);
      function bufferToStream(buf) {
        return new ReadableStream({
          start(controller) {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      function streamToBuffer(stream) {
        return __async(this, null, function* () {
          const chunks = [];
          const reader2 = stream.getReader();
          while (true) {
            const { done, value } = yield reader2.read();
            if (done)
              break;
            chunks.push(value);
          }
          return concatBuffers(chunks);
        });
      }
      function createChunkedReader(stream, chunkSize) {
        const reader2 = stream.getReader();
        const lock = new AsyncLock();
        const buffer = [];
        let bufferLength = 0;
        let next2;
        let first = true;
        function readInner() {
          return __async(this, null, function* () {
            const { value } = yield reader2.read();
            if (first) {
              first = false;
              const { value: nextValue } = yield reader2.read();
              next2 = nextValue;
              return value;
            }
            const tmp = next2;
            next2 = value;
            return tmp;
          });
        }
        function read() {
          return __async(this, null, function* () {
            if (bufferLength > chunkSize) {
              const chunks = [];
              let length = 0;
              while (length < chunkSize && buffer.length) {
                const chunk = buffer.shift();
                length += chunk.length;
                chunks.push(chunk);
              }
              if (length > chunkSize) {
                const lastChunk = chunks.pop();
                const diff = length - chunkSize;
                chunks.push(lastChunk.subarray(0, lastChunk.length - diff));
                buffer.unshift(lastChunk.subarray(lastChunk.length - diff));
                length = chunkSize;
              }
              if (length === chunkSize) {
                bufferLength -= chunkSize;
                return concatBuffers(chunks);
              }
            } else if (next2 === void 0 && bufferLength > 0) {
              bufferLength = 0;
              return concatBuffers(buffer);
            }
            const value = yield readInner();
            if (!value)
              return null;
            if (bufferLength > 0) {
              buffer.push(value);
              bufferLength += value.length;
              return read();
            }
            if (value.length > chunkSize) {
              const rest = value.subarray(chunkSize);
              buffer.push(rest);
              bufferLength += rest.length;
              return value.subarray(0, chunkSize);
            }
            if (value.length === chunkSize) {
              return value;
            }
            buffer.push(value);
            bufferLength += value.length;
            return read();
          });
        }
        function readLocked() {
          return __async(this, null, function* () {
            yield lock.acquire();
            let res = null;
            let err = null;
            try {
              res = yield read();
            } catch (e2) {
              err = e2;
            }
            lock.release();
            if (err)
              throw err;
            return res;
          });
        }
        return {
          ended: () => bufferLength === 0 && next2 === void 0,
          read: readLocked
        };
      }
      function serializeBasicDcOption(dc) {
        const writer2 = TlBinaryWriter.manual(64);
        const flags = (dc.ipv6 ? 1 : 0) | (dc.mediaOnly ? 2 : 0);
        writer2.raw(
          new Uint8Array([
            1,
            // version
            dc.id,
            flags
          ])
        );
        writer2.string(dc.ipAddress);
        writer2.int(dc.port);
        return writer2.result();
      }
      function parseBasicDcOption(data2) {
        const reader2 = TlBinaryReader.manual(data2);
        const [version2, id2, flags] = reader2.raw(3);
        if (version2 !== 1)
          return null;
        const ipAddress = reader2.string();
        const port2 = reader2.int();
        return {
          id: id2,
          ipAddress,
          port: port2,
          ipv6: (flags & 1) !== 0,
          mediaOnly: (flags & 2) !== 0
        };
      }
      const defaultProductionDc = exports("ad", {
        main: {
          ipAddress: "149.154.167.50",
          port: 443,
          id: 2
        },
        media: {
          ipAddress: "149.154.167.222",
          port: 443,
          id: 2,
          mediaOnly: true
        }
      });
      const defaultProductionIpv6Dc = exports("ae", {
        main: {
          ipAddress: "2001:067c:04e8:f002:0000:0000:0000:000a",
          ipv6: true,
          port: 443,
          id: 2
        },
        media: {
          ipAddress: "2001:067c:04e8:f002:0000:0000:0000:000b",
          ipv6: true,
          port: 443,
          id: 2,
          mediaOnly: true
        }
      });
      const defaultTestDc = exports("af", {
        main: {
          ipAddress: "149.154.167.40",
          port: 443,
          id: 2
        },
        media: {
          ipAddress: "149.154.167.40",
          port: 443,
          id: 2,
          mediaOnly: true
        }
      });
      const defaultTestIpv6Dc = exports("ag", {
        main: {
          ipAddress: "2001:67c:4e8:f002::e",
          port: 443,
          ipv6: true,
          id: 2
        },
        media: {
          ipAddress: "2001:67c:4e8:f002::e",
          port: 443,
          ipv6: true,
          id: 2,
          mediaOnly: true
        }
      });
      function readTlDcOption(reader2) {
        const ctorId = reader2.uint();
        if (ctorId !== 414687501) {
          throw new MtArgumentError(`Invalid dcOption constructor id: ${ctorId}`);
        }
        const flags = reader2.uint();
        const id2 = reader2.int();
        const ipAddress = reader2.string();
        const port2 = reader2.int();
        if (flags & 1024) {
          reader2.bytes();
        }
        return {
          id: id2,
          ipAddress,
          port: port2,
          ipv6: Boolean(flags & 1),
          mediaOnly: Boolean(flags & 2)
        };
      }
      function writeStringSession(data2) {
        const writer2 = TlBinaryWriter.manual(512);
        const version2 = data2.version;
        if (version2 !== 3) {
          throw new MtArgumentError(`Unsupported string session version: ${version2}`);
        }
        let flags = 0;
        if (data2.self) {
          flags |= 1;
        }
        if (data2.testMode) {
          flags |= 2;
        }
        writer2.uint8View[0] = version2;
        writer2.pos += 1;
        if (version2 >= 2 && data2.primaryDcs.media !== data2.primaryDcs.main) {
          flags |= 4;
        }
        writer2.int(flags);
        writer2.bytes(serializeBasicDcOption(data2.primaryDcs.main));
        if (version2 >= 2 && data2.primaryDcs.media !== data2.primaryDcs.main) {
          writer2.bytes(serializeBasicDcOption(data2.primaryDcs.media));
        }
        if (data2.self) {
          writer2.int53(data2.self.userId);
          writer2.boolean(data2.self.isBot);
        }
        writer2.bytes(data2.authKey);
        return getPlatform().base64Encode(writer2.result(), true);
      }
      function readStringSession(data2) {
        const buf = getPlatform().base64Decode(data2, true);
        const version2 = buf[0];
        if (version2 !== 1 && version2 !== 2 && version2 !== 3) {
          throw new Error(`Invalid session string (version = ${version2})`);
        }
        if (version2 < 3) {
          console.warn(
            `You are using a deprecated session string (${data2.slice(
              0,
              10
            )}...). Please update your session string, as it will stop working in the future.`
          );
        }
        const reader2 = TlBinaryReader.manual(buf, 1);
        const flags = reader2.int();
        const hasSelf = flags & 1;
        const testMode = Boolean(flags & 2);
        const hasMedia = version2 >= 2 && Boolean(flags & 4);
        let primaryDc;
        let primaryMediaDc;
        if (version2 <= 2) {
          const primaryDc_ = readTlDcOption(reader2);
          const primaryMediaDc_ = hasMedia ? readTlDcOption(reader2) : primaryDc_;
          primaryDc = primaryDc_;
          primaryMediaDc = primaryMediaDc_;
        } else if (version2 === 3) {
          const primaryDc_ = parseBasicDcOption(reader2.bytes());
          if (primaryDc_ === null) {
            throw new MtArgumentError("Invalid session string (failed to parse primaryDc)");
          }
          const primaryMediaDc_ = hasMedia ? parseBasicDcOption(reader2.bytes()) : primaryDc_;
          if (primaryMediaDc_ === null) {
            throw new MtArgumentError("Invalid session string (failed to parse primaryMediaDc)");
          }
          primaryDc = primaryDc_;
          primaryMediaDc = primaryMediaDc_;
        } else {
          throw new Error("unreachable");
        }
        let self2 = null;
        if (hasSelf) {
          const selfId = reader2.int53();
          const selfBot = reader2.boolean();
          self2 = {
            userId: selfId,
            isBot: selfBot,
            // todo: we should make sure we fetch this from the server at first start
            isPremium: false,
            usernames: []
          };
        }
        const key = reader2.bytes();
        return {
          version: version2,
          testMode,
          primaryDcs: {
            main: primaryDc,
            media: primaryMediaDc
          },
          self: self2,
          authKey: key
        };
      }
      function decodeWaveform(wf) {
        const bitsCount = wf.length * 8;
        const valuesCount = ~~(bitsCount / 5);
        if (!valuesCount)
          return [];
        const lastIdx = valuesCount - 1;
        const result = [];
        const dv = dataViewFromBuffer(wf);
        for (let i = 0, j = 0; i < lastIdx; i++, j += 5) {
          const byteIdx = ~~(j / 8);
          const bitShift = j % 8;
          result[i] = dv.getUint16(byteIdx, true) >> bitShift & 31;
        }
        const lastByteIdx = ~~(lastIdx * 5 / 8);
        const lastBitShift = lastIdx * 5 % 8;
        const lastValue = lastByteIdx === wf.length - 1 ? wf[lastByteIdx] : dv.getUint16(lastByteIdx, true);
        result[lastIdx] = lastValue >> lastBitShift & 31;
        return result;
      }
      function encodeWaveform(wf) {
        const bitsCount = wf.length * 5;
        const bytesCount = ~~((bitsCount + 7) / 8);
        const result = new Uint8Array(bytesCount + 1);
        const dv = dataViewFromBuffer(result);
        for (let i = 0, j = 0; i < wf.length; i++, j += 5) {
          const byteIdx = ~~(j / 8);
          const bitShift = j % 8;
          const value = (wf[i] & 31) << bitShift;
          dv.setUint16(byteIdx, dv.getUint16(byteIdx, true) | value, true);
        }
        return result.slice(0, bytesCount);
      }
      class BaseService {
        constructor(opts) {
          __publicField(this, "_driver");
          __publicField(this, "_readerMap");
          __publicField(this, "_writerMap");
          __publicField(this, "_log");
          this._driver = opts.driver;
          this._readerMap = opts.readerMap;
          this._writerMap = opts.writerMap;
          this._log = opts.log;
        }
        _serializeTl(obj) {
          return TlBinaryWriter.serializeObject(this._writerMap, obj);
        }
        _deserializeTl(data2) {
          try {
            return TlBinaryReader.deserializeObject(this._readerMap, data2);
          } catch (e2) {
            return null;
          }
        }
      }
      exports("k", BaseService);
      function isPresent(t2) {
        return t2 !== void 0 && t2 !== null;
      }
      function hasValueAtKey(k, v) {
        return function(a) {
          return a[k] === v;
        };
      }
      function assertTypeIs(context, obj, expected) {
        if (obj._ !== expected) {
          throw new MtTypeAssertionError(context, expected, obj._);
        }
      }
      function assertTypeIsNot(context, obj, expectedNot) {
        if (obj._ === expectedNot) {
          throw new MtTypeAssertionError(context, `not ${expectedNot}`, obj._);
        }
      }
      function mtpAssertTypeIs(context, obj, expected) {
        if (obj._ !== expected) {
          throw new MtTypeAssertionError(context, expected, obj._);
        }
      }
      function assertTrue(context, cond) {
        if (!cond) {
          throw new MtTypeAssertionError(context, "true", "false");
        }
      }
      function isTlRpcError(obj) {
        return typeof obj === "object" && obj !== null && obj._ === "mt_rpc_error";
      }
      const KV_CURRENT_USER = "current_user";
      function serialize(info) {
        if (!info)
          return new Uint8Array(0);
        const hasUsernames = info.usernames.length > 0;
        let usernamesOverhead = hasUsernames ? 4 : 0;
        for(let   username2 of info.usernames) {
          usernamesOverhead += TlSerializationCounter.countBytesOverhead(username2.length) + username2.length;
        }
        const writer2 = TlBinaryWriter.manual(16 + usernamesOverhead);
        writer2.int(1);
        let flags = 0;
        if (info.isBot)
          flags |= 1;
        if (hasUsernames)
          flags |= 2;
        if (info.isPremium)
          flags |= 4;
        writer2.int(flags);
        writer2.int53(info.userId);
        if (hasUsernames) {
          writer2.int(info.usernames.length);
          for(let   username2 of info.usernames) {
            writer2.string(username2);
          }
        }
        return writer2.result();
      }
      function parse$1(data2) {
        if (data2.length === 0)
          return null;
        const reader2 = TlBinaryReader.manual(data2);
        if (reader2.int() !== 1)
          return null;
        const flags = reader2.int();
        const userId = reader2.int53();
        let usernames = [];
        if (flags & 2) {
          const len = reader2.int();
          usernames = new Array(len);
          for (let i = 0; i < len; i++) {
            usernames[i] = reader2.string();
          }
        }
        return {
          userId,
          isBot: (flags & 1) !== 0,
          isPremium: (flags & 4) !== 0,
          usernames
        };
      }
      class CurrentUserService extends BaseService {
        constructor(_kv, opts) {
          super(opts);
          __publicField(this, "_cached");
          this._kv = _kv;
        }
        store(info) {
          return __async(this, null, function* () {
            var _a3, _b2;
            if (info && this._cached) {
              if (this._cached.userId === info.userId) {
                return;
              }
              this._cached.userId = info.userId;
              this._cached.isBot = info.isBot;
            } else {
              this._cached = info;
            }
            yield this._kv.set(KV_CURRENT_USER, serialize(info));
            yield (_b2 = (_a3 = this._driver).save) == null ? void 0 : _b2.call(_a3);
          });
        }
        storeFrom(user) {
          return __async(this, null, function* () {
            assertTypeIs("storeFrom", user, "user");
            const obj = {
              userId: user.id,
              isBot: user.bot,
              isPremium: user.premium,
              usernames: extractUsernames(user)
            };
            yield this.store(obj);
            return obj;
          });
        }
        fetch() {
          return __async(this, null, function* () {
            if (this._cached)
              return this._cached;
            const data2 = yield this._kv.get(KV_CURRENT_USER);
            if (!data2)
              return null;
            const info = parse$1(data2);
            this._cached = info;
            return info;
          });
        }
        getCached(safe = false) {
          if (this._cached === void 0) {
            if (safe)
              return null;
            throw new MtArgumentError("User info is not cached yet");
          }
          return this._cached;
        }
        update(params) {
          return __async(this, null, function* () {
            const info = yield this.fetch();
            if (!info)
              return;
            const { username: username2, usernames, isPremium } = params;
            if (isPremium !== void 0)
              info.isPremium = isPremium;
            if (username2 !== void 0) {
              info.usernames[0] = username2;
            } else if (usernames !== void 0) {
              info.usernames = usernames;
            }
            return this.store(info);
          });
        }
      }
      exports("C", CurrentUserService);
      const KV_PTS = "updates_pts";
      const KV_QTS = "updates_qts";
      const KV_DATE = "updates_date";
      const KV_SEQ = "updates_seq";
      const KV_CHANNEL_PREFIX = "updates_channel:";
      class UpdatesStateService extends BaseService {
        constructor(_kv, opts) {
          super(opts);
          this._kv = _kv;
        }
        _getInt(key) {
          return __async(this, null, function* () {
            const val = yield this._kv.get(key);
            if (!val)
              return null;
            return dataViewFromBuffer(val).getInt32(0, true);
          });
        }
        _setInt(key, val) {
          return __async(this, null, function* () {
            const buf = new Uint8Array(4);
            dataViewFromBuffer(buf).setInt32(0, val, true);
            yield this._kv.set(key, buf);
          });
        }
        getState() {
          return __async(this, null, function* () {
            const [pts, qts, date2, seq] = yield Promise.all([
              this._getInt(KV_PTS),
              this._getInt(KV_QTS),
              this._getInt(KV_DATE),
              this._getInt(KV_SEQ)
            ]);
            if (pts === null || qts === null || date2 === null || seq === null) {
              return null;
            }
            return [pts, qts, date2, seq];
          });
        }
        setPts(pts) {
          return __async(this, null, function* () {
            yield this._setInt(KV_PTS, pts);
          });
        }
        setQts(qts) {
          return __async(this, null, function* () {
            yield this._setInt(KV_QTS, qts);
          });
        }
        setDate(date2) {
          return __async(this, null, function* () {
            yield this._setInt(KV_DATE, date2);
          });
        }
        setSeq(seq) {
          return __async(this, null, function* () {
            yield this._setInt(KV_SEQ, seq);
          });
        }
        getChannelPts(channelId) {
          return __async(this, null, function* () {
            const val = yield this._kv.get(KV_CHANNEL_PREFIX + channelId);
            if (!val)
              return null;
            return dataViewFromBuffer(val).getUint32(0, true);
          });
        }
        setChannelPts(channelId, pts) {
          return __async(this, null, function* () {
            const buf = new Uint8Array(4);
            dataViewFromBuffer(buf).setUint32(0, pts, true);
            yield this._kv.set(KV_CHANNEL_PREFIX + channelId, buf);
          });
        }
        setManyChannelPts(cpts) {
          return __async(this, null, function* () {
            const promises = [];
            for(let   [channelId, pts] of cpts.entries()) {
              promises.push(this.setChannelPts(channelId, pts));
            }
            yield Promise.all(promises);
          });
        }
      }
      exports("U", UpdatesStateService);
      const KV_MAIN = "dc_main";
      const KV_MEDIA = "dc_media";
      class DefaultDcsService extends BaseService {
        constructor(_kv, opts) {
          super(opts);
          __publicField(this, "_cached");
          this._kv = _kv;
        }
        store(dcs) {
          return __async(this, null, function* () {
            if (this._cached) {
              if (this._cached.main === dcs.main && this._cached.media === dcs.media) {
                return;
              }
            }
            this._cached = dcs;
            const { main: main2, media: media2 } = dcs;
            const mainData = serializeBasicDcOption(main2);
            yield this._kv.set(KV_MAIN, mainData);
            if (media2 !== main2) {
              const mediaData = serializeBasicDcOption(media2);
              yield this._kv.set(KV_MEDIA, mediaData);
            } else {
              yield this._kv.delete(KV_MEDIA);
            }
          });
        }
        fetch() {
          return __async(this, null, function* () {
            if (this._cached)
              return this._cached;
            const [mainData, mediaData] = yield Promise.all([
              this._kv.get(KV_MAIN),
              this._kv.get(KV_MEDIA)
            ]);
            if (!mainData)
              return null;
            const main2 = parseBasicDcOption(mainData);
            if (!main2)
              return null;
            const dcs = { main: main2, media: main2 };
            if (mediaData) {
              const media2 = parseBasicDcOption(mediaData);
              if (media2) {
                dcs.media = media2;
              }
            }
            this._cached = dcs;
            return dcs;
          });
        }
      }
      exports("j", DefaultDcsService);
      class JSBI extends Array {
        constructor(i, _) {
          if (super(i), this.sign = _, Object.setPrototypeOf(this, JSBI.prototype), i > JSBI.__kMaxLength)
            throw new RangeError("Maximum BigInt size exceeded");
        }
        static BigInt(i) {
          var _ = Math.floor, t2 = Number.isFinite;
          if ("number" == typeof i) {
            if (0 === i)
              return JSBI.__zero();
            if (JSBI.__isOneDigitInt(i))
              return 0 > i ? JSBI.__oneDigit(-i, true) : JSBI.__oneDigit(i, false);
            if (!t2(i) || _(i) !== i)
              throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
            return JSBI.__fromDouble(i);
          }
          if ("string" == typeof i) {
            const _2 = JSBI.__fromString(i);
            if (null === _2)
              throw new SyntaxError("Cannot convert " + i + " to a BigInt");
            return _2;
          }
          if ("boolean" == typeof i)
            return true === i ? JSBI.__oneDigit(1, false) : JSBI.__zero();
          if ("object" == typeof i) {
            if (i.constructor === JSBI)
              return i;
            const _2 = JSBI.__toPrimitive(i);
            return JSBI.BigInt(_2);
          }
          throw new TypeError("Cannot convert " + i + " to a BigInt");
        }
        toDebugString() {
          const i = ["BigInt["];
          for(let   _ of this)
            i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
          return i.push("]"), i.join("");
        }
        toString(i = 10) {
          if (2 > i || 36 < i)
            throw new RangeError("toString() radix argument must be between 2 and 36");
          return 0 === this.length ? "0" : 0 == (i & i - 1) ? JSBI.__toStringBasePowerOfTwo(this, i) : JSBI.__toStringGeneric(this, i, false);
        }
        valueOf() {
          throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
        }
        static toNumber(i) {
          const _ = i.length;
          if (0 === _)
            return 0;
          if (1 === _) {
            const _2 = i.__unsignedDigit(0);
            return i.sign ? -_2 : _2;
          }
          const t2 = i.__digit(_ - 1), e2 = JSBI.__clz30(t2), n2 = 30 * _ - e2;
          if (1024 < n2)
            return i.sign ? -Infinity : 1 / 0;
          let g = n2 - 1, o2 = t2, s = _ - 1;
          const l2 = e2 + 3;
          let r2 = 32 === l2 ? 0 : o2 << l2;
          r2 >>>= 12;
          const a = l2 - 12;
          let u = 12 <= l2 ? 0 : o2 << 20 + l2, d = 20 + l2;
          for (0 < a && 0 < s && (s--, o2 = i.__digit(s), r2 |= o2 >>> 30 - a, u = o2 << a + 2, d = a + 2); 0 < d && 0 < s; )
            s--, o2 = i.__digit(s), u |= 30 <= d ? o2 << d - 30 : o2 >>> 30 - d, d -= 30;
          const h2 = JSBI.__decideRounding(i, d, s, o2);
          if ((1 === h2 || 0 === h2 && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r2++, 0 != r2 >>> 20 && (r2 = 0, g++, 1023 < g))))
            return i.sign ? -Infinity : 1 / 0;
          const m2 = i.sign ? -2147483648 : 0;
          return g = g + 1023 << 20, JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] = m2 | g | r2, JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow] = u, JSBI.__kBitConversionDouble[0];
        }
        static unaryMinus(i) {
          if (0 === i.length)
            return i;
          const _ = i.__copy();
          return _.sign = !i.sign, _;
        }
        static bitwiseNot(i) {
          return i.sign ? JSBI.__absoluteSubOne(i).__trim() : JSBI.__absoluteAddOne(i, true);
        }
        static exponentiate(i, _) {
          if (_.sign)
            throw new RangeError("Exponent must be positive");
          if (0 === _.length)
            return JSBI.__oneDigit(1, false);
          if (0 === i.length)
            return i;
          if (1 === i.length && 1 === i.__digit(0))
            return i.sign && 0 == (1 & _.__digit(0)) ? JSBI.unaryMinus(i) : i;
          if (1 < _.length)
            throw new RangeError("BigInt too big");
          let t2 = _.__unsignedDigit(0);
          if (1 === t2)
            return i;
          if (t2 >= JSBI.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          if (1 === i.length && 2 === i.__digit(0)) {
            const _2 = 1 + (0 | t2 / 30), e3 = i.sign && 0 != (1 & t2), n3 = new JSBI(_2, e3);
            n3.__initializeDigits();
            const g = 1 << t2 % 30;
            return n3.__setDigit(_2 - 1, g), n3;
          }
          let e2 = null, n2 = i;
          for (0 != (1 & t2) && (e2 = i), t2 >>= 1; 0 !== t2; t2 >>= 1)
            n2 = JSBI.multiply(n2, n2), 0 != (1 & t2) && (null === e2 ? e2 = n2 : e2 = JSBI.multiply(e2, n2));
          return e2;
        }
        static multiply(_, t2) {
          if (0 === _.length)
            return _;
          if (0 === t2.length)
            return t2;
          let i = _.length + t2.length;
          30 <= _.__clzmsd() + t2.__clzmsd() && i--;
          const e2 = new JSBI(i, _.sign !== t2.sign);
          e2.__initializeDigits();
          for (let n2 = 0; n2 < _.length; n2++)
            JSBI.__multiplyAccumulate(t2, _.__digit(n2), e2, n2);
          return e2.__trim();
        }
        static divide(i, _) {
          if (0 === _.length)
            throw new RangeError("Division by zero");
          if (0 > JSBI.__absoluteCompare(i, _))
            return JSBI.__zero();
          const t2 = i.sign !== _.sign, e2 = _.__unsignedDigit(0);
          let n2;
          if (1 === _.length && 32767 >= e2) {
            if (1 === e2)
              return t2 === i.sign ? i : JSBI.unaryMinus(i);
            n2 = JSBI.__absoluteDivSmall(i, e2, null);
          } else
            n2 = JSBI.__absoluteDivLarge(i, _, true, false);
          return n2.sign = t2, n2.__trim();
        }
        static remainder(i, _) {
          if (0 === _.length)
            throw new RangeError("Division by zero");
          if (0 > JSBI.__absoluteCompare(i, _))
            return i;
          const t2 = _.__unsignedDigit(0);
          if (1 === _.length && 32767 >= t2) {
            if (1 === t2)
              return JSBI.__zero();
            const _2 = JSBI.__absoluteModSmall(i, t2);
            return 0 === _2 ? JSBI.__zero() : JSBI.__oneDigit(_2, i.sign);
          }
          const e2 = JSBI.__absoluteDivLarge(i, _, false, true);
          return e2.sign = i.sign, e2.__trim();
        }
        static add(i, _) {
          const t2 = i.sign;
          return t2 === _.sign ? JSBI.__absoluteAdd(i, _, t2) : 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t2) : JSBI.__absoluteSub(_, i, !t2);
        }
        static subtract(i, _) {
          const t2 = i.sign;
          return t2 === _.sign ? 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t2) : JSBI.__absoluteSub(_, i, !t2) : JSBI.__absoluteAdd(i, _, t2);
        }
        static leftShift(i, _) {
          return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__rightShiftByAbsolute(i, _) : JSBI.__leftShiftByAbsolute(i, _);
        }
        static signedRightShift(i, _) {
          return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__leftShiftByAbsolute(i, _) : JSBI.__rightShiftByAbsolute(i, _);
        }
        static unsignedRightShift() {
          throw new TypeError("BigInts have no unsigned right shift; use >> instead");
        }
        static lessThan(i, _) {
          return 0 > JSBI.__compareToBigInt(i, _);
        }
        static lessThanOrEqual(i, _) {
          return 0 >= JSBI.__compareToBigInt(i, _);
        }
        static greaterThan(i, _) {
          return 0 < JSBI.__compareToBigInt(i, _);
        }
        static greaterThanOrEqual(i, _) {
          return 0 <= JSBI.__compareToBigInt(i, _);
        }
        static equal(_, t2) {
          if (_.sign !== t2.sign)
            return false;
          if (_.length !== t2.length)
            return false;
          for (let e2 = 0; e2 < _.length; e2++)
            if (_.__digit(e2) !== t2.__digit(e2))
              return false;
          return true;
        }
        static notEqual(i, _) {
          return !JSBI.equal(i, _);
        }
        static bitwiseAnd(i, _) {
          var t2 = Math.max;
          if (!i.sign && !_.sign)
            return JSBI.__absoluteAnd(i, _).__trim();
          if (i.sign && _.sign) {
            const e2 = t2(i.length, _.length) + 1;
            let n2 = JSBI.__absoluteSubOne(i, e2);
            const g = JSBI.__absoluteSubOne(_);
            return n2 = JSBI.__absoluteOr(n2, g, n2), JSBI.__absoluteAddOne(n2, true, n2).__trim();
          }
          return i.sign && ([i, _] = [_, i]), JSBI.__absoluteAndNot(i, JSBI.__absoluteSubOne(_)).__trim();
        }
        static bitwiseXor(i, _) {
          var t2 = Math.max;
          if (!i.sign && !_.sign)
            return JSBI.__absoluteXor(i, _).__trim();
          if (i.sign && _.sign) {
            const e3 = t2(i.length, _.length), n3 = JSBI.__absoluteSubOne(i, e3), g = JSBI.__absoluteSubOne(_);
            return JSBI.__absoluteXor(n3, g, n3).__trim();
          }
          const e2 = t2(i.length, _.length) + 1;
          i.sign && ([i, _] = [_, i]);
          let n2 = JSBI.__absoluteSubOne(_, e2);
          return n2 = JSBI.__absoluteXor(n2, i, n2), JSBI.__absoluteAddOne(n2, true, n2).__trim();
        }
        static bitwiseOr(i, _) {
          var t2 = Math.max;
          const e2 = t2(i.length, _.length);
          if (!i.sign && !_.sign)
            return JSBI.__absoluteOr(i, _).__trim();
          if (i.sign && _.sign) {
            let t3 = JSBI.__absoluteSubOne(i, e2);
            const n3 = JSBI.__absoluteSubOne(_);
            return t3 = JSBI.__absoluteAnd(t3, n3, t3), JSBI.__absoluteAddOne(t3, true, t3).__trim();
          }
          i.sign && ([i, _] = [_, i]);
          let n2 = JSBI.__absoluteSubOne(_, e2);
          return n2 = JSBI.__absoluteAndNot(n2, i, n2), JSBI.__absoluteAddOne(n2, true, n2).__trim();
        }
        static asIntN(_, t2) {
          var i = Math.floor;
          if (0 === t2.length)
            return t2;
          if (_ = i(_), 0 > _)
            throw new RangeError("Invalid value: not (convertible to) a safe integer");
          if (0 === _)
            return JSBI.__zero();
          if (_ >= JSBI.__kMaxLengthBits)
            return t2;
          const e2 = 0 | (_ + 29) / 30;
          if (t2.length < e2)
            return t2;
          const g = t2.__unsignedDigit(e2 - 1), o2 = 1 << (_ - 1) % 30;
          if (t2.length === e2 && g < o2)
            return t2;
          if (!((g & o2) === o2))
            return JSBI.__truncateToNBits(_, t2);
          if (!t2.sign)
            return JSBI.__truncateAndSubFromPowerOfTwo(_, t2, true);
          if (0 == (g & o2 - 1)) {
            for (let n2 = e2 - 2; 0 <= n2; n2--)
              if (0 !== t2.__digit(n2))
                return JSBI.__truncateAndSubFromPowerOfTwo(_, t2, false);
            return t2.length === e2 && g === o2 ? t2 : JSBI.__truncateToNBits(_, t2);
          }
          return JSBI.__truncateAndSubFromPowerOfTwo(_, t2, false);
        }
        static asUintN(i, _) {
          var t2 = Math.floor;
          if (0 === _.length)
            return _;
          if (i = t2(i), 0 > i)
            throw new RangeError("Invalid value: not (convertible to) a safe integer");
          if (0 === i)
            return JSBI.__zero();
          if (_.sign) {
            if (i > JSBI.__kMaxLengthBits)
              throw new RangeError("BigInt too big");
            return JSBI.__truncateAndSubFromPowerOfTwo(i, _, false);
          }
          if (i >= JSBI.__kMaxLengthBits)
            return _;
          const e2 = 0 | (i + 29) / 30;
          if (_.length < e2)
            return _;
          const g = i % 30;
          if (_.length == e2) {
            if (0 === g)
              return _;
            const i2 = _.__digit(e2 - 1);
            if (0 == i2 >>> g)
              return _;
          }
          return JSBI.__truncateToNBits(i, _);
        }
        static ADD(i, _) {
          if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i)
            return "string" != typeof _ && (_ = _.toString()), i + _;
          if ("string" == typeof _)
            return i.toString() + _;
          if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i) && JSBI.__isBigInt(_))
            return JSBI.add(i, _);
          if ("number" == typeof i && "number" == typeof _)
            return i + _;
          throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
        }
        static LT(i, _) {
          return JSBI.__compare(i, _, 0);
        }
        static LE(i, _) {
          return JSBI.__compare(i, _, 1);
        }
        static GT(i, _) {
          return JSBI.__compare(i, _, 2);
        }
        static GE(i, _) {
          return JSBI.__compare(i, _, 3);
        }
        static EQ(i, _) {
          for (; ; ) {
            if (JSBI.__isBigInt(i))
              return JSBI.__isBigInt(_) ? JSBI.equal(i, _) : JSBI.EQ(_, i);
            if ("number" == typeof i) {
              if (JSBI.__isBigInt(_))
                return JSBI.__equalToNumber(_, i);
              if ("object" != typeof _)
                return i == _;
              _ = JSBI.__toPrimitive(_);
            } else if ("string" == typeof i) {
              if (JSBI.__isBigInt(_))
                return i = JSBI.__fromString(i), null !== i && JSBI.equal(i, _);
              if ("object" != typeof _)
                return i == _;
              _ = JSBI.__toPrimitive(_);
            } else if ("boolean" == typeof i) {
              if (JSBI.__isBigInt(_))
                return JSBI.__equalToNumber(_, +i);
              if ("object" != typeof _)
                return i == _;
              _ = JSBI.__toPrimitive(_);
            } else if ("symbol" == typeof i) {
              if (JSBI.__isBigInt(_))
                return false;
              if ("object" != typeof _)
                return i == _;
              _ = JSBI.__toPrimitive(_);
            } else if ("object" == typeof i) {
              if ("object" == typeof _ && _.constructor !== JSBI)
                return i == _;
              i = JSBI.__toPrimitive(i);
            } else
              return i == _;
          }
        }
        static NE(i, _) {
          return !JSBI.EQ(i, _);
        }
        static DataViewGetBigInt64(i, _, t2 = false) {
          return JSBI.asIntN(64, JSBI.DataViewGetBigUint64(i, _, t2));
        }
        static DataViewGetBigUint64(i, _, t2 = false) {
          const [e2, n2] = t2 ? [4, 0] : [0, 4], g = i.getUint32(_ + e2, t2), o2 = i.getUint32(_ + n2, t2), s = new JSBI(3, false);
          return s.__setDigit(0, 1073741823 & o2), s.__setDigit(1, (268435455 & g) << 2 | o2 >>> 30), s.__setDigit(2, g >>> 28), s.__trim();
        }
        static DataViewSetBigInt64(i, _, t2, e2 = false) {
          JSBI.DataViewSetBigUint64(i, _, t2, e2);
        }
        static DataViewSetBigUint64(i, _, t2, e2 = false) {
          t2 = JSBI.asUintN(64, t2);
          let n2 = 0, g = 0;
          if (0 < t2.length && (g = t2.__digit(0), 1 < t2.length)) {
            const i2 = t2.__digit(1);
            g |= i2 << 30, n2 = i2 >>> 2, 2 < t2.length && (n2 |= t2.__digit(2) << 28);
          }
          const [o2, s] = e2 ? [4, 0] : [0, 4];
          i.setUint32(_ + o2, n2, e2), i.setUint32(_ + s, g, e2);
        }
        static __zero() {
          return new JSBI(0, false);
        }
        static __oneDigit(i, _) {
          const t2 = new JSBI(1, _);
          return t2.__setDigit(0, i), t2;
        }
        __copy() {
          const _ = new JSBI(this.length, this.sign);
          for (let t2 = 0; t2 < this.length; t2++)
            _[t2] = this[t2];
          return _;
        }
        __trim() {
          let i = this.length, _ = this[i - 1];
          for (; 0 === _; )
            i--, _ = this[i - 1], this.pop();
          return 0 === i && (this.sign = false), this;
        }
        __initializeDigits() {
          for (let _ = 0; _ < this.length; _++)
            this[_] = 0;
        }
        static __decideRounding(i, _, t2, e2) {
          if (0 < _)
            return -1;
          let n2;
          if (0 > _)
            n2 = -_ - 1;
          else {
            if (0 === t2)
              return -1;
            t2--, e2 = i.__digit(t2), n2 = 29;
          }
          let g = 1 << n2;
          if (0 == (e2 & g))
            return -1;
          if (g -= 1, 0 != (e2 & g))
            return 1;
          for (; 0 < t2; )
            if (t2--, 0 !== i.__digit(t2))
              return 1;
          return 0;
        }
        static __fromDouble(i) {
          JSBI.__kBitConversionDouble[0] = i;
          const _ = 2047 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] >>> 20, t2 = _ - 1023, e2 = (0 | t2 / 30) + 1, n2 = new JSBI(e2, 0 > i);
          let g = 1048575 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] | 1048576, o2 = JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow];
          const s = 20, l2 = t2 % 30;
          let r2, a = 0;
          if (l2 < 20) {
            const i2 = s - l2;
            a = i2 + 32, r2 = g >>> i2, g = g << 32 - i2 | o2 >>> i2, o2 <<= 32 - i2;
          } else if (l2 === 20)
            a = 32, r2 = g, g = o2, o2 = 0;
          else {
            const i2 = l2 - s;
            a = 32 - i2, r2 = g << i2 | o2 >>> 32 - i2, g = o2 << i2, o2 = 0;
          }
          n2.__setDigit(e2 - 1, r2);
          for (let _2 = e2 - 2; 0 <= _2; _2--)
            0 < a ? (a -= 30, r2 = g >>> 2, g = g << 30 | o2 >>> 2, o2 <<= 30) : r2 = 0, n2.__setDigit(_2, r2);
          return n2.__trim();
        }
        static __isWhitespace(i) {
          return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);
        }
        static __fromString(i, _ = 0) {
          let t2 = 0;
          const e2 = i.length;
          let n2 = 0;
          if (n2 === e2)
            return JSBI.__zero();
          let g = i.charCodeAt(n2);
          for (; JSBI.__isWhitespace(g); ) {
            if (++n2 === e2)
              return JSBI.__zero();
            g = i.charCodeAt(n2);
          }
          if (43 === g) {
            if (++n2 === e2)
              return null;
            g = i.charCodeAt(n2), t2 = 1;
          } else if (45 === g) {
            if (++n2 === e2)
              return null;
            g = i.charCodeAt(n2), t2 = -1;
          }
          if (0 === _) {
            if (_ = 10, 48 === g) {
              if (++n2 === e2)
                return JSBI.__zero();
              if (g = i.charCodeAt(n2), 88 === g || 120 === g) {
                if (_ = 16, ++n2 === e2)
                  return null;
                g = i.charCodeAt(n2);
              } else if (79 === g || 111 === g) {
                if (_ = 8, ++n2 === e2)
                  return null;
                g = i.charCodeAt(n2);
              } else if (66 === g || 98 === g) {
                if (_ = 2, ++n2 === e2)
                  return null;
                g = i.charCodeAt(n2);
              }
            }
          } else if (16 === _ && 48 === g) {
            if (++n2 === e2)
              return JSBI.__zero();
            if (g = i.charCodeAt(n2), 88 === g || 120 === g) {
              if (++n2 === e2)
                return null;
              g = i.charCodeAt(n2);
            }
          }
          if (0 != t2 && 10 !== _)
            return null;
          for (; 48 === g; ) {
            if (++n2 === e2)
              return JSBI.__zero();
            g = i.charCodeAt(n2);
          }
          const o2 = e2 - n2;
          let s = JSBI.__kMaxBitsPerChar[_], l2 = JSBI.__kBitsPerCharTableMultiplier - 1;
          if (o2 > 1073741824 / s)
            return null;
          const r2 = s * o2 + l2 >>> JSBI.__kBitsPerCharTableShift, a = new JSBI(0 | (r2 + 29) / 30, false), u = 10 > _ ? _ : 10, h2 = 10 < _ ? _ - 10 : 0;
          if (0 == (_ & _ - 1)) {
            s >>= JSBI.__kBitsPerCharTableShift;
            const _2 = [], t3 = [];
            let o3 = false;
            do {
              let l3 = 0, r3 = 0;
              for (; ; ) {
                let _3;
                if (g - 48 >>> 0 < u)
                  _3 = g - 48;
                else if ((32 | g) - 97 >>> 0 < h2)
                  _3 = (32 | g) - 87;
                else {
                  o3 = true;
                  break;
                }
                if (r3 += s, l3 = l3 << s | _3, ++n2 === e2) {
                  o3 = true;
                  break;
                }
                if (g = i.charCodeAt(n2), 30 < r3 + s)
                  break;
              }
              _2.push(l3), t3.push(r3);
            } while (!o3);
            JSBI.__fillFromParts(a, _2, t3);
          } else {
            a.__initializeDigits();
            let t3 = false, o3 = 0;
            do {
              let r3 = 0, b = 1;
              for (; ; ) {
                let s2;
                if (g - 48 >>> 0 < u)
                  s2 = g - 48;
                else if ((32 | g) - 97 >>> 0 < h2)
                  s2 = (32 | g) - 87;
                else {
                  t3 = true;
                  break;
                }
                const l3 = b * _;
                if (1073741823 < l3)
                  break;
                if (b = l3, r3 = r3 * _ + s2, o3++, ++n2 === e2) {
                  t3 = true;
                  break;
                }
                g = i.charCodeAt(n2);
              }
              l2 = 30 * JSBI.__kBitsPerCharTableMultiplier - 1;
              const D = 0 | (s * o3 + l2 >>> JSBI.__kBitsPerCharTableShift) / 30;
              a.__inplaceMultiplyAdd(b, r3, D);
            } while (!t3);
          }
          if (n2 !== e2) {
            if (!JSBI.__isWhitespace(g))
              return null;
            for (n2++; n2 < e2; n2++)
              if (g = i.charCodeAt(n2), !JSBI.__isWhitespace(g))
                return null;
          }
          return a.sign = -1 == t2, a.__trim();
        }
        static __fillFromParts(_, t2, e2) {
          let n2 = 0, g = 0, o2 = 0;
          for (let s = t2.length - 1; 0 <= s; s--) {
            const i = t2[s], l2 = e2[s];
            g |= i << o2, o2 += l2, 30 === o2 ? (_.__setDigit(n2++, g), o2 = 0, g = 0) : 30 < o2 && (_.__setDigit(n2++, 1073741823 & g), o2 -= 30, g = i >>> l2 - o2);
          }
          if (0 !== g) {
            if (n2 >= _.length)
              throw new Error("implementation bug");
            _.__setDigit(n2++, g);
          }
          for (; n2 < _.length; n2++)
            _.__setDigit(n2, 0);
        }
        static __toStringBasePowerOfTwo(_, i) {
          const t2 = _.length;
          let e2 = i - 1;
          e2 = (85 & e2 >>> 1) + (85 & e2), e2 = (51 & e2 >>> 2) + (51 & e2), e2 = (15 & e2 >>> 4) + (15 & e2);
          const n2 = e2, g = i - 1, o2 = _.__digit(t2 - 1), s = JSBI.__clz30(o2);
          let l2 = 0 | (30 * t2 - s + n2 - 1) / n2;
          if (_.sign && l2++, 268435456 < l2)
            throw new Error("string too long");
          const r2 = Array(l2);
          let a = l2 - 1, u = 0, d = 0;
          for (let e3 = 0; e3 < t2 - 1; e3++) {
            const i2 = _.__digit(e3), t3 = (u | i2 << d) & g;
            r2[a--] = JSBI.__kConversionChars[t3];
            const o3 = n2 - d;
            for (u = i2 >>> o3, d = 30 - o3; d >= n2; )
              r2[a--] = JSBI.__kConversionChars[u & g], u >>>= n2, d -= n2;
          }
          const h2 = (u | o2 << d) & g;
          for (r2[a--] = JSBI.__kConversionChars[h2], u = o2 >>> n2 - d; 0 !== u; )
            r2[a--] = JSBI.__kConversionChars[u & g], u >>>= n2;
          if (_.sign && (r2[a--] = "-"), -1 != a)
            throw new Error("implementation bug");
          return r2.join("");
        }
        static __toStringGeneric(_, i, t2) {
          const e2 = _.length;
          if (0 === e2)
            return "";
          if (1 === e2) {
            let e3 = _.__unsignedDigit(0).toString(i);
            return false === t2 && _.sign && (e3 = "-" + e3), e3;
          }
          const n2 = 30 * e2 - JSBI.__clz30(_.__digit(e2 - 1)), g = JSBI.__kMaxBitsPerChar[i], o2 = g - 1;
          let s = n2 * JSBI.__kBitsPerCharTableMultiplier;
          s += o2 - 1, s = 0 | s / o2;
          const l2 = s + 1 >> 1, r2 = JSBI.exponentiate(JSBI.__oneDigit(i, false), JSBI.__oneDigit(l2, false));
          let a, u;
          const d = r2.__unsignedDigit(0);
          if (1 === r2.length && 32767 >= d) {
            a = new JSBI(_.length, false), a.__initializeDigits();
            let t3 = 0;
            for (let e3 = 2 * _.length - 1; 0 <= e3; e3--) {
              const i2 = t3 << 15 | _.__halfDigit(e3);
              a.__setHalfDigit(e3, 0 | i2 / d), t3 = 0 | i2 % d;
            }
            u = t3.toString(i);
          } else {
            const t3 = JSBI.__absoluteDivLarge(_, r2, true, true);
            a = t3.quotient;
            const e3 = t3.remainder.__trim();
            u = JSBI.__toStringGeneric(e3, i, true);
          }
          a.__trim();
          let h2 = JSBI.__toStringGeneric(a, i, true);
          for (; u.length < l2; )
            u = "0" + u;
          return false === t2 && _.sign && (h2 = "-" + h2), h2 + u;
        }
        static __unequalSign(i) {
          return i ? -1 : 1;
        }
        static __absoluteGreater(i) {
          return i ? -1 : 1;
        }
        static __absoluteLess(i) {
          return i ? 1 : -1;
        }
        static __compareToBigInt(i, _) {
          const t2 = i.sign;
          if (t2 !== _.sign)
            return JSBI.__unequalSign(t2);
          const e2 = JSBI.__absoluteCompare(i, _);
          return 0 < e2 ? JSBI.__absoluteGreater(t2) : 0 > e2 ? JSBI.__absoluteLess(t2) : 0;
        }
        static __compareToNumber(i, _) {
          if (JSBI.__isOneDigitInt(_)) {
            const t2 = i.sign, e2 = 0 > _;
            if (t2 !== e2)
              return JSBI.__unequalSign(t2);
            if (0 === i.length) {
              if (e2)
                throw new Error("implementation bug");
              return 0 === _ ? 0 : -1;
            }
            if (1 < i.length)
              return JSBI.__absoluteGreater(t2);
            const n2 = Math.abs(_), g = i.__unsignedDigit(0);
            return g > n2 ? JSBI.__absoluteGreater(t2) : g < n2 ? JSBI.__absoluteLess(t2) : 0;
          }
          return JSBI.__compareToDouble(i, _);
        }
        static __compareToDouble(i, _) {
          if (_ !== _)
            return _;
          if (_ === 1 / 0)
            return -1;
          if (_ === -Infinity)
            return 1;
          const t2 = i.sign;
          if (t2 !== 0 > _)
            return JSBI.__unequalSign(t2);
          if (0 === _)
            throw new Error("implementation bug: should be handled elsewhere");
          if (0 === i.length)
            return -1;
          JSBI.__kBitConversionDouble[0] = _;
          const e2 = 2047 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] >>> 20;
          if (2047 == e2)
            throw new Error("implementation bug: handled elsewhere");
          const n2 = e2 - 1023;
          if (0 > n2)
            return JSBI.__absoluteGreater(t2);
          const g = i.length;
          let o2 = i.__digit(g - 1);
          const s = JSBI.__clz30(o2), l2 = 30 * g - s, r2 = n2 + 1;
          if (l2 < r2)
            return JSBI.__absoluteLess(t2);
          if (l2 > r2)
            return JSBI.__absoluteGreater(t2);
          let a = 1048576 | 1048575 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh], u = JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow];
          const d = 20, h2 = 29 - s;
          if (h2 !== (0 | (l2 - 1) % 30))
            throw new Error("implementation bug");
          let m2, b = 0;
          if (20 > h2) {
            const i2 = d - h2;
            b = i2 + 32, m2 = a >>> i2, a = a << 32 - i2 | u >>> i2, u <<= 32 - i2;
          } else if (20 === h2)
            b = 32, m2 = a, a = u, u = 0;
          else {
            const i2 = h2 - d;
            b = 32 - i2, m2 = a << i2 | u >>> 32 - i2, a = u << i2, u = 0;
          }
          if (o2 >>>= 0, m2 >>>= 0, o2 > m2)
            return JSBI.__absoluteGreater(t2);
          if (o2 < m2)
            return JSBI.__absoluteLess(t2);
          for (let e3 = g - 2; 0 <= e3; e3--) {
            0 < b ? (b -= 30, m2 = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m2 = 0;
            const _2 = i.__unsignedDigit(e3);
            if (_2 > m2)
              return JSBI.__absoluteGreater(t2);
            if (_2 < m2)
              return JSBI.__absoluteLess(t2);
          }
          if (0 !== a || 0 !== u) {
            if (0 === b)
              throw new Error("implementation bug");
            return JSBI.__absoluteLess(t2);
          }
          return 0;
        }
        static __equalToNumber(i, _) {
          var t2 = Math.abs;
          return JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t2(_) : 0 === JSBI.__compareToDouble(i, _);
        }
        static __comparisonResultToBool(i, _) {
          return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;
        }
        static __compare(i, _, t2) {
          if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _)
            switch (t2) {
              case 0:
                return i < _;
              case 1:
                return i <= _;
              case 2:
                return i > _;
              case 3:
                return i >= _;
            }
          if (JSBI.__isBigInt(i) && "string" == typeof _)
            return _ = JSBI.__fromString(_), null !== _ && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t2);
          if ("string" == typeof i && JSBI.__isBigInt(_))
            return i = JSBI.__fromString(i), null !== i && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t2);
          if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i)) {
            if (JSBI.__isBigInt(_))
              return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t2);
            if ("number" != typeof _)
              throw new Error("implementation bug");
            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i, _), t2);
          }
          if ("number" != typeof i)
            throw new Error("implementation bug");
          if (JSBI.__isBigInt(_))
            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_, i), 2 ^ t2);
          if ("number" != typeof _)
            throw new Error("implementation bug");
          return 0 === t2 ? i < _ : 1 === t2 ? i <= _ : 2 === t2 ? i > _ : 3 === t2 ? i >= _ : void 0;
        }
        __clzmsd() {
          return JSBI.__clz30(this.__digit(this.length - 1));
        }
        static __absoluteAdd(_, t2, e2) {
          if (_.length < t2.length)
            return JSBI.__absoluteAdd(t2, _, e2);
          if (0 === _.length)
            return _;
          if (0 === t2.length)
            return _.sign === e2 ? _ : JSBI.unaryMinus(_);
          let n2 = _.length;
          (0 === _.__clzmsd() || t2.length === _.length && 0 === t2.__clzmsd()) && n2++;
          const g = new JSBI(n2, e2);
          let o2 = 0, s = 0;
          for (; s < t2.length; s++) {
            const i = _.__digit(s) + t2.__digit(s) + o2;
            o2 = i >>> 30, g.__setDigit(s, 1073741823 & i);
          }
          for (; s < _.length; s++) {
            const i = _.__digit(s) + o2;
            o2 = i >>> 30, g.__setDigit(s, 1073741823 & i);
          }
          return s < g.length && g.__setDigit(s, o2), g.__trim();
        }
        static __absoluteSub(_, t2, e2) {
          if (0 === _.length)
            return _;
          if (0 === t2.length)
            return _.sign === e2 ? _ : JSBI.unaryMinus(_);
          const n2 = new JSBI(_.length, e2);
          let g = 0, o2 = 0;
          for (; o2 < t2.length; o2++) {
            const i = _.__digit(o2) - t2.__digit(o2) - g;
            g = 1 & i >>> 30, n2.__setDigit(o2, 1073741823 & i);
          }
          for (; o2 < _.length; o2++) {
            const i = _.__digit(o2) - g;
            g = 1 & i >>> 30, n2.__setDigit(o2, 1073741823 & i);
          }
          return n2.__trim();
        }
        static __absoluteAddOne(_, i, t2 = null) {
          const e2 = _.length;
          null === t2 ? t2 = new JSBI(e2, i) : t2.sign = i;
          let n2 = 1;
          for (let g = 0; g < e2; g++) {
            const i2 = _.__digit(g) + n2;
            n2 = i2 >>> 30, t2.__setDigit(g, 1073741823 & i2);
          }
          return 0 != n2 && t2.__setDigitGrow(e2, 1), t2;
        }
        static __absoluteSubOne(_, t2) {
          const e2 = _.length;
          t2 = t2 || e2;
          const n2 = new JSBI(t2, false);
          let g = 1;
          for (let o2 = 0; o2 < e2; o2++) {
            const i = _.__digit(o2) - g;
            g = 1 & i >>> 30, n2.__setDigit(o2, 1073741823 & i);
          }
          if (0 != g)
            throw new Error("implementation bug");
          for (let g2 = e2; g2 < t2; g2++)
            n2.__setDigit(g2, 0);
          return n2;
        }
        static __absoluteAnd(_, t2, e2 = null) {
          let n2 = _.length, g = t2.length, o2 = g;
          if (n2 < g) {
            o2 = n2;
            const i = _, e3 = n2;
            _ = t2, n2 = g, t2 = i, g = e3;
          }
          let s = o2;
          null === e2 ? e2 = new JSBI(s, false) : s = e2.length;
          let l2 = 0;
          for (; l2 < o2; l2++)
            e2.__setDigit(l2, _.__digit(l2) & t2.__digit(l2));
          for (; l2 < s; l2++)
            e2.__setDigit(l2, 0);
          return e2;
        }
        static __absoluteAndNot(_, t2, e2 = null) {
          const n2 = _.length, g = t2.length;
          let o2 = g;
          n2 < g && (o2 = n2);
          let s = n2;
          null === e2 ? e2 = new JSBI(s, false) : s = e2.length;
          let l2 = 0;
          for (; l2 < o2; l2++)
            e2.__setDigit(l2, _.__digit(l2) & ~t2.__digit(l2));
          for (; l2 < n2; l2++)
            e2.__setDigit(l2, _.__digit(l2));
          for (; l2 < s; l2++)
            e2.__setDigit(l2, 0);
          return e2;
        }
        static __absoluteOr(_, t2, e2 = null) {
          let n2 = _.length, g = t2.length, o2 = g;
          if (n2 < g) {
            o2 = n2;
            const i = _, e3 = n2;
            _ = t2, n2 = g, t2 = i, g = e3;
          }
          let s = n2;
          null === e2 ? e2 = new JSBI(s, false) : s = e2.length;
          let l2 = 0;
          for (; l2 < o2; l2++)
            e2.__setDigit(l2, _.__digit(l2) | t2.__digit(l2));
          for (; l2 < n2; l2++)
            e2.__setDigit(l2, _.__digit(l2));
          for (; l2 < s; l2++)
            e2.__setDigit(l2, 0);
          return e2;
        }
        static __absoluteXor(_, t2, e2 = null) {
          let n2 = _.length, g = t2.length, o2 = g;
          if (n2 < g) {
            o2 = n2;
            const i = _, e3 = n2;
            _ = t2, n2 = g, t2 = i, g = e3;
          }
          let s = n2;
          null === e2 ? e2 = new JSBI(s, false) : s = e2.length;
          let l2 = 0;
          for (; l2 < o2; l2++)
            e2.__setDigit(l2, _.__digit(l2) ^ t2.__digit(l2));
          for (; l2 < n2; l2++)
            e2.__setDigit(l2, _.__digit(l2));
          for (; l2 < s; l2++)
            e2.__setDigit(l2, 0);
          return e2;
        }
        static __absoluteCompare(_, t2) {
          const e2 = _.length - t2.length;
          if (0 != e2)
            return e2;
          let n2 = _.length - 1;
          for (; 0 <= n2 && _.__digit(n2) === t2.__digit(n2); )
            n2--;
          return 0 > n2 ? 0 : _.__unsignedDigit(n2) > t2.__unsignedDigit(n2) ? 1 : -1;
        }
        static __multiplyAccumulate(_, t2, e2, n2) {
          if (0 === t2)
            return;
          const g = 32767 & t2, o2 = t2 >>> 15;
          let s = 0, l2 = 0;
          for (let r2, a = 0; a < _.length; a++, n2++) {
            r2 = e2.__digit(n2);
            const i = _.__digit(a), t3 = 32767 & i, u = i >>> 15, d = JSBI.__imul(t3, g), h2 = JSBI.__imul(t3, o2), m2 = JSBI.__imul(u, g), b = JSBI.__imul(u, o2);
            r2 += l2 + d + s, s = r2 >>> 30, r2 &= 1073741823, r2 += ((32767 & h2) << 15) + ((32767 & m2) << 15), s += r2 >>> 30, l2 = b + (h2 >>> 15) + (m2 >>> 15), e2.__setDigit(n2, 1073741823 & r2);
          }
          for (; 0 != s || 0 !== l2; n2++) {
            let i = e2.__digit(n2);
            i += s + l2, l2 = 0, s = i >>> 30, e2.__setDigit(n2, 1073741823 & i);
          }
        }
        static __internalMultiplyAdd(_, t2, e2, g, o2) {
          let s = e2, l2 = 0;
          for (let n2 = 0; n2 < g; n2++) {
            const i = _.__digit(n2), e3 = JSBI.__imul(32767 & i, t2), g2 = JSBI.__imul(i >>> 15, t2), a = e3 + ((32767 & g2) << 15) + l2 + s;
            s = a >>> 30, l2 = g2 >>> 15, o2.__setDigit(n2, 1073741823 & a);
          }
          if (o2.length > g)
            for (o2.__setDigit(g++, s + l2); g < o2.length; )
              o2.__setDigit(g++, 0);
          else if (0 !== s + l2)
            throw new Error("implementation bug");
        }
        __inplaceMultiplyAdd(i, _, t2) {
          t2 > this.length && (t2 = this.length);
          const e2 = 32767 & i, n2 = i >>> 15;
          let g = 0, o2 = _;
          for (let s = 0; s < t2; s++) {
            const i2 = this.__digit(s), _2 = 32767 & i2, t3 = i2 >>> 15, l2 = JSBI.__imul(_2, e2), r2 = JSBI.__imul(_2, n2), a = JSBI.__imul(t3, e2), u = JSBI.__imul(t3, n2);
            let d = o2 + l2 + g;
            g = d >>> 30, d &= 1073741823, d += ((32767 & r2) << 15) + ((32767 & a) << 15), g += d >>> 30, o2 = u + (r2 >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
          }
          if (0 != g || 0 !== o2)
            throw new Error("implementation bug");
        }
        static __absoluteDivSmall(_, t2, e2 = null) {
          null === e2 && (e2 = new JSBI(_.length, false));
          let n2 = 0;
          for (let g, o2 = 2 * _.length - 1; 0 <= o2; o2 -= 2) {
            g = (n2 << 15 | _.__halfDigit(o2)) >>> 0;
            const i = 0 | g / t2;
            n2 = 0 | g % t2, g = (n2 << 15 | _.__halfDigit(o2 - 1)) >>> 0;
            const s = 0 | g / t2;
            n2 = 0 | g % t2, e2.__setDigit(o2 >>> 1, i << 15 | s);
          }
          return e2;
        }
        static __absoluteModSmall(_, t2) {
          let e2 = 0;
          for (let n2 = 2 * _.length - 1; 0 <= n2; n2--) {
            const i = (e2 << 15 | _.__halfDigit(n2)) >>> 0;
            e2 = 0 | i % t2;
          }
          return e2;
        }
        static __absoluteDivLarge(i, _, t2, e2) {
          const g = _.__halfDigitLength(), n2 = _.length, o2 = i.__halfDigitLength() - g;
          let s = null;
          t2 && (s = new JSBI(o2 + 2 >>> 1, false), s.__initializeDigits());
          const l2 = new JSBI(g + 2 >>> 1, false);
          l2.__initializeDigits();
          const r2 = JSBI.__clz15(_.__halfDigit(g - 1));
          0 < r2 && (_ = JSBI.__specialLeftShift(_, r2, 0));
          const a = JSBI.__specialLeftShift(i, r2, 1), u = _.__halfDigit(g - 1);
          let d = 0;
          for (let r3, h2 = o2; 0 <= h2; h2--) {
            r3 = 32767;
            const i2 = a.__halfDigit(h2 + g);
            if (i2 !== u) {
              const t3 = (i2 << 15 | a.__halfDigit(h2 + g - 1)) >>> 0;
              r3 = 0 | t3 / u;
              let e4 = 0 | t3 % u;
              const n3 = _.__halfDigit(g - 2), o3 = a.__halfDigit(h2 + g - 2);
              for (; JSBI.__imul(r3, n3) >>> 0 > (e4 << 16 | o3) >>> 0 && (r3--, e4 += u, !(32767 < e4)); )
                ;
            }
            JSBI.__internalMultiplyAdd(_, r3, 0, n2, l2);
            let e3 = a.__inplaceSub(l2, h2, g + 1);
            0 !== e3 && (e3 = a.__inplaceAdd(_, h2, g), a.__setHalfDigit(h2 + g, 32767 & a.__halfDigit(h2 + g) + e3), r3--), t2 && (1 & h2 ? d = r3 << 15 : s.__setDigit(h2 >>> 1, d | r3));
          }
          if (e2)
            return a.__inplaceRightShift(r2), t2 ? { quotient: s, remainder: a } : a;
          if (t2)
            return s;
          throw new Error("unreachable");
        }
        static __clz15(i) {
          return JSBI.__clz30(i) - 15;
        }
        __inplaceAdd(_, t2, e2) {
          let n2 = 0;
          for (let g = 0; g < e2; g++) {
            const i = this.__halfDigit(t2 + g) + _.__halfDigit(g) + n2;
            n2 = i >>> 15, this.__setHalfDigit(t2 + g, 32767 & i);
          }
          return n2;
        }
        __inplaceSub(_, t2, e2) {
          let n2 = 0;
          if (1 & t2) {
            t2 >>= 1;
            let g = this.__digit(t2), o2 = 32767 & g, s = 0;
            for (; s < e2 - 1 >>> 1; s++) {
              const i2 = _.__digit(s), e3 = (g >>> 15) - (32767 & i2) - n2;
              n2 = 1 & e3 >>> 15, this.__setDigit(t2 + s, (32767 & e3) << 15 | 32767 & o2), g = this.__digit(t2 + s + 1), o2 = (32767 & g) - (i2 >>> 15) - n2, n2 = 1 & o2 >>> 15;
            }
            const i = _.__digit(s), l2 = (g >>> 15) - (32767 & i) - n2;
            n2 = 1 & l2 >>> 15, this.__setDigit(t2 + s, (32767 & l2) << 15 | 32767 & o2);
            if (t2 + s + 1 >= this.length)
              throw new RangeError("out of bounds");
            0 == (1 & e2) && (g = this.__digit(t2 + s + 1), o2 = (32767 & g) - (i >>> 15) - n2, n2 = 1 & o2 >>> 15, this.__setDigit(t2 + _.length, 1073709056 & g | 32767 & o2));
          } else {
            t2 >>= 1;
            let g = 0;
            for (; g < _.length - 1; g++) {
              const i2 = this.__digit(t2 + g), e3 = _.__digit(g), o3 = (32767 & i2) - (32767 & e3) - n2;
              n2 = 1 & o3 >>> 15;
              const s2 = (i2 >>> 15) - (e3 >>> 15) - n2;
              n2 = 1 & s2 >>> 15, this.__setDigit(t2 + g, (32767 & s2) << 15 | 32767 & o3);
            }
            const i = this.__digit(t2 + g), o2 = _.__digit(g), s = (32767 & i) - (32767 & o2) - n2;
            n2 = 1 & s >>> 15;
            let l2 = 0;
            0 == (1 & e2) && (l2 = (i >>> 15) - (o2 >>> 15) - n2, n2 = 1 & l2 >>> 15), this.__setDigit(t2 + g, (32767 & l2) << 15 | 32767 & s);
          }
          return n2;
        }
        __inplaceRightShift(_) {
          if (0 === _)
            return;
          let t2 = this.__digit(0) >>> _;
          const e2 = this.length - 1;
          for (let n2 = 0; n2 < e2; n2++) {
            const i = this.__digit(n2 + 1);
            this.__setDigit(n2, 1073741823 & i << 30 - _ | t2), t2 = i >>> _;
          }
          this.__setDigit(e2, t2);
        }
        static __specialLeftShift(_, t2, e2) {
          const g = _.length, n2 = new JSBI(g + e2, false);
          if (0 === t2) {
            for (let t3 = 0; t3 < g; t3++)
              n2.__setDigit(t3, _.__digit(t3));
            return 0 < e2 && n2.__setDigit(g, 0), n2;
          }
          let o2 = 0;
          for (let s = 0; s < g; s++) {
            const i = _.__digit(s);
            n2.__setDigit(s, 1073741823 & i << t2 | o2), o2 = i >>> 30 - t2;
          }
          return 0 < e2 && n2.__setDigit(g, o2), n2;
        }
        static __leftShiftByAbsolute(_, i) {
          const t2 = JSBI.__toShiftAmount(i);
          if (0 > t2)
            throw new RangeError("BigInt too big");
          const e2 = 0 | t2 / 30, n2 = t2 % 30, g = _.length, o2 = 0 !== n2 && 0 != _.__digit(g - 1) >>> 30 - n2, s = g + e2 + (o2 ? 1 : 0), l2 = new JSBI(s, _.sign);
          if (0 === n2) {
            let t3 = 0;
            for (; t3 < e2; t3++)
              l2.__setDigit(t3, 0);
            for (; t3 < s; t3++)
              l2.__setDigit(t3, _.__digit(t3 - e2));
          } else {
            let t3 = 0;
            for (let _2 = 0; _2 < e2; _2++)
              l2.__setDigit(_2, 0);
            for (let o3 = 0; o3 < g; o3++) {
              const i2 = _.__digit(o3);
              l2.__setDigit(o3 + e2, 1073741823 & i2 << n2 | t3), t3 = i2 >>> 30 - n2;
            }
            if (o2)
              l2.__setDigit(g + e2, t3);
            else if (0 !== t3)
              throw new Error("implementation bug");
          }
          return l2.__trim();
        }
        static __rightShiftByAbsolute(_, i) {
          const t2 = _.length, e2 = _.sign, n2 = JSBI.__toShiftAmount(i);
          if (0 > n2)
            return JSBI.__rightShiftByMaximum(e2);
          const g = 0 | n2 / 30, o2 = n2 % 30;
          let s = t2 - g;
          if (0 >= s)
            return JSBI.__rightShiftByMaximum(e2);
          let l2 = false;
          if (e2) {
            if (0 != (_.__digit(g) & (1 << o2) - 1))
              l2 = true;
            else
              for (let t3 = 0; t3 < g; t3++)
                if (0 !== _.__digit(t3)) {
                  l2 = true;
                  break;
                }
          }
          if (l2 && 0 === o2) {
            const i2 = _.__digit(t2 - 1);
            0 == ~i2 && s++;
          }
          let r2 = new JSBI(s, e2);
          if (0 === o2) {
            r2.__setDigit(s - 1, 0);
            for (let e3 = g; e3 < t2; e3++)
              r2.__setDigit(e3 - g, _.__digit(e3));
          } else {
            let e3 = _.__digit(g) >>> o2;
            const n3 = t2 - g - 1;
            for (let t3 = 0; t3 < n3; t3++) {
              const i2 = _.__digit(t3 + g + 1);
              r2.__setDigit(t3, 1073741823 & i2 << 30 - o2 | e3), e3 = i2 >>> o2;
            }
            r2.__setDigit(n3, e3);
          }
          return l2 && (r2 = JSBI.__absoluteAddOne(r2, true, r2)), r2.__trim();
        }
        static __rightShiftByMaximum(i) {
          return i ? JSBI.__oneDigit(1, true) : JSBI.__zero();
        }
        static __toShiftAmount(i) {
          if (1 < i.length)
            return -1;
          const _ = i.__unsignedDigit(0);
          return _ > JSBI.__kMaxLengthBits ? -1 : _;
        }
        static __toPrimitive(i, _ = "default") {
          if ("object" != typeof i)
            return i;
          if (i.constructor === JSBI)
            return i;
          if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive && i[Symbol.toPrimitive]) {
            const t3 = i[Symbol.toPrimitive](_);
            if ("object" != typeof t3)
              return t3;
            throw new TypeError("Cannot convert object to primitive value");
          }
          const t2 = i.valueOf;
          if (t2) {
            const _2 = t2.call(i);
            if ("object" != typeof _2)
              return _2;
          }
          const e2 = i.toString;
          if (e2) {
            const _2 = e2.call(i);
            if ("object" != typeof _2)
              return _2;
          }
          throw new TypeError("Cannot convert object to primitive value");
        }
        static __toNumeric(i) {
          return JSBI.__isBigInt(i) ? i : +i;
        }
        static __isBigInt(i) {
          return "object" == typeof i && null !== i && i.constructor === JSBI;
        }
        static __truncateToNBits(i, _) {
          const t2 = 0 | (i + 29) / 30, e2 = new JSBI(t2, _.sign), n2 = t2 - 1;
          for (let t3 = 0; t3 < n2; t3++)
            e2.__setDigit(t3, _.__digit(t3));
          let g = _.__digit(n2);
          if (0 != i % 30) {
            const _2 = 32 - i % 30;
            g = g << _2 >>> _2;
          }
          return e2.__setDigit(n2, g), e2.__trim();
        }
        static __truncateAndSubFromPowerOfTwo(_, t2, e2) {
          var n2 = Math.min;
          const g = 0 | (_ + 29) / 30, o2 = new JSBI(g, e2);
          let s = 0;
          const l2 = g - 1;
          let a = 0;
          for(let   i = n2(l2, t2.length); s < i; s++) {
            const i2 = 0 - t2.__digit(s) - a;
            a = 1 & i2 >>> 30, o2.__setDigit(s, 1073741823 & i2);
          }
          for (; s < l2; s++)
            o2.__setDigit(s, 0 | 1073741823 & -a);
          let u = l2 < t2.length ? t2.__digit(l2) : 0;
          const d = _ % 30;
          let h2;
          if (0 == d)
            h2 = 0 - u - a, h2 &= 1073741823;
          else {
            const i = 32 - d;
            u = u << i >>> i;
            const _2 = 1 << 32 - i;
            h2 = _2 - u - a, h2 &= _2 - 1;
          }
          return o2.__setDigit(l2, h2), o2.__trim();
        }
        __digit(_) {
          return this[_];
        }
        __unsignedDigit(_) {
          return this[_] >>> 0;
        }
        __setDigit(_, i) {
          this[_] = 0 | i;
        }
        __setDigitGrow(_, i) {
          this[_] = 0 | i;
        }
        __halfDigitLength() {
          const i = this.length;
          return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
        }
        __halfDigit(_) {
          return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
        }
        __setHalfDigit(_, i) {
          const t2 = _ >>> 1, e2 = this.__digit(t2), n2 = 1 & _ ? 32767 & e2 | i << 15 : 1073709056 & e2 | 32767 & i;
          this.__setDigit(t2, n2);
        }
        static __digitPow(i, _) {
          let t2 = 1;
          for (; 0 < _; )
            1 & _ && (t2 *= i), _ >>>= 1, i *= i;
          return t2;
        }
        static __detectBigEndian() {
          return JSBI.__kBitConversionDouble[0] = -0, 0 !== JSBI.__kBitConversionInts[0];
        }
        static __isOneDigitInt(i) {
          return (1073741823 & i) === i;
        }
      }
      exports("e1", JSBI);
      JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionIntHigh = JSBI.__detectBigEndian() ? 0 : 1, JSBI.__kBitConversionIntLow = JSBI.__detectBigEndian() ? 1 : 0, JSBI.__clz30 = Math.clz32 ? function(i) {
        return Math.clz32(i) - 2;
      } : function(i) {
        return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
      }, JSBI.__imul = Math.imul || function(i, _) {
        return 0 | i * _;
      };
      var jsbn = { exports: {} };
      (function(module2, exports2) {
        (function() {
          var dbits;
          var canary = 244837814094590;
          var j_lm = (canary & 16777215) == 15715070;
          function BigInteger(a, b, c) {
            if (a != null)
              if ("number" == typeof a)
                this.fromNumber(a, b, c);
              else if (b == null && "string" != typeof a)
                this.fromString(a, 256);
              else
                this.fromString(a, b);
          }
          function nbi() {
            return new BigInteger(null);
          }
          function am1(i, x, w, j, c, n2) {
            while (--n2 >= 0) {
              var v = x * this[i++] + w[j] + c;
              c = Math.floor(v / 67108864);
              w[j++] = v & 67108863;
            }
            return c;
          }
          function am2(i, x, w, j, c, n2) {
            var xl = x & 32767, xh = x >> 15;
            while (--n2 >= 0) {
              var l2 = this[i] & 32767;
              var h2 = this[i++] >> 15;
              var m2 = xh * l2 + h2 * xl;
              l2 = xl * l2 + ((m2 & 32767) << 15) + w[j] + (c & 1073741823);
              c = (l2 >>> 30) + (m2 >>> 15) + xh * h2 + (c >>> 30);
              w[j++] = l2 & 1073741823;
            }
            return c;
          }
          function am3(i, x, w, j, c, n2) {
            var xl = x & 16383, xh = x >> 14;
            while (--n2 >= 0) {
              var l2 = this[i] & 16383;
              var h2 = this[i++] >> 14;
              var m2 = xh * l2 + h2 * xl;
              l2 = xl * l2 + ((m2 & 16383) << 14) + w[j] + c;
              c = (l2 >> 28) + (m2 >> 14) + xh * h2;
              w[j++] = l2 & 268435455;
            }
            return c;
          }
          var inBrowser = typeof navigator !== "undefined";
          if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
            BigInteger.prototype.am = am2;
            dbits = 30;
          } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
            BigInteger.prototype.am = am1;
            dbits = 26;
          } else {
            BigInteger.prototype.am = am3;
            dbits = 28;
          }
          BigInteger.prototype.DB = dbits;
          BigInteger.prototype.DM = (1 << dbits) - 1;
          BigInteger.prototype.DV = 1 << dbits;
          var BI_FP = 52;
          BigInteger.prototype.FV = Math.pow(2, BI_FP);
          BigInteger.prototype.F1 = BI_FP - dbits;
          BigInteger.prototype.F2 = 2 * dbits - BI_FP;
          var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
          var BI_RC = new Array();
          var rr, vv;
          rr = "0".charCodeAt(0);
          for (vv = 0; vv <= 9; ++vv)
            BI_RC[rr++] = vv;
          rr = "a".charCodeAt(0);
          for (vv = 10; vv < 36; ++vv)
            BI_RC[rr++] = vv;
          rr = "A".charCodeAt(0);
          for (vv = 10; vv < 36; ++vv)
            BI_RC[rr++] = vv;
          function int2char(n2) {
            return BI_RM.charAt(n2);
          }
          function intAt(s, i) {
            var c = BI_RC[s.charCodeAt(i)];
            return c == null ? -1 : c;
          }
          function bnpCopyTo(r2) {
            for (var i = this.t - 1; i >= 0; --i)
              r2[i] = this[i];
            r2.t = this.t;
            r2.s = this.s;
          }
          function bnpFromInt(x) {
            this.t = 1;
            this.s = x < 0 ? -1 : 0;
            if (x > 0)
              this[0] = x;
            else if (x < -1)
              this[0] = x + this.DV;
            else
              this.t = 0;
          }
          function nbv(i) {
            var r2 = nbi();
            r2.fromInt(i);
            return r2;
          }
          function bnpFromString(s, b) {
            var k;
            if (b == 16)
              k = 4;
            else if (b == 8)
              k = 3;
            else if (b == 256)
              k = 8;
            else if (b == 2)
              k = 1;
            else if (b == 32)
              k = 5;
            else if (b == 4)
              k = 2;
            else {
              this.fromRadix(s, b);
              return;
            }
            this.t = 0;
            this.s = 0;
            var i = s.length, mi = false, sh = 0;
            while (--i >= 0) {
              var x = k == 8 ? s[i] & 255 : intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == "-")
                  mi = true;
                continue;
              }
              mi = false;
              if (sh == 0)
                this[this.t++] = x;
              else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
                this[this.t++] = x >> this.DB - sh;
              } else
                this[this.t - 1] |= x << sh;
              sh += k;
              if (sh >= this.DB)
                sh -= this.DB;
            }
            if (k == 8 && (s[0] & 128) != 0) {
              this.s = -1;
              if (sh > 0)
                this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
            }
            this.clamp();
            if (mi)
              BigInteger.ZERO.subTo(this, this);
          }
          function bnpClamp() {
            var c = this.s & this.DM;
            while (this.t > 0 && this[this.t - 1] == c)
              --this.t;
          }
          function bnToString(b) {
            if (this.s < 0)
              return "-" + this.negate().toString(b);
            var k;
            if (b == 16)
              k = 4;
            else if (b == 8)
              k = 3;
            else if (b == 2)
              k = 1;
            else if (b == 32)
              k = 5;
            else if (b == 4)
              k = 2;
            else
              return this.toRadix(b);
            var km = (1 << k) - 1, d, m2 = false, r2 = "", i = this.t;
            var p = this.DB - i * this.DB % k;
            if (i-- > 0) {
              if (p < this.DB && (d = this[i] >> p) > 0) {
                m2 = true;
                r2 = int2char(d);
              }
              while (i >= 0) {
                if (p < k) {
                  d = (this[i] & (1 << p) - 1) << k - p;
                  d |= this[--i] >> (p += this.DB - k);
                } else {
                  d = this[i] >> (p -= k) & km;
                  if (p <= 0) {
                    p += this.DB;
                    --i;
                  }
                }
                if (d > 0)
                  m2 = true;
                if (m2)
                  r2 += int2char(d);
              }
            }
            return m2 ? r2 : "0";
          }
          function bnNegate() {
            var r2 = nbi();
            BigInteger.ZERO.subTo(this, r2);
            return r2;
          }
          function bnAbs() {
            return this.s < 0 ? this.negate() : this;
          }
          function bnCompareTo(a) {
            var r2 = this.s - a.s;
            if (r2 != 0)
              return r2;
            var i = this.t;
            r2 = i - a.t;
            if (r2 != 0)
              return this.s < 0 ? -r2 : r2;
            while (--i >= 0)
              if ((r2 = this[i] - a[i]) != 0)
                return r2;
            return 0;
          }
          function nbits(x) {
            var r2 = 1, t3;
            if ((t3 = x >>> 16) != 0) {
              x = t3;
              r2 += 16;
            }
            if ((t3 = x >> 8) != 0) {
              x = t3;
              r2 += 8;
            }
            if ((t3 = x >> 4) != 0) {
              x = t3;
              r2 += 4;
            }
            if ((t3 = x >> 2) != 0) {
              x = t3;
              r2 += 2;
            }
            if ((t3 = x >> 1) != 0) {
              x = t3;
              r2 += 1;
            }
            return r2;
          }
          function bnBitLength() {
            if (this.t <= 0)
              return 0;
            return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
          }
          function bnpDLShiftTo(n2, r2) {
            var i;
            for (i = this.t - 1; i >= 0; --i)
              r2[i + n2] = this[i];
            for (i = n2 - 1; i >= 0; --i)
              r2[i] = 0;
            r2.t = this.t + n2;
            r2.s = this.s;
          }
          function bnpDRShiftTo(n2, r2) {
            for (var i = n2; i < this.t; ++i)
              r2[i - n2] = this[i];
            r2.t = Math.max(this.t - n2, 0);
            r2.s = this.s;
          }
          function bnpLShiftTo(n2, r2) {
            var bs = n2 % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << cbs) - 1;
            var ds = Math.floor(n2 / this.DB), c = this.s << bs & this.DM, i;
            for (i = this.t - 1; i >= 0; --i) {
              r2[i + ds + 1] = this[i] >> cbs | c;
              c = (this[i] & bm) << bs;
            }
            for (i = ds - 1; i >= 0; --i)
              r2[i] = 0;
            r2[ds] = c;
            r2.t = this.t + ds + 1;
            r2.s = this.s;
            r2.clamp();
          }
          function bnpRShiftTo(n2, r2) {
            r2.s = this.s;
            var ds = Math.floor(n2 / this.DB);
            if (ds >= this.t) {
              r2.t = 0;
              return;
            }
            var bs = n2 % this.DB;
            var cbs = this.DB - bs;
            var bm = (1 << bs) - 1;
            r2[0] = this[ds] >> bs;
            for (var i = ds + 1; i < this.t; ++i) {
              r2[i - ds - 1] |= (this[i] & bm) << cbs;
              r2[i - ds] = this[i] >> bs;
            }
            if (bs > 0)
              r2[this.t - ds - 1] |= (this.s & bm) << cbs;
            r2.t = this.t - ds;
            r2.clamp();
          }
          function bnpSubTo(a, r2) {
            var i = 0, c = 0, m2 = Math.min(a.t, this.t);
            while (i < m2) {
              c += this[i] - a[i];
              r2[i++] = c & this.DM;
              c >>= this.DB;
            }
            if (a.t < this.t) {
              c -= a.s;
              while (i < this.t) {
                c += this[i];
                r2[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += this.s;
            } else {
              c += this.s;
              while (i < a.t) {
                c -= a[i];
                r2[i++] = c & this.DM;
                c >>= this.DB;
              }
              c -= a.s;
            }
            r2.s = c < 0 ? -1 : 0;
            if (c < -1)
              r2[i++] = this.DV + c;
            else if (c > 0)
              r2[i++] = c;
            r2.t = i;
            r2.clamp();
          }
          function bnpMultiplyTo(a, r2) {
            var x = this.abs(), y = a.abs();
            var i = x.t;
            r2.t = i + y.t;
            while (--i >= 0)
              r2[i] = 0;
            for (i = 0; i < y.t; ++i)
              r2[i + x.t] = x.am(0, y[i], r2, i, 0, x.t);
            r2.s = 0;
            r2.clamp();
            if (this.s != a.s)
              BigInteger.ZERO.subTo(r2, r2);
          }
          function bnpSquareTo(r2) {
            var x = this.abs();
            var i = r2.t = 2 * x.t;
            while (--i >= 0)
              r2[i] = 0;
            for (i = 0; i < x.t - 1; ++i) {
              var c = x.am(i, x[i], r2, 2 * i, 0, 1);
              if ((r2[i + x.t] += x.am(i + 1, 2 * x[i], r2, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r2[i + x.t] -= x.DV;
                r2[i + x.t + 1] = 1;
              }
            }
            if (r2.t > 0)
              r2[r2.t - 1] += x.am(i, x[i], r2, 2 * i, 0, 1);
            r2.s = 0;
            r2.clamp();
          }
          function bnpDivRemTo(m2, q, r2) {
            var pm = m2.abs();
            if (pm.t <= 0)
              return;
            var pt = this.abs();
            if (pt.t < pm.t) {
              if (q != null)
                q.fromInt(0);
              if (r2 != null)
                this.copyTo(r2);
              return;
            }
            if (r2 == null)
              r2 = nbi();
            var y = nbi(), ts = this.s, ms = m2.s;
            var nsh = this.DB - nbits(pm[pm.t - 1]);
            if (nsh > 0) {
              pm.lShiftTo(nsh, y);
              pt.lShiftTo(nsh, r2);
            } else {
              pm.copyTo(y);
              pt.copyTo(r2);
            }
            var ys = y.t;
            var y0 = y[ys - 1];
            if (y0 == 0)
              return;
            var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
            var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e2 = 1 << this.F2;
            var i = r2.t, j = i - ys, t3 = q == null ? nbi() : q;
            y.dlShiftTo(j, t3);
            if (r2.compareTo(t3) >= 0) {
              r2[r2.t++] = 1;
              r2.subTo(t3, r2);
            }
            BigInteger.ONE.dlShiftTo(ys, t3);
            t3.subTo(y, y);
            while (y.t < ys)
              y[y.t++] = 0;
            while (--j >= 0) {
              var qd = r2[--i] == y0 ? this.DM : Math.floor(r2[i] * d1 + (r2[i - 1] + e2) * d2);
              if ((r2[i] += y.am(0, qd, r2, j, 0, ys)) < qd) {
                y.dlShiftTo(j, t3);
                r2.subTo(t3, r2);
                while (r2[i] < --qd)
                  r2.subTo(t3, r2);
              }
            }
            if (q != null) {
              r2.drShiftTo(ys, q);
              if (ts != ms)
                BigInteger.ZERO.subTo(q, q);
            }
            r2.t = ys;
            r2.clamp();
            if (nsh > 0)
              r2.rShiftTo(nsh, r2);
            if (ts < 0)
              BigInteger.ZERO.subTo(r2, r2);
          }
          function bnMod(a) {
            var r2 = nbi();
            this.abs().divRemTo(a, null, r2);
            if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
              a.subTo(r2, r2);
            return r2;
          }
          function Classic(m2) {
            this.m = m2;
          }
          function cConvert(x) {
            if (x.s < 0 || x.compareTo(this.m) >= 0)
              return x.mod(this.m);
            else
              return x;
          }
          function cRevert(x) {
            return x;
          }
          function cReduce(x) {
            x.divRemTo(this.m, null, x);
          }
          function cMulTo(x, y, r2) {
            x.multiplyTo(y, r2);
            this.reduce(r2);
          }
          function cSqrTo(x, r2) {
            x.squareTo(r2);
            this.reduce(r2);
          }
          Classic.prototype.convert = cConvert;
          Classic.prototype.revert = cRevert;
          Classic.prototype.reduce = cReduce;
          Classic.prototype.mulTo = cMulTo;
          Classic.prototype.sqrTo = cSqrTo;
          function bnpInvDigit() {
            if (this.t < 1)
              return 0;
            var x = this[0];
            if ((x & 1) == 0)
              return 0;
            var y = x & 3;
            y = y * (2 - (x & 15) * y) & 15;
            y = y * (2 - (x & 255) * y) & 255;
            y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
            y = y * (2 - x * y % this.DV) % this.DV;
            return y > 0 ? this.DV - y : -y;
          }
          function Montgomery(m2) {
            this.m = m2;
            this.mp = m2.invDigit();
            this.mpl = this.mp & 32767;
            this.mph = this.mp >> 15;
            this.um = (1 << m2.DB - 15) - 1;
            this.mt2 = 2 * m2.t;
          }
          function montConvert(x) {
            var r2 = nbi();
            x.abs().dlShiftTo(this.m.t, r2);
            r2.divRemTo(this.m, null, r2);
            if (x.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
              this.m.subTo(r2, r2);
            return r2;
          }
          function montRevert(x) {
            var r2 = nbi();
            x.copyTo(r2);
            this.reduce(r2);
            return r2;
          }
          function montReduce(x) {
            while (x.t <= this.mt2)
              x[x.t++] = 0;
            for (var i = 0; i < this.m.t; ++i) {
              var j = x[i] & 32767;
              var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
              j = i + this.m.t;
              x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
              while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
              }
            }
            x.clamp();
            x.drShiftTo(this.m.t, x);
            if (x.compareTo(this.m) >= 0)
              x.subTo(this.m, x);
          }
          function montSqrTo(x, r2) {
            x.squareTo(r2);
            this.reduce(r2);
          }
          function montMulTo(x, y, r2) {
            x.multiplyTo(y, r2);
            this.reduce(r2);
          }
          Montgomery.prototype.convert = montConvert;
          Montgomery.prototype.revert = montRevert;
          Montgomery.prototype.reduce = montReduce;
          Montgomery.prototype.mulTo = montMulTo;
          Montgomery.prototype.sqrTo = montSqrTo;
          function bnpIsEven() {
            return (this.t > 0 ? this[0] & 1 : this.s) == 0;
          }
          function bnpExp(e2, z2) {
            if (e2 > 4294967295 || e2 < 1)
              return BigInteger.ONE;
            var r2 = nbi(), r22 = nbi(), g = z2.convert(this), i = nbits(e2) - 1;
            g.copyTo(r2);
            while (--i >= 0) {
              z2.sqrTo(r2, r22);
              if ((e2 & 1 << i) > 0)
                z2.mulTo(r22, g, r2);
              else {
                var t3 = r2;
                r2 = r22;
                r22 = t3;
              }
            }
            return z2.revert(r2);
          }
          function bnModPowInt(e2, m2) {
            var z2;
            if (e2 < 256 || m2.isEven())
              z2 = new Classic(m2);
            else
              z2 = new Montgomery(m2);
            return this.exp(e2, z2);
          }
          BigInteger.prototype.copyTo = bnpCopyTo;
          BigInteger.prototype.fromInt = bnpFromInt;
          BigInteger.prototype.fromString = bnpFromString;
          BigInteger.prototype.clamp = bnpClamp;
          BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
          BigInteger.prototype.drShiftTo = bnpDRShiftTo;
          BigInteger.prototype.lShiftTo = bnpLShiftTo;
          BigInteger.prototype.rShiftTo = bnpRShiftTo;
          BigInteger.prototype.subTo = bnpSubTo;
          BigInteger.prototype.multiplyTo = bnpMultiplyTo;
          BigInteger.prototype.squareTo = bnpSquareTo;
          BigInteger.prototype.divRemTo = bnpDivRemTo;
          BigInteger.prototype.invDigit = bnpInvDigit;
          BigInteger.prototype.isEven = bnpIsEven;
          BigInteger.prototype.exp = bnpExp;
          BigInteger.prototype.toString = bnToString;
          BigInteger.prototype.negate = bnNegate;
          BigInteger.prototype.abs = bnAbs;
          BigInteger.prototype.compareTo = bnCompareTo;
          BigInteger.prototype.bitLength = bnBitLength;
          BigInteger.prototype.mod = bnMod;
          BigInteger.prototype.modPowInt = bnModPowInt;
          BigInteger.ZERO = nbv(0);
          BigInteger.ONE = nbv(1);
          function bnClone() {
            var r2 = nbi();
            this.copyTo(r2);
            return r2;
          }
          function bnIntValue() {
            if (this.s < 0) {
              if (this.t == 1)
                return this[0] - this.DV;
              else if (this.t == 0)
                return -1;
            } else if (this.t == 1)
              return this[0];
            else if (this.t == 0)
              return 0;
            return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
          }
          function bnByteValue() {
            return this.t == 0 ? this.s : this[0] << 24 >> 24;
          }
          function bnShortValue() {
            return this.t == 0 ? this.s : this[0] << 16 >> 16;
          }
          function bnpChunkSize(r2) {
            return Math.floor(Math.LN2 * this.DB / Math.log(r2));
          }
          function bnSigNum() {
            if (this.s < 0)
              return -1;
            else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
              return 0;
            else
              return 1;
          }
          function bnpToRadix(b) {
            if (b == null)
              b = 10;
            if (this.signum() == 0 || b < 2 || b > 36)
              return "0";
            var cs = this.chunkSize(b);
            var a = Math.pow(b, cs);
            var d = nbv(a), y = nbi(), z2 = nbi(), r2 = "";
            this.divRemTo(d, y, z2);
            while (y.signum() > 0) {
              r2 = (a + z2.intValue()).toString(b).substr(1) + r2;
              y.divRemTo(d, y, z2);
            }
            return z2.intValue().toString(b) + r2;
          }
          function bnpFromRadix(s, b) {
            this.fromInt(0);
            if (b == null)
              b = 10;
            var cs = this.chunkSize(b);
            var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
            for (var i = 0; i < s.length; ++i) {
              var x = intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0)
                  mi = true;
                continue;
              }
              w = b * w + x;
              if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
              }
            }
            if (j > 0) {
              this.dMultiply(Math.pow(b, j));
              this.dAddOffset(w, 0);
            }
            if (mi)
              BigInteger.ZERO.subTo(this, this);
          }
          function bnpFromNumber(a, b, c) {
            if ("number" == typeof b) {
              if (a < 2)
                this.fromInt(1);
              else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1))
                  this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                if (this.isEven())
                  this.dAddOffset(1, 0);
                while (!this.isProbablePrime(b)) {
                  this.dAddOffset(2, 0);
                  if (this.bitLength() > a)
                    this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                }
              }
            } else {
              var x = new Array(), t3 = a & 7;
              x.length = (a >> 3) + 1;
              b.nextBytes(x);
              if (t3 > 0)
                x[0] &= (1 << t3) - 1;
              else
                x[0] = 0;
              this.fromString(x, 256);
            }
          }
          function bnToByteArray() {
            var i = this.t, r2 = new Array();
            r2[0] = this.s;
            var p = this.DB - i * this.DB % 8, d, k = 0;
            if (i-- > 0) {
              if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
                r2[k++] = d | this.s << this.DB - p;
              while (i >= 0) {
                if (p < 8) {
                  d = (this[i] & (1 << p) - 1) << 8 - p;
                  d |= this[--i] >> (p += this.DB - 8);
                } else {
                  d = this[i] >> (p -= 8) & 255;
                  if (p <= 0) {
                    p += this.DB;
                    --i;
                  }
                }
                if ((d & 128) != 0)
                  d |= -256;
                if (k == 0 && (this.s & 128) != (d & 128))
                  ++k;
                if (k > 0 || d != this.s)
                  r2[k++] = d;
              }
            }
            return r2;
          }
          function bnEquals(a) {
            return this.compareTo(a) == 0;
          }
          function bnMin(a) {
            return this.compareTo(a) < 0 ? this : a;
          }
          function bnMax(a) {
            return this.compareTo(a) > 0 ? this : a;
          }
          function bnpBitwiseTo(a, op, r2) {
            var i, f, m2 = Math.min(a.t, this.t);
            for (i = 0; i < m2; ++i)
              r2[i] = op(this[i], a[i]);
            if (a.t < this.t) {
              f = a.s & this.DM;
              for (i = m2; i < this.t; ++i)
                r2[i] = op(this[i], f);
              r2.t = this.t;
            } else {
              f = this.s & this.DM;
              for (i = m2; i < a.t; ++i)
                r2[i] = op(f, a[i]);
              r2.t = a.t;
            }
            r2.s = op(this.s, a.s);
            r2.clamp();
          }
          function op_and(x, y) {
            return x & y;
          }
          function bnAnd(a) {
            var r2 = nbi();
            this.bitwiseTo(a, op_and, r2);
            return r2;
          }
          function op_or(x, y) {
            return x | y;
          }
          function bnOr(a) {
            var r2 = nbi();
            this.bitwiseTo(a, op_or, r2);
            return r2;
          }
          function op_xor(x, y) {
            return x ^ y;
          }
          function bnXor(a) {
            var r2 = nbi();
            this.bitwiseTo(a, op_xor, r2);
            return r2;
          }
          function op_andnot(x, y) {
            return x & ~y;
          }
          function bnAndNot(a) {
            var r2 = nbi();
            this.bitwiseTo(a, op_andnot, r2);
            return r2;
          }
          function bnNot() {
            var r2 = nbi();
            for (var i = 0; i < this.t; ++i)
              r2[i] = this.DM & ~this[i];
            r2.t = this.t;
            r2.s = ~this.s;
            return r2;
          }
          function bnShiftLeft(n2) {
            var r2 = nbi();
            if (n2 < 0)
              this.rShiftTo(-n2, r2);
            else
              this.lShiftTo(n2, r2);
            return r2;
          }
          function bnShiftRight(n2) {
            var r2 = nbi();
            if (n2 < 0)
              this.lShiftTo(-n2, r2);
            else
              this.rShiftTo(n2, r2);
            return r2;
          }
          function lbit(x) {
            if (x == 0)
              return -1;
            var r2 = 0;
            if ((x & 65535) == 0) {
              x >>= 16;
              r2 += 16;
            }
            if ((x & 255) == 0) {
              x >>= 8;
              r2 += 8;
            }
            if ((x & 15) == 0) {
              x >>= 4;
              r2 += 4;
            }
            if ((x & 3) == 0) {
              x >>= 2;
              r2 += 2;
            }
            if ((x & 1) == 0)
              ++r2;
            return r2;
          }
          function bnGetLowestSetBit() {
            for (var i = 0; i < this.t; ++i)
              if (this[i] != 0)
                return i * this.DB + lbit(this[i]);
            if (this.s < 0)
              return this.t * this.DB;
            return -1;
          }
          function cbit(x) {
            var r2 = 0;
            while (x != 0) {
              x &= x - 1;
              ++r2;
            }
            return r2;
          }
          function bnBitCount() {
            var r2 = 0, x = this.s & this.DM;
            for (var i = 0; i < this.t; ++i)
              r2 += cbit(this[i] ^ x);
            return r2;
          }
          function bnTestBit(n2) {
            var j = Math.floor(n2 / this.DB);
            if (j >= this.t)
              return this.s != 0;
            return (this[j] & 1 << n2 % this.DB) != 0;
          }
          function bnpChangeBit(n2, op) {
            var r2 = BigInteger.ONE.shiftLeft(n2);
            this.bitwiseTo(r2, op, r2);
            return r2;
          }
          function bnSetBit(n2) {
            return this.changeBit(n2, op_or);
          }
          function bnClearBit(n2) {
            return this.changeBit(n2, op_andnot);
          }
          function bnFlipBit(n2) {
            return this.changeBit(n2, op_xor);
          }
          function bnpAddTo(a, r2) {
            var i = 0, c = 0, m2 = Math.min(a.t, this.t);
            while (i < m2) {
              c += this[i] + a[i];
              r2[i++] = c & this.DM;
              c >>= this.DB;
            }
            if (a.t < this.t) {
              c += a.s;
              while (i < this.t) {
                c += this[i];
                r2[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += this.s;
            } else {
              c += this.s;
              while (i < a.t) {
                c += a[i];
                r2[i++] = c & this.DM;
                c >>= this.DB;
              }
              c += a.s;
            }
            r2.s = c < 0 ? -1 : 0;
            if (c > 0)
              r2[i++] = c;
            else if (c < -1)
              r2[i++] = this.DV + c;
            r2.t = i;
            r2.clamp();
          }
          function bnAdd(a) {
            var r2 = nbi();
            this.addTo(a, r2);
            return r2;
          }
          function bnSubtract(a) {
            var r2 = nbi();
            this.subTo(a, r2);
            return r2;
          }
          function bnMultiply(a) {
            var r2 = nbi();
            this.multiplyTo(a, r2);
            return r2;
          }
          function bnSquare() {
            var r2 = nbi();
            this.squareTo(r2);
            return r2;
          }
          function bnDivide(a) {
            var r2 = nbi();
            this.divRemTo(a, r2, null);
            return r2;
          }
          function bnRemainder(a) {
            var r2 = nbi();
            this.divRemTo(a, null, r2);
            return r2;
          }
          function bnDivideAndRemainder(a) {
            var q = nbi(), r2 = nbi();
            this.divRemTo(a, q, r2);
            return new Array(q, r2);
          }
          function bnpDMultiply(n2) {
            this[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
            ++this.t;
            this.clamp();
          }
          function bnpDAddOffset(n2, w) {
            if (n2 == 0)
              return;
            while (this.t <= w)
              this[this.t++] = 0;
            this[w] += n2;
            while (this[w] >= this.DV) {
              this[w] -= this.DV;
              if (++w >= this.t)
                this[this.t++] = 0;
              ++this[w];
            }
          }
          function NullExp() {
          }
          function nNop(x) {
            return x;
          }
          function nMulTo(x, y, r2) {
            x.multiplyTo(y, r2);
          }
          function nSqrTo(x, r2) {
            x.squareTo(r2);
          }
          NullExp.prototype.convert = nNop;
          NullExp.prototype.revert = nNop;
          NullExp.prototype.mulTo = nMulTo;
          NullExp.prototype.sqrTo = nSqrTo;
          function bnPow(e2) {
            return this.exp(e2, new NullExp());
          }
          function bnpMultiplyLowerTo(a, n2, r2) {
            var i = Math.min(this.t + a.t, n2);
            r2.s = 0;
            r2.t = i;
            while (i > 0)
              r2[--i] = 0;
            var j;
            for (j = r2.t - this.t; i < j; ++i)
              r2[i + this.t] = this.am(0, a[i], r2, i, 0, this.t);
            for (j = Math.min(a.t, n2); i < j; ++i)
              this.am(0, a[i], r2, i, 0, n2 - i);
            r2.clamp();
          }
          function bnpMultiplyUpperTo(a, n2, r2) {
            --n2;
            var i = r2.t = this.t + a.t - n2;
            r2.s = 0;
            while (--i >= 0)
              r2[i] = 0;
            for (i = Math.max(n2 - this.t, 0); i < a.t; ++i)
              r2[this.t + i - n2] = this.am(n2 - i, a[i], r2, 0, 0, this.t + i - n2);
            r2.clamp();
            r2.drShiftTo(1, r2);
          }
          function Barrett(m2) {
            this.r2 = nbi();
            this.q3 = nbi();
            BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
            this.mu = this.r2.divide(m2);
            this.m = m2;
          }
          function barrettConvert(x) {
            if (x.s < 0 || x.t > 2 * this.m.t)
              return x.mod(this.m);
            else if (x.compareTo(this.m) < 0)
              return x;
            else {
              var r2 = nbi();
              x.copyTo(r2);
              this.reduce(r2);
              return r2;
            }
          }
          function barrettRevert(x) {
            return x;
          }
          function barrettReduce(x) {
            x.drShiftTo(this.m.t - 1, this.r2);
            if (x.t > this.m.t + 1) {
              x.t = this.m.t + 1;
              x.clamp();
            }
            this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
            this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
            while (x.compareTo(this.r2) < 0)
              x.dAddOffset(1, this.m.t + 1);
            x.subTo(this.r2, x);
            while (x.compareTo(this.m) >= 0)
              x.subTo(this.m, x);
          }
          function barrettSqrTo(x, r2) {
            x.squareTo(r2);
            this.reduce(r2);
          }
          function barrettMulTo(x, y, r2) {
            x.multiplyTo(y, r2);
            this.reduce(r2);
          }
          Barrett.prototype.convert = barrettConvert;
          Barrett.prototype.revert = barrettRevert;
          Barrett.prototype.reduce = barrettReduce;
          Barrett.prototype.mulTo = barrettMulTo;
          Barrett.prototype.sqrTo = barrettSqrTo;
          function bnModPow(e2, m2) {
            var i = e2.bitLength(), k, r2 = nbv(1), z2;
            if (i <= 0)
              return r2;
            else if (i < 18)
              k = 1;
            else if (i < 48)
              k = 3;
            else if (i < 144)
              k = 4;
            else if (i < 768)
              k = 5;
            else
              k = 6;
            if (i < 8)
              z2 = new Classic(m2);
            else if (m2.isEven())
              z2 = new Barrett(m2);
            else
              z2 = new Montgomery(m2);
            var g = new Array(), n2 = 3, k1 = k - 1, km = (1 << k) - 1;
            g[1] = z2.convert(this);
            if (k > 1) {
              var g2 = nbi();
              z2.sqrTo(g[1], g2);
              while (n2 <= km) {
                g[n2] = nbi();
                z2.mulTo(g2, g[n2 - 2], g[n2]);
                n2 += 2;
              }
            }
            var j = e2.t - 1, w, is1 = true, r22 = nbi(), t3;
            i = nbits(e2[j]) - 1;
            while (j >= 0) {
              if (i >= k1)
                w = e2[j] >> i - k1 & km;
              else {
                w = (e2[j] & (1 << i + 1) - 1) << k1 - i;
                if (j > 0)
                  w |= e2[j - 1] >> this.DB + i - k1;
              }
              n2 = k;
              while ((w & 1) == 0) {
                w >>= 1;
                --n2;
              }
              if ((i -= n2) < 0) {
                i += this.DB;
                --j;
              }
              if (is1) {
                g[w].copyTo(r2);
                is1 = false;
              } else {
                while (n2 > 1) {
                  z2.sqrTo(r2, r22);
                  z2.sqrTo(r22, r2);
                  n2 -= 2;
                }
                if (n2 > 0)
                  z2.sqrTo(r2, r22);
                else {
                  t3 = r2;
                  r2 = r22;
                  r22 = t3;
                }
                z2.mulTo(r22, g[w], r2);
              }
              while (j >= 0 && (e2[j] & 1 << i) == 0) {
                z2.sqrTo(r2, r22);
                t3 = r2;
                r2 = r22;
                r22 = t3;
                if (--i < 0) {
                  i = this.DB - 1;
                  --j;
                }
              }
            }
            return z2.revert(r2);
          }
          function bnGCD(a) {
            var x = this.s < 0 ? this.negate() : this.clone();
            var y = a.s < 0 ? a.negate() : a.clone();
            if (x.compareTo(y) < 0) {
              var t3 = x;
              x = y;
              y = t3;
            }
            var i = x.getLowestSetBit(), g = y.getLowestSetBit();
            if (g < 0)
              return x;
            if (i < g)
              g = i;
            if (g > 0) {
              x.rShiftTo(g, x);
              y.rShiftTo(g, y);
            }
            while (x.signum() > 0) {
              if ((i = x.getLowestSetBit()) > 0)
                x.rShiftTo(i, x);
              if ((i = y.getLowestSetBit()) > 0)
                y.rShiftTo(i, y);
              if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
              } else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
              }
            }
            if (g > 0)
              y.lShiftTo(g, y);
            return y;
          }
          function bnpModInt(n2) {
            if (n2 <= 0)
              return 0;
            var d = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
            if (this.t > 0)
              if (d == 0)
                r2 = this[0] % n2;
              else
                for (var i = this.t - 1; i >= 0; --i)
                  r2 = (d * r2 + this[i]) % n2;
            return r2;
          }
          function bnModInverse(m2) {
            var ac = m2.isEven();
            if (this.isEven() && ac || m2.signum() == 0)
              return BigInteger.ZERO;
            var u = m2.clone(), v = this.clone();
            var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
            while (u.signum() != 0) {
              while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                  if (!a.isEven() || !b.isEven()) {
                    a.addTo(this, a);
                    b.subTo(m2, b);
                  }
                  a.rShiftTo(1, a);
                } else if (!b.isEven())
                  b.subTo(m2, b);
                b.rShiftTo(1, b);
              }
              while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                  if (!c.isEven() || !d.isEven()) {
                    c.addTo(this, c);
                    d.subTo(m2, d);
                  }
                  c.rShiftTo(1, c);
                } else if (!d.isEven())
                  d.subTo(m2, d);
                d.rShiftTo(1, d);
              }
              if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac)
                  a.subTo(c, a);
                b.subTo(d, b);
              } else {
                v.subTo(u, v);
                if (ac)
                  c.subTo(a, c);
                d.subTo(b, d);
              }
            }
            if (v.compareTo(BigInteger.ONE) != 0)
              return BigInteger.ZERO;
            if (d.compareTo(m2) >= 0)
              return d.subtract(m2);
            if (d.signum() < 0)
              d.addTo(m2, d);
            else
              return d;
            if (d.signum() < 0)
              return d.add(m2);
            else
              return d;
          }
          var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
          var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
          function bnIsProbablePrime(t3) {
            var i, x = this.abs();
            if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
              for (i = 0; i < lowprimes.length; ++i)
                if (x[0] == lowprimes[i])
                  return true;
              return false;
            }
            if (x.isEven())
              return false;
            i = 1;
            while (i < lowprimes.length) {
              var m2 = lowprimes[i], j = i + 1;
              while (j < lowprimes.length && m2 < lplim)
                m2 *= lowprimes[j++];
              m2 = x.modInt(m2);
              while (i < j)
                if (m2 % lowprimes[i++] == 0)
                  return false;
            }
            return x.millerRabin(t3);
          }
          function bnpMillerRabin(t3) {
            var n1 = this.subtract(BigInteger.ONE);
            var k = n1.getLowestSetBit();
            if (k <= 0)
              return false;
            var r2 = n1.shiftRight(k);
            t3 = t3 + 1 >> 1;
            if (t3 > lowprimes.length)
              t3 = lowprimes.length;
            var a = nbi();
            for (var i = 0; i < t3; ++i) {
              a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
              var y = a.modPow(r2, this);
              if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                  y = y.modPowInt(2, this);
                  if (y.compareTo(BigInteger.ONE) == 0)
                    return false;
                }
                if (y.compareTo(n1) != 0)
                  return false;
              }
            }
            return true;
          }
          BigInteger.prototype.chunkSize = bnpChunkSize;
          BigInteger.prototype.toRadix = bnpToRadix;
          BigInteger.prototype.fromRadix = bnpFromRadix;
          BigInteger.prototype.fromNumber = bnpFromNumber;
          BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
          BigInteger.prototype.changeBit = bnpChangeBit;
          BigInteger.prototype.addTo = bnpAddTo;
          BigInteger.prototype.dMultiply = bnpDMultiply;
          BigInteger.prototype.dAddOffset = bnpDAddOffset;
          BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
          BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
          BigInteger.prototype.modInt = bnpModInt;
          BigInteger.prototype.millerRabin = bnpMillerRabin;
          BigInteger.prototype.clone = bnClone;
          BigInteger.prototype.intValue = bnIntValue;
          BigInteger.prototype.byteValue = bnByteValue;
          BigInteger.prototype.shortValue = bnShortValue;
          BigInteger.prototype.signum = bnSigNum;
          BigInteger.prototype.toByteArray = bnToByteArray;
          BigInteger.prototype.equals = bnEquals;
          BigInteger.prototype.min = bnMin;
          BigInteger.prototype.max = bnMax;
          BigInteger.prototype.and = bnAnd;
          BigInteger.prototype.or = bnOr;
          BigInteger.prototype.xor = bnXor;
          BigInteger.prototype.andNot = bnAndNot;
          BigInteger.prototype.not = bnNot;
          BigInteger.prototype.shiftLeft = bnShiftLeft;
          BigInteger.prototype.shiftRight = bnShiftRight;
          BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
          BigInteger.prototype.bitCount = bnBitCount;
          BigInteger.prototype.testBit = bnTestBit;
          BigInteger.prototype.setBit = bnSetBit;
          BigInteger.prototype.clearBit = bnClearBit;
          BigInteger.prototype.flipBit = bnFlipBit;
          BigInteger.prototype.add = bnAdd;
          BigInteger.prototype.subtract = bnSubtract;
          BigInteger.prototype.multiply = bnMultiply;
          BigInteger.prototype.divide = bnDivide;
          BigInteger.prototype.remainder = bnRemainder;
          BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
          BigInteger.prototype.modPow = bnModPow;
          BigInteger.prototype.modInverse = bnModInverse;
          BigInteger.prototype.pow = bnPow;
          BigInteger.prototype.gcd = bnGCD;
          BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
          BigInteger.prototype.square = bnSquare;
          BigInteger.prototype.Barrett = Barrett;
          var rng_state;
          var rng_pool;
          var rng_pptr;
          function rng_seed_int(x) {
            rng_pool[rng_pptr++] ^= x & 255;
            rng_pool[rng_pptr++] ^= x >> 8 & 255;
            rng_pool[rng_pptr++] ^= x >> 16 & 255;
            rng_pool[rng_pptr++] ^= x >> 24 & 255;
            if (rng_pptr >= rng_psize)
              rng_pptr -= rng_psize;
          }
          function rng_seed_time() {
            rng_seed_int((/* @__PURE__ */ new Date()).getTime());
          }
          if (rng_pool == null) {
            rng_pool = new Array();
            rng_pptr = 0;
            var t2;
            if (typeof window !== "undefined" && window.crypto) {
              if (window.crypto.getRandomValues) {
                var ua = new Uint8Array(32);
                window.crypto.getRandomValues(ua);
                for (t2 = 0; t2 < 32; ++t2)
                  rng_pool[rng_pptr++] = ua[t2];
              } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
                var z = window.crypto.random(32);
                for (t2 = 0; t2 < z.length; ++t2)
                  rng_pool[rng_pptr++] = z.charCodeAt(t2) & 255;
              }
            }
            while (rng_pptr < rng_psize) {
              t2 = Math.floor(65536 * Math.random());
              rng_pool[rng_pptr++] = t2 >>> 8;
              rng_pool[rng_pptr++] = t2 & 255;
            }
            rng_pptr = 0;
            rng_seed_time();
          }
          function rng_get_byte() {
            if (rng_state == null) {
              rng_seed_time();
              rng_state = prng_newstate();
              rng_state.init(rng_pool);
              for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
                rng_pool[rng_pptr] = 0;
              rng_pptr = 0;
            }
            return rng_state.next();
          }
          function rng_get_bytes(ba) {
            var i;
            for (i = 0; i < ba.length; ++i)
              ba[i] = rng_get_byte();
          }
          function SecureRandom() {
          }
          SecureRandom.prototype.nextBytes = rng_get_bytes;
          function Arcfour() {
            this.i = 0;
            this.j = 0;
            this.S = new Array();
          }
          function ARC4init(key) {
            var i, j, t3;
            for (i = 0; i < 256; ++i)
              this.S[i] = i;
            j = 0;
            for (i = 0; i < 256; ++i) {
              j = j + this.S[i] + key[i % key.length] & 255;
              t3 = this.S[i];
              this.S[i] = this.S[j];
              this.S[j] = t3;
            }
            this.i = 0;
            this.j = 0;
          }
          function ARC4next() {
            var t3;
            this.i = this.i + 1 & 255;
            this.j = this.j + this.S[this.i] & 255;
            t3 = this.S[this.i];
            this.S[this.i] = this.S[this.j];
            this.S[this.j] = t3;
            return this.S[t3 + this.S[this.i] & 255];
          }
          Arcfour.prototype.init = ARC4init;
          Arcfour.prototype.next = ARC4next;
          function prng_newstate() {
            return new Arcfour();
          }
          var rng_psize = 256;
          {
            module2.exports = {
              default: BigInteger,
              BigInteger,
              SecureRandom
            };
          }
        }).call(commonjsGlobal);
      })(jsbn);
      var jsbnExports = jsbn.exports;
      const ZERO = exports("Z", JSBI.BigInt(0));
      const ONE = exports("O", JSBI.BigInt(1));
      const TWO = exports("T", JSBI.BigInt(2));
      function bigIntBitLength(n2) {
        const i = (n2.toString(16).length - 1) * 4;
        return i + 32 - Math.clz32(JSBI.toNumber(JSBI.signedRightShift(n2, JSBI.BigInt(i))));
      }
      function bigIntToBuffer(value, length = 0, le = false) {
        const bits = bigIntBitLength(value);
        const bytes = Math.ceil(bits / 8);
        if (length !== 0 && bytes > length) {
          throw new Error("Value out of bounds");
        }
        if (length === 0)
          length = bytes;
        const buf = new ArrayBuffer(length);
        const u8 = new Uint8Array(buf);
        const unaligned = length % 8;
        const dv = new DataView(buf, 0, length - unaligned);
        for (let i = 0; i < dv.byteLength; i += 8) {
          JSBI.DataViewSetBigUint64(dv, i, JSBI.bitwiseAnd(value, JSBI.BigInt("0xFFFFFFFFFFFFFFFF")), true);
          value = JSBI.signedRightShift(value, JSBI.BigInt(64));
        }
        if (unaligned > 0) {
          for (let i = length - unaligned; i < length; i++) {
            u8[i] = JSBI.toNumber(JSBI.bitwiseAnd(value, JSBI.BigInt("0xFF")));
            value = JSBI.signedRightShift(value, JSBI.BigInt(8));
          }
        }
        if (!le)
          u8.reverse();
        return u8;
      }
      function bufferToBigInt(buffer, le = false) {
        if (le)
          buffer = bufferToReversed(buffer);
        const unaligned = buffer.length % 8;
        const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength - unaligned);
        let res = ZERO;
        for (let i = 0; i < dv.byteLength; i += 8) {
          res = JSBI.bitwiseOr(JSBI.leftShift(res, JSBI.BigInt(64)), JSBI.DataViewGetBigUint64(dv, i, false));
        }
        if (unaligned > 0) {
          for (let i = buffer.length - unaligned; i < buffer.length; i++) {
            res = JSBI.bitwiseOr(JSBI.leftShift(res, JSBI.BigInt(8)), JSBI.BigInt(buffer[i]));
          }
        }
        return res;
      }
      function randomBigInt(crypto, size2) {
        return bufferToBigInt(crypto.randomBytes(size2));
      }
      function randomBigIntBits(crypto, bits) {
        let num2 = randomBigInt(crypto, Math.ceil(bits / 8));
        const bitLength = bigIntBitLength(num2);
        if (bitLength > bits) {
          const toTrim = bitLength - bits;
          num2 = JSBI.signedRightShift(num2, JSBI.BigInt(toTrim));
        }
        return num2;
      }
      function randomBigIntInRange(crypto, max2, min2 = JSBI.BigInt(1)) {
        const interval = JSBI.subtract(max2, min2);
        if (JSBI.lessThan(interval, ZERO))
          throw new Error("expected min < max");
        const byteSize = Math.ceil(bigIntBitLength(interval) / 8);
        let result = randomBigInt(crypto, byteSize);
        while (JSBI.greaterThan(result, interval))
          result = JSBI.subtract(result, interval);
        return JSBI.add(min2, result);
      }
      function twoMultiplicity(n2) {
        if (JSBI.equal(n2, ZERO))
          return ZERO;
        let m2 = ZERO;
        let pow = ONE;
        while (true) {
          if (JSBI.notEqual(JSBI.bitwiseAnd(n2, pow), ZERO))
            return m2;
          m2 = JSBI.add(m2, ONE);
          pow = JSBI.leftShift(pow, ONE);
        }
      }
      function bigIntMin(a, b) {
        return JSBI.lessThan(a, b) ? a : b;
      }
      function bigIntAbs(a) {
        return JSBI.lessThan(a, ZERO) ? JSBI.unaryMinus(a) : a;
      }
      function bigIntGcd(a, b) {
        while (JSBI.notEqual(b, ZERO)) {
          const t2 = b;
          b = JSBI.remainder(a, b);
          a = t2;
        }
        return a;
      }
      const native = typeof BigInt !== "undefined";
      function bigIntModPow(_base, _exp, _mod) {
        if (native) {
          _base = JSBI.remainder(_base, _mod);
          let result = ONE;
          while (JSBI.greaterThan(_exp, ONE)) {
            if (JSBI.equal(JSBI.remainder(_exp, TWO), ONE)) {
              result = JSBI.remainder(JSBI.multiply(result, _base), _mod);
            }
            _exp = JSBI.signedRightShift(_exp, ONE);
            _base = JSBI.remainder(JSBI.exponentiate(_base, TWO), _mod);
          }
          return result;
        } else {
          const base = new jsbnExports.BigInteger(_base.toString(16), 16);
          const exp = new jsbnExports.BigInteger(_exp.toString(16), 16);
          const mod = new jsbnExports.BigInteger(_mod.toString(16), 16);
          const result = base.modPow(exp, mod);
          const final = JSBI.BigInt(`0x${result.toString(16)}`);
          return final;
        }
      }
      function eGcd(a, b) {
        let x = ZERO;
        let y = ONE;
        let u = ONE;
        let v = ZERO;
        while (JSBI.notEqual(a, ZERO)) {
          const q = JSBI.divide(b, a);
          const r2 = JSBI.remainder(b, a);
          const m2 = JSBI.subtract(x, JSBI.multiply(u, q));
          const n2 = JSBI.subtract(y, JSBI.multiply(v, q));
          b = a;
          a = r2;
          x = u;
          y = v;
          u = m2;
          v = n2;
        }
        return [b, x, y];
      }
      function toZn(a, n2) {
        if (typeof a === "number")
          a = JSBI.BigInt(a);
        if (typeof n2 === "number")
          n2 = JSBI.BigInt(n2);
        if (JSBI.lessThanOrEqual(n2, ZERO)) {
          throw new RangeError("n must be > 0");
        }
        const aZn = JSBI.remainder(a, n2);
        return JSBI.lessThan(aZn, ZERO) ? JSBI.add(aZn, n2) : aZn;
      }
      function bigIntModInv(a, n2) {
        const [g, x] = eGcd(toZn(a, n2), n2);
        if (JSBI.notEqual(g, ONE)) {
          throw new RangeError(`${a.toString()} does not have inverse modulo ${n2.toString()}`);
        } else {
          return toZn(x, n2);
        }
      }
      function composeMiddlewares(middlewares, final) {
        middlewares = middlewares.slice();
        middlewares.push(final);
        function dispatch(i, ctx) {
          const fn = middlewares[i];
          if (!fn)
            return final(ctx);
          return fn(ctx, boundDispatches[i + 1]);
        }
        const boundDispatches = [];
        for (let i = 0; i < middlewares.length; i++) {
          boundDispatches.push(dispatch.bind(null, i));
        }
        return function(context) {
          return boundDispatches[0](context);
        };
      }
      class ConditionVariable {
        constructor() {
          __publicField(this, "_notify");
          __publicField(this, "_timeout");
        }
        wait(timeout) {
          const prom = new Promise((resolve) => {
            this._notify = resolve;
          });
          if (timeout) {
            this._timeout = setTimeoutWrap(() => {
              var _a3;
              (_a3 = this._notify) == null ? void 0 : _a3.call(this);
              this._timeout = void 0;
            }, timeout);
          }
          return prom;
        }
        notify() {
          var _a3;
          (_a3 = this._notify) == null ? void 0 : _a3.call(this);
          if (this._timeout)
            clearTimeoutWrap(this._timeout);
          this._notify = void 0;
        }
      }
      exports("l", ConditionVariable);
      function createControllablePromise() {
        let _resolve;
        let _reject;
        const promise = new Promise((resolve, reject) => {
          _resolve = resolve;
          _reject = reject;
        });
        promise.resolve = _resolve;
        promise.reject = _reject;
        return promise;
      }
      var rsaKeys = {};
      Object.defineProperty(rsaKeys, "__esModule", { value: true });
      var __publicKeyIndex = rsaKeys.__publicKeyIndex = JSON.parse('{"b25898df208d2603":{"modulus":"c8c11d635691fac091dd9489aedced2932aa8a0bcefef05fa800892d9b52ed03200865c9e97211cb2ee6c7ae96d3fb0e15aeffd66019b44a08a240cfdd2868a85e1f54d6fa5deaa041f6941ddf302690d61dc476385c2fa655142353cb4e4b59f6e5b6584db76fe8b1370263246c010c93d011014113ebdf987d093f9d37c2be48352d69a1683f8f6e6c2167983c761e3ab169fde5daaa12123fa1beab621e4da5935e9c198f82f35eae583a99386d8110ea6bd1abb0f568759f62694419ea5f69847c43462abef858b4cb5edc84e7b9226cd7bd7e183aa974a712c079dde85b9dc063b8a5c08e8f859c0ee5dcd824c7807f20153361a7f63cfd2a433a1be7f5","exponent":"010001","fingerprint":"b25898df208d2603","old":false},"d09d1d85de64fd85":{"modulus":"e8bb3305c0b52c6cf2afdf7637313489e63e05268e5badb601af417786472e5f93b85438968e20e6729a301c0afc121bf7151f834436f7fda680847a66bf64accec78ee21c0b316f0edafe2f41908da7bd1f4a5107638eeb67040ace472a14f90d9f7c2b7def99688ba3073adb5750bb02964902a359fe745d8170e36876d4fd8a5d41b2a76cbff9a13267eb9580b2d06d10357448d20d9da2191cb5d8c93982961cdfdeda629e37f1fb09a0722027696032fe61ed663db7a37f6f263d370f69db53a0dc0a1748bdaaff6209d5645485e6e001d1953255757e4b8e42813347b11da6ab500fd0ace7e6dfa3736199ccaf9397ed0745a427dcfa6cd67bcb1acff3","exponent":"010001","fingerprint":"d09d1d85de64fd85","old":false},"0bc35f3509f7b7a5":{"modulus":"aeec36c8ffc109cb099624685b97815415657bd76d8c9c3e398103d7ad16c9bba6f525ed0412d7ae2c2de2b44e77d72cbf4b7438709a4e646a05c43427c7f184debf72947519680e651500890c6832796dd11f772c25ff8f576755afe055b0a3752c696eb7d8da0d8be1faf38c9bdd97ce0a77d3916230c4032167100edd0f9e7a3a9b602d04367b689536af0d64b613ccba7962939d3b57682beb6dae5b608130b2e52aca78ba023cf6ce806b1dc49c72cf928a7199d22e3d7ac84e47bc9427d0236945d10dbd15177bab413fbf0edfda09f014c7a7da088dde9759702ca760af2b8e4e97cc055c617bd74c3d97008635b98dc4d621b4891da9fb0473047927","exponent":"010001","fingerprint":"0bc35f3509f7b7a5","old":true},"15ae5fa8b5529542":{"modulus":"bdf2c77d81f6afd47bd30f29ac76e55adfe70e487e5e48297e5a9055c9c07d2b93b4ed3994d3eca5098bf18d978d54f8b7c713eb10247607e69af9ef44f38e28f8b439f257a11572945cc0406fe3f37bb92b79112db69eedf2dc71584a661638ea5becb9e23585074b80d57d9f5710dd30d2da940e0ada2f1b878397dc1a72b5ce2531b6f7dd158e09c828d03450ca0ff8a174deacebcaa22dde84ef66ad370f259d18af806638012da0ca4a70baa83d9c158f3552bc9158e69bf332a45809e1c36905a5caa12348dd57941a482131be7b2355a5f4635374f3bd3ddf5ff925bf4809ee27c1e67d9120c5fe08a9de458b1b4a3c5d0a428437f2beca81f4e2d5ff","exponent":"010001","fingerprint":"15ae5fa8b5529542","old":true},"aeae98e13cd7f94f":{"modulus":"b3f762b739be98f343eb1921cf0148cfa27ff7af02b6471213fed9daa0098976e667750324f1abcea4c31e43b7d11f1579133f2b3d9fe27474e462058884e5e1b123be9cbbc6a443b2925c08520e7325e6f1a6d50e117eb61ea49d2534c8bb4d2ae4153fabe832b9edf4c5755fdd8b19940b81d1d96cf433d19e6a22968a85dc80f0312f596bd2530c1cfb28b5fe019ac9bc25cd9c2a5d8a0f3a1c0c79bcca524d315b5e21b5c26b46babe3d75d06d1cd33329ec782a0f22891ed1db42a1d6c0dea431428bc4d7aabdcf3e0eb6fda4e23eb7733e7727e9a1915580796c55188d2596d2665ad1182ba7abf15aaa5a8b779ea996317a20ae044b820bff35b6e8a1","exponent":"010001","fingerprint":"aeae98e13cd7f94f","old":true},"5a181b2235057d98":{"modulus":"be6a71558ee577ff03023cfa17aab4e6c86383cff8a7ad38edb9fafe6f323f2d5106cbc8cafb83b869cffd1ccf121cd743d509e589e68765c96601e813dc5b9dfc4be415c7a6526132d0035ca33d6d6075d4f535122a1cdfe017041f1088d1419f65c8e5490ee613e16dbf662698c0f54870f0475fa893fc41eb55b08ff1ac211bc045ded31be27d12c96d8d3cfc6a7ae8aa50bf2ee0f30ed507cc2581e3dec56de94f5dc0a7abee0be990b893f2887bd2c6310a1e0a9e3e38bd34fded2541508dc102a9c9b4c95effd9dd2dfe96c29be647d6c69d66ca500843cfaed6e440196f1dbe0e2e22163c61ca48c79116fa77216726749a976a1c4b0944b5121e8c01","exponent":"010001","fingerprint":"5a181b2235057d98","old":true},"c3b42b026ce86b21":{"modulus":"c150023e2f70db7985ded064759cfecf0af328e69a41daf4d6f01b538135a6f91f8f8b2a0ec9ba9720ce352efcf6c5680ffc424bd634864902de0b4bd6d49f4e580230e3ae97d95c8b19442b3c0a10d8f5633fecedd6926a7f6dab0ddb7d457f9ea81b8465fcd6fffeed114011df91c059caedaf97625f6c96ecc74725556934ef781d866b34f011fce4d835a090196e9a5f0e4449af7eb697ddb9076494ca5f81104a305b6dd27665722c46b60e5df680fb16b210607ef217652e60236c255f6a28315f4083a96791d7214bf64c1df4fd0db1944fb26a2a57031b32eee64ad15a8ba68885cde74a5bfc920f6abf59ba5c75506373e7130f9042da922179251f","exponent":"010001","fingerprint":"c3b42b026ce86b21","old":true},"9a996a1db11c729b":{"modulus":"c6aeda78b02a251db4b6441031f467fa871faed32526c436524b1fb3b5dca28efb8c089dd1b46d92c895993d87108254951c5f001a0f055f3063dcd14d431a300eb9e29517e359a1c9537e5e87ab1b116faecf5d17546ebc21db234d9d336a693efcb2b6fbcca1e7d1a0be414dca408a11609b9c4269a920b09fed1f9a1597be02761430f09e4bc48fcafbe289054c99dba51b6b5eb7d9c3a2ab4e490545b4676bd620e93804bcac93bf94f73f92c729ca899477ff17625ef14a934d51dc11d5f8650a3364586b3a52fcff2fedec8a8406cac4e751705a472e55707e3c8cd5594342b119c6c3293532d85dbe9271ed54a2fd18b4dc79c04a30951107d5639397","exponent":"010001","fingerprint":"9a996a1db11c729b","old":true},"b05b2a6f70cdea78":{"modulus":"b1066749655935f0a5936f517034c943bea7f3365a8931ae52c8bcb14856f004b83d26cf2839be0f22607470d67481771c1ce5ec31de16b20bbaa4ecd2f7d2ecf6b6356f27501c226984263edc046b89fb6d3981546b01d7bd34fedcfcc1058e2d494bda732ff813e50e1c6ae249890b225f82b22b1e55fcb063dc3c0e18e91c28d0c4aa627dec8353eee6038a95a4fd1ca984eb09f94aeb7a2220635a8ceb450ea7e61d915cdb4eecedaa083aa3801daf071855ec1fb38516cb6c2996d2d60c0ecbcfa57e4cf1fb0ed39b2f37e94ab4202ecf595e167b3ca62669a6da520859fb6d6c6203dfdfc79c75ec3ee97da8774b2da903e3435f2cd294670a75a526c1","exponent":"010001","fingerprint":"b05b2a6f70cdea78","old":true},"71e025b6c76033e3":{"modulus":"c2a8c55b4a62e2b78a19b91cf692bcdc4ba7c23fe4d06f194e2a0c30f6d9996f7d1a2bcc89bc1ac4333d44359a6c433252d1a8402d9970378b5912b75bc8cc3fa76710a025bcb9032df0b87d7607cc53b928712a174ea2a80a8176623588119d42ffce40205c6d72160860d8d80b22a8b8651907cf388effbef29cd7cf2b4eb8a872052da1351cfe7fec214ce48304ea472bd66329d60115b3420d08f6894b0410b6ab9450249967617670c932f7cbdb5d6fbcce1e492c595f483109999b2661fcdeec31b196429b7834c7211a93c6789d9ee601c18c39e521fda9d7264e61e518add6f0712d2d5228204b851e13c4f322e5c5431c3b7f31089668486aadc59f","exponent":"010001","fingerprint":"71e025b6c76033e3","old":true}}');
      function parsePemContents(pem) {
        return getPlatform().base64Decode(pem.replace(/^-----(?:BEGIN|END)(?: RSA)? PUBLIC KEY-----$|\n/gm, ""));
      }
      const ELOOPN = 102;
      const ELOOP = `iterated over ${ELOOPN} elements (probably a malformed file)`;
      const EDEEPN = 60;
      const EDEEP = `element nested over ${EDEEPN} layers deep (probably a malformed file)`;
      const CTYPES = {
        48: true,
        49: true,
        160: true,
        161: true
      };
      const VTYPES = {
        1: true,
        2: true,
        5: true,
        6: true,
        12: true,
        130: true
      };
      function parseAsn1(data2) {
        function parseAsn1Inner(buf, depth, eager = false) {
          if (depth.length >= EDEEPN) {
            throw new Error(EDEEP);
          }
          let index = 2;
          const asn12 = { type: buf[0], lengthSize: 0, length: buf[1] };
          let child;
          let iters = 0;
          let adjust = 0;
          let adjustedLen = 0;
          if (128 & asn12.length) {
            asn12.lengthSize = 127 & asn12.length;
            asn12.length = Number.parseInt(getPlatform().hexEncode(buf.subarray(index, index + asn12.lengthSize)), 16);
            index += asn12.lengthSize;
          }
          if (buf[index] === 0 && (asn12.type === 2 || asn12.type === 3)) {
            if (asn12.length > 1) {
              index += 1;
              adjust = -1;
            }
          }
          adjustedLen = asn12.length + adjust;
          function parseChildren(eager2 = false) {
            asn12.children = [];
            while (iters < ELOOPN && index < 2 + asn12.length + asn12.lengthSize) {
              iters += 1;
              depth.length += 1;
              child = parseAsn1Inner(buf.subarray(index, index + adjustedLen), depth, eager2);
              depth.length -= 1;
              index += 2 + child.lengthSize + child.length;
              if (index > 2 + asn12.lengthSize + asn12.length) {
                throw new Error(
                  `Parse error: child value length (${child.length}) is greater than remaining parent length (${asn12.length - index} = ${asn12.length} - ${index})`
                );
              }
              asn12.children.push(child);
            }
            if (index !== 2 + asn12.lengthSize + asn12.length) {
              throw new Error("Unexpected EOF");
            }
            if (iters >= ELOOPN) {
              throw new Error(ELOOP);
            }
            delete asn12.value;
            return asn12;
          }
          if (CTYPES[asn12.type]) {
            return parseChildren(eager);
          }
          asn12.value = buf.subarray(index, index + adjustedLen);
          if (VTYPES[asn12.type]) {
            return asn12;
          }
          try {
            return parseChildren(true);
          } catch (e2) {
            if (asn12.children)
              asn12.children.length = 0;
            return asn12;
          }
        }
        const asn1 = parseAsn1Inner(data2, []);
        const len = data2.length;
        if (len !== 2 + asn1.lengthSize + asn1.length) {
          throw new Error("Length of buffer does not match length of ASN.1 sequence.");
        }
        return asn1;
      }
      function parsePublicKey(crypto, key, old = false) {
        var _a3, _b2;
        const asn1 = parseAsn1(parsePemContents(key));
        const modulus = (_a3 = asn1.children) == null ? void 0 : _a3[0].value;
        const exponent = (_b2 = asn1.children) == null ? void 0 : _b2[1].value;
        if (!modulus || !exponent)
          throw new Error("Invalid public key");
        const writer2 = TlBinaryWriter.manual(512);
        writer2.bytes(modulus);
        writer2.bytes(exponent);
        const platform2 = getPlatform();
        const data2 = writer2.result();
        const sha = crypto.sha1(data2);
        const fp = platform2.hexEncode(sha.slice(-8).reverse());
        return {
          modulus: platform2.hexEncode(modulus),
          exponent: platform2.hexEncode(exponent),
          fingerprint: fp,
          old
        };
      }
      function addPublicKey(crypto, key, old = false) {
        const parsed = parsePublicKey(crypto, key, old);
        __publicKeyIndex[parsed.fingerprint] = parsed;
      }
      function findKeyByFingerprints(fingerprints, allowOld = false) {
        for (let fp of fingerprints) {
          if (typeof fp !== "string") {
            fp = fp.toUnsigned().toString(16);
          }
          if (fp in __publicKeyIndex) {
            if (__publicKeyIndex[fp].old && !allowOld)
              continue;
            return __publicKeyIndex[fp];
          }
        }
        if (!allowOld)
          return findKeyByFingerprints(fingerprints, true);
        return null;
      }
      const FOUR$1 = JSBI.BigInt(4);
      function millerRabin(crypto, n2, rounds = 20) {
        if (JSBI.lessThan(n2, FOUR$1))
          return JSBI.greaterThan(n2, ONE);
        if (JSBI.equal(JSBI.remainder(n2, TWO), ZERO) || JSBI.lessThan(n2, ZERO))
          return false;
        const nBits = bigIntBitLength(n2);
        const nSub = JSBI.subtract(n2, ONE);
        const r2 = twoMultiplicity(nSub);
        const d = JSBI.signedRightShift(nSub, r2);
        for (let i = 0; i < rounds; i++) {
          let base;
          do {
            base = randomBigIntBits(crypto, nBits);
          } while (JSBI.lessThanOrEqual(base, ONE) || JSBI.greaterThanOrEqual(base, nSub));
          let x = bigIntModPow(base, d, n2);
          if (JSBI.equal(x, ONE) || JSBI.equal(x, nSub))
            continue;
          let i2 = ZERO;
          let y;
          while (JSBI.lessThan(i2, r2)) {
            y = bigIntModPow(x, TWO, n2);
            if (JSBI.equal(x, ONE))
              return false;
            if (JSBI.equal(x, nSub))
              break;
            i2 = JSBI.add(i2, ONE);
            x = y;
          }
          if (JSBI.equal(i2, r2))
            return false;
        }
        return true;
      }
      function generateKeyAndIvFromNonce(crypto, serverNonce, newNonce) {
        const hash1 = crypto.sha1(concatBuffers([newNonce, serverNonce]));
        const hash2 = crypto.sha1(concatBuffers([serverNonce, newNonce]));
        const hash3 = crypto.sha1(concatBuffers([newNonce, newNonce]));
        const key = concatBuffers([hash1, hash2.subarray(0, 12)]);
        const iv = concatBuffers([hash2.subarray(12, 20), hash3, newNonce.subarray(0, 4)]);
        return [key, iv];
      }
      function createAesIgeForMessage(crypto, authKey, messageKey, client2) {
        const x = client2 ? 0 : 8;
        const sha256a = crypto.sha256(concatBuffers([messageKey, authKey.subarray(x, 36 + x)]));
        const sha256b = crypto.sha256(concatBuffers([authKey.subarray(40 + x, 76 + x), messageKey]));
        const key = concatBuffers([sha256a.subarray(0, 8), sha256b.subarray(8, 24), sha256a.subarray(24, 32)]);
        const iv = concatBuffers([sha256b.subarray(0, 8), sha256a.subarray(8, 24), sha256b.subarray(24, 32)]);
        return crypto.createAesIge(key, iv);
      }
      function createAesIgeForMessageOld(crypto, authKey, messageKey, client2) {
        const x = client2 ? 0 : 8;
        const sha1a = crypto.sha1(concatBuffers([messageKey, authKey.subarray(x, 32 + x)]));
        const sha1b = crypto.sha1(
          concatBuffers([authKey.subarray(32 + x, 48 + x), messageKey, authKey.subarray(48 + x, 64 + x)])
        );
        const sha1c = crypto.sha1(concatBuffers([authKey.subarray(64 + x, 96 + x), messageKey]));
        const sha1d = crypto.sha1(concatBuffers([messageKey, authKey.subarray(96 + x, 128 + x)]));
        const key = concatBuffers([sha1a.subarray(0, 8), sha1b.subarray(8, 20), sha1c.subarray(4, 16)]);
        const iv = concatBuffers([
          sha1a.subarray(8, 20),
          sha1b.subarray(0, 8),
          sha1c.subarray(16, 20),
          sha1d.subarray(0, 8)
        ]);
        return crypto.createAesIge(key, iv);
      }
      function xorBuffer(data2, key) {
        const ret = new Uint8Array(data2.length);
        for (let i = 0; i < data2.length; i++) {
          ret[i] = data2[i] ^ key[i];
        }
        return ret;
      }
      function xorBufferInPlace(data2, key) {
        for (let i = 0; i < data2.length; i++) {
          data2[i] ^= key[i];
        }
      }
      function computePasswordHash(crypto, password, salt1, salt2) {
        return __async(this, null, function* () {
          const SH = (data2, salt) => crypto.sha256(concatBuffers([salt, data2, salt]));
          const PH1 = (pwd, salt12, salt22) => SH(SH(pwd, salt12), salt22);
          return SH(yield crypto.pbkdf2(PH1(password, salt1, salt2), salt1, 1e5), salt2);
        });
      }
      function computeNewPasswordHash(crypto, algo, password) {
        return __async(this, null, function* () {
          assertTypeIs("account.getPassword", algo, "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow");
          const salt1 = new Uint8Array(algo.salt1.length + 32);
          salt1.set(algo.salt1);
          crypto.randomFill(salt1.subarray(algo.salt1.length));
          algo.salt1 = salt1;
          const _x = yield computePasswordHash(crypto, getPlatform().utf8Encode(password), algo.salt1, algo.salt2);
          const g = JSBI.BigInt(algo.g);
          const p = bufferToBigInt(algo.p);
          const x = bufferToBigInt(_x);
          return bigIntToBuffer(bigIntModPow(g, x, p), 256);
        });
      }
      function computeSrpParams(crypto, request, password) {
        return __async(this, null, function* () {
          var _a3;
          if (!request.currentAlgo || request.currentAlgo._ !== "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow") {
            throw new MtUnsupportedError(`Unknown algo ${(_a3 = request.currentAlgo) == null ? void 0 : _a3._}`);
          }
          const algo = request.currentAlgo;
          if (!request.srpB) {
            throw new MtSecurityError("SRP_B is not present in the request");
          }
          if (!request.srpId) {
            throw new MtSecurityError("SRP_ID is not present in the request");
          }
          const g = JSBI.BigInt(algo.g);
          const _g = bigIntToBuffer(g, 256);
          const p = bufferToBigInt(algo.p);
          const gB = bufferToBigInt(request.srpB);
          const a = bufferToBigInt(crypto.randomBytes(256));
          const gA = bigIntModPow(g, a, p);
          const _gA = bigIntToBuffer(gA, 256);
          const H = (data2) => crypto.sha256(data2);
          const _k = crypto.sha256(concatBuffers([algo.p, _g]));
          const _u = crypto.sha256(concatBuffers([_gA, request.srpB]));
          const _x = yield computePasswordHash(crypto, getPlatform().utf8Encode(password), algo.salt1, algo.salt2);
          const k = bufferToBigInt(_k);
          const u = bufferToBigInt(_u);
          const x = bufferToBigInt(_x);
          const v = bigIntModPow(g, x, p);
          const kV = JSBI.remainder(JSBI.multiply(k, v), p);
          let t2 = JSBI.subtract(gB, kV);
          if (JSBI.lessThan(t2, ZERO))
            t2 = JSBI.add(t2, p);
          const sA = bigIntModPow(t2, JSBI.add(a, JSBI.multiply(u, x)), p);
          const _kA = H(bigIntToBuffer(sA, 256));
          const _M1 = H(concatBuffers([xorBuffer(H(algo.p), H(_g)), H(algo.salt1), H(algo.salt2), _gA, request.srpB, _kA]));
          return {
            _: "inputCheckPasswordSRP",
            srpId: request.srpId,
            A: _gA,
            M1: _M1
          };
        });
      }
      class EarlyTimer {
        constructor() {
          __publicField(this, "_timeout");
          __publicField(this, "_immediate");
          __publicField(this, "_timeoutTs");
          __publicField(this, "_handler", () => {
          });
          this.emitNow = this.emitNow.bind(this);
        }
        /**
         * Emit the timer when the event loop is idle
         * (basically `setImmediate()`)
         */
        emitWhenIdle() {
          if (this._immediate)
            return;
          clearTimeoutWrap(this._timeout);
          this._timeoutTs = Date.now();
          if (typeof setImmediateWrapExported !== "undefined") {
            this._immediate = setImmediateWrapExported(this.emitNow);
          } else {
            this._timeout = setTimeoutWrap(this.emitNow, 0);
          }
        }
        /**
         * Emit the timer before the next given milliseconds
         *
         * Shorthand for `emitBefore(Date.now() + ms)`
         *
         * @param ms  Milliseconds to schedule for
         */
        emitBeforeNext(ms) {
          return this.emitBefore(Date.now() + ms);
        }
        /**
         * Emit the timer before the given time
         *
         * @param ts  Unix time in MS
         */
        emitBefore(ts) {
          if (!this._timeoutTs || ts < this._timeoutTs) {
            this.reset();
            this._timeout = setTimeoutWrap(this.emitNow, ts - Date.now());
            this._timeoutTs = ts;
          }
        }
        /**
         * Emit the timer right now
         */
        emitNow() {
          this.reset();
          this._handler();
        }
        /**
         * Cancel the timer
         */
        reset() {
          if (this._immediate) {
            clearImmediateWrapExported(this._immediate);
            this._immediate = void 0;
          } else {
            clearTimeoutWrap(this._timeout);
          }
          this._timeoutTs = void 0;
        }
        /**
         * Set timeout handler
         */
        onTimeout(handler) {
          this._handler = handler;
        }
      }
      exports("E", EarlyTimer);
      function throttle(func, delay) {
        let timeout;
        const res = function() {
          if (timeout) {
            return;
          }
          const later = () => {
            timeout = null;
            func();
          };
          timeout = setTimeoutWrap(later, delay);
        };
        res.reset = () => {
          if (timeout) {
            clearTimeoutWrap(timeout);
            timeout = null;
          }
        };
        return res;
      }
      function asyncResettable(func) {
        let runningPromise = null;
        let finished = false;
        const run2 = function(...args) {
          if (finished)
            return Promise.resolve();
          if (runningPromise) {
            return runningPromise;
          }
          runningPromise = func(...args);
          void runningPromise.then(() => {
            runningPromise = null;
            finished = true;
          });
          return runningPromise;
        };
        return {
          run: run2,
          finished: () => finished,
          wait: () => runningPromise,
          reset: () => {
            finished = false;
          }
        };
      }
      class SortedLinkedList {
        constructor(comparator) {
          __publicField(this, "_first");
          __publicField(this, "_last");
          __publicField(this, "_size", 0);
          this.comparator = comparator;
        }
        get length() {
          return this._size;
        }
        _remove(item2) {
          if (this._first === item2) {
            this._first = item2.n;
          }
          if (this._last === item2) {
            this._last = item2.p;
          }
          if (item2.p)
            item2.p.n = item2.n;
          if (item2.n)
            item2.n.p = item2.p;
          this._size -= 1;
        }
        popFront() {
          if (!this._first)
            return void 0;
          const it = this._first;
          this._first = this._first.n;
          if (!this._first)
            this._last = void 0;
          this._size -= 1;
          return it.v;
        }
        add(item2) {
          const it = { v: item2 };
          if (!this._first) {
            this._first = this._last = it;
          } else {
            let cur = this._first;
            while (cur && this.comparator(cur.v, it.v) < 0) {
              cur = cur.n;
            }
            if (!cur) {
              this._last.n = it;
              it.p = this._last;
              this._last = it;
            } else {
              it.n = cur;
              it.p = cur.p;
              if (cur.p)
                cur.p.n = it;
              cur.p = it;
              if (cur === this._first)
                this._first = it;
            }
          }
          this._size += 1;
        }
        clear() {
          this._first = this._last = void 0;
          this._size = 0;
        }
      }
      exports("u", SortedLinkedList);
      function writeQuery(query) {
        if (!query)
          return "";
        let str = "";
        for(let   [key, value] of Object.entries(query)) {
          if (value == void 0)
            continue;
          if (str)
            str += "&";
          if (value === true) {
            str += `${key}`;
            continue;
          }
          str += `${key}=${encodeURIComponent(value)}`;
        }
        if (!str)
          return "";
        return `?${str}`;
      }
      // @__NO_SIDE_EFFECTS__
      function deeplinkBuilder(params) {
        const { internalBuild, internalParse, externalBuild, externalParse } = params;
        const fn_ = (options2) => {
          const _a3 = options2, { protocol = "https", domain = "t.me" } = _a3, rest = __objRest(_a3, ["protocol", "domain"]);
          if (protocol === "tg") {
            if (!internalBuild)
              throw new Error("tg:// deeplink is not supported");
            const [path22, query2] = internalBuild(rest);
            return `tg://${path22}${writeQuery(query2)}`;
          }
          if (!externalBuild)
            throw new Error("t.me deeplink is not supported");
          const [path2, query] = externalBuild(rest);
          return `${protocol}://${domain}/${path2}${writeQuery(query)}`;
        };
        const fn = fn_;
        fn.parse = (url2) => {
          const isInternal = url2.startsWith("tg://");
          if (isInternal)
            url2 = `https://fake/${url2.slice(5)}`;
          const parsed = new URL(url2);
          if (isInternal) {
            if (!internalParse)
              throw new Error("tg:// deeplink is not supported");
            const path22 = parsed.pathname.slice(1);
            return internalParse(path22, parsed.searchParams);
          }
          if (!externalParse)
            throw new Error("t.me deeplink is not supported");
          const path2 = parsed.pathname.slice(1);
          return externalParse(path2, parsed.searchParams);
        };
        return fn;
      }
      const chatInvite = exports("b", /* @__PURE__ */ deeplinkBuilder({
        internalBuild: ({ hash }) => ["join", { invite: hash }],
        internalParse: (path2, query) => {
          if (path2 !== "join")
            return null;
          const invite = query.get("invite");
          if (!invite)
            return null;
          return { hash: invite };
        },
        externalBuild: ({ hash }) => [`+${hash}`, null],
        externalParse: (path2) => {
          const m2 = path2.match(/^(?:\+|joinchat\/)([\w-]+)$/);
          if (!m2)
            return null;
          if (m2[1].match(/^\d+$/)) {
            return null;
          }
          return { hash: m2[1] };
        }
      }));
      const chatFolder = exports("c", /* @__PURE__ */ deeplinkBuilder({
        internalBuild: ({ slug }) => ["addlist", { slug }],
        internalParse: (path2, query) => {
          if (path2 !== "addlist")
            return null;
          const slug = query.get("slug");
          if (!slug)
            return null;
          return { slug };
        },
        externalBuild: ({ slug }) => [`addlist/${slug}`, null],
        externalParse: (path2) => {
          const [prefix, slug] = path2.split("/");
          if (prefix !== "addlist")
            return null;
          return { slug };
        }
      }));
      function parseMediaTimestamp(timestamp) {
        let m2;
        if (m2 = timestamp.match(/^(\d+)$/)) {
          return Number(m2[1]);
        }
        if (m2 = timestamp.match(/^(\d+):(\d{1,2})$/)) {
          return Number(m2[1]) * 60 + Number(m2[2]);
        }
        if (m2 = timestamp.match(/^(?:(\d+)h)?(?:(\d{1,2})m)?(\d{1,2})s$/)) {
          return (Number(m2[1]) || 0) * 3600 + (Number(m2[2]) || 0) * 60 + (Number(m2[3]) || 0);
        }
        return void 0;
      }
      const message$1 = exports("m", /* @__PURE__ */ deeplinkBuilder({
        internalBuild: (params) => {
          const common = {
            post: params.id,
            thread: params.threadId,
            comment: params.commentId,
            t: params.mediaTimestamp,
            single: params.single ? "" : void 0
          };
          if ("username" in params) {
            return ["resolve", __spreadValues({ domain: params.username }, common)];
          }
          return ["privatepost", __spreadValues({ channel: params.channelId }, common)];
        },
        internalParse: (path2, query) => {
          const common = {
            id: Number(query.get("post")),
            threadId: query.has("thread") ? Number(query.get("thread")) : void 0,
            commentId: query.has("comment") ? Number(query.get("comment")) : void 0,
            mediaTimestamp: query.has("t") ? parseMediaTimestamp(query.get("t")) : void 0,
            single: query.has("single")
          };
          if (path2 === "resolve") {
            const username2 = query.get("domain");
            if (!username2)
              return null;
            return __spreadValues({ username: username2 }, common);
          }
          if (path2 === "privatepost") {
            const channelId = Number(query.get("channel"));
            if (!channelId)
              return null;
            return __spreadValues({ channelId }, common);
          }
          return null;
        },
        externalBuild: (params) => {
          const common = {
            comment: params.commentId,
            t: params.mediaTimestamp,
            single: params.single ? "" : void 0
          };
          if ("username" in params) {
            if (params.threadId) {
              return [`${params.username}/${params.threadId}/${params.id}`, common];
            }
            return [`${params.username}/${params.id}`, common];
          }
          if (params.threadId) {
            return [`c/${params.channelId}/${params.threadId}/${params.id}`, common];
          }
          return [`c/${params.channelId}/${params.id}`, common];
        },
        externalParse: (path2, query) => {
          const chunks = path2.split("/");
          if (chunks.length < 2)
            return null;
          const id2 = Number(chunks[chunks.length - 1]);
          if (Number.isNaN(id2))
            return null;
          const common = {
            id: id2,
            commentId: query.has("comment") ? Number(query.get("comment")) : void 0,
            mediaTimestamp: query.has("t") ? parseMediaTimestamp(query.get("t")) : void 0,
            single: query.has("single")
          };
          if (chunks[0] === "c") {
            const channelId = Number(chunks[1]);
            if (Number.isNaN(channelId))
              return null;
            return __spreadValues({
              channelId,
              threadId: chunks[3] ? Number(chunks[2]) : void 0
            }, common);
          }
          const username2 = chunks[0];
          if (username2[0] === "+")
            return null;
          return __spreadValues({
            username: username2,
            threadId: chunks[2] ? Number(chunks[1]) : void 0
          }, common);
        }
      }));
      const DEFAULT_LOG_LEVEL = 2;
      const FORMATTER_RE = /%[a-z]/gi;
      class Logger {
        constructor(mgr, tag, parent = mgr) {
          __publicField(this, "color");
          __publicField(this, "prefix", "");
          __publicField(this, "error", this.log.bind(this, LogManager.ERROR));
          __publicField(this, "warn", this.log.bind(this, LogManager.WARN));
          __publicField(this, "info", this.log.bind(this, LogManager.INFO));
          __publicField(this, "debug", this.log.bind(this, LogManager.DEBUG));
          __publicField(this, "verbose", this.log.bind(this, LogManager.VERBOSE));
          this.mgr = mgr;
          this.tag = tag;
          this.parent = parent;
          let hash = 0;
          for (let i = 0; i < tag.length; i++) {
            hash = (hash << 5) - hash + tag.charCodeAt(i);
            hash |= 0;
          }
          this.color = Math.abs(hash) % 6;
        }
        getPrefix() {
          let s = "";
          let obj = this;
          while (obj) {
            if (obj.prefix)
              s = obj.prefix + s;
            obj = obj.parent;
          }
          return s;
        }
        log(level, fmt, ...args) {
          if (level > this.mgr.level)
            return;
          if (!this.mgr["_filter"](this.tag))
            return;
          if (fmt.includes("%h") || fmt.includes("%b") || fmt.includes("%j") || fmt.includes("%J") || fmt.includes("%l") || fmt.includes("%L") || fmt.includes("%e")) {
            let idx = 0;
            fmt = fmt.replace(FORMATTER_RE, (m2) => {
              if (m2 === "%h" || m2 === "%b" || m2 === "%j" || m2 === "%J" || m2 === "%l" || m2 === "%L" || m2 === "%e") {
                let val = args[idx];
                args.splice(idx, 1);
                if (m2 === "%h") {
                  if (ArrayBuffer.isView(val))
                    return this.mgr.platform.hexEncode(val);
                  if (typeof val === "number" || typeof val === "bigint")
                    return val.toString(16);
                  return String(val);
                }
                if (m2 === "%b")
                  return String(Boolean(val));
                if (m2 === "%j" || m2 === "%J") {
                  if (m2 === "%J") {
                    val = [...val];
                  }
                  return JSON.stringify(val, (k, v) => {
                    if (ArrayBuffer.isView(v) || typeof v === "object" && v.type === "Buffer" && Array.isArray(v.data)) {
                      let str = v.data ? Buffer.from(v.data).toString("hex") : this.mgr.platform.hexEncode(v);
                      if (str.length > 300) {
                        str = `${str.slice(0, 300)}...`;
                      }
                      return str;
                    }
                    return v;
                  });
                }
                if (m2 === "%l")
                  return String(val);
                if (m2 === "%L") {
                  if (!Array.isArray(val))
                    return "n/a";
                  return `[${val.map(String).join(", ")}]`;
                }
                if (m2 === "%e") {
                  if (isTlRpcError(val)) {
                    return `${val.errorCode} ${val.errorMessage}`;
                  }
                  if (tl.tl.RpcError.is(val)) {
                    return `${val.code} ${val.text}`;
                  }
                  return val && typeof val === "object" ? val.stack || val.message : String(val);
                }
              }
              idx++;
              return m2;
            });
          }
          this.mgr.handler(this.color, level, this.tag, this.getPrefix() + fmt, args);
        }
        /**
         * Create a {@link Logger} with the given tag
         * from the same {@link LogManager} as the current
         * Logger.
         *
         * @param tag  Logger tag
         */
        create(tag) {
          return new Logger(this.mgr, tag, this);
        }
      }
      exports("p", Logger);
      const defaultFilter = () => true;
      class LogManager extends Logger {
        constructor(tag = "base") {
          var _a3;
          super(null, tag);
          __publicField(this, "platform");
          __publicField(this, "level");
          __publicField(this, "handler");
          __publicField(this, "_filter", defaultFilter);
          this.mgr = this;
          this.platform = getPlatform();
          this.level = (_a3 = this.platform.getDefaultLogLevel()) != null ? _a3 : DEFAULT_LOG_LEVEL;
          this.handler = this.platform.log.bind(this.platform);
        }
        /**
         * Create a {@link Logger} with the given tag
         *
         * @param tag  Logger tag
         */
        create(tag) {
          return new Logger(this, tag);
        }
        /**
         * Filter logging by tags.
         *
         * @param cb
         */
        filter(cb) {
          this._filter = cb != null ? cb : defaultFilter;
        }
      }
      __publicField(LogManager, "OFF", 0);
      __publicField(LogManager, "ERROR", 1);
      __publicField(LogManager, "WARN", 2);
      __publicField(LogManager, "INFO", 3);
      __publicField(LogManager, "DEBUG", 4);
      __publicField(LogManager, "VERBOSE", 5);
      exports("o", LogManager);
      const sleep = exports("aX", (ms) => new Promise((resolve) => setTimeoutWrap(resolve, ms)));
      function sleepWithAbort(ms, signal) {
        return new Promise((resolve, reject) => {
          let timeout;
          const onAbort = () => {
            clearTimeoutWrap(timeout);
            reject(signal.reason);
          };
          signal.addEventListener("abort", onAbort);
          timeout = setTimeoutWrap(() => {
            signal.removeEventListener("abort", onAbort);
            resolve();
          }, ms);
        });
      }
      function getRandomInt(top2) {
        return Math.floor(Math.random() * top2);
      }
      function randomLong(unsigned = false) {
        const lo = getRandomInt(4294967295);
        const hi2 = getRandomInt(4294967295);
        return new Long(lo, hi2, unsigned);
      }
      function longFromBuffer(buf, unsigned = false, le = true) {
        const dv = dataViewFromBuffer(buf);
        if (le) {
          return new Long(dv.getInt32(0, true), dv.getInt32(4, true), unsigned);
        }
        return new Long(dv.getInt32(4, false), dv.getInt32(0, false), unsigned);
      }
      function removeFromLongArray(arr, val) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i];
          if (v === val || v.eq(val)) {
            arr.splice(i, 1);
            return true;
          }
        }
        return false;
      }
      function compareLongs(a, b) {
        if (a.eq(b))
          return 0;
        if (a.gt(b))
          return 1;
        return -1;
      }
      function longToFastString(val) {
        return `${val.low}|${val.high}`;
      }
      function longFromFastString(val, unsigned = false) {
        const parts = val.split("|");
        if (parts.length !== 2)
          throw new Error(`Invalid long fast string: ${val}`);
        const low2 = Number.parseInt(parts[0]);
        const high = Number.parseInt(parts[1]);
        if (Number.isNaN(low2) || Number.isNaN(high)) {
          throw new TypeError(`Invalid long fast string: ${val}`);
        }
        return new Long(low2, high, unsigned);
      }
      class LongMap {
        constructor() {
          __publicField(this, "_map", /* @__PURE__ */ new Map());
        }
        set(key, value) {
          this._map.set(longToFastString(key), value);
        }
        has(key) {
          return this._map.has(longToFastString(key));
        }
        get(key) {
          return this._map.get(longToFastString(key));
        }
        delete(key) {
          this._map.delete(longToFastString(key));
        }
        *keys(unsigned) {
          for(let   v of this._map.keys()) {
            yield longFromFastString(v, unsigned);
          }
        }
        values() {
          return this._map.values();
        }
        clear() {
          this._map.clear();
        }
        size() {
          return this._map.size;
        }
      }
      exports("q", LongMap);
      class LongSet {
        constructor() {
          __publicField(this, "_set", /* @__PURE__ */ new Set());
        }
        get size() {
          return this._set.size;
        }
        add(val) {
          this._set.add(longToFastString(val));
        }
        delete(val) {
          this._set.delete(longToFastString(val));
        }
        has(val) {
          return this._set.has(longToFastString(val));
        }
        clear() {
          this._set.clear();
        }
        toArray() {
          const arr = [];
          for(let   v of this._set) {
            arr.push(longFromFastString(v));
          }
          return arr;
        }
      }
      exports("r", LongSet);
      class LruMap {
        constructor(capacity, forLong = false) {
          __publicField(this, "_capacity");
          __publicField(this, "_first");
          __publicField(this, "_last");
          __publicField(this, "_map");
          __publicField(this, "_size", 0);
          this._capacity = capacity;
          this._map = forLong ? new LongMap() : /* @__PURE__ */ new Map();
        }
        _markUsed(item2) {
          if (item2 === this._first) {
            return;
          }
          if (item2.p) {
            if (item2 === this._last) {
              this._last = item2.p;
            }
            item2.p.n = item2.n;
          }
          if (item2.n) {
            item2.n.p = item2.p;
          }
          item2.p = void 0;
          item2.n = this._first;
          if (this._first) {
            this._first.p = item2;
          }
          this._first = item2;
        }
        get(key) {
          const item2 = this._map.get(key);
          if (!item2)
            return void 0;
          this._markUsed(item2);
          return item2.v;
        }
        has(key) {
          return this._map.has(key);
        }
        _remove(item2) {
          if (item2.p) {
            this._last = item2.p;
            this._last.n = void 0;
          } else {
            this._last = void 0;
            this._first = void 0;
          }
          item2.p = item2.n = void 0;
          this._map.delete(item2.k);
          this._size -= 1;
        }
        set(key, value) {
          let item2 = this._map.get(key);
          if (item2) {
            item2.v = value;
            this._markUsed(item2);
            return;
          }
          item2 = {
            k: key,
            v: value,
            // for jit to optimize stuff
            n: void 0,
            p: void 0
          };
          this._map.set(key, item2);
          if (this._first) {
            this._first.p = item2;
            item2.n = this._first;
          } else {
            this._last = item2;
          }
          this._first = item2;
          this._size += 1;
          if (this._size > this._capacity) {
            const oldest = this._last;
            if (oldest) {
              this._remove(oldest);
            }
          }
        }
        delete(key) {
          const item2 = this._map.get(key);
          if (item2)
            this._remove(item2);
        }
        clear() {
          this._map.clear();
          this._first = void 0;
          this._last = void 0;
          this._size = 0;
        }
      }
      exports("s", LruMap);
      class LruSet {
        constructor(capacity, forLong = false) {
          __publicField(this, "_capacity");
          __publicField(this, "_first");
          __publicField(this, "_last");
          __publicField(this, "_set");
          this._capacity = capacity;
          this._set = forLong ? new LongSet() : /* @__PURE__ */ new Set();
        }
        clear() {
          this._first = this._last = void 0;
          this._set.clear();
        }
        add(val) {
          if (this._set.has(val))
            return;
          if (!this._first)
            this._first = { v: val };
          if (!this._last) {
            this._last = this._first;
          } else {
            this._last.n = { v: val };
            this._last = this._last.n;
          }
          this._set.add(val);
          if (this._set.size > this._capacity && this._first) {
            this._set.delete(this._first.v);
            this._first = this._first.n;
          }
        }
        has(val) {
          return this._set.has(val);
        }
      }
      exports("t", LruSet);
      const ZERO_CHANNEL_ID = -1e12;
      const ZERO_SECRET_CHAT_ID = -2e12;
      const MAX_SECRET_CHAT_ID = -1997852516353;
      const MIN_MARKED_CHAT_ID = -999999999999;
      const MAX_USER_ID = 1099511627775;
      const MIN_MARKED_CHANNEL_ID = -1997852516352;
      function toggleChannelIdMark(id2) {
        return ZERO_CHANNEL_ID - id2;
      }
      function getBarePeerId(peer) {
        switch (peer._) {
          case "peerUser":
            return peer.userId;
          case "peerChat":
            return peer.chatId;
          case "peerChannel":
            return peer.channelId;
        }
      }
      function getMarkedPeerId(peer, peerType) {
        if (typeof peer === "number") {
          switch (peerType) {
            case "user":
              return peer;
            case "chat":
              return -peer;
            case "channel":
              return ZERO_CHANNEL_ID - peer;
          }
          throw new MtArgumentError("Invalid peer type");
        }
        switch (peer._) {
          case "mtcute.dummyInputPeerMinUser":
          case "peerUser":
          case "inputPeerUser":
          case "inputPeerUserFromMessage":
          case "inputUser":
          case "inputUserFromMessage":
            return peer.userId;
          case "peerChat":
          case "inputPeerChat":
            return -peer.chatId;
          case "mtcute.dummyInputPeerMinChannel":
          case "peerChannel":
          case "inputPeerChannel":
          case "inputPeerChannelFromMessage":
          case "inputChannel":
          case "inputChannelFromMessage":
            return ZERO_CHANNEL_ID - peer.channelId;
        }
        throw new MtArgumentError(`Invalid peer: ${peer._}`);
      }
      function parseMarkedPeerId(id2) {
        if (id2 < 0) {
          if (MIN_MARKED_CHAT_ID <= id2) {
            return ["chat", -id2];
          }
          if (MIN_MARKED_CHANNEL_ID <= id2 && id2 !== ZERO_CHANNEL_ID) {
            return ["channel", ZERO_CHANNEL_ID - id2];
          }
          if (MAX_SECRET_CHAT_ID >= id2 && id2 !== ZERO_SECRET_CHAT_ID) {
            throw new MtUnsupportedError("Secret chats are not supported");
          }
        } else if (id2 > 0 && id2 <= MAX_USER_ID) {
          return ["user", id2];
        }
        throw new MtArgumentError(`Invalid marked peer id: ${id2}`);
      }
      function* getAllPeersFrom(obj) {
        if (typeof obj !== "object")
          return;
        if (Array.isArray(obj)) {
          for(let   it of obj) {
            yield* __yieldStar(getAllPeersFrom(it));
          }
          return;
        }
        switch (obj._) {
          case "user":
          case "chat":
          case "channel":
          case "chatForbidden":
          case "channelForbidden":
            yield obj;
            return;
        }
        if ("user" in obj && typeof obj.user === "object" && obj.user._ === "user") {
          yield obj.user;
        }
        if ("chat" in obj && typeof obj.chat === "object") {
          switch (obj.chat._) {
            case "chat":
            case "channel":
            case "chatForbidden":
            case "channelForbidden":
              yield obj.chat;
              break;
          }
        }
        if ("channel" in obj && typeof obj.channel === "object") {
          switch (obj.channel._) {
            case "chat":
            case "channel":
            case "chatForbidden":
            case "channelForbidden":
              yield obj.channel;
              break;
          }
        }
        if ("users" in obj && Array.isArray(obj.users) && obj.users.length) {
          for(let   user of obj.users) {
            if (typeof user === "object" && user._ === "user") {
              yield user;
            }
          }
        }
        if ("chats" in obj && Array.isArray(obj.chats) && obj.chats.length) {
          for(let   chat2 of obj.chats) {
            if (typeof chat2 === "object") {
              switch (chat2._) {
                case "chat":
                case "channel":
                case "chatForbidden":
                case "channelForbidden":
                  yield chat2;
                  break;
              }
            }
          }
        }
      }
      class SortedArray {
        constructor(array = [], comparator) {
          __publicField(this, "raw");
          this.comparator = comparator;
          this.raw = array.sort(comparator);
          this.comparator = comparator;
        }
        get length() {
          return this.raw.length;
        }
        insert(item2) {
          if (Array.isArray(item2)) {
            let ind = -1;
            item2.forEach((it) => {
              ind = this.insert(it);
            });
            return ind;
          }
          if (this.raw.length === 0) {
            this.raw.push(item2);
            return 0;
          }
          let lo = 0;
          let hi2 = this.raw.length;
          while (lo < hi2) {
            const mid = Math.floor((lo + hi2) / 2);
            if (this.comparator(this.raw[mid], item2) > 0) {
              hi2 = mid;
            } else {
              lo = mid + 1;
            }
          }
          this.raw.splice(lo, 0, item2);
          return lo;
        }
        // closest: return the closest value (right-hand side)
        // meaning that raw[idx - 1] <= item <= raw[idx]
        // in other words, smallest idx such that raw[idx] >= item
        index(item2, closest = false) {
          let lo = 0;
          let hi2 = this.raw.length;
          while (lo < hi2) {
            const mid = Math.floor((lo + hi2) / 2);
            const cmp = this.comparator(this.raw[mid], item2);
            if (cmp === 0) {
              return mid;
            }
            if (cmp > 0) {
              hi2 = mid;
            } else {
              lo = mid + 1;
            }
          }
          return closest ? lo : -1;
        }
        remove(item2) {
          const idx = this.index(item2);
          if (idx === -1)
            return;
          this.raw.splice(idx, 1);
        }
        includes(item2) {
          return this.index(item2) !== -1;
        }
        find(item2) {
          const ind = this.index(item2);
          return ind === -1 ? null : this.raw[ind];
        }
        clear() {
          this.raw.length = 0;
        }
      }
      exports("S", SortedArray);
      function jsonToTlJson(obj) {
        if (obj === null || obj === void 0)
          return { _: "jsonNull" };
        if (typeof obj === "boolean")
          return { _: "jsonBool", value: obj };
        if (typeof obj === "number")
          return { _: "jsonNumber", value: obj };
        if (typeof obj === "string")
          return { _: "jsonString", value: obj };
        if (Array.isArray(obj)) {
          return { _: "jsonArray", value: obj.map(jsonToTlJson) };
        }
        if (typeof obj !== "object") {
          throw new MtArgumentError(`Unsupported type: ${typeof obj}`);
        }
        const items = [];
        Object.entries(obj).forEach(([key, value]) => {
          items.push({
            _: "jsonObjectValue",
            key,
            value: jsonToTlJson(value)
          });
        });
        return {
          _: "jsonObject",
          value: items
        };
      }
      function tlJsonToJson(obj) {
        switch (obj._) {
          case "jsonNull":
            return null;
          case "jsonBool":
          case "jsonNumber":
          case "jsonString":
            return obj.value;
          case "jsonArray":
            return obj.value.map(tlJsonToJson);
        }
        const ret = {};
        obj.value.forEach((item2) => {
          ret[item2.key] = tlJsonToJson(item2.value);
        });
        return ret;
      }
      class AuthKeysService extends BaseService {
        constructor(_keys, _salts, opts) {
          super(opts);
          this._keys = _keys;
          this._salts = _salts;
        }
        deleteByDc(dc) {
          return __async(this, null, function* () {
            yield this._keys.deleteByDc(dc);
            yield this._salts.delete(dc);
          });
        }
      }
      const KV_PREFIX = "salts:";
      class FutureSaltsService extends BaseService {
        constructor(_kv, opts) {
          super(opts);
          __publicField(this, "_cached", /* @__PURE__ */ new Map());
          this._kv = _kv;
        }
        store(dcId, salts) {
          return __async(this, null, function* () {
            if (this._cached.get(dcId) === salts)
              return;
            const writer2 = TlBinaryWriter.alloc(this._writerMap, 8 + 20 * salts.length);
            writer2.vector(writer2.object, salts);
            yield this._kv.set(KV_PREFIX + dcId, writer2.result());
          });
        }
        fetch(dcId) {
          return __async(this, null, function* () {
            const cached2 = this._cached.get(dcId);
            if (cached2)
              return cached2;
            const data2 = yield this._kv.get(KV_PREFIX + dcId);
            if (!data2)
              return null;
            const reader2 = new TlBinaryReader(this._readerMap, data2);
            const salts = reader2.vector();
            for(let   salt of salts) {
              if (salt._ !== "mt_future_salt")
                return null;
            }
            const salts_ = salts;
            this._cached.set(dcId, salts_);
            return salts_;
          });
        }
        delete(dcId) {
          return __async(this, null, function* () {
            this._cached.delete(dcId);
            yield this._kv.delete(KV_PREFIX + dcId);
          });
        }
      }
      class StorageManager {
        constructor(options2) {
          __publicField(this, "provider");
          __publicField(this, "driver");
          __publicField(this, "log");
          __publicField(this, "dcs");
          __publicField(this, "salts");
          __publicField(this, "keys");
          __publicField(this, "_cleanupRestore");
          __publicField(this, "_load", asyncResettable(() => __async(this, null, function* () {
            var _a3, _b2, _c, _d, _e;
            (_b2 = (_a3 = this.driver).setup) == null ? void 0 : _b2.call(_a3, this.log);
            if ((_c = this.options.cleanup) != null ? _c : true) {
              this._cleanupRestore = getPlatform().beforeExit(() => {
                this._destroy().catch((err) => this.log.error("cleanup error: %e", err));
              });
            }
            yield (_e = (_d = this.driver).load) == null ? void 0 : _e.call(_d);
          })));
          this.options = options2;
          this.provider = this.options.provider;
          this.driver = this.provider.driver;
          this.log = this.options.log.create("storage");
          const serviceOptions = {
            driver: this.driver,
            readerMap: this.options.readerMap,
            writerMap: this.options.writerMap,
            log: this.log
          };
          this.dcs = new DefaultDcsService(this.provider.kv, serviceOptions);
          this.salts = new FutureSaltsService(this.provider.kv, serviceOptions);
          this.keys = new AuthKeysService(this.provider.authKeys, this.salts, serviceOptions);
        }
        load() {
          return this._load.run();
        }
        save() {
          return __async(this, null, function* () {
            var _a3, _b2;
            yield (_b2 = (_a3 = this.driver).save) == null ? void 0 : _b2.call(_a3);
          });
        }
        clear(withAuthKeys = false) {
          return __async(this, null, function* () {
            if (withAuthKeys) {
              yield this.provider.authKeys.deleteAll();
            }
            yield this.provider.kv.deleteAll();
            yield this.save();
          });
        }
        _destroy() {
          return __async(this, null, function* () {
            var _a3, _b2;
            if (!this._load.finished())
              return;
            yield this._load.wait();
            yield (_b2 = (_a3 = this.driver).destroy) == null ? void 0 : _b2.call(_a3);
            this._load.reset();
          });
        }
        destroy() {
          return __async(this, null, function* () {
            if (this._cleanupRestore) {
              this._cleanupRestore();
              this._cleanupRestore = void 0;
            }
            yield this._destroy();
          });
        }
      }
      exports("cR", StorageManager);
      class Reloadable {
        constructor(params) {
          __publicField(this, "_data");
          __publicField(this, "_expiresAt", 0);
          __publicField(this, "_listeners", []);
          __publicField(this, "_timeout");
          __publicField(this, "_reload", asyncResettable(() => __async(this, null, function* () {
            const data2 = yield this.params.reload(this._data);
            this.setData(data2);
            this._listeners.forEach((cb) => cb(data2));
          })));
          this.params = params;
        }
        get isStale() {
          return !this._data || this._expiresAt <= Date.now();
        }
        setData(data2) {
          const expiresAt = this.params.getExpiresAt(data2);
          this._data = data2;
          this._expiresAt = expiresAt;
          if (this._timeout)
            clearTimeoutWrap(this._timeout);
          if (!this.params.disableAutoReload) {
            this._timeout = setTimeoutWrap(() => {
              this._reload.reset();
              this.update().catch((err) => {
                var _a3, _b2;
                (_b2 = (_a3 = this.params).onError) == null ? void 0 : _b2.call(_a3, err);
              });
            }, expiresAt - Date.now());
          }
        }
        update(force = false) {
          if (!force && !this.isStale)
            return Promise.resolve();
          return this._reload.run();
        }
        onReload(cb) {
          this._listeners.push(cb);
        }
        offReload(cb) {
          const idx = this._listeners.indexOf(cb);
          if (idx >= 0)
            this._listeners.splice(idx, 1);
        }
        getNow() {
          return this._data;
        }
        get() {
          return __async(this, null, function* () {
            yield this.update();
            return this._data;
          });
        }
        destroy() {
          if (this._timeout)
            clearTimeoutWrap(this._timeout);
          this._listeners.length = 0;
          this._reload.reset();
        }
      }
      class ConfigManager extends Reloadable {
        constructor(update) {
          super({
            reload: update,
            getExpiresAt: (data2) => data2.expires * 1e3
          });
        }
        findOption(params) {
          return __async(this, null, function* () {
            if (this.isStale)
              yield this.update();
            const options2 = this._data.dcOptions.filter((opt) => {
              if (opt.tcpoOnly)
                return false;
              if (opt.ipv6 && !params.allowIpv6)
                return false;
              if (opt.mediaOnly && !params.allowMedia)
                return false;
              if (opt.cdn && !params.cdn)
                return false;
              return opt.id === params.dcId;
            });
            if (params.preferMedia && params.preferIpv6) {
              const r2 = options2.find((opt) => opt.mediaOnly && opt.ipv6);
              if (r2)
                return r2;
            }
            if (params.preferMedia) {
              const r2 = options2.find((opt) => opt.mediaOnly);
              if (r2)
                return r2;
            }
            if (params.preferIpv6) {
              const r2 = options2.find((opt) => opt.ipv6);
              if (r2)
                return r2;
            }
            return options2[0];
          });
        }
      }
      function combineAbortSignals(signal1, signal2) {
        if (!signal2)
          return signal1;
        const controller = new AbortController();
        signal1.addEventListener("abort", () => controller.abort());
        signal2.addEventListener("abort", () => controller.abort());
        return controller.signal;
      }
      function floodWaiter(options2) {
        const { maxWait = 1e4, maxRetries = 5, store: store2 = true, minStoredWait = 3e3 } = options2;
        const storage = /* @__PURE__ */ new Map();
        return (ctx, next2) => __async(this, null, function* () {
          var _a3, _b2, _c, _d;
          const method = ctx.request._;
          const storedWaitUntil = store2 ? storage.get(method) : void 0;
          const floodSleepThreshold = (_b2 = (_a3 = ctx.params) == null ? void 0 : _a3.floodSleepThreshold) != null ? _b2 : maxWait;
          if (storedWaitUntil !== void 0) {
            const delta = storedWaitUntil - Date.now();
            if (delta <= minStoredWait) {
              storage.delete(method);
            } else if (delta <= floodSleepThreshold) {
              yield sleepWithAbort(delta, combineAbortSignals(ctx.manager.params.stopSignal, (_c = ctx.params) == null ? void 0 : _c.abortSignal));
              storage.delete(method);
            } else {
              return {
                _: "mt_rpc_error",
                errorCode: 420,
                errorMessage: `FLOOD_WAIT_${Math.ceil(delta / 1e3)}`
              };
            }
          }
          let lastError;
          for (let i = 0; i <= maxRetries; i++) {
            const res = yield next2(ctx);
            if (!isTlRpcError(res)) {
              return res;
            }
            lastError = res;
            const err = res.errorMessage;
            if (err.startsWith("FLOOD_WAIT_") || err.startsWith("SLOWMODE_WAIT_") || err.startsWith("FLOOD_TEST_PHONE_WAIT_")) {
              let seconds = Number(err.slice(err.lastIndexOf("_") + 1));
              if (Number.isNaN(seconds)) {
                ctx.manager._log.warn("invalid flood wait error received: %s, ignoring", err);
                return res;
              }
              if (store2 && !err.startsWith("SLOWMODE_WAIT_")) {
                storage.set(method, Date.now() + seconds * 1e3);
              }
              if (seconds === 0) {
                seconds = 1;
              }
              const ms = seconds * 1e3;
              if (ms <= floodSleepThreshold) {
                ctx.manager._log.warn("%s resulted in a flood wait, will retry in %d seconds", method, seconds);
                yield sleepWithAbort(
                  ms,
                  combineAbortSignals(ctx.manager.params.stopSignal, (_d = ctx.params) == null ? void 0 : _d.abortSignal)
                );
                continue;
              }
            }
            return res;
          }
          return lastError;
        });
      }
      const CLIENT_ERRORS = /* @__PURE__ */ new Set([
        tl.tl.RpcError.BAD_REQUEST,
        tl.tl.RpcError.UNAUTHORIZED,
        tl.tl.RpcError.FORBIDDEN,
        tl.tl.RpcError.NOT_FOUND,
        tl.tl.RpcError.FLOOD,
        tl.tl.RpcError.SEE_OTHER,
        tl.tl.RpcError.NOT_ACCEPTABLE
      ]);
      function internalErrorsHandler(params) {
        const { maxRetries = Infinity, waitTime = 1 } = params;
        return (ctx, next2) => __async(this, null, function* () {
          var _a3, _b2, _c, _d;
          const numRetries = (_b2 = (_a3 = ctx.params) == null ? void 0 : _a3.maxRetryCount) != null ? _b2 : maxRetries;
          for (let i = 0; i <= numRetries; i++) {
            const res = yield next2(ctx);
            if (!isTlRpcError(res))
              return res;
            if (!CLIENT_ERRORS.has(res.errorCode)) {
              if (((_c = ctx.params) == null ? void 0 : _c.throw503) && res.errorCode === -503) {
                throw new MtTimeoutError();
              }
              const waitSeconds = res.errorMessage === "WORKER_BUSY_TOO_LONG_RETRY" ? Math.max(1, waitTime) : waitTime;
              ctx.manager._log.warn(
                "Telegram is having internal issues: %d:%s, retrying in %ds",
                res.errorCode,
                res.errorMessage,
                waitSeconds
              );
              if (waitSeconds > 0) {
                yield sleepWithAbort(
                  waitSeconds * 1e3,
                  combineAbortSignals(ctx.manager.params.stopSignal, (_d = ctx.params) == null ? void 0 : _d.abortSignal)
                );
              }
              continue;
            }
            return res;
          }
        });
      }
      function basic(options2) {
        var _a3, _b2;
        return [floodWaiter((_a3 = options2 == null ? void 0 : options2.floodWaiter) != null ? _a3 : {}), internalErrorsHandler((_b2 = options2 == null ? void 0 : options2.internalErrors) != null ? _b2 : {})];
      }
      class AuthKey {
        constructor(_crypto, log, _readerMap) {
          __publicField(this, "ready", false);
          __publicField(this, "key");
          __publicField(this, "id");
          __publicField(this, "clientSalt");
          __publicField(this, "serverSalt");
          this._crypto = _crypto;
          this.log = log;
          this._readerMap = _readerMap;
        }
        match(keyId) {
          return this.ready && buffersEqual(keyId, this.id);
        }
        setup(authKey) {
          if (!authKey)
            return this.reset();
          this.ready = true;
          this.key = authKey;
          this.clientSalt = authKey.subarray(88, 120);
          this.serverSalt = authKey.subarray(96, 128);
          this.id = this._crypto.sha1(authKey).subarray(-8);
          this.log.verbose("auth key set up, id = %h", this.id);
        }
        encryptMessage(message2, serverSalt, sessionId) {
          if (!this.ready)
            throw new MtcuteError("Keys are not set up!");
          let padding = (16 + message2.length + 12) % 16;
          padding = 12 + (padding ? 16 - padding : 0);
          const buf = new Uint8Array(16 + message2.length + padding);
          const dv = dataViewFromBuffer(buf);
          dv.setInt32(0, serverSalt.low, true);
          dv.setInt32(4, serverSalt.high, true);
          dv.setInt32(8, sessionId.low, true);
          dv.setInt32(12, sessionId.high, true);
          buf.set(message2, 16);
          this._crypto.randomFill(buf.subarray(16 + message2.length, 16 + message2.length + padding));
          const messageKey = this._crypto.sha256(concatBuffers([this.clientSalt, buf])).subarray(8, 24);
          const ige = createAesIgeForMessage(this._crypto, this.key, messageKey, true);
          const encryptedData = ige.encrypt(buf);
          return concatBuffers([this.id, messageKey, encryptedData]);
        }
        decryptMessage(data2, sessionId, callback2) {
          const messageKey = data2.subarray(8, 24);
          let encryptedData = data2.subarray(24);
          const mod16 = encryptedData.byteLength % 16;
          if (mod16 !== 0) {
            encryptedData = encryptedData.subarray(0, encryptedData.byteLength - mod16);
          }
          const ige = createAesIgeForMessage(this._crypto, this.key, messageKey, false);
          const innerData = ige.decrypt(encryptedData);
          const msgKeySource = this._crypto.sha256(concatBuffers([this.serverSalt, innerData]));
          const expectedMessageKey = msgKeySource.subarray(8, 24);
          if (!buffersEqual(messageKey, expectedMessageKey)) {
            this.log.warn("received message with invalid messageKey = %h (expected %h)", messageKey, expectedMessageKey);
            return;
          }
          const innerReader = new TlBinaryReader(this._readerMap, innerData);
          innerReader.seek(8);
          const sessionId_ = innerReader.long();
          const messageId = innerReader.long(true);
          if (sessionId_.neq(sessionId)) {
            this.log.warn("ignoring message with invalid sessionId = %h", sessionId_);
            return;
          }
          const seqNo = innerReader.uint();
          const length = innerReader.uint();
          if (length > innerData.length - 32) {
            this.log.warn("ignoring message with invalid length: %d > %d", length, innerData.length - 32);
            return;
          }
          if (length % 4 !== 0) {
            this.log.warn("ignoring message with invalid length: %d is not a multiple of 4", length);
            return;
          }
          const paddingSize = innerData.length - length - 32;
          if (paddingSize < 12 || paddingSize > 1024) {
            this.log.warn("ignoring message with invalid padding size: %d", paddingSize);
            return;
          }
          callback2(messageId, seqNo, innerReader);
        }
        copyFrom(authKey) {
          this.ready = authKey.ready;
          this.key = authKey.key;
          this.id = authKey.id;
          this.serverSalt = authKey.serverSalt;
          this.clientSalt = authKey.clientSalt;
        }
        reset() {
          this.ready = false;
        }
      }
      class MtprotoSession {
        constructor(_crypto, log, _readerMap, _writerMap, _salts) {
          __publicField(this, "_sessionId", randomLong());
          __publicField(this, "_authKey");
          __publicField(this, "_authKeyTemp");
          __publicField(this, "_authKeyTempSecondary");
          __publicField(this, "_timeOffset", 0);
          __publicField(this, "_lastMessageId", Long.ZERO);
          __publicField(this, "_seqNo", 0);
          /// state ///
          // recent msg ids
          __publicField(this, "recentOutgoingMsgIds", new LruSet(1e3, true));
          __publicField(this, "recentIncomingMsgIds", new LruSet(1e3, true));
          // queues
          __publicField(this, "queuedRpc", new Deque());
          __publicField(this, "queuedAcks", []);
          __publicField(this, "queuedStateReq", []);
          __publicField(this, "queuedResendReq", []);
          __publicField(this, "queuedCancelReq", []);
          __publicField(this, "getStateSchedule", new SortedArray([], (a, b) => a.getState - b.getState));
          __publicField(this, "chains", /* @__PURE__ */ new Map());
          __publicField(this, "chainsPendingFails", /* @__PURE__ */ new Map());
          // requests info
          __publicField(this, "pendingMessages", new LongMap());
          __publicField(this, "destroySessionIdToMsgId", new LongMap());
          __publicField(this, "lastPingRtt", Number.NaN);
          __publicField(this, "lastPingTime", 0);
          __publicField(this, "lastPingMsgId", Long.ZERO);
          __publicField(this, "lastSessionCreatedUid", Long.ZERO);
          __publicField(this, "initConnectionCalled", false);
          __publicField(this, "authorizationPending", false);
          __publicField(this, "next429Timeout", 1e3);
          __publicField(this, "current429Timeout");
          __publicField(this, "next429ResetTimeout");
          this._crypto = _crypto;
          this.log = log;
          this._readerMap = _readerMap;
          this._writerMap = _writerMap;
          this._salts = _salts;
          this.log.prefix = `[SESSION ${this._sessionId.toString(16)}] `;
          this._authKey = new AuthKey(_crypto, log, _readerMap);
          this._authKeyTemp = new AuthKey(_crypto, log, _readerMap);
          this._authKeyTempSecondary = new AuthKey(_crypto, log, _readerMap);
        }
        get hasPendingMessages() {
          return Boolean(
            this.queuedRpc.length || this.queuedAcks.length || this.queuedStateReq.length || this.queuedResendReq.length
          );
        }
        /**
         * Reset session by resetting auth key(s) and session state
         */
        reset(withAuthKey = false) {
          if (withAuthKey) {
            this.resetAuthKey();
          }
          clearTimeoutWrap(this.current429Timeout);
          this.resetState(withAuthKey);
          this.resetLastPing(true);
        }
        resetAuthKey() {
          this._authKey.reset();
          this._authKeyTemp.reset();
          this._authKeyTempSecondary.reset();
        }
        updateTimeOffset(offset) {
          this.log.debug("time offset updated: %d", offset);
          this._timeOffset = offset;
          this._lastMessageId = Long.ZERO;
        }
        /**
         * Reset session state and generate a new session ID.
         *
         * By default, also cancels any pending RPC requests.
         * If `keepPending` is set to `true`, pending requests will be kept
         */
        resetState(keepPending = false) {
          this._lastMessageId = Long.ZERO;
          this._seqNo = 0;
          this._sessionId = randomLong();
          this.log.debug("session reset, new sid = %h", this._sessionId);
          this.log.prefix = `[SESSION ${this._sessionId.toString(16)}] `;
          if (!keepPending) {
            for(let   info of this.pendingMessages.values()) {
              if (info._ === "rpc") {
                this.log.debug("rejecting pending rpc %s", info.rpc.method);
                info.rpc.promise.reject(new MtcuteError("Session is reset"));
              }
            }
            this.pendingMessages.clear();
          }
          this.recentOutgoingMsgIds.clear();
          this.recentIncomingMsgIds.clear();
          if (!keepPending) {
            while (this.queuedRpc.length) {
              const rpc = this.queuedRpc.popFront();
              if (rpc.sent === false) {
                this.log.debug("rejecting pending rpc %s", rpc.method);
                rpc.promise.reject(new MtcuteError("Session is reset"));
              }
            }
          }
          this.queuedAcks.length = 0;
          this.queuedStateReq.length = 0;
          this.queuedResendReq.length = 0;
          this.queuedCancelReq.length = 0;
          this.getStateSchedule.clear();
          this.chains.clear();
          this.chainsPendingFails.clear();
        }
        enqueueRpc(rpc, force) {
          if (!force && !rpc.sent || rpc.cancelled)
            return false;
          rpc.sent = false;
          rpc.containerId = void 0;
          this.log.debug("enqueued %s for sending (msg_id = %s)", rpc.method, rpc.msgId || "n/a");
          this.queuedRpc.pushBack(rpc);
          return true;
        }
        getMessageId() {
          const timeTicks = Date.now();
          const timeSec = Math.floor(timeTicks / 1e3) - this._timeOffset;
          const timeMSec = timeTicks % 1e3;
          const random = getRandomInt(65535);
          let messageId = new Long(timeMSec << 21 | random << 3 | 4, timeSec);
          if (this._lastMessageId.ge(messageId)) {
            messageId = this._lastMessageId.add(4);
          }
          this._lastMessageId = messageId;
          return messageId;
        }
        getSeqNo(isContentRelated = true) {
          let seqNo = this._seqNo;
          if (isContentRelated) {
            seqNo += 1;
            this._seqNo += 2;
          }
          return seqNo;
        }
        /** Encrypt a single MTProto message using session's keys */
        encryptMessage(message2) {
          const key = this._authKeyTemp.ready ? this._authKeyTemp : this._authKey;
          return key.encryptMessage(message2, this._salts.currentSalt, this._sessionId);
        }
        /** Decrypt a single MTProto message using session's keys */
        decryptMessage(data2, callback2) {
          if (!this._authKey.ready)
            throw new MtcuteError("Keys are not set up!");
          const authKeyId = data2.subarray(0, 8);
          let key;
          if (this._authKey.match(authKeyId)) {
            key = this._authKey;
          } else if (this._authKeyTemp.match(authKeyId)) {
            key = this._authKeyTemp;
          } else if (this._authKeyTempSecondary.match(authKeyId)) {
            key = this._authKeyTempSecondary;
          } else {
            this.log.warn(
              "received message with unknown authKey = %h (expected %h or %h or %h)",
              authKeyId,
              this._authKey.id,
              this._authKeyTemp.id,
              this._authKeyTempSecondary.id
            );
            return;
          }
          return key.decryptMessage(data2, this._sessionId, callback2);
        }
        writeMessage(writer2, content2, isContentRelated = true) {
          const messageId = this.getMessageId();
          const seqNo = this.getSeqNo(isContentRelated);
          const length = ArrayBuffer.isView(content2) ? content2.length : TlSerializationCounter.countNeededBytes(writer2.objectMap, content2);
          writer2.long(messageId);
          writer2.int(seqNo);
          writer2.uint(length);
          if (ArrayBuffer.isView(content2))
            writer2.raw(content2);
          else
            writer2.object(content2);
          return messageId;
        }
        onTransportFlood(callback2) {
          if (this.current429Timeout)
            return;
          this.resetLastPing(true);
          const timeout = this.next429Timeout;
          this.next429Timeout = Math.min(this.next429Timeout * 2, 32e3);
          clearTimeoutWrap(this.current429Timeout);
          clearTimeoutWrap(this.next429ResetTimeout);
          this.current429Timeout = setTimeoutWrap(() => {
            this.current429Timeout = void 0;
            callback2();
          }, timeout);
          this.next429ResetTimeout = setTimeoutWrap(() => {
            this.next429ResetTimeout = void 0;
            this.next429Timeout = 1e3;
          }, 6e4);
          this.log.debug("transport flood, waiting for %d ms before proceeding", timeout);
          return Date.now() + timeout;
        }
        resetLastPing(withTime = false) {
          if (withTime)
            this.lastPingTime = 0;
          if (!this.lastPingMsgId.isZero()) {
            this.pendingMessages.delete(this.lastPingMsgId);
          }
          this.lastPingMsgId = Long.ZERO;
        }
        addToChain(chainId, msgId) {
          const prevMsgId = this.chains.get(chainId);
          this.chains.set(chainId, msgId);
          this.log.debug("added message %l to chain %s (prev: %l)", msgId, chainId, prevMsgId);
          return prevMsgId;
        }
        removeFromChain(chainId, msgId) {
          const lastMsgId = this.chains.get(chainId);
          if (!lastMsgId) {
            this.log.warn("tried to remove message %l from empty chain %s", msgId, chainId);
            return;
          }
          if (lastMsgId.eq(msgId)) {
            this.log.debug("chain %s: exhausted, last message %l", chainId, msgId);
            this.chains.delete(chainId);
          }
        }
        getPendingChainedFails(chainId) {
          let arr = this.chainsPendingFails.get(chainId);
          if (!arr) {
            arr = new SortedArray([], (a, b) => compareLongs(a.invokeAfter, b.invokeAfter));
            this.chainsPendingFails.set(chainId, arr);
          }
          return arr;
        }
      }
      const TWO_ZERO_FOUR_EIGHT = JSBI.BigInt(2048);
      const DH_SAFETY_RANGE = JSBI.exponentiate(TWO, JSBI.subtract(TWO_ZERO_FOUR_EIGHT, JSBI.BigInt(64)));
      const KNOWN_DH_PRIME = JSBI.BigInt("0xC71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F87FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B");
      const TWO_POW_2047 = JSBI.exponentiate(TWO, JSBI.BigInt(2047));
      const TWO_POW_2048 = JSBI.exponentiate(TWO, TWO_ZERO_FOUR_EIGHT);
      const checkedPrimesCache = [];
      const THREE = JSBI.BigInt(3);
      const FOUR = JSBI.BigInt(4);
      const FIVE = JSBI.BigInt(5);
      const SIX = JSBI.BigInt(6);
      const SEVEN = JSBI.BigInt(7);
      const EIGHT = JSBI.BigInt(8);
      const TWENTYFOUR = JSBI.BigInt(24);
      const NINETEEN = JSBI.BigInt(19);
      const TWENTYTHREE = JSBI.BigInt(23);
      function checkDhPrime(crypto, log, dhPrime, g) {
        if (JSBI.equal(KNOWN_DH_PRIME, dhPrime)) {
          log.debug("server is using known dh prime, skipping validation");
          return;
        }
        let checkedPrime = checkedPrimesCache.find((x) => JSBI.equal(x.prime, dhPrime));
        if (!checkedPrime) {
          if (JSBI.lessThanOrEqual(dhPrime, TWO_POW_2047) || JSBI.greaterThanOrEqual(dhPrime, TWO_POW_2048)) {
            throw new MtSecurityError("Step 3: dh_prime is not in the 2048-bit range");
          }
          if (!millerRabin(crypto, dhPrime)) {
            throw new MtSecurityError("Step 3: dh_prime is not prime");
          }
          if (!millerRabin(crypto, JSBI.divide(JSBI.subtract(dhPrime, ONE), TWO))) {
            throw new MtSecurityError("Step 3: dh_prime is not a safe prime - (dh_prime-1)/2 is not prime");
          }
          log.debug("dh_prime is probably prime");
          checkedPrime = {
            prime: dhPrime,
            generators: []
          };
          checkedPrimesCache.push(checkedPrime);
        } else {
          log.debug("dh_prime is probably prime (cached)");
        }
        const generatorChecked = checkedPrime.generators.includes(g);
        if (generatorChecked) {
          log.debug("g = %d is already checked for dh_prime", g);
          return;
        }
        switch (g) {
          case 2:
            if (JSBI.notEqual(JSBI.remainder(dhPrime, EIGHT), SEVEN)) {
              throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 8 != 7");
            }
            break;
          case 3:
            if (JSBI.notEqual(JSBI.remainder(dhPrime, THREE), TWO)) {
              throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 3 != 2");
            }
            break;
          case 4:
            break;
          case 5: {
            const mod = JSBI.remainder(dhPrime, FIVE);
            if (JSBI.notEqual(mod, ONE) && JSBI.notEqual(mod, FOUR)) {
              throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 5 != 1 && dh_prime mod 5 != 4");
            }
            break;
          }
          case 6: {
            const mod = JSBI.remainder(dhPrime, TWENTYFOUR);
            if (JSBI.notEqual(mod, NINETEEN) && JSBI.notEqual(mod, TWENTYTHREE)) {
              throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 24 != 19 && dh_prime mod 24 != 23");
            }
            break;
          }
          case 7: {
            const mod = JSBI.remainder(dhPrime, SEVEN);
            if (JSBI.notEqual(mod, THREE) && JSBI.notEqual(mod, FIVE) && JSBI.notEqual(mod, SIX)) {
              throw new MtSecurityError(
                "Step 3: ivalid g - dh_prime mod 7 != 3 && dh_prime mod 7 != 5 && dh_prime mod 7 != 6"
              );
            }
            break;
          }
          default:
            throw new MtSecurityError(`Step 3: ivalid g - unknown g = ${g}`);
        }
        checkedPrime.generators.push(g);
        log.debug("g = %d is safe to use with dh_prime", g);
      }
      function rsaPad(data2, crypto, key) {
        const keyModulus = JSBI.BigInt(`0x${key.modulus}`);
        const keyExponent = JSBI.BigInt(`0x${key.exponent}`);
        if (data2.length > 144) {
          throw new MtArgumentError("Failed to pad: too big data");
        }
        const dataPadded = new Uint8Array(192);
        dataPadded.set(data2, 0);
        crypto.randomFill(dataPadded.subarray(data2.length));
        data2 = dataPadded;
        for (; ; ) {
          const aesIv = new Uint8Array(32);
          const aesKey = crypto.randomBytes(32);
          const dataWithHash = concatBuffers([data2, crypto.sha256(concatBuffers([aesKey, data2]))]);
          dataWithHash.subarray(0, 192).reverse();
          const aes = crypto.createAesIge(aesKey, aesIv);
          const encrypted = aes.encrypt(dataWithHash);
          const encryptedHash = crypto.sha256(encrypted);
          xorBufferInPlace(aesKey, encryptedHash);
          const decryptedData = concatBuffers([aesKey, encrypted]);
          const decryptedDataBigint = bufferToBigInt(decryptedData);
          if (JSBI.greaterThanOrEqual(decryptedDataBigint, keyModulus)) {
            continue;
          }
          const encryptedBigint = bigIntModPow(decryptedDataBigint, keyExponent, keyModulus);
          return bigIntToBuffer(encryptedBigint, 256);
        }
      }
      function rsaEncrypt(data2, crypto, key) {
        const toEncrypt = concatBuffers([
          crypto.sha1(data2),
          data2,
          // sha1 is always 20 bytes, so we're left with 255 - 20 - x padding
          crypto.randomBytes(235 - data2.length)
        ]);
        const encryptedBigInt = bigIntModPow(
          bufferToBigInt(toEncrypt),
          JSBI.BigInt(`0x${key.exponent}`),
          JSBI.BigInt(`0x${key.modulus}`)
        );
        return bigIntToBuffer(encryptedBigInt);
      }
      function doAuthorization(connection, crypto, expiresIn) {
        return __async(this, null, function* () {
          const session = connection["_session"];
          const readerMap = session._readerMap;
          const writerMap = session._writerMap;
          const log = connection.log.create("auth");
          function sendPlainMessage(message2) {
            const length = TlSerializationCounter.countNeededBytes(writerMap, message2);
            const writer2 = TlBinaryWriter.alloc(writerMap, length + 20);
            const messageId = session.getMessageId();
            log.verbose("[PLAIN] >>> %j", message2);
            writer2.long(Long.ZERO);
            writer2.long(messageId);
            writer2.uint(length);
            writer2.object(message2);
            return connection.send(writer2.result());
          }
          function readNext() {
            return __async(this, null, function* () {
              const res = TlBinaryReader.deserializeObject(
                readerMap,
                yield connection.waitForUnencryptedMessage(),
                20
                // skip mtproto header
              );
              log.verbose("[PLAIN] <<< %j", res);
              return res;
            });
          }
          if (expiresIn)
            log.prefix = "[PFS] ";
          const nonce = crypto.randomBytes(16);
          log.debug("starting PQ handshake (temp = %b), nonce = %h", expiresIn, nonce);
          yield sendPlainMessage({ _: "mt_req_pq_multi", nonce });
          const resPq = yield readNext();
          mtpAssertTypeIs("auth step 1", resPq, "mt_resPQ");
          if (!buffersEqual(resPq.nonce, nonce)) {
            throw new MtSecurityError("Step 1: invalid nonce from server");
          }
          const serverKeys = resPq.serverPublicKeyFingerprints.map((it) => it.toUnsigned().toString(16));
          log.debug("received PQ, keys: %j", serverKeys);
          const publicKey = findKeyByFingerprints(serverKeys);
          if (!publicKey) {
            throw new MtSecurityError(
              `Step 2: Could not find server public key with any of these fingerprints: ${serverKeys.join(", ")}`
            );
          }
          log.debug("found server key, fp = %s, old = %s", publicKey.fingerprint, publicKey.old);
          if (millerRabin(crypto, bufferToBigInt(resPq.pq))) {
            throw new MtSecurityError("Step 2: pq is prime");
          }
          const [p, q] = yield crypto.factorizePQ(resPq.pq);
          log.debug("factorized PQ: PQ = %h, P = %h, Q = %h", resPq.pq, p, q);
          const newNonce = crypto.randomBytes(32);
          let dcId = connection.params.dc.id;
          if (connection.params.testMode)
            dcId += 1e4;
          if (connection.params.dc.mediaOnly)
            dcId = -dcId;
          const _pqInnerData = {
            _: expiresIn ? "mt_p_q_inner_data_temp_dc" : "mt_p_q_inner_data_dc",
            pq: resPq.pq,
            p,
            q,
            nonce,
            newNonce,
            serverNonce: resPq.serverNonce,
            dc: dcId,
            expiresIn
            // whatever
          };
          const pqInnerData = TlBinaryWriter.serializeObject(writerMap, _pqInnerData);
          const encryptedData = publicKey.old ? rsaEncrypt(pqInnerData, crypto, publicKey) : rsaPad(pqInnerData, crypto, publicKey);
          log.debug("requesting DH params");
          yield sendPlainMessage({
            _: "mt_req_DH_params",
            nonce,
            serverNonce: resPq.serverNonce,
            p,
            q,
            publicKeyFingerprint: Long.fromString(publicKey.fingerprint, true, 16),
            encryptedData
          });
          const serverDhParams = yield readNext();
          mtpAssertTypeIs("auth step 2", serverDhParams, "mt_server_DH_params_ok");
          if (!buffersEqual(serverDhParams.nonce, nonce)) {
            throw new MtSecurityError("Step 2: invalid nonce from server");
          }
          if (!buffersEqual(serverDhParams.serverNonce, resPq.serverNonce)) {
            throw new MtSecurityError("Step 2: invalid server nonce from server");
          }
          log.debug("server DH ok");
          if (serverDhParams.encryptedAnswer.length % 16 !== 0) {
            throw new MtSecurityError("Step 2: AES block size is invalid");
          }
          const [key, iv] = generateKeyAndIvFromNonce(crypto, resPq.serverNonce, newNonce);
          const ige = crypto.createAesIge(key, iv);
          const plainTextAnswer = ige.decrypt(serverDhParams.encryptedAnswer);
          const innerDataHash = plainTextAnswer.subarray(0, 20);
          const serverDhInnerReader = new TlBinaryReader(readerMap, plainTextAnswer, 20);
          const serverDhInner = serverDhInnerReader.object();
          if (!buffersEqual(innerDataHash, crypto.sha1(plainTextAnswer.subarray(20, serverDhInnerReader.pos)))) {
            throw new MtSecurityError("Step 3: invalid inner data hash");
          }
          mtpAssertTypeIs("auth step 3", serverDhInner, "mt_server_DH_inner_data");
          if (!buffersEqual(serverDhInner.nonce, nonce)) {
            throw new Error("Step 3: invalid nonce from server");
          }
          if (!buffersEqual(serverDhInner.serverNonce, resPq.serverNonce)) {
            throw new Error("Step 3: invalid server nonce from server");
          }
          const dhPrime = bufferToBigInt(serverDhInner.dhPrime);
          const timeOffset = Math.floor(Date.now() / 1e3) - serverDhInner.serverTime;
          session.updateTimeOffset(timeOffset);
          const g = JSBI.BigInt(serverDhInner.g);
          const gA = bufferToBigInt(serverDhInner.gA);
          checkDhPrime(crypto, log, dhPrime, serverDhInner.g);
          let retryId = Long.ZERO;
          const serverSalt = xorBuffer(newNonce.subarray(0, 8), resPq.serverNonce.subarray(0, 8));
          for (; ; ) {
            const b = bufferToBigInt(crypto.randomBytes(256));
            const gB = bigIntModPow(g, b, dhPrime);
            const authKey = bigIntToBuffer(bigIntModPow(gA, b, dhPrime));
            const authKeyAuxHash = crypto.sha1(authKey).subarray(0, 8);
            if (JSBI.lessThanOrEqual(g, ONE) || JSBI.greaterThanOrEqual(g, JSBI.subtract(dhPrime, ONE))) {
              throw new MtSecurityError("g is not within (1, dh_prime - 1)");
            }
            if (JSBI.lessThanOrEqual(gA, ONE) || JSBI.greaterThanOrEqual(gA, JSBI.subtract(dhPrime, ONE))) {
              throw new MtSecurityError("g_a is not within (1, dh_prime - 1)");
            }
            if (JSBI.lessThanOrEqual(gB, ONE) || JSBI.greaterThanOrEqual(gB, JSBI.subtract(dhPrime, ONE))) {
              throw new MtSecurityError("g_b is not within (1, dh_prime - 1)");
            }
            if (JSBI.lessThanOrEqual(gA, DH_SAFETY_RANGE) || JSBI.greaterThanOrEqual(gA, JSBI.subtract(dhPrime, DH_SAFETY_RANGE))) {
              throw new MtSecurityError("g_a is not within (2^{2048-64}, dh_prime - 2^{2048-64})");
            }
            if (JSBI.lessThanOrEqual(gB, DH_SAFETY_RANGE) || JSBI.greaterThanOrEqual(gB, JSBI.subtract(dhPrime, DH_SAFETY_RANGE))) {
              throw new MtSecurityError("g_b is not within (2^{2048-64}, dh_prime - 2^{2048-64})");
            }
            const gB_ = bigIntToBuffer(gB, 0, false);
            const clientDhInner = {
              _: "mt_client_DH_inner_data",
              nonce,
              serverNonce: resPq.serverNonce,
              retryId,
              gB: gB_
            };
            let innerLength = TlSerializationCounter.countNeededBytes(writerMap, clientDhInner) + 20;
            const innerPaddingLength = innerLength % 16;
            if (innerPaddingLength > 0)
              innerLength += 16 - innerPaddingLength;
            const clientDhInnerWriter = TlBinaryWriter.alloc(writerMap, innerLength);
            clientDhInnerWriter.pos = 20;
            clientDhInnerWriter.object(clientDhInner);
            const clientDhInnerHash = crypto.sha1(clientDhInnerWriter.uint8View.subarray(20, clientDhInnerWriter.pos));
            clientDhInnerWriter.pos = 0;
            clientDhInnerWriter.raw(clientDhInnerHash);
            log.debug("sending client DH (timeOffset = %d)", timeOffset);
            const clientDhEncrypted = ige.encrypt(clientDhInnerWriter.uint8View);
            yield sendPlainMessage({
              _: "mt_set_client_DH_params",
              nonce,
              serverNonce: resPq.serverNonce,
              encryptedData: clientDhEncrypted
            });
            const dhGen = yield readNext();
            if (!tl.mtp.isAnySet_client_DH_params_answer(dhGen)) {
              throw new MtTypeAssertionError("auth step 4", "set_client_DH_params_answer", dhGen._);
            }
            if (!buffersEqual(dhGen.nonce, nonce)) {
              throw new MtSecurityError("Step 4: invalid nonce from server");
            }
            if (!buffersEqual(dhGen.serverNonce, resPq.serverNonce)) {
              throw new MtSecurityError("Step 4: invalid server nonce from server");
            }
            log.debug("DH result: %s", dhGen._);
            if (dhGen._ === "mt_dh_gen_fail") {
              throw new MtTypeAssertionError("auth step 4", "!mt_dh_gen_fail", dhGen._);
            }
            if (dhGen._ === "mt_dh_gen_retry") {
              const expectedHash2 = crypto.sha1(concatBuffers([newNonce, new Uint8Array([2]), authKeyAuxHash]));
              if (!buffersEqual(expectedHash2.subarray(4, 20), dhGen.newNonceHash2)) {
                throw new MtSecurityError("Step 4: invalid retry nonce hash from server");
              }
              retryId = Long.fromBytesLE(authKeyAuxHash);
              continue;
            }
            if (dhGen._ !== "mt_dh_gen_ok")
              throw new Error("unreachable");
            const expectedHash = crypto.sha1(concatBuffers([newNonce, new Uint8Array([1]), authKeyAuxHash]));
            if (!buffersEqual(expectedHash.subarray(4, 20), dhGen.newNonceHash1)) {
              throw new MtSecurityError("Step 4: invalid nonce hash from server");
            }
            log.info("authorization successful");
            const dv = dataViewFromBuffer(serverSalt);
            return [authKey, new Long(dv.getInt32(0, true), dv.getInt32(4, true)), timeOffset];
          }
        });
      }
      var TransportState = exports("db", /* @__PURE__ */ ((TransportState2) => {
        TransportState2["Idle"] = "idle";
        TransportState2["Connecting"] = "connecting";
        TransportState2["Ready"] = "ready";
        return TransportState2;
      })(TransportState || {}));
      class TransportError extends Error {
        constructor(code2) {
          super(`Transport error: ${code2}`);
          __publicField(this, "code");
          this.code = code2;
        }
      }
      exports("da", TransportError);
      class StreamedCodec extends EventEmitter {
        constructor() {
          super(...arguments);
          __publicField(this, "_stream", new Uint8Array(0));
        }
        feed(data2) {
          this._stream = concatBuffers([this._stream, data2]);
          while (this._packetAvailable()) {
            if (!this._handlePacket())
              break;
          }
        }
        reset() {
          this._stream = new Uint8Array(0);
        }
      }
      exports("d3", StreamedCodec);
      const TAG = new Uint8Array([238, 238, 238, 238]);
      const PADDED_TAG = new Uint8Array([221, 221, 221, 221]);
      class IntermediatePacketCodec extends StreamedCodec {
        tag() {
          return TAG;
        }
        encode(packet) {
          const ret = new Uint8Array(packet.length + 4);
          const dv = dataViewFromBuffer(ret);
          dv.setUint32(0, packet.length, true);
          ret.set(packet, 4);
          return ret;
        }
        _packetAvailable() {
          return this._stream.length >= 8;
        }
        _handlePacket() {
          const dv = dataViewFromBuffer(this._stream);
          const payloadLength = dv.getUint32(0, true);
          if (payloadLength <= this._stream.length - 4) {
            if (payloadLength === 4) {
              const code2 = dv.getInt32(4, true) * -1;
              this.emit("error", new TransportError(code2));
            } else {
              const payload = this._stream.subarray(4, payloadLength + 4);
              this.emit("packet", payload);
            }
            this._stream = this._stream.subarray(payloadLength + 4);
            return true;
          }
          return false;
        }
      }
      exports("c7", IntermediatePacketCodec);
      class PaddedIntermediatePacketCodec extends IntermediatePacketCodec {
        constructor() {
          super(...arguments);
          __publicField(this, "_crypto");
        }
        tag() {
          return PADDED_TAG;
        }
        setup(crypto) {
          this._crypto = crypto;
        }
        encode(packet) {
          const padSize = getRandomInt(16);
          const ret = new Uint8Array(packet.length + 4 + padSize);
          const dv = dataViewFromBuffer(ret);
          dv.setUint32(0, packet.length + padSize, true);
          ret.set(packet, 4);
          this._crypto.randomFill(ret.subarray(4 + packet.length));
          return ret;
        }
      }
      exports("cu", PaddedIntermediatePacketCodec);
      class WrappedCodec extends EventEmitter {
        constructor(inner2) {
          super();
          __publicField(this, "_crypto");
          __publicField(this, "_inner");
          this._inner = inner2;
          this._inner.on("error", (err) => this.emit("error", err));
          this._inner.on("packet", (buf) => this.emit("packet", buf));
        }
        removeAllListeners() {
          super.removeAllListeners();
          this._inner.removeAllListeners();
          return this;
        }
        setup(crypto, log) {
          var _a3, _b2;
          this._crypto = crypto;
          (_b2 = (_a3 = this._inner).setup) == null ? void 0 : _b2.call(_a3, crypto, log);
        }
      }
      exports("dq", WrappedCodec);
      class ObfuscatedPacketCodec extends WrappedCodec {
        constructor(inner2, proxy2) {
          super(inner2);
          __publicField(this, "_encryptor");
          __publicField(this, "_decryptor");
          __publicField(this, "_proxy");
          this._proxy = proxy2;
        }
        tag() {
          return __async(this, null, function* () {
            let random;
            let dv;
            for (; ; ) {
              random = this._crypto.randomBytes(64);
              if (random[0] === 239)
                continue;
              dv = dataViewFromBuffer(random);
              const firstInt = dv.getUint32(0, true);
              if (firstInt === 1145128264 || firstInt === 1414745936 || firstInt === 542393671 || firstInt === 1230262351 || firstInt === 3722304989 || firstInt === 4008636142 || firstInt === 33620758) {
                continue;
              }
              if (dv.getInt32(4, true) === 0)
                continue;
              break;
            }
            let innerTag = yield this._inner.tag();
            if (innerTag.length !== 4) {
              const b = innerTag[0];
              innerTag = new Uint8Array([b, b, b, b]);
            }
            random.set(innerTag, 56);
            if (this._proxy) {
              let dcId = this._proxy.dcId;
              if (this._proxy.test)
                dcId += 1e4;
              if (this._proxy.media)
                dcId = -dcId;
              dv.setInt16(60, dcId, true);
            }
            const randomRev = bufferToReversed(random, 8, 56);
            let encryptKey = random.subarray(8, 40);
            const encryptIv = random.subarray(40, 56);
            let decryptKey = randomRev.subarray(0, 32);
            const decryptIv = randomRev.subarray(32, 48);
            if (this._proxy) {
              encryptKey = this._crypto.sha256(concatBuffers([encryptKey, this._proxy.secret]));
              decryptKey = this._crypto.sha256(concatBuffers([decryptKey, this._proxy.secret]));
            }
            this._encryptor = this._crypto.createAesCtr(encryptKey, encryptIv, true);
            this._decryptor = this._crypto.createAesCtr(decryptKey, decryptIv, false);
            const encrypted = this._encryptor.process(random);
            random.set(encrypted.subarray(56, 64), 56);
            return random;
          });
        }
        encode(packet) {
          return __async(this, null, function* () {
            return this._encryptor.process(yield this._inner.encode(packet));
          });
        }
        feed(data2) {
          const dec = this._decryptor.process(data2);
          this._inner.feed(dec);
        }
        reset() {
          var _a3, _b2, _c, _d;
          this._inner.reset();
          (_b2 = (_a3 = this._encryptor) == null ? void 0 : _a3.close) == null ? void 0 : _b2.call(_a3);
          (_d = (_c = this._decryptor) == null ? void 0 : _c.close) == null ? void 0 : _d.call(_c);
          this._encryptor = void 0;
          this._decryptor = void 0;
        }
      }
      exports("ct", ObfuscatedPacketCodec);
      let nextConnectionUid = 0;
      class PersistentConnection extends EventEmitter {
        constructor(params, log) {
          super();
          __publicField(this, "_uid", nextConnectionUid++);
          __publicField(this, "params");
          __publicField(this, "_transport");
          __publicField(this, "_sendOnceConnected", []);
          // reconnection
          __publicField(this, "_lastError", null);
          __publicField(this, "_consequentFails", 0);
          __publicField(this, "_previousWait", null);
          __publicField(this, "_reconnectionTimeout", null);
          __publicField(this, "_shouldReconnectImmediately", false);
          __publicField(this, "_disconnectedManually", false);
          // inactivity timeout
          __publicField(this, "_inactivityTimeout", null);
          __publicField(this, "_inactive", true);
          __publicField(this, "_destroyed", false);
          __publicField(this, "_usable", false);
          this.log = log;
          this.params = params;
          this.changeTransport(params.transportFactory);
          this.log.prefix = `[UID ${this._uid}] `;
          this._onInactivityTimeout = this._onInactivityTimeout.bind(this);
        }
        get isConnected() {
          return this._transport.state() !== TransportState.Idle;
        }
        changeTransport(factory) {
          var _a3, _b2;
          if (this._transport) {
            Promise.resolve(this._transport.close()).catch((err) => {
              this.log.warn("error closing previous transport: %e", err);
            });
          }
          this._transport = factory();
          (_b2 = (_a3 = this._transport).setup) == null ? void 0 : _b2.call(_a3, this.params.crypto, this.log);
          this._transport.on("ready", this.onTransportReady.bind(this));
          this._transport.on("message", this.onMessage.bind(this));
          this._transport.on("error", this.onTransportError.bind(this));
          this._transport.on("close", this.onTransportClose.bind(this));
        }
        onTransportReady() {
          if (this._sendOnceConnected.length) {
            const sendNext = () => {
              if (!this._sendOnceConnected.length) {
                this.onConnected();
                return;
              }
              const data2 = this._sendOnceConnected.shift();
              this._transport.send(data2).then(sendNext).catch((err) => {
                this.log.error("error sending queued data: %e", err);
                this._sendOnceConnected.unshift(data2);
              });
            };
            sendNext();
            return;
          }
          this.onConnected();
        }
        onConnectionUsable() {
          const isReconnection = this._consequentFails > 0;
          this._lastError = null;
          this._consequentFails = 0;
          this._previousWait = null;
          this._usable = true;
          this.emit("usable", isReconnection);
          this._rescheduleInactivity();
        }
        onTransportError(err) {
          this._lastError = err;
          this.onError(err);
        }
        onTransportClose() {
          if (this._inactive || this._disconnectedManually)
            return;
          if (this._shouldReconnectImmediately) {
            this._shouldReconnectImmediately = false;
            this.connect();
            return;
          }
          this._consequentFails += 1;
          const wait = this.params.reconnectionStrategy(
            this.params,
            this._lastError,
            this._consequentFails,
            this._previousWait
          );
          if (wait === false) {
            this.destroy().catch((err) => {
              this.log.warn("error destroying connection: %e", err);
            });
            return;
          }
          this.emit("wait", wait);
          this._previousWait = wait;
          if (this._reconnectionTimeout != null) {
            clearTimeoutWrap(this._reconnectionTimeout);
          }
          this._reconnectionTimeout = setTimeoutWrap(() => {
            if (this._destroyed)
              return;
            this._reconnectionTimeout = null;
            this.connect();
          }, wait);
        }
        connect() {
          if (this.isConnected) {
            throw new MtcuteError("Connection is already opened!");
          }
          if (this._destroyed) {
            throw new MtcuteError("Connection is already destroyed!");
          }
          if (this._reconnectionTimeout != null) {
            clearTimeoutWrap(this._reconnectionTimeout);
            this._reconnectionTimeout = null;
          }
          this._inactive = false;
          this._disconnectedManually = false;
          this._transport.connect(this.params.dc, this.params.testMode);
        }
        reconnect() {
          if (this._inactive)
            return;
          if (this.isConnected) {
            this._shouldReconnectImmediately = true;
            Promise.resolve(this._transport.close()).catch((err) => {
              this.log.error("error closing transport: %e", err);
            });
            return;
          }
          this.connect();
        }
        disconnectManual() {
          return __async(this, null, function* () {
            this._disconnectedManually = true;
            yield this._transport.close();
          });
        }
        destroy() {
          return __async(this, null, function* () {
            this._disconnectedManually = true;
            if (this._reconnectionTimeout != null) {
              clearTimeoutWrap(this._reconnectionTimeout);
            }
            if (this._inactivityTimeout != null) {
              clearTimeoutWrap(this._inactivityTimeout);
            }
            yield this._transport.close();
            this._transport.removeAllListeners();
            this._destroyed = true;
          });
        }
        _rescheduleInactivity() {
          if (!this.params.inactivityTimeout)
            return;
          if (this._inactivityTimeout)
            clearTimeoutWrap(this._inactivityTimeout);
          this._inactivityTimeout = setTimeoutWrap(this._onInactivityTimeout, this.params.inactivityTimeout);
        }
        _onInactivityTimeout() {
          this.log.info("disconnected because of inactivity for %d", this.params.inactivityTimeout);
          this._inactive = true;
          this._inactivityTimeout = null;
          Promise.resolve(this._transport.close()).catch((err) => {
            this.log.warn("error closing transport: %e", err);
          });
        }
        setInactivityTimeout(timeout) {
          this.params.inactivityTimeout = timeout;
          if (this._inactivityTimeout) {
            clearTimeoutWrap(this._inactivityTimeout);
          }
          if (timeout) {
            this._rescheduleInactivity();
          }
        }
        send(data2) {
          return __async(this, null, function* () {
            if (this._inactive) {
              this.connect();
            }
            if (this._transport.state() === TransportState.Ready) {
              yield this._transport.send(data2);
            } else {
              this._sendOnceConnected.push(data2);
            }
          });
        }
      }
      const TEMP_AUTH_KEY_EXPIRY = 86400;
      const PING_INTERVAL = 6e4;
      const GET_STATE_INTERVAL = 1500;
      const GZIP_PACKED_ID = 812830625;
      const MSG_CONTAINER_ID = 1945237724;
      const RPC_RESULT_ID = 4082920705;
      const RPC_ERROR_ID = 558156313;
      const INVOKE_AFTER_MSG_ID = 3416209197;
      const INVOKE_AFTER_MSG_SIZE = 12;
      class SessionConnection extends PersistentConnection {
        constructor(params, _session) {
          var _a3, _b2, _c, _d;
          super(params, _session.log.create("conn"));
          __publicField(this, "_flushTimer", new EarlyTimer());
          __publicField(this, "_queuedDestroySession", []);
          // waitForMessage
          __publicField(this, "_pendingWaitForUnencrypted", []);
          __publicField(this, "_usePfs");
          __publicField(this, "_isPfsBindingPending", false);
          __publicField(this, "_isPfsBindingPendingInBackground", false);
          __publicField(this, "_pfsUpdateTimeout");
          __publicField(this, "_inactivityPendingFlush", false);
          __publicField(this, "_readerMap");
          __publicField(this, "_writerMap");
          __publicField(this, "_crypto");
          __publicField(this, "_salts");
          __publicField(this, "_online");
          this._session = _session;
          this._flushTimer.onTimeout(this._flush.bind(this));
          this._readerMap = params.readerMap;
          this._writerMap = params.writerMap;
          this._crypto = params.crypto;
          this._salts = params.salts;
          this._handleRawMessage = this._handleRawMessage.bind(this);
          this._usePfs = (_a3 = this.params.usePfs) != null ? _a3 : false;
          this._online = (_d = (_c = (_b2 = getPlatform()).isOnline) == null ? void 0 : _c.call(_b2)) != null ? _d : true;
        }
        getAuthKey(temp = false) {
          const key = temp ? this._session._authKeyTemp : this._session._authKey;
          if (!key.ready)
            return null;
          return key.key;
        }
        setUsePfs(usePfs) {
          if (this._usePfs === usePfs)
            return;
          this.log.debug("use pfs changed to %s", usePfs);
          this._usePfs = usePfs;
          if (!usePfs) {
            this._isPfsBindingPending = false;
            this._isPfsBindingPendingInBackground = false;
            this._session._authKeyTemp.reset();
            clearTimeoutWrap(this._pfsUpdateTimeout);
          }
          this._resetSession();
        }
        onTransportClose() {
          super.onTransportClose();
          Object.values(this._pendingWaitForUnencrypted).forEach(([prom, timeout]) => {
            prom.reject(new MtcuteError("Connection closed"));
            clearTimeoutWrap(timeout);
          });
          for(let   msgId of this._session.pendingMessages.keys()) {
            const pending2 = this._session.pendingMessages.get(msgId);
            if (pending2._ === "state") {
              this._onMessageFailed(msgId, "connection loss", true);
            }
          }
          this.emit("disconnect");
          this.reset();
        }
        destroy() {
          return __async(this, null, function* () {
            yield __superGet(SessionConnection.prototype, this, "destroy").call(this);
            this.reset(true);
          });
        }
        reset(forever = false) {
          this._session.initConnectionCalled = false;
          this._flushTimer.reset();
          this._salts.isFetching = false;
          if (forever) {
            clearTimeoutWrap(this._pfsUpdateTimeout);
            this.removeAllListeners();
            this.on("error", (err) => {
              this.log.warn("caught error after destroying: %s", err);
            });
          }
        }
        onConnected() {
          if (!this._session._authKey.ready) {
            if (!this.params.isMainConnection) {
              this.log.info("no auth key, waiting for main connection");
              return;
            }
            this.log.info("no perm auth key, authorizing...");
            this._authorize();
            return;
          }
          if (this._usePfs && !this._session._authKeyTemp.ready) {
            this.log.info("no temp auth key but using pfs, authorizing");
            this._authorizePfs();
            return;
          }
          this.log.info("auth keys are already available");
          this.onConnectionUsable();
        }
        onError(error) {
          if (error instanceof TransportError) {
            if (error.code === 404) {
              if (this._usePfs) {
                if (!this._isPfsBindingPending && this._session._authKeyTemp.ready) {
                  this.log.info("transport error 404, reauthorizing pfs");
                  this._session._authKeyTemp.reset();
                  this._authorizePfs();
                  this._onAllFailed("temp key expired, binding started");
                  return;
                } else if (this._isPfsBindingPending) {
                  this.log.info("transport error 404, pfs binding in progress");
                  this._onAllFailed("temp key expired, binding pending");
                  return;
                }
              }
              this.log.info("transport error 404, reauthorizing");
              this._session.resetAuthKey();
              this._resetSession();
              this.emit("key-change", null);
              this.emit("error", error);
              return;
            }
            this.log.error("transport error %d", error.code);
            this._onAllFailed(`transport error ${error.code}`);
            if (error.code === 429) {
              this._session.onTransportFlood(this.emit.bind(this, "flood-done"));
              return;
            }
          }
          this.emit("error", error);
        }
        onConnectionUsable() {
          super.onConnectionUsable();
          if (this.params.withUpdates) {
            this.sendRpc({ _: "updates.getState" }).catch((err) => {
              if (this._destroyed || tl.tl.RpcError.is(err, "AUTH_KEY_UNREGISTERED"))
                return;
              this.log.warn("failed to send updates.getState: %e", err);
            });
          }
          this._flushTimer.emitBeforeNext(1e3);
        }
        _authorize() {
          if (this._session.authorizationPending) {
            this.log.info("_authorize(): authorization already in progress");
            return;
          }
          if (!this.params.isMainConnection) {
            this.log.debug("_authorize(): non-main connection, requesting...");
            this.emit("request-auth");
            return;
          }
          this._session.authorizationPending = true;
          this.emit("auth-begin");
          doAuthorization(this, this._crypto).then(([authKey, serverSalt, timeOffset]) => {
            this._session._authKey.setup(authKey);
            this._salts.currentSalt = serverSalt;
            this._session.updateTimeOffset(timeOffset);
            this._session.authorizationPending = false;
            this.emit("key-change", authKey);
            if (this._usePfs) {
              return this._authorizePfs();
            }
            this.onConnectionUsable();
          }).catch((err) => {
            this._session.authorizationPending = false;
            if (this._destroyed)
              return;
            this.log.error("Authorization error: %e", err);
            this.onError(err);
            this.reconnect();
          });
        }
        _authorizePfs(background2 = false) {
          if (this._isPfsBindingPending)
            return;
          if (this._pfsUpdateTimeout) {
            clearTimeoutWrap(this._pfsUpdateTimeout);
            this._pfsUpdateTimeout = void 0;
          }
          if (this._isPfsBindingPendingInBackground) {
            this._isPfsBindingPendingInBackground = false;
            this._isPfsBindingPending = true;
            return;
          }
          if (background2) {
            this._isPfsBindingPendingInBackground = true;
          } else {
            this._isPfsBindingPending = true;
          }
          doAuthorization(this, this._crypto, TEMP_AUTH_KEY_EXPIRY).then((_0) => __async(this, [_0], function* ([tempAuthKey, tempServerSalt]) {
            if (!this._usePfs) {
              this.log.info("pfs has been disabled while generating temp key");
              return;
            }
            const tempKey = this._session._authKeyTempSecondary;
            tempKey.setup(tempAuthKey);
            const msgId = this._session.getMessageId();
            this.log.debug(
              "binding temp_auth_key (%h) to perm_auth_key (%h), msg_id = %l...",
              tempKey.id,
              this._session._authKey.id,
              msgId
            );
            const inner2 = {
              _: "mt_bind_auth_key_inner",
              nonce: randomLong(),
              tempAuthKeyId: longFromBuffer(tempKey.id),
              permAuthKeyId: longFromBuffer(this._session._authKey.id),
              tempSessionId: this._session._sessionId,
              expiresAt: Math.floor(Date.now() / 1e3) + TEMP_AUTH_KEY_EXPIRY
            };
            const writer2 = TlBinaryWriter.alloc(this.params.writerMap, 80);
            writer2.raw(this._crypto.randomBytes(16));
            writer2.long(msgId);
            writer2.int(0);
            writer2.int(40);
            writer2.object(inner2);
            const msgWithoutPadding = writer2.result();
            writer2.raw(this._crypto.randomBytes(8));
            const msgWithPadding = writer2.result();
            const hash = this._crypto.sha1(msgWithoutPadding);
            const msgKey = hash.subarray(4, 20);
            const ige = createAesIgeForMessageOld(this._crypto, this._session._authKey.key, msgKey, true);
            const encryptedData = ige.encrypt(msgWithPadding);
            const encryptedMessage = concatBuffers([this._session._authKey.id, msgKey, encryptedData]);
            const promise = createControllablePromise();
            this._session.pendingMessages.set(msgId, {
              _: "bind",
              promise
            });
            const request = {
              _: "auth.bindTempAuthKey",
              permAuthKeyId: inner2.permAuthKeyId,
              nonce: inner2.nonce,
              expiresAt: inner2.expiresAt,
              encryptedMessage
            };
            const reqSize = TlSerializationCounter.countNeededBytes(this._writerMap, request);
            const reqWriter = TlBinaryWriter.alloc(this._writerMap, reqSize + 16);
            reqWriter.long(this._registerOutgoingMsgId(msgId));
            reqWriter.uint(this._session.getSeqNo());
            reqWriter.uint(reqSize);
            reqWriter.object(request);
            const requestEncrypted = tempKey.encryptMessage(
              reqWriter.result(),
              tempServerSalt,
              this._session._sessionId
            );
            yield this.send(requestEncrypted);
            const res = yield promise;
            this._session.pendingMessages.delete(msgId);
            if (!this._usePfs) {
              this.log.info("pfs has been disabled while binding temp key");
              return;
            }
            if (typeof res === "object") {
              this.log.error("failed to bind temp key: %s:%s", res.errorCode, res.errorMessage);
              throw new MtcuteError("Failed to bind temporary key");
            }
            this._session._authKeyTempSecondary = this._session._authKeyTemp;
            this._session._authKeyTemp = tempKey;
            this._salts.currentSalt = tempServerSalt;
            this.log.debug("temp key has been bound, exp = %d", inner2.expiresAt);
            this._isPfsBindingPending = false;
            this._isPfsBindingPendingInBackground = false;
            this._session.initConnectionCalled = false;
            this.emit("tmp-key-change", tempAuthKey, inner2.expiresAt);
            this.onConnectionUsable();
            this._pfsUpdateTimeout = setTimeoutWrap(
              () => {
                this._pfsUpdateTimeout = void 0;
                this.log.debug("temp key is expiring soon");
                this._authorizePfs(true);
              },
              (TEMP_AUTH_KEY_EXPIRY - 60) * 1e3
            );
          })).catch((err) => {
            if (this._destroyed)
              return;
            this.log.error("PFS Authorization error: %e", err);
            if (this._isPfsBindingPendingInBackground) {
              this._isPfsBindingPendingInBackground = false;
              return this._authorizePfs(true);
            }
            this._isPfsBindingPending = false;
            this.onError(err);
            this.reconnect();
          });
        }
        waitForUnencryptedMessage(timeout = 5e3) {
          if (this._destroyed) {
            return Promise.reject(new MtcuteError("Connection destroyed"));
          }
          const promise = createControllablePromise();
          const timeoutId = setTimeoutWrap(() => {
            promise.reject(new MtTimeoutError(timeout));
            this._pendingWaitForUnencrypted = this._pendingWaitForUnencrypted.filter((it) => it[0] !== promise);
          }, timeout);
          this._pendingWaitForUnencrypted.push([promise, timeoutId]);
          return promise;
        }
        onMessage(data2) {
          if (this._pendingWaitForUnencrypted.length) {
            const int32 = new Int32Array(data2.buffer, data2.byteOffset, 2);
            if (int32[0] === 0 && int32[1] === 0) {
              const [promise, timeout] = this._pendingWaitForUnencrypted.shift();
              clearTimeoutWrap(timeout);
              promise.resolve(data2);
              return;
            }
          }
          if (!this._session._authKey.ready) {
            this.log.warn("received message before authorization: %h", data2);
            return;
          }
          try {
            this._session.decryptMessage(data2, this._handleRawMessage);
          } catch (err) {
            this.log.error("failed to decrypt message: %s\ndata: %h", err, data2);
          }
        }
        _handleRawMessage(messageId, seqNo, message2) {
          const objectId = message2.uint();
          if (objectId === GZIP_PACKED_ID) {
            return this._handleRawMessage(
              messageId,
              seqNo,
              new TlBinaryReader(this._readerMap, this._crypto.gunzip(message2.bytes()))
            );
          }
          if (objectId === MSG_CONTAINER_ID) {
            const count2 = message2.uint();
            for (let i = 0; i < count2; i++) {
              const msgId = message2.long();
              const seqNo2 = message2.uint();
              const length = message2.uint();
              const obj = message2.raw(length);
              this._handleRawMessage(msgId, seqNo2, new TlBinaryReader(this._readerMap, obj));
            }
            return;
          }
          if (objectId === RPC_RESULT_ID) {
            return this._onRpcResult(messageId, message2);
          }
          this._handleMessage(messageId, message2.object(objectId));
        }
        _handleMessage(messageId, message_) {
          if (messageId.isEven()) {
            this.log.warn("warn: ignoring message with invalid messageId = %s (is even)", messageId);
            return;
          }
          if (this._session.recentIncomingMsgIds.has(messageId)) {
            this.log.debug("ignoring duplicate message %s", messageId);
            return;
          }
          const message2 = message_;
          this.log.debug("received %s (msg_id: %l)", message2._, messageId);
          this._session.recentIncomingMsgIds.add(messageId);
          switch (message2._) {
            case "mt_msgs_ack":
            case "mt_http_wait":
            case "mt_bad_msg_notification":
            case "mt_bad_server_salt":
            case "mt_msgs_all_info":
            case "mt_msgs_state_info":
            case "mt_msg_detailed_info":
            case "mt_msg_new_detailed_info":
              break;
            default:
              this._sendAck(messageId);
          }
          switch (message2._) {
            case "mt_pong":
              this._onPong(message2);
              break;
            case "mt_bad_server_salt":
              this._onBadServerSalt(message2);
              break;
            case "mt_bad_msg_notification":
              this._onBadMsgNotification(messageId, message2);
              break;
            case "mt_msgs_ack":
              message2.msgIds.forEach((msgId) => this._onMessageAcked(msgId));
              break;
            case "mt_new_session_created":
              this._onNewSessionCreated(message2);
              break;
            case "mt_msgs_all_info":
              this._onMessagesInfo(message2.msgIds, message2.info);
              break;
            case "mt_msg_detailed_info":
              this._onMessageInfo(message2.msgId, message2.status, message2.answerMsgId);
              break;
            case "mt_msg_new_detailed_info":
              this._onMessageInfo(Long.ZERO, 0, message2.answerMsgId);
              break;
            case "mt_msgs_state_info":
              this._onMsgsStateInfo(message2);
              break;
            case "mt_future_salts":
              this._onFutureSalts(message2);
              break;
            case "mt_msgs_state_req":
            case "mt_msg_resend_req":
              this.log.warn("received %s (msg_id = %l): %j", message2._, messageId, message2);
              break;
            case "mt_destroy_session_ok":
            case "mt_destroy_session_none":
              this._onDestroySessionResult(message2);
              break;
            default:
              if (tl.tl.isAnyUpdates(message2)) {
                if (this._usable && this.params.inactivityTimeout) {
                  this._rescheduleInactivity();
                }
                this.log.verbose("<<< %j", message2);
                if (this.params.disableUpdates) {
                  this.log.warn("received updates, but updates are disabled");
                  break;
                }
                this.emit("update", message2);
                return;
              }
              this.log.warn("unknown message received: %j", message2);
          }
        }
        _onRpcResult(messageId, message2) {
          if (this._usable && this.params.inactivityTimeout) {
            this._rescheduleInactivity();
          }
          const reqMsgId = message2.long();
          if (reqMsgId.isZero()) {
            let resultType;
            try {
              resultType = message2.object()._;
            } catch (e2) {
              resultType = message2.peekUint();
            }
            this.log.warn("received rpc_result with %j with req_msg_id = 0", resultType);
            return;
          }
          const msg = this._session.pendingMessages.get(reqMsgId);
          if (!msg) {
            let result2;
            try {
              result2 = message2.object();
            } catch (e2) {
              result2 = "[failed to parse]";
            }
            if (this._session.recentOutgoingMsgIds.has(reqMsgId)) {
              this.log.debug("received rpc_result again for %l (contains %j)", reqMsgId, result2);
            } else {
              this.log.warn("received rpc_result for unknown message %l: %j", reqMsgId, result2);
            }
            return;
          }
          this._sendAck(messageId);
          if (msg._ !== "rpc") {
            if (msg._ === "bind") {
              this._sendAck(messageId);
              msg.promise.resolve(message2.object());
              return;
            }
            if (msg._ === "cancel") {
              let result2;
              try {
                result2 = message2.object();
              } catch (e2) {
                this.log.debug("failed to parse rpc_result for cancel request %l, ignoring", reqMsgId);
                return;
              }
              this.log.debug("received %s for cancelled request %l: %j", result2._, reqMsgId, result2);
              this._onMessageAcked(reqMsgId);
              return;
            }
            this.log.error("received rpc_result for %s request %l", msg._, reqMsgId);
            return;
          }
          const rpc = msg.rpc;
          const resultConstructorId = message2.peekUint();
          let result;
          const customReader = this._readerMap._results[rpc.method];
          if (resultConstructorId === RPC_ERROR_ID) {
            result = message2.object();
          } else if (customReader) {
            result = customReader(message2);
          } else {
            const objectId = message2.uint();
            if (objectId === GZIP_PACKED_ID) {
              const inner2 = this._crypto.gunzip(message2.bytes());
              result = TlBinaryReader.deserializeObject(this._readerMap, inner2);
            } else {
              result = message2.object(objectId);
            }
          }
          if (rpc.initConn) {
            this._session.initConnectionCalled = true;
          }
          rpc.done = true;
          this.log.verbose("<<< (%s:%l) %j", rpc.method, reqMsgId, result);
          if (result._ === "mt_rpc_error") {
            const res = result;
            this.log.debug(
              "received rpc_error [%d:%s] for %l (%s)",
              res.errorCode,
              res.errorMessage,
              reqMsgId,
              rpc.method
            );
            if (rpc.cancelled)
              return;
            switch (res.errorMessage) {
              case "AUTH_KEY_PERM_EMPTY":
                this._authorizePfs();
                this._onMessageFailed(reqMsgId, "AUTH_KEY_PERM_EMPTY", true);
                return;
              case "CONNECTION_NOT_INITED": {
                this._session.initConnectionCalled = false;
                this._onMessageFailed(reqMsgId, res.errorMessage, true);
                this.sendRpc({ _: "help.getNearestDc" }).then(() => {
                  this.log.debug("additional help.getNearestDc for initConnection ok");
                }).catch((err) => {
                  this.log.debug("additional help.getNearestDc for initConnection error: %e", err);
                });
                return;
              }
              case "MSG_WAIT_TIMEOUT":
              case "MSG_WAIT_FAILED": {
                if (!rpc.invokeAfter) {
                  this.log.warn("received %s for non-chained request %l", res.errorMessage, reqMsgId);
                  break;
                }
                if (this._session.pendingMessages.has(rpc.invokeAfter)) {
                  this.log.debug(
                    "chain %s: waiting for %l before processing %l",
                    rpc.chainId,
                    rpc.invokeAfter,
                    reqMsgId
                  );
                  this._session.getPendingChainedFails(rpc.chainId).insert(rpc);
                } else {
                  this._session.chains.delete(rpc.chainId);
                  this._onMessageFailed(reqMsgId, "MSG_WAIT_FAILED", true);
                }
                return;
              }
            }
            rpc.promise.resolve(res);
          } else {
            this.log.debug("received rpc_result (%s) for request %l (%s)", result._, reqMsgId, rpc.method);
            if (rpc.cancelled)
              return;
            rpc.promise.resolve(result);
          }
          if (rpc.chainId) {
            this._processPendingChainedFails(rpc.chainId, reqMsgId);
          }
          this._onMessageAcked(reqMsgId);
          this._session.pendingMessages.delete(reqMsgId);
        }
        _processPendingChainedFails(chainId, sinceMsgId) {
          this._session.removeFromChain(chainId, sinceMsgId);
          const oldPending = this._session.chainsPendingFails.get(chainId);
          if (!(oldPending == null ? void 0 : oldPending.length)) {
            return;
          }
          const idx = oldPending.index({ invokeAfter: sinceMsgId }, true);
          if (idx === -1)
            return;
          const toFail = oldPending.raw.splice(idx);
          this.log.debug("chain %s: failing %d dependant messages: %L", chainId, toFail.length, toFail);
          this._session.chains.delete(chainId);
          for(let   rpc of toFail) {
            this._onMessageFailed(rpc.msgId, "MSG_WAIT_FAILED", true);
          }
        }
        _onMessageAcked(msgId, inContainer = false) {
          const msg = this._session.pendingMessages.get(msgId);
          if (!msg) {
            if (!this._session.recentOutgoingMsgIds.has(msgId)) {
              this.log.warn("received ack for unknown message %l", msgId);
            }
            return;
          }
          switch (msg._) {
            case "container":
              this.log.debug("received ack for container %l (size = %d)", msgId, msg.msgIds.length);
              msg.msgIds.forEach((msgId2) => this._onMessageAcked(msgId2, true));
              this._session.pendingMessages.delete(msgId);
              break;
            case "rpc": {
              const rpc = msg.rpc;
              this.log.debug("received ack for rpc query %l (%s, acked before = %s)", msgId, rpc.method, rpc.acked);
              rpc.acked = true;
              if (!inContainer && rpc.containerId && this._session.pendingMessages.has(rpc.containerId)) {
                this._onMessageAcked(rpc.containerId);
              }
              removeFromLongArray(this._session.queuedStateReq, msgId);
              removeFromLongArray(this._session.queuedResendReq, msgId);
              this._session.getStateSchedule.remove(rpc);
              break;
            }
            case "bind":
            case "cancel":
              break;
            default:
              if (!inContainer) {
                this.log.warn("received unexpected ack for %s query %l", msg._, msgId);
              }
          }
        }
        _onAllFailed(reason) {
          this.log.debug("all messages failed because of %s", reason);
          for(let   msgId of this._session.pendingMessages.keys()) {
            const info = this._session.pendingMessages.get(msgId);
            switch (info._) {
              case "container":
              case "state":
              case "resend":
              case "ping":
                this.log.debug("forgetting about %s message %l", info._, msgId);
                this._session.pendingMessages.delete(msgId);
                break;
              default:
                this._onMessageFailed(msgId, reason, true);
                break;
            }
          }
        }
        _onMessageFailed(msgId, reason, inContainer = false) {
          const msgInfo = this._session.pendingMessages.get(msgId);
          if (!msgInfo) {
            this.log.debug("unknown message %l failed because of %s", msgId, reason);
            return;
          }
          switch (msgInfo._) {
            case "container":
              this.log.debug("container %l (size = %d) failed because of %s", msgId, msgInfo.msgIds.length, reason);
              msgInfo.msgIds.forEach((msgId2) => this._onMessageFailed(msgId2, reason, true));
              break;
            case "ping":
              this.log.debug("ping (msg_id = %l) failed because of %s", msgId, reason);
              this._session.resetLastPing(true);
              break;
            case "rpc": {
              const rpc = msgInfo.rpc;
              this.log.debug("rpc query %l (%s) failed because of %s", msgId, rpc.method, reason);
              this._session.pendingMessages.delete(msgId);
              rpc.msgId = void 0;
              this._enqueueRpc(rpc, true);
              if (!inContainer && rpc.containerId && this._session.pendingMessages.has(rpc.containerId)) {
                this._onMessageFailed(rpc.containerId, reason);
              }
              removeFromLongArray(this._session.queuedStateReq, msgId);
              removeFromLongArray(this._session.queuedResendReq, msgId);
              this._session.getStateSchedule.remove(rpc);
              break;
            }
            case "resend":
              this.log.debug(
                "resend request %l (size = %d) failed because of %s",
                msgId,
                msgInfo.msgIds.length,
                reason
              );
              this._session.queuedResendReq.splice(0, 0, ...msgInfo.msgIds);
              this._flushTimer.emitWhenIdle();
              break;
            case "state":
              this.log.debug(
                "state request %l (size = %d) failed because of %s",
                msgId,
                msgInfo.msgIds.length,
                reason
              );
              this._session.queuedStateReq.splice(0, 0, ...msgInfo.msgIds);
              this._flushTimer.emitWhenIdle();
              break;
            case "bind":
              this.log.debug("temp key binding request %l failed because of %s, retrying", msgId, reason);
              msgInfo.promise.reject(new Error(reason));
              break;
            case "future_salts":
              this.log.debug("future_salts request %l failed because of %s, will retry", msgId, reason);
              this._salts.isFetching = false;
              break;
          }
          this._session.pendingMessages.delete(msgId);
        }
        _registerOutgoingMsgId(msgId) {
          this._session.recentOutgoingMsgIds.add(msgId);
          return msgId;
        }
        _onPong({ msgId, pingId }) {
          const info = this._session.pendingMessages.get(msgId);
          if (!info) {
            this.log.warn("received pong to unknown ping (msg_id %l, ping_id %l)", msgId, pingId);
            return;
          }
          if (info._ !== "ping") {
            this.log.warn("received pong to %s query, not ping (msg_id %l, ping_id %l)", info._, msgId, pingId);
            return;
          }
          if (info.pingId.neq(pingId)) {
            this.log.warn("received pong to %l, but expected ping_id = %l (got %l)", msgId, info.pingId, pingId);
          }
          const rtt = Date.now() - this._session.lastPingTime;
          this._session.lastPingRtt = rtt;
          if (info.containerId.neq(msgId)) {
            this._onMessageAcked(info.containerId);
          }
          this.log.debug("received pong: msg_id %l, ping_id %l, rtt = %dms", msgId, pingId, rtt);
          this._session.resetLastPing();
        }
        _onBadServerSalt(msg) {
          this._salts.currentSalt = msg.newServerSalt;
          this._onMessageFailed(msg.badMsgId, "bad_server_salt");
        }
        _onBadMsgNotification(msgId, msg) {
          switch (msg.errorCode) {
            case 16:
            case 17:
            case 20: {
              if (msg.errorCode !== 20) {
                const serverTime = msgId.high >>> 0;
                const timeOffset = Math.floor(Date.now() / 1e3) - serverTime;
                this._session.updateTimeOffset(timeOffset);
                this.log.debug("server time: %d, corrected offset to %d", serverTime, timeOffset);
              }
              this._onMessageFailed(msg.badMsgId, `bad_msg_notification ${msg.errorCode}`);
              break;
            }
            default:
              this.log.error(
                "received bad_msg_notification for msg_id = %l, code = %d. session will be reset",
                msg.badMsgId,
                msg.errorCode
              );
              this._resetSession();
              break;
          }
        }
        _onNewSessionCreated({ firstMsgId, serverSalt, uniqueId }) {
          if (uniqueId.eq(this._session.lastSessionCreatedUid)) {
            this.log.debug("received new_session_created with the same uid = %l, ignoring", uniqueId);
            return;
          }
          if (!this._session.lastSessionCreatedUid.isZero() && !this.params.disableUpdates) {
            this.emit("update", { _: "updatesTooLong" });
          }
          this._salts.currentSalt = serverSalt;
          this.log.debug("received new_session_created, uid = %l, first msg_id = %l", uniqueId, firstMsgId);
          for(let   msgId of this._session.pendingMessages.keys()) {
            const val = this._session.pendingMessages.get(msgId);
            if (val._ === "bind") {
              if (msgId.lt(firstMsgId)) {
                this._onMessageFailed(msgId, "received in wrong session");
              }
              continue;
            }
            if (val._ === "container") {
              if (msgId.lt(firstMsgId)) {
                this._session.pendingMessages.delete(msgId);
              }
              return;
            }
            const containerId = val._ === "rpc" ? val.rpc.containerId || msgId : val.containerId;
            if (containerId.lt(firstMsgId)) {
              this._onMessageFailed(msgId, "new_session_created", true);
            }
          }
        }
        _onMessageInfo(msgId, status, answerMsgId) {
          if (!msgId.isZero()) {
            const info = this._session.pendingMessages.get(msgId);
            if (!info) {
              if (!this._session.recentOutgoingMsgIds.has(msgId)) {
                this.log.warn("received message info about unknown message %l", msgId);
              }
              return;
            }
            switch (status & 7) {
              case 1:
              case 2:
              case 3:
                return this._onMessageFailed(msgId, `message info state ${status}`);
              case 0:
                if (!answerMsgId.isZero()) {
                  this.log.warn(
                    "received message info with status = 0: msg_id = %l, status = %d, ans_id = %l",
                    msgId,
                    status,
                    answerMsgId
                  );
                  return this._onMessageFailed(msgId, "message info state = 0, ans_id = 0");
                }
              case 4:
                this._onMessageAcked(msgId);
                break;
            }
          }
          if (!answerMsgId.isZero() && !this._session.recentIncomingMsgIds.has(answerMsgId)) {
            this.log.debug("received message info for %l, but answer (%l) was not received yet", msgId, answerMsgId);
            this._session.queuedResendReq.push(answerMsgId);
            this._flushTimer.emitWhenIdle();
            return;
          }
          if (answerMsgId.isZero()) {
            this.log.debug("received message info for %l: message is still pending (status = %d)", msgId, status);
            return;
          }
          this.log.debug("received message info for %l, and answer (%l) was already received", msgId, answerMsgId);
        }
        _onMessagesInfo(msgIds, info) {
          if (msgIds.length !== info.length) {
            this.log.warn("messages state info was invalid: msg_ids.length !== info.length");
          }
          for (let i = 0; i < msgIds.length; i++) {
            this._onMessageInfo(msgIds[i], info[i], Long.ZERO);
          }
        }
        _onMsgsStateInfo(msg) {
          const info = this._session.pendingMessages.get(msg.reqMsgId);
          if (!info) {
            this.log.warn("received msgs_state_info to unknown request %l", msg.reqMsgId);
            return;
          }
          if (info._ !== "state") {
            this.log.warn("received msgs_state_info to %s query %l", info._, msg.reqMsgId);
            return;
          }
          this._session.pendingMessages.delete(msg.reqMsgId);
          this._onMessagesInfo(info.msgIds, msg.info);
        }
        _onFutureSalts(msg) {
          const info = this._session.pendingMessages.get(msg.reqMsgId);
          if (!info) {
            this.log.warn("received future_salts to unknown request %l", msg.reqMsgId);
            return;
          }
          if (info._ !== "future_salts") {
            this.log.warn("received future_salts to %s query %l", info._, msg.reqMsgId);
            return;
          }
          this._session.pendingMessages.delete(msg.reqMsgId);
          this.log.debug("received future_salts: %d salts", msg.salts.length);
          this._salts.isFetching = false;
          this._salts.setFutureSalts(msg.salts.slice());
          this.emit("future-salts", msg.salts);
        }
        _onDestroySessionResult(msg) {
          const reqMsgId = this._session.destroySessionIdToMsgId.get(msg.sessionId);
          if (!reqMsgId) {
            this.log.warn("received %s for unknown session %h", msg._, msg.sessionId);
            return;
          }
          this._session.destroySessionIdToMsgId.delete(msg.sessionId);
          this._session.pendingMessages.delete(reqMsgId);
          this.log.debug("received %s for session %h", msg._, msg.sessionId);
        }
        _enqueueRpc(rpc, force) {
          if (this._session.enqueueRpc(rpc, force)) {
            this._flushTimer.emitWhenIdle();
          }
        }
        _resetSession() {
          this._queuedDestroySession.push(this._session._sessionId);
          this._session.resetState(true);
          this._onAllFailed("session reset");
          this.reconnect();
          this._flushTimer.reset();
        }
        _sendAck(msgId) {
          if (this._session.queuedAcks.length === 0) {
            this._flushTimer.emitBeforeNext(3e4);
          }
          this._session.queuedAcks.push(msgId);
          if (this._session.queuedAcks.length >= 100) {
            this._flushTimer.emitWhenIdle();
          }
        }
        sendRpc(request, timeout, abortSignal, chainId) {
          var _a3, _b2;
          if (this._usable && this.params.inactivityTimeout) {
            this._rescheduleInactivity();
          }
          const method = request._;
          let obj = request;
          let initConn = false;
          if (this.params.disableUpdates) {
            obj = {
              _: "invokeWithoutUpdates",
              query: obj
            };
          }
          if (!this._session.initConnectionCalled) {
            this.log.debug("wrapping %s with initConnection, layer: %d", method, this.params.layer);
            const proxy2 = (_b2 = (_a3 = this._transport).getMtproxyInfo) == null ? void 0 : _b2.call(_a3);
            obj = {
              _: "invokeWithLayer",
              layer: this.params.layer,
              query: __spreadProps(__spreadValues({}, this.params.initConnection), {
                proxy: proxy2,
                query: obj
              })
            };
            initConn = true;
          }
          this.log.verbose(">>> %j", obj);
          let content2 = TlBinaryWriter.serializeObject(this._writerMap, obj);
          if (content2.length > 1044404) {
            throw new MtArgumentError(`Payload is too big (${content2.length} > 1044404)`);
          }
          let shouldGzip = content2.length > 128;
          if (content2.length > 16384) {
            const middle = ~~((content2.length - 1024) / 2);
            const middlePart = content2.subarray(middle, middle + 1024);
            const gzipped = this._crypto.gzip(middlePart, Math.floor(middlePart.length * 0.9));
            if (!gzipped)
              shouldGzip = false;
          }
          if (shouldGzip) {
            const gzipped = this._crypto.gzip(content2, Math.floor(content2.length * 0.9));
            if (gzipped) {
              this.log.debug("gzipped %s (%db -> %db)", method, content2.length, gzipped.length);
              content2 = gzipped;
            } else {
              shouldGzip = false;
            }
          }
          const pending2 = {
            method,
            promise: createControllablePromise(),
            data: content2,
            // we will need to know size of gzip_packed overhead in _flush()
            gzipOverhead: shouldGzip ? 4 + TlSerializationCounter.countBytesOverhead(content2.length) : 0,
            initConn,
            chainId,
            // setting them as well so jit can optimize stuff
            invokeAfter: void 0,
            sent: void 0,
            done: void 0,
            getState: void 0,
            msgId: void 0,
            seqNo: void 0,
            containerId: void 0,
            acked: void 0,
            cancelled: void 0,
            timeout: void 0
          };
          if (abortSignal == null ? void 0 : abortSignal.aborted) {
            pending2.promise.reject(abortSignal.reason);
            return pending2.promise;
          }
          if (timeout) {
            pending2.timeout = setTimeoutWrap(() => this._cancelRpc(pending2, true), timeout);
          }
          if (abortSignal) {
            abortSignal.addEventListener("abort", () => this._cancelRpc(pending2, false, abortSignal));
          }
          this._enqueueRpc(pending2, true);
          return pending2.promise;
        }
        notifyNetworkChanged(online) {
          this._online = online;
          if (online) {
            this.reconnect();
          } else {
            this.disconnectManual().catch((err) => {
              this.log.warn("error while disconnecting: %e", err);
            });
          }
        }
        _cancelRpc(rpc, onTimeout = false, abortSignal) {
          if (rpc.done)
            return;
          if (rpc.cancelled && !onTimeout) {
            throw new MtcuteError("RPC was already cancelled");
          }
          if (!onTimeout && rpc.timeout) {
            clearTimeoutWrap(rpc.timeout);
          }
          if (onTimeout) {
            rpc.promise.resolve({
              _: "mt_rpc_error",
              errorCode: 400,
              errorMessage: "TIMEOUT"
            });
          } else if (abortSignal) {
            rpc.promise.reject(abortSignal.reason);
          }
          rpc.cancelled = true;
          if (rpc.msgId) {
            this._session.queuedCancelReq.push(rpc.msgId);
            this._session.getStateSchedule.remove(rpc);
            this._flushTimer.emitWhenIdle();
          } else {
            this._session.queuedRpc.remove(rpc);
          }
        }
        _onInactivityTimeout() {
          let hasPendingRpc = false;
          for(let   it of this._session.pendingMessages.values()) {
            if (it._ === "rpc") {
              hasPendingRpc = true;
              break;
            }
          }
          if (hasPendingRpc) {
            this.log.debug("waiting for pending rpc queries to finish before closing connection");
            this._rescheduleInactivity();
            return;
          }
          if (!this._session.hasPendingMessages) {
            this.log.debug("no pending service messages, closing connection");
            super._onInactivityTimeout();
            return;
          }
          this._inactivityPendingFlush = true;
          this._flush();
        }
        flushWhenIdle() {
          this._flushTimer.emitWhenIdle();
        }
        _flush() {
          var _a3;
          if (this._disconnectedManually || !this._session._authKey.ready || this._isPfsBindingPending || this._session.current429Timeout) {
            this.log.debug(
              "skipping flush, connection is not usable (offline = %b, auth key ready = %b, pfs binding pending = %b, 429 timeout = %b)",
              this._disconnectedManually,
              this._session._authKey.ready,
              this._isPfsBindingPending,
              this._session.current429Timeout
            );
            return;
          }
          try {
            this._doFlush();
          } catch (e2) {
            this.log.error("flush error: %s", e2.stack);
          }
          if (this._session.hasPendingMessages) {
            this._flushTimer.emitWhenIdle();
          } else {
            const nextPingTime = this._session.lastPingTime + PING_INTERVAL;
            const nextGetScheduleTime = ((_a3 = this._session.getStateSchedule.raw[0]) == null ? void 0 : _a3.getState) || Infinity;
            this._flushTimer.emitBefore(Math.min(nextPingTime, nextGetScheduleTime));
          }
        }
        _doFlush() {
          this.log.debug("flushing send queue. queued rpc: %d", this._session.queuedRpc.length);
          let packetSize = 0;
          let messageCount = 0;
          let containerMessageCount = 0;
          let containerSize = 0;
          let ackRequest = null;
          let ackMsgIds = null;
          let getFutureSaltsRequest = null;
          let getFutureSaltsMsgId = null;
          let pingRequest = null;
          let pingId = null;
          let pingMsgId = null;
          let getStateRequest = null;
          let getStateMsgId = null;
          let getStateMsgIds = null;
          let resendRequest = null;
          let resendMsgId = null;
          let resendMsgIds = null;
          let cancelRpcs = null;
          let destroySessions = null;
          let rootMsgId = null;
          const now2 = Date.now();
          if (this._session.queuedAcks.length) {
            let acks = this._session.queuedAcks;
            if (acks.length > 8192) {
              this._session.queuedAcks = acks.slice(8192);
              acks = acks.slice(0, 8192);
            } else {
              this._session.queuedAcks = [];
            }
            const obj = {
              _: "mt_msgs_ack",
              msgIds: acks
            };
            ackMsgIds = obj.msgIds;
            ackRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
            packetSize += ackRequest.length + 16;
            messageCount += 1;
          }
          if (now2 - this._session.lastPingTime > PING_INTERVAL) {
            if (!this._session.lastPingMsgId.isZero()) {
              this.log.warn("didn't receive pong for previous ping (msg_id = %l)", this._session.lastPingMsgId);
              this._session.pendingMessages.delete(this._session.lastPingMsgId);
            }
            pingId = randomLong();
            const obj = {
              _: "mt_ping_delay_disconnect",
              pingId,
              disconnectDelay: 75
            };
            this._session.lastPingTime = Date.now();
            pingRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
            containerSize += pingRequest.length + 16;
            containerMessageCount += 1;
          }
          {
            if (this._session.queuedStateReq.length) {
              let ids = this._session.queuedStateReq;
              if (ids.length > 8192) {
                this._session.queuedStateReq = ids.slice(8192);
                ids = ids.slice(0, 8192);
              } else {
                this._session.queuedStateReq = [];
              }
              getStateMsgIds = ids;
            }
            const idx = this._session.getStateSchedule.index({ getState: now2 }, true);
            if (idx > 0) {
              const toGetState = this._session.getStateSchedule.raw.splice(0, idx);
              if (!getStateMsgIds)
                getStateMsgIds = [];
              toGetState.forEach((it) => getStateMsgIds.push(it.msgId));
            }
            if (getStateMsgIds) {
              const obj = {
                _: "mt_msgs_state_req",
                msgIds: getStateMsgIds
              };
              getStateRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
              packetSize += getStateRequest.length + 16;
              messageCount += 1;
            }
          }
          if (this._session.queuedResendReq.length) {
            resendMsgIds = this._session.queuedResendReq;
            if (resendMsgIds.length > 8192) {
              this._session.queuedResendReq = resendMsgIds.slice(8192);
              resendMsgIds = resendMsgIds.slice(0, 8192);
            } else {
              this._session.queuedResendReq = [];
            }
            const obj = {
              _: "mt_msg_resend_req",
              msgIds: resendMsgIds
            };
            resendRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
            packetSize += resendRequest.length + 16;
            messageCount += 1;
          }
          if (this._session.queuedCancelReq.length) {
            containerMessageCount += this._session.queuedCancelReq.length;
            containerSize += this._session.queuedCancelReq.length * 28;
            cancelRpcs = this._session.queuedCancelReq;
            this._session.queuedCancelReq = [];
          }
          if (this._queuedDestroySession.length) {
            containerMessageCount += this._queuedDestroySession.length;
            containerSize += this._queuedDestroySession.length * 28;
            destroySessions = this._queuedDestroySession;
            this._queuedDestroySession = [];
          }
          if (this._salts.shouldFetchSalts()) {
            const obj = {
              _: "mt_get_future_salts",
              num: 64
            };
            getFutureSaltsRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
            containerSize += getFutureSaltsRequest.length + 16;
            containerMessageCount += 1;
            this._salts.isFetching = true;
          }
          let forceContainer = false;
          const rpcToSend = [];
          while (this._session.queuedRpc.length && containerSize < 32768 && containerMessageCount < 1020) {
            const msg = this._session.queuedRpc.popFront();
            if (msg.cancelled)
              continue;
            rpcToSend.push(msg);
            containerSize += msg.data.length + 16;
            if (msg.gzipOverhead)
              containerSize += msg.gzipOverhead;
            if (msg.chainId) {
              containerSize += INVOKE_AFTER_MSG_SIZE;
            }
            if (msg.msgId)
              forceContainer = true;
            if (msg.method === "upload.getFile")
              break;
          }
          packetSize += containerSize;
          messageCount += containerMessageCount + rpcToSend.length;
          if (!messageCount) {
            this.log.debug("flush did not happen: nothing to flush");
            return;
          }
          const useContainer = forceContainer || messageCount > 1;
          if (useContainer)
            packetSize += 24;
          const writer2 = TlBinaryWriter.alloc(this._writerMap, packetSize);
          if (useContainer) {
            writer2.pos += 16;
            writer2.uint(MSG_CONTAINER_ID);
            writer2.uint(messageCount);
          }
          const otherPendings = [];
          if (ackRequest) {
            this._registerOutgoingMsgId(this._session.writeMessage(writer2, ackRequest));
          }
          if (pingRequest) {
            pingMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, pingRequest));
            this._session.lastPingMsgId = pingMsgId;
            const pingPending = {
              _: "ping",
              pingId,
              containerId: pingMsgId
            };
            this._session.pendingMessages.set(pingMsgId, pingPending);
            otherPendings.push(pingPending);
          }
          if (getStateRequest) {
            getStateMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, getStateRequest));
            const getStatePending = {
              _: "state",
              msgIds: getStateMsgIds,
              containerId: getStateMsgId
            };
            this._session.pendingMessages.set(getStateMsgId, getStatePending);
            otherPendings.push(getStatePending);
          }
          if (resendRequest) {
            resendMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, resendRequest));
            const resendPending = {
              _: "resend",
              msgIds: resendMsgIds,
              containerId: resendMsgId
            };
            this._session.pendingMessages.set(resendMsgId, resendPending);
            otherPendings.push(resendPending);
          }
          if (cancelRpcs) {
            cancelRpcs.forEach((msgId) => {
              const cancelMsgId = this._registerOutgoingMsgId(
                this._session.writeMessage(writer2, {
                  _: "mt_rpc_drop_answer",
                  reqMsgId: msgId
                })
              );
              const pending2 = {
                _: "cancel",
                msgId,
                containerId: cancelMsgId
              };
              this._session.pendingMessages.set(cancelMsgId, pending2);
              otherPendings.push(pending2);
            });
          }
          if (destroySessions) {
            destroySessions.forEach((sessionId) => {
              const msgId = this._registerOutgoingMsgId(
                this._session.writeMessage(writer2, {
                  _: "mt_destroy_session",
                  sessionId
                })
              );
              const pending2 = {
                _: "destroy_session",
                sessionId,
                containerId: msgId
              };
              this._session.pendingMessages.set(msgId, pending2);
              this._session.destroySessionIdToMsgId.set(sessionId, msgId);
              otherPendings.push(pending2);
            });
          }
          if (getFutureSaltsRequest) {
            getFutureSaltsMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, getFutureSaltsRequest));
            const pending2 = {
              _: "future_salts",
              containerId: getFutureSaltsMsgId
            };
            this._session.pendingMessages.set(getFutureSaltsMsgId, pending2);
            otherPendings.push(pending2);
          }
          const getStateTime = now2 + GET_STATE_INTERVAL;
          for (let i = 0; i < rpcToSend.length; i++) {
            const msg = rpcToSend[i];
            if (!msg.msgId) {
              const msgId = this._session.getMessageId();
              const seqNo = this._session.getSeqNo();
              this.log.debug("%s: msg_id assigned %l, seqno: %d", msg.method, msgId, seqNo);
              msg.msgId = msgId;
              msg.seqNo = seqNo;
              this._session.pendingMessages.set(msgId, {
                _: "rpc",
                rpc: msg
              });
              if (msg.chainId) {
                msg.invokeAfter = this._session.addToChain(msg.chainId, msgId);
                this.log.debug("chain %s: invoke %l after %l", msg.chainId, msg.msgId, msg.invokeAfter);
              }
            } else {
              this.log.debug("%s: msg_id already assigned, reusing %l, seqno: %d", msg.method, msg.msgId, msg.seqNo);
            }
            if (msg.getState) {
              this._session.getStateSchedule.remove(msg);
            }
            if (!msg.acked) {
              msg.getState = getStateTime;
              this._session.getStateSchedule.insert(msg);
            }
            if (rootMsgId === null)
              rootMsgId = msg.msgId;
            writer2.long(this._registerOutgoingMsgId(msg.msgId));
            writer2.uint(msg.seqNo);
            const invokeAfterSize = msg.invokeAfter ? INVOKE_AFTER_MSG_SIZE : 0;
            const writeInvokeAfter = () => {
              if (!msg.invokeAfter)
                return;
              writer2.uint(INVOKE_AFTER_MSG_ID);
              writer2.long(msg.invokeAfter);
            };
            if (msg.gzipOverhead) {
              writer2.uint(msg.data.length + msg.gzipOverhead + invokeAfterSize);
              writeInvokeAfter();
              writer2.uint(GZIP_PACKED_ID);
              writer2.bytes(msg.data);
            } else {
              writer2.uint(msg.data.length + invokeAfterSize);
              writeInvokeAfter();
              writer2.raw(msg.data);
            }
            msg.sent = true;
          }
          if (useContainer) {
            packetSize = writer2.pos;
            const containerId = this._session.getMessageId();
            const seqNo = this._session.getSeqNo(false);
            this.log.debug("container: msg_id assigned %l, seqno: %d", containerId, seqNo);
            writer2.pos = 0;
            rootMsgId = containerId;
            writer2.long(this._registerOutgoingMsgId(containerId));
            writer2.uint(seqNo);
            writer2.uint(packetSize - 16);
            writer2.pos = packetSize;
            const msgIds = [];
            for (let i = 0; i < rpcToSend.length; i++) {
              const msg = rpcToSend[i];
              msg.containerId = containerId;
              msgIds.push(msg.msgId);
            }
            if (otherPendings.length) {
              otherPendings.forEach((msg) => {
                msgIds.push(msg.containerId);
                msg.containerId = containerId;
              });
            }
            this._session.pendingMessages.set(containerId, {
              _: "container",
              msgIds
            });
          }
          const result = writer2.result();
          this.log.debug(
            "sending %d messages: size = %db, acks = %L, ping = %b (msg_id = %l), state_req = %L (msg_id = %l), resend = %L (msg_id = %l), cancels = %L (msg_id = %l), salts_req = %b (msg_id = %l), rpc = %s, container = %b, root msg_id = %l",
            messageCount,
            packetSize,
            ackMsgIds,
            pingRequest,
            pingMsgId,
            getStateMsgIds,
            getStateMsgId,
            resendMsgIds,
            cancelRpcs,
            cancelRpcs,
            resendMsgId,
            getFutureSaltsRequest,
            getFutureSaltsMsgId,
            rpcToSend.map((it) => it.method),
            useContainer,
            rootMsgId
          );
          const enc = this._session.encryptMessage(result);
          const promise = this.send(enc).catch((err) => {
            this.log.error("error while sending pending messages (root msg_id = %l): %e", rootMsgId, err);
            if (ackMsgIds) {
              this._session.queuedAcks.splice(0, 0, ...ackMsgIds);
            }
            if (rootMsgId) {
              this._onMessageFailed(rootMsgId, "unknown error");
            }
          });
          if (this._inactivityPendingFlush && !this._session.hasPendingMessages) {
            void promise.then(() => {
              this.log.debug("pending messages sent, closing connection");
              this._flushTimer.reset();
              this._inactivityPendingFlush = false;
              super._onInactivityTimeout();
            });
          }
        }
      }
      exports("cL", SessionConnection);
      class MultiSessionConnection extends EventEmitter {
        constructor(params, _count, log, logPrefix = "") {
          super();
          __publicField(this, "_log");
          __publicField(this, "_sessions");
          __publicField(this, "_enforcePfs", false);
          __publicField(this, "_connections", []);
          __publicField(this, "_destroyed", false);
          __publicField(this, "_nextConnection", 0);
          this.params = params;
          this._count = _count;
          this._log = log.create("multi");
          if (logPrefix)
            this._log.prefix = `[${logPrefix}] `;
          this._enforcePfs = _count > 1 && params.isMainConnection;
          this._sessions = [];
          this._updateConnections();
        }
        setCount(count2, connect = this.params.isMainConnection) {
          this._count = count2;
          this._updateConnections(connect);
        }
        _updateSessions() {
          this._log.debug("updating sessions count: %d -> %d", this._sessions.length, this._count);
          if (this._sessions.length === this._count)
            return;
          if (this._sessions.length > this._count) {
            for (let i = this._sessions.length - 1; i >= this._count; i--) {
              this._sessions[i].reset();
            }
            this._sessions.splice(this._count);
            return;
          }
          while (this._sessions.length < this._count) {
            const idx = this._sessions.length;
            const session = new MtprotoSession(
              this.params.crypto,
              this._log.create("session"),
              this.params.readerMap,
              this.params.writerMap,
              this.params.salts
            );
            if (idx !== 0)
              session._authKey = this._sessions[0]._authKey;
            this._sessions.push(session);
          }
        }
        _updateConnections(connect = false) {
          this._updateSessions();
          if (this._connections.length === this._count)
            return;
          this._log.debug("updating connections count: %d -> %d", this._connections.length, this._count);
          const newEnforcePfs = this._count > 1 && this.params.isMainConnection;
          const enforcePfsChanged = newEnforcePfs !== this._enforcePfs;
          if (enforcePfsChanged) {
            this._log.debug("enforcePfs changed: %s -> %s", this._enforcePfs, newEnforcePfs);
            this._enforcePfs = newEnforcePfs;
          }
          if (this._connections.length > this._count) {
            for (let i = this._connections.length - 1; i >= this._count; i--) {
              this._connections[i].removeAllListeners();
              this._connections[i].destroy().catch((err) => {
                this._log.warn("error destroying connection: %e", err);
              });
            }
            this._connections.splice(this._count);
            return;
          }
          if (enforcePfsChanged) {
            const promise = createControllablePromise();
            this.emit("request-keys", promise);
            promise.then(() => {
              this._connections.forEach((conn) => {
                conn.setUsePfs(this.params.usePfs || this._enforcePfs);
                if (connect)
                  conn.connect();
              });
            }).catch((err) => {
              this.emit("error", err);
            });
          }
          for (let i = this._connections.length; i < this._count; i++) {
            const session = this._sessions[i];
            const conn = new SessionConnection(
              __spreadProps(__spreadValues({}, this.params), {
                usePfs: this.params.usePfs || this._enforcePfs,
                isMainConnection: this.params.isMainConnection && i === 0,
                withUpdates: this.params.isMainConnection && this.params.isMainDcConnection && !this.params.disableUpdates
              }),
              session
            );
            if (this.params.isMainConnection && this.params.isMainDcConnection) {
              conn.on("update", (update) => this.emit("update", update));
            }
            conn.on("error", (err) => this.emit("error", err, conn));
            conn.on("key-change", (key) => {
              this.emit("key-change", i, key);
              for(let   conn_ of this._connections) {
                if (conn_ === conn)
                  continue;
                conn_.onConnected();
              }
            });
            conn.on("tmp-key-change", (key, expires) => this.emit("tmp-key-change", i, key, expires));
            conn.on("future-salts", (salts) => this.emit("future-salts", salts));
            conn.on("auth-begin", () => {
              this._log.debug("received auth-begin from connection %d", i);
              this.emit("auth-begin", i);
              this._connections.forEach((conn_) => {
                conn_._session._authKeyTemp.reset();
                if (conn_ !== conn)
                  conn_.reconnect();
              });
            });
            conn.on("usable", () => this.emit("usable", i));
            conn.on("wait", () => this.emit("wait", i));
            conn.on("request-auth", () => this.emit("request-auth", i));
            conn.on("flood-done", () => {
              this._log.debug("received flood-done from connection %d", i);
              this._connections.forEach((it) => it.flushWhenIdle());
            });
            this._connections.push(conn);
            if (connect && !enforcePfsChanged)
              conn.connect();
          }
        }
        destroy() {
          return __async(this, null, function* () {
            yield Promise.all(this._connections.map((conn) => conn.destroy()));
            this._sessions.forEach((sess) => sess.reset());
            this.removeAllListeners();
            this._destroyed = true;
          });
        }
        sendRpc(request, timeout, abortSignal, chainId) {
          let min2 = Infinity;
          let minIdx = 0;
          for (let i = 0; i < this._connections.length; i++) {
            const conn = this._connections[i];
            const total = conn._session.queuedRpc.length + conn._session.pendingMessages.size();
            if (total < min2) {
              min2 = total;
              minIdx = i;
            }
          }
          return this._connections[minIdx].sendRpc(request, timeout, abortSignal, chainId);
        }
        connect() {
          for(let   conn of this._connections) {
            conn.connect();
          }
        }
        ensureConnected() {
          if (this._connections[0].isConnected)
            return;
          this.connect();
        }
        setAuthKey(authKey, temp = false, idx = 0) {
          const session = this._sessions[idx];
          const key = temp ? session._authKeyTemp : session._authKey;
          key.setup(authKey);
        }
        resetAuthKeys() {
          for(let   session of this._sessions) {
            session.reset(true);
          }
          this.notifyKeyChange();
        }
        setInactivityTimeout(timeout) {
          this._log.debug("setting inactivity timeout to %s", timeout);
          this.params.inactivityTimeout = timeout;
          for(let   conn of this._connections) {
            conn.setInactivityTimeout(timeout);
          }
        }
        notifyKeyChange() {
          const session = this._sessions[0];
          if (this.params.usePfs && !session._authKeyTemp.ready) {
            this._log.debug("temp auth key needed but not ready, ignoring key change");
            return;
          }
          if (this._sessions[0].queuedRpc.length) {
            this._log.debug("notifying key change on the connection due to queued rpc");
            this._connections[0].onConnected();
          }
        }
        notifyNetworkChanged(connected) {
          for(let   conn of this._connections) {
            conn.notifyNetworkChanged(connected);
          }
        }
        requestAuth() {
          this._connections[0]._authorize();
        }
        resetSessions() {
          if (this.params.isMainConnection) {
            for(let   conn of this._connections) {
              conn._resetSession();
            }
          } else {
            this._connections[0]._resetSession();
          }
        }
        changeTransport(factory) {
          this._connections.forEach((conn) => conn.changeTransport(factory));
        }
        getPoolSize() {
          return this._connections.length;
        }
      }
      const defaultReconnectionStrategy = exports("dy", (params, lastError, consequentFails, previousWait) => {
        if (previousWait === null)
          return 0;
        if (previousWait === 0)
          return 1e3;
        if (previousWait >= 5e3)
          return 5e3;
        return Math.min(5e3, previousWait + 1e3);
      });
      class ServerSaltManager {
        constructor() {
          __publicField(this, "_futureSalts", []);
          __publicField(this, "currentSalt", Long.ZERO);
          __publicField(this, "isFetching", false);
          __publicField(this, "_timer");
        }
        shouldFetchSalts() {
          return !this.isFetching && !this.currentSalt.isZero() && this._futureSalts.length < 2;
        }
        setFutureSalts(salts) {
          this._futureSalts = salts;
          const now2 = Date.now() / 1e3;
          while (salts.length > 0 && now2 > salts[0].validSince) {
            this.currentSalt = salts[0].salt;
            this._futureSalts.shift();
          }
          if (!this._futureSalts.length)
            this.currentSalt = Long.ZERO;
          else
            this._scheduleNext();
        }
        _scheduleNext() {
          if (this._timer)
            clearTimeoutWrap(this._timer);
          if (this._futureSalts.length === 0)
            return;
          const next2 = this._futureSalts.shift();
          this._timer = setTimeoutWrap(
            () => {
              this.currentSalt = next2.salt;
              this._scheduleNext();
            },
            next2.validSince * 1e3 - Date.now()
          );
        }
        destroy() {
          clearTimeoutWrap(this._timer);
        }
      }
      const defaultConnectionCountDelegate = (kind, dcId, isPremium) => {
        switch (kind) {
          case "main":
            return 0;
          case "upload":
            return isPremium || dcId !== 2 && dcId !== 4 ? 8 : 4;
          case "download":
            return isPremium ? 8 : 2;
          case "downloadSmall":
            return 2;
        }
      };
      class DcConnectionManager {
        constructor(manager, dcId, _dcs, isPrimary = false) {
          __publicField(this, "_salts", new ServerSaltManager());
          __publicField(this, "_log");
          /** Main connection pool */
          __publicField(this, "main");
          /** Upload connection pool */
          __publicField(this, "upload");
          /** Download connection pool */
          __publicField(this, "download");
          /** Download connection pool (for small files) */
          __publicField(this, "downloadSmall");
          var _a3, _b2;
          this.manager = manager;
          this.dcId = dcId;
          this._dcs = _dcs;
          this.isPrimary = isPrimary;
          this._log = this.manager._log.create("dc-manager");
          this._log.prefix = `[DC ${dcId}] `;
          const baseConnectionParams = () => {
            var _a4;
            return {
              crypto: this.manager.params.crypto,
              initConnection: this.manager._initConnectionParams,
              transportFactory: this.manager._transportFactory,
              dc: this._dcs.media,
              testMode: this.manager.params.testMode,
              reconnectionStrategy: this.manager._reconnectionStrategy,
              layer: this.manager.params.layer,
              disableUpdates: this.manager.params.disableUpdates,
              readerMap: this.manager.params.readerMap,
              writerMap: this.manager.params.writerMap,
              usePfs: this.manager.params.usePfs,
              isMainConnection: false,
              isMainDcConnection: this.isPrimary,
              inactivityTimeout: (_a4 = this.manager.params.inactivityTimeout) != null ? _a4 : 6e4,
              enableErrorReporting: this.manager.params.enableErrorReporting,
              salts: this._salts
            };
          };
          const mainParams = baseConnectionParams();
          mainParams.isMainConnection = true;
          mainParams.dc = _dcs.main;
          if (isPrimary) {
            mainParams.inactivityTimeout = void 0;
          }
          let mainCount;
          if (this.isPrimary) {
            mainCount = this._mainCountOverride;
            if (mainCount === 0) {
              mainCount = (_b2 = (_a3 = this.manager.config.getNow()) == null ? void 0 : _a3.tmpSessions) != null ? _b2 : 1;
            }
          } else {
            mainCount = 1;
          }
          this.main = new MultiSessionConnection(mainParams, mainCount, this._log, "MAIN");
          this.upload = new MultiSessionConnection(
            baseConnectionParams(),
            this.manager._connectionCount("upload", this.dcId, this.manager.params.isPremium),
            this._log,
            "UPLOAD"
          );
          this.download = new MultiSessionConnection(
            baseConnectionParams(),
            this.manager._connectionCount("download", this.dcId, this.manager.params.isPremium),
            this._log,
            "DOWNLOAD"
          );
          this.downloadSmall = new MultiSessionConnection(
            baseConnectionParams(),
            this.manager._connectionCount("downloadSmall", this.dcId, this.manager.params.isPremium),
            this._log,
            "DOWNLOAD_SMALL"
          );
          this._setupMulti("main");
          this._setupMulti("upload");
          this._setupMulti("download");
          this._setupMulti("downloadSmall");
        }
        get _mainCountOverride() {
          var _a3, _b2, _c;
          return (_c = (_b2 = (_a3 = this.manager.params).connectionCount) == null ? void 0 : _b2.call(_a3, "main", this.dcId, this.manager.params.isPremium)) != null ? _c : 0;
        }
        _setupMulti(kind) {
          const connection = this[kind];
          connection.on("key-change", (idx, key) => {
            if (kind !== "main") {
              this.manager._log.warn("got key-change from non-main connection, ignoring");
              return;
            }
            this.manager._log.debug("key change for dc %d from connection %d", this.dcId, idx);
            this.upload.setAuthKey(key);
            this.download.setAuthKey(key);
            this.downloadSmall.setAuthKey(key);
            Promise.resolve(this.manager._storage.provider.authKeys.set(this.dcId, key)).then(() => {
              this.upload.notifyKeyChange();
              this.download.notifyKeyChange();
              this.downloadSmall.notifyKeyChange();
            }).catch((e2) => {
              this.manager._log.warn("failed to save auth key for dc %d: %e", this.dcId, e2);
              this.manager.params.emitError(e2);
            });
          });
          connection.on("tmp-key-change", (idx, key, expires) => {
            if (kind !== "main") {
              this.manager._log.warn("got tmp-key-change from non-main connection, ignoring");
              return;
            }
            this.manager._log.debug("temp key change for dc %d from connection %d", this.dcId, idx);
            this.upload.setAuthKey(key, true);
            this.download.setAuthKey(key, true);
            this.downloadSmall.setAuthKey(key, true);
            Promise.resolve(this.manager._storage.provider.authKeys.setTemp(this.dcId, idx, key, expires * 1e3)).then(() => {
              this.upload.notifyKeyChange();
              this.download.notifyKeyChange();
              this.downloadSmall.notifyKeyChange();
            }).catch((e2) => {
              this.manager._log.warn("failed to save temp auth key %d for dc %d: %e", idx, this.dcId, e2);
              this.manager.params.emitError(e2);
            });
          });
          connection.on("future-salts", (salts) => {
            Promise.resolve(this.manager._storage.salts.store(this.dcId, salts)).catch(
              (e2) => this.manager.params.emitError(e2)
            );
          });
          connection.on("auth-begin", () => {
            if (kind !== "main") {
              this.manager._log.warn("got auth-begin from non-main connection, ignoring");
              return;
            }
            this.upload.resetAuthKeys();
            this.download.resetAuthKeys();
            this.downloadSmall.resetAuthKeys();
          });
          connection.on("request-auth", () => {
            this.main.requestAuth();
          });
          connection.on("request-keys", (promise) => {
            this.loadKeys(true).then(() => promise.resolve()).catch((e2) => promise.reject(e2));
          });
          connection.on("error", (err, conn) => {
            this.manager.params.emitError(err, conn);
          });
        }
        setIsPrimary(isPrimary) {
          var _a3;
          if (this.isPrimary === isPrimary)
            return;
          this.isPrimary = isPrimary;
          this.main.params.isMainDcConnection = isPrimary;
          if (isPrimary) {
            this.main.setInactivityTimeout(void 0);
          } else {
            this.main.setInactivityTimeout((_a3 = this.manager.params.inactivityTimeout) != null ? _a3 : 6e4);
          }
        }
        setIsPremium(isPremium) {
          this.upload.setCount(this.manager._connectionCount("upload", this.dcId, isPremium));
          this.download.setCount(this.manager._connectionCount("download", this.dcId, isPremium));
          this.downloadSmall.setCount(this.manager._connectionCount("downloadSmall", this.dcId, isPremium));
        }
        loadKeys(forcePfs = false) {
          return __async(this, null, function* () {
            const [permanent, salts] = yield Promise.all([
              this.manager._storage.provider.authKeys.get(this.dcId),
              this.manager._storage.salts.fetch(this.dcId)
            ]);
            this.main.setAuthKey(permanent);
            this.upload.setAuthKey(permanent);
            this.download.setAuthKey(permanent);
            this.downloadSmall.setAuthKey(permanent);
            if (salts) {
              this._salts.setFutureSalts(salts);
            }
            if (!permanent) {
              return false;
            }
            if (this.manager.params.usePfs || forcePfs) {
              const now2 = Date.now();
              yield Promise.all(
                this.main._sessions.map((_, i) => __async(this, null, function* () {
                  const temp = yield this.manager._storage.provider.authKeys.getTemp(this.dcId, i, now2);
                  this.main.setAuthKey(temp, true, i);
                  if (i === 0) {
                    this.upload.setAuthKey(temp, true);
                    this.download.setAuthKey(temp, true);
                    this.downloadSmall.setAuthKey(temp, true);
                  }
                }))
              );
            }
            return true;
          });
        }
        setMainConnectionCount(count2) {
          if (this._mainCountOverride > 0)
            return;
          this.main.setCount(count2);
        }
        destroy() {
          return __async(this, null, function* () {
            yield this.main.destroy();
            yield this.upload.destroy();
            yield this.download.destroy();
            yield this.downloadSmall.destroy();
            this._salts.destroy();
          });
        }
      }
      class NetworkManager {
        constructor(params, config) {
          __publicField(this, "_log");
          __publicField(this, "_storage");
          __publicField(this, "_initConnectionParams");
          __publicField(this, "_transportFactory");
          __publicField(this, "_reconnectionStrategy");
          __publicField(this, "_connectionCount");
          __publicField(this, "_dcConnections", /* @__PURE__ */ new Map());
          __publicField(this, "_primaryDc");
          __publicField(this, "_updateHandler");
          __publicField(this, "_resetOnNetworkChange");
          __publicField(this, "_dcCreationPromise", /* @__PURE__ */ new Map());
          __publicField(this, "_pendingExports", {});
          __publicField(this, "call");
          __publicField(this, "_composeCall", (middlewares) => {
            if (!middlewares) {
              middlewares = basic();
            }
            if (!middlewares.length) {
              return this._call;
            }
            const final = (ctx) => __async(this, null, function* () {
              return this._call(ctx.request, ctx.params);
            });
            const composed = composeMiddlewares(middlewares, final);
            return (message2, params) => __async(this, null, function* () {
              return composed({
                request: message2,
                manager: this,
                params
              });
            });
          });
          __publicField(this, "_call", (message2, params) => __async(this, null, function* () {
            var _a3;
            if (!this._primaryDc) {
              throw new MtcuteError("Not connected to any DC");
            }
            const kind = (_a3 = params == null ? void 0 : params.kind) != null ? _a3 : "main";
            let manager;
            if (params == null ? void 0 : params.manager) {
              manager = params.manager;
            } else if ((params == null ? void 0 : params.dcId) && params.dcId !== this._primaryDc.dcId) {
              manager = yield this._getOtherDc(params.dcId);
            } else {
              manager = this._primaryDc;
            }
            let multi = manager[kind];
            let res = yield multi.sendRpc(message2, params == null ? void 0 : params.timeout, params == null ? void 0 : params.abortSignal, params == null ? void 0 : params.chainId);
            if (!isTlRpcError(res)) {
              return res;
            }
            const err = res.errorMessage;
            if (manager === this._primaryDc) {
              if (err.startsWith("PHONE_MIGRATE_") || err.startsWith("NETWORK_MIGRATE_") || err.startsWith("USER_MIGRATE_")) {
                const newDc = Number(err.slice(err.lastIndexOf("_") + 1));
                if (Number.isNaN(newDc)) {
                  this._log.warn("invalid migrate error received: %s, ignoring", err);
                  return res;
                }
                if (params == null ? void 0 : params.localMigrate) {
                  manager = yield this._getOtherDc(newDc);
                } else {
                  this._log.info("received %s, migrating to dc %d", err, newDc);
                  yield this.changePrimaryDc(newDc);
                  manager = this._primaryDc;
                }
                multi = manager[kind];
                res = yield multi.sendRpc(message2, params == null ? void 0 : params.timeout, params == null ? void 0 : params.abortSignal, params == null ? void 0 : params.chainId);
              }
            } else if (err === "AUTH_KEY_UNREGISTERED") {
              this._log.warn("exported auth key error, trying re-exporting..");
              yield this._exportAuthTo(manager);
              res = yield multi.sendRpc(message2, params == null ? void 0 : params.timeout, params == null ? void 0 : params.abortSignal, params == null ? void 0 : params.chainId);
            }
            return res;
          }));
          var _a3, _b2, _c;
          this.params = params;
          this.config = config;
          const deviceModel = `mtcute on ${getPlatform().getDeviceModel()}`;
          this._initConnectionParams = __spreadProps(__spreadValues({
            _: "initConnection",
            deviceModel,
            systemVersion: "1.0",
            appVersion: "%VERSION%",
            systemLangCode: "en",
            langPack: "",
            // "langPacks are for official apps only"
            langCode: "en"
          }, (_a3 = params.initConnectionOptions) != null ? _a3 : {}), {
            apiId: params.apiId,
            // eslint-disable-next-line
            query: null
          });
          this._transportFactory = params.transport;
          this._reconnectionStrategy = (_b2 = params.reconnectionStrategy) != null ? _b2 : defaultReconnectionStrategy;
          this._connectionCount = (_c = params.connectionCount) != null ? _c : defaultConnectionCountDelegate;
          this._updateHandler = params.onUpdate;
          this.call = this._composeCall(params.middlewares);
          this._onConfigChanged = this._onConfigChanged.bind(this);
          config.onReload(this._onConfigChanged);
          this._log = params.log.create("network");
          this._storage = params.storage;
        }
        _findDcOptions(dcId) {
          return __async(this, null, function* () {
            const main2 = yield this.config.findOption({
              dcId,
              allowIpv6: this.params.useIpv6,
              preferIpv6: this.params.useIpv6,
              allowMedia: false,
              cdn: false
            });
            const media2 = yield this.config.findOption({
              dcId,
              allowIpv6: this.params.useIpv6,
              preferIpv6: this.params.useIpv6,
              allowMedia: true,
              preferMedia: true,
              cdn: false
            });
            if (!main2 || !media2) {
              throw new MtArgumentError(`Could not find DC ${dcId}`);
            }
            return { main: main2, media: media2 };
          });
        }
        _switchPrimaryDc(dc) {
          if (this._primaryDc && this._primaryDc !== dc) {
            this._primaryDc.setIsPrimary(false);
          }
          this._primaryDc = dc;
          dc.setIsPrimary(true);
          this.params.onConnecting();
          dc.main.on("usable", () => {
            if (dc !== this._primaryDc)
              return;
            this.params.onUsable();
          });
          dc.main.on("wait", () => {
            if (dc !== this._primaryDc)
              return;
            this.params.onConnecting();
          });
          dc.main.on("update", (update) => {
            this._updateHandler(update, false);
          });
          return dc.loadKeys().then(() => dc.main.ensureConnected());
        }
        _getOtherDc(dcId) {
          return __async(this, null, function* () {
            if (!this._dcConnections.has(dcId)) {
              if (this._dcCreationPromise.has(dcId)) {
                this._log.debug("waiting for DC %d to be created", dcId);
                yield this._dcCreationPromise.get(dcId);
                return this._dcConnections.get(dcId);
              }
              const promise = createControllablePromise();
              this._dcCreationPromise.set(dcId, promise);
              this._log.debug("creating new DC %d", dcId);
              try {
                const dcOptions = yield this._findDcOptions(dcId);
                const dc = new DcConnectionManager(this, dcId, dcOptions);
                if (!(yield dc.loadKeys())) {
                  dc.main.requestAuth();
                }
                this._dcConnections.set(dcId, dc);
                promise.resolve();
              } catch (e2) {
                promise.reject(e2);
              }
            }
            return this._dcConnections.get(dcId);
          });
        }
        /**
         * Perform initial connection to the default DC
         *
         * @param defaultDcs  Default DCs to connect to
         */
        connect(defaultDcs) {
          return __async(this, null, function* () {
            var _a3, _b2;
            if (defaultDcs.main.id !== defaultDcs.media.id) {
              throw new MtArgumentError("Default DCs must be the same");
            }
            if (this._dcConnections.has(defaultDcs.main.id)) {
              throw new MtArgumentError("DC manager already exists");
            }
            this._resetOnNetworkChange = (_b2 = (_a3 = getPlatform()).onNetworkChanged) == null ? void 0 : _b2.call(_a3, this.notifyNetworkChanged.bind(this));
            const dc = new DcConnectionManager(this, defaultDcs.main.id, defaultDcs, true);
            this._dcConnections.set(defaultDcs.main.id, dc);
            yield this._switchPrimaryDc(dc);
          });
        }
        _exportAuthTo(manager) {
          return __async(this, null, function* () {
            if (manager.dcId in this._pendingExports) {
              this._log.debug("waiting for auth export to dc %d", manager.dcId);
              return this._pendingExports[manager.dcId];
            }
            this._log.debug("exporting auth to dc %d", manager.dcId);
            const promise = createControllablePromise();
            this._pendingExports[manager.dcId] = promise;
            try {
              const auth = yield this.call({
                _: "auth.exportAuthorization",
                dcId: manager.dcId
              });
              if (isTlRpcError(auth)) {
                throw new MtcuteError(`Failed to export (${auth.errorCode}: ${auth.errorMessage})`);
              }
              const res = yield this.call(
                {
                  _: "auth.importAuthorization",
                  id: auth.id,
                  bytes: auth.bytes
                },
                { manager }
              );
              if (isTlRpcError(res)) {
                throw new MtcuteError(`Failed to import (${res.errorCode}: ${res.errorMessage})`);
              }
              assertTypeIs("auth.importAuthorization", res, "auth.authorization");
              promise.resolve();
              delete this._pendingExports[manager.dcId];
            } catch (e2) {
              this._log.warn("failed to export auth to dc %d: %s", manager.dcId, e2);
              promise.reject(e2);
              throw e2;
            }
          });
        }
        setIsPremium(isPremium) {
          this._log.debug("setting isPremium to %s", isPremium);
          this.params.isPremium = isPremium;
          for(let   dc of this._dcConnections.values()) {
            dc.setIsPremium(isPremium);
          }
        }
        notifyLoggedIn(auth) {
          var _a3;
          if (auth._ === "auth.authorizationSignUpRequired") {
            throw new MtUnsupportedError(
              "Signup is no longer supported by Telegram for non-official clients. Please use your mobile device to sign up."
            );
          }
          let user;
          if (auth._ === "auth.authorization") {
            if (auth.tmpSessions) {
              (_a3 = this._primaryDc) == null ? void 0 : _a3.setMainConnectionCount(auth.tmpSessions);
            }
            user = auth.user;
          } else {
            if (auth.bot) {
              this.config.update(true).catch((e2) => this.params.emitError(e2));
            }
            user = auth;
          }
          this.setIsPremium(user.premium);
          if (auth._ === "auth.authorization" && this.params.disableUpdates) {
            this.resetSessions();
          }
          return user;
        }
        notifyLoggedOut() {
          this.setIsPremium(false);
          this.resetSessions();
        }
        notifyNetworkChanged(connected) {
          this._log.debug("network changed: %s", connected ? "connected" : "disconnected");
          this.params.onNetworkChanged(connected);
          for(let   dc of this._dcConnections.values()) {
            dc.main.notifyNetworkChanged(connected);
            dc.upload.notifyNetworkChanged(connected);
            dc.download.notifyNetworkChanged(connected);
            dc.downloadSmall.notifyNetworkChanged(connected);
          }
        }
        resetSessions() {
          const dc = this._primaryDc;
          if (!dc)
            return;
          dc.main.resetSessions();
          dc.upload.resetSessions();
          dc.download.resetSessions();
          dc.downloadSmall.resetSessions();
        }
        _onConfigChanged(config) {
          var _a3;
          if (config.tmpSessions) {
            (_a3 = this._primaryDc) == null ? void 0 : _a3.setMainConnectionCount(config.tmpSessions);
          }
        }
        changePrimaryDc(newDc) {
          return __async(this, null, function* () {
            var _a3;
            if (newDc === ((_a3 = this._primaryDc) == null ? void 0 : _a3.dcId))
              return;
            const options2 = yield this._findDcOptions(newDc);
            if (!this._dcConnections.has(newDc)) {
              this._dcConnections.set(newDc, new DcConnectionManager(this, newDc, options2, true));
            }
            yield this._storage.dcs.store(options2);
            yield this._switchPrimaryDc(this._dcConnections.get(newDc));
          });
        }
        changeTransport(factory) {
          for(let   dc of this._dcConnections.values()) {
            dc.main.changeTransport(factory);
            dc.upload.changeTransport(factory);
            dc.download.changeTransport(factory);
            dc.downloadSmall.changeTransport(factory);
          }
        }
        getPoolSize(kind, dcId) {
          const dc = dcId ? this._dcConnections.get(dcId) : this._primaryDc;
          if (!dc) {
            if (!this._primaryDc) {
              throw new MtcuteError("Not connected to any DC");
            }
            return this._connectionCount(kind, dcId != null ? dcId : this._primaryDc.dcId, this.params.isPremium);
          }
          return dc[kind].getPoolSize();
        }
        getPrimaryDcId() {
          if (!this._primaryDc)
            throw new MtcuteError("Not connected to any DC");
          return this._primaryDc.dcId;
        }
        destroy() {
          return __async(this, null, function* () {
            var _a3;
            for(let   dc of this._dcConnections.values()) {
              yield dc.destroy();
            }
            this._dcConnections.clear();
            this.config.offReload(this._onConfigChanged);
            (_a3 = this._resetOnNetworkChange) == null ? void 0 : _a3.call(this);
          });
        }
        getMtprotoMessageId() {
          return this._primaryDc.main._sessions[0].getMessageId();
        }
      }
      class MtClient extends EventEmitter {
        constructor(params) {
          var _a3, _b2, _c, _d, _e, _f;
          super();
          /**
           * Crypto provider taken from {@link MtClientOptions.crypto}
           */
          __publicField(this, "crypto");
          /** Storage manager */
          __publicField(this, "storage");
          /**
           * "Test mode" taken from {@link MtClientOptions.testMode}
           */
          __publicField(this, "_testMode");
          /**
           * Primary DCs taken from {@link MtClientOptions.defaultDcs},
           * loaded from session or changed by other means (like redirecting).
           */
          __publicField(this, "_defaultDcs");
          /** TL layer used by the client */
          __publicField(this, "_layer");
          /** TL readers map used by the client */
          __publicField(this, "_readerMap");
          /** TL writers map used by the client */
          __publicField(this, "_writerMap");
          __publicField(this, "_config", new ConfigManager(() => __async(this, null, function* () {
            const res = yield this.call({ _: "help.getConfig" });
            if (isTlRpcError(res))
              throw new Error(`Failed to get config: ${res.errorMessage}`);
            return res;
          })));
          __publicField(this, "_emitError");
          __publicField(this, "log");
          __publicField(this, "network");
          __publicField(this, "_abortController");
          __publicField(this, "stopSignal");
          __publicField(this, "_prepare", asyncResettable(() => __async(this, null, function* () {
            var _a3, _b2;
            yield (_b2 = (_a3 = this.crypto).initialize) == null ? void 0 : _b2.call(_a3);
            yield this.storage.load();
            const primaryDc = yield this.storage.dcs.fetch();
            if (primaryDc !== null)
              this._defaultDcs = primaryDc;
          })));
          __publicField(this, "_connect", asyncResettable(() => __async(this, null, function* () {
            yield this._prepare.run();
            yield this.network.connect(this._defaultDcs);
          })));
          this.params = params;
          this.log = (_a3 = params.logger) != null ? _a3 : new LogManager();
          if (params.logLevel !== void 0) {
            this.log.mgr.level = params.logLevel;
          }
          this.crypto = params.crypto;
          this._testMode = Boolean(params.testMode);
          let dc = params.defaultDcs;
          if (!dc) {
            if (params.testMode) {
              dc = params.useIpv6 ? defaultTestIpv6Dc : defaultTestDc;
            } else {
              dc = params.useIpv6 ? defaultProductionIpv6Dc : defaultProductionDc;
            }
          }
          this._defaultDcs = dc;
          this._layer = (_b2 = params.overrideLayer) != null ? _b2 : tl.tl.LAYER;
          this._readerMap = (_c = params.readerMap) != null ? _c : __tlReaderMap;
          this._writerMap = (_d = params.writerMap) != null ? _d : __tlWriterMap;
          this._abortController = new AbortController();
          this.stopSignal = this._abortController.signal;
          this.storage = new StorageManager(__spreadValues({
            provider: params.storage,
            log: this.log,
            readerMap: this._readerMap,
            writerMap: this._writerMap
          }, params.storageOptions));
          this.network = new NetworkManager(
            __spreadValues({
              apiId: params.apiId,
              crypto: this.crypto,
              disableUpdates: (_e = params.disableUpdates) != null ? _e : false,
              initConnectionOptions: params.initConnectionOptions,
              layer: this._layer,
              log: this.log,
              readerMap: this._readerMap,
              writerMap: this._writerMap,
              reconnectionStrategy: params.reconnectionStrategy,
              storage: this.storage,
              testMode: Boolean(params.testMode),
              transport: params.transport,
              emitError: this.emitError.bind(this),
              isPremium: false,
              useIpv6: Boolean(params.useIpv6),
              enableErrorReporting: (_f = params.enableErrorReporting) != null ? _f : false,
              onUsable: () => this.emit("usable"),
              onConnecting: () => this.emit("connecting"),
              onNetworkChanged: (connected) => this.emit("networkChanged", connected),
              onUpdate: (upd) => this.emit("update", upd),
              stopSignal: this.stopSignal
            }, params.network),
            this._config
          );
        }
        emitError(err) {
          if (this._emitError) {
            this._emitError(err);
          } else if (this._connect.finished()) {
            this.log.error("unhandled error:", err);
          }
        }
        /**
         * **ADVANCED**
         *
         * Do all the preparations, but don't connect just yet.
         * Useful when you want to do some preparations before
         * connecting, like setting up session.
         *
         * Call {@link connect} to actually connect.
         */
        prepare() {
          return this._prepare.run();
        }
        /**
         * Initialize the connection to the primary DC.
         *
         * You shouldn't usually call this method directly as it is called
         * implicitly the first time you call {@link call}.
         */
        connect() {
          return __async(this, null, function* () {
            return this._connect.run();
          });
        }
        /**
         * Close all connections and finalize the client.
         */
        close() {
          return __async(this, null, function* () {
            var _a3, _b2;
            this.log.debug("closing client");
            this._config.destroy();
            yield this.network.destroy();
            yield this.storage.save();
            yield (_b2 = (_a3 = this.storage).destroy) == null ? void 0 : _b2.call(_a3);
            this._prepare.reset();
            this._connect.reset();
            this._abortController.abort();
            this.log.debug("client closed successfully");
          });
        }
        /**
         * Make an RPC call.
         *
         * The connection must have been {@link connect}-ed
         * before calling this method.
         *
         * This method is still quite low-level and you shouldn't use this
         * when using high-level API provided by `@mtcute/client`.
         *
         * @param message  RPC method to call
         * @param params  Additional call parameters
         */
        call(message2, params) {
          return __async(this, null, function* () {
            return this.network.call(message2, params);
          });
        }
        /**
         * Register an error handler for the client
         *
         * @param handler Error handler.
         */
        onError(handler) {
          this._emitError = handler;
        }
      }
      exports("ck", MtClient);
      function reportUnknownError(log, error, method) {
        if (typeof fetch !== "function")
          return;
        fetch(`https://report-rpc-error.madelineproto.xyz/?code=${error.code}&method=${method}&error=${error.text}`).then((r2) => r2.json()).then((r2) => {
          if (r2.result) {
            log.info("telerpc responded with error info for %s: %s", error.text, r2.result);
          } else {
            log.info(
              "Reported error %s to telerpc. You can disable this using `enableErrorReporting: false`",
              error.text
            );
          }
        }).catch((e2) => {
          log.debug("failed to report error %s to telerpc: %e", error.text, e2);
        });
      }
      class AppConfigManager {
        constructor(client2) {
          __publicField(this, "_reloadable", new Reloadable({
            reload: this._reload.bind(this),
            getExpiresAt: () => 36e5,
            disableAutoReload: true
          }));
          __publicField(this, "_object");
          this.client = client2;
        }
        _reload(old) {
          return __async(this, null, function* () {
            var _a3;
            const res = yield this.client.call({
              _: "help.getAppConfig",
              hash: (_a3 = old == null ? void 0 : old.hash) != null ? _a3 : 0
            });
            if (res._ === "help.appConfigNotModified")
              return old;
            return res;
          });
        }
        get() {
          return __async(this, null, function* () {
            if (!this._reloadable.isStale && this._object)
              return this._object;
            const obj = tlJsonToJson((yield this._reloadable.get()).config);
            if (!obj || typeof obj !== "object") {
              throw new MtTypeAssertionError("appConfig", "object", typeof obj);
            }
            this._object = obj;
            return this._object;
          });
        }
        getField(field, fallback) {
          return __async(this, null, function* () {
            var _a3;
            const obj = yield this.get();
            return (_a3 = obj[field]) != null ? _a3 : fallback;
          });
        }
      }
      const USERNAME_TTL = 24 * 60 * 60 * 1e3;
      function getInputPeer(dto) {
        const [type, id2] = parseMarkedPeerId(dto.id);
        switch (type) {
          case "user":
            return {
              _: "inputPeerUser",
              userId: id2,
              accessHash: longFromFastString(dto.accessHash)
            };
          case "chat":
            return {
              _: "inputPeerChat",
              chatId: id2
            };
          case "channel":
            return {
              _: "inputPeerChannel",
              channelId: id2,
              accessHash: longFromFastString(dto.accessHash)
            };
        }
      }
      class PeersService extends BaseService {
        constructor(options2, _peers, _refs, common) {
          var _a3;
          super(common);
          __publicField(this, "_cache");
          __publicField(this, "_pendingWrites", /* @__PURE__ */ new Map());
          this.options = options2;
          this._peers = _peers;
          this._refs = _refs;
          this._cache = new LruMap((_a3 = options2.cacheSize) != null ? _a3 : 100);
        }
        updatePeersFrom(obj) {
          return __async(this, null, function* () {
            var _a3, _b2;
            let count2 = 0;
            let minCount = 0;
            for(let   peer of getAllPeersFrom(obj)) {
              if (peer.min) {
                minCount += 1;
              }
              count2 += 1;
              yield this.store(peer);
            }
            if (count2 > 0) {
              yield (_b2 = (_a3 = this._driver).save) == null ? void 0 : _b2.call(_a3);
              this._log.debug("cached %d peers (%d min)", count2, minCount);
              return true;
            }
            return false;
          });
        }
        store(peer) {
          return __async(this, null, function* () {
            var _a3, _b2;
            let dto;
            let accessHash;
            switch (peer._) {
              case "user": {
                if (!peer.accessHash) {
                  this._log.warn("received user without access hash: %j", peer);
                  return;
                }
                dto = {
                  id: peer.id,
                  accessHash: longToFastString(peer.accessHash),
                  isMin: peer.min && !(peer.phone !== void 0 && peer.phone.length === 0),
                  phone: peer.phone,
                  usernames: extractUsernames(peer),
                  updated: Date.now(),
                  complete: this._serializeTl(peer)
                };
                accessHash = peer.accessHash;
                break;
              }
              case "chat":
              case "chatForbidden": {
                dto = {
                  id: -peer.id,
                  accessHash: "",
                  isMin: false,
                  // chats can't be "min"
                  updated: Date.now(),
                  complete: this._serializeTl(peer),
                  usernames: []
                };
                accessHash = Long.ZERO;
                break;
              }
              case "channel":
              case "channelForbidden": {
                if (!peer.accessHash) {
                  this._log.warn("received channel without access hash: %j", peer);
                  return;
                }
                dto = {
                  id: toggleChannelIdMark(peer.id),
                  accessHash: longToFastString(peer.accessHash),
                  isMin: peer._ === "channel" ? peer.min : false,
                  usernames: extractUsernames(peer),
                  updated: Date.now(),
                  complete: this._serializeTl(peer)
                };
                accessHash = peer.accessHash;
                break;
              }
              default:
                return;
            }
            const cached2 = this._cache.get(peer.id);
            if (cached2 && this.options.updatesWriteInterval !== 0) {
              const oldAccessHash = cached2.peer.accessHash;
              if (oldAccessHash == null ? void 0 : oldAccessHash.eq(accessHash)) {
                this._pendingWrites.set(peer.id, dto);
                cached2.complete = peer;
                return;
              }
            }
            let newComplete = peer;
            if (peer.min) {
              const existing = (_b2 = (_a3 = this._cache.get(peer.id)) == null ? void 0 : _a3.complete) != null ? _b2 : yield this.getCompleteById(peer.id);
              if (existing && !existing.min) {
                if (existing._ === "channel" && peer._ === "channel") {
                  newComplete = __spreadProps(__spreadValues({}, existing), {
                    title: peer.title,
                    megagroup: peer.megagroup,
                    color: peer.color,
                    photo: peer.photo,
                    username: peer.username,
                    usernames: peer.usernames,
                    hasGeo: peer.hasGeo,
                    noforwards: peer.noforwards,
                    emojiStatus: peer.emojiStatus,
                    hasLink: peer.hasLink,
                    slowmodeEnabled: peer.slowmodeEnabled,
                    scam: peer.scam,
                    fake: peer.fake,
                    gigagroup: peer.gigagroup,
                    forum: peer.forum,
                    level: peer.level,
                    restricted: peer.restricted,
                    restrictionReason: peer.restrictionReason,
                    joinToSend: peer.joinToSend,
                    joinRequest: peer.joinRequest,
                    verified: peer.verified,
                    defaultBannedRights: peer.defaultBannedRights
                  });
                } else if (existing._ === "user" && peer._ === "user") {
                  newComplete = __spreadProps(__spreadValues({}, existing), {
                    deleted: peer.deleted,
                    bot: peer.bot,
                    botChatHistory: peer.botChatHistory,
                    botNochats: peer.botNochats,
                    verified: peer.verified,
                    restricted: peer.restricted,
                    botInlineGeo: peer.botInlineGeo,
                    support: peer.support,
                    scam: peer.scam,
                    fake: peer.fake,
                    botAttachMenu: peer.botAttachMenu,
                    premium: peer.premium,
                    storiesUnavailable: peer.storiesUnavailable,
                    contactRequirePremium: peer.contactRequirePremium,
                    botBusiness: peer.botBusiness,
                    botHasMainApp: peer.botHasMainApp,
                    photo: peer.applyMinPhoto ? peer.photo : existing.photo,
                    status: !existing.status || existing.status._ === "userStatusEmpty" ? peer.status : existing.status,
                    botInfoVersion: peer.botInfoVersion,
                    restrictionReason: peer.restrictionReason,
                    botInlinePlaceholder: peer.botInlinePlaceholder,
                    langCode: peer.langCode,
                    emojiStatus: peer.emojiStatus,
                    color: peer.color,
                    profileColor: peer.profileColor,
                    botActiveUsers: peer.botActiveUsers
                  });
                }
              }
            }
            yield this._peers.store(dto);
            this._cache.set(peer.id, {
              peer: getInputPeer(dto),
              complete: newComplete
            });
            yield this._refs.deleteByPeer(peer.id);
          });
        }
        _returnCaching(id2, dto) {
          const peer = getInputPeer(dto);
          const complete = this._deserializeTl(dto.complete);
          this._cache.set(id2, {
            peer,
            complete
          });
          return peer;
        }
        getById(id2, allowRefs = true) {
          return __async(this, null, function* () {
            const cached2 = this._cache.get(id2);
            if (cached2)
              return cached2.peer;
            const dto = yield this._peers.getById(id2, false);
            if (dto) {
              return this._returnCaching(id2, dto);
            }
            if (allowRefs) {
              const ref = yield this._refs.getForPeer(id2);
              if (!ref)
                return null;
              const [chatId, msgId] = ref;
              const chat2 = yield this.getById(chatId, false);
              if (!chat2)
                return null;
              if (id2 > 0) {
                return {
                  _: "inputPeerUserFromMessage",
                  peer: chat2,
                  msgId,
                  userId: id2
                };
              }
              return {
                _: "inputPeerChannelFromMessage",
                peer: chat2,
                msgId,
                channelId: toggleChannelIdMark(id2)
              };
            }
            return null;
          });
        }
        getByPhone(phone) {
          return __async(this, null, function* () {
            const dto = yield this._peers.getByPhone(phone);
            if (!dto)
              return null;
            return this._returnCaching(dto.id, dto);
          });
        }
        getByUsername(username2) {
          return __async(this, null, function* () {
            const dto = yield this._peers.getByUsername(username2.toLowerCase());
            if (!dto)
              return null;
            if (Date.now() - dto.updated > USERNAME_TTL) {
              return null;
            }
            return this._returnCaching(dto.id, dto);
          });
        }
        getCompleteById(id2, allowMin = false) {
          return __async(this, null, function* () {
            const cached2 = this._cache.get(id2);
            if (cached2)
              return cached2.complete;
            const dto = yield this._peers.getById(id2, allowMin);
            if (!dto)
              return null;
            const cacheItem = {
              peer: getInputPeer(dto),
              complete: this._deserializeTl(dto.complete)
            };
            this._cache.set(id2, cacheItem);
            return cacheItem.complete;
          });
        }
      }
      class RefMessagesService extends BaseService {
        constructor(options2, _refs, common) {
          var _a3;
          super(common);
          __publicField(this, "_cache");
          this.options = options2;
          this._refs = _refs;
          this._cache = new LruMap((_a3 = options2.cacheSize) != null ? _a3 : 1e3);
        }
        store(peerId, chatId, msgId) {
          return __async(this, null, function* () {
            yield this._refs.store(peerId, chatId, msgId);
            this._cache.set(peerId, [chatId, msgId]);
          });
        }
        getForPeer(peerId) {
          return __async(this, null, function* () {
            const cached2 = this._cache.get(peerId);
            if (cached2)
              return cached2;
            const ref = yield this._refs.getByPeer(peerId);
            if (ref)
              this._cache.set(peerId, ref);
            return ref;
          });
        }
        delete(chatId, msgIds) {
          return __async(this, null, function* () {
            yield this._refs.delete(chatId, msgIds);
            this._cache.clear();
          });
        }
        deleteByPeer(peerId) {
          return __async(this, null, function* () {
            yield this._refs.deleteByPeer(peerId);
            this._cache.delete(peerId);
          });
        }
      }
      class TelegramStorageManager {
        constructor(mt, options2) {
          __publicField(this, "provider");
          __publicField(this, "updates");
          __publicField(this, "self");
          __publicField(this, "refMsgs");
          __publicField(this, "peers");
          var _a3, _b2;
          this.mt = mt;
          this.options = options2;
          this.provider = this.options.provider;
          const serviceOptions = {
            driver: this.mt.driver,
            readerMap: this.mt.options.readerMap,
            writerMap: this.mt.options.writerMap,
            log: this.mt.log
          };
          this.updates = new UpdatesStateService(this.provider.kv, serviceOptions);
          this.self = new CurrentUserService(this.provider.kv, serviceOptions);
          this.refMsgs = new RefMessagesService(
            (_a3 = this.options.refMessages) != null ? _a3 : {},
            this.provider.refMessages,
            serviceOptions
          );
          this.peers = new PeersService(
            (_b2 = this.options.peers) != null ? _b2 : {},
            this.provider.peers,
            this.refMsgs,
            serviceOptions
          );
        }
        clear(withAuthKeys = false) {
          return __async(this, null, function* () {
            yield this.provider.peers.deleteAll();
            yield this.provider.refMessages.deleteAll();
            yield this.mt.clear(withAuthKeys);
          });
        }
      }
      exports("d6", TelegramStorageManager);
      const ERROR_MSG = "Given peer is not available in this index. This is most likely an internal library error.";
      class PeersIndex {
        constructor(users = /* @__PURE__ */ new Map(), chats = /* @__PURE__ */ new Map()) {
          __publicField(this, "hasMin", false);
          this.users = users;
          this.chats = chats;
        }
        static from(obj) {
          var _a3, _b2;
          const index = new PeersIndex();
          (_a3 = obj.users) == null ? void 0 : _a3.forEach((user) => {
            index.users.set(user.id, user);
            if (user.min) {
              index.hasMin = true;
            }
          });
          (_b2 = obj.chats) == null ? void 0 : _b2.forEach((chat2) => {
            index.chats.set(chat2.id, chat2);
            if (chat2.min) {
              index.hasMin = true;
            }
          });
          return index;
        }
        get empty() {
          return this.users.size === 0 && this.chats.size === 0;
        }
        user(id2) {
          const r2 = this.users.get(id2);
          if (!r2) {
            throw new MtArgumentError(ERROR_MSG);
          }
          return r2;
        }
        chat(id2) {
          const r2 = this.chats.get(id2);
          if (!r2) {
            throw new MtArgumentError(ERROR_MSG);
          }
          return r2;
        }
        get(peer) {
          switch (peer._) {
            case "peerUser":
              return this.user(peer.userId);
            case "peerChat":
              return this.chat(peer.chatId);
            case "peerChannel":
              return this.chat(peer.channelId);
          }
        }
      }
      exports("cz", PeersIndex);
      function batchedQuery(params) {
        const { inputKey, outputKey, fetch: fetch2, maxBatchSize = Infinity, maxConcurrent = 1, retrySingleOnError } = params;
        const symbol = Symbol("batchedQueryState");
        function getState(client_) {
          const client2 = client_;
          if (!client2[symbol]) {
            client2[symbol] = {
              waiters: /* @__PURE__ */ new Map(),
              fetchingKeys: /* @__PURE__ */ new Set(),
              retryQueue: new Deque(),
              numRunning: 0
            };
          }
          return client2[symbol];
        }
        function addWaiter(client2, waiters, item2) {
          const key = inputKey(item2, client2);
          let arr = waiters.get(key);
          if (!arr) {
            arr = [];
            waiters.set(key, arr);
          }
          return new Promise((resolve, reject) => {
            arr.push([item2, resolve, reject]);
          });
        }
        function popWaiters(waiters, key) {
          const arr = waiters.get(key);
          if (!arr)
            return [];
          waiters.delete(key);
          return arr;
        }
        function startLoops(client2, state) {
          for (let i = state.numRunning; i <= maxConcurrent; i++) {
            processPending(client2, state);
          }
        }
        function processPending(client2, state) {
          const { waiters, fetchingKeys, retryQueue } = state;
          if (state.numRunning >= maxConcurrent)
            return;
          const request = [];
          const requestKeys = [];
          let isRetryRequest = false;
          if (retryQueue.length > 0) {
            isRetryRequest = true;
            const it = retryQueue.popFront();
            request.push(it);
            const key = inputKey(it, client2);
            requestKeys.push(key);
            fetchingKeys.add(key);
          } else {
            for(let   it of waiters.keys()) {
              if (fetchingKeys.has(it))
                continue;
              request.push(waiters.get(it)[0][0]);
              requestKeys.push(it);
              fetchingKeys.add(it);
              if (request.length === maxBatchSize)
                break;
            }
            if (request.length === 0)
              return;
          }
          state.numRunning += 1;
          fetch2(client2, request).then((res) => {
            const receivedKeys = /* @__PURE__ */ new Set();
            for(let   it of res) {
              const key = outputKey(it, client2);
              receivedKeys.add(key);
              for(let   waiter of popWaiters(waiters, key)) {
                waiter[1](it);
              }
              fetchingKeys.delete(key);
            }
            for(let   key of requestKeys) {
              if (!receivedKeys.has(key)) {
                for(let   waiter of popWaiters(waiters, key)) {
                  waiter[1](null);
                }
                fetchingKeys.delete(key);
              }
            }
          }).catch((err) => {
            if (retrySingleOnError && !isRetryRequest) {
              const retry = retrySingleOnError(request, err);
              if (retry === true) {
                for(let   it of request) {
                  retryQueue.pushBack(it);
                }
                return;
              } else if (Array.isArray(retry)) {
                for(let   req of retry) {
                  const requestKeysIdx = request.indexOf(req);
                  if (requestKeysIdx < 0)
                    continue;
                  retryQueue.pushBack(req);
                  request.splice(requestKeysIdx, 1);
                  requestKeys.splice(requestKeysIdx, 1);
                }
              }
            }
            for(let   key of requestKeys) {
              for(let   waiter of popWaiters(waiters, key)) {
                waiter[2](err);
              }
              fetchingKeys.delete(key);
            }
          }).then(() => {
            state.numRunning -= 1;
            if (waiters.size > 0)
              processPending(client2, state);
          });
        }
        return function(client2, item2) {
          const state = getState(client2);
          const promise = addWaiter(client2, state.waiters, item2);
          startLoops(client2, state);
          return promise;
        };
      }
      const _getUsersBatched = batchedQuery({
        fetch: (client2, items) => client2.call({
          _: "users.getUsers",
          id: items
          // there's actually not much point in filtering, since telegram currently simply omits the missing users
          // but maybe it will change in the future and i don't want to think about it
        }).then((res) => res.filter((it) => it._ !== "userEmpty")),
        inputKey: (item2, client2) => {
          switch (item2._) {
            case "inputUser":
            case "inputUserFromMessage":
              return item2.userId;
            case "inputUserSelf":
              return client2.storage.self.getCached().userId;
            default:
              throw new MtArgumentError("Invalid input user");
          }
        },
        outputKey: (item2) => item2.id,
        maxBatchSize: 50,
        maxConcurrent: 3,
        retrySingleOnError: (items, err) => {
          if (!tl.tl.RpcError.is(err))
            return false;
          let fromMessageCount = 0;
          for(let   item2 of items) {
            if (item2._ === "inputUserFromMessage")
              fromMessageCount++;
          }
          if (fromMessageCount === 0) {
            return false;
          }
          switch (err.text) {
            case "CHANNEL_INVALID":
            case "USER_BANNED_IN_CHANNEL":
            case "CHANNEL_PRIVATE":
            case "MSG_ID_INVALID":
              return true;
            default:
              return false;
          }
        }
      });
      const _getChatsBatched = batchedQuery({
        fetch: (client2, items) => client2.call({
          _: "messages.getChats",
          id: items
        }).then((res) => res.chats.filter((it) => it._ === "chat")),
        inputKey: (id2) => id2,
        outputKey: (item2) => item2.id,
        maxBatchSize: 50,
        maxConcurrent: 3
      });
      const _getChannelsBatched = batchedQuery({
        fetch: (client2, items) => client2.call({
          _: "channels.getChannels",
          id: items
        }).then(
          (res) => res.chats.filter(
            (it) => it._ === "channel" || it._ === "channelForbidden"
          )
        ),
        inputKey: (id2) => {
          switch (id2._) {
            case "inputChannel":
            case "inputChannelFromMessage":
              return id2.channelId;
            default:
              throw new MtArgumentError("Invalid input channel");
          }
        },
        outputKey: (item2) => item2.id,
        maxBatchSize: 50,
        maxConcurrent: 3,
        retrySingleOnError: (items, err) => {
          if (!tl.tl.RpcError.is(err))
            return false;
          let fromMessageCount = 0;
          for(let   item2 of items) {
            if (item2._ === "inputChannelFromMessage")
              fromMessageCount++;
          }
          if (fromMessageCount === 0) {
            return false;
          }
          switch (err.text) {
            case "CHANNEL_INVALID":
            case "USER_BANNED_IN_CHANNEL":
            case "CHANNEL_PRIVATE":
            case "MSG_ID_INVALID":
              return true;
            default:
              return false;
          }
        }
      });
      function _getRawPeerBatched(client2, peer) {
        if (isInputPeerUser(peer)) {
          return _getUsersBatched(client2, toInputUser(peer));
        } else if (isInputPeerChannel(peer)) {
          return _getChannelsBatched(client2, toInputChannel(peer));
        } else if (isInputPeerChat(peer)) {
          return _getChatsBatched(client2, peer.chatId);
        }
        throw new MtArgumentError("Invalid peer");
      }
      function messageToUpdate(message2) {
        switch (message2.peerId._) {
          case "peerUser":
          case "peerChat":
            return {
              _: "updateNewMessage",
              message: message2,
              pts: 0,
              ptsCount: 0
            };
          case "peerChannel":
            return {
              _: "updateNewChannelMessage",
              message: message2,
              pts: 0,
              ptsCount: 0
            };
        }
      }
      function extractChannelIdFromUpdate(upd) {
        let res = 0;
        if ("channelId" in upd) {
          res = upd.channelId;
        } else if ("message" in upd && typeof upd.message !== "string" && "peerId" in upd.message && upd.message.peerId && "channelId" in upd.message.peerId) {
          res = upd.message.peerId.channelId;
        }
        if (res === 0)
          return void 0;
        return res;
      }
      function toPendingUpdate(upd, peers, fromDifference = false) {
        const channelId = extractChannelIdFromUpdate(upd) || 0;
        const pts = "pts" in upd ? upd.pts : void 0;
        const ptsCount = "ptsCount" in upd ? upd.ptsCount : pts ? 0 : void 0;
        const qts = "qts" in upd ? upd.qts : void 0;
        return {
          update: upd,
          channelId,
          pts,
          ptsBefore: pts ? pts - ptsCount : void 0,
          qts,
          qtsBefore: qts ? qts - 1 : void 0,
          peers,
          fromDifference
        };
      }
      function isMessageEmpty(upd) {
        var _a3;
        return ((_a3 = upd.message) == null ? void 0 : _a3._) === "messageEmpty";
      }
      function createDummyUpdatesContainer(updates, seq = 0) {
        return {
          _: "updates",
          seq,
          date: 0,
          chats: [],
          users: [],
          updates
        };
      }
      function createDummyUpdate(pts, ptsCount, channelId = 0) {
        return createDummyUpdatesContainer([
          {
            _: "mtcute.dummyUpdate",
            channelId,
            pts,
            ptsCount
          }
        ]);
      }
      function assertIsUpdatesGroup(ctx, upd) {
        switch (upd._) {
          case "updates":
          case "updatesCombined":
            return;
        }
        throw new MtTypeAssertionError(ctx, "updates | updatesCombined", upd._);
      }
      const KEEP_ALIVE_INTERVAL = 15 * 60 * 1e3;
      const UPDATES_TOO_LONG = { _: "updatesTooLong" };
      class UpdatesManager {
        constructor(client2, params = {}) {
          __publicField(this, "updatesLoopActive", false);
          __publicField(this, "updatesLoopCv", new ConditionVariable());
          __publicField(this, "postponedTimer", new EarlyTimer());
          __publicField(this, "hasTimedoutPostponed", false);
          __publicField(this, "pendingUpdateContainers", new SortedLinkedList((a, b) => a.seqStart - b.seqStart));
          __publicField(this, "pendingPtsUpdates", new SortedLinkedList((a, b) => a.ptsBefore - b.ptsBefore));
          __publicField(this, "pendingPtsUpdatesPostponed", new SortedLinkedList((a, b) => a.ptsBefore - b.ptsBefore));
          __publicField(this, "pendingQtsUpdates", new SortedLinkedList((a, b) => a.qtsBefore - b.qtsBefore));
          __publicField(this, "pendingQtsUpdatesPostponed", new SortedLinkedList((a, b) => a.qtsBefore - b.qtsBefore));
          __publicField(this, "pendingUnorderedUpdates", new Deque());
          __publicField(this, "noDispatchEnabled");
          // channel id or 0 => msg id
          __publicField(this, "noDispatchMsg", /* @__PURE__ */ new Map());
          // channel id or 0 => pts
          __publicField(this, "noDispatchPts", /* @__PURE__ */ new Map());
          __publicField(this, "noDispatchQts", /* @__PURE__ */ new Set());
          __publicField(this, "lock", new AsyncLock());
          // rpsIncoming?: RpsMeter
          // rpsProcessing?: RpsMeter
          // accessing storage every time might be expensive,
          // so store everything here, and load & save
          // every time session is loaded & saved.
          __publicField(this, "pts");
          __publicField(this, "qts");
          __publicField(this, "date");
          __publicField(this, "seq");
          // old values of the updates state (i.e. as in DB)
          // used to avoid redundant storage calls
          __publicField(this, "oldPts");
          __publicField(this, "oldQts");
          __publicField(this, "oldDate");
          __publicField(this, "oldSeq");
          // whether to catch up channels from the locally stored pts
          __publicField(this, "catchingUp", false);
          __publicField(this, "catchUpOnStart");
          __publicField(this, "cpts", /* @__PURE__ */ new Map());
          __publicField(this, "cptsMod", /* @__PURE__ */ new Map());
          __publicField(this, "channelDiffTimeouts", /* @__PURE__ */ new Map());
          __publicField(this, "channelsOpened", /* @__PURE__ */ new Map());
          __publicField(this, "log");
          __publicField(this, "_handler", () => {
          });
          __publicField(this, "_onCatchingUp", () => {
          });
          // eslint-disable-next-line ts/no-unsafe-function-type
          __publicField(this, "_channelPtsLimit");
          __publicField(this, "auth");
          // todo: do we need a local copy?
          __publicField(this, "keepAliveInterval");
          var _a3;
          this.client = client2;
          this.params = params;
          if (client2.params.disableUpdates) {
            throw new MtArgumentError("Updates must be enabled to use updates manager");
          }
          this._onKeepAlive = this._onKeepAlive.bind(this);
          this.postponedTimer.onTimeout(() => {
            this.hasTimedoutPostponed = true;
            this.updatesLoopCv.notify();
          });
          this.log = client2.log.create("updates");
          this.catchUpOnStart = (_a3 = params.catchUp) != null ? _a3 : false;
          this.noDispatchEnabled = !params.disableNoDispatch;
          if (params.channelPtsLimit) {
            if (typeof params.channelPtsLimit === "function") {
              this._channelPtsLimit = params.channelPtsLimit;
            } else {
              const limit = params.channelPtsLimit;
              this._channelPtsLimit = () => limit;
            }
          } else {
            this._channelPtsLimit = () => {
              var _a4;
              return ((_a4 = this.auth) == null ? void 0 : _a4.isBot) ? 1e5 : 100;
            };
          }
        }
        setHandler(handler) {
          this._handler = handler;
        }
        getHandler() {
          return this._handler;
        }
        onCatchingUp(handler) {
          this._onCatchingUp = handler;
        }
        destroy() {
          this.stopLoop();
        }
        notifyLoggedIn(self2) {
          this.auth = self2;
          this.startLoop().catch((err) => this.client.emitError(err));
        }
        notifyLoggedOut() {
          this.stopLoop();
          this.cpts.clear();
          this.cptsMod.clear();
          this.pts = this.qts = this.date = this.seq = void 0;
        }
        prepare() {
          return __async(this, null, function* () {
            yield this._loadUpdatesStorage();
          });
        }
        _onKeepAlive() {
          this.log.debug("no updates for >15 minutes, catching up");
          this.handleUpdate(UPDATES_TOO_LONG);
        }
        /**
         * Start updates loop.
         *
         * You must first call {@link enableUpdatesProcessing} to use this method.
         *
         * It is recommended to use this method in callback to {@link start},
         * or otherwise make sure the user is logged in.
         *
         * > **Note**: If you are using {@link UpdatesManagerParams.catchUp} option,
         * > catching up will be done in background, you can't await it.
         * > Instead, listen for the `updating` and `connected` connection state events.
         */
        startLoop() {
          return __async(this, null, function* () {
            if (this.updatesLoopActive)
              return;
            if (!this.catchUpOnStart) {
              yield this._fetchUpdatesState();
            }
            this.updatesLoopActive = true;
            clearIntervalWrap(this.keepAliveInterval);
            this.keepAliveInterval = setIntervalWrap(this._onKeepAlive, KEEP_ALIVE_INTERVAL);
            this._loop().catch((err) => this.client.emitError(err));
            if (this.catchUpOnStart) {
              this.catchUp();
            }
          });
        }
        /**
         * **ADVANCED**
         *
         * Manually stop updates loop.
         * Usually done automatically when stopping the client with {@link close}
         */
        stopLoop() {
          if (!this.updatesLoopActive)
            return;
          clearIntervalWrap(this.keepAliveInterval);
          for(let   timer of this.channelDiffTimeouts.values()) {
            clearTimeoutWrap(timer);
          }
          this.channelDiffTimeouts.clear();
          this.updatesLoopActive = false;
          this.pendingUpdateContainers.clear();
          this.pendingUnorderedUpdates.clear();
          this.pendingPtsUpdates.clear();
          this.pendingQtsUpdates.clear();
          this.pendingPtsUpdatesPostponed.clear();
          this.pendingQtsUpdatesPostponed.clear();
          this.postponedTimer.reset();
          this.updatesLoopCv.notify();
        }
        /**
         * Catch up with the server by loading missed updates.
         *.
         * > **Note**: In case the storage was not properly
         * > closed the last time, "catching up" might
         * > result in duplicate updates.
         */
        catchUp() {
          if (!this.updatesLoopActive) {
            this.log.warn("catch up requested, but updates loop is not active, ignoring");
            return;
          }
          this.log.debug("catch up requested");
          this._onCatchingUp(true);
          this.catchingUp = true;
          this.handleUpdate(UPDATES_TOO_LONG);
        }
        handleClientUpdate(update, noDispatch = true) {
          if (noDispatch && this.noDispatchEnabled) {
            this._addToNoDispatchIndex(update);
          }
          this.handleUpdate(update);
        }
        handleUpdate(update) {
          this.log.debug(
            "received %s, queueing for processing. containers queue size: %d",
            update._,
            this.pendingUpdateContainers.length
          );
          switch (update._) {
            case "updatesTooLong":
            case "updateShortMessage":
            case "updateShortChatMessage":
            case "updateShort":
            case "updateShortSentMessage":
              this.pendingUpdateContainers.add({
                upd: update,
                seqStart: 0,
                seqEnd: 0
              });
              break;
            case "updates":
            case "updatesCombined":
              this.pendingUpdateContainers.add({
                upd: update,
                seqStart: update._ === "updatesCombined" ? update.seqStart : update.seq,
                seqEnd: update.seq
              });
              break;
            default:
              assertNever$1();
          }
          this.updatesLoopCv.notify();
        }
        /**
         * **ADVANCED**
         *
         * Notify the updates manager that some channel was "opened".
         * Channel difference for "opened" channels will be fetched on a regular basis.
         * This is a low-level method, prefer using {@link openChat} instead.
         *
         * Channel must be resolve-able with `resolvePeer` method (i.e. be in cache);
         * base chat PTS must either be passed (e.g. from {@link Dialog}), or cached in storage.
         *
         * @param channelId  Bare ID of the channel
         * @param pts  PTS of the channel, if known (e.g. from {@link Dialog})
         * @returns `true` if the channel was opened for the first time, `false` if it is already opened
         */
        notifyChannelOpened(channelId, pts) {
          if (this.channelsOpened.has(channelId)) {
            this.log.debug("channel %d opened again", channelId);
            this.channelsOpened.set(channelId, this.channelsOpened.get(channelId) + 1);
            return false;
          }
          this.channelsOpened.set(channelId, 1);
          this.log.debug("channel %d opened (pts=%d)", channelId, pts);
          this._fetchChannelDifferenceViaUpdate(channelId, pts);
          return true;
        }
        /**
         * **ADVANCED**
         *
         * Notify the updates manager that some channel was "closed".
         * Basically the opposite of {@link notifyChannelOpened}.
         * This is a low-level method, prefer using {@link closeChat} instead.
         *
         * @param channelId  Bare channel ID
         * @returns `true` if the chat was closed for the last time, `false` otherwise
         */
        notifyChannelClosed(channelId) {
          const opened = this.channelsOpened.get(channelId);
          if (opened === void 0) {
            return false;
          }
          if (opened > 1) {
            this.log.debug("channel %d closed, but is opened %d more times", channelId, opened - 1);
            this.channelsOpened.set(channelId, opened - 1);
            return false;
          }
          this.channelsOpened.delete(channelId);
          this.log.debug("channel %d closed", channelId);
          return true;
        }
        /// /////////////////////////////////////////// IMPLEMENTATION //////////////////////////////////////////////
        _fetchUpdatesState() {
          return __async(this, null, function* () {
            const { client: client2, lock, log } = this;
            yield lock.acquire();
            log.debug("fetching initial state");
            try {
              let fetchedState = yield client2.call({ _: "updates.getState" });
              log.debug(
                "updates.getState returned state: pts=%d, qts=%d, date=%d, seq=%d",
                fetchedState.pts,
                fetchedState.qts,
                fetchedState.date,
                fetchedState.seq
              );
              const diff = yield client2.call({
                _: "updates.getDifference",
                pts: fetchedState.pts,
                qts: fetchedState.qts,
                date: fetchedState.date
              });
              switch (diff._) {
                case "updates.differenceEmpty":
                  break;
                case "updates.differenceTooLong":
                  fetchedState.pts = diff.pts;
                  break;
                case "updates.differenceSlice":
                  fetchedState = diff.intermediateState;
                  break;
                case "updates.difference":
                  fetchedState = diff.state;
                  break;
                default:
                  assertNever$1(diff);
              }
              this.qts = fetchedState.qts;
              this.pts = fetchedState.pts;
              this.date = fetchedState.date;
              this.seq = fetchedState.seq;
              log.debug("loaded initial state: pts=%d, qts=%d, date=%d, seq=%d", this.pts, this.qts, this.date, this.seq);
            } catch (e2) {
              if (tl.tl.RpcError.is(e2, "AUTH_KEY_UNREGISTERED")) {
                lock.release();
                this.stopLoop();
                return;
              }
              if (this.client.isConnected) {
                log.error("failed to fetch updates state: %s", e2);
              }
              lock.release();
              throw e2;
            }
            lock.release();
          });
        }
        _loadUpdatesStorage() {
          return __async(this, null, function* () {
            const storedState = yield this.client.storage.updates.getState();
            if (storedState) {
              this.pts = this.oldPts = storedState[0];
              this.qts = this.oldQts = storedState[1];
              this.date = this.oldDate = storedState[2];
              this.seq = this.oldSeq = storedState[3];
              this.log.debug(
                "loaded stored state: pts=%d, qts=%d, date=%d, seq=%d",
                storedState[0],
                storedState[1],
                storedState[2],
                storedState[3]
              );
            }
          });
        }
        _saveUpdatesStorage(save = false) {
          return __async(this, null, function* () {
            const { client: client2 } = this;
            if (this.pts !== void 0) {
              if (this.oldPts === void 0 || this.oldPts !== this.pts) {
                yield client2.storage.updates.setPts(this.pts);
              }
              if (this.oldQts === void 0 || this.oldQts !== this.qts) {
                yield client2.storage.updates.setQts(this.qts);
              }
              if (this.oldDate === void 0 || this.oldDate !== this.date) {
                yield client2.storage.updates.setDate(this.date);
              }
              if (this.oldSeq === void 0 || this.oldSeq !== this.seq) {
                yield client2.storage.updates.setSeq(this.seq);
              }
              this.oldPts = this.pts;
              this.oldQts = this.qts;
              this.oldDate = this.date;
              this.oldSeq = this.seq;
              yield client2.storage.updates.setManyChannelPts(this.cptsMod);
              this.cptsMod.clear();
              if (save) {
                yield client2.mt.storage.save();
              }
            }
          });
        }
        _addToNoDispatchIndex(updates) {
          if (!updates)
            return;
          const { noDispatchMsg, noDispatchPts, noDispatchQts } = this;
          const addUpdate = (upd) => {
            var _a3, _b2;
            const channelId = (_a3 = extractChannelIdFromUpdate(upd)) != null ? _a3 : 0;
            const pts = "pts" in upd ? upd.pts : void 0;
            if (pts) {
              const set2 = noDispatchPts.get(channelId);
              if (!set2)
                noDispatchPts.set(channelId, /* @__PURE__ */ new Set([pts]));
              else
                set2.add(pts);
            }
            const qts = "qts" in upd ? upd.qts : void 0;
            if (qts) {
              noDispatchQts.add(qts);
            }
            switch (upd._) {
              case "updateNewMessage":
              case "updateNewChannelMessage":
              case "updateBotNewBusinessMessage": {
                const channelId2 = ((_b2 = upd.message.peerId) == null ? void 0 : _b2._) === "peerChannel" ? upd.message.peerId.channelId : 0;
                const set2 = noDispatchMsg.get(channelId2);
                if (!set2)
                  noDispatchMsg.set(channelId2, /* @__PURE__ */ new Set([upd.message.id]));
                else
                  set2.add(upd.message.id);
                break;
              }
            }
          };
          switch (updates._) {
            case "updates":
            case "updatesCombined":
              updates.updates.forEach(addUpdate);
              break;
            case "updateShortMessage":
            case "updateShortChatMessage":
            case "updateShortSentMessage": {
              let set2 = noDispatchMsg.get(0);
              if (!set2)
                noDispatchMsg.set(0, /* @__PURE__ */ new Set([updates.id]));
              else
                set2.add(updates.id);
              set2 = noDispatchPts.get(0);
              if (!set2)
                noDispatchPts.set(0, /* @__PURE__ */ new Set([updates.pts]));
              else
                set2.add(updates.pts);
              break;
            }
            case "updateShort":
              addUpdate(updates.update);
              break;
            case "updatesTooLong":
              break;
            default:
              assertNever$1();
          }
        }
        _fetchMissingPeers(upd, peers, fromDifference = false) {
          return __async(this, null, function* () {
            const { client: client2, log } = this;
            const missing = /* @__PURE__ */ new Set();
            function fetchPeer(peer, allowZeroHash = false) {
              return __async(this, null, function* () {
                if (!peer)
                  return true;
                const bare = typeof peer === "number" ? parseMarkedPeerId(peer)[1] : getBarePeerId(peer);
                const marked = typeof peer === "number" ? peer : getMarkedPeerId(peer);
                const index = marked > 0 ? peers.users : peers.chats;
                const fromIndex = index.get(bare);
                if (fromIndex && !fromIndex.min)
                  return true;
                if (missing.has(marked))
                  return false;
                const cached2 = yield client2.storage.peers.getCompleteById(marked);
                if (!cached2) {
                  if (fromDifference && allowZeroHash && parseMarkedPeerId(marked)[0] === "channel") {
                    log.debug("trying to fetch peer %d with zero access hash", marked);
                    const fetched = yield _getChannelsBatched(client2, {
                      _: "inputChannel",
                      channelId: bare,
                      accessHash: Long.ZERO
                    });
                    if ((fetched == null ? void 0 : fetched._) === "channel" && !fetched.min) {
                      index.set(bare, fetched);
                      return true;
                    }
                  }
                  missing.add(marked);
                  return fromDifference;
                }
                index.set(bare, cached2);
                return true;
              });
            }
            switch (upd._) {
              case "updateNewMessage":
              case "updateNewChannelMessage":
              case "updateEditMessage":
              case "updateEditChannelMessage": {
                const msg = upd.message;
                if (msg._ === "messageEmpty")
                  return missing;
                if (!(yield fetchPeer(msg.peerId, true)))
                  return missing;
                if (!(yield fetchPeer(msg.fromId)))
                  return missing;
                if (msg.replyTo) {
                  if (msg.replyTo._ === "messageReplyHeader" && !(yield fetchPeer(msg.replyTo.replyToPeerId))) {
                    return missing;
                  }
                  if (msg.replyTo._ === "messageReplyStoryHeader" && !(yield fetchPeer(msg.replyTo.peer))) {
                    return missing;
                  }
                }
                if (msg._ !== "messageService") {
                  if (msg.fwdFrom && (!(yield fetchPeer(msg.fwdFrom.fromId)) || !(yield fetchPeer(msg.fwdFrom.savedFromPeer, true)))) {
                    return missing;
                  }
                  if (!(yield fetchPeer(msg.viaBotId)))
                    return missing;
                  if (msg.entities) {
                    for(let   ent of msg.entities) {
                      if (ent._ === "messageEntityMentionName") {
                        if (!(yield fetchPeer(ent.userId)))
                          return missing;
                      }
                    }
                  }
                  if (msg.media) {
                    switch (msg.media._) {
                      case "messageMediaContact":
                        if (msg.media.userId && !(yield fetchPeer(msg.media.userId))) {
                          return missing;
                        }
                    }
                  }
                } else {
                  switch (msg.action._) {
                    case "messageActionChatCreate":
                    case "messageActionChatAddUser":
                    case "messageActionInviteToGroupCall":
                      for(let   user of msg.action.users) {
                        if (!(yield fetchPeer(user)))
                          return missing;
                      }
                      break;
                    case "messageActionChatJoinedByLink":
                      if (!(yield fetchPeer(msg.action.inviterId))) {
                        return missing;
                      }
                      break;
                    case "messageActionChatDeleteUser":
                      if (!(yield fetchPeer(msg.action.userId)))
                        return missing;
                      break;
                    case "messageActionChatMigrateTo":
                      if (!(yield fetchPeer(toggleChannelIdMark(msg.action.channelId), true))) {
                        return missing;
                      }
                      break;
                    case "messageActionChannelMigrateFrom":
                      if (!(yield fetchPeer(-msg.action.chatId)))
                        return missing;
                      break;
                    case "messageActionGeoProximityReached":
                      if (!(yield fetchPeer(msg.action.fromId)))
                        return missing;
                      if (!(yield fetchPeer(msg.action.toId)))
                        return missing;
                      break;
                  }
                }
                break;
              }
              case "updateDraftMessage":
                if ("entities" in upd.draft && upd.draft.entities) {
                  for(let   ent of upd.draft.entities) {
                    if (ent._ === "messageEntityMentionName") {
                      if (!(yield fetchPeer(ent.userId)))
                        return missing;
                    }
                  }
                }
            }
            return missing;
          });
        }
        _storeMessageReferences(msg) {
          return __async(this, null, function* () {
            var _a3, _b2;
            if (msg._ === "messageEmpty")
              return;
            const { client: client2 } = this;
            const peerId = msg.peerId;
            if (peerId._ !== "peerChannel")
              return;
            const channelId = toggleChannelIdMark(peerId.channelId);
            const promises = [];
            function store2(peer) {
              if (!peer)
                return;
              if (Array.isArray(peer)) {
                peer.forEach(store2);
                return;
              }
              const marked = typeof peer === "number" ? peer : getMarkedPeerId(peer);
              promises.push(client2.storage.refMsgs.store(marked, channelId, msg.id));
            }
            store2(msg.fromId);
            if (msg._ === "message") {
              store2(msg.viaBotId);
              store2((_a3 = msg.fwdFrom) == null ? void 0 : _a3.fromId);
              if (msg.media) {
                switch (msg.media._) {
                  case "messageMediaWebPage":
                    if (msg.media.webpage._ === "webPage" && msg.media.webpage.attributes) {
                      for(let   attr of msg.media.webpage.attributes) {
                        if (attr._ === "webPageAttributeStory") {
                          store2(attr.peer);
                        }
                      }
                    }
                    break;
                  case "messageMediaContact":
                    store2(msg.media.userId);
                    break;
                  case "messageMediaStory":
                    store2(msg.media.peer);
                    break;
                  case "messageMediaGiveaway":
                    store2(msg.media.channels.map(toggleChannelIdMark));
                    break;
                }
              }
            } else {
              switch (msg.action._) {
                case "messageActionChatCreate":
                case "messageActionChatAddUser":
                case "messageActionInviteToGroupCall":
                  store2(msg.action.users);
                  break;
                case "messageActionChatDeleteUser":
                  store2(msg.action.userId);
                  break;
              }
            }
            if (msg.replyTo) {
              switch (msg.replyTo._) {
                case "messageReplyHeader":
                  store2(msg.replyTo.replyToPeerId);
                  store2((_b2 = msg.replyTo.replyFrom) == null ? void 0 : _b2.fromId);
                  break;
                case "messageReplyStoryHeader":
                  store2(msg.replyTo.peer);
                  break;
              }
            }
            yield Promise.all(promises);
          });
        }
        _fetchChannelDifference(channelId, fallbackPts) {
          return __async(this, null, function* () {
            const { channelDiffTimeouts, cpts, cptsMod, channelsOpened, client: client2, log, pendingUnorderedUpdates } = this;
            if (channelDiffTimeouts.has(channelId)) {
              clearTimeoutWrap(channelDiffTimeouts.get(channelId));
              channelDiffTimeouts.delete(channelId);
            }
            let _pts = cpts.get(channelId);
            if (!_pts && this.catchingUp) {
              _pts = yield client2.storage.updates.getChannelPts(channelId);
            }
            if (!_pts)
              _pts = fallbackPts;
            if (!_pts) {
              log.debug("fetchChannelDifference failed for channel %d: base pts not available", channelId);
              return false;
            }
            const channelPeer = yield client2.storage.peers.getById(toggleChannelIdMark(channelId));
            if (!channelPeer) {
              log.debug("fetchChannelDifference failed for channel %d: input peer not found", channelId);
              return false;
            }
            const channel = toInputChannel(channelPeer);
            let pts = _pts;
            let limit = this._channelPtsLimit(channelId);
            if (pts <= 0) {
              pts = 1;
              limit = 1;
            }
            let lastTimeout = 0;
            for (; ; ) {
              const diff = yield client2.call({
                _: "updates.getChannelDifference",
                force: true,
                // Set to true to skip some possibly unneeded updates and reduce server-side load
                channel,
                pts,
                limit,
                filter: { _: "channelMessagesFilterEmpty" }
              });
              if (diff.timeout) {
                lastTimeout = this.params.overrideOpenChatTimeout ? this.params.overrideOpenChatTimeout(diff) : diff.timeout;
              }
              if (diff._ === "updates.channelDifferenceEmpty") {
                log.debug("getChannelDifference (cid = %d) returned channelDifferenceEmpty", channelId);
                break;
              }
              const peers = PeersIndex.from(diff);
              if (diff._ === "updates.channelDifferenceTooLong") {
                if (diff.dialog._ === "dialog") {
                  pts = diff.dialog.pts;
                }
                if (this.params.onChannelTooLong) {
                  this.params.onChannelTooLong(channelId, diff);
                } else {
                  log.warn(
                    "getChannelDifference (cid = %d) returned channelDifferenceTooLong. new pts: %d, recent msgs: %d",
                    channelId,
                    pts,
                    diff.messages.length
                  );
                  diff.messages.forEach((message2) => {
                    log.debug(
                      "processing message %d (%s) from TooLong diff for channel %d",
                      message2.id,
                      message2._,
                      channelId
                    );
                    if (message2._ === "messageEmpty")
                      return;
                    pendingUnorderedUpdates.pushBack(toPendingUpdate(messageToUpdate(message2), peers, true));
                  });
                }
                break;
              }
              log.debug(
                "getChannelDifference (cid = %d) returned %d messages, %d updates. new pts: %d, final: %b",
                channelId,
                diff.newMessages.length,
                diff.otherUpdates.length,
                diff.pts,
                diff.final
              );
              diff.newMessages.forEach((message2) => {
                log.debug("processing message %d (%s) from diff for channel %d", message2.id, message2._, channelId);
                if (message2._ === "messageEmpty")
                  return;
                pendingUnorderedUpdates.pushBack(toPendingUpdate(messageToUpdate(message2), peers, true));
              });
              diff.otherUpdates.forEach((upd) => {
                const parsed = toPendingUpdate(upd, peers, true);
                log.debug(
                  "processing %s from diff for channel %d, pts_before: %d, pts: %d",
                  upd._,
                  channelId,
                  parsed.ptsBefore,
                  parsed.pts
                );
                if (isMessageEmpty(upd))
                  return;
                pendingUnorderedUpdates.pushBack(parsed);
              });
              pts = diff.pts;
              if (diff.final)
                break;
            }
            cpts.set(channelId, pts);
            cptsMod.set(channelId, pts);
            if (lastTimeout !== 0 && channelsOpened.has(channelId)) {
              log.debug("scheduling next fetch for channel %d in %d seconds", channelId, lastTimeout);
              channelDiffTimeouts.set(
                channelId,
                setTimeoutWrap(() => this._fetchChannelDifferenceViaUpdate(channelId), lastTimeout * 1e3)
              );
            }
            return true;
          });
        }
        _fetchChannelDifferenceLater(requestedDiff, channelId, fallbackPts) {
          if (!requestedDiff.has(channelId)) {
            requestedDiff.set(
              channelId,
              this._fetchChannelDifference(channelId, fallbackPts).catch((err) => {
                this.log.warn("error fetching difference for %d: %e", channelId, err);
              }).then((ok) => {
                requestedDiff.delete(channelId);
                if (!ok) {
                  this.log.debug("channel difference for %d failed, falling back to common diff", channelId);
                  this._fetchDifferenceLater(requestedDiff);
                }
              })
            );
          }
        }
        _fetchChannelDifferenceViaUpdate(channelId, pts) {
          this.handleUpdate(
            createDummyUpdatesContainer([
              {
                _: "updateChannelTooLong",
                channelId,
                pts
              }
            ])
          );
        }
        _fetchDifference(requestedDiff) {
          return __async(this, null, function* () {
            const { client: client2, log, pendingPtsUpdates, pendingUnorderedUpdates } = this;
            const diff = yield client2.call({
              _: "updates.getDifference",
              pts: this.pts,
              date: this.date,
              qts: this.qts
            });
            switch (diff._) {
              case "updates.differenceEmpty":
                log.debug("updates.getDifference returned updates.differenceEmpty");
                return;
              case "updates.differenceTooLong":
                this.pts = diff.pts;
                log.debug("updates.getDifference returned updates.differenceTooLong");
                return;
            }
            const fetchedState = diff._ === "updates.difference" ? diff.state : diff.intermediateState;
            log.debug(
              "updates.getDifference returned %d messages, %d updates. new pts: %d, qts: %d, seq: %d, final: %b",
              diff.newMessages.length,
              diff.otherUpdates.length,
              fetchedState.pts,
              fetchedState.qts,
              fetchedState.seq,
              diff._ === "updates.difference"
            );
            const peers = PeersIndex.from(diff);
            diff.newMessages.forEach((message2) => {
              log.debug("processing message %d in %j (%s) from common diff", message2.id, message2.peerId, message2._);
              if (message2._ === "messageEmpty")
                return;
              pendingUnorderedUpdates.pushBack(toPendingUpdate(messageToUpdate(message2), peers, true));
            });
            diff.otherUpdates.forEach((upd) => {
              if (upd._ === "updateChannelTooLong") {
                log.debug(
                  "received updateChannelTooLong for channel %d in common diff (pts = %d), fetching diff",
                  upd.channelId,
                  upd.pts
                );
                this._fetchChannelDifferenceLater(requestedDiff, upd.channelId, upd.pts);
                return;
              }
              if (isMessageEmpty(upd))
                return;
              const parsed = toPendingUpdate(upd, peers, true);
              if (parsed.channelId && parsed.ptsBefore) {
                pendingPtsUpdates.add(parsed);
              } else {
                pendingUnorderedUpdates.pushBack(parsed);
              }
              log.debug(
                "received %s from common diff, cid: %d, pts_before: %d, pts: %d, qts_before: %d",
                upd._,
                parsed.channelId,
                parsed.ptsBefore,
                parsed.pts,
                parsed.qtsBefore
              );
            });
            this.pts = fetchedState.pts;
            this.qts = fetchedState.qts;
            this.seq = fetchedState.seq;
            this.date = fetchedState.date;
            if (diff._ === "updates.difference") {
              return;
            }
            this.handleUpdate(UPDATES_TOO_LONG);
          });
        }
        _fetchDifferenceLater(requestedDiff) {
          if (!requestedDiff.has(0)) {
            requestedDiff.set(
              0,
              this._fetchDifference(requestedDiff).catch((err) => {
                if (tl.tl.RpcError.is(err, "AUTH_KEY_UNREGISTERED")) {
                  this.stopLoop();
                  return;
                }
                this.log.warn("error fetching common difference: %e", err);
                if (tl.tl.RpcError.is(err, "PERSISTENT_TIMESTAMP_INVALID")) {
                  return this._fetchUpdatesState();
                }
              }).then(() => {
                requestedDiff.delete(0);
              })
            );
          }
        }
        _onUpdate(pending2, requestedDiff, postponed = false, unordered = false) {
          return __async(this, null, function* () {
            var _a3, _b2, _c, _d, _e, _f;
            const { client: client2, log } = this;
            const upd = pending2.update;
            let missing;
            if (pending2.peers.hasMin || pending2.peers.empty) {
              log.debug("loading missing peers for %s (pts = %d, cid = %d)", upd._, pending2.pts, pending2.channelId);
              missing = yield this._fetchMissingPeers(upd, pending2.peers, pending2.fromDifference);
              if (!pending2.fromDifference && missing.size) {
                log.debug(
                  "fetching difference because some peers were min (%J) and not cached for %s (pts = %d, cid = %d)",
                  missing,
                  upd._,
                  pending2.pts,
                  pending2.channelId
                );
                if (pending2.channelId && !(upd._ === "updateNewChannelMessage" && upd.message._ === "messageService")) {
                  this._fetchChannelDifferenceLater(requestedDiff, pending2.channelId, pending2.ptsBefore);
                } else {
                  this._fetchDifferenceLater(requestedDiff);
                }
                return;
              }
              if (missing.size) {
                log.debug(
                  "peers still missing after fetching difference: %J for %s (pts = %d, cid = %d)",
                  missing,
                  upd._,
                  pending2.pts,
                  pending2.channelId
                );
              }
            }
            if (!unordered) {
              if (pending2.pts) {
                const localPts = pending2.channelId ? this.cpts.get(pending2.channelId) : this.pts;
                if (localPts && pending2.ptsBefore !== localPts) {
                  log.warn(
                    "pts_before does not match local_pts for %s (cid = %d, pts_before = %d, pts = %d, local_pts = %d)",
                    upd._,
                    pending2.channelId,
                    pending2.ptsBefore,
                    pending2.pts,
                    localPts
                  );
                }
                log.debug(
                  "applying new pts (cid = %d) because received %s: %d -> %d (before: %d, count: %d) (postponed = %s)",
                  pending2.channelId,
                  upd._,
                  localPts,
                  pending2.pts,
                  pending2.ptsBefore,
                  pending2.pts - pending2.ptsBefore,
                  postponed
                );
                if (pending2.channelId) {
                  this.cpts.set(pending2.channelId, pending2.pts);
                  this.cptsMod.set(pending2.channelId, pending2.pts);
                } else {
                  this.pts = pending2.pts;
                }
              }
              if (pending2.qtsBefore) {
                log.debug(
                  "applying new qts because received %s: %d -> %d (postponed = %s)",
                  upd._,
                  this.qts,
                  pending2.qtsBefore + 1,
                  postponed
                );
                this.qts = pending2.qts;
              }
            }
            if (isMessageEmpty(upd))
              return;
            switch (upd._) {
              case "mtcute.dummyUpdate":
                return;
              case "updateDcOptions": {
                const config = client2.mt.network.config.getNow();
                if (config) {
                  client2.mt.network.config.setData(__spreadProps(__spreadValues({}, config), {
                    dcOptions: upd.dcOptions
                  }));
                } else {
                  client2.mt.network.config.update(true).catch((err) => client2.emitError(err));
                }
                break;
              }
              case "updateConfig":
                client2.mt.network.config.update(true).catch((err) => client2.emitError(err));
                break;
              case "updateUserName":
                break;
              case "updateDeleteChannelMessages":
                if (!((_a3 = this.auth) == null ? void 0 : _a3.isBot)) {
                  yield client2.storage.refMsgs.delete(toggleChannelIdMark(upd.channelId), upd.messages);
                }
                break;
              case "updateNewMessage":
              case "updateEditMessage":
              case "updateNewChannelMessage":
              case "updateEditChannelMessage":
                if (!((_b2 = this.auth) == null ? void 0 : _b2.isBot)) {
                  yield this._storeMessageReferences(upd.message);
                }
                break;
            }
            if (missing == null ? void 0 : missing.size) {
              if ((_c = this.auth) == null ? void 0 : _c.isBot) {
                this.log.warn(
                  "missing peers (%J) after getDifference for %s (pts = %d, cid = %d)",
                  missing,
                  upd._,
                  pending2.pts,
                  pending2.channelId
                );
              } else {
                yield client2.mt.storage.save();
                for(let   id2 of missing) {
                  Promise.resolve(client2.storage.peers.getById(id2)).then((peer) => {
                    if (!peer) {
                      this.log.warn("cannot fetch full peer %d - getPeerById returned null", id2);
                      return;
                    }
                    log.warn("cannot fetch full peer %d - unknown peer type %s", id2, peer._);
                  }).catch((err) => {
                    log.warn("error fetching full peer %d: %e", id2, err);
                  });
                }
              }
            }
            if (this.noDispatchEnabled) {
              const channelId = (_d = pending2.channelId) != null ? _d : 0;
              const msgId = upd._ === "updateNewMessage" || upd._ === "updateNewChannelMessage" || upd._ === "updateBotNewBusinessMessage" ? upd.message.id : void 0;
              const foundByMsgId = msgId && ((_e = this.noDispatchMsg.get(channelId)) == null ? void 0 : _e.delete(msgId));
              const foundByPts = (_f = this.noDispatchPts.get(channelId)) == null ? void 0 : _f.delete(pending2.pts);
              const foundByQts = this.noDispatchQts.delete(pending2.qts);
              if (foundByMsgId || foundByPts || foundByQts) {
                log.debug("not dispatching %s because it is in no_dispatch index", upd._);
                return;
              }
            }
            log.debug("dispatching %s (postponed = %s)", upd._, postponed);
            this._handler(upd, pending2.peers);
          });
        }
        _loop() {
          return __async(this, null, function* () {
            const {
              log,
              client: client2,
              cpts,
              cptsMod,
              pendingUpdateContainers,
              pendingPtsUpdates,
              pendingPtsUpdatesPostponed,
              pendingQtsUpdates,
              pendingQtsUpdatesPostponed,
              pendingUnorderedUpdates,
              updatesLoopCv,
              postponedTimer
            } = this;
            log.debug("updates loop started, state available? %b", this.pts);
            try {
              if (!this.pts) {
                yield this._fetchUpdatesState();
              }
              while (this.updatesLoopActive) {
                if (!(pendingUpdateContainers.length || pendingPtsUpdates.length || pendingQtsUpdates.length || pendingUnorderedUpdates.length || this.hasTimedoutPostponed)) {
                  if (this.catchingUp) {
                    this.log.debug("catching up completed");
                    this.catchingUp = false;
                    this._onCatchingUp(false);
                  }
                  yield updatesLoopCv.wait();
                }
                if (!this.updatesLoopActive)
                  break;
                log.debug(
                  "updates loop tick. pending containers: %d, pts: %d, pts_postponed: %d, qts: %d, qts_postponed: %d, unordered: %d",
                  pendingUpdateContainers.length,
                  pendingPtsUpdates.length,
                  pendingPtsUpdatesPostponed.length,
                  pendingQtsUpdates.length,
                  pendingQtsUpdatesPostponed.length,
                  pendingUnorderedUpdates.length
                );
                const requestedDiff = /* @__PURE__ */ new Map();
                this.log.debug("processing pending containers");
                while (pendingUpdateContainers.length) {
                  const { upd, seqStart, seqEnd } = pendingUpdateContainers.popFront();
                  switch (upd._) {
                    case "updatesTooLong":
                      log.debug("received updatesTooLong, fetching difference");
                      this._fetchDifferenceLater(requestedDiff);
                      break;
                    case "updatesCombined":
                    case "updates": {
                      if (seqStart !== 0) {
                        const nextLocalSeq = this.seq + 1;
                        log.debug(
                          "received seq-ordered %s (seq_start = %d, seq_end = %d, size = %d)",
                          upd._,
                          seqStart,
                          seqEnd,
                          upd.updates.length
                        );
                        if (nextLocalSeq > seqStart) {
                          log.debug(
                            "ignoring updates group because already applied (by seq: exp %d, got %d)",
                            nextLocalSeq,
                            seqStart
                          );
                          continue;
                        }
                        if (nextLocalSeq < seqStart) {
                          log.debug(
                            "fetching difference because gap detected (by seq: exp %d, got %d)",
                            nextLocalSeq,
                            seqStart
                          );
                          this._fetchDifferenceLater(requestedDiff);
                        }
                      } else {
                        log.debug("received %s (size = %d)", upd._, upd.updates.length);
                      }
                      yield client2.storage.peers.updatePeersFrom(upd);
                      const peers = PeersIndex.from(upd);
                      for(let   update of upd.updates) {
                        switch (update._) {
                          case "updateChannelTooLong":
                            log.debug(
                              "received updateChannelTooLong for channel %d (pts = %d) in container, fetching diff",
                              update.channelId,
                              update.pts
                            );
                            this._fetchChannelDifferenceLater(requestedDiff, update.channelId, update.pts);
                            continue;
                          case "updatePtsChanged":
                            if (client2.mt.network.getPoolSize("main") > 1) {
                              log.debug(
                                "updatePtsChanged received, resetting pts to 1 and fetching difference"
                              );
                              this.pts = 1;
                              this._fetchDifferenceLater(requestedDiff);
                            } else {
                              log.debug("updatePtsChanged received, fetching updates state");
                              yield this._fetchUpdatesState();
                            }
                            continue;
                        }
                        const parsed = toPendingUpdate(update, peers);
                        if (parsed.ptsBefore !== void 0) {
                          pendingPtsUpdates.add(parsed);
                        } else if (parsed.qtsBefore !== void 0) {
                          pendingQtsUpdates.add(parsed);
                        } else {
                          pendingUnorderedUpdates.pushBack(parsed);
                        }
                      }
                      if (seqEnd !== 0 && seqEnd > this.seq) {
                        this.seq = seqEnd;
                        this.date = upd.date;
                      }
                      break;
                    }
                    case "updateShort": {
                      log.debug("received short %s", upd._);
                      const parsed = toPendingUpdate(upd.update, new PeersIndex());
                      if (parsed.ptsBefore !== void 0) {
                        pendingPtsUpdates.add(parsed);
                      } else if (parsed.qtsBefore !== void 0) {
                        pendingQtsUpdates.add(parsed);
                      } else {
                        pendingUnorderedUpdates.pushBack(parsed);
                      }
                      break;
                    }
                    case "updateShortMessage": {
                      log.debug("received updateShortMessage");
                      const message2 = {
                        _: "message",
                        out: upd.out,
                        mentioned: upd.mentioned,
                        mediaUnread: upd.mediaUnread,
                        silent: upd.silent,
                        id: upd.id,
                        fromId: {
                          _: "peerUser",
                          userId: upd.out ? this.auth.userId : upd.userId
                        },
                        peerId: {
                          _: "peerUser",
                          userId: upd.userId
                        },
                        fwdFrom: upd.fwdFrom,
                        viaBotId: upd.viaBotId,
                        replyTo: upd.replyTo,
                        date: upd.date,
                        message: upd.message,
                        entities: upd.entities,
                        ttlPeriod: upd.ttlPeriod
                      };
                      const update = {
                        _: "updateNewMessage",
                        message: message2,
                        pts: upd.pts,
                        ptsCount: upd.ptsCount
                      };
                      pendingPtsUpdates.add({
                        update,
                        ptsBefore: upd.pts - upd.ptsCount,
                        pts: upd.pts,
                        peers: new PeersIndex(),
                        fromDifference: false
                      });
                      break;
                    }
                    case "updateShortChatMessage": {
                      log.debug("received updateShortChatMessage");
                      const message2 = {
                        _: "message",
                        out: upd.out,
                        mentioned: upd.mentioned,
                        mediaUnread: upd.mediaUnread,
                        silent: upd.silent,
                        id: upd.id,
                        fromId: {
                          _: "peerUser",
                          userId: upd.fromId
                        },
                        peerId: {
                          _: "peerChat",
                          chatId: upd.chatId
                        },
                        fwdFrom: upd.fwdFrom,
                        viaBotId: upd.viaBotId,
                        replyTo: upd.replyTo,
                        date: upd.date,
                        message: upd.message,
                        entities: upd.entities,
                        ttlPeriod: upd.ttlPeriod
                      };
                      const update = {
                        _: "updateNewMessage",
                        message: message2,
                        pts: upd.pts,
                        ptsCount: upd.ptsCount
                      };
                      pendingPtsUpdates.add({
                        update,
                        ptsBefore: upd.pts - upd.ptsCount,
                        pts: upd.pts,
                        peers: new PeersIndex(),
                        fromDifference: false
                      });
                      break;
                    }
                    case "updateShortSentMessage": {
                      log.warn("received updateShortSentMessage");
                      break;
                    }
                    default:
                      assertNever$1(upd);
                  }
                }
                this.log.debug("processing pending pts-ordered updates");
                while (pendingPtsUpdates.length) {
                  const pending2 = pendingPtsUpdates.popFront();
                  const upd = pending2.update;
                  let localPts = null;
                  if (!pending2.channelId) {
                    localPts = this.pts;
                  } else if (cpts.has(pending2.channelId)) {
                    localPts = cpts.get(pending2.channelId);
                  } else if (this.catchingUp) {
                    const saved = yield client2.storage.updates.getChannelPts(pending2.channelId);
                    if (saved) {
                      cpts.set(pending2.channelId, saved);
                      localPts = saved;
                    }
                  }
                  if (localPts) {
                    const diff = localPts - pending2.ptsBefore;
                    const isPtsDrop = diff > 1000009;
                    if (diff > 0 && !isPtsDrop) {
                      log.debug(
                        "ignoring %s (cid = %d) because already applied (by pts: exp %d, got %d)",
                        upd._,
                        pending2.channelId,
                        localPts,
                        pending2.ptsBefore
                      );
                      continue;
                    }
                    if (diff < 0) {
                      if (diff > -3) {
                        log.debug(
                          "postponing %s for 0.5s (cid = %d) because small gap detected (by pts: exp %d, got %d, diff=%d)",
                          upd._,
                          pending2.channelId,
                          localPts,
                          pending2.ptsBefore,
                          diff
                        );
                        pending2.timeout = Date.now() + 500;
                        pendingPtsUpdatesPostponed.add(pending2);
                        postponedTimer.emitBefore(pending2.timeout);
                      } else if (diff > -1e6) {
                        log.debug(
                          "fetching difference after %s (cid = %d) because pts gap detected (by pts: exp %d, got %d, diff=%d)",
                          upd._,
                          pending2.channelId,
                          localPts,
                          pending2.ptsBefore,
                          diff
                        );
                        if (pending2.channelId) {
                          this._fetchChannelDifferenceLater(requestedDiff, pending2.channelId);
                        } else {
                          this._fetchDifferenceLater(requestedDiff);
                        }
                      } else {
                        log.debug(
                          "skipping all updates because pts gap is too big (by pts: exp %d, got %d, diff=%d)",
                          localPts,
                          pending2.ptsBefore,
                          diff
                        );
                        if (pending2.channelId) {
                          cpts.set(pending2.channelId, 0);
                          cptsMod.set(pending2.channelId, 0);
                        } else {
                          yield this._fetchUpdatesState();
                        }
                      }
                      continue;
                    }
                    if (isPtsDrop) {
                      log.debug("pts drop detected (%d -> %d)", localPts, pending2.ptsBefore);
                    }
                  }
                  yield this._onUpdate(pending2, requestedDiff);
                }
                this.log.debug("processing postponed pts-ordered updates");
                for (let item2 = pendingPtsUpdatesPostponed._first; item2; item2 = item2.n) {
                  const pending2 = item2.v;
                  const upd = pending2.update;
                  let localPts;
                  if (!pending2.channelId) {
                    localPts = this.pts;
                  } else if (cpts.has(pending2.channelId)) {
                    localPts = cpts.get(pending2.channelId);
                  }
                  if (!localPts) {
                    log.warn(
                      "local pts not available for postponed %s (cid = %d), skipping",
                      upd._,
                      pending2.channelId
                    );
                    continue;
                  }
                  if (localPts > pending2.ptsBefore) {
                    log.debug(
                      "ignoring postponed %s (cid = %d) because already applied (by pts: exp %d, got %d)",
                      upd._,
                      pending2.channelId,
                      localPts,
                      pending2.ptsBefore
                    );
                    pendingPtsUpdatesPostponed._remove(item2);
                    continue;
                  }
                  if (localPts < pending2.ptsBefore) {
                    const now2 = Date.now();
                    if (now2 < pending2.timeout) {
                      log.debug(
                        "postponed %s (cid = %d) is still waiting (%dms left) (current pts %d, need %d)",
                        upd._,
                        pending2.channelId,
                        pending2.timeout - now2,
                        localPts,
                        pending2.ptsBefore
                      );
                    } else {
                      log.debug(
                        "gap for postponed %s (cid = %d) wasn't filled, fetching diff (current pts %d, need %d)",
                        upd._,
                        pending2.channelId,
                        localPts,
                        pending2.ptsBefore
                      );
                      pendingPtsUpdatesPostponed._remove(item2);
                      if (pending2.channelId) {
                        this._fetchChannelDifferenceLater(requestedDiff, pending2.channelId);
                      } else {
                        this._fetchDifferenceLater(requestedDiff);
                      }
                    }
                    continue;
                  }
                  yield this._onUpdate(pending2, requestedDiff, true);
                  pendingPtsUpdatesPostponed._remove(item2);
                }
                this.log.debug("processing pending qts-ordered updates");
                while (pendingQtsUpdates.length) {
                  const pending2 = pendingQtsUpdates.popFront();
                  const upd = pending2.update;
                  const diff = this.qts - pending2.qtsBefore;
                  const isQtsDrop = diff > 1000009;
                  if (diff > 0 && !isQtsDrop) {
                    log.debug(
                      "ignoring %s because already applied (by qts: exp %d, got %d)",
                      upd._,
                      this.qts,
                      pending2.qtsBefore
                    );
                    continue;
                  }
                  if (this.qts < pending2.qtsBefore) {
                    if (diff > -3) {
                      log.debug(
                        "postponing %s for 0.5s because small gap detected (by qts: exp %d, got %d, diff=%d)",
                        upd._,
                        this.qts,
                        pending2.qtsBefore,
                        diff
                      );
                      pending2.timeout = Date.now() + 500;
                      pendingQtsUpdatesPostponed.add(pending2);
                      postponedTimer.emitBefore(pending2.timeout);
                    } else {
                      log.debug(
                        "fetching difference after %s because qts gap detected (by qts: exp %d, got %d, diff=%d)",
                        upd._,
                        this.qts,
                        pending2.qtsBefore,
                        diff
                      );
                      this._fetchDifferenceLater(requestedDiff);
                    }
                    continue;
                  }
                  if (isQtsDrop) {
                    log.debug("qts drop detected (%d -> %d)", this.qts, pending2.qtsBefore);
                  }
                  yield this._onUpdate(pending2, requestedDiff);
                }
                this.log.debug("processing postponed qts-ordered updates");
                for (let item2 = pendingQtsUpdatesPostponed._first; item2; item2 = item2.n) {
                  const pending2 = item2.v;
                  const upd = pending2.update;
                  if (this.qts > pending2.qtsBefore) {
                    log.debug(
                      "ignoring postponed %s because already applied (by qts: exp %d, got %d)",
                      upd._,
                      this.qts,
                      pending2.qtsBefore
                    );
                    continue;
                  }
                  if (this.qts < pending2.qtsBefore) {
                    const now2 = Date.now();
                    if (now2 < pending2.timeout) {
                      log.debug(
                        "postponed %s is still waiting (%dms left) (current qts %d, need %d)",
                        upd._,
                        pending2.timeout - now2,
                        this.qts,
                        pending2.qtsBefore
                      );
                    } else {
                      log.debug(
                        "gap for postponed %s wasn't filled, fetching diff (current qts %d, need %d)",
                        upd._,
                        this.qts,
                        pending2.qtsBefore
                      );
                      pendingQtsUpdatesPostponed._remove(item2);
                      this._fetchDifferenceLater(requestedDiff);
                    }
                    continue;
                  }
                  yield this._onUpdate(pending2, requestedDiff, true);
                  pendingQtsUpdatesPostponed._remove(item2);
                }
                this.hasTimedoutPostponed = false;
                while (requestedDiff.size) {
                  log.debug(
                    "waiting for %d pending diffs before processing unordered: %J",
                    requestedDiff.size,
                    requestedDiff.keys()
                  );
                  yield Promise.all([...requestedDiff.values()]);
                  log.debug(
                    "pending diffs awaited, new diffs requested: %d (%J)",
                    requestedDiff.size,
                    requestedDiff.keys()
                  );
                }
                this.log.debug("processing pending unordered updates");
                while (pendingUnorderedUpdates.length) {
                  const pending2 = pendingUnorderedUpdates.popFront();
                  yield this._onUpdate(pending2, requestedDiff, false, true);
                }
                while (requestedDiff.size) {
                  log.debug(
                    "waiting for %d pending diffs after processing unordered: %J",
                    requestedDiff.size,
                    requestedDiff.keys()
                  );
                  yield Promise.all([...requestedDiff.values()]);
                  log.debug(
                    "pending diffs awaited, new diffs requested: %d (%j)",
                    requestedDiff.size,
                    requestedDiff.keys()
                  );
                }
                yield this._saveUpdatesStorage(true);
              }
              log.debug("updates loop stopped");
            } catch (e2) {
              log.error("updates loop encountered error, restarting: %s", e2);
              return this._loop();
            }
          });
        }
      }
      exports("dc", UpdatesManager);
      function makeRpcError(raw, stack, method) {
        const error = tl.tl.RpcError.fromTl(raw);
        error.stack = `RpcError (${error.code} ${error.text}): ${error.message}
    at ${method}
${stack.split("\n").slice(2).join("\n")}`;
        return error;
      }
      let BaseTelegramClient$1 = class BaseTelegramClient {
        constructor(params) {
          __publicField(this, "updates");
          __publicField(this, "_serverUpdatesHandler", () => {
          });
          __publicField(this, "_connectionStateHandler", () => {
          });
          __publicField(this, "log");
          __publicField(this, "mt");
          __publicField(this, "crypto");
          __publicField(this, "storage");
          __publicField(this, "appConfig", new AppConfigManager(this));
          __publicField(this, "_prepare", asyncResettable(() => __async(this, null, function* () {
            var _a3, _b2, _c;
            yield this.mt.prepare();
            const self2 = yield this.storage.self.fetch();
            this.log.prefix = `[USER ${(_a3 = self2 == null ? void 0 : self2.userId) != null ? _a3 : "n/a"}] `;
            this.mt.network.setIsPremium((_b2 = self2 == null ? void 0 : self2.isPremium) != null ? _b2 : false);
            yield (_c = this.updates) == null ? void 0 : _c.prepare();
          })));
          // used in a hot path, avoid extra function calls
          __publicField(this, "_connected", false);
          __publicField(this, "_connect", asyncResettable(() => __async(this, null, function* () {
            yield this._prepare.run();
            yield this.mt.connect();
            this._connected = true;
          })));
          var _a3;
          this.params = params;
          this.log = (_a3 = this.params.logger) != null ? _a3 : new LogManager("client");
          this.mt = new MtClient(__spreadProps(__spreadValues({}, this.params), {
            logger: this.log.create("mtproto")
          }));
          if (!params.disableUpdates && params.updates !== false) {
            this.updates = new UpdatesManager(this, params.updates);
            this._serverUpdatesHandler = this.updates.handleUpdate.bind(this.updates);
            this.updates.onCatchingUp((catchingUp) => {
              this._connectionStateHandler(catchingUp ? "updating" : "connected");
            });
          }
          this.mt.on("update", (update) => {
            this._serverUpdatesHandler(update);
          });
          this.mt.on("usable", () => {
            this._connectionStateHandler("connected");
          });
          this.mt.on("wait", () => {
            this._connectionStateHandler("connecting");
          });
          this.mt.on("networkChanged", (connected) => {
            if (!connected) {
              this._connectionStateHandler("offline");
            }
          });
          this.crypto = this.mt.crypto;
          this.storage = new TelegramStorageManager(this.mt.storage, __spreadValues({
            provider: this.params.storage
          }, this.params.storageOptions));
        }
        /**
         * **ADVANCED**
         *
         * Do all the preparations, but don't connect just yet.
         * Useful when you want to do some preparations before
         * connecting, like setting up session.
         *
         * Call {@link connect} to actually connect.
         */
        prepare() {
          return this._prepare.run();
        }
        /**
         * Initialize the connection to the primary DC.
         *
         * You shouldn't usually call this method directly as it is called
         * implicitly the first time you call {@link call}.
         */
        connect() {
          return __async(this, null, function* () {
            return this._connect.run();
          });
        }
        get isConnected() {
          return this._connected;
        }
        close() {
          return __async(this, null, function* () {
            var _a3;
            this._connected = false;
            yield this.mt.close();
            (_a3 = this.updates) == null ? void 0 : _a3.stopLoop();
            this._prepare.reset();
            this._connect.reset();
          });
        }
        notifyLoggedIn(auth) {
          return __async(this, null, function* () {
            var _a3;
            const user = this.mt.network.notifyLoggedIn(auth);
            this.log.prefix = `[USER ${user.id}] `;
            const self2 = yield this.storage.self.storeFrom(user);
            (_a3 = this.updates) == null ? void 0 : _a3.notifyLoggedIn(self2);
            return user;
          });
        }
        notifyLoggedOut() {
          return __async(this, null, function* () {
            this.mt.network.notifyLoggedOut();
            this.log.prefix = "[USER n/a] ";
            yield this.storage.self.store(null);
          });
        }
        notifyChannelOpened(channelId, pts) {
          return __async(this, null, function* () {
            var _a3, _b2;
            return (_b2 = (_a3 = this.updates) == null ? void 0 : _a3.notifyChannelOpened(channelId, pts)) != null ? _b2 : false;
          });
        }
        notifyChannelClosed(channelId) {
          return __async(this, null, function* () {
            var _a3, _b2;
            return (_b2 = (_a3 = this.updates) == null ? void 0 : _a3.notifyChannelClosed(channelId)) != null ? _b2 : false;
          });
        }
        startUpdatesLoop() {
          return __async(this, null, function* () {
            var _a3;
            yield (_a3 = this.updates) == null ? void 0 : _a3.startLoop();
          });
        }
        stopUpdatesLoop() {
          return __async(this, null, function* () {
            var _a3;
            (_a3 = this.updates) == null ? void 0 : _a3.stopLoop();
          });
        }
        /**
         * Make an RPC call
         *
         * This method is still quite low-level and you shouldn't use this
         * when using high-level API provided by `@mtcute/client`.
         *
         * @param message  RPC method to call
         * @param params  Additional call parameters
         */
        call(message2, params) {
          return __async(this, null, function* () {
            var _a3;
            if (!this._connected) {
              yield this._connect.run();
            }
            const res = yield this.mt.call(message2, params);
            if (isTlRpcError(res)) {
              const error = makeRpcError(res, (_a3 = new Error().stack) != null ? _a3 : "", message2._);
              if (error.unknown && this.params.enableErrorReporting) {
                reportUnknownError(this.log, error, message2._);
              }
              throw error;
            }
            yield this.storage.peers.updatePeersFrom(res);
            return res;
          });
        }
        /**
         * Import the session from the given session string.
         *
         * Note that the session will only be imported in case
         * the storage is missing authorization (i.e. does not contain
         * auth key for the primary DC), otherwise it will be ignored (unless `force`).
         *
         * @param session  Session string to import
         * @param force  Whether to overwrite existing session
         */
        importSession(session, force = false) {
          return __async(this, null, function* () {
            yield this.prepare();
            const defaultDcAuthKey = yield this.mt.storage.provider.authKeys.get(this.mt._defaultDcs.main.id);
            if (defaultDcAuthKey && !force)
              return;
            const data2 = typeof session === "string" ? readStringSession(session) : session;
            if (data2.testMode && !this.params.testMode) {
              throw new Error(
                `This session string is not for the current backend. Session is ${data2.testMode ? "test" : "prod"}, but the client is ${this.params.testMode ? "test" : "prod"}`
              );
            }
            this.mt._defaultDcs = data2.primaryDcs;
            yield this.mt.storage.dcs.store(data2.primaryDcs);
            if (data2.self) {
              yield this.storage.self.store(data2.self);
            }
            yield this.mt.storage.provider.authKeys.set(data2.primaryDcs.main.id, data2.authKey);
            yield this.mt.storage.save();
          });
        }
        /**
         * Export current session to a single *LONG* string, containing
         * all the needed information.
         *
         * > **Warning!** Anyone with this string will be able
         * > to authorize as you and do anything. Treat this
         * > as your password, and never give it away!
         * >
         * > In case you have accidentally leaked this string,
         * > make sure to revoke this session in account settings:
         * > "Privacy & Security" > "Active sessions" >
         * > find the one containing `mtcute` > Revoke,
         * > or, in case this is a bot, revoke bot token
         * > with [@BotFather](//t.me/botfather)
         */
        exportSession() {
          return __async(this, null, function* () {
            var _a3;
            yield this._prepare.run();
            const primaryDcs = (_a3 = yield this.mt.storage.dcs.fetch()) != null ? _a3 : this.mt._defaultDcs;
            const authKey = yield this.mt.storage.provider.authKeys.get(primaryDcs.main.id);
            if (!authKey)
              throw new Error("Auth key is not ready yet");
            return writeStringSession({
              version: 3,
              self: yield this.storage.self.fetch(),
              testMode: Boolean(this.params.testMode),
              primaryDcs,
              authKey
            });
          });
        }
        /**
         * Register an error handler for the client
         *
         * @param handler  Error handler.
         */
        onError(handler) {
          this.mt.onError(handler);
        }
        emitError(err) {
          this.mt.emitError(err);
        }
        handleClientUpdate(updates, noDispatch) {
          var _a3;
          (_a3 = this.updates) == null ? void 0 : _a3.handleClientUpdate(updates, noDispatch);
        }
        onServerUpdate(handler) {
          this._serverUpdatesHandler = handler;
        }
        getServerUpdateHandler() {
          return this._serverUpdatesHandler;
        }
        onUpdate(handler) {
          if (!this.updates) {
            throw new MtArgumentError("Updates manager is disabled");
          }
          this.updates.setHandler(handler);
        }
        onConnectionState(handler) {
          this._connectionStateHandler = handler;
        }
        getApiCrenetials() {
          return __async(this, null, function* () {
            return {
              id: this.params.apiId,
              hash: this.params.apiHash
            };
          });
        }
        getPoolSize(kind, dcId) {
          return __async(this, null, function* () {
            if (!this._connected) {
              yield this._connect.run();
            }
            return this.mt.network.getPoolSize(kind, dcId);
          });
        }
        getPrimaryDcId() {
          return __async(this, null, function* () {
            if (!this._connected) {
              yield this._connect.run();
            }
            return this.mt.network.getPrimaryDcId();
          });
        }
        computeSrpParams(request, password) {
          return computeSrpParams(this.crypto, request, password);
        }
        computeNewPasswordHash(algo, password) {
          return computeNewPasswordHash(this.crypto, algo, password);
        }
        get stopSignal() {
          return this.mt.stopSignal;
        }
        changePrimaryDc(dcId) {
          return this.mt.network.changePrimaryDc(dcId);
        }
        getMtprotoMessageId() {
          return __async(this, null, function* () {
            return this.mt.network.getMtprotoMessageId();
          });
        }
      };
      function memoizeGetters(cls, fields) {
        for(let   field of fields) {
          const desc2 = Object.getOwnPropertyDescriptor(cls.prototype, field);
          if (!desc2)
            continue;
          const { get: get2 } = desc2;
          if (!get2)
            continue;
          Object.defineProperty(cls.prototype, field, {
            get() {
              const val = get2.call(this);
              Object.defineProperty(this, field, {
                value: val,
                enumerable: true,
                writable: true
              });
              return val;
            },
            enumerable: true,
            configurable: true
          });
        }
        return cls;
      }
      class MessageEntity {
        constructor(raw, _text) {
          this.raw = raw;
          this._text = _text;
        }
        /**
         * Offset in UTF-16 code units to the start of the entity.
         *
         * Since JS strings are UTF-16, you can use this as-is
         */
        get offset() {
          return this.raw.offset;
        }
        /**
         * Length of the entity in UTF-16 code units.
         *
         * Since JS strings are UTF-16, you can use this as-is
         */
        get length() {
          return this.raw.length;
        }
        /**
         * Kind of the entity (see {@link MessageEntityParams})
         */
        get kind() {
          return this.params.kind;
        }
        /**
         * Params of the entity
         */
        get params() {
          switch (this.raw._) {
            case "messageEntityMention":
              return { kind: "mention" };
            case "messageEntityHashtag":
              return { kind: "hashtag" };
            case "messageEntityCashtag":
              return { kind: "cashtag" };
            case "messageEntityBotCommand":
              return { kind: "bot_command" };
            case "messageEntityUrl":
              return { kind: "url" };
            case "messageEntityEmail":
              return { kind: "email" };
            case "messageEntityPhone":
              return { kind: "phone_number" };
            case "messageEntityBold":
              return { kind: "bold" };
            case "messageEntityItalic":
              return { kind: "italic" };
            case "messageEntityUnderline":
              return { kind: "underline" };
            case "messageEntityStrike":
              return { kind: "strikethrough" };
            case "messageEntitySpoiler":
              return { kind: "spoiler" };
            case "messageEntityCode":
              return { kind: "code" };
            case "messageEntityPre":
              return { kind: "pre", language: this.raw.language };
            case "messageEntityTextUrl":
              return { kind: "text_link", url: this.raw.url };
            case "messageEntityMentionName":
              return { kind: "text_mention", userId: this.raw.userId };
            case "messageEntityBlockquote":
              return { kind: "blockquote", collapsible: this.raw.collapsed };
            case "messageEntityCustomEmoji":
              return { kind: "emoji", emojiId: this.raw.documentId };
            case "messageEntityBankCard":
              return { kind: "bank_card" };
          }
          return { kind: "unknown" };
        }
        /**
         * Text contained in this entity.
         *
         * > **Note**: This does not take into account that entities may overlap,
         * > and is only useful for simple cases.
         */
        get text() {
          if (!this._text)
            return "";
          return this._text.slice(this.raw.offset, this.raw.offset + this.raw.length);
        }
        /**
         * Checks if this entity is of the given type, and adjusts the type accordingly.
         * @param kind
         * @returns
         */
        is(kind) {
          return this.params.kind === kind;
        }
      }
      exports("cf", MessageEntity);
      memoizeGetters(MessageEntity, ["params"]);
      class EmojiStatus {
        constructor(raw) {
          this.raw = raw;
        }
        /** ID of the custom emoji */
        get emoji() {
          return this.raw.documentId;
        }
        /** This status is valid at most until this date */
        get expireDate() {
          if (this.raw._ === "emojiStatus")
            return null;
          return new Date(this.raw.until * 1e3);
        }
      }
      class ChatColors {
        constructor(_peerId, raw) {
          this._peerId = _peerId;
          this.raw = raw;
        }
        /**
         * Color ID
         *
         * Note that this value is **not** an RGB color representation. Instead, it is
         * a number which should be used to pick a color from a predefined
         * list of colors:
         *  - `0-6` are the default colors used by Telegram clients:
         *    `red, orange, purple, green, sea, blue, pink`
         *  - `>= 7` are returned by `help.getAppConfig`.
         */
        get color() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw) == null ? void 0 : _a3.color) != null ? _b2 : this._peerId % 7;
        }
        /**
         * ID of the emoji that should be used as a background pattern
         * when rendering the color
         */
        get backgroundEmojiId() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw) == null ? void 0 : _a3.backgroundEmojiId) != null ? _b2 : null;
        }
      }
      class ChatPermissions {
        constructor(bannedRights) {
          __publicField(this, "raw");
          this.raw = bannedRights;
        }
        /**
         * Whether users can view messages
         */
        get canViewMessages() {
          return !this.raw.viewMessages;
        }
        /**
         * Whether users can send text messages,
         * contacts, locations and venues
         */
        get canSendMessages() {
          return !this.raw.sendMessages;
        }
        /**
         * Whether users can send media messages,
         * including documents, photos, videos, video notes and voice notes.
         *
         * Implies {@link canSendMessages}
         */
        get canSendMedia() {
          return !this.raw.sendMedia;
        }
        /**
         * Whether users can send stickers.
         *
         * Implies {@link canSendMedia}
         */
        get canSendStickers() {
          return !this.raw.sendStickers;
        }
        /**
         * Whether users can send GIFs.
         *
         * Implies {@link canSendMedia}
         */
        get canSendGifs() {
          return !this.raw.sendGifs;
        }
        /**
         * Whether users can send photos.
         *
         * Implies {@link canSendMedia}
         */
        get canSendPhotos() {
          return !this.raw.sendPhotos;
        }
        /**
         * Whether users can send videos.
         *
         * Implies {@link canSendMedia}
         */
        get canSendVideos() {
          return !this.raw.sendVideos;
        }
        /**
         * Whether users can send round videos (i.e. video notes).
         *
         * Implies {@link canSendMedia}
         */
        get canSendRoundVideos() {
          return !this.raw.sendRoundvideos;
        }
        /**
         * Whether users can send audio files.
         *
         * Implies {@link canSendMedia}
         */
        get canSendAudios() {
          return !this.raw.sendAudios;
        }
        /**
         * Whether users can send voice notes.
         *
         * Implies {@link canSendMedia}
         */
        get canSendVoices() {
          return !this.raw.sendVoices;
        }
        /**
         * Whether users can send files.
         *
         * Implies {@link canSendMedia}
         */
        get canSendFiles() {
          return !this.raw.sendDocs;
        }
        /**
         * Whether users can send games.
         *
         * Implies {@link canSendMedia}
         */
        get canSendGames() {
          return !this.raw.sendGames;
        }
        /**
         * Whether users can use inline bots.
         *
         * Implies {@link canSendMedia}
         */
        get canUseInline() {
          return !this.raw.sendInline;
        }
        /**
         * Whether users can use inline bots.
         *
         * Implies {@link canSendMedia}
         */
        get canAddWebPreviews() {
          return !this.raw.embedLinks;
        }
        /**
         * Whether users can send text messages.
         *
         * Implies {@link canSendMessages}
         */
        get canSendText() {
          return !this.raw.sendPlain;
        }
        /**
         * Whether users can send polls.
         *
         * Implies {@link canSendMessages}
         */
        get canSendPolls() {
          return !this.raw.sendPolls;
        }
        /**
         * Whether users can change the chat title,
         * photo and other settings.
         */
        get canChangeInfo() {
          return !this.raw.changeInfo;
        }
        /**
         * Whether users can invite other users to the chat
         */
        get canInviteUsers() {
          return !this.raw.inviteUsers;
        }
        /**
         * Whether users can pin messages
         */
        get canPinMessages() {
          return !this.raw.pinMessages;
        }
        /**
         * Whether users can pin messages
         */
        get canManageTopics() {
          return !this.raw.manageTopics;
        }
        /**
         * UNIX date until which these permissions are valid,
         * or `null` if forever.
         *
         * For example, represents the time when the restrictions
         * will be lifted from a {@link ChatMember}
         */
        get untilDate() {
          return this.raw.untilDate === 0 ? null : new Date(this.raw.untilDate * 1e3);
        }
      }
      exports("bG", ChatPermissions);
      const PERSISTENT_ID_VERSION_OLD = 2;
      const PERSISTENT_ID_VERSION = 4;
      const WEB_LOCATION_FLAG = 1 << 24;
      const FILE_REFERENCE_FLAG = 1 << 25;
      const CURRENT_VERSION = 54;
      class FileIdError extends Error {
      }
      class UnsupportedError extends FileIdError {
      }
      class InvalidFileIdError extends FileIdError {
      }
      class ConversionError extends FileIdError {
        constructor(to) {
          super(`Cannot convert given File ID to ${to}`);
        }
      }
      var FileType$1 = /* @__PURE__ */ ((FileType2) => {
        FileType2[FileType2["Thumbnail"] = 0] = "Thumbnail";
        FileType2[FileType2["ProfilePhoto"] = 1] = "ProfilePhoto";
        FileType2[FileType2["Photo"] = 2] = "Photo";
        FileType2[FileType2["VoiceNote"] = 3] = "VoiceNote";
        FileType2[FileType2["Video"] = 4] = "Video";
        FileType2[FileType2["Document"] = 5] = "Document";
        FileType2[FileType2["Encrypted"] = 6] = "Encrypted";
        FileType2[FileType2["Temp"] = 7] = "Temp";
        FileType2[FileType2["Sticker"] = 8] = "Sticker";
        FileType2[FileType2["Audio"] = 9] = "Audio";
        FileType2[FileType2["Animation"] = 10] = "Animation";
        FileType2[FileType2["EncryptedThumbnail"] = 11] = "EncryptedThumbnail";
        FileType2[FileType2["Wallpaper"] = 12] = "Wallpaper";
        FileType2[FileType2["VideoNote"] = 13] = "VideoNote";
        FileType2[FileType2["SecureRaw"] = 14] = "SecureRaw";
        FileType2[FileType2["Secure"] = 15] = "Secure";
        FileType2[FileType2["Background"] = 16] = "Background";
        FileType2[FileType2["DocumentAsFile"] = 17] = "DocumentAsFile";
        FileType2[FileType2["Size"] = 18] = "Size";
        FileType2[FileType2["None"] = 19] = "None";
        return FileType2;
      })(FileType$1 || {});
      function isFileIdLike(obj) {
        return typeof obj === "string" || obj !== null && typeof obj === "object" && obj._ === "remoteFileLocation";
      }
      const typesInner = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        CURRENT_VERSION,
        ConversionError,
        FILE_REFERENCE_FLAG,
        FileIdError,
        FileType: FileType$1,
        InvalidFileIdError,
        PERSISTENT_ID_VERSION,
        PERSISTENT_ID_VERSION_OLD,
        UnsupportedError,
        WEB_LOCATION_FLAG,
        isFileIdLike
      }, Symbol.toStringTag, { value: "Module" }));
      function telegramRleEncode(buf) {
        const len = buf.length;
        const ret = [];
        let count2 = 0;
        for (let i = 0; i < len; i++) {
          const cur = buf[i];
          if (cur === 0) {
            count2 += 1;
          } else {
            if (count2 > 0) {
              ret.push(0, count2);
              count2 = 0;
            }
            ret.push(cur);
          }
        }
        if (count2 > 0) {
          ret.push(0, count2);
        }
        return new Uint8Array(ret);
      }
      function telegramRleDecode(buf) {
        const len = buf.length;
        const ret = [];
        let prev = -1;
        for (let i = 0; i < len; i++) {
          const cur = buf[i];
          if (prev === 0) {
            for (let j = 0; j < cur; j++) {
              ret.push(prev);
            }
            prev = -1;
          } else {
            if (prev !== -1)
              ret.push(prev);
            prev = cur;
          }
        }
        if (prev !== -1)
          ret.push(prev);
        return new Uint8Array(ret);
      }
      function assertNever(_) {
        throw new Error("unreachable");
      }
      function parseWebFileLocation(reader2) {
        return {
          _: "web",
          url: reader2.string(),
          accessHash: reader2.long()
        };
      }
      function parsePhotoSizeSource(platform2, reader2) {
        const variant = reader2.int();
        switch (variant) {
          case 0:
            return {
              _: "legacy",
              secret: reader2.long()
            };
          case 1: {
            const fileType = reader2.int();
            if (fileType < 0 || fileType >= FileType$1.Size) {
              throw new UnsupportedError(
                `Unsupported file type: ${fileType} (${platform2.base64Encode(reader2.uint8View)})`
              );
            }
            const thumbnailType = reader2.int();
            if (thumbnailType < 0 || thumbnailType > 255) {
              throw new InvalidFileIdError(
                `Wrong thumbnail type: ${thumbnailType} (${platform2.base64Encode(reader2.uint8View)})`
              );
            }
            return {
              _: "thumbnail",
              fileType,
              thumbnailType: String.fromCharCode(thumbnailType)
            };
          }
          case 2:
          case 3:
            return {
              _: "dialogPhoto",
              big: variant === 3,
              id: reader2.int53(),
              accessHash: reader2.long()
            };
          case 4:
            return {
              _: "stickerSetThumbnail",
              id: reader2.long(),
              accessHash: reader2.long()
            };
          case 5: {
            const res = {
              _: "fullLegacy",
              volumeId: reader2.long(),
              secret: reader2.long(),
              localId: reader2.int()
            };
            if (res.localId < 0) {
              throw new InvalidFileIdError("Wrong local_id (< 0)");
            }
            return res;
          }
          case 6:
          case 7: {
            const res = {
              _: "dialogPhotoLegacy",
              big: variant === 7,
              id: reader2.int53(),
              accessHash: reader2.long(),
              volumeId: reader2.long(),
              localId: reader2.int()
            };
            if (res.localId < 0) {
              throw new InvalidFileIdError("Wrong local_id (< 0)");
            }
            return res;
          }
          case 8: {
            const res = {
              _: "stickerSetThumbnailLegacy",
              id: reader2.long(),
              accessHash: reader2.long(),
              volumeId: reader2.long(),
              localId: reader2.int()
            };
            if (res.localId < 0) {
              throw new InvalidFileIdError("Wrong local_id (< 0)");
            }
            return res;
          }
          case 9:
            return {
              _: "stickerSetThumbnailVersion",
              id: reader2.long(),
              accessHash: reader2.long(),
              version: reader2.int()
            };
          default:
            throw new UnsupportedError(
              `Unsupported photo size source ${variant} (${platform2.base64Encode(reader2.uint8View)})`
            );
        }
      }
      function parsePhotoFileLocation(platform2, reader2, version2) {
        const id2 = reader2.long();
        const accessHash = reader2.long();
        let source;
        if (version2 >= 32) {
          source = parsePhotoSizeSource(platform2, reader2);
        } else {
          const volumeId = reader2.long();
          let localId = 0;
          if (version2 >= 22) {
            source = parsePhotoSizeSource(platform2, reader2);
            localId = reader2.int();
          } else {
            source = {
              _: "fullLegacy",
              secret: reader2.long(),
              localId: reader2.int(),
              volumeId
            };
          }
          switch (source._) {
            case "legacy":
              source = {
                _: "fullLegacy",
                secret: reader2.long(),
                localId: reader2.int(),
                volumeId
              };
              break;
            case "fullLegacy":
            case "thumbnail":
              break;
            case "dialogPhoto":
              source = {
                _: "dialogPhotoLegacy",
                id: source.id,
                accessHash: source.accessHash,
                big: source.big,
                localId,
                volumeId
              };
              break;
            case "stickerSetThumbnail":
              source = {
                _: "stickerSetThumbnailLegacy",
                id: source.id,
                accessHash: source.accessHash,
                localId,
                volumeId
              };
              break;
            default:
              throw new InvalidFileIdError("Invalid PhotoSizeSource in legacy PhotoRemoteFileLocation");
          }
        }
        return {
          _: "photo",
          id: id2,
          accessHash,
          source
        };
      }
      function parseCommonFileLocation(reader2) {
        return {
          _: "common",
          id: reader2.long(),
          accessHash: reader2.long()
        };
      }
      function fromPersistentIdV23(platform2, binary, version2) {
        if (version2 < 0 || version2 > CURRENT_VERSION) {
          throw new UnsupportedError(`Unsupported file ID v3 subversion: ${version2} (${platform2.base64Encode(binary)})`);
        }
        binary = telegramRleDecode(binary);
        const reader2 = TlBinaryReader.manual(binary);
        let fileType = reader2.int();
        const isWeb = Boolean(fileType & WEB_LOCATION_FLAG);
        const hasFileReference = Boolean(fileType & FILE_REFERENCE_FLAG);
        fileType &= -16777217;
        fileType &= -33554433;
        if (fileType < 0 || fileType >= FileType$1.Size) {
          throw new UnsupportedError(`Unsupported file type: ${fileType} (${platform2.base64Encode(binary)})`);
        }
        const dcId = reader2.int();
        let fileReference = null;
        if (hasFileReference) {
          fileReference = reader2.bytes();
          if (fileReference.length === 1 && fileReference[0] === 35) {
            fileReference = null;
          }
        }
        let location2;
        if (isWeb) {
          location2 = parseWebFileLocation(reader2);
        } else {
          switch (fileType) {
            case FileType$1.Photo:
            case FileType$1.ProfilePhoto:
            case FileType$1.Thumbnail:
            case FileType$1.EncryptedThumbnail:
            case FileType$1.Wallpaper: {
              location2 = parsePhotoFileLocation(platform2, reader2, version2);
              switch (location2.source._) {
                case "thumbnail":
                  if (location2.source.fileType !== fileType || fileType !== FileType$1.Photo && fileType !== FileType$1.Thumbnail && fileType !== FileType$1.EncryptedThumbnail) {
                    throw new InvalidFileIdError("Invalid FileType in PhotoRemoteFileLocation Thumbnail");
                  }
                  break;
                case "dialogPhoto":
                case "dialogPhotoLegacy":
                  if (fileType !== FileType$1.ProfilePhoto) {
                    throw new InvalidFileIdError("Invalid FileType in PhotoRemoteFileLocation DialogPhoto");
                  }
                  break;
                case "stickerSetThumbnail":
                case "stickerSetThumbnailLegacy":
                case "stickerSetThumbnailVersion":
                  if (fileType !== FileType$1.Thumbnail) {
                    throw new InvalidFileIdError(
                      "Invalid FileType in PhotoRemoteFileLocation StickerSetThumbnail"
                    );
                  }
                  break;
              }
              break;
            }
            case FileType$1.Video:
            case FileType$1.VoiceNote:
            case FileType$1.Document:
            case FileType$1.Sticker:
            case FileType$1.Audio:
            case FileType$1.Animation:
            case FileType$1.Encrypted:
            case FileType$1.VideoNote:
            case FileType$1.SecureRaw:
            case FileType$1.Secure:
            case FileType$1.Background:
            case FileType$1.DocumentAsFile: {
              location2 = parseCommonFileLocation(reader2);
              break;
            }
            default:
              throw new UnsupportedError(`Invalid file type: ${fileType} (${platform2.base64Encode(binary)})`);
          }
        }
        return {
          _: "remoteFileLocation",
          dcId,
          type: fileType,
          fileReference,
          location: location2
        };
      }
      function fromPersistentIdV2(platform2, binary) {
        return fromPersistentIdV23(platform2, binary.subarray(0, -1), 0);
      }
      function fromPersistentIdV3(platform2, binary) {
        const subversion = binary[binary.length - 2];
        return fromPersistentIdV23(platform2, binary.subarray(0, -2), subversion);
      }
      function parseFileId(platform2, fileId) {
        if (typeof fileId === "string")
          fileId = platform2.base64Decode(fileId, true);
        const version2 = fileId[fileId.length - 1];
        if (version2 === PERSISTENT_ID_VERSION_OLD) {
          return fromPersistentIdV2(platform2, fileId);
        }
        if (version2 === PERSISTENT_ID_VERSION) {
          return fromPersistentIdV3(platform2, fileId);
        }
        throw new UnsupportedError(`Unsupported file ID version: ${version2} (${platform2.base64Encode(fileId)})`);
      }
      const SUFFIX = new Uint8Array([CURRENT_VERSION, PERSISTENT_ID_VERSION]);
      function toFileId(platform2, location2) {
        const loc = location2.location;
        let type = location2.type;
        if (loc._ === "web")
          type |= WEB_LOCATION_FLAG;
        if (location2.fileReference)
          type |= FILE_REFERENCE_FLAG;
        const writer2 = TlBinaryWriter.manual(loc._ === "web" ? platform2.utf8ByteLength(loc.url) + 32 : 100);
        writer2.int(type);
        writer2.int(location2.dcId);
        if (location2.fileReference) {
          writer2.bytes(location2.fileReference);
        }
        switch (loc._) {
          case "web":
            writer2.string(loc.url);
            writer2.long(loc.accessHash);
            break;
          case "photo":
            writer2.long(loc.id);
            writer2.long(loc.accessHash);
            switch (loc.source._) {
              case "legacy":
                writer2.int(0);
                writer2.long(loc.source.secret);
                break;
              case "thumbnail":
                writer2.int(1);
                writer2.int(loc.source.fileType);
                writer2.int(loc.source.thumbnailType.charCodeAt(0));
                break;
              case "dialogPhoto":
                writer2.int(loc.source.big ? 3 : 2);
                writer2.int53(loc.source.id);
                writer2.long(loc.source.accessHash);
                break;
              case "stickerSetThumbnail":
                writer2.int(4);
                writer2.long(loc.source.id);
                writer2.long(loc.source.accessHash);
                break;
              case "fullLegacy":
                writer2.int(5);
                writer2.long(loc.source.volumeId);
                writer2.long(loc.source.secret);
                writer2.int(loc.source.localId);
                break;
              case "dialogPhotoLegacy":
                writer2.int(loc.source.big ? 7 : 6);
                writer2.int53(loc.source.id);
                writer2.long(loc.source.accessHash);
                writer2.long(loc.source.volumeId);
                writer2.int(loc.source.localId);
                break;
              case "stickerSetThumbnailLegacy":
                writer2.int(8);
                writer2.long(loc.source.id);
                writer2.long(loc.source.accessHash);
                writer2.long(loc.source.volumeId);
                writer2.int(loc.source.localId);
                break;
              case "stickerSetThumbnailVersion":
                writer2.int(9);
                writer2.long(loc.source.id);
                writer2.long(loc.source.accessHash);
                writer2.int(loc.source.version);
                break;
              default:
                assertNever(loc.source);
            }
            break;
          case "common":
            writer2.long(loc.id);
            writer2.long(loc.accessHash);
            break;
          default:
            assertNever();
        }
        const result = telegramRleEncode(writer2.result());
        const withSuffix = new Uint8Array(result.length + SUFFIX.length);
        withSuffix.set(result);
        withSuffix.set(SUFFIX, result.length);
        return platform2.base64Encode(withSuffix, true);
      }
      function toUniqueFileId(platform2, first, second) {
        const inputType = typeof first === "number" ? first : first.type;
        const inputLocation = typeof first === "number" ? second : first.location;
        let type;
        if (inputLocation._ === "web") {
          type = 0;
        } else {
          switch (inputType) {
            case FileType$1.Photo:
            case FileType$1.ProfilePhoto:
            case FileType$1.Thumbnail:
            case FileType$1.EncryptedThumbnail:
            case FileType$1.Wallpaper:
              type = 1;
              break;
            case FileType$1.Video:
            case FileType$1.VoiceNote:
            case FileType$1.Document:
            case FileType$1.Sticker:
            case FileType$1.Audio:
            case FileType$1.Animation:
            case FileType$1.VideoNote:
            case FileType$1.Background:
            case FileType$1.DocumentAsFile:
              type = 2;
              break;
            case FileType$1.SecureRaw:
            case FileType$1.Secure:
              type = 3;
              break;
            case FileType$1.Encrypted:
              type = 4;
              break;
            case FileType$1.Temp:
              type = 5;
              break;
            default:
              throw new InvalidFileIdError(`Invalid file type: ${inputType}`);
          }
        }
        let writer2;
        switch (inputLocation._) {
          case "photo": {
            const source = inputLocation.source;
            switch (source._) {
              case "legacy": {
                writer2 = TlBinaryWriter.manual(16);
                writer2.int(type);
                writer2.int(100);
                writer2.long(source.secret);
                break;
              }
              case "stickerSetThumbnail": {
                writer2 = TlBinaryWriter.manual(24);
                writer2.int(type);
                writer2.int(150);
                writer2.long(source.id);
                writer2.long(source.accessHash);
                break;
              }
              case "dialogPhoto": {
                writer2 = TlBinaryWriter.manual(13);
                writer2.int(type);
                writer2.long(inputLocation.id);
                writer2.raw(new Uint8Array([Number(source.big)]));
                break;
              }
              case "thumbnail": {
                writer2 = TlBinaryWriter.manual(13);
                let thumbType = source.thumbnailType.charCodeAt(0);
                if (thumbType === 97) {
                  thumbType = 0;
                } else if (thumbType === 99) {
                  thumbType = 1;
                } else {
                  thumbType += 5;
                }
                writer2.int(type);
                writer2.long(inputLocation.id);
                writer2.raw(new Uint8Array([thumbType]));
                break;
              }
              case "fullLegacy":
              case "dialogPhotoLegacy":
              case "stickerSetThumbnailLegacy":
                writer2 = TlBinaryWriter.manual(16);
                writer2.int(type);
                writer2.long(source.volumeId);
                writer2.int(source.localId);
                break;
              case "stickerSetThumbnailVersion":
                writer2 = TlBinaryWriter.manual(17);
                writer2.int(type);
                writer2.raw(new Uint8Array([2]));
                writer2.long(source.id);
                writer2.int(source.version);
                break;
            }
            break;
          }
          case "web":
            writer2 = TlBinaryWriter.manual(platform2.utf8ByteLength(inputLocation.url) + 8);
            writer2.int(type);
            writer2.string(inputLocation.url);
            break;
          case "common":
            writer2 = TlBinaryWriter.manual(12);
            writer2.int(type);
            writer2.long(inputLocation.id);
            break;
          default:
            assertNever();
        }
        return platform2.base64Encode(telegramRleEncode(writer2.result()), true);
      }
      class FileLocation {
        constructor(location2, fileSize, dcId) {
          this.location = location2;
          this.fileSize = fileSize;
          this.dcId = dcId;
        }
      }
      exports("bY", FileLocation);
      function isUploadedFile(obj) {
        return obj !== null && typeof obj === "object" && "inputFile" in obj && "size" in obj && "mime" in obj;
      }
      function STUB_LOCATION() {
        throw new MtArgumentError("This web document is not downloadable through Telegram");
      }
      class WebDocument extends FileLocation {
        constructor(raw) {
          super(
            raw._ === "webDocument" ? {
              _: "inputWebFileLocation",
              url: raw.url,
              accessHash: raw.accessHash
            } : STUB_LOCATION,
            raw.size
          );
          this.raw = raw;
          this.raw = raw;
        }
        /**
         * URL to the file
         */
        get url() {
          return this.raw.url;
        }
        /**
         * MIME type of the file
         */
        get mimeType() {
          return this.raw.mimeType;
        }
        /**
         * Whether this file can be downloaded through Telegram.
         *
         * If `false`, you should use {@link url} to manually
         * fetch data via HTTP(s), and trying to use `download*` methods
         * will result in an error
         */
        get isDownloadable() {
          return this.raw._ === "webDocument";
        }
      }
      exports("dl", WebDocument);
      class ChatPhotoSize extends FileLocation {
        constructor(peer, obj, big) {
          super(
            {
              _: "inputPeerPhotoFileLocation",
              peer,
              photoId: obj.photoId,
              big
            },
            void 0,
            obj.dcId
          );
          this.peer = peer;
          this.obj = obj;
          this.big = big;
          this.peer = peer;
          this.obj = obj;
          this.big = big;
        }
        /**
         * TDLib and Bot API compatible File ID representing this size
         */
        get fileId() {
          const peer = this.peer;
          let id2;
          let hash;
          switch (peer._) {
            case "inputPeerUser":
              id2 = peer.userId;
              hash = peer.accessHash;
              break;
            case "inputPeerChat":
              id2 = -peer.chatId;
              hash = Long.ZERO;
              break;
            case "inputPeerChannel":
              id2 = toggleChannelIdMark(peer.channelId);
              hash = peer.accessHash;
              break;
            default:
              throw new MtArgumentError("Input peer was invalid");
          }
          return toFileId(getPlatform(), {
            dcId: this.obj.dcId,
            type: typesInner.FileType.ProfilePhoto,
            fileReference: null,
            location: {
              _: "photo",
              id: this.obj.photoId,
              accessHash: Long.ZERO,
              source: {
                _: "dialogPhoto",
                big: this.big,
                id: id2,
                accessHash: hash
              }
            }
          });
        }
        /**
         * TDLib and Bot API compatible unique File ID representing this size
         */
        get uniqueFileId() {
          return toUniqueFileId(getPlatform(), typesInner.FileType.ProfilePhoto, {
            _: "photo",
            id: this.obj.photoId,
            // eslint-disable-next-line ts/no-unsafe-assignment
            source: {
              _: "dialogPhoto",
              big: this.big
            }
          });
        }
      }
      exports("bI", ChatPhotoSize);
      memoizeGetters(ChatPhotoSize, ["fileId", "uniqueFileId"]);
      class ChatPhoto {
        constructor(peer, raw) {
          this.peer = peer;
          this.raw = raw;
        }
        /**
         * Whether this photo is personal (i.e. you set it yourself for this peer)
         */
        get isPersonal() {
          return this.raw._ === "userProfilePhoto" && this.raw.personal;
        }
        /** Chat photo file location in small resolution (160x160) */
        get small() {
          return new ChatPhotoSize(this.peer, this.raw, false);
        }
        /** Chat photo file location in big resolution (640x640) */
        get big() {
          return new ChatPhotoSize(this.peer, this.raw, true);
        }
        /**
         * Chat photo preview in *very* small resolution, if available
         */
        get thumb() {
          if (!this.raw.strippedThumb)
            return null;
          return strippedPhotoToJpg(this.raw.strippedThumb);
        }
      }
      exports("bH", ChatPhoto);
      memoizeGetters(ChatPhoto, ["small", "big", "thumb"]);
      class User {
        constructor(user) {
          __publicField(this, "type", "user");
          /**
           * Underlying raw TL object
           */
          __publicField(this, "raw");
          assertTypeIs("User#init", user, "user");
          this.raw = user;
        }
        /** Unique identifier for this user or bot */
        get id() {
          return this.raw.id;
        }
        /**
         * Whether this user's information is incomplete.
         *
         * This usually only happens in large chats, where
         * the server sometimes sends only a part of the user's
         * information. Basic info like name and profile photo
         * are always available, but other fields may be omitted
         * despite being available.
         *
         * For a rough list of fields that may be missing, see the
         * [official docs](https://core.telegram.org/constructor/user).
         *
         * This currently only ever happens for non-bot users, so if you are building
         * a normal bot, you can safely ignore this field.
         *
         * To fetch the "complete" user information, use one of these methods:
         *  - {@link TelegramClient.getUsers}
         *  - {@link TelegramClient.getChat}
         *  - {@link TelegramClient.getFullChat}.
         *
         * Learn more: [Incomplete peers](https://mtcute.dev/guide/topics/peers.html#incomplete-peers)
         */
        get isMin() {
          return this.raw.min;
        }
        /** Whether this user is you yourself */
        get isSelf() {
          return this.raw.self;
        }
        /** Whether this user is in your contacts */
        get isContact() {
          return this.raw.contact;
        }
        /** Whether you both have each other's contact */
        get isMutualContact() {
          return this.raw.mutualContact;
        }
        /** Whether this user is in yout "close friends" list */
        get isCloseFriend() {
          return this.raw.closeFriend;
        }
        /** Whether this user is deleted */
        get isDeleted() {
          return this.raw.deleted;
        }
        /** Whether this user is a bot */
        get isBot() {
          return this.raw.bot;
        }
        /**
         * Whether this user is a bot that can be connected to a
         * Telegram Business account to receive its messages
         */
        get isBusinessBot() {
          return this.raw.botBusiness;
        }
        /** Whether this user is a bot that has access to all messages */
        get isBotWithHistory() {
          return this.raw.botChatHistory;
        }
        /** Whether this user is a bot that can't be added to chats */
        get isBotWithoutChats() {
          return this.raw.botNochats;
        }
        /** Whether this bot offers an attachment menu web app */
        get isBotWithAttachmentMenu() {
          return this.raw.botAttachMenu;
        }
        /** Whether this bot can be edited by the current user */
        get isBotEditable() {
          return this.raw.botCanEdit;
        }
        /** Whether this user has been verified by Telegram */
        get isVerified() {
          return this.raw.verified;
        }
        /**
         * Whether this user has been restricted. Bots only.
         * See {@link restrictionReason} for details
         */
        get isRestricted() {
          return this.raw.restricted;
        }
        /**
         * Reason why this bot was restricted
         */
        get restrictionReason() {
          var _a3;
          return (_a3 = this.raw.restrictionReason) != null ? _a3 : [];
        }
        /** Whether this user has been flagged for scam */
        get isScam() {
          return this.raw.scam;
        }
        /** Whether this user has been flagged for impersonation */
        get isFake() {
          return this.raw.fake;
        }
        /** Whether this user is part of the Telegram support team */
        get isSupport() {
          return this.raw.support;
        }
        /** Whether this user has Premium subscription */
        get isPremium() {
          return this.raw.premium;
        }
        /** Whether Premium is required to contact this user */
        get isPremiumRequired() {
          return this.raw.contactRequirePremium;
        }
        /** Number of bot's active users, if available */
        get botActiveUsers() {
          var _a3;
          return (_a3 = this.raw.botActiveUsers) != null ? _a3 : null;
        }
        /** Whether this bot has a main app */
        get hasMainApp() {
          return this.raw.botHasMainApp;
        }
        /** User's or bot's first name */
        get firstName() {
          var _a3;
          return (_a3 = this.raw.firstName) != null ? _a3 : "Deleted Account";
        }
        /** User's or bot's last name */
        get lastName() {
          var _a3;
          return (_a3 = this.raw.lastName) != null ? _a3 : null;
        }
        static parseStatus(status, bot = false) {
          let ret;
          let date2;
          let byMe = false;
          const us = status;
          if (bot) {
            ret = "bot";
          } else if (!us) {
            ret = "long_time_ago";
          } else {
            switch (us._) {
              case "userStatusOnline":
                ret = "online";
                date2 = new Date(us.expires * 1e3);
                break;
              case "userStatusOffline":
                ret = "offline";
                date2 = new Date(us.wasOnline * 1e3);
                break;
              case "userStatusRecently":
                ret = "recently";
                byMe = us.byMe;
                break;
              case "userStatusLastWeek":
                ret = "within_week";
                byMe = us.byMe;
                break;
              case "userStatusLastMonth":
                ret = "within_month";
                byMe = us.byMe;
                break;
              default:
                ret = "long_time_ago";
                break;
            }
          }
          return {
            status: ret,
            lastOnline: ret === "offline" ? date2 : null,
            nextOffline: ret === "online" ? date2 : null,
            byMe
          };
        }
        get _parsedStatus() {
          return User.parseStatus(this.raw.status, this.raw.bot);
        }
        /** User's Last Seen & Online status */
        get status() {
          return this._parsedStatus.status;
        }
        /**
         * Whether user's online status is hidden because
         * we have hidden our own online status from them,
         * and we don't have Premium subscription.
         */
        get statusHiddenByMe() {
          return this._parsedStatus.byMe;
        }
        /**
         * Last time this user was seen online.
         * Only available if {@link status} is `offline`
         */
        get lastOnline() {
          return this._parsedStatus.lastOnline;
        }
        /**
         * Time when this user will automatically go offline.
         * Only available if {@link status} is `online`
         */
        get nextOffline() {
          return this._parsedStatus.nextOffline;
        }
        /** User's or bot's username */
        get username() {
          var _a3, _b2, _c, _d;
          return (_d = (_c = this.raw.username) != null ? _c : (_b2 = (_a3 = this.raw.usernames) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.username) != null ? _d : null;
        }
        /** User's or bot's usernames (including collectibles) */
        get usernames() {
          var _a3;
          if (this.raw.username) {
            return [{ _: "username", username: this.raw.username, active: true }];
          }
          if (!((_a3 = this.raw.usernames) == null ? void 0 : _a3.length)) {
            return null;
          }
          return this.raw.usernames;
        }
        /**
         * IETF language tag of the user's language
         *
         * Only available in some contexts
         */
        get language() {
          var _a3;
          return (_a3 = this.raw.langCode) != null ? _a3 : null;
        }
        /**
         * User's or bot's assigned DC (data center).
         * Available only in case the user has set a public profile photo.
         *
         * **Note**: this information is approximate; it is based on where
         * Telegram stores a user profile pictures and does not by any means tell
         * you the user location (i.e. a user might travel far away, but will still connect
         * to its assigned DC).
         * More info at [Pyrogram FAQ](https://docs.pyrogram.org/faq#what-are-the-ip-addresses-of-telegram-data-centers).
         */
        get dcId() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.photo) == null ? void 0 : _a3.dcId) != null ? _b2 : null;
        }
        /** User's phone number */
        get phoneNumber() {
          var _a3;
          return (_a3 = this.raw.phone) != null ? _a3 : null;
        }
        /**
         * Get this user's input peer for advanced use-cases.
         *
         * > **Note**: for {@link min} users, this method will return
         * > `mtcute.dummyInputPeerMinUser`, which is actually not a valid input peer.
         * > These are used to indicate that the user is incomplete, and a message
         * > reference is needed to resolve the peer.
         * >
         * > Such objects are handled by {@link TelegramClient.resolvePeer} method,
         * > so prefer using it whenever you need an input peer.
         */
        get inputPeer() {
          if (this.raw.min) {
            return {
              _: "mtcute.dummyInputPeerMinUser",
              userId: this.raw.id
            };
          }
          if (!this.raw.accessHash) {
            throw new MtArgumentError("user's access hash is not available!");
          }
          return {
            _: "inputPeerUser",
            userId: this.raw.id,
            accessHash: this.raw.accessHash
          };
        }
        /**
         * User's or bot's current profile photo, if any.
         * Suitable for downloads only
         */
        get photo() {
          var _a3;
          if (((_a3 = this.raw.photo) == null ? void 0 : _a3._) !== "userProfilePhoto")
            return null;
          return new ChatPhoto(this.inputPeer, this.raw.photo);
        }
        /**
         * The list of reasons why this bot might be unavailable to some users.
         * This field is available only in case *isRestricted* is `true`
         */
        get restrictions() {
          var _a3;
          return (_a3 = this.raw.restrictionReason) != null ? _a3 : null;
        }
        /**
         * User's display name.
         *
         * First name and last name if available,
         * only first name otherwise.
         */
        get displayName() {
          if (!this.firstName)
            return "Deleted Account";
          if (this.lastName)
            return `${this.firstName} ${this.lastName}`;
          return this.firstName;
        }
        /**
         * User's emoji status, if any.
         */
        get emojiStatus() {
          if (!this.raw.emojiStatus || this.raw.emojiStatus._ === "emojiStatusEmpty")
            return null;
          return new EmojiStatus(this.raw.emojiStatus);
        }
        /** Whether you have hidden (arhived) this user's stories */
        get storiesHidden() {
          return this.raw.storiesHidden;
        }
        get storiesUnavailable() {
          return this.raw.storiesUnavailable;
        }
        /**
         * Maximum ID of stories this user has (or 0 if none)
         */
        get storiesMaxId() {
          var _a3;
          return (_a3 = this.raw.storiesMaxId) != null ? _a3 : 0;
        }
        /**
         * Color that should be used when rendering replies to
         * their messages and web previews sent by them,
         * as well as to render the chat title
         */
        get color() {
          return new ChatColors(this.raw.id, this.raw.color);
        }
        /**
         * Color that should be used when rendering the header of
         * the user's profile
         *
         * If `null`, a generic header should be used instead
         */
        get profileColors() {
          return this.raw.profileColor ? new ChatColors(this.raw.id, this.raw.profileColor) : null;
        }
        /**
         * Create a mention for the user.
         *
         * When available and `text` is omitted, this method will return `@username`.
         * Otherwise, text mention is created.
         *
         * Use `null` as `text` (first parameter) to force create a text
         * mention with display name, even if there is a username.
         *
         * > **Note**: This method doesn't format anything on its own.
         * > Instead, it returns a {@link MessageEntity} that can later
         * > be used with `html` or `md` template tags
         *
         * @param text  Text of the mention.
         * @example
         * ```typescript
         * msg.replyText(html`Hello, ${msg.sender.mention()`)
         * ```
         */
        mention(text2) {
          if (text2 === void 0 && this.username) {
            return `@${this.username}`;
          }
          if (!text2)
            text2 = this.displayName;
          return new MessageEntity(
            {
              _: "messageEntityMentionName",
              offset: 0,
              length: text2.length,
              userId: this.raw.id
            },
            text2
          );
        }
        /**
         * Create a permanent mention for this user.
         *
         * Permanent* means that this mention will also
         * contain user's access hash, so even if the user
         * changes their username or the client forgets
         * about that user, it can still be mentioned.
         *
         * Telegram might change access hash in some cases,
         * so it may not exactly be *permanent*. The only way
         * to actually make it permanent is to send it as a message
         * somewhere and load it from there if needed.
         *
         * Note that some users (particularly, users with hidden forwards)
         * may not be mentioned like this outside the chats you have in common.
         *
         * This method is only needed when the result will be
         * stored somewhere outside current mtcute instance (e.g. saved for later use),
         * otherwise {@link mention} will be enough.
         *
         * > **Note**: This method doesn't format anything on its own.
         * > Instead, it returns a {@link MessageEntity} that can later
         * > be used with `html` or `md` template tags
         *
         * > **Note**: the resulting text can only be used by clients
         * > that support mtcute notation of permanent
         * > mention links (`tg://user?id=123&hash=abc`).
         * >
         * > Also note that these permanent mentions are only
         * > valid for current account, since peer access hashes are
         * > account-specific and can't be used on another account.
         * >
         * > Also note that for some users such mentions might not work at all
         * > due to privacy settings.
         *
         * @param text  Mention text
         */
        permanentMention(text2) {
          if (!this.raw.accessHash) {
            throw new MtArgumentError("User's access hash is not available!");
          }
          if (!text2)
            text2 = this.displayName;
          return new MessageEntity(
            {
              _: "messageEntityTextUrl",
              offset: 0,
              length: text2.length,
              url: `tg://user?id=${this.id}&hash=${this.raw.accessHash.toString(16)}`
            },
            text2
          );
        }
      }
      exports("dd", User);
      memoizeGetters(User, [
        "_parsedStatus",
        "usernames",
        "inputPeer",
        "photo",
        "emojiStatus",
        "color",
        "profileColors"
      ]);
      class Chat {
        constructor(peer) {
          __publicField(this, "type", "chat");
          /**
           * Raw peer object that this {@link Chat} represents.
           */
          __publicField(this, "peer");
          /**
           * Distance in meters of this group chat from your location
           * Returned only in {@link TelegramClient.getNearbyChats}
           */
          __publicField(this, "distance");
          if (!peer)
            throw new MtArgumentError("peer is not available");
          switch (peer._) {
            case "user":
            case "chat":
            case "channel":
            case "chatForbidden":
            case "channelForbidden":
              break;
            default:
              throw new MtTypeAssertionError("peer", "user | chat | channel", peer._);
          }
          this.peer = peer;
        }
        /** Marked ID of this chat */
        get id() {
          return getMarkedPeerId(this.inputPeer);
        }
        /**
         * Whether this chat's information is incomplete.
         *
         * This usually only happens in large chats, where
         * the server sometimes sends only a part of the chat's
         * information. Basic info like name and profile photo
         * are always available, but other fields may be omitted
         * despite being available.
         *
         * For a rough list of fields that may be missing, see the
         * official docs for [channel](https://core.telegram.org/constructor/channel)
         * and [user](https://core.telegram.org/constructor/user).
         *
         * This currently only ever happens for non-bot users, so if you are building
         * a normal bot, you can safely ignore this field.
         *
         * To fetch the "complete" user information, use one of these methods:
         *  - {@link TelegramClient.getChat}
         *  - {@link TelegramClient.getFullChat}.
         *
         * Learn more: [Incomplete peers](https://mtcute.dev/guide/topics/peers.html#incomplete-peers)
         */
        get isMin() {
          return Boolean(this.peer.min);
        }
        /**
         * Chat's input peer for advanced use-cases.
         *
         * > **Note**: for {@link min} chats, this method will return
         * > `mtcute.dummyInputPeerMin*`, which are actually not a valid input peer,
         * > These are used to indicate that the user is incomplete, and a message
         * > reference is needed to resolve the peer.
         * >
         * > Such objects are handled by {@link TelegramClient.resolvePeer} method,
         * so prefer using it whenever you need an input peer.
         */
        get inputPeer() {
          switch (this.peer._) {
            case "user":
              if (this.peer.min) {
                return {
                  _: "mtcute.dummyInputPeerMinUser",
                  userId: this.peer.id
                };
              }
              if (!this.peer.accessHash) {
                throw new MtArgumentError("Peer's access hash is not available!");
              }
              return {
                _: "inputPeerUser",
                userId: this.peer.id,
                accessHash: this.peer.accessHash
              };
            case "chat":
            case "chatForbidden":
              return {
                _: "inputPeerChat",
                chatId: this.peer.id
              };
            case "channel":
            case "channelForbidden":
              if (this.peer.min) {
                return {
                  _: "mtcute.dummyInputPeerMinChannel",
                  channelId: this.peer.id
                };
              }
              if (!this.peer.accessHash) {
                throw new MtArgumentError("Peer's access hash is not available!");
              }
              return {
                _: "inputPeerChannel",
                channelId: this.peer.id,
                accessHash: this.peer.accessHash
              };
          }
        }
        /** Type of chat */
        get chatType() {
          switch (this.peer._) {
            case "user":
              return this.peer.bot ? "bot" : "private";
            case "chat":
            case "chatForbidden":
              return "group";
            case "channel":
            case "channelForbidden":
              if (this.peer._ === "channel" && this.peer.gigagroup) {
                return "gigagroup";
              } else if (this.peer.broadcast) {
                return "channel";
              }
              return "supergroup";
          }
        }
        /**
         * Whether this chat is a group chat
         * (i.e. not a channel and not PM)
         */
        get isGroup() {
          switch (this.chatType) {
            case "group":
            case "supergroup":
            case "gigagroup":
              return true;
          }
          return false;
        }
        /**
         * Whether this chat has been verified by Telegram.
         * Supergroups, channels and groups only
         */
        get isVerified() {
          return "verified" in this.peer ? this.peer.verified : false;
        }
        /**
         * Whether this chat has been restricted.
         * See {@link restrictions} for details
         */
        get isRestricted() {
          return "restricted" in this.peer ? this.peer.restricted : false;
        }
        /**
         * Whether this chat is owned by the current user.
         * Supergroups, channels and groups only
         */
        get isCreator() {
          return "creator" in this.peer ? this.peer.creator : false;
        }
        /**
         * Whether current user has admin rights in this chat.
         * Supergroups, channels and groups only.
         */
        get isAdmin() {
          return "adminRights" in this.peer && Boolean(this.peer.adminRights);
        }
        /** Whether this chat has been flagged for scam */
        get isScam() {
          return "scam" in this.peer ? this.peer.scam : false;
        }
        /** Whether this chat has been flagged for impersonation */
        get isFake() {
          return "fake" in this.peer ? this.peer.fake : false;
        }
        /** Whether this chat is part of the Telegram support team. Users and bots only */
        get isSupport() {
          return this.peer._ === "user" && this.peer.support;
        }
        /** Whether this chat is chat with yourself (i.e. Saved Messages) */
        get isSelf() {
          return this.peer._ === "user" && this.peer.self;
        }
        /** Whether this peer is your contact */
        get isContact() {
          return this.peer._ === "user" && this.peer.contact;
        }
        /** Whether this peer is a forum supergroup */
        get isForum() {
          return this.peer._ === "channel" && this.peer.forum;
        }
        /** Whether the chat is not available (e.g. because the user was banned from there) */
        get isUnavailable() {
          return this.peer._ === "chatForbidden" || this.peer._ === "channelForbidden";
        }
        /**
         * Whether the current user is a member of the chat.
         *
         * For users, this is always `true`.
         */
        get isMember() {
          switch (this.peer._) {
            case "user":
              return true;
            case "channel":
            case "chat":
              return !this.peer.left;
            default:
              return false;
          }
        }
        /** Whether you have hidden (arhived) this chat's stories */
        get storiesHidden() {
          return "storiesHidden" in this.peer ? this.peer.storiesHidden : false;
        }
        get storiesUnavailable() {
          return "storiesUnavailable" in this.peer ? this.peer.storiesUnavailable : false;
        }
        /** Whether this group is a channel/supergroup with join requests enabled */
        get hasJoinRequests() {
          return this.peer._ === "channel" && this.peer.joinRequest;
        }
        /** Whether this group is a supergroup with join-to-send rule enabled */
        get hasJoinToSend() {
          return this.peer._ === "channel" && this.peer.joinToSend;
        }
        /** Whether this group has content protection (i.e. disabled forwards) */
        get hasContentProtection() {
          return (this.peer._ === "channel" || this.peer._ === "chat") && this.peer.noforwards;
        }
        /** Whether this channel has profile signatures (i.e. "Super Channel") */
        get hasProfileSignatures() {
          return this.peer._ === "channel" && this.peer.signatureProfiles;
        }
        /**
         * Title, for supergroups, channels and groups
         */
        get title() {
          var _a3;
          return this.peer._ !== "user" ? (_a3 = this.peer.title) != null ? _a3 : null : null;
        }
        /**
         * Username, for private chats, bots, supergroups and channels if available
         */
        get username() {
          var _a3, _b2, _c;
          if (!("username" in this.peer))
            return null;
          return (_c = (_b2 = this.peer.username) != null ? _b2 : (_a3 = this.peer.usernames) == null ? void 0 : _a3[0].username) != null ? _c : null;
        }
        /**
         * Usernames (inclufing collectibles), for private chats, bots, supergroups and channels if available
         */
        get usernames() {
          var _a3;
          if (!("usernames" in this.peer))
            return null;
          return (_a3 = this.peer.usernames) != null ? _a3 : this.peer.username ? [{ _: "username", username: this.peer.username, active: true }] : null;
        }
        /**
         * First name of the other party in a private chat,
         * for private chats and bots
         */
        get firstName() {
          var _a3;
          return this.peer._ === "user" ? (_a3 = this.peer.firstName) != null ? _a3 : null : null;
        }
        /**
         * Last name of the other party in a private chat, for private chats
         */
        get lastName() {
          var _a3;
          return this.peer._ === "user" ? (_a3 = this.peer.lastName) != null ? _a3 : null : null;
        }
        /**
         * Get the display name of the chat.
         *
         * Title for groups and channels,
         * name (and last name if available) for users
         */
        get displayName() {
          var _a3;
          if (this.peer._ === "user") {
            if (this.peer.lastName) {
              return `${this.peer.firstName} ${this.peer.lastName}`;
            }
            return (_a3 = this.peer.firstName) != null ? _a3 : "Deleted Account";
          }
          return this.peer.title;
        }
        /**
         * Chat photo, if any.
         * Suitable for downloads only.
         *
         * If full chat information is available, prefer {@link FullChat#fullPhoto} instead.
         */
        get photo() {
          if (!("photo" in this.peer) || !this.peer.photo || this.peer.photo._ !== "userProfilePhoto" && this.peer.photo._ !== "chatPhoto") {
            return null;
          }
          return new ChatPhoto(this.inputPeer, this.peer.photo);
        }
        /**
         * User's or bot's assigned DC (data center).
         * Available only in case the user has set a public profile photo.
         *
         * **Note**: this information is approximate; it is based on where
         * Telegram stores the current chat photo. It is accurate only in case
         * the owner has set the chat photo, otherwise it will be the DC assigned
         * to the administrator who set the current profile photo.
         */
        get dcId() {
          var _a3, _b2;
          if (!("photo" in this.peer))
            return null;
          return (_b2 = (_a3 = this.peer.photo) == null ? void 0 : _a3.dcId) != null ? _b2 : null;
        }
        /**
         * The list of reasons why this chat might be unavailable to some users.
         * This field is available only in case {@link isRestricted} is `true`
         */
        get restrictions() {
          var _a3;
          return "restrictionReason" in this.peer ? (_a3 = this.peer.restrictionReason) != null ? _a3 : null : null;
        }
        /**
         * Current user's permissions, for supergroups.
         */
        get permissions() {
          if (!("bannedRights" in this.peer && this.peer.bannedRights)) {
            return null;
          }
          return new ChatPermissions(this.peer.bannedRights);
        }
        /**
         * Default chat member permissions, for groups and supergroups.
         */
        get defaultPermissions() {
          if (!("defaultBannedRights" in this.peer) || !this.peer.defaultBannedRights) {
            return null;
          }
          return new ChatPermissions(this.peer.defaultBannedRights);
        }
        /**
         * Admin rights of the current user in this chat.
         * `null` for PMs and non-administered chats
         */
        get adminRights() {
          var _a3;
          return "adminRights" in this.peer ? (_a3 = this.peer.adminRights) != null ? _a3 : null : null;
        }
        /**
         * Maximum ID of stories this chat has (or 0 if none)
         */
        get storiesMaxId() {
          var _a3;
          switch (this.peer._) {
            case "channel":
            case "user":
              return (_a3 = this.peer.storiesMaxId) != null ? _a3 : 0;
          }
          return 0;
        }
        /**
         * Color that should be used when rendering replies to
         * the messages and web previews sent by this chat,
         * as well as to render the chat title
         */
        get color() {
          const color2 = this.peer._ === "user" || this.peer._ === "channel" ? this.peer.color : void 0;
          return new ChatColors(this.peer.id, color2);
        }
        /**
         * Chat's emoji status, if any.
         */
        get emojiStatus() {
          if (this.peer._ !== "user" && this.peer._ !== "channel")
            return null;
          if (!this.peer.emojiStatus || this.peer.emojiStatus._ === "emojiStatusEmpty")
            return null;
          return new EmojiStatus(this.peer.emojiStatus);
        }
        /**
         * Color that should be used when rendering the header of
         * the user's profile
         *
         * If `null`, a generic header should be used instead
         */
        get profileColors() {
          const color2 = this.peer._ === "user" || this.peer._ === "channel" ? this.peer.profileColor : void 0;
          return new ChatColors(this.peer.id, color2);
        }
        /** Boosts level this chat has (0 if none or is not a channel) */
        get boostsLevel() {
          var _a3;
          return this.peer._ === "channel" ? (_a3 = this.peer.level) != null ? _a3 : 0 : 0;
        }
        /**
         * Get a {@link User} from this chat.
         *
         * Returns `null` if this is not a chat with user
         */
        get user() {
          if (this.peer._ !== "user")
            return null;
          return new User(this.peer);
        }
        /**
         * If a subscription to this channel was bought using Telegram Stars,
         * this field will contain the date when the subscription will expire.
         */
        get subscriptionUntilDate() {
          if (this.peer._ !== "channel" || !this.peer.subscriptionUntilDate)
            return null;
          return new Date(this.peer.subscriptionUntilDate * 1e3);
        }
        /** @internal */
        static _parseFromMessage(message2, peers) {
          return Chat._parseFromPeer(message2.peerId, peers);
        }
        /** @internal */
        static _parseFromPeer(peer, peers) {
          switch (peer._) {
            case "peerUser":
              return new Chat(peers.user(peer.userId));
            case "peerChat":
              return new Chat(peers.chat(peer.chatId));
          }
          return new Chat(peers.chat(peer.channelId));
        }
        /**
         * Create a mention for the chat.
         *
         * If this is a user, works just like {@link User.mention}.
         * Otherwise, if the chat has a username, a `@username` is created
         * (or text link, if `text` is passed). If it does not, chat title is
         * simply returned without additional formatting.
         *
         * When available and `text` is omitted, this method will return `@username`.
         * Otherwise, text mention is created for the given (or default) parse mode
         *
         * Use `null` as `text` (first parameter) to force create a text
         * mention with display name, even if there is a username.
         *
         * > **Note**: This method doesn't format anything on its own.
         * > Instead, it returns a {@link MessageEntity} that can later
         * > be used with `html` or `md` template tags, or `unparse` method directly.
         *
         * @param text  Text of the mention.
         * @example
         * ```typescript
         * msg.replyText(html`Hello, ${msg.chat.mention()`)
         * ```
         */
        mention(text2) {
          if (this.user)
            return this.user.mention(text2);
          if (text2 === void 0 && this.username) {
            return `@${this.username}`;
          }
          if (!text2)
            text2 = this.displayName;
          if (!this.username)
            return text2;
          return new MessageEntity(
            {
              _: "messageEntityTextUrl",
              offset: 0,
              length: text2.length,
              url: `https://t.me/${this.username}`
            },
            text2
          );
        }
      }
      exports("by", Chat);
      memoizeGetters(Chat, [
        "inputPeer",
        "chatType",
        "usernames",
        "photo",
        "permissions",
        "defaultPermissions",
        "user",
        "color"
      ]);
      class DraftMessage {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Text of the draft message
         */
        get text() {
          return this.raw.message;
        }
        /**
         * Information about replies/quotes in this message
         */
        get replyToMessage() {
          var _a3;
          if (((_a3 = this.raw.replyTo) == null ? void 0 : _a3._) !== "inputReplyToMessage")
            return null;
          return this.raw.replyTo;
        }
        /**
         * Date of the last time this draft was updated
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Whether no webpage preview will be generated
         */
        get disableWebPreview() {
          return this.raw.noWebpage;
        }
        /**
         * Message text entities (may be empty)
         */
        get entities() {
          var _a3;
          const entities = [];
          if ((_a3 = this.raw.entities) == null ? void 0 : _a3.length) {
            for(let   ent of this.raw.entities) {
              entities.push(new MessageEntity(ent, this.raw.message));
            }
          }
          return entities;
        }
      }
      exports("bV", DraftMessage);
      memoizeGetters(DraftMessage, ["entities"]);
      class BotKeyboardBuilder {
        constructor(maxRowWidth = 3) {
          __publicField(this, "_buttons", []);
          this.maxRowWidth = maxRowWidth;
        }
        /**
         * Add buttons, wrapping them once {@link maxRowWidth} is reached
         *
         * @param buttons  Buttons to add
         */
        push(...buttons) {
          if (!buttons.length)
            return this;
          let row = [];
          buttons.forEach((btn) => {
            if (typeof btn === "function")
              btn = btn();
            if (!btn)
              return;
            row.push(btn);
            if (row.length === this.maxRowWidth) {
              this._buttons.push(row);
              row = [];
            }
          });
          if (row.length) {
            this._buttons.push(row);
          }
          return this;
        }
        /**
         * Add a row of buttons. Will not be wrapped.
         *
         * @param row  Row or a function that will populate it
         */
        row(row) {
          if (typeof row === "function") {
            const fn = row;
            row = [];
            fn(row);
          }
          const normal = row.filter(Boolean);
          if (normal.length)
            this._buttons.push(normal);
          return this;
        }
        /**
         * Append a button to the last row, wrapping if needed.
         *
         * @param btn  Button to add
         * @param force  Whether to forcefully add the button (i.e. do not wrap)
         */
        append(btn, force = false) {
          if (typeof btn === "function")
            btn = btn();
          if (!btn)
            return this;
          if (this._buttons.length && (this.maxRowWidth === null || force || this._buttons[this._buttons.length - 1].length < this.maxRowWidth)) {
            this._buttons[this._buttons.length - 1].push(btn);
          } else {
            this._buttons.push([btn]);
          }
          return this;
        }
        /**
         * Return contents of this builder as an inline keyboard
         */
        asInline() {
          return {
            type: "inline",
            buttons: this._buttons
          };
        }
        /**
         * Return contents of this builder as a reply keyboard
         */
        asReply(params = {}) {
          const ret = params;
          ret.type = "reply";
          ret.buttons = this._buttons;
          return ret;
        }
      }
      exports("bm", BotKeyboardBuilder);
      function builder(maxRowWidth) {
        return new BotKeyboardBuilder(maxRowWidth);
      }
      function inline(buttons) {
        return {
          type: "inline",
          buttons
        };
      }
      function reply$1(buttons, params = {}) {
        const ret = params;
        ret.type = "reply";
        ret.buttons = buttons;
        return ret;
      }
      function hideReply(selective) {
        return {
          type: "reply_hide",
          selective
        };
      }
      function forceReply(params = {}) {
        const ret = params;
        ret.type = "force_reply";
        return ret;
      }
      function text$3(text2) {
        return {
          _: "keyboardButton",
          text: text2
        };
      }
      function requestContact(text2) {
        return {
          _: "keyboardButtonRequestPhone",
          text: text2
        };
      }
      function requestGeo(text2) {
        return {
          _: "keyboardButtonRequestGeoLocation",
          text: text2
        };
      }
      function requestPoll(text2, quiz2) {
        return {
          _: "keyboardButtonRequestPoll",
          text: text2,
          quiz: quiz2
        };
      }
      function url(text2, url2) {
        return {
          _: "keyboardButtonUrl",
          text: text2,
          url: url2
        };
      }
      function callback(text2, data2, requiresPassword) {
        return {
          _: "keyboardButtonCallback",
          text: text2,
          requiresPassword,
          data: typeof data2 === "string" ? getPlatform().utf8Encode(data2) : data2
        };
      }
      function switchInline(text2, query = "", currentChat) {
        return {
          _: "keyboardButtonSwitchInline",
          samePeer: currentChat,
          text: text2,
          query
        };
      }
      function game$3(text2) {
        return { _: "keyboardButtonGame", text: text2 };
      }
      function pay(text2) {
        return { _: "keyboardButtonBuy", text: text2 };
      }
      function urlAuth(text2, url2, params = {}) {
        var _a3;
        return {
          _: "inputKeyboardButtonUrlAuth",
          text: text2,
          url: url2,
          bot: (_a3 = params.bot) != null ? _a3 : {
            _: "inputUserSelf"
          },
          fwdText: params.fwdText,
          requestWriteAccess: params.requestWriteAccess
        };
      }
      function webView(text2, url2) {
        return {
          _: "keyboardButtonWebView",
          text: text2,
          url: url2
        };
      }
      function userProfile(text2, user) {
        return {
          _: "inputKeyboardButtonUserProfile",
          text: text2,
          userId: toInputUser(user)
        };
      }
      function requestPeer(text2, buttonId, params) {
        var _a3;
        return {
          _: "keyboardButtonRequestPeer",
          text: text2,
          buttonId,
          peerType: params.peerType,
          maxQuantity: (_a3 = params.count) != null ? _a3 : 1
        };
      }
      function copy(params) {
        var _a3;
        return {
          _: "keyboardButtonCopy",
          text: params.text,
          copyText: (_a3 = params == null ? void 0 : params.copyText) != null ? _a3 : params.text
        };
      }
      function findButton(buttons, predicate) {
        if (typeof predicate === "string") {
          const text2 = predicate;
          predicate = (btn) => {
            return "text" in btn && btn.text === text2;
          };
        }
        for(let   row of buttons) {
          for(let   btn of row) {
            if (predicate(btn)) {
              return btn;
            }
          }
        }
        return null;
      }
      function _rowsTo2d(rows) {
        return rows.map((it) => it.buttons);
      }
      function _2dToRows(arr, inline2) {
        return arr.map((row) => {
          if (!inline2) {
            row = row.map(
              (btn) => btn._ === "keyboardButtonWebView" ? __spreadProps(__spreadValues({}, btn), {
                _: "keyboardButtonSimpleWebView"
              }) : btn
            );
          }
          return {
            _: "keyboardButtonRow",
            buttons: row
          };
        });
      }
      function _convertToTl$2(obj) {
        if (!obj)
          return obj;
        if (tl.tl.isAnyReplyMarkup(obj))
          return obj;
        switch (obj.type) {
          case "reply":
            return {
              _: "replyKeyboardMarkup",
              resize: obj.resize,
              singleUse: obj.singleUse,
              selective: obj.selective,
              persistent: obj.persistent,
              placeholder: obj.placeholder,
              rows: _2dToRows(obj.buttons, false)
            };
          case "reply_hide":
            return {
              _: "replyKeyboardHide",
              selective: obj.selective
            };
          case "force_reply":
            return {
              _: "replyKeyboardForceReply",
              singleUse: obj.singleUse,
              selective: obj.selective,
              placeholder: obj.placeholder
            };
          case "inline":
            return {
              _: "replyInlineMarkup",
              rows: _2dToRows(obj.buttons, true)
            };
          default:
            assertNever$1();
        }
      }
      const factories$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        _2dToRows,
        _convertToTl: _convertToTl$2,
        _rowsTo2d,
        builder,
        callback,
        copy,
        findButton,
        forceReply,
        game: game$3,
        hideReply,
        inline,
        pay,
        reply: reply$1,
        requestContact,
        requestGeo,
        requestPeer,
        requestPoll,
        switchInline,
        text: text$3,
        url,
        urlAuth,
        userProfile,
        webView
      }, Symbol.toStringTag, { value: "Module" }));
      exports("bl", factories$3);
      function parsePeer(peer, index) {
        switch (peer._) {
          case "peerUser":
            return new User(index.user(peer.userId));
          case "peerChat":
            return new Chat(index.chat(peer.chatId));
          case "peerChannel":
            return new Chat(index.chat(peer.channelId));
        }
      }
      class FactCheck {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Text of the fact-check
         */
        get text() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.text) == null ? void 0 : _a3.text) != null ? _b2 : "";
        }
        /**
         * Entities contained in the fact-check text
         */
        get entities() {
          var _a3;
          const entities = [];
          if ((_a3 = this.raw.text) == null ? void 0 : _a3.entities) {
            for(let   ent of this.raw.text.entities) {
              entities.push(new MessageEntity(ent, this.raw.text.text));
            }
          }
          return entities;
        }
        /**
         * Country for which the fact-check is relevant
         */
        get country() {
          var _a3;
          return (_a3 = this.raw.country) != null ? _a3 : null;
        }
        /**
         * Whether this information might be outdated
         * and should be re-fetched manually
         */
        get shouldRecheck() {
          return this.raw.needCheck;
        }
        /**
         * Hash of the fact-check
         */
        get hash() {
          return this.raw.hash;
        }
      }
      exports("bX", FactCheck);
      memoizeGetters(FactCheck, ["entities"]);
      function _callDiscardReasonFromTl(raw) {
        switch (raw._) {
          case "phoneCallDiscardReasonMissed":
            return "missed";
          case "phoneCallDiscardReasonDisconnect":
            return "disconnect";
          case "phoneCallDiscardReasonHangup":
            return "hangup";
          case "phoneCallDiscardReasonBusy":
            return "busy";
          default:
            assertNever$1();
        }
      }
      function _callDiscardReasonToTl(r2) {
        switch (r2) {
          case "missed":
            return { _: "phoneCallDiscardReasonMissed" };
          case "disconnect":
            return { _: "phoneCallDiscardReasonDisconnect" };
          case "hangup":
            return { _: "phoneCallDiscardReasonHangup" };
          case "busy":
            return { _: "phoneCallDiscardReasonBusy" };
          default:
            assertNever$1();
        }
      }
      const _Thumbnail = class _Thumbnail extends FileLocation {
        constructor(media2, sz) {
          switch (sz._) {
            case "photoSizeEmpty":
            case "photoCachedSize":
              throw new MtTypeAssertionError("sz", "not (photoSizeEmpty | photoCachedSize)", sz._);
          }
          let location2;
          let size2;
          let width;
          let height;
          switch (sz._) {
            case "photoStrippedSize":
              location2 = strippedPhotoToJpg(sz.bytes);
              width = height = Number.NaN;
              size2 = location2.length;
              break;
            case "photoPathSize": {
              const imageSize = media2._ === "document" ? media2.attributes.find((it) => it._ === "documentAttributeImageSize") : void 0;
              location2 = () => svgPathToFile(this._path, imageSize);
              if (imageSize) {
                width = imageSize.w;
                height = imageSize.h;
              } else {
                width = height = 512;
              }
              size2 = Infinity;
              break;
            }
            case "videoSizeEmojiMarkup":
            case "videoSizeStickerMarkup":
              location2 = () => {
                throw new MtArgumentError("Cannot download thumbnail with emoji/sticker markup, try other size");
              };
              width = height = Number.NaN;
              size2 = Infinity;
              break;
            default:
              if (media2._ === "stickerSet") {
                location2 = {
                  _: "inputStickerSetThumb",
                  stickerset: {
                    _: "inputStickerSetID",
                    id: media2.id,
                    accessHash: media2.accessHash
                  },
                  thumbVersion: media2.thumbVersion
                };
              } else if (media2._ === "messageExtendedMediaPreview") {
                throw new MtTypeAssertionError("messageExtendedMediaPreview#thumb", "photoStrippedSize", sz._);
              } else {
                location2 = {
                  _: media2._ === "photo" ? "inputPhotoFileLocation" : "inputDocumentFileLocation",
                  id: media2.id,
                  fileReference: media2.fileReference,
                  accessHash: media2.accessHash,
                  thumbSize: sz.type
                };
              }
              width = sz.w;
              height = sz.h;
              size2 = sz._ === "photoSizeProgressive" ? Math.max(...sz.sizes) : sz.size;
              break;
          }
          let dcId;
          if (media2._ === "stickerSet") {
            dcId = media2.thumbDcId;
          } else if (media2._ === "messageExtendedMediaPreview") {
            dcId = 0;
          } else {
            dcId = media2.dcId;
          }
          super(location2, size2, dcId);
          __publicField(this, "raw");
          /**
           * Thumbnail width
           * (`NaN` for {@link THUMB_OUTLINE} and {@link THUMB_STRIP})
           */
          __publicField(this, "width");
          /**
           * Thumbnail height
           * (`NaN` for {@link THUMB_OUTLINE} and {@link THUMB_STRIP})
           */
          __publicField(this, "height");
          __publicField(this, "_path");
          __publicField(this, "_media");
          this.raw = sz;
          this.width = width;
          this.height = height;
          this._media = media2;
          if (sz._ === "photoPathSize") {
            this._path = inflateSvgPath(sz.bytes);
          }
        }
        get isVideo() {
          return this.raw._ === "videoSize";
        }
        /**
         * Thumbnail type
         */
        get type() {
          if (this.raw._ === "videoSizeEmojiMarkup") {
            return _Thumbnail.THUMB_EMOJI_MARKUP;
          }
          if (this.raw._ === "videoSizeStickerMarkup") {
            return _Thumbnail.THUMB_STICKER_MARKUP;
          }
          return this.raw.type;
        }
        /**
         * If {@link raw} is `tl.RawPhotoPathSize` (i.e. `raw.type === Thumbnail.THUMB_OUTLINE`),
         * this property will return raw SVG path of the preview.
         *
         * When downloading path thumbnails, a valid SVG file is returned.
         *
         * See also: https://core.telegram.org/api/files#vector-thumbnails
         *
         * @throws MtTypeAssertionError  In case {@link raw} is not `tl.RawPhotoPathSize`
         */
        get path() {
          assertTypeIs("Thumbnail#path", this.raw, "photoPathSize");
          return this._path;
        }
        /**
         * Get TDLib and Bot API compatible File ID
         * representing this thumbnail.
         *
         * > **Note:** You can't use this file id to send a thumbnail,
         * > only to download it.
         */
        get fileId() {
          if (this.raw._ !== "photoSize" && this.raw._ !== "photoSizeProgressive" && this.raw._ !== "videoSize" || this._media._ === "messageExtendedMediaPreview") {
            throw new MtArgumentError(`Cannot generate a file ID for "${this.type}"`);
          }
          if (this._media._ === "stickerSet") {
            return toFileId(getPlatform(), {
              type: typesInner.FileType.Thumbnail,
              dcId: this.dcId,
              fileReference: null,
              location: {
                _: "photo",
                id: Long.ZERO,
                accessHash: Long.ZERO,
                source: {
                  _: "stickerSetThumbnailVersion",
                  id: this._media.id,
                  accessHash: this._media.accessHash,
                  version: this._media.thumbVersion
                }
              }
            });
          }
          return toFileId(getPlatform(), {
            type: this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail,
            dcId: this.dcId,
            fileReference: this._media.fileReference,
            location: {
              _: "photo",
              id: this._media.id,
              accessHash: this._media.accessHash,
              source: {
                _: "thumbnail",
                fileType: this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail,
                thumbnailType: this.raw.type === "u" ? "\0" : this.raw.type
              }
            }
          });
        }
        /**
         * Get a unique File ID representing this thumbnail.
         */
        get uniqueFileId() {
          if (this.raw._ !== "photoSize" && this.raw._ !== "photoSizeProgressive" && this.raw._ !== "videoSize" || this._media._ === "messageExtendedMediaPreview") {
            throw new MtArgumentError(`Cannot generate a unique file ID for "${this.type}"`);
          }
          if (this._media._ === "stickerSet") {
            return toUniqueFileId(getPlatform(), typesInner.FileType.Thumbnail, {
              _: "photo",
              id: Long.ZERO,
              source: {
                _: "stickerSetThumbnailVersion",
                id: this._media.id,
                accessHash: this._media.accessHash,
                version: this._media.thumbVersion
              }
            });
          }
          return toUniqueFileId(getPlatform(), this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail, {
            _: "photo",
            id: this._media.id,
            source: {
              _: "thumbnail",
              fileType: this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail,
              thumbnailType: this.raw.type === "u" ? "\0" : this.raw.type
            }
          });
        }
      };
      // see: https://core.telegram.org/api/files#image-thumbnail-types
      __publicField(_Thumbnail, "THUMB_100x100_BOX", "s");
      __publicField(_Thumbnail, "THUMB_320x320_BOX", "m");
      __publicField(_Thumbnail, "THUMB_800x800_BOX", "x");
      __publicField(_Thumbnail, "THUMB_1280x1280_BOX", "y");
      __publicField(_Thumbnail, "THUMB_2560x2560_BOX", "w");
      __publicField(_Thumbnail, "THUMB_160x160_CROP", "a");
      __publicField(_Thumbnail, "THUMB_320x320_CROP", "b");
      __publicField(_Thumbnail, "THUMB_640x640_CROP", "c");
      __publicField(_Thumbnail, "THUMB_1280x1280_CROP", "d");
      __publicField(_Thumbnail, "THUMB_STRIP", "i");
      __publicField(_Thumbnail, "THUMB_OUTLINE", "j");
      /** Animated profile pictures preview */
      __publicField(_Thumbnail, "THUMB_VIDEO_PROFILE", "u");
      /** Trimmed and downscaled video previews */
      __publicField(_Thumbnail, "THUMB_VIDEO_PREVIEW", "v");
      /** Fullscreen animation for Premium stickers */
      __publicField(_Thumbnail, "THUMB_VIDEO_FULLSCREEN", "f");
      /** (non-standard) Emoji-based markup for profile photo */
      __publicField(_Thumbnail, "THUMB_EMOJI_MARKUP", "pfp_em");
      /** (non-standard) Sticker-based markup for profile photo */
      __publicField(_Thumbnail, "THUMB_STICKER_MARKUP", "pfp_st");
      let Thumbnail = _Thumbnail;
      exports("d9", Thumbnail);
      memoizeGetters(Thumbnail, ["fileId", "uniqueFileId"]);
      class Photo extends FileLocation {
        constructor(raw, media2) {
          const location2 = {
            _: "inputPhotoFileLocation",
            id: raw.id,
            fileReference: raw.fileReference,
            accessHash: raw.accessHash,
            thumbSize: ""
          };
          let size2;
          let width;
          let height;
          let bestSize;
          const progressive = raw.sizes.find((it) => it._ === "photoSizeProgressive");
          if (progressive) {
            location2.thumbSize = progressive.type;
            size2 = Math.max(...progressive.sizes);
            width = progressive.w;
            height = progressive.h;
            bestSize = progressive;
          } else {
            let max2 = null;
            for(let   sz of raw.sizes) {
              if (sz._ === "photoSize" && (!max2 || sz.size > max2.size)) {
                max2 = sz;
              }
            }
            if (max2) {
              location2.thumbSize = max2.type;
              size2 = max2.size;
              width = max2.w;
              height = max2.h;
              bestSize = max2;
            } else {
              throw new MtArgumentError("Photo does not have any sizes");
            }
          }
          super(location2, size2, raw.dcId);
          __publicField(this, "type", "photo");
          /** Biggest available photo width */
          __publicField(this, "width");
          /** Biggest available photo height */
          __publicField(this, "height");
          __publicField(this, "_bestSize");
          this.raw = raw;
          this.media = media2;
          this._bestSize = bestSize;
          this.width = width;
          this.height = height;
          this.type = "photo";
        }
        /**
         * Photo ID
         */
        get id() {
          return this.raw.id;
        }
        /** Date this photo was sent */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Whether this photo is an animated profile picture
         */
        get isAnimatedAvatar() {
          var _a3;
          return Boolean((_a3 = this.raw.videoSizes) == null ? void 0 : _a3.some((s) => s._ === "videoSize" && s.type === "u"));
        }
        /**
         * Whether this photo is an animated profile picture, built from an emoji/sticker markup
         */
        get isMarkupAvatar() {
          var _a3;
          return Boolean(
            (_a3 = this.raw.videoSizes) == null ? void 0 : _a3.some((s) => s._ === "videoSizeEmojiMarkup" || s._ === "videoSizeStickerMarkup")
          );
        }
        /** Whether this photo is hidden with a spoiler */
        get hasSpoiler() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.media) == null ? void 0 : _a3.spoiler) != null ? _b2 : false;
        }
        /** For self-destructing photos, TTL in seconds */
        get ttlSeconds() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.media) == null ? void 0 : _a3.ttlSeconds) != null ? _b2 : null;
        }
        /**
         * Available thumbnails.
         *
         * **Note**: This list will also contain the largest thumbnail that is
         * represented by the current object.
         */
        get thumbnails() {
          var _a3;
          const res = this.raw.sizes.map((sz) => new Thumbnail(this.raw, sz));
          (_a3 = this.raw.videoSizes) == null ? void 0 : _a3.forEach((sz) => res.push(new Thumbnail(this.raw, sz)));
          return res;
        }
        /**
         * Get a photo thumbnail by its type.
         *
         * Thumbnail types are described in the
         * [Telegram docs](https://core.telegram.org/api/files#image-thumbnail-types),
         * and are also available as static members of {@link Thumbnail} for convenience.
         *
         * @param type  Thumbnail type
         */
        getThumbnail(type) {
          var _a3;
          return (_a3 = this.thumbnails.find((it) => it.type === type)) != null ? _a3 : null;
        }
        /**
         * Get TDLib and Bot API compatible File ID
         * representing this photo's best thumbnail.
         */
        get fileId() {
          if (!this._bestSize) {
            throw new MtArgumentError("Cannot get File ID for this photo");
          }
          return this.getThumbnail(this._bestSize.type).fileId;
        }
        /**
         * Get TDLib and Bot API compatible Unique File ID
         * representing this photo's best thumbnail.
         */
        get uniqueFileId() {
          if (!this._bestSize) {
            throw new MtArgumentError("Cannot get File ID for this photo");
          }
          return this.getThumbnail(this._bestSize.type).uniqueFileId;
        }
        /**
         * Input photo generated from this object.
         */
        get inputPhoto() {
          return {
            _: "inputPhoto",
            id: this.raw.id,
            accessHash: this.raw.accessHash,
            fileReference: this.raw.fileReference
          };
        }
        /**
         * Input media generated from this object,
         * to be used in {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         */
        get inputMedia() {
          return {
            _: "inputMediaPhoto",
            id: this.inputPhoto
          };
        }
      }
      exports("cA", Photo);
      memoizeGetters(Photo, ["thumbnails", "fileId", "uniqueFileId"]);
      class RawDocument extends FileLocation {
        constructor(raw) {
          super(
            {
              _: "inputDocumentFileLocation",
              id: raw.id,
              fileReference: raw.fileReference,
              accessHash: raw.accessHash,
              thumbSize: ""
            },
            raw.size,
            raw.dcId
          );
          this.raw = raw;
          this.raw = raw;
        }
        /**
         * Original file name, extracted from the document
         * attributes.
         */
        get fileName() {
          var _a3;
          const attr = this.raw.attributes.find((it) => it._ === "documentAttributeFilename");
          return (_a3 = attr == null ? void 0 : attr.fileName) != null ? _a3 : null;
        }
        /**
         * File MIME type, as defined by the sender.
         */
        get mimeType() {
          return this.raw.mimeType;
        }
        /**
         * Date the document was sent
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Available thumbnails, if any.
         *
         * If there are no thumbnails, the array will be empty.
         */
        get thumbnails() {
          var _a3, _b2;
          const arr = [];
          (_a3 = this.raw.thumbs) == null ? void 0 : _a3.forEach((sz) => arr.push(new Thumbnail(this.raw, sz)));
          (_b2 = this.raw.videoThumbs) == null ? void 0 : _b2.forEach((sz) => arr.push(new Thumbnail(this.raw, sz)));
          return arr;
        }
        /**
         * Get a thumbnail by its type.
         *
         * Thumbnail types are described in the
         * [Telegram docs](https://core.telegram.org/api/files#image-thumbnail-types),
         * and are also available as static members of {@link Thumbnail} for convenience.
         *
         * @param type  Thumbnail type
         */
        getThumbnail(type) {
          var _a3;
          return (_a3 = this.thumbnails.find((it) => {
            if (it.raw._ === "videoSizeEmojiMarkup" || it.raw._ === "videoSizeStickerMarkup") {
              return false;
            }
            return it.raw.type === type;
          })) != null ? _a3 : null;
        }
        /**
         * Input document TL object generated from this object,
         * to be used with methods that use it
         */
        get inputDocument() {
          return {
            _: "inputDocument",
            id: this.raw.id,
            accessHash: this.raw.accessHash,
            fileReference: this.raw.fileReference
          };
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         */
        get inputMedia() {
          return {
            _: "inputMediaDocument",
            id: this.inputDocument
          };
        }
        _fileIdType() {
          return typesInner.FileType.Document;
        }
        /**
         * Get TDLib and Bot API compatible File ID
         * representing this document.
         */
        get fileId() {
          return toFileId(getPlatform(), {
            type: this._fileIdType(),
            dcId: this.raw.dcId,
            fileReference: this.raw.fileReference,
            location: {
              _: "common",
              id: this.raw.id,
              accessHash: this.raw.accessHash
            }
          });
        }
        /**
         * Get a unique File ID representing this document.
         */
        get uniqueFileId() {
          return toUniqueFileId(getPlatform(), typesInner.FileType.Document, {
            _: "common",
            id: this.raw.id
          });
        }
      }
      exports("cG", RawDocument);
      class Document extends RawDocument {
        constructor() {
          super(...arguments);
          __publicField(this, "type", "document");
        }
      }
      exports("bU", Document);
      memoizeGetters(Document, ["fileName", "thumbnails", "fileId", "uniqueFileId"]);
      class Audio extends RawDocument {
        constructor(doc, attr) {
          super(doc);
          /** Type of the media (for use in a tagged union) */
          __publicField(this, "type", "audio");
          this.attr = attr;
        }
        /** Type of the file for File ID generation */
        _fileIdType() {
          return typesInner.FileType.Audio;
        }
        /**
         * Duration of the audio in seconds.
         *
         * May not be accurate since provided by the sender.
         */
        get duration() {
          return this.attr.duration;
        }
        /**
         * Performer of the audio track.
         */
        get performer() {
          var _a3;
          return (_a3 = this.attr.performer) != null ? _a3 : null;
        }
        /**
         * Title of the audio track.
         */
        get title() {
          var _a3;
          return (_a3 = this.attr.title) != null ? _a3 : null;
        }
      }
      exports("bc", Audio);
      memoizeGetters(Audio, ["fileName", "thumbnails", "fileId", "uniqueFileId"]);
      const MASK_POSITION_POINT_TO_TL = exports("cb", {
        forehead: 0,
        eyes: 1,
        mouth: 2,
        chin: 3
      });
      const MASK_POS = ["forehead", "eyes", "mouth", "chin"];
      class Sticker extends RawDocument {
        constructor(doc, attr, attr2) {
          super(doc);
          __publicField(this, "type", "sticker");
          this.attr = attr;
          this.attr2 = attr2;
        }
        _fileIdType() {
          return typesInner.FileType.Sticker;
        }
        /**
         * Sticker width in pixels
         */
        get width() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.attr2) == null ? void 0 : _a3.w) != null ? _b2 : 512;
        }
        /**
         * Sticker height in pixels
         */
        get height() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.attr2) == null ? void 0 : _a3.h) != null ? _b2 : 512;
        }
        /**
         * Whether this sticker is a premium sticker
         * (has premium fullscreen animation)
         */
        get isPremiumSticker() {
          var _a3;
          return Boolean((_a3 = this.raw.videoThumbs) == null ? void 0 : _a3.some((s) => s._ === "videoSize" && s.type === "f"));
        }
        /**
         * Whether this sticker is a valid sticker.
         *
         * If it is not, then this is probably a WEBP photo
         * that Telegram treats as a sticker.
         */
        get isValidSticker() {
          return this.attr2 !== void 0 && (this.attr2.w === 512 || this.attr2.h === 512);
        }
        /**
         * Primary emoji associated with this sticker,
         * that is displayed in dialogs list.
         *
         * If there is none, empty string is returned.
         *
         * **Note:** This only contains at most one emoji.
         * Some stickers have multiple associated emojis,
         * but only one is returned here. This is Telegram's
         * limitation! Use {@link getAllEmojis} instead.
         *
         * For custom emojis, this alt should be used as a fallback
         * text that will be "behind" the custom emoji entity.
         */
        get emoji() {
          return this.attr.alt;
        }
        /**
         * Whether this custom emoji can be used by non-premium users.
         * `false` if this is not a custom emoji.
         *
         * > Not sure if there are any such stickers currently.
         */
        get customEmojiFree() {
          var _a3;
          return this.attr._ === "documentAttributeCustomEmoji" ? (_a3 = this.attr.free) != null ? _a3 : false : false;
        }
        /**
         * If this is a custom emoji, its unique ID
         * that can be used in {@link TelegramClient#getCustomEmojis}
         */
        get customEmojiId() {
          if (this.attr._ !== "documentAttributeCustomEmoji") {
            throw new MtArgumentError("This is not a custom emoji");
          }
          return this.raw.id;
        }
        /**
         * Type of the sticker
         */
        get stickerType() {
          if (this.attr._ === "documentAttributeSticker") {
            return this.attr.mask ? "mask" : "sticker";
          } else if (this.attr._ === "documentAttributeCustomEmoji") {
            return "emoji";
          }
          return "sticker";
        }
        /**
         * Type of the file representing the sticker
         */
        get sourceType() {
          var _a3;
          if (((_a3 = this.attr2) == null ? void 0 : _a3._) === "documentAttributeVideo") {
            return "video";
          }
          return this.mimeType === "application/x-tgsticker" ? "animated" : "static";
        }
        /**
         * Whether this sticker has an associated public sticker set.
         */
        get hasStickerSet() {
          return this.attr.stickerset._ === "inputStickerSetID";
        }
        /**
         * Input sticker set that it associated with this sticker, if available.
         */
        get inputStickerSet() {
          return this.attr.stickerset._ === "inputStickerSetEmpty" ? null : this.attr.stickerset;
        }
        /**
         * Position where this mask should be placed
         */
        get maskPosition() {
          if (this.attr._ !== "documentAttributeSticker" || !this.attr.maskCoords) {
            return null;
          }
          const raw = this.attr.maskCoords;
          return {
            point: MASK_POS[raw.n],
            x: raw.x,
            y: raw.y,
            scale: raw.zoom
          };
        }
      }
      exports("cP", Sticker);
      memoizeGetters(Sticker, ["fileName", "thumbnails", "fileId", "uniqueFileId", "maskPosition"]);
      class Video extends RawDocument {
        constructor(doc, attr, media2) {
          super(doc);
          __publicField(this, "type", "video");
          this.attr = attr;
          this.media = media2;
        }
        _fileIdType() {
          if (this.isRound)
            return typesInner.FileType.VideoNote;
          if (this.isAnimation)
            return typesInner.FileType.Animation;
          return typesInner.FileType.Video;
        }
        /**
         * Video width in pixels
         */
        get width() {
          return this.attr.w;
        }
        /**
         * Video height in pixels
         */
        get height() {
          return this.attr.h;
        }
        /**
         * Video duration in seconds.
         *
         * `0` for legacy GIFs
         */
        get duration() {
          return this.attr._ === "documentAttributeVideo" ? this.attr.duration : 0;
        }
        /**
         * Whether this video is an animated GIF
         * (represented either by actual GIF or a silent MP4 video)
         */
        get isAnimation() {
          return this.attr._ === "documentAttributeImageSize" || this.raw.attributes.some((it) => it._ === "documentAttributeAnimated");
        }
        /**
         * Whether this video is a round video message (aka video note)
         */
        get isRound() {
          return this.attr._ === "documentAttributeVideo" && Boolean(this.attr.roundMessage);
        }
        /**
         * Whether this video is a legacy GIF (i.e. its MIME is `image/gif`)
         */
        get isLegacyGif() {
          return this.attr._ === "documentAttributeImageSize";
        }
        /** Whether this video is hidden with a spoiler */
        get hasSpoiler() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.media) == null ? void 0 : _a3.spoiler) != null ? _b2 : false;
        }
        /** For self-destructing videos, TTL in seconds */
        get ttlSeconds() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.media) == null ? void 0 : _a3.ttlSeconds) != null ? _b2 : null;
        }
        get videoStartTs() {
          var _a3;
          return this.attr._ === "documentAttributeVideo" ? (_a3 = this.attr.videoStartTs) != null ? _a3 : null : null;
        }
        get codec() {
          var _a3;
          return this.attr._ === "documentAttributeVideo" ? (_a3 = this.attr.videoCodec) != null ? _a3 : null : null;
        }
      }
      exports("di", Video);
      memoizeGetters(Video, ["fileName", "thumbnails", "fileId", "uniqueFileId", "isAnimation"]);
      class Voice extends RawDocument {
        constructor(doc, attr) {
          super(doc);
          __publicField(this, "type", "voice");
          this.attr = attr;
        }
        _fileIdType() {
          return typesInner.FileType.VoiceNote;
        }
        /**
         * Duration of the voice note in seconds.
         */
        get duration() {
          return this.attr.duration;
        }
        /**
         * Voice note's waveform
         *
         * Represented with integers in range [0, 31],
         * usually has length of 100
         */
        get waveform() {
          return decodeWaveform(this.attr.waveform);
        }
      }
      exports("dj", Voice);
      memoizeGetters(Voice, ["fileName", "thumbnails", "fileId", "uniqueFileId", "waveform"]);
      function parseSticker(doc) {
        const stickerAttr = doc.attributes.find(
          (a) => a._ === "documentAttributeSticker" || a._ === "documentAttributeCustomEmoji"
        );
        if (stickerAttr) {
          const sz = doc.attributes.find(
            (it) => it._ === "documentAttributeImageSize" || it._ === "documentAttributeVideo"
          );
          return new Sticker(doc, stickerAttr, sz);
        }
      }
      function parseDocument(doc, media2) {
        const sticker2 = parseSticker(doc);
        if (sticker2)
          return sticker2;
        for(let   attr of doc.attributes) {
          switch (attr._) {
            case "documentAttributeAudio":
              if (attr.voice) {
                return new Voice(doc, attr);
              }
              return new Audio(doc, attr);
            case "documentAttributeVideo":
              return new Video(doc, attr, media2);
            case "documentAttributeImageSize":
              if (doc.mimeType === "image/gif") {
                return new Video(doc, attr, media2);
              }
          }
        }
        return new Document(doc);
      }
      class StarGift {
        constructor(raw) {
          this.raw = raw;
        }
        /** ID of the gift */
        get id() {
          return this.raw.id;
        }
        /** Sticker associated with the gift */
        get sticker() {
          assertTypeIs("StarGift#sticker", this.raw.sticker, "document");
          const parsed = parseDocument(this.raw.sticker);
          if (parsed.type !== "sticker") {
            throw new MtTypeAssertionError("StarGift#sticker", "sticker", parsed.type);
          }
          return parsed;
        }
        /** Amount of stars the gift was purchased for */
        get purchaseStars() {
          return this.raw.stars;
        }
        /**
         * Amount of stars the gift can be converted to by the recipient
         */
        get convertStars() {
          return this.raw.convertStars;
        }
        /**
         * For limited availability gifts,
         * the number of remaining and total gifts available
         */
        get availability() {
          if (!this.raw.availabilityRemains || !this.raw.availabilityTotal) {
            return null;
          }
          return {
            remains: this.raw.availabilityRemains,
            total: this.raw.availabilityTotal
          };
        }
      }
      exports("cM", StarGift);
      memoizeGetters(StarGift, ["sticker"]);
      class UserStarGift {
        constructor(raw, peers) {
          this.raw = raw;
          this.peers = peers;
        }
        /** Whether the sender chose to appear anonymously */
        get nameHidden() {
          return this.raw.nameHidden;
        }
        /** Whether this gift is not visible on the recipient's profile */
        get hidden() {
          return this.raw.unsaved;
        }
        /** Sender of the gift, if available */
        get sender() {
          return this.raw.fromId ? new User(this.peers.user(this.raw.fromId)) : null;
        }
        /** Message ID where the gift was sent, if available */
        get messageId() {
          var _a3;
          return (_a3 = this.raw.msgId) != null ? _a3 : null;
        }
        /** Date the gift was sent */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /** The gift itself */
        get gift() {
          return new StarGift(this.raw.gift);
        }
        /** Text attached to the gift */
        get text() {
          var _a3;
          return (_a3 = this.raw.message) != null ? _a3 : null;
        }
        /**
         * If the gift was converted to stars, the amount of stars
         * it was converted to
         */
        get convertStars() {
          var _a3;
          return (_a3 = this.raw.convertStars) != null ? _a3 : null;
        }
      }
      exports("de", UserStarGift);
      memoizeGetters(UserStarGift, ["sender", "gift"]);
      function _messageActionFromTl(act) {
        var _a3, _b2, _c, _d, _e;
        switch (act._) {
          case "messageActionChatCreate":
            return {
              type: "chat_created",
              title: act.title,
              users: act.users
            };
          case "messageActionChannelCreate":
            return {
              type: "channel_created",
              title: act.title
            };
          case "messageActionChatMigrateTo":
            return {
              type: "chat_migrate_to",
              id: act.channelId
            };
          case "messageActionChannelMigrateFrom":
            return {
              type: "channel_migrate_from",
              id: act.chatId,
              title: act.title
            };
          case "messageActionPinMessage":
            return {
              type: "message_pinned"
            };
          case "messageActionHistoryClear":
            return {
              type: "history_cleared"
            };
          case "messageActionGameScore":
            return {
              type: "game_score",
              gameId: act.gameId,
              score: act.score
            };
          case "messageActionContactSignUp":
            return {
              type: "contact_joined"
            };
          case "messageActionChatEditTitle":
            return {
              type: "title_changed",
              title: act.title
            };
          case "messageActionChatEditPhoto":
            return {
              type: "photo_changed",
              photo: new Photo(act.photo)
            };
          case "messageActionChatDeletePhoto":
            return {
              type: "photo_deleted"
            };
          case "messageActionChatAddUser":
            return {
              type: "users_added",
              users: act.users
            };
          case "messageActionChatDeleteUser":
            if (((_a3 = this.raw.fromId) == null ? void 0 : _a3._) === "peerUser" && act.userId === this.raw.fromId.userId) {
              return {
                type: "user_left"
              };
            }
            return {
              type: "user_removed",
              user: act.userId
            };
          case "messageActionChatJoinedByLink":
            return {
              type: "user_joined_link",
              inviter: act.inviterId
            };
          case "messageActionPaymentSentMe":
            return {
              type: "payment_received",
              currency: act.currency,
              amount: act.totalAmount,
              payload: act.payload,
              info: act.info,
              shippingOptionId: act.shippingOptionId,
              charge: act.charge
            };
          case "messageActionPaymentSent":
            return {
              type: "payment_sent",
              currency: act.currency,
              amount: act.totalAmount
            };
          case "messageActionPhoneCall":
            return {
              type: "call",
              id: act.callId,
              isVideo: Boolean(act.video),
              reason: act.reason ? _callDiscardReasonFromTl(act.reason) : void 0,
              duration: (_b2 = act.duration) != null ? _b2 : 0
            };
          case "messageActionScreenshotTaken":
            return {
              type: "screenshot_taken"
            };
          case "messageActionBotAllowed":
            return {
              type: "bot_allowed",
              domain: act.domain
            };
          case "messageActionGeoProximityReached":
            if (act.fromId._ !== "peerUser" || act.toId._ !== "peerUser") {
              return null;
            }
            return {
              type: "geo_proximity",
              targetId: act.toId.userId,
              userId: act.fromId.userId,
              distance: act.distance
            };
          case "messageActionGroupCall":
            if (act.duration) {
              return {
                type: "group_call_ended",
                call: act.call,
                duration: act.duration
              };
            }
            return {
              type: "group_call_started",
              call: act.call
            };
          case "messageActionGroupCallScheduled":
            return {
              type: "group_call_scheduled",
              call: act.call,
              date: new Date(act.scheduleDate * 1e3)
            };
          case "messageActionInviteToGroupCall":
            return {
              type: "group_call_invite",
              call: act.call,
              userIds: act.users
            };
          case "messageActionSetMessagesTTL":
            return {
              type: "ttl_changed",
              period: act.period
            };
          case "messageActionTopicCreate":
            return {
              type: "topic_created",
              title: act.title,
              iconColor: act.iconColor,
              iconCustomEmoji: act.iconEmojiId
            };
          case "messageActionTopicEdit":
            return {
              type: "topic_edited",
              title: act.title,
              iconCustomEmoji: act.iconEmojiId,
              closed: act.closed,
              hidden: act.hidden
            };
          case "messageActionCustomAction":
            return {
              type: "custom",
              action: act.message
            };
          case "messageActionSetChatTheme":
            return {
              type: "theme_changed",
              emoji: act.emoticon
            };
          case "messageActionChatJoinedByRequest":
            return {
              type: "user_joined_approved"
            };
          case "messageActionWebViewDataSent":
            return {
              type: "webview_sent",
              text: act.text
            };
          case "messageActionWebViewDataSentMe":
            return {
              type: "webview_received",
              text: act.text,
              data: act.data
            };
          case "messageActionGiftPremium":
            return {
              type: "premium_gifted",
              currency: act.currency,
              amount: act.amount.toNumber(),
              months: act.months,
              crypto: act.cryptoAmount ? {
                currency: act.cryptoCurrency,
                amount: act.cryptoAmount.toNumber()
              } : void 0
            };
          case "messageActionSuggestProfilePhoto":
            return {
              type: "photo_suggested",
              photo: new Photo(act.photo)
            };
          case "messageActionRequestedPeerSentMe":
            return {
              type: "peer_sent",
              buttonId: act.buttonId,
              peers: act.peers
            };
          case "messageActionRequestedPeer":
            return {
              type: "peer_chosen",
              buttonId: act.buttonId,
              peers: act.peers.map((it) => parsePeer(it, this._peers))
            };
          case "messageActionSetChatWallPaper":
            return {
              type: "wallpaper_changed",
              same: act.same,
              forBoth: act.forBoth,
              wallpaper: act.wallpaper
            };
          case "messageActionGiftCode":
            return {
              type: "gift_code",
              raw: act
            };
          case "messageActionGiveawayLaunch":
            return {
              type: "giveaway_started"
            };
          case "messageActionGiveawayResults":
            return {
              type: "giveaway_ended",
              winners: act.winnersCount,
              undistributed: act.unclaimedCount
            };
          case "messageActionBoostApply":
            return {
              type: "boost_apply",
              count: act.boosts
            };
          case "messageActionPaymentRefunded":
            return {
              type: "payment_refunded",
              currency: act.currency,
              peerId: getMarkedPeerId(act.peer),
              amount: act.totalAmount,
              payload: act.payload,
              charge: act.charge
            };
          case "messageActionGiftStars":
            return {
              type: "stars_gifted",
              isCrypto: Boolean(act.cryptoCurrency),
              currency: (_c = act.cryptoCurrency) != null ? _c : act.currency,
              amount: (_d = act.cryptoAmount) != null ? _d : act.amount,
              stars: act.stars,
              transactionId: act.transactionId
            };
          case "messageActionPrizeStars":
            return {
              type: "stars_prize",
              claimed: !act.unclaimed,
              stars: act.stars,
              transactionId: act.transactionId,
              boostPeer: parsePeer(act.boostPeer, this._peers),
              giveawayMessageId: act.giveawayMsgId
            };
          case "messageActionStarGift":
            return {
              type: "stars_gift",
              nameHidden: act.nameHidden,
              saved: act.saved,
              converted: act.converted,
              convertStars: act.convertStars,
              gift: new StarGift(act.gift),
              message: (_e = act.message) != null ? _e : null
            };
          default:
            return null;
        }
      }
      class MessageForwardInfo {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Date the original message was sent
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Sender of the original message (either user or a channel)
         * or their name (for users with private forwards)
         */
        get sender() {
          if (this.raw.fromName) {
            return {
              type: "anonymous",
              displayName: this.raw.fromName
            };
          }
          if (this.raw.fromId) {
            return parsePeer(this.raw.fromId, this._peers);
          }
          throw new MtTypeAssertionError("MessageForwardInfo", "to have fromId or fromName", "neither");
        }
        /**
         * For "saved" messages (i.e. messages forwarded to yourself,
         * "Saved Messages"), the peer where the message was originally sent
         */
        fromChat() {
          if (!this.raw.savedFromPeer)
            return null;
          return Chat._parseFromPeer(this.raw.savedFromPeer, this._peers);
        }
        /**
         * For messages forwarded from channels,
         * identifier of the original message in the channel
         */
        get fromMessageId() {
          var _a3;
          return (_a3 = this.raw.savedFromMsgId) != null ? _a3 : null;
        }
        /**
         * For messages forwarded from channels,
         * signature of the post author (if present)
         */
        get signature() {
          var _a3;
          return (_a3 = this.raw.postAuthor) != null ? _a3 : null;
        }
      }
      exports("cg", MessageForwardInfo);
      memoizeGetters(MessageForwardInfo, ["sender", "fromChat"]);
      class Contact {
        constructor(obj) {
          __publicField(this, "type", "contact");
          this.obj = obj;
        }
        /**
         * Contact's phone number
         */
        get phoneNumber() {
          return this.obj.phoneNumber;
        }
        /**
         * Contact's first name
         */
        get firstName() {
          return this.obj.firstName;
        }
        /**
         * Contact's last name
         */
        get lastName() {
          return this.obj.lastName;
        }
        /**
         * Contact's user ID in Telegram or `0` if not available
         */
        get userId() {
          return this.obj.userId;
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         */
        get inputMedia() {
          return __spreadProps(__spreadValues({}, this.obj), {
            _: "inputMediaContact"
          });
        }
      }
      exports("bN", Contact);
      class Dice {
        constructor(obj) {
          __publicField(this, "type", "dice");
          this.obj = obj;
        }
        /**
         * An emoji which was originally sent.
         *
         * See static members of {@link Dice} for a list
         * of possible values
         */
        get emoji() {
          return this.obj.emoticon;
        }
        /**
         * Emoji's interactive value.
         *
         * See what this value represents in the corresponding
         * type's documentation (in {@link Dice} static fields)
         */
        get value() {
          return this.obj.value;
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         *
         * Note that when you use this media, a new `value`
         * will be generated!
         */
        get inputMedia() {
          return {
            _: "inputMediaDice",
            emoticon: this.obj.emoticon
          };
        }
      }
      /**
       * A simple 6-sided dice.
       *
       * {@link value} represents its value (1-6)
       */
      __publicField(Dice, "TYPE_DICE", "🎲");
      /**
       * A dart. Telegram dart has 4 rings and middle.
       *
       * {@link value} represents the position of the dart:
       * ![Dart position graph](https://i.imgur.com/iPBm7HG.png)
       */
      __publicField(Dice, "TYPE_DART", "🎯");
      /**
       * A basketball thrown into a hoop.
       *
       * {@link value} represents the motion of the ball:
       *  - 1: simple miss (ball hits right part, bounces to the left)
       *  - 2: first hit the ring, then miss
       *  - 3: ball gets stuck between the ring and the base
       *  - 4: first hit the ring, then score
       *  - 5: direct score
       */
      __publicField(Dice, "TYPE_BASKETBALL", "🏀");
      /**
       * A football thrown to the gate.
       *
       * {@link value} represents the motion of the ball:
       *  - 1: flies above the top barbell
       *  - 2: hits right barbell, then miss
       *  - 3: direct score in the middle
       *  - 4: hits left barbell, then score, then hits right barbell
       *  - 5: score in the top-right corner
       */
      __publicField(Dice, "TYPE_FOOTBALL", "⚽️");
      /**
       * A bowling ball thrown to pins.
       *
       * Assuming the following identifiers for the pins:
       * ```
       * 4 5 6
       *  2 3
       *   1
       * ```
       *
       * {@link value} represents the motion of the ball and pins:
       *  - 1: the ball touched 6th pin, none are down
       *  - 2: the ball hit 4th pin, only 4th pin is down.
       *  - 3: the ball hit 1st pin, pins 1, 2, 5 are down, leaving pins 3, 4, 6
       *  - 4: the ball hit 1st pin on the right side, all the pins except 2nd and 6th are down
       *  - 5: the ball hit 3rd pin and all the pins except 2nd are down.
       *  - 6: the ball hit 1st pin and all pins are down
       */
      __publicField(Dice, "TYPE_BOWLING", "🎳");
      /**
       * A slot machine.
       *
       * {@link value} represents the result of the machine.
       * Value itself is an integer in range `[1, 64]`,
       * and is composed out of several parts.
       *
       * > **Note**: The following information is based on the TDesktop
       * > implementation. These are the relevant files:
       * >  - [`chat_helpers/stickers_dice_pack.cpp`](https://github.com/telegramdesktop/tdesktop/blob/dev/Telegram/SourceFiles/chat_helpers/stickers_dice_pack.cpp)
       * >  - [`history/view/media/history_view_slot_machine.cpp`](https://github.com/telegramdesktop/tdesktop/blob/dev/Telegram/SourceFiles/history/view/media/history_view_slot_machine.cpp)
       *
       * Unlike other animated dices, this does not have
       * all the possible combinations in the sticker set.
       * Instead, `value` is a specially encoded integer that contains
       * the information about the indexes.
       *
       * There are some base parts of the animations:
       *  - 0th sticker is the base background of the machine
       *  - 1st sticker is the background of the machine for the "winning" state (i.e. `777`)
       *  - 2nd sticker is the frame of the machine, including the handle
       *  - 8th sticker is the "idle" state for the left slot
       *  - 14th sticker is the "idle" state for the middle slot
       *  - 20th sticker is the "idle" state for the right slot
       *
       * The machine result is encoded as 3 concatenated two-bit integers,
       * and the resulting integer is incremented by one.
       *
       * So, to decode the value to its parts, you can use this code:
       * ```typescript
       * const computePartValue = (val: number, idx: number) => ((val - 1) >> (idx * 2)) & 0x03; // 0..3
       * const parts = [
       *   computePartValue(msg.media.value, 0),
       *   computePartValue(msg.media.value, 1),
       *   computePartValue(msg.media.value, 2),
       * ]
       * ```
       *
       * Each part of the value corresponds to a particular slot (i.e. part 0 is left slot,
       * part 1 is middle, part 2 is right). The slot values are as follows:
       *  - 0: BAR (displayed as a *BAR* sign on a black background)
       *  - 1: BERRIES (displayed as berries, similar to emoji 🍇)
       *  - 2: LEMON (displayed as a lemon, similar to emoji 🍋)
       *  - 3: SEVEN (displayed as a red digit 7)
       *
       * Therefore, the winning value (i.e. `777`) is represented as `(3 << 4 | 3 << 2 | 3 << 0) + 1 = 64`
       *
       * To determine the needed animation parts, you'll need to apply some shifts.
       * These are the offsets for the individual symbols:
       *  - WIN_SEVEN: 0
       *  - SEVEN: 1
       *  - BAR: 2
       *  - BERRIES: 3
       *  - LEMON: 4
       *
       * And these are the shifts for each slot:
       *  - LEFT: 3
       *  - MIDDLE: 9
       *  - RIGHT: 15
       *
       * > WIN_SEVEN is the same as SEVEN, but only used if the machine result is `777` (i.e. `value = 64`),
       * > as it contains additional "blinking" animation.
       *
       * The sticker index is computed as follows: `SHIFTS[SLOT] + OFFSETS[SYM]`.
       * For example, berries for the middle slot would be: `SHIFTS[MIDDLE] + OFFSETS[BERRIES] = 9 + 3 = 12`
       *
       * Currently, this sticker set is used for the machine: [SlotMachineAnimated](https://t.me/addstickers/SlotMachineAnimated)
       */
      __publicField(Dice, "TYPE_SLOTS", "🎰");
      exports("bT", Dice);
      class Game {
        constructor(game2) {
          __publicField(this, "type", "game");
          this.game = game2;
        }
        /**
         * Unique identifier of the game.
         */
        get id() {
          return this.game.id;
        }
        /**
         * Title of the game
         */
        get title() {
          return this.game.title;
        }
        /**
         * Description of the game
         */
        get description() {
          return this.game.description;
        }
        /**
         * Unique short name of the game
         */
        get shortName() {
          return this.game.shortName;
        }
        /**
         * Photo that will be displayed in the game message in chats
         */
        get photo() {
          if (this.game.photo._ === "photoEmpty")
            return null;
          return new Photo(this.game.photo);
        }
        /**
         * Animation that will be displayed in the game message in chats
         */
        get animation() {
          var _a3;
          if (((_a3 = this.game.document) == null ? void 0 : _a3._) !== "document")
            return null;
          const attr = this.game.document.attributes.find((it) => it._ === "documentAttributeVideo");
          if (!attr) {
            return null;
          }
          return new Video(this.game.document, attr);
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         */
        get inputMedia() {
          return {
            _: "inputMediaGame",
            id: {
              _: "inputGameID",
              id: this.game.id,
              accessHash: this.game.accessHash
            }
          };
        }
      }
      exports("b$", Game);
      memoizeGetters(Game, ["photo", "animation"]);
      class ExtendedMediaPreview {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Width of the preview, in pixels (if available, else 0)
         */
        get width() {
          var _a3;
          return (_a3 = this.raw.w) != null ? _a3 : 0;
        }
        /**
         * Height of the preview, in pixels (if available, else 0)
         */
        get height() {
          var _a3;
          return (_a3 = this.raw.h) != null ? _a3 : 0;
        }
        get thumbnail() {
          if (!this.raw.thumb) {
            return null;
          }
          return new Thumbnail(this.raw, this.raw.thumb);
        }
        /**
         * If this is a video, the duration of the video,
         * in seconds (if available, else 0)
         */
        get videoDuration() {
          var _a3;
          return (_a3 = this.raw.videoDuration) != null ? _a3 : 0;
        }
      }
      exports("bW", ExtendedMediaPreview);
      memoizeGetters(ExtendedMediaPreview, ["thumbnail"]);
      class Invoice {
        constructor(raw, _extendedMedia) {
          __publicField(this, "type", "invoice");
          this.raw = raw;
          this._extendedMedia = _extendedMedia;
        }
        /**
         * Whether the shipping address was requested
         */
        isShippingAddressRequested() {
          return this.raw.shippingAddressRequested;
        }
        /**
         * Whether this is an example (test) invoice
         */
        isTest() {
          return this.raw.test;
        }
        /**
         * Product name, 1-32 characters
         */
        get title() {
          return this.raw.title;
        }
        /**
         * Product description, 1-255 characters
         */
        get description() {
          return this.raw.description;
        }
        /**
         * URL of the product photo for the invoice
         */
        get photo() {
          if (!this.raw.photo)
            return null;
          return new WebDocument(this.raw.photo);
        }
        /**
         * Message ID of receipt
         */
        get receiptMessageId() {
          var _a3;
          return (_a3 = this.raw.receiptMsgId) != null ? _a3 : null;
        }
        /**
         * Three-letter ISO 4217 currency code
         */
        get currency() {
          return this.raw.currency;
        }
        /**
         * Total price in the smallest units of the currency
         * (integer, not float/double). For example, for a price
         * of `US$ 1.45` `amount = 145`.
         *
         * See the exp parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json),
         * it shows the number of digits past the decimal point
         * for each currency (2 for the majority of currencies).
         */
        get amount() {
          return this.raw.totalAmount;
        }
        /**
         * Unique bot deep-linking parameter that can be used to generate this invoice
         */
        get startParam() {
          return this.raw.startParam;
        }
        /**
         * If this invoice has extended media
         */
        get extendedMediaState() {
          if (!this.raw.extendedMedia)
            return "none";
          if (this.raw.extendedMedia._ === "messageExtendedMediaPreview") {
            return "preview";
          }
          return "full";
        }
        /**
         * Get the invoice's extended media preview.
         * Only available if {@link extendedMediaState} is `preview`.
         * Otherwise, throws an error.
         */
        get extendedMediaPreview() {
          var _a3;
          if (((_a3 = this.raw.extendedMedia) == null ? void 0 : _a3._) !== "messageExtendedMediaPreview") {
            throw new MtArgumentError("No extended media preview available");
          }
          return new ExtendedMediaPreview(this.raw.extendedMedia);
        }
        /**
         * Get the invoice's extended media.
         * Only available if {@link extendedMediaState} is `full`.
         * Otherwise, throws an error.
         */
        get extendedMedia() {
          if (!this._extendedMedia) {
            throw new MtArgumentError("No extended media available");
          }
          return this._extendedMedia;
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}.
         *
         * Invoice can't provide an input media, since some
         * of the data is not available to the user,
         * which is required to send it. This getter
         * is only provided to allow using `msg.media.inputMedia`
         */
        get inputMedia() {
          throw new MtArgumentError("Invoice cannot provide an InputMedia");
        }
      }
      exports("c8", Invoice);
      memoizeGetters(Invoice, ["extendedMediaPreview", "photo"]);
      class RawLocation {
        constructor(geo2) {
          this.geo = geo2;
        }
        /**
         * Geo point latitude
         */
        get latitude() {
          return this.geo.lat;
        }
        /**
         * Geo point longitude
         */
        get longitude() {
          return this.geo.long;
        }
        /**
         * Accuracy radius in meters.
         */
        get radius() {
          var _a3;
          return (_a3 = this.geo.accuracyRadius) != null ? _a3 : 0;
        }
        /**
         * Create {@link FileLocation} containing
         * server-generated image with the map preview
         */
        preview(params = {}) {
          var _a3, _b2, _c, _d;
          return new FileLocation({
            _: "inputWebFileGeoPointLocation",
            geoPoint: {
              _: "inputGeoPoint",
              lat: this.geo.lat,
              long: this.geo.long,
              accuracyRadius: this.geo.accuracyRadius
            },
            accessHash: this.geo.accessHash,
            w: (_a3 = params.width) != null ? _a3 : 128,
            h: (_b2 = params.height) != null ? _b2 : 128,
            zoom: (_c = params.zoom) != null ? _c : 15,
            scale: (_d = params.scale) != null ? _d : 1
          });
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         */
        get inputMedia() {
          return {
            _: "inputMediaGeoPoint",
            geoPoint: {
              _: "inputGeoPoint",
              lat: this.geo.lat,
              long: this.geo.long,
              accuracyRadius: this.geo.accuracyRadius
            }
          };
        }
      }
      exports("cH", RawLocation);
      class Location extends RawLocation {
        constructor() {
          super(...arguments);
          __publicField(this, "type", "location");
        }
      }
      exports("ca", Location);
      class LiveLocation extends RawLocation {
        constructor(live) {
          super(live.geo);
          __publicField(this, "type", "live_location");
          this.live = live;
        }
        /**
         * A direction in which the location moves, in degrees; 1-360
         */
        get heading() {
          var _a3;
          return (_a3 = this.live.heading) != null ? _a3 : null;
        }
        /**
         * Validity period of provided geolocation
         */
        get period() {
          return this.live.period;
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         *
         * Note that using this will result in an
         * independent live geolocation, which
         * will not be auto-updated with the current
         */
        get inputMedia() {
          return {
            _: "inputMediaGeoLive",
            geoPoint: {
              _: "inputGeoPoint",
              lat: this.geo.lat,
              long: this.geo.long,
              accuracyRadius: this.geo.accuracyRadius
            },
            heading: this.live.heading,
            period: this.live.period,
            proximityNotificationRadius: this.live.proximityNotificationRadius
          };
        }
        // todo: api to subscribe for real-time updates
      }
      exports("c9", LiveLocation);
      class PaidMedia {
        constructor(raw, _extendedMedia) {
          __publicField(this, "type", "paid");
          this.raw = raw;
          this._extendedMedia = _extendedMedia;
        }
        /** Whether this media was paid for */
        get isPaid() {
          return this._extendedMedia !== void 0;
        }
        /** Price of the media (in Telegram Stars) */
        get price() {
          return this.raw.starsAmount;
        }
        /**
         * Get the available media previews.
         *
         * If the media is already paid for, this will return an empty array.
         */
        get previews() {
          const res = [];
          this.raw.extendedMedia.forEach((m2) => {
            if (m2._ !== "messageExtendedMediaPreview")
              return;
            res.push(new ExtendedMediaPreview(m2));
          });
          return res;
        }
        /**
         * Get the available full media.
         *
         * If the media is not paid for, this will return an empty array.
         */
        get medias() {
          return this._extendedMedia;
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}.
         *
         * Will throw if the media is not paid for.
         */
        get inputMedia() {
          if (!this.isPaid) {
            throw new Error("Cannot get input media for non-paid media");
          }
          return {
            _: "inputMediaPaidMedia",
            starsAmount: this.raw.starsAmount,
            extendedMedia: this._extendedMedia.map((m2) => m2.inputMedia)
          };
        }
      }
      exports("cv", PaidMedia);
      memoizeGetters(PaidMedia, ["previews", "inputMedia"]);
      class PollAnswer {
        constructor(raw, result) {
          this.raw = raw;
          this.result = result;
        }
        /**
         * Answer text
         */
        get text() {
          return this.raw.text.text;
        }
        /**
         * Format entities for {@link text}, currently may only contain custom emojis
         */
        get textEntities() {
          return this.raw.text.entities.map((ent) => new MessageEntity(ent, this.raw.text.text));
        }
        /**
         * Answer data, to be passed to
         * {@link TelegramClient.sendVote}
         */
        get data() {
          return this.raw.option;
        }
        /**
         * Number of people who has chosen this result.
         * If not available (i.e. not voted yet)
         *
         * @default
         */
        get voters() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.result) == null ? void 0 : _a3.voters) != null ? _b2 : 0;
        }
        /**
         * Whether this answer was chosen by the current user
         */
        get chosen() {
          var _a3;
          return Boolean((_a3 = this.result) == null ? void 0 : _a3.chosen);
        }
        /**
         * Whether this answer is correct (for quizzes).
         * Not available before choosing an answer
         *
         * @default
         */
        get correct() {
          var _a3;
          return Boolean((_a3 = this.result) == null ? void 0 : _a3.correct);
        }
      }
      exports("cC", PollAnswer);
      memoizeGetters(PollAnswer, ["textEntities"]);
      class Poll {
        constructor(raw, _peers, results) {
          __publicField(this, "type", "poll");
          this.raw = raw;
          this._peers = _peers;
          this.results = results;
        }
        /**
         * Unique identifier of the poll
         */
        get id() {
          return this.raw.id;
        }
        /**
         * Poll question
         */
        get question() {
          return this.raw.question.text;
        }
        /**
         * Format entities for {@link question} (currently may only contain custom emojis)
         */
        get questionEntities() {
          return this.raw.question.entities.map((ent) => new MessageEntity(ent, this.raw.question.text));
        }
        /**
         * List of answers in this poll
         */
        get answers() {
          var _a3;
          const results = (_a3 = this.results) == null ? void 0 : _a3.results;
          return this.raw.answers.map((ans, idx) => {
            if (results) {
              return new PollAnswer(ans, results[idx]);
            }
            return new PollAnswer(ans);
          });
        }
        /**
         * Total number of voters in this poll, if available
         */
        get voters() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.results) == null ? void 0 : _a3.totalVoters) != null ? _b2 : 0;
        }
        /**
         * Whether this poll is closed, i.e. does not
         * accept votes anymore
         */
        get isClosed() {
          return this.raw.closed;
        }
        /**
         * Whether this poll is public, i.e. you
         * list of voters is publicly available
         */
        get isPublic() {
          return this.raw.publicVoters;
        }
        /**
         * Whether this is a quiz
         */
        get isQuiz() {
          return this.raw.quiz;
        }
        /**
         * Whether this poll accepts multiple answers
         */
        get isMultiple() {
          return this.raw.multipleChoice;
        }
        /**
         * Solution for the quiz, only available
         * in case you have already answered
         */
        get solution() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.results) == null ? void 0 : _a3.solution) != null ? _b2 : null;
        }
        /**
         * Format entities for {@link solution}, only available
         * in case you have already answered
         */
        get solutionEntities() {
          var _a3;
          if (!this.results)
            return null;
          const res = [];
          if ((_a3 = this.results.solutionEntities) == null ? void 0 : _a3.length) {
            for(let   ent of this.results.solutionEntities) {
              res.push(new MessageEntity(ent, this.results.solution));
            }
          }
          return res;
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         *
         * A few notes:
         *  - Using this will result in an
         *    independent poll, which will not
         *    be auto-updated with the current.
         *  - If this is a quiz, a normal poll
         *    will be returned since the client does not
         *    know the correct answer.
         *  - This always returns a non-closed poll,
         *    even if the current poll was closed
         */
        get inputMedia() {
          return {
            _: "inputMediaPoll",
            poll: {
              _: "poll",
              closed: false,
              id: Long.ZERO,
              publicVoters: this.raw.publicVoters,
              multipleChoice: this.raw.multipleChoice,
              question: this.raw.question,
              answers: this.raw.answers,
              closePeriod: this.raw.closePeriod,
              closeDate: this.raw.closeDate
            }
          };
        }
      }
      exports("cB", Poll);
      memoizeGetters(Poll, ["answers", "solutionEntities", "questionEntities"]);
      function normalizeInputReaction(reaction) {
        if (typeof reaction === "string") {
          if (reaction === "paid") {
            return {
              _: "reactionPaid"
            };
          }
          return {
            _: "reactionEmoji",
            emoticon: reaction
          };
        } else if (Long.isLong(reaction)) {
          return {
            _: "reactionCustomEmoji",
            documentId: reaction
          };
        } else if (reaction) {
          return reaction;
        }
        return {
          _: "reactionEmpty"
        };
      }
      function toReactionEmoji(reaction, allowEmpty) {
        switch (reaction._) {
          case "reactionEmoji":
            return reaction.emoticon;
          case "reactionCustomEmoji":
            return reaction.documentId;
          case "reactionPaid":
            return "⭐";
          case "reactionEmpty":
            if (!allowEmpty) {
              throw new MtTypeAssertionError("toReactionEmoji", "not reactionEmpty", reaction._);
            }
            return null;
        }
      }
      class PeerReaction {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Emoji representing the reaction
         */
        get emoji() {
          return toReactionEmoji(this.raw.reaction);
        }
        /**
         * Whether this is a big reaction
         */
        get big() {
          return this.raw.big;
        }
        /**
         * Whether this reaction is unread by the current user
         */
        get unread() {
          return this.raw.unread;
        }
        /**
         * ID of the user who has reacted
         */
        get userId() {
          return getMarkedPeerId(this.raw.peerId);
        }
        /**
         * User who has reacted
         */
        get user() {
          assertTypeIs("PeerReaction#user", this.raw.peerId, "peerUser");
          return new User(this._peers.user(this.raw.peerId.userId));
        }
      }
      exports("cx", PeerReaction);
      memoizeGetters(PeerReaction, ["user"]);
      class PaidPeerReaction {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Whether this reaction is from the current user */
        get my() {
          return this.raw.my;
        }
        /** Whether this reaction was sent anonymously */
        get anonymous() {
          return this.raw.anonymous;
        }
        /**
         * If this reaction was not sent anonymously,
         * this field will contain the user who sent it
         */
        get peer() {
          if (!this.raw.peerId)
            return null;
          return parsePeer(this.raw.peerId, this._peers);
        }
        /** Number of reactions sent by this user */
        get count() {
          return this.raw.count;
        }
      }
      exports("cw", PaidPeerReaction);
      memoizeGetters(PaidPeerReaction, ["peer"]);
      class StoryInteractiveArea {
        constructor(raw) {
          this.raw = raw;
          this.raw = raw;
        }
        /** X coordinate of the top-left corner of the area */
        get x() {
          return this.raw.coordinates.x;
        }
        /** Y coordinate of the top-left corner of the area */
        get y() {
          return this.raw.coordinates.y;
        }
        /** Width of the area */
        get width() {
          return this.raw.coordinates.w;
        }
        /** Height of the area */
        get height() {
          return this.raw.coordinates.h;
        }
        /** Rotation of the area */
        get rotation() {
          return this.raw.coordinates.rotation;
        }
      }
      class StoryInteractiveChannelPost extends StoryInteractiveArea {
        constructor(raw, _peers) {
          super(raw);
          __publicField(this, "type", "channel_post");
          this.raw = raw;
          this._peers = _peers;
        }
        /** Channel being mentioned */
        get chat() {
          return new Chat(this._peers.chat(this.raw.channelId));
        }
        /** ID of the message being mentioned */
        get messageId() {
          return this.raw.msgId;
        }
      }
      exports("cV", StoryInteractiveChannelPost);
      memoizeGetters(StoryInteractiveChannelPost, ["chat"]);
      class StoryInteractiveLocation extends StoryInteractiveArea {
        constructor(raw) {
          super(raw);
          __publicField(this, "type", "location");
          this.raw = raw;
        }
        /**
         * Geolocation
         */
        get location() {
          assertTypeIs("StoryInteractiveLocation#location", this.raw.geo, "geoPoint");
          return new Location(this.raw.geo);
        }
      }
      exports("cW", StoryInteractiveLocation);
      memoizeGetters(StoryInteractiveLocation, ["location"]);
      class StoryInteractiveReaction extends StoryInteractiveArea {
        constructor(raw) {
          super(raw);
          __publicField(this, "type", "reaction");
          this.raw = raw;
        }
        /** Whether this reaction is on a dark background */
        get isDark() {
          return this.raw.dark;
        }
        /** Whether this reaction is flipped (i.e. has tail on the left) */
        get isFlipped() {
          return this.raw.flipped;
        }
        /** Emoji representing the reaction */
        get emoji() {
          return toReactionEmoji(this.raw.reaction);
        }
      }
      exports("cX", StoryInteractiveReaction);
      class StoryInteractiveUrl extends StoryInteractiveArea {
        constructor(raw) {
          super(raw);
          __publicField(this, "type", "url");
          this.raw = raw;
        }
        get url() {
          return this.raw.url;
        }
      }
      exports("cY", StoryInteractiveUrl);
      class StoryInteractiveVenue extends StoryInteractiveArea {
        constructor(raw) {
          super(raw);
          __publicField(this, "type", "venue");
          this.raw = raw;
        }
        /**
         * Geolocation of the venue
         */
        get location() {
          assertTypeIs("StoryInteractiveVenue#location", this.raw.geo, "geoPoint");
          return new Location(this.raw.geo);
        }
        /**
         * Venue name
         */
        get title() {
          return this.raw.title;
        }
        /**
         * Venue address
         */
        get address() {
          return this.raw.address;
        }
        /**
         * When available, source from where this venue was acquired
         */
        get source() {
          if (!this.raw.provider)
            return null;
          return {
            provider: this.raw.provider,
            id: this.raw.venueId,
            type: this.raw.venueType
          };
        }
      }
      exports("cZ", StoryInteractiveVenue);
      memoizeGetters(StoryInteractiveVenue, ["location"]);
      class StoryInteractiveWeather extends StoryInteractiveArea {
        constructor(raw) {
          super(raw);
          __publicField(this, "type", "weather");
          this.raw = raw;
        }
        /** Emoji representing the weather */
        get emoji() {
          return this.raw.emoji;
        }
        /** Temperature in Celsius */
        get temperature() {
          return this.raw.temperatureC;
        }
        get color() {
          return this.raw.color;
        }
      }
      exports("c_", StoryInteractiveWeather);
      function _storyInteractiveElementFromTl(raw, peers) {
        switch (raw._) {
          case "mediaAreaSuggestedReaction":
            return new StoryInteractiveReaction(raw);
          case "mediaAreaGeoPoint":
            return new StoryInteractiveLocation(raw);
          case "mediaAreaVenue":
            return new StoryInteractiveVenue(raw);
          case "mediaAreaChannelPost":
            return new StoryInteractiveChannelPost(raw, peers);
          case "mediaAreaUrl":
            return new StoryInteractiveUrl(raw);
          case "mediaAreaWeather":
            return new StoryInteractiveWeather(raw);
          case "inputMediaAreaVenue":
          case "inputMediaAreaChannelPost":
            throw new MtTypeAssertionError("StoryInteractiveElement", "!input*", raw._);
        }
      }
      class ReactionCount {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Emoji representing the reaction
         */
        get emoji() {
          return toReactionEmoji(this.raw.reaction);
        }
        /** Whether this is a paid reaction */
        get isPaid() {
          return this.raw.reaction._ === "reactionPaid";
        }
        /**
         * Number of users who reacted with this emoji
         */
        get count() {
          return this.raw.count;
        }
        /**
         * If the current user has reacted with this emoji,
         * this field will contain the order in which the
         * reaction was added.
         */
        get order() {
          var _a3;
          return (_a3 = this.raw.chosenOrder) != null ? _a3 : null;
        }
      }
      class StoryInteractions {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Whether information about viewers is available.
         *
         * When `true`, you can use {@link TelegarmClient.getStoryViewers}
         * to get the full list of viewers, and also {@link recentViewers}
         * will be available.
         */
        get hasViewers() {
          return this.raw.hasViewers;
        }
        /** Number of views */
        get viewsCount() {
          return this.raw.viewsCount;
        }
        /** Number of forwards (if available) */
        get forwardsCount() {
          var _a3;
          return (_a3 = this.raw.forwardsCount) != null ? _a3 : null;
        }
        /** Total number of reactions */
        get reactionsCount() {
          var _a3;
          return (_a3 = this.raw.reactionsCount) != null ? _a3 : 0;
        }
        /**
         * Reactions on the message, along with their counts
         */
        get reactions() {
          if (!this.raw.reactions)
            return [];
          return this.raw.reactions.map((it) => new ReactionCount(it));
        }
        /**
         * List of users who have recently viewed this story.
         */
        get recentViewers() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.recentViewers) == null ? void 0 : _a3.map((it) => new User(this._peers.user(it)))) != null ? _b2 : [];
        }
      }
      exports("cU", StoryInteractions);
      memoizeGetters(StoryInteractions, ["reactions", "recentViewers"]);
      class Story {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Whether this story is pinned */
        get isPinned() {
          return this.raw.pinned;
        }
        /**
         * Whether this object contains reduced set of fields.
         *
         * When `true`, these field will not contain correct data:
         * {@link privacyRules}, {@link interactiveAreas}
         *
         */
        get isShort() {
          return this.raw.min;
        }
        /** Whether this story is content-protected, i.e. can't be forwarded */
        get isContentProtected() {
          return this.raw.noforwards;
        }
        /** Whether this story has been edited */
        get isEdited() {
          return this.raw.edited;
        }
        /** Whether this story has been posted by the current user */
        get isMy() {
          return this.raw.out;
        }
        /** ID of the story */
        get id() {
          return this.raw.id;
        }
        /** Date when this story was posted */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /** Date when this story will expire */
        get expireDate() {
          return new Date(this.raw.expireDate * 1e3);
        }
        /** Whether the story is active (i.e. not expired yet) */
        get isActive() {
          return Date.now() < this.expireDate.getTime();
        }
        /** Story visibility */
        get visibility() {
          if (this.raw.public)
            return "public";
          if (this.raw.contacts)
            return "contacts";
          if (this.raw.closeFriends)
            return "close_friends";
          if (this.raw.selectedContacts)
            return "selected_contacts";
          throw new MtUnsupportedError("Unknown story visibility");
        }
        /** Caption of the story */
        get caption() {
          var _a3;
          return (_a3 = this.raw.caption) != null ? _a3 : null;
        }
        /**
         * Caption entities (may be empty)
         */
        get entities() {
          var _a3;
          const entities = [];
          if ((_a3 = this.raw.entities) == null ? void 0 : _a3.length) {
            for(let   ent of this.raw.entities) {
              entities.push(new MessageEntity(ent, this.raw.caption));
            }
          }
          return entities;
        }
        /**
         * Story media.
         *
         * Currently, can only be {@link Photo} or {@link Video}.
         */
        get media() {
          var _a3, _b2;
          switch (this.raw.media._) {
            case "messageMediaPhoto":
              if (((_a3 = this.raw.media.photo) == null ? void 0 : _a3._) !== "photo")
                throw new MtUnsupportedError("Unsupported story media type");
              return new Photo(this.raw.media.photo, this.raw.media);
            case "messageMediaDocument": {
              if (((_b2 = this.raw.media.document) == null ? void 0 : _b2._) !== "document") {
                throw new MtUnsupportedError("Unsupported story media type");
              }
              const doc = parseDocument(this.raw.media.document, this.raw.media);
              if (doc.type === "video")
                return doc;
            }
          }
          throw new MtUnsupportedError("Unsupported story media type");
        }
        /**
         * Interactive elements of the story
         */
        get interactiveElements() {
          if (!this.raw.mediaAreas)
            return [];
          return this.raw.mediaAreas.map((it) => _storyInteractiveElementFromTl(it, this._peers));
        }
        /**
         * Privacy rules of the story.
         *
         * Only available when {@link isMy} is `true`.
         */
        get privacyRules() {
          if (!this.raw.privacy)
            return null;
          return this.raw.privacy;
        }
        /**
         * Information about story interactions
         */
        get interactions() {
          if (!this.raw.views)
            return null;
          return new StoryInteractions(this.raw.views, this._peers);
        }
        /**
         * Emoji representing a reaction sent by the current user, if any
         */
        get sentReactionEmoji() {
          if (!this.raw.sentReaction)
            return null;
          return toReactionEmoji(this.raw.sentReaction, true);
        }
      }
      exports("cT", Story);
      memoizeGetters(Story, ["entities", "media", "interactiveElements", "interactions"]);
      class MediaStory {
        constructor(raw, _peers) {
          __publicField(this, "type", "story");
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Whether this story was automatically forwarded to you
         * because you were mentioned in it
         */
        get isMention() {
          return this.raw.viaMention;
        }
        /**
         * Peer who has posted this story
         */
        get peer() {
          return parsePeer(this.raw.peer, this._peers);
        }
        /**
         * ID of the story
         */
        get storyId() {
          return this.raw.id;
        }
        /**
         * Contents of the story. May not be available, in which case the story
         * should be fetched using {@link getStoriesById}
         */
        get story() {
          var _a3;
          if (((_a3 = this.raw.story) == null ? void 0 : _a3._) !== "storyItem")
            return null;
          return new Story(this.raw.story, this._peers);
        }
        get inputMedia() {
          return {
            _: "inputMediaStory",
            peer: this.peer.inputPeer,
            id: this.raw.id
          };
        }
      }
      exports("cc", MediaStory);
      class Venue {
        constructor(raw) {
          __publicField(this, "type", "venue");
          this.raw = raw;
        }
        /**
         * Geolocation of the venue
         */
        get location() {
          assertTypeIs("Venue#location", this.raw.geo, "geoPoint");
          return new Location(this.raw.geo);
        }
        /**
         * Venue name
         */
        get title() {
          return this.raw.title;
        }
        /**
         * Venue address
         */
        get address() {
          return this.raw.address;
        }
        /**
         * When available, source from where this venue was acquired
         */
        get source() {
          if (!this.raw.provider)
            return null;
          return {
            provider: this.raw.provider,
            id: this.raw.venueId,
            type: this.raw.venueType
          };
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}
         *
         * A few notes:
         *  - Using this will result in an
         *    independent poll, which will not
         *    be auto-updated with the current.
         *  - If this is a quiz, a normal poll
         *    will be returned since the client does not
         *    know the correct answer.
         *  - This always returns a non-closed poll,
         *    even if the current poll was closed
         */
        get inputMedia() {
          return {
            _: "inputMediaVenue",
            geoPoint: {
              _: "inputGeoPoint",
              lat: this.raw.geo.lat,
              long: this.raw.geo.long,
              accuracyRadius: this.raw.geo.accuracyRadius
            },
            title: this.raw.title,
            address: this.raw.address,
            provider: this.raw.provider,
            venueId: this.raw.venueId,
            venueType: this.raw.venueType
          };
        }
      }
      exports("dh", Venue);
      memoizeGetters(Venue, ["location", "source"]);
      class WebPage {
        constructor(raw) {
          __publicField(this, "type", "webpage");
          this.raw = raw;
        }
        /**
         * Unique ID of the preview
         */
        get id() {
          return this.raw.id;
        }
        /**
         * Original page URL
         */
        get url() {
          return this.raw.url;
        }
        /**
         * URL to be displayed to the user.
         *
         * Usually a normal URL with stripped protocol and garbage.
         */
        get displayUrl() {
          return this.raw.displayUrl;
        }
        /**
         * Type of the preview, taken directly from TL object
         *
         * Officially documented are:
         * `article, photo, audio, video, document, profile, app`,
         * but also these are encountered:
         * `telegram_user, telegram_bot, telegram_channel, telegram_megagroup, telegram_story`:
         *
         * - `telegram_*` ones seem to be used for `t.me` links.
         * - `article` seems to be used for almost all custom pages with `og:*` tags
         * - `photo`, `audio` and `video` seem to be derived from `og:type`,
         *    and the page itself may contain a preview photo and an embed link
         *    for the player. This may not correctly represent actual content type:
         *    Spotify links are `audio`, but SoundCloud are `video`. YouTube links are `video`,
         *    but tweets with video are `photo`.
         * - `document` seem to be used for files downloadable directly from the URL,
         *    like PDFs, audio files, videos, etc. {@link document} seem to be
         *    present if `type` is `document`.
         * - `profile` doesn't seem to be used
         * - `app` doesn't seem to be used
         *
         * `unknown` is returned if no type is returned in the TL object.
         */
        get previewType() {
          return this.raw.type || "unknown";
        }
        /**
         * Page title
         *
         * Usually defined by `og:site_name` meta tag or website domain
         */
        get siteName() {
          var _a3;
          return (_a3 = this.raw.siteName) != null ? _a3 : null;
        }
        /**
         * Page title
         *
         * Usually defined by `og:title` meta tag or `<title>` tag
         */
        get title() {
          var _a3;
          return (_a3 = this.raw.title) != null ? _a3 : null;
        }
        /**
         * Page description
         *
         * Usually defined by `description` or `og:description` meta tag
         */
        get description() {
          var _a3;
          return (_a3 = this.raw.description) != null ? _a3 : null;
        }
        /**
         * Page author
         *
         * The source for this is unknown, seems to be
         * custom-made for services like Twitter.
         *
         * In official apps this seems to be used as a fallback for description.
         */
        get author() {
          var _a3;
          return (_a3 = this.raw.author) != null ? _a3 : null;
        }
        /**
         * The embed URL.
         *
         * Based on my research, Telegram only allows
         * embedding pages from a server-side white-list of domains.
         *
         * That is, you can't just copy-paste meta tags
         * from YouTube to your own domain and expect Telegram
         * to return a webpage with embed.
         *
         * IDK why is that, maybe they are concerned about
         * leaking users' IPs to 3rd parties or something
         * (but why allow embedding in the first place then?)
         *
         * Telegram for Android does not show "play" button for
         * webpages without embeds, and instead treats it like a simple
         * photo (why?).
         *
         * TDesktop does not support embeds and seems
         * to use {@link type} to determine them, and specifically
         * [checks](https://github.com/telegramdesktop/tdesktop/blob/3343880ed0e5a86accc7334af54b3470e29ee686/Telegram/SourceFiles/history/view/media/history_view_web_page.cpp#L561)
         * for `YouTube` in {@link siteName} to display YouTube icon.
         */
        get embedUrl() {
          var _a3;
          return (_a3 = this.raw.embedUrl) != null ? _a3 : null;
        }
        /**
         * Embed type.
         *
         * Now this is actually stupid.
         * As per [official documentation](https://core.telegram.org/constructor/webPage),
         * `embed_type` contains «MIME type of the embedded preview, (e.g., text/html or video/mp4)».
         * But in fact every time I encountered it it contained a simple string `iframe`.
         *
         * I couldn't find any usage of this field in official apps either.
         */
        get embedType() {
          var _a3;
          return (_a3 = this.raw.embedType) != null ? _a3 : null;
        }
        /**
         * Width of the embed in pixels, 0 if not available.
         */
        get embedWidth() {
          return this.raw.embedWidth || 0;
        }
        /**
         * Height of the embed in pixels, 0 if not available.
         */
        get embedHeight() {
          return this.raw.embedHeight || 0;
        }
        /**
         * A photo inside this webpage preview.
         *
         * Used for most of the preview types.
         */
        get photo() {
          var _a3;
          if (((_a3 = this.raw.photo) == null ? void 0 : _a3._) !== "photo") {
            return null;
          }
          return new Photo(this.raw.photo);
        }
        /**
         * Document inside this webpage preview.
         *
         * Seems that this is only used for `document` previews.
         *
         * Can be a {@link Photo}, {@link Video},
         * {@link Audio}, {@link Document}.
         */
        get document() {
          var _a3;
          if (((_a3 = this.raw.document) == null ? void 0 : _a3._) !== "document") {
            return null;
          }
          return parseDocument(this.raw.document);
        }
        /**
         * Input media TL object generated from this object,
         * to be used inside {@link InputMediaLike} and
         * {@link TelegramClient.sendMedia}.
         *
         * WebPage can't provide an input media, since some
         * can only be auto-generated from a link. This getter
         * is only provided to allow using `msg.media.inputMedia`
         */
        get inputMedia() {
          throw new MtArgumentError("WebPage cannot provide an InputMedia");
        }
      }
      exports("dm", WebPage);
      memoizeGetters(WebPage, ["photo", "document"]);
      function _messageMediaFromTl(peers, m2) {
        var _a3, _b2, _c;
        switch (m2._) {
          case "messageMediaPhoto":
            if (!(((_a3 = m2.photo) == null ? void 0 : _a3._) === "photo"))
              return null;
            return new Photo(m2.photo, m2);
          case "messageMediaDice":
            return new Dice(m2);
          case "messageMediaContact":
            return new Contact(m2);
          case "messageMediaDocument":
            if (!(((_b2 = m2.document) == null ? void 0 : _b2._) === "document"))
              return null;
            return parseDocument(m2.document, m2);
          case "messageMediaGeo":
            if (!(m2.geo._ === "geoPoint"))
              return null;
            return new Location(m2.geo);
          case "messageMediaGeoLive":
            if (!(m2.geo._ === "geoPoint"))
              return null;
            return new LiveLocation(m2);
          case "messageMediaGame":
            return new Game(m2.game);
          case "messageMediaWebPage":
            if (!(m2.webpage._ === "webPage"))
              return null;
            return new WebPage(m2.webpage);
          case "messageMediaVenue":
            return new Venue(m2);
          case "messageMediaPoll":
            if (!peers) {
              throw new MtTypeAssertionError("can't create poll without peers index", "PeersIndex", "null");
            }
            return new Poll(m2.poll, peers, m2.results);
          case "messageMediaInvoice": {
            const extended = ((_c = m2.extendedMedia) == null ? void 0 : _c._) === "messageExtendedMedia" ? _messageMediaFromTl(peers, m2.extendedMedia.media) : null;
            return new Invoice(m2, extended);
          }
          case "messageMediaStory": {
            if (!peers) {
              throw new MtTypeAssertionError("can't create story without peers index", "PeersIndex", "null");
            }
            return new MediaStory(m2, peers);
          }
          case "messageMediaPaidMedia": {
            const extended = [];
            m2.extendedMedia.forEach((e2) => {
              if (e2._ !== "messageExtendedMedia")
                return;
              extended.push(_messageMediaFromTl(peers, e2.media));
            });
            return new PaidMedia(m2, extended);
          }
          default:
            return null;
        }
      }
      class MessageReactions {
        constructor(messageId, chatId, raw, _peers) {
          this.messageId = messageId;
          this.chatId = chatId;
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Whether you can use {@link getUsers}
         * (or {@link TelegramClient.getReactionUsers})
         * to get the users who reacted to this message
         */
        get usersVisible() {
          return this.raw.canSeeList;
        }
        /**
         * Reactions on the message, along with their counts
         */
        get reactions() {
          return this.raw.results.map((it) => new ReactionCount(it));
        }
        /**
         * Recently reacted users.
         * To get a full list of users, use {@link getUsers}
         */
        get recentReactions() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.recentReactions) == null ? void 0 : _a3.map((reaction) => new PeerReaction(reaction, this._peers))) != null ? _b2 : [];
        }
        /** Leaderboard of paid reactions to the message */
        get paidReactions() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.topReactors) == null ? void 0 : _a3.map((reaction) => new PaidPeerReaction(reaction, this._peers))) != null ? _b2 : [];
        }
      }
      exports("ch", MessageReactions);
      memoizeGetters(MessageReactions, ["reactions", "recentReactions"]);
      class MessageRepliesInfo {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Whether this message is a channel post that has a comments thread
         * in the linked discussion group
         */
        get hasComments() {
          return this.raw.comments;
        }
        /**
         * Total number of replies
         */
        get count() {
          return this.raw.replies;
        }
        /**
         * Whether this reply thread has unread messages
         */
        get hasUnread() {
          return this.raw.readMaxId !== void 0 && this.raw.readMaxId !== this.raw.maxId;
        }
        /**
         * ID of the last message in the thread (if any)
         */
        get lastMessageId() {
          var _a3;
          return (_a3 = this.raw.maxId) != null ? _a3 : null;
        }
        /**
         * ID of the last read message in the thread (if any)
         */
        get lastReadMessageId() {
          var _a3;
          return (_a3 = this.raw.readMaxId) != null ? _a3 : null;
        }
        /**
         * ID of the discussion group for the post
         *
         * `null` if the post is not a channel post
         */
        get discussion() {
          if (!this.raw.channelId)
            return null;
          return getMarkedPeerId(this.raw.channelId, "channel");
        }
        /**
         * Last few commenters to the post (usually 3)
         */
        get repliers() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.recentRepliers) == null ? void 0 : _a3.map((it) => parsePeer(it, this._peers))) != null ? _b2 : [];
        }
      }
      exports("ci", MessageRepliesInfo);
      memoizeGetters(MessageRepliesInfo, ["discussion", "repliers"]);
      class RepliedMessageInfo {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Whether this message is a reply to another scheduled message */
        get isScheduled() {
          return this.raw.replyToScheduled;
        }
        /** Whether this message was sent to a forum topic */
        get isForumTopic() {
          return this.raw.forumTopic;
        }
        /** Whether this message is quoting another message */
        get isQuote() {
          return this.raw.quote;
        }
        /** Origin of the replied-to message */
        get origin() {
          if (!this.raw.replyToMsgId)
            return "private";
          if (!this.raw.replyFrom)
            return "same_chat";
          return "other_chat";
        }
        /**
         * Helper method to check {@link origin} that will also
         * narrow the type of this object respectively
         */
        originIs(origin) {
          var _a3;
          if (this.origin === origin) {
            switch (origin) {
              case "same_chat":
                return true;
              case "other_chat":
                return this.raw.replyToPeerId !== void 0;
              case "private":
                return ((_a3 = this.raw.replyFrom) == null ? void 0 : _a3.fromId) !== void 0;
            }
          }
          return false;
        }
        /**
         * For non-`private` origin, ID of the replied-to message in the original chat.
         */
        get id() {
          var _a3;
          return (_a3 = this.raw.replyToMsgId) != null ? _a3 : null;
        }
        /** ID of the replies thread where this message belongs to */
        get threadId() {
          var _a3;
          return (_a3 = this.raw.replyToTopId) != null ? _a3 : null;
        }
        /**
         * If replied-to message is available, chat where the message was sent.
         *
         * If `null`, the message was sent in the same chat.
         */
        get chat() {
          if (!this.raw.replyToPeerId || !this.raw.replyFrom) {
            return null;
          }
          return Chat._parseFromPeer(this.raw.replyToPeerId, this._peers);
        }
        /**
         * Sender of the replied-to message (either user or a channel)
         * or their name (for users with private forwards).
         *
         * For replies to channel messages, this will be the channel itself.
         *
         * `null` if the sender is not available (for `same_chat` origin)
         */
        get sender() {
          var _a3;
          const { replyFrom, replyToPeerId } = this.raw;
          if (!replyFrom && !replyToPeerId)
            return null;
          if (replyFrom == null ? void 0 : replyFrom.fromName) {
            return {
              type: "anonymous",
              displayName: replyFrom.fromName
            };
          }
          const peer = (_a3 = replyFrom == null ? void 0 : replyFrom.fromId) != null ? _a3 : replyToPeerId;
          if (peer) {
            switch (peer._) {
              case "peerChannel":
                return new Chat(this._peers.chat(peer.channelId));
              case "peerUser":
                return new User(this._peers.user(peer.userId));
              default:
                throw new MtTypeAssertionError("fromId ?? replyToPeerId", "peerUser | peerChannel", peer._);
            }
          }
          throw new MtTypeAssertionError("replyFrom", "to have fromId, replyToPeerId or fromName", "neither");
        }
        /**
         * For non-`same_chat` origin, date the original message was sent.
         */
        get date() {
          var _a3;
          if (!((_a3 = this.raw.replyFrom) == null ? void 0 : _a3.date))
            return null;
          return new Date(this.raw.replyFrom.date * 1e3);
        }
        /**
         * If this message is a quote, text of the quote.
         *
         * For non-`same_chat` origin, this will be the full text of the
         * replied-to message in case `.isQuote` is `false`
         */
        get quoteText() {
          var _a3;
          return (_a3 = this.raw.quoteText) != null ? _a3 : "";
        }
        /** Message entities contained in the quote */
        get quoteEntities() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.quoteEntities) == null ? void 0 : _a3.map((e2) => new MessageEntity(e2))) != null ? _b2 : [];
        }
        /**
         * Offset of the start of the {@link quoteText} in the replied-to message.
         *
         * Note that this offset should only be used as a hint, as the actual
         * quote offset may be different due to message being edited after the quote
         *
         * `null` if not available, in which case it should be assumed that the quote
         * starts at `.indexOf(quoteText)` of the replied-to message text.
         */
        get quoteOffset() {
          if (!this.raw.quoteOffset)
            return null;
          return this.raw.quoteOffset;
        }
        /**
         * Media contained in the replied-to message
         *
         * Only available for non-`same_chat` origin
         */
        get media() {
          if (!this.raw.replyMedia)
            return null;
          return _messageMediaFromTl(this._peers, this.raw.replyMedia);
        }
      }
      exports("cI", RepliedMessageInfo);
      memoizeGetters(RepliedMessageInfo, ["chat", "sender", "quoteEntities", "media"]);
      class Message {
        constructor(raw, _peers, isScheduled = false) {
          /**
           * Raw TL object.
           */
          __publicField(this, "raw");
          this._peers = _peers;
          this.isScheduled = isScheduled;
          assertTypeIsNot("Message#ctor", raw, "messageEmpty");
          this.raw = raw;
        }
        /** Unique message identifier inside this chat */
        get id() {
          return this.raw.id;
        }
        /**
         * For channel posts, number of views
         *
         * `null` for service messages and non-post messages.
         */
        get views() {
          var _a3;
          return this.raw._ === "message" ? (_a3 = this.raw.views) != null ? _a3 : null : null;
        }
        /**
         * For channel posts, number of forwards
         *
         * `null` for service messages and non-post messages, or
         * if the current user is not an admin in the channel
         */
        get forwards() {
          var _a3;
          return this.raw._ === "message" ? (_a3 = this.raw.forwards) != null ? _a3 : null : null;
        }
        /**
         * For channel posts with signatures enabled, name of the post author
         */
        get signature() {
          var _a3;
          return this.raw._ === "message" ? (_a3 = this.raw.postAuthor) != null ? _a3 : null : null;
        }
        /**
         * Whether the message is incoming or outgoing:
         *  - Messages received from other chats are incoming (`outgoing = false`)
         *  - Messages sent by you to other chats are outgoing (`outgoing = true`)
         *  - Messages to yourself (i.e. *Saved Messages*) are incoming (`outgoing = false`)
         */
        get isOutgoing() {
          return this.raw.out;
        }
        /**
         * Whether this message is a service message
         */
        get isService() {
          return this.raw._ === "messageService";
        }
        /** Whether this message has content protection (i.e. disabled forwards) */
        get isContentProtected() {
          return this.raw._ === "message" && this.raw.noforwards;
        }
        /**
         * Whether the message was sent by an implicit action, for example,
         * as an away or a greeting business message, or as a scheduled message
         */
        get isFromOffline() {
          return this.raw._ === "message" && this.raw.offline;
        }
        /** Whether this is a silent message (no notification triggered) */
        get isSilent() {
          return this.raw.silent;
        }
        /** Whether there are unread media attachments in this message */
        get hasUnreadMedia() {
          return this.raw.mediaUnread;
        }
        /** Whether this is a broadcast channel post */
        get isChannelPost() {
          return this.raw._ === "message" && this.raw.post;
        }
        /**
         * Whether this message was automatically sent from a scheduled message.
         *
         * **Note**: for messages sent by other users, this is always `false`.
         */
        get isFromScheduled() {
          return this.raw._ === "message" && this.raw.fromScheduled;
        }
        /** Whether the message is pinned in the current chat */
        get isPinned() {
          return this.raw._ === "message" && this.raw.pinned;
        }
        /** Whether the message should be considered unedited, even if {@link editDate} ≠ null */
        get hideEditMark() {
          return this.raw._ === "message" && this.raw.editHide;
        }
        /**
         * If set, any eventual webpage preview should be shown on top of
         * the message instead of at the bottom.
         */
        get invertMedia() {
          return this.raw._ === "message" && this.raw.invertMedia;
        }
        /**
         * Multiple media messages with the same grouped ID
         * indicate an album or media group
         *
         * `null` for service messages and non-grouped messages
         */
        get groupedId() {
          var _a3;
          return this.raw._ === "message" ? (_a3 = this.raw.groupedId) != null ? _a3 : null : null;
        }
        /**
         * Same as {@link groupedId}, but is globally unique across chats.
         */
        get groupedIdUnique() {
          if (!(this.raw._ === "message" && this.raw.groupedId !== void 0))
            return null;
          return `${this.raw.groupedId.low}|${this.raw.groupedId.high}|${getMarkedPeerId(this.raw.peerId)}`;
        }
        /**
         * Message sender.
         *
         * Usually is a {@link User}, but can be a {@link Chat}
         * in case the message was sent by an anonymous admin, anonymous premium user,
         * or if the message is a forwarded channel post.
         *
         * If the message was sent by an anonymous admin,
         * sender will equal to {@link chat}.
         *
         * If the message is a forwarded channel post,
         * sender is the channel itself.
         */
        get sender() {
          const from2 = this.raw.fromId;
          if (!from2) {
            if (this.raw.peerId._ === "peerUser") {
              return new User(this._peers.user(this.raw.peerId.userId));
            }
            return this.chat;
          }
          return parsePeer(from2, this._peers);
        }
        /**
         * Number of boosts applied to this {@link chat} by the sender
         */
        get senderBoostCount() {
          var _a3;
          if (this.raw._ !== "message")
            return 0;
          return (_a3 = this.raw.fromBoostsApplied) != null ? _a3 : 0;
        }
        /**
         * Conversation the message belongs to
         */
        get chat() {
          return Chat._parseFromMessage(this.raw, this._peers);
        }
        /**
         * Date when the message was sent
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Date when the message was last edited
         */
        get editDate() {
          if (this.raw._ === "messageService")
            return null;
          return this.raw.editDate ? new Date(this.raw.editDate * 1e3) : null;
        }
        /**
         * If this message is a forward, contains info about it.
         */
        get forward() {
          if (this.raw._ !== "message" || !this.raw.fwdFrom) {
            return null;
          }
          return new MessageForwardInfo(this.raw.fwdFrom, this._peers);
        }
        /**
         * Whether the message is a channel post that was
         * automatically forwarded to the connected discussion group
         */
        get isAutomaticForward() {
          var _a3;
          if (this.raw._ === "messageService" || !this.raw.fwdFrom)
            return false;
          const fwd = this.raw.fwdFrom;
          return Boolean(
            this.chat.chatType === "supergroup" && fwd.savedFromMsgId && ((_a3 = fwd.savedFromPeer) == null ? void 0 : _a3._) === "peerChannel" && getMarkedPeerId(fwd.savedFromPeer) !== getMarkedPeerId(this.raw.peerId)
          );
        }
        /**
         * Information about comments (for channels) or replies (for groups)
         */
        get replies() {
          if (this.raw._ !== "message" || !this.raw.replies)
            return null;
          return new MessageRepliesInfo(this.raw.replies, this._peers);
        }
        /**
         * For replies, information about the that is being replied to.
         *
         * Mutually exclusive with {@link replyToStory}
         */
        get replyToMessage() {
          var _a3;
          if (((_a3 = this.raw.replyTo) == null ? void 0 : _a3._) !== "messageReplyHeader")
            return null;
          return new RepliedMessageInfo(this.raw.replyTo, this._peers);
        }
        /**
         * For replies, information about the story that is being replied to
         *
         * Mutually exclusive with {@link replyToMessage}
         */
        get replyToStory() {
          var _a3;
          if (((_a3 = this.raw.replyTo) == null ? void 0 : _a3._) !== "messageReplyStoryHeader")
            return null;
          return this.raw.replyTo;
        }
        /** Whether this message is in a forum topic */
        get isTopicMessage() {
          var _a3;
          if (((_a3 = this.raw.replyTo) == null ? void 0 : _a3._) !== "messageReplyHeader")
            return false;
          return this.raw.replyTo.forumTopic;
        }
        /**
         * Whether this message contains mention of the current user
         */
        get isMention() {
          return this.raw.mentioned;
        }
        /**
         * If non-null, this message is not actually sent, and is
         * instead inside a group of "quick reply" messages
         * under the given shortcut ID
         */
        get quickReplyShortcutId() {
          var _a3;
          if (this.raw._ === "messageService")
            return null;
          return (_a3 = this.raw.quickReplyShortcutId) != null ? _a3 : null;
        }
        /**
         * If this message is generated from an inline query,
         * information about the bot which generated it
         */
        get viaBot() {
          if (this.raw._ === "messageService" || !this.raw.viaBotId) {
            return null;
          }
          return new User(this._peers.user(this.raw.viaBotId));
        }
        /**
         * If this message was sent by a business bot on behalf of {@link sender},
         * information about the business bot.
         *
         * **Note**: only available to the business account and the bot itself.
         */
        get viaBusinessBot() {
          if (this.raw._ === "messageService" || !this.raw.viaBusinessBotId) {
            return null;
          }
          return new User(this._peers.user(this.raw.viaBusinessBotId));
        }
        /**
         * Message text or media caption.
         *
         * Empty string for service messages
         * (you should handle i18n yourself)
         */
        get text() {
          return this.raw._ === "messageService" ? "" : this.raw.message;
        }
        /**
         * Message text/caption entities (may be empty)
         */
        get entities() {
          var _a3;
          const entities = [];
          if (this.raw._ === "message" && ((_a3 = this.raw.entities) == null ? void 0 : _a3.length)) {
            for(let   ent of this.raw.entities) {
              entities.push(new MessageEntity(ent, this.raw.message));
            }
          }
          return entities;
        }
        get textWithEntities() {
          if (this.raw._ === "messageService")
            return { text: "", entities: [] };
          return {
            text: this.raw.message,
            entities: this.raw.entities
          };
        }
        /**
         * Message action. `null` for non-service messages
         * or for unsupported events.
         *
         * For unsupported events, use `.raw.action` directly.
         */
        get action() {
          if (this.raw._ === "message") {
            return null;
          }
          return _messageActionFromTl.call(this, this.raw.action);
        }
        /**
         * Message media. `null` for text-only and service messages
         * and for unsupported media types.
         *
         * For unsupported media types, use `.raw.media` directly.
         */
        get media() {
          if (this.raw._ === "messageService" || !this.raw.media || this.raw.media._ === "messageMediaEmpty") {
            return null;
          }
          return _messageMediaFromTl(this._peers, this.raw.media);
        }
        /**
         * Whether this is a premium media
         * (e.g. >2gb file or fullscreen sticker)
         * that was forwarded without author by a non-premium user
         */
        get isForwardedPremiumMedia() {
          var _a3;
          return this.raw._ === "message" && ((_a3 = this.raw.media) == null ? void 0 : _a3._) === "messageMediaDocument" && this.raw.media.nopremium;
        }
        /**
         * TTL period of the message, in seconds.
         */
        get ttlPeriod() {
          var _a3;
          return (_a3 = this.raw.ttlPeriod) != null ? _a3 : null;
        }
        /**
         * Reply markup provided with this message, if any.
         */
        get markup() {
          if (this.raw._ === "messageService" || !this.raw.replyMarkup) {
            return null;
          }
          const rm = this.raw.replyMarkup;
          switch (rm._) {
            case "replyKeyboardHide":
              return {
                type: "reply_hide",
                selective: rm.selective
              };
            case "replyKeyboardForceReply":
              return {
                type: "force_reply",
                singleUse: rm.singleUse,
                selective: rm.selective
              };
            case "replyKeyboardMarkup":
              return {
                type: "reply",
                resize: rm.resize,
                singleUse: rm.singleUse,
                selective: rm.selective,
                buttons: _rowsTo2d(rm.rows)
              };
            case "replyInlineMarkup":
              return {
                type: "inline",
                buttons: _rowsTo2d(rm.rows)
              };
            default:
              assertNever$1();
          }
        }
        /**
         * Whether this message can be forwarded
         *
         * `false` for service mesasges and private restricted chats/chanenls
         */
        get canBeForwarded() {
          return this.raw._ === "message" && !this.raw.noforwards;
        }
        /**
         * Reactions added to this message, if any
         */
        get reactions() {
          if (this.raw._ === "messageService" || !this.raw.reactions) {
            return null;
          }
          return new MessageReactions(this.raw.id, getMarkedPeerId(this.raw.peerId), this.raw.reactions, this._peers);
        }
        /**
         * Information about fact-check added to the message, if any
         */
        get factCheck() {
          if (this.raw._ === "messageService")
            return null;
          if (!this.raw.factcheck || this.raw.factcheck.hash.isZero())
            return null;
          return new FactCheck(this.raw.factcheck);
        }
        /**
         * If this message was sent with a message effect, ID of the effect
         */
        get effectId() {
          var _a3;
          if (this.raw._ === "messageService")
            return null;
          return (_a3 = this.raw.effect) != null ? _a3 : null;
        }
        /**
         * Generated permalink to this message, only for groups and channels
         *
         * @throws MtArgumentError  In case the chat does not support message links
         */
        get link() {
          if (this.chat.chatType === "supergroup" || this.chat.chatType === "channel") {
            if (this.chat.username) {
              return `https://t.me/${this.chat.username}/${this.id}`;
            }
            return `https://t.me/c/${toggleChannelIdMark(this.chat.id)}/${this.id}`;
          }
          throw new MtArgumentError(`Cannot generate message link for ${this.chat.chatType}`);
        }
      }
      exports("cd", Message);
      memoizeGetters(Message, [
        "sender",
        "chat",
        "forward",
        "replies",
        "viaBot",
        "entities",
        "action",
        "media",
        "markup",
        "reactions",
        "factCheck"
      ]);
      class Dialog {
        constructor(raw, _peers, _messages) {
          this.raw = raw;
          this._peers = _peers;
          this._messages = _messages;
        }
        /**
         * Parse a list of dialogs from a TL object
         *
         * @param client  Client instance
         * @param dialogs  TL object
         * @param limit  Maximum number of dialogs to parse
         */
        static parseTlDialogs(dialogs2, limit) {
          assertTypeIsNot("parseDialogs", dialogs2, "messages.dialogsNotModified");
          const peers = PeersIndex.from(dialogs2);
          const messages = /* @__PURE__ */ new Map();
          dialogs2.messages.forEach((msg) => {
            if (!msg.peerId)
              return;
            messages.set(getMarkedPeerId(msg.peerId), msg);
          });
          const arr = dialogs2.dialogs.filter(hasValueAtKey("_", "dialog")).map((it) => new Dialog(it, peers, messages));
          if (limit) {
            return arr.slice(0, limit);
          }
          return arr;
        }
        /**
         * Find pinned dialogs from a list of dialogs
         *
         * @param dialogs  Dialogs list
         * @param folder  If passed, status of pin will be checked against this folder, and not globally
         */
        static findPinned(dialogs2, folder) {
          if (folder) {
            const index = {};
            folder.pinnedPeers.forEach((peer) => {
              index[getMarkedPeerId(peer)] = true;
            });
            return dialogs2.filter((i) => index[i.chat.id]);
          }
          return dialogs2.filter((i) => i.isPinned);
        }
        /**
         * Create a filter predicate for the given Folder.
         * Returned predicate can be used in `Array.filter()`
         *
         * @param folder  Folder to filter for
         * @param excludePinned  Whether to exclude pinned folders
         */
        static filterFolder(folder, excludePinned = true) {
          if (folder._ === "dialogFilterDefault") {
            return () => true;
          }
          const pinned = {};
          const include = {};
          const exclude2 = {};
          if (excludePinned) {
            folder.pinnedPeers.forEach((peer) => {
              pinned[getMarkedPeerId(peer)] = true;
            });
          }
          folder.includePeers.forEach((peer) => {
            include[getMarkedPeerId(peer)] = true;
          });
          if (folder._ === "dialogFilterChatlist") {
            return (dialog2) => {
              const chatId = dialog2.chat.id;
              if (excludePinned && pinned[chatId])
                return false;
              return include[chatId] || pinned[chatId];
            };
          }
          folder.excludePeers.forEach((peer) => {
            exclude2[getMarkedPeerId(peer)] = true;
          });
          return (dialog2) => {
            const chat2 = dialog2.chat;
            const chatId = dialog2.chat.id;
            const chatType = dialog2.chat.chatType;
            if (include[chatId])
              return true;
            if (exclude2[chatId] || excludePinned && pinned[chatId]) {
              return false;
            }
            if (folder.excludeRead && !dialog2.isUnread)
              return false;
            if (folder.excludeMuted && dialog2.isMuted)
              return false;
            if (folder.excludeArchived && dialog2.isArchived)
              return false;
            if (folder.contacts && chatType === "private" && chat2.isContact) {
              return true;
            }
            if (folder.nonContacts && chatType === "private" && !chat2.isContact) {
              return true;
            }
            if (folder.groups && (chatType === "group" || chatType === "supergroup")) {
              return true;
            }
            if (folder.broadcasts && chatType === "channel")
              return true;
            if (folder.bots && chatType === "bot")
              return true;
            return false;
          };
        }
        /**
         * Whether this dialog is pinned
         */
        get isPinned() {
          return this.raw.pinned;
        }
        /**
         * Whether this chat was manually marked as unread
         */
        get isManuallyUnread() {
          return this.raw.unreadMark;
        }
        /**
         * Whether this chat should be considered unread
         * (i.e. has more than 1 unread message, or has
         * a "manually unread" mark)
         */
        get isUnread() {
          return this.raw.unreadMark || this.raw.unreadCount > 1;
        }
        /**
         * Whether this dialog is muted.
         *
         * If `null`, the default account-level setting should be used.
         */
        get isMuted() {
          var _a3;
          return (_a3 = this.raw.notifySettings.silent) != null ? _a3 : null;
        }
        /**
         * Whether this dialog is archived
         */
        get isArchived() {
          return this.raw.folderId === 1;
        }
        /**
         * Chat that this dialog represents
         */
        get chat() {
          return Chat._parseFromPeer(this.raw.peer, this._peers);
        }
        /**
         * The latest message sent in this chat (if any)
         */
        get lastMessage() {
          const cid = this.chat.id;
          if (this._messages.has(cid)) {
            return new Message(this._messages.get(cid), this._peers);
          }
          return null;
        }
        /**
         * ID of the last read outgoing message in this dialog
         */
        get lastReadOutgoing() {
          return this.raw.readOutboxMaxId;
        }
        /**
         * ID of the last read ingoing message in this dialog
         */
        get lastReadIngoing() {
          return this.raw.readInboxMaxId;
        }
        /**
         * ID of the last read message in this dialog
         */
        get lastRead() {
          return Math.max(this.raw.readOutboxMaxId, this.raw.readInboxMaxId);
        }
        /**
         * Number of unread messages
         */
        get unreadCount() {
          return this.raw.unreadCount;
        }
        /**
         * Number of unread mentions
         */
        get unreadMentionsCount() {
          return this.raw.unreadMentionsCount;
        }
        /**
         * Number of unread reactions
         */
        get unreadReactionsCount() {
          return this.raw.unreadReactionsCount;
        }
        /**
         * Draft message in this dialog
         */
        get draftMessage() {
          var _a3;
          if (((_a3 = this.raw.draft) == null ? void 0 : _a3._) === "draftMessage") {
            return new DraftMessage(this.raw.draft);
          }
          return null;
        }
        /**
         * TTL period of all messages in this dialog
         */
        get ttlPeriod() {
          var _a3;
          return (_a3 = this.raw.ttlPeriod) != null ? _a3 : null;
        }
      }
      exports("bS", Dialog);
      memoizeGetters(Dialog, ["chat", "lastMessage", "draftMessage"]);
      function _normalizePeerId(peerId) {
        if (typeof peerId === "object") {
          if (tl.tl.isAnyPeer(peerId)) {
            peerId = getMarkedPeerId(peerId);
          } else if ("inputPeer" in peerId) {
            peerId = peerId.inputPeer;
          } else {
            peerId = toInputPeer(peerId);
          }
        }
        if (typeof peerId === "object") {
          switch (peerId._) {
            case "mtcute.dummyInputPeerMinUser":
              return peerId.userId;
            case "mtcute.dummyInputPeerMinChannel":
              return toggleChannelIdMark(peerId.channelId);
            default:
              return peerId;
          }
        }
        return peerId;
      }
      function resolvePeer(client2, peerId, force = false) {
        return __async(this, null, function* () {
          var _a3;
          peerId = _normalizePeerId(peerId);
          if (typeof peerId === "object") {
            return peerId;
          }
          if (typeof peerId === "number" && !force) {
            const fromStorage = yield client2.storage.peers.getById(peerId);
            if (fromStorage)
              return fromStorage;
          }
          if (typeof peerId === "string") {
            if (peerId === "self" || peerId === "me")
              return { _: "inputPeerSelf" };
            peerId = peerId.replace(/[@+\s()]/g, "");
            let res;
            if (peerId.match(/^\d+$/)) {
              const fromStorage = yield client2.storage.peers.getByPhone(peerId);
              if (fromStorage)
                return fromStorage;
              try {
                res = yield client2.call({
                  _: "contacts.resolvePhone",
                  phone: peerId
                });
              } catch (e2) {
                if (tl.tl.RpcError.is(e2, "PHONE_NOT_OCCUPIED")) {
                  throw new MtPeerNotFoundError(`Peer with phone number ${peerId} was not found`);
                } else {
                  throw e2;
                }
              }
            } else {
              if (!force) {
                const fromStorage = yield client2.storage.peers.getByUsername(peerId);
                if (fromStorage)
                  return fromStorage;
              }
              try {
                res = yield client2.call({
                  _: "contacts.resolveUsername",
                  username: peerId
                });
              } catch (e2) {
                if (tl.tl.RpcError.is(e2, "USERNAME_NOT_OCCUPIED")) {
                  throw new MtPeerNotFoundError(`Peer with username ${peerId} was not found`);
                } else {
                  throw e2;
                }
              }
            }
            if (res.peer._ === "peerUser") {
              const id2 = res.peer.userId;
              const found = res.users.find((it) => it.id === id2);
              if (found && found._ === "user") {
                if (!found.accessHash) {
                  throw new MtPeerNotFoundError(
                    `Peer (user) with username ${peerId} was found, but it has no access hash`
                  );
                }
                return {
                  _: "inputPeerUser",
                  userId: found.id,
                  accessHash: found.accessHash
                };
              }
            } else if (res.peer._ === "peerChannel") {
              const id2 = res.peer.channelId;
              const found = res.chats.find((it) => it.id === id2);
              if (found) {
                if (!(found._ === "channel" || found._ === "channelForbidden")) {
                  throw new MtTypeAssertionError("contacts.resolveUsername#chats", "channel", found._);
                }
                if (!found.accessHash) {
                  throw new MtPeerNotFoundError(`Peer (channel) with ${peerId} was found, but it has no access hash`);
                }
                return {
                  _: "inputPeerChannel",
                  channelId: found.id,
                  accessHash: found.accessHash
                };
              }
            } else {
              throw new MtTypeAssertionError("contacts.resolveUsername", "user or channel", res.peer._);
            }
            throw new MtPeerNotFoundError(`Could not find a peer by ${peerId}`);
          }
          const [peerType, bareId] = parseMarkedPeerId(peerId);
          if (!(peerType === "chat" || ((_a3 = client2.storage.self.getCached(true)) == null ? void 0 : _a3.isBot))) {
            const cached2 = yield client2.storage.peers.getCompleteById(peerId, true);
            if (cached2 && (cached2._ === "channel" || cached2._ === "user")) {
              const [username2] = extractUsernames(cached2);
              if (username2) {
                const resolved = yield resolvePeer(client2, username2, true);
                if (getMarkedPeerId(resolved) === peerId) {
                  return resolved;
                }
              }
              if (cached2._ === "user" && cached2.phone) {
                const resolved = yield resolvePeer(client2, cached2.phone, true);
                if (getMarkedPeerId(resolved) === peerId) {
                  return resolved;
                }
              }
            }
            throw new MtPeerNotFoundError(`Peer ${peerId} is not found in local cache`);
          }
          switch (peerType) {
            case "user":
              return {
                _: "inputPeerUser",
                userId: bareId,
                accessHash: Long.ZERO
              };
            case "chat":
              return {
                _: "inputPeerChat",
                chatId: bareId
              };
            case "channel":
              return {
                _: "inputPeerChannel",
                channelId: bareId,
                accessHash: Long.ZERO
              };
          }
        });
      }
      function resolveUser(client2, peerId, force = false) {
        return __async(this, null, function* () {
          return toInputUser(yield resolvePeer(client2, peerId, force), peerId);
        });
      }
      function resolveChannel(client2, peerId, force = false) {
        return __async(this, null, function* () {
          return toInputChannel(yield resolvePeer(client2, peerId, force), peerId);
        });
      }
      function resolvePeerMany(client2, peerIds, normalizer) {
        return __async(this, null, function* () {
          const ret = [];
          const limit = 8;
          if (peerIds.length < limit) {
            const res = yield Promise.all(
              peerIds.map(
                (it) => resolvePeer(client2, it).catch((e2) => {
                  if (e2 instanceof MtPeerNotFoundError) {
                    return null;
                  }
                  throw e2;
                })
              )
            );
            if (!normalizer)
              return res;
            for(let   value of res) {
              if (!value)
                continue;
              const norm = normalizer(value);
              if (norm) {
                ret.push(norm);
              }
            }
            return ret;
          }
          const cv = new ConditionVariable();
          const buffer = {};
          let nextIdx = 0;
          let nextWorkerIdx = 0;
          const fetchNext = (..._0) => __async(this, [..._0], function* (idx = nextWorkerIdx++) {
            try {
              const result = yield resolvePeer(client2, peerIds[idx]);
              buffer[idx] = result;
            } catch (e2) {
              if (e2 instanceof MtPeerNotFoundError) {
                buffer[idx] = null;
              } else {
                throw e2;
              }
            }
            if (nextIdx === idx) {
              cv.notify();
            }
            if (nextWorkerIdx < peerIds.length) {
              yield fetchNext(nextWorkerIdx++);
            }
          });
          let error;
          void Promise.all(Array.from({ length: limit }, (_, i) => fetchNext(i))).catch((e2) => {
            client2.log.debug("resolvePeerMany errored: %e", e2);
            error = e2;
            cv.notify();
          });
          while (nextIdx < peerIds.length) {
            yield cv.wait();
            if (error)
              throw error;
            while (nextIdx in buffer) {
              const buf = buffer[nextIdx];
              delete buffer[nextIdx];
              nextIdx++;
              if (!normalizer) {
                ret.push(buf);
                continue;
              }
              if (buf !== null) {
                const norm = normalizer(buf);
                if (norm) {
                  ret.push(norm);
                }
              }
            }
          }
          return ret;
        });
      }
      function getPeerDialogs(client2, peers) {
        return __async(this, null, function* () {
          if (!Array.isArray(peers))
            peers = [peers];
          const res = yield client2.call({
            _: "messages.getPeerDialogs",
            peers: yield resolvePeerMany(client2, peers).then(
              (peers2) => peers2.filter(isPresent).map((it) => ({
                _: "inputDialogPeer",
                peer: it
              }))
            )
          });
          return Dialog.parseTlDialogs(res);
        });
      }
      function readHistory$1(client2, chatId, params) {
        return __async(this, null, function* () {
          const { maxId = 0, clearMentions, shouldDispatch } = params != null ? params : {};
          const peer = yield resolvePeer(client2, chatId);
          if (clearMentions) {
            const res = yield client2.call({
              _: "messages.readMentions",
              peer
            });
            if (!shouldDispatch) {
              if (isInputPeerChannel(peer)) {
                client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, peer.channelId));
              } else {
                client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
              }
            }
          }
          if (isInputPeerChannel(peer)) {
            const r2 = yield client2.call({
              _: "channels.readHistory",
              channel: toInputChannel(peer),
              maxId
            });
            assertTrue("channels.readHistory", r2);
          } else {
            const res = yield client2.call({
              _: "messages.readHistory",
              peer,
              maxId
            });
            if (!shouldDispatch) {
              client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
            }
          }
        });
      }
      function inputTextToTl(text2) {
        var _a3;
        return {
          _: "textWithEntities",
          text: typeof text2 === "string" ? text2 : text2.text,
          entities: typeof text2 === "string" ? [] : (_a3 = text2.entities) != null ? _a3 : []
        };
      }
      const FileType = typesInner.FileType;
      const EMPTY_BUFFER = new Uint8Array(0);
      function dialogPhotoToInputPeer(dialog2) {
        const markedPeerId = dialog2.id;
        const [peerType, peerId] = parseMarkedPeerId(markedPeerId);
        if (peerType === "user") {
          return {
            _: "inputPeerUser",
            userId: peerId,
            accessHash: dialog2.accessHash
          };
        } else if (peerType === "chat") {
          return {
            _: "inputPeerChat",
            chatId: peerId
          };
        }
        return {
          _: "inputPeerChannel",
          channelId: peerId,
          accessHash: dialog2.accessHash
        };
      }
      function fileIdToInputWebFileLocation(fileId) {
        if (typeof fileId === "string")
          fileId = parseFileId(getPlatform(), fileId);
        if (fileId.location._ !== "web") {
          throw new typesInner.ConversionError("inputWebFileLocation");
        }
        return {
          _: "inputWebFileLocation",
          url: fileId.location.url,
          accessHash: fileId.location.accessHash
        };
      }
      function fileIdToInputFileLocation(fileId) {
        if (typeof fileId === "string")
          fileId = parseFileId(getPlatform(), fileId);
        const loc = fileId.location;
        switch (loc._) {
          case "web":
            throw new typesInner.ConversionError("InputFileLocation");
          case "photo": {
            switch (loc.source._) {
              case "legacy":
                if (!fileId.fileReference) {
                  throw new typesInner.InvalidFileIdError("Expected legacy photo to have file reference");
                }
                return {
                  _: "inputPhotoLegacyFileLocation",
                  fileReference: fileId.fileReference,
                  id: loc.id,
                  accessHash: loc.accessHash,
                  volumeId: Long.ZERO,
                  localId: 0,
                  secret: loc.source.secret
                };
              case "thumbnail":
                if (!fileId.fileReference) {
                  throw new typesInner.InvalidFileIdError("Expected thumbnail photo to have file reference");
                }
                if (loc.source.fileType !== FileType.Photo && loc.source.fileType !== FileType.Thumbnail) {
                  throw new typesInner.InvalidFileIdError("Expected a thumbnail to have a correct file type");
                }
                return {
                  _: loc.source.fileType === FileType.Photo ? "inputPhotoFileLocation" : "inputDocumentFileLocation",
                  fileReference: fileId.fileReference,
                  id: loc.id,
                  accessHash: loc.accessHash,
                  thumbSize: loc.source.thumbnailType
                };
              case "dialogPhoto":
                return {
                  _: "inputPeerPhotoFileLocation",
                  big: loc.source.big,
                  peer: dialogPhotoToInputPeer(loc.source),
                  photoId: loc.id
                };
              case "stickerSetThumbnail":
                return {
                  _: "inputStickerSetThumb",
                  stickerset: {
                    _: "inputStickerSetID",
                    id: loc.source.id,
                    accessHash: loc.source.accessHash
                  },
                  thumbVersion: 0
                };
              case "fullLegacy":
                if (!fileId.fileReference) {
                  throw new typesInner.InvalidFileIdError("Expected legacy photo to have file reference");
                }
                return {
                  _: "inputPhotoLegacyFileLocation",
                  fileReference: fileId.fileReference,
                  id: loc.id,
                  accessHash: loc.accessHash,
                  volumeId: loc.source.volumeId,
                  localId: loc.source.localId,
                  secret: loc.source.secret
                };
              case "dialogPhotoLegacy":
                return {
                  _: "inputPeerPhotoFileLocationLegacy",
                  big: loc.source.big,
                  peer: dialogPhotoToInputPeer(loc.source),
                  volumeId: loc.source.volumeId,
                  localId: loc.source.localId
                };
              case "stickerSetThumbnailLegacy":
                return {
                  _: "inputStickerSetThumbLegacy",
                  stickerset: {
                    _: "inputStickerSetID",
                    id: loc.source.id,
                    accessHash: loc.source.accessHash
                  },
                  volumeId: loc.source.volumeId,
                  localId: loc.source.localId
                };
              case "stickerSetThumbnailVersion":
                return {
                  _: "inputStickerSetThumb",
                  stickerset: {
                    _: "inputStickerSetID",
                    id: loc.source.id,
                    accessHash: loc.source.accessHash
                  },
                  thumbVersion: loc.source.version
                };
              default:
                assertNever$1(loc.source);
            }
            throw new typesInner.ConversionError("inputFileLocation");
          }
          case "common": {
            if (!fileId.fileReference) {
              throw new typesInner.InvalidFileIdError("Expected common to have file reference");
            }
            if (fileId.type === FileType.Encrypted) {
              return {
                _: "inputEncryptedFileLocation",
                id: loc.id,
                accessHash: loc.accessHash
              };
            } else if (fileId.type === FileType.Secure || fileId.type === FileType.SecureRaw) {
              return {
                _: "inputSecureFileLocation",
                id: loc.id,
                accessHash: loc.accessHash
              };
            }
            return {
              _: "inputDocumentFileLocation",
              fileReference: fileId.fileReference,
              id: loc.id,
              accessHash: loc.accessHash,
              thumbSize: ""
            };
          }
          default:
            assertNever$1();
        }
      }
      function fileIdToInputDocument(fileId) {
        if (typeof fileId === "string")
          fileId = parseFileId(getPlatform(), fileId);
        if (fileId.location._ !== "common" || fileId.type === FileType.Secure || fileId.type === FileType.SecureRaw || fileId.type === FileType.Encrypted) {
          throw new typesInner.ConversionError("inputDocument");
        }
        let fileRef = fileId.fileReference;
        if (!fileRef) {
          if (fileId.type === FileType.Sticker) {
            fileRef = EMPTY_BUFFER;
          } else {
            throw new typesInner.InvalidFileIdError("Expected document to have file reference");
          }
        }
        return {
          _: "inputDocument",
          fileReference: fileRef,
          id: fileId.location.id,
          accessHash: fileId.location.accessHash
        };
      }
      function fileIdToInputPhoto(fileId) {
        if (typeof fileId === "string")
          fileId = parseFileId(getPlatform(), fileId);
        if (fileId.location._ !== "photo") {
          throw new typesInner.ConversionError("inputPhoto");
        }
        if (!fileId.fileReference) {
          throw new typesInner.InvalidFileIdError("Expected photo to have file reference");
        }
        return {
          _: "inputPhoto",
          fileReference: fileId.fileReference,
          id: fileId.location.id,
          accessHash: fileId.location.accessHash
        };
      }
      const empty = ["", void 0];
      function _normalizeInputText(client2, input) {
        return __async(this, null, function* () {
          if (!input) {
            return empty;
          }
          if (typeof input === "string") {
            return [input, void 0];
          }
          const { text: text2, entities } = input;
          if (!entities)
            return [text2, void 0];
          for(let   ent of entities) {
            if (ent._ === "messageEntityMentionName") {
              try {
                const inputPeer = yield resolveUser(client2, ent.userId);
                const ent_ = ent;
                ent_._ = "inputMessageEntityMentionName";
                ent_.userId = inputPeer;
              } catch (e2) {
                client2.log.warn("Failed to resolve mention entity for %s: %s", ent.userId, e2);
              }
            }
          }
          return [text2, entities];
        });
      }
      function guessFileMime(chunk) {
        if (chunk.length < 12)
          return null;
        const b0 = chunk[0];
        const b1 = chunk[1];
        if (b0 === 66 && b1 === 77)
          return "image/bmp";
        if (b0 === 77 && b1 === 90)
          return "application/x-msdownload";
        if (b0 === 31 && (b1 === 157 || b1 === 160))
          return "application/x-compress";
        if (b0 === 31 && b1 === 139)
          return "application/gzip";
        const b2 = chunk[2];
        if (b0 === 66 && b1 === 90 && b2 === 104)
          return "application/x-bzip2";
        if (b0 === 73 && b1 === 68 && b2 === 51)
          return "audio/mpeg";
        if (b0 === 255 && (b1 === 251 || b1 === 243 || b1 === 242))
          return "audio/mpeg";
        const b3 = chunk[3];
        if (b0 === 80 && b1 === 75 && b2 === 3 && b3 === 4)
          return "application/zip";
        if (b0 === 56 && b1 === 66 && b2 === 80 && b3 === 83)
          return "image/vnd.adobe.photoshop";
        if (b0 === 127 && b1 === 69 && b2 === 76 && b3 === 70)
          return "application/x-elf";
        if (b0 === 254 && b1 === 237 && b2 === 250 && b3 === 207)
          return "application/x-mach-binary";
        if (b0 === 40 && b1 === 181 && b2 === 47 && b3 === 253)
          return "application/zstd";
        if (b0 === 102 && b1 === 76 && b2 === 97 && b3 === 67)
          return "audio/x-flac";
        if (b0 === 255 && b1 === 216 && b2 === 255 && (b3 === 219 || b3 === 224 || b3 === 238 || b3 === 225)) {
          return "image/jpeg";
        }
        if (b0 === 79 && b1 === 103 && b2 === 103 && b3 === 83) {
          if (chunk.length > 36) {
            const type = String.fromCharCode(...chunk.subarray(28, 36));
            if (type === "OpusHead")
              return "audio/ogg";
            if (type.startsWith("theora"))
              return "video/ogg";
            if (type.startsWith("video"))
              return "video/ogg";
            if (type.startsWith("FLAC"))
              return "audio/ogg";
            if (type.startsWith("Speex  "))
              return "audio/ogg";
            if (type.startsWith("vorbis"))
              return "audio/ogg";
          }
          return "application/ogg";
        }
        const b4 = chunk[4];
        if (b0 === 37 && b1 === 80 && b2 === 68 && b3 === 70 && b4 === 45)
          return "application/pdf";
        const b5 = chunk[5];
        if (b0 === 71 && b1 === 73 && b2 === 70 && b3 === 56) {
          if ((b4 === 55 || b4 === 57) && b5 === 97)
            return "image/gif";
        }
        if (b0 === 55 && b1 === 122 && b2 === 188 && b3 === 175 && b4 === 39 && b5 === 28) {
          return "application/x-7z-compressed";
        }
        const b6 = chunk[6];
        const b7 = chunk[7];
        if (b0 === 137 && b1 === 80 && b2 === 78 && b3 === 71 && b4 === 13 && b5 === 10 && b6 === 26 && b7 === 10) {
          return "image/png";
        }
        if (b0 === 82 && b1 === 97 && b2 === 114 && b3 === 33 && b4 === 26 && b5 === 7) {
          if (b6 === 0 || b6 === 1)
            return "application/x-rar-compressed";
        }
        if (b4 === 102 && b5 === 116 && b6 === 121 && b7 === 112 && chunk[8] & 96) {
          const brandMajor = String.fromCharCode(...chunk.subarray(8, 12)).replace(/\0/g, " ").trim();
          switch (brandMajor) {
            case "avif":
            case "avis":
              return "image/avif";
            case "mif1":
              return "image/heif";
            case "msf1":
              return "image/heif-sequence";
            case "heic":
            case "heix":
              return "image/heic";
            case "hevc":
            case "hevx":
              return "image/heic-sequence";
            case "qt":
              return "video/quicktime";
            case "M4V":
            case "M4VH":
            case "M4VP":
              return "video/x-m4v";
            case "M4A":
              return "audio/x-m4a";
            case "M4B":
            case "F4A":
            case "F4B":
              return "audio/mp4";
            case "crx":
              return "image/x-canon-cr3";
            default:
              if (brandMajor.startsWith("3g")) {
                if (brandMajor.startsWith("3g2")) {
                  return "video/3gpp2";
                }
                return "video/3gpp";
              }
              return "video/mp4";
          }
        }
        return null;
      }
      const MIME_TO_EXTENSION = {
        "image/bmp": "bmp",
        "application/x-msdownload": "exe",
        "application/x-compress": "z",
        "application/gzip": "gz",
        "application/x-bzip2": "bz2",
        "audio/mpeg": "mp3",
        "application/zip": "zip",
        "image/vnd.adobe.photoshop": "psd",
        "application/zstd": "zst",
        "audio/x-flac": "flac",
        "image/jpeg": "jpg",
        "audio/ogg": "ogg",
        "video/ogg": "ogv",
        "application/ogg": "ogg",
        "application/pdf": "pdf",
        "image/gif": "gif",
        "application/x-7z-compressed": "7z",
        "image/png": "png",
        "application/x-rar-compressed": "rar",
        "image/avif": "avif",
        "image/heif": "heif",
        "image/heif-sequence": "heif",
        "image/heic": "heic",
        "image/heic-sequence": "heic",
        "video/quicktime": "mov",
        "video/x-m4v": "m4v",
        "audio/x-m4a": "m4a",
        "audio/mp4": "m4a",
        "image/x-canon-cr3": "cr3",
        "video/3gpp2": "3g2",
        "video/3gpp": "3gp",
        "video/mp4": "mp4"
      };
      const OVERRIDE_MIME = {
        // tg doesn't interpret `audio/opus` files as voice messages for some reason
        "audio/opus": "audio/ogg"
      };
      const SMALL_FILE_MAX_SIZE$1 = 131072;
      const BIG_FILE_MIN_SIZE = 10485760;
      const DEFAULT_FILE_NAME = "unnamed";
      const REQUESTS_PER_CONNECTION$1 = 3;
      const MAX_PART_COUNT = 4e3;
      const MAX_PART_COUNT_PREMIUM = 8e3;
      const HAS_FILE = typeof File !== "undefined";
      const HAS_RESPONSE = typeof Response !== "undefined";
      const HAS_URL = typeof URL !== "undefined";
      const HAS_BLOB = typeof Blob !== "undefined";
      function uploadFile(client2, params) {
        return __async(this, null, function* () {
          var _a3, _b2, _c;
          let file2 = params.file;
          let fileSize = -1;
          let fileName = params.fileName;
          let fileMime = params.fileMime;
          const platform2 = getPlatform();
          if (platform2.normalizeFile) {
            const res = yield platform2.normalizeFile(file2);
            if (res == null ? void 0 : res.file) {
              file2 = res.file;
              if (res.fileSize)
                fileSize = res.fileSize;
              if (res.fileName)
                fileName = res.fileName;
            }
          }
          if (ArrayBuffer.isView(file2)) {
            fileSize = file2.length;
            file2 = bufferToStream(file2);
          }
          if (HAS_FILE && file2 instanceof File) {
            fileName = file2.name;
            fileSize = file2.size;
            fileMime = file2.type;
            file2 = file2.stream();
          }
          if (HAS_URL && file2 instanceof URL) {
            file2 = yield fetch(file2);
          }
          if (HAS_BLOB && file2 instanceof Blob) {
            fileSize = file2.size;
            file2 = file2.stream();
          }
          if (HAS_RESPONSE && file2 instanceof Response) {
            const length = Number.parseInt(file2.headers.get("content-length") || "0");
            if (!Number.isNaN(length) && length)
              fileSize = length;
            fileMime = (_a3 = file2.headers.get("content-type")) == null ? void 0 : _a3.split(";")[0];
            const disposition = file2.headers.get("content-disposition");
            if (disposition) {
              const idx2 = disposition.indexOf("filename=");
              if (idx2 > -1) {
                const raw = disposition.slice(idx2 + 9).split(";")[0];
                fileName = JSON.parse(raw);
              }
            }
            if (fileName === DEFAULT_FILE_NAME) {
              const url2 = new URL(file2.url);
              const name2 = url2.pathname.split("/").pop();
              if (name2 && name2.includes(".")) {
                fileName = name2;
              }
            }
            if (!file2.body) {
              throw new MtArgumentError("Fetch response contains `null` body");
            }
            file2 = file2.body;
          }
          if (!(file2 instanceof ReadableStream)) {
            throw new MtArgumentError("Could not convert input `file` to stream!");
          }
          if (fileSize === -1 && params.fileSize)
            fileSize = params.fileSize;
          if (fileSize === -1 && params.requireFileSize) {
            const buffer = yield streamToBuffer(file2);
            fileSize = buffer.length;
            file2 = bufferToStream(buffer);
          }
          let partSizeKb = params.partSize;
          if (!partSizeKb) {
            if (fileSize === -1) {
              partSizeKb = params.estimatedSize ? determinePartSize(params.estimatedSize) : 64;
            } else {
              partSizeKb = determinePartSize(fileSize);
            }
          }
          if (partSizeKb > 512) {
            throw new MtArgumentError(`Invalid part size: ${partSizeKb}KB`);
          }
          const partSize = partSizeKb * 1024;
          let partCount = fileSize === -1 ? -1 : ~~((fileSize + partSize - 1) / partSize);
          const maxPartCount = ((_b2 = client2.storage.self.getCached()) == null ? void 0 : _b2.isPremium) ? MAX_PART_COUNT_PREMIUM : MAX_PART_COUNT;
          if (partCount > maxPartCount) {
            throw new MtArgumentError(`File is too large (max ${maxPartCount} parts, got ${partCount})`);
          }
          const isBig = fileSize === -1 || fileSize > BIG_FILE_MIN_SIZE;
          const isSmall = fileSize !== -1 && fileSize < SMALL_FILE_MAX_SIZE$1;
          const connectionKind = isSmall ? "main" : "upload";
          const connectionPoolSize = Math.min(yield client2.getPoolSize(connectionKind), partCount);
          const requestsPerConnection = (_c = params.requestsPerConnection) != null ? _c : REQUESTS_PER_CONNECTION$1;
          client2.log.debug(
            "uploading %d bytes file in %d chunks, each %d bytes in %s connection pool of size %d",
            fileSize,
            partCount,
            partSize,
            connectionKind,
            connectionPoolSize
          );
          const fileId = randomLong();
          const stream = file2;
          let pos = 0;
          let idx = 0;
          const reader2 = createChunkedReader(stream, partSize);
          const uploadNextPart = () => __async(this, null, function* () {
            var _a4, _b3;
            const thisIdx = idx++;
            let part = yield reader2.read();
            if (!part && fileSize !== -1) {
              throw new MtArgumentError(`Unexpected EOS (there were only ${idx - 1} parts, but expected ${partCount})`);
            }
            if (fileSize === -1 && (reader2.ended() || !part)) {
              fileSize = pos + ((_a4 = part == null ? void 0 : part.length) != null ? _a4 : 0);
              partCount = ~~((fileSize + partSize - 1) / partSize);
              if (!part)
                part = new Uint8Array(0);
              client2.log.debug("readable ended, file size = %d, part count = %d", fileSize, partCount);
            }
            if (!ArrayBuffer.isView(part)) {
              throw new MtArgumentError(`Part ${thisIdx} was not a Uint8Array!`);
            }
            if (part.length > partSize) {
              throw new MtArgumentError(`Part ${thisIdx} had invalid size (expected ${partSize}, got ${part.length})`);
            }
            if (thisIdx === 0 && fileMime === void 0) {
              const mime = guessFileMime(part);
              if (mime) {
                fileMime = mime;
              } else {
                const isPlainText = isProbablyPlainText(part.slice(0, 8));
                fileMime = isPlainText ? "text/plain" : "application/octet-stream";
              }
            }
            const request = isBig ? {
              _: "upload.saveBigFilePart",
              fileId,
              filePart: thisIdx,
              fileTotalParts: partCount,
              bytes: part
            } : {
              _: "upload.saveFilePart",
              fileId,
              filePart: thisIdx,
              bytes: part
            };
            const result = yield client2.call(request, { kind: connectionKind });
            if (!result)
              throw new Error(`Failed to upload part ${idx}`);
            pos += part.length;
            (_b3 = params.progressCallback) == null ? void 0 : _b3.call(params, pos, fileSize);
            if (idx === partCount)
              return;
            return uploadNextPart();
          });
          let poolSize = partCount === -1 ? 1 : connectionPoolSize * requestsPerConnection;
          if (partCount !== -1 && poolSize > partCount)
            poolSize = partCount;
          yield Promise.all(Array.from({ length: poolSize }, uploadNextPart));
          if (fileName === void 0) {
            const ext = MIME_TO_EXTENSION[fileMime];
            fileName = ext ? `${DEFAULT_FILE_NAME}.${ext}` : DEFAULT_FILE_NAME;
          } else if (params.requireExtension) {
            const extFromMime = MIME_TO_EXTENSION[fileMime];
            const idx2 = fileName.lastIndexOf(".");
            const extFromName = idx2 === -1 ? void 0 : fileName.slice(idx2 + 1);
            if (!extFromName) {
              if (!extFromMime) {
                throw new MtArgumentError(`File name does not have an extension, and we cannot guess it from the mime type (${fileMime})`);
              }
              fileName = `${fileName}.${extFromMime}`;
            } else if (extFromMime && extFromName !== extFromMime) {
              throw new MtArgumentError(`File name has ${extFromName} extension (${fileName}), but the mime type (${fileMime}) expects it to be ${extFromMime}`);
            }
          }
          let inputFile;
          if (isBig) {
            inputFile = {
              _: "inputFileBig",
              id: fileId,
              parts: partCount,
              name: fileName
            };
          } else {
            inputFile = {
              _: "inputFile",
              id: fileId,
              parts: partCount,
              name: fileName,
              md5Checksum: ""
              // tdlib doesn't do this, why should we?
            };
          }
          if (fileMime in OVERRIDE_MIME)
            fileMime = OVERRIDE_MIME[fileMime];
          return {
            inputFile,
            size: fileSize,
            mime: fileMime
          };
        });
      }
      function _normalizeInputFile(client2, input, params) {
        return __async(this, null, function* () {
          if (typeof input === "object" && tl.tl.isAnyInputMedia(input)) {
            throw new MtArgumentError("InputFile can't be created from an InputMedia");
          } else if (typesInner.isFileIdLike(input)) {
            if (typeof input === "string" && input.match(/^file:/)) {
              const uploaded = yield uploadFile(client2, __spreadValues({
                file: input.substring(5)
              }, params));
              return uploaded.inputFile;
            }
            throw new MtArgumentError("InputFile can't be created from an URL or a File ID");
          } else if (isUploadedFile(input)) {
            return input.inputFile;
          } else if (typeof input === "object" && tl.tl.isAnyInputFile(input)) {
            return input;
          } else {
            const uploaded = yield uploadFile(client2, __spreadValues({
              file: input
            }, params));
            return uploaded.inputFile;
          }
        });
      }
      function _normalizeInputMedia(_0, _1) {
        return __async(this, arguments, function* (client2, media2, params = {}, uploadMedia2 = false) {
          var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
          if (tl.tl.isAnyInputMedia(media2)) {
            switch (media2._) {
              case "inputMediaStory":
                return __spreadProps(__spreadValues({}, media2), {
                  peer: yield resolvePeer(client2, media2.peer)
                });
            }
            return media2;
          }
          if (media2.type === "venue") {
            return {
              _: "inputMediaVenue",
              geoPoint: {
                _: "inputGeoPoint",
                lat: media2.latitude,
                long: media2.longitude
              },
              title: media2.title,
              address: media2.address,
              provider: (_b2 = (_a3 = media2.source) == null ? void 0 : _a3.provider) != null ? _b2 : "",
              venueId: (_d = (_c = media2.source) == null ? void 0 : _c.id) != null ? _d : "",
              venueType: (_f = (_e = media2.source) == null ? void 0 : _e.type) != null ? _f : ""
            };
          }
          if (media2.type === "geo") {
            return {
              _: "inputMediaGeoPoint",
              geoPoint: {
                _: "inputGeoPoint",
                lat: media2.latitude,
                long: media2.longitude
              }
            };
          }
          if (media2.type === "geo_live") {
            return {
              _: "inputMediaGeoLive",
              geoPoint: {
                _: "inputGeoPoint",
                lat: media2.latitude,
                long: media2.longitude
              },
              stopped: media2.stopped,
              heading: media2.heading,
              period: media2.period,
              proximityNotificationRadius: media2.proximityNotificationRadius
            };
          }
          if (media2.type === "dice") {
            return {
              _: "inputMediaDice",
              emoticon: media2.emoji
            };
          }
          if (media2.type === "contact") {
            return {
              _: "inputMediaContact",
              phoneNumber: media2.phone,
              firstName: media2.firstName,
              lastName: (_g = media2.lastName) != null ? _g : "",
              vcard: (_h = media2.vcard) != null ? _h : ""
            };
          }
          if (media2.type === "game") {
            return {
              _: "inputMediaGame",
              id: typeof media2.game === "string" ? {
                _: "inputGameShortName",
                botId: { _: "inputUserSelf" },
                shortName: media2.game
              } : media2.game
            };
          }
          if (media2.type === "invoice") {
            return {
              _: "inputMediaInvoice",
              title: media2.title,
              description: media2.description,
              photo: typeof media2.photo === "string" ? {
                _: "inputWebDocument",
                url: media2.photo,
                mimeType: "image/jpeg",
                size: 0,
                attributes: []
              } : media2.photo,
              invoice: media2.invoice,
              payload: media2.payload,
              provider: media2.token,
              providerData: {
                _: "dataJSON",
                data: JSON.stringify(media2.providerData)
              },
              startParam: media2.startParam,
              extendedMedia: media2.extendedMedia ? yield _normalizeInputMedia(client2, media2.extendedMedia, params) : void 0
            };
          }
          if (media2.type === "poll" || media2.type === "quiz") {
            const answers = media2.answers.map((ans, idx) => {
              if (typeof ans === "object" && tl.tl.isAnyPollAnswer(ans))
                return ans;
              return {
                _: "pollAnswer",
                text: inputTextToTl(ans),
                // emulate the behaviour of most implementations
                option: new Uint8Array([48 + idx])
              };
            });
            let correct;
            let solution;
            let solutionEntities;
            if (media2.type === "quiz") {
              let input2 = media2.correct;
              if (!Array.isArray(input2))
                input2 = [input2];
              correct = input2.map((it) => {
                if (typeof it === "number") {
                  return answers[it].option;
                }
                return it;
              });
              if (media2.solution) {
                [solution, solutionEntities] = yield _normalizeInputText(client2, media2.solution);
              }
            }
            return {
              _: "inputMediaPoll",
              poll: {
                _: "poll",
                closed: media2.closed,
                id: Long.ZERO,
                publicVoters: media2.public,
                multipleChoice: media2.multiple,
                quiz: media2.type === "quiz",
                question: inputTextToTl(media2.question),
                answers,
                closePeriod: media2.closePeriod,
                closeDate: normalizeDate(media2.closeDate)
              },
              correctAnswers: correct,
              solution,
              solutionEntities
            };
          }
          if (media2.type === "story") {
            return {
              _: "inputMediaStory",
              peer: yield resolvePeer(client2, media2.peer),
              id: media2.id
            };
          }
          if (media2.type === "webpage") {
            return {
              _: "inputMediaWebPage",
              forceLargeMedia: media2.size === "large",
              forceSmallMedia: media2.size === "small",
              optional: !media2.required,
              url: media2.url
            };
          }
          if (media2.type === "paid") {
            let medias;
            if (Array.isArray(media2.media)) {
              medias = yield Promise.all(media2.media.map((m2) => _normalizeInputMedia(client2, m2, params)));
            } else {
              medias = [yield _normalizeInputMedia(client2, media2.media, params)];
            }
            return {
              _: "inputMediaPaidMedia",
              starsAmount: Long.isLong(media2.starsAmount) ? media2.starsAmount : Long.fromNumber(media2.starsAmount),
              extendedMedia: medias,
              payload: media2.payload
            };
          }
          let inputFile;
          let thumb2;
          let mime = "application/octet-stream";
          const upload = (file2) => __async(this, null, function* () {
            let sendMime;
            if (media2.type === "sticker") {
              sendMime = media2.isAnimated ? "application/x-tgsticker" : "image/webp";
            } else {
              sendMime = media2.fileMime;
            }
            const uploaded = yield uploadFile(client2, {
              file: file2,
              progressCallback: params.progressCallback,
              fileName: media2.fileName,
              fileMime: sendMime,
              fileSize: media2.fileSize,
              requireFileSize: media2.type === "photo",
              requireExtension: media2.type === "photo"
            });
            inputFile = uploaded.inputFile;
            mime = uploaded.mime;
          });
          const uploadPeer = (_i = params.uploadPeer) != null ? _i : { _: "inputPeerSelf" };
          const uploadMediaIfNeeded = (inputMedia, photo2) => __async(this, null, function* () {
            if (!uploadMedia2)
              return inputMedia;
            const res = yield client2.call({
              _: "messages.uploadMedia",
              peer: uploadPeer,
              media: inputMedia,
              businessConnectionId: params.businessConnectionId
            });
            if (photo2) {
              assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res, "messageMediaPhoto");
              assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res.photo, "photo");
              return {
                _: "inputMediaPhoto",
                id: {
                  _: "inputPhoto",
                  id: res.photo.id,
                  accessHash: res.photo.accessHash,
                  fileReference: res.photo.fileReference
                },
                ttlSeconds: media2.ttlSeconds,
                spoiler: media2.type === "video" && media2.spoiler
              };
            }
            assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res, "messageMediaDocument");
            assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res.document, "document");
            return {
              _: "inputMediaDocument",
              id: {
                _: "inputDocument",
                id: res.document.id,
                accessHash: res.document.accessHash,
                fileReference: res.document.fileReference
              },
              ttlSeconds: media2.ttlSeconds,
              spoiler: media2.type === "video" && media2.spoiler
            };
          });
          const input = media2.file;
          if (typesInner.isFileIdLike(input)) {
            if (typeof input === "string" && input.match(/^https?:\/\//)) {
              return uploadMediaIfNeeded(
                {
                  _: media2.type === "photo" ? "inputMediaPhotoExternal" : "inputMediaDocumentExternal",
                  url: input
                },
                media2.type === "photo"
              );
            } else if (typeof input === "string" && input.match(/^file:/)) {
              yield upload(input.substring(5));
            } else {
              const parsed = typeof input === "string" ? parseFileId(getPlatform(), input) : input;
              if (parsed.location._ === "photo") {
                return {
                  _: "inputMediaPhoto",
                  id: fileIdToInputPhoto(parsed)
                };
              } else if (parsed.location._ === "web") {
                return uploadMediaIfNeeded(
                  {
                    _: parsed.type === typesInner.FileType.Photo ? "inputMediaPhotoExternal" : "inputMediaDocumentExternal",
                    url: parsed.location.url
                  },
                  parsed.type === typesInner.FileType.Photo
                );
              }
              return {
                _: "inputMediaDocument",
                id: fileIdToInputDocument(parsed)
              };
            }
          } else if (typeof input === "object" && tl.tl.isAnyInputMedia(input)) {
            return input;
          } else if (isUploadedFile(input)) {
            inputFile = input.inputFile;
            mime = input.mime;
          } else if (typeof input === "object" && tl.tl.isAnyInputFile(input)) {
            inputFile = input;
          } else {
            yield upload(input);
          }
          if (!inputFile)
            throw new Error("should not happen");
          if (media2.type === "photo") {
            return uploadMediaIfNeeded(
              {
                _: "inputMediaUploadedPhoto",
                file: inputFile,
                ttlSeconds: media2.ttlSeconds,
                spoiler: media2.spoiler
              },
              true
            );
          }
          if ("thumb" in media2 && media2.thumb) {
            thumb2 = yield _normalizeInputFile(client2, media2.thumb, {});
          }
          const attributes = [];
          if (media2.type !== "voice") {
            attributes.push({
              _: "documentAttributeFilename",
              fileName: media2.fileName || (inputFile._ === "inputFileStoryDocument" ? "story" : inputFile.name)
            });
          }
          if (media2.type === "video") {
            attributes.push({
              _: "documentAttributeVideo",
              duration: media2.duration || 0,
              w: media2.width || 0,
              h: media2.height || 0,
              supportsStreaming: media2.supportsStreaming,
              roundMessage: media2.isRound
            });
            if (media2.isAnimated) {
              attributes.push({ _: "documentAttributeAnimated" });
            }
          }
          if (media2.type === "audio" || media2.type === "voice") {
            attributes.push({
              _: "documentAttributeAudio",
              voice: media2.type === "voice",
              duration: media2.duration || 0,
              title: media2.type === "audio" ? media2.title : void 0,
              performer: media2.type === "audio" ? media2.performer : void 0,
              waveform: media2.type === "voice" && media2.waveform ? encodeWaveform(media2.waveform) : void 0
            });
          }
          if (media2.type === "sticker") {
            attributes.push({
              _: "documentAttributeSticker",
              stickerset: {
                _: "inputStickerSetEmpty"
              },
              alt: (_j = media2.alt) != null ? _j : ""
            });
          }
          return uploadMediaIfNeeded(
            {
              _: "inputMediaUploadedDocument",
              nosoundVideo: media2.type === "video" && media2.isAnimated,
              forceFile: media2.type === "document",
              file: inputFile,
              thumb: thumb2,
              mimeType: mime,
              attributes,
              ttlSeconds: media2.ttlSeconds,
              spoiler: media2.type === "video" && media2.spoiler
            },
            false
          );
        });
      }
      class BusinessConnection {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Whether the connection was removed by the user */
        get isRemoved() {
          return this.raw.disabled;
        }
        /** ID of the connection */
        get id() {
          return this.raw.connectionId;
        }
        /** Datacenter ID of the connected user */
        get dcId() {
          return this.raw.dcId;
        }
        /** Date when the connection was created */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /** Whether the bot can reply on behalf of the user */
        get canReply() {
          return this.raw.canReply;
        }
        /** Business account user that created the business connection */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
      }
      exports("bt", BusinessConnection);
      memoizeGetters(BusinessConnection, ["user"]);
      function getBusinessConnection(client2, connectionId) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "account.getBotBusinessConnection",
            connectionId
          });
          assertIsUpdatesGroup("account.getBotBusinessConnection", res);
          client2.handleClientUpdate(res);
          assertTypeIs("account.getBotBusinessConnection", res.updates[0], "updateBotBusinessConnect");
          const peers = PeersIndex.from(res);
          return new BusinessConnection(res.updates[0].connection, peers);
        });
      }
      const DC_MAP_SYMBOL = Symbol("dcMap");
      function getDcMap(client2) {
        const client_ = client2;
        if (!client_[DC_MAP_SYMBOL]) {
          client_[DC_MAP_SYMBOL] = new LruMap(50);
        }
        return client_[DC_MAP_SYMBOL];
      }
      function _maybeInvokeWithBusinessConnection(client2, businessConnectionId, request, params) {
        return __async(this, null, function* () {
          if (!businessConnectionId) {
            return client2.call(request, params);
          }
          const dcMap = getDcMap(client2);
          if (!dcMap.has(businessConnectionId)) {
            const res = yield getBusinessConnection(client2, businessConnectionId);
            dcMap.set(businessConnectionId, res.dcId);
          }
          const dcId = dcMap.get(businessConnectionId);
          return client2.call(
            {
              _: "invokeWithBusinessConnection",
              connectionId: businessConnectionId,
              query: request
            },
            __spreadProps(__spreadValues({}, params), {
              localMigrate: true,
              // just in case
              dcId
            })
          );
        });
      }
      function normalizeInputMessageId(id2) {
        if ("chatId" in id2)
          return id2;
        return { chatId: id2.message.chat.inputPeer, message: id2.message.id };
      }
      class MessageEffect {
        constructor(raw, documentsMap) {
          this.raw = raw;
          this.documentsMap = documentsMap;
        }
        /** Whether Telegram Premium is required to use this effect */
        get isPremiumRequired() {
          return this.raw.premiumRequired;
        }
        /** ID of this effect */
        get id() {
          return this.raw.id;
        }
        /** Emoji representint this reaction */
        get emoji() {
          return this.raw.emoticon;
        }
        /** Sticker representing a static icon for this effect (if any) */
        get staticIcon() {
          if (!this.raw.staticIconId)
            return null;
          const document2 = this.documentsMap.get(this.raw.staticIconId);
          if (!document2)
            return null;
          const parsed = parseSticker(document2);
          if (!parsed) {
            throw new MtTypeAssertionError("MessageEffect.staticIcon", "sticker", "null");
          }
          return parsed;
        }
        /** Animated icon representing the effect  */
        get icon() {
          const document2 = this.documentsMap.get(this.raw.effectStickerId);
          if (!document2) {
            throw new MtTypeAssertionError("MessageEffect.effect", "document", "null");
          }
          const parsed = parseSticker(document2);
          if (!parsed) {
            throw new MtTypeAssertionError("MessageEffect.effect", "sticker", "null");
          }
          return parsed;
        }
        /** The animation itself */
        get animation() {
          if (!this.raw.effectAnimationId)
            return null;
          const document2 = this.documentsMap.get(this.raw.effectAnimationId);
          if (!document2)
            return null;
          const parsed = parseSticker(document2);
          if (!parsed) {
            throw new MtTypeAssertionError("MessageEffect.effectAnimation", "sticker", "null");
          }
          return parsed;
        }
      }
      exports("ce", MessageEffect);
      memoizeGetters(MessageEffect, ["staticIcon", "icon", "animation"]);
      const SearchFilters = exports("cJ", {
        Empty: { _: "inputMessagesFilterEmpty" },
        Photo: { _: "inputMessagesFilterPhotos" },
        Video: { _: "inputMessagesFilterVideo" },
        PhotoAndVideo: {
          _: "inputMessagesFilterPhotoVideo"
        },
        Document: { _: "inputMessagesFilterDocument" },
        Url: { _: "inputMessagesFilterUrl" },
        Gif: { _: "inputMessagesFilterGif" },
        Voice: { _: "inputMessagesFilterVoice" },
        Audio: { _: "inputMessagesFilterMusic" },
        ChatPhotoChange: {
          _: "inputMessagesFilterChatPhotos"
        },
        Call: { _: "inputMessagesFilterPhoneCalls" },
        Round: { _: "inputMessagesFilterRoundVideo" },
        RoundAndVoice: {
          _: "inputMessagesFilterRoundVoice"
        },
        MyMention: { _: "inputMessagesFilterMyMentions" },
        Location: { _: "inputMessagesFilterGeo" },
        Contact: { _: "inputMessagesFilterContacts" },
        Pinned: { _: "inputMessagesFilterPinned" }
      });
      class ChatInviteLink {
        constructor(raw, _peers) {
          __publicField(this, "raw");
          this._peers = _peers;
          assertTypeIsNot("ChatInviteLink", raw, "chatInvitePublicJoinRequests");
          this.raw = raw;
        }
        /**
         * The invite link as a `t.me/joinchat/` string.
         *
         * If the link was created by another administrator, the second
         * part of the link will be censored with `...` (e.g. `https://t.me/joinchat/BGxxHIg4...`
         *
         * See also: {@link isMyLink}
         */
        get link() {
          return this.raw.link;
        }
        /**
         * Whether this invite link was created by the current user.
         *
         * If so, {@link link} will be a full invite link.
         */
        get isMyLink() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.creator) == null ? void 0 : _a3.isSelf) != null ? _b2 : !this.raw.link.endsWith("...");
        }
        /**
         * Creator of the invite link, if available
         */
        get creator() {
          if (!this._peers)
            return null;
          return new User(this._peers.user(this.raw.adminId));
        }
        /**
         * Creation date of the link
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Whether this link is primary (i.e. "permanent")
         */
        get isPrimary() {
          return this.raw.permanent;
        }
        /**
         * Whether this link was revoked and can't be used anymore
         */
        get isRevoked() {
          return this.raw.revoked;
        }
        /**
         * The date since which the link will be valid (if any)
         */
        get startDate() {
          return this.raw.startDate ? new Date(this.raw.startDate * 1e3) : null;
        }
        /**
         * The date until which the link will be valid (if any)
         */
        get endDate() {
          return this.raw.expireDate ? new Date(this.raw.expireDate * 1e3) : null;
        }
        /**
         * Maximum number of users that can be members of this chat
         * at the same time after joining using this link.
         *
         * Integer in range `[1, 99999]` or `Infinity` if unspecified
         */
        get usageLimit() {
          var _a3;
          return (_a3 = this.raw.usageLimit) != null ? _a3 : Infinity;
        }
        /**
         * Number of users currently in the chat that joined using this link
         */
        get usage() {
          var _a3;
          return (_a3 = this.raw.usage) != null ? _a3 : 0;
        }
        /**
         * Whether users joined by this link need to be
         * approved by the group administrator before they can join
         */
        get approvalNeeded() {
          return this.raw.requestNeeded;
        }
        /**
         * Number of users currently awaiting admin approval.
         *
         * 0 in case the link is not using approvals
         */
        get pendingApprovals() {
          var _a3;
          return (_a3 = this.raw.requested) != null ? _a3 : 0;
        }
      }
      exports("bA", ChatInviteLink);
      memoizeGetters(ChatInviteLink, ["creator"]);
      class ChatLocation {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Location of the chat
         */
        get location() {
          return new Location(this.raw.geoPoint);
        }
        /**
         * Textual description of the address
         */
        get address() {
          return this.raw.address;
        }
      }
      exports("bD", ChatLocation);
      memoizeGetters(ChatLocation, ["location"]);
      class ChatMember {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Information about the user
         */
        get user() {
          switch (this.raw._) {
            case "channelParticipantBanned":
            case "channelParticipantLeft":
              assertTypeIs("ChatMember#user (raw.peer)", this.raw.peer, "peerUser");
              return new User(this._peers.user(this.raw.peer.userId));
            default:
              return new User(this._peers.user(this.raw.userId));
          }
        }
        /**
         * Get the chat member status
         */
        get status() {
          switch (this.raw._) {
            case "channelParticipant":
            case "channelParticipantSelf":
            case "chatParticipant":
              return "member";
            case "channelParticipantCreator":
            case "chatParticipantCreator":
              return "creator";
            case "channelParticipantAdmin":
            case "chatParticipantAdmin":
              return "admin";
            case "channelParticipantLeft":
              return "left";
            case "channelParticipantBanned":
              return this.raw.bannedRights.viewMessages ? "banned" : "restricted";
          }
        }
        /**
         * Custom title (for creators and admins).
         *
         * `null` for non-admins and in case custom title is not set.
         */
        get title() {
          var _a3;
          switch (this.raw._) {
            case "channelParticipantCreator":
            case "channelParticipantAdmin":
              return (_a3 = this.raw.rank) != null ? _a3 : null;
            default:
              return null;
          }
        }
        /**
         * Date when the user has joined the chat.
         *
         * Not available for creators and left members
         */
        get joinedDate() {
          switch (this.raw._) {
            case "channelParticipantCreator":
            case "chatParticipantCreator":
            case "channelParticipantLeft":
              return null;
            default:
              return new Date(this.raw.date * 1e3);
          }
        }
        /**
         * Information about whoever invited this member to the chat.
         *
         * Only available in the following cases:
         *  - `user` is yourself
         *  - `chat` is a legacy group
         *  - `chat` is a supergroup/channel, and `user` is an admin
         */
        get invitedBy() {
          if ("inviterId" in this.raw && this.raw.inviterId) {
            return new User(this._peers.user(this.raw.inviterId));
          }
          return null;
        }
        /**
         * Information about whoever promoted this admin.
         *
         * Only available if `status = admin`.
         */
        get promotedBy() {
          if (this.raw._ === "channelParticipantAdmin") {
            return new User(this._peers.user(this.raw.promotedBy));
          }
          return null;
        }
        /**
         * Information about whoever restricted this user.
         *
         * Only available if `status = restricted or status = banned`
         */
        get restrictedBy() {
          if (this.raw._ === "channelParticipantBanned") {
            return new User(this._peers.user(this.raw.kickedBy));
          }
          return null;
        }
        /**
         * For restricted and banned users,
         * information about the restrictions
         */
        get restrictions() {
          if (this.raw._ !== "channelParticipantBanned")
            return null;
          return new ChatPermissions(this.raw.bannedRights);
        }
        /**
         * Whether this member is a part of the chat now.
         *
         * Makes sense only when `status = restricted or staus = banned`
         */
        get isMember() {
          return this.raw._ === "channelParticipantBanned" ? !this.raw.left : this.raw._ !== "channelParticipantLeft";
        }
        /**
         * For admins and creator of supergroup/channels,
         * list of their admin permissions.
         *
         * Also contains whether this admin is anonymous.
         */
        get permissions() {
          switch (this.raw._) {
            case "channelParticipantAdmin":
            case "channelParticipantCreator":
              return this.raw.adminRights;
            default:
              return null;
          }
        }
        /**
         * If this member subscribed to a channel using Telegram Stars,
         * this field will contain the date when the subscription will expire
         */
        get subscriptionUntilDate() {
          switch (this.raw._) {
            case "channelParticipant":
            case "channelParticipantSelf":
              if (!this.raw.subscriptionUntilDate)
                return null;
              return new Date(this.raw.subscriptionUntilDate * 1e3);
          }
          return null;
        }
      }
      exports("bE", ChatMember);
      memoizeGetters(ChatMember, ["user", "invitedBy", "promotedBy", "restrictedBy", "restrictions"]);
      const _ForumTopic = class _ForumTopic {
        constructor(raw, _peers, _messages) {
          this.raw = raw;
          this._peers = _peers;
          this._messages = _messages;
        }
        static parseTlForumTopics(topics) {
          const peers = PeersIndex.from(topics);
          const messages = /* @__PURE__ */ new Map();
          topics.messages.forEach((msg) => {
            if (!msg.peerId)
              return;
            messages.set(msg.id, msg);
          });
          return topics.topics.filter(hasValueAtKey("_", "forumTopic")).map((it) => new _ForumTopic(it, peers, messages));
        }
        /**
         * Whether the topic was created by the current user
         */
        get isMy() {
          return this.raw.my;
        }
        /**
         * Whether the topic is closed
         */
        get isClosed() {
          return this.raw.closed;
        }
        /**
         * Whether the topic is pinned
         */
        get isPinned() {
          return this.raw.pinned;
        }
        /**
         * Whether this constructor is a reduced version of the full topic information.
         *
         * If `true`, only {@link isMy}, {@link isClosed}, {@link id}, {@link date},
         * {@link title}, {@link iconColor}, {@link iconCustomEmoji} and {@link creator}
         * parameters will contain valid information.
         */
        get isShort() {
          return this.raw.short;
        }
        /**
         * ID of the topic
         */
        get id() {
          return this.raw.id;
        }
        /**
         * Date when the topic was created
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Title of the topic
         */
        get title() {
          return this.raw.title;
        }
        /**
         * Color of the topic's icon, used as a fallback
         * in case {@link iconEmoji} is not set.
         *
         * One of the static `COLOR_*` fields.
         */
        get iconColor() {
          var _a3;
          return (_a3 = this.raw.iconColor) != null ? _a3 : null;
        }
        /**
         * Emoji used as the topic's icon.
         */
        get iconCustomEmoji() {
          var _a3;
          return (_a3 = this.raw.iconEmojiId) != null ? _a3 : null;
        }
        /**
         * Creator of the topic
         */
        get creator() {
          return parsePeer(this.raw.fromId, this._peers);
        }
        /**
         * The latest message sent in this topic
         */
        get lastMessage() {
          var _a3;
          const id2 = this.raw.topMessage;
          if ((_a3 = this._messages) == null ? void 0 : _a3.has(id2)) {
            return new Message(this._messages.get(id2), this._peers);
          }
          throw new MtMessageNotFoundError(0, id2);
        }
        /**
         * ID of the last read outgoing message in this topic
         */
        get lastReadIngoing() {
          return this.raw.readInboxMaxId;
        }
        /**
         * ID of the last read ingoing message in this topic
         */
        get lastReadOutgoing() {
          return this.raw.readOutboxMaxId;
        }
        /**
         * ID of the last read message in this topic
         */
        get lastRead() {
          return Math.max(this.raw.readOutboxMaxId, this.raw.readInboxMaxId);
        }
        /**
         * Number of unread messages in the topic
         */
        get unreadCount() {
          return this.raw.unreadCount;
        }
        /**
         * Number of unread mentions in the topic
         */
        get unreadMentionsCount() {
          return this.raw.unreadMentionsCount;
        }
        /**
         * Number of unread reactions in the topic
         */
        get unreadReactionsCount() {
          return this.raw.unreadReactionsCount;
        }
        /**
         * Draft message in the topic
         */
        get draftMessage() {
          if (!this.raw.draft || this.raw.draft._ === "draftMessageEmpty")
            return null;
          return new DraftMessage(this.raw.draft);
        }
      };
      __publicField(_ForumTopic, "COLOR_BLUE", 7322096);
      __publicField(_ForumTopic, "COLOR_YELLOW", 16766590);
      __publicField(_ForumTopic, "COLOR_PURPLE", 13338331);
      __publicField(_ForumTopic, "COLOR_GREEN", 9367192);
      __publicField(_ForumTopic, "COLOR_PINK", 16749490);
      __publicField(_ForumTopic, "COLOR_RED", 16478047);
      let ForumTopic = _ForumTopic;
      exports("bZ", ForumTopic);
      memoizeGetters(ForumTopic, ["creator", "lastMessage", "draftMessage"]);
      function _actionFromTl(e2, peers) {
        switch (e2._) {
          case "channelAdminLogEventActionParticipantJoin":
            return { type: "user_joined" };
          case "channelAdminLogEventActionChangeTitle":
            return {
              type: "title_changed",
              old: e2.prevValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionChangeAbout":
            return {
              type: "description_changed",
              old: e2.prevValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionChangeUsername":
            return {
              type: "username_changed",
              old: e2.prevValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionChangeUsernames":
            return {
              type: "usernames_changed",
              old: e2.prevValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionChangePhoto":
            return {
              type: "photo_changed",
              old: new Photo(e2.prevPhoto),
              new: new Photo(e2.newPhoto)
            };
          case "channelAdminLogEventActionToggleInvites":
            return {
              type: "invites_toggled",
              old: !e2.newValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionToggleSignatures":
            return {
              type: "signatures_toggled",
              old: !e2.newValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionUpdatePinned":
            return {
              type: "msg_pinned",
              message: new Message(e2.message, peers)
            };
          case "channelAdminLogEventActionEditMessage":
            return {
              type: "msg_edited",
              old: new Message(e2.prevMessage, peers),
              new: new Message(e2.newMessage, peers)
            };
          case "channelAdminLogEventActionDeleteMessage":
            return {
              type: "msg_deleted",
              message: new Message(e2.message, peers)
            };
          case "channelAdminLogEventActionParticipantLeave":
            return { type: "user_left" };
          case "channelAdminLogEventActionParticipantInvite":
            return {
              type: "user_invited",
              member: new ChatMember(e2.participant, peers)
            };
          case "channelAdminLogEventActionParticipantToggleBan":
            return {
              type: "user_perms_changed",
              old: new ChatMember(e2.prevParticipant, peers),
              new: new ChatMember(e2.newParticipant, peers)
            };
          case "channelAdminLogEventActionParticipantToggleAdmin":
            return {
              type: "user_admin_perms_changed",
              old: new ChatMember(e2.prevParticipant, peers),
              new: new ChatMember(e2.newParticipant, peers)
            };
          case "channelAdminLogEventActionChangeStickerSet":
            return {
              type: "stickerset_changed",
              old: e2.prevStickerset,
              new: e2.newStickerset
            };
          case "channelAdminLogEventActionTogglePreHistoryHidden":
            return {
              type: "history_toggled",
              old: !e2.newValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionDefaultBannedRights":
            return {
              type: "def_perms_changed",
              old: new ChatPermissions(e2.prevBannedRights),
              new: new ChatPermissions(e2.newBannedRights)
            };
          case "channelAdminLogEventActionStopPoll":
            return {
              type: "poll_stopped",
              message: new Message(e2.message, peers)
            };
          case "channelAdminLogEventActionChangeLinkedChat":
            return {
              type: "linked_chat_changed",
              old: toggleChannelIdMark(e2.prevValue),
              new: toggleChannelIdMark(e2.newValue)
            };
          case "channelAdminLogEventActionChangeLocation":
            return {
              type: "location_changed",
              old: e2.prevValue._ === "channelLocationEmpty" ? null : new ChatLocation(e2.prevValue),
              new: e2.newValue._ === "channelLocationEmpty" ? null : new ChatLocation(e2.newValue)
            };
          case "channelAdminLogEventActionToggleSlowMode":
            return {
              type: "slow_mode_changed",
              old: e2.prevValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionStartGroupCall":
            return {
              type: "call_started",
              call: e2.call
            };
          case "channelAdminLogEventActionDiscardGroupCall":
            return {
              type: "call_ended",
              call: e2.call
            };
          case "channelAdminLogEventActionParticipantMute":
          case "channelAdminLogEventActionParticipantUnmute":
          case "channelAdminLogEventActionParticipantVolume":
            return null;
          case "channelAdminLogEventActionToggleGroupCallSetting":
            return {
              type: "call_setting_changed",
              joinMuted: e2.joinMuted
            };
          case "channelAdminLogEventActionParticipantJoinByInvite":
            return {
              type: "user_joined_invite",
              link: new ChatInviteLink(e2.invite, peers)
            };
          case "channelAdminLogEventActionExportedInviteDelete":
            return {
              type: "invite_deleted",
              link: new ChatInviteLink(e2.invite, peers)
            };
          case "channelAdminLogEventActionExportedInviteRevoke":
            return {
              type: "invite_revoked",
              link: new ChatInviteLink(e2.invite, peers)
            };
          case "channelAdminLogEventActionExportedInviteEdit":
            return {
              type: "invite_edited",
              old: new ChatInviteLink(e2.prevInvite, peers),
              new: new ChatInviteLink(e2.newInvite, peers)
            };
          case "channelAdminLogEventActionChangeHistoryTTL":
            return {
              type: "ttl_changed",
              old: e2.prevValue,
              new: e2.newValue
            };
          case "channelAdminLogEventActionParticipantJoinByRequest":
            return {
              type: "user_joined_approved",
              link: new ChatInviteLink(e2.invite, peers),
              approvedBy: new User(peers.user(e2.approvedBy))
            };
          case "channelAdminLogEventActionToggleForum":
            return {
              type: "forum_toggled",
              enabled: e2.newValue
            };
          case "channelAdminLogEventActionCreateTopic":
            assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e2.topic, "forumTopic");
            return {
              type: "topic_created",
              topic: new ForumTopic(e2.topic, peers)
            };
          case "channelAdminLogEventActionEditTopic":
            assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e2.prevTopic, "forumTopic");
            assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e2.newTopic, "forumTopic");
            return {
              type: "topic_edited",
              old: new ForumTopic(e2.prevTopic, peers),
              new: new ForumTopic(e2.newTopic, peers)
            };
          case "channelAdminLogEventActionDeleteTopic":
            assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e2.topic, "forumTopic");
            return {
              type: "topic_deleted",
              topic: new ForumTopic(e2.topic, peers)
            };
          case "channelAdminLogEventActionToggleNoForwards":
            return {
              type: "no_forwards_toggled",
              enabled: e2.newValue
            };
          case "channelAdminLogEventActionToggleSignatureProfiles":
            return {
              type: "signature_profiles_toggled",
              new: e2.newValue
            };
          case "channelAdminLogEventActionParticipantSubExtend":
            return {
              type: "sub_extend",
              prev: new ChatMember(e2.prevParticipant, peers),
              new: new ChatMember(e2.newParticipant, peers)
            };
          default:
            return null;
        }
      }
      class ChatEvent {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Event ID.
         *
         * Event IDs are generated in direct chronological order
         * (i.e. newer events have bigger event ID)
         */
        get id() {
          return this.raw.id;
        }
        /**
         * Date of the event
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Actor of the event
         */
        get actor() {
          return new User(this._peers.user(this.raw.userId));
        }
        get action() {
          return _actionFromTl(this.raw.action, this._peers);
        }
      }
      exports("bz", ChatEvent);
      memoizeGetters(ChatEvent, ["actor", "action"]);
      class ChatInviteLinkMember {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * User who joined the chat
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * Date when the user joined the chat
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Whether this user currently has a pending join request
         * (and is actually not a member yet)
         */
        get isPendingRequest() {
          return this.raw.requested;
        }
        /**
         * Whether the participant joined by importing a chat folder deep link
         */
        get isViaChatlist() {
          return this.raw.requested;
        }
        /**
         * For users with pending requests, contains bio of the user that requested to join
         */
        get bio() {
          var _a3;
          return (_a3 = this.raw.about) != null ? _a3 : null;
        }
        /**
         * The administrator that approved the join request of the user
         */
        get approvedBy() {
          if (!this.raw.approvedBy)
            return null;
          return new User(this._peers.user(this.raw.approvedBy));
        }
      }
      exports("bB", ChatInviteLinkMember);
      memoizeGetters(ChatInviteLinkMember, ["user", "approvedBy"]);
      class ChatPreview {
        constructor(invite, link) {
          this.invite = invite;
          this.link = link;
        }
        /**
         * Title of the chat
         */
        get title() {
          return this.invite.title;
        }
        /**
         * Type of the chat
         */
        get type() {
          if (this.invite.broadcast)
            return "channel";
          if (this.invite.megagroup || this.invite.channel)
            return "supergroup";
          return "group";
        }
        /**
         * Whether this chat is public
         */
        get public() {
          return this.invite.public;
        }
        /**
         * Total chat member count
         */
        get memberCount() {
          return this.invite.participantsCount;
        }
        /**
         * Chat photo
         */
        get photo() {
          if (this.invite.photo._ === "photoEmpty")
            return null;
          return new Photo(this.invite.photo);
        }
        /**
         * Preview of some of the chat members.
         *
         * This usually contains around 10 members,
         * and members that are inside your contacts list are
         * ordered before others.
         */
        get someMembers() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.invite.participants) == null ? void 0 : _a3.map((it) => new User(it))) != null ? _b2 : [];
        }
        /**
         * Whether by using this link you'll also need
         * to wait for admin approval.
         */
        get withApproval() {
          return this.invite.requestNeeded;
        }
      }
      exports("bJ", ChatPreview);
      memoizeGetters(ChatPreview, ["photo", "someMembers"]);
      class ChatlistPreview {
        constructor(raw) {
          __publicField(this, "peers");
          this.raw = raw;
          this.peers = PeersIndex.from(raw);
        }
        /** Whether the current user has already joined this chatlist */
        get isJoined() {
          return this.raw._ === "chatlists.chatlistInviteAlready";
        }
        /** If we joined the chatlist, ID of the folder representing it */
        get folderId() {
          return this.raw._ === "chatlists.chatlistInviteAlready" ? this.raw.filterId : null;
        }
        /** Title of the chatlist (only available for non-joined chatlists) */
        get title() {
          return this.raw._ === "chatlists.chatlistInvite" ? this.raw.title : "";
        }
        /** Emoji representing an icon of the chatlist (may only be available for non-joined chatlists) */
        get emoji() {
          var _a3;
          return this.raw._ === "chatlists.chatlistInvite" ? (_a3 = this.raw.emoticon) != null ? _a3 : null : null;
        }
        /** List of all chats contained in the chatlist */
        get chats() {
          let peers;
          if (this.raw._ === "chatlists.chatlistInvite") {
            peers = this.raw.peers;
          } else {
            peers = [...this.raw.alreadyPeers, ...this.raw.missingPeers];
          }
          return peers.map((peer) => Chat._parseFromPeer(peer, this.peers));
        }
      }
      exports("bK", ChatlistPreview);
      memoizeGetters(ChatlistPreview, ["chats"]);
      function animation(file2, params = {}) {
        const ret = params;
        ret.type = "video";
        ret.file = file2;
        ret.isAnimated = true;
        return ret;
      }
      function audio$1(file2, params = {}) {
        const ret = params;
        ret.type = "audio";
        ret.file = file2;
        return ret;
      }
      function document$1(file2, params = {}) {
        const ret = params;
        ret.type = "document";
        ret.file = file2;
        return ret;
      }
      function photo$4(file2, params = {}) {
        const ret = params;
        ret.type = "photo";
        ret.file = file2;
        return ret;
      }
      function video$2(file2, params = {}) {
        const ret = params;
        ret.type = "video";
        ret.file = file2;
        return ret;
      }
      function voice$2(file2, params = {}) {
        const ret = params;
        ret.type = "voice";
        ret.file = file2;
        return ret;
      }
      function sticker$2(file2, params = {}) {
        const ret = params;
        ret.type = "sticker";
        ret.file = file2;
        return ret;
      }
      function venue$2(params) {
        const ret = params;
        ret.type = "venue";
        return ret;
      }
      function geo$2(latitude, longitude, params = {}) {
        const ret = params;
        ret.type = "geo";
        ret.latitude = latitude;
        ret.longitude = longitude;
        return ret;
      }
      function geoLive$1(latitude, longitude, params = {}) {
        const ret = params;
        ret.type = "geo_live";
        ret.latitude = latitude;
        ret.longitude = longitude;
        return ret;
      }
      function dice(emoji2, params) {
        const ret = params;
        ret.type = "dice";
        return ret;
      }
      function contact$3(params) {
        const ret = params;
        ret.type = "contact";
        return ret;
      }
      function game$2(game2) {
        return {
          type: "game",
          game: game2
        };
      }
      function invoice(params) {
        const ret = params;
        ret.type = "invoice";
        return ret;
      }
      function poll(params) {
        const ret = params;
        ret.type = "poll";
        return ret;
      }
      function quiz(params) {
        const ret = params;
        ret.type = "quiz";
        return ret;
      }
      function story(params) {
        const ret = params;
        ret.type = "story";
        return ret;
      }
      function webpage$1(url2, params = {}) {
        const ret = params;
        ret.type = "webpage";
        ret.url = url2;
        return ret;
      }
      function paid(params) {
        const ret = params;
        ret.type = "paid";
        return ret;
      }
      function auto(file2, params = {}) {
        const ret = params;
        ret.type = "auto";
        ret.file = file2;
        return ret;
      }
      const factories$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        animation,
        audio: audio$1,
        auto,
        contact: contact$3,
        dice,
        document: document$1,
        game: game$2,
        geo: geo$2,
        geoLive: geoLive$1,
        invoice,
        paid,
        photo: photo$4,
        poll,
        quiz,
        sticker: sticker$2,
        story,
        venue: venue$2,
        video: video$2,
        voice: voice$2,
        webpage: webpage$1
      }, Symbol.toStringTag, { value: "Module" }));
      exports("c6", factories$2);
      function normalizeInputStickerSet(input) {
        if (typeof input === "string") {
          return {
            _: "inputStickerSetShortName",
            shortName: input
          };
        }
        if ("_" in input)
          return input;
        if (input instanceof StickerSet)
          return input.inputStickerSet;
        if ("dice" in input) {
          return {
            _: "inputStickerSetDice",
            emoticon: input.dice
          };
        }
        switch (input.system) {
          case "animated":
            return { _: "inputStickerSetAnimatedEmoji" };
          case "animated_animations":
            return { _: "inputStickerSetAnimatedEmojiAnimations" };
          case "premium_gifts":
            return { _: "inputStickerSetPremiumGifts" };
          case "generic_animations":
            return { _: "inputStickerSetEmojiGenericAnimations" };
          case "default_statuses":
            return { _: "inputStickerSetEmojiDefaultStatuses" };
          case "default_topic_icons":
            return { _: "inputStickerSetEmojiDefaultTopicIcons" };
          case "default_channel_statuses":
            return { _: "inputStickerSetEmojiChannelDefaultStatuses" };
        }
      }
      function parseStickerOrThrow(doc) {
        const sticker2 = parseSticker(doc);
        if (!sticker2) {
          throw new MtTypeAssertionError("full.documents", "sticker", "not a sticker");
        }
        return sticker2;
      }
      class StickerSet {
        constructor(raw) {
          __publicField(this, "brief");
          __publicField(this, "full");
          __publicField(this, "cover");
          /**
           * Whether this object contains information about stickers inside the set
           */
          __publicField(this, "isFull");
          if (raw._ === "messages.stickerSet") {
            this.full = raw;
            this.brief = raw.set;
          } else if (raw._ === "stickerSet") {
            this.brief = raw;
          } else if (tl.tl.isAnyStickerSetCovered(raw)) {
            this.cover = raw;
            this.brief = raw.set;
          } else {
            throw new MtTypeAssertionError("StickerSet", "messages.stickerSet | stickerSet", raw._);
          }
          this.isFull = raw._ === "messages.stickerSet";
        }
        /**
         * Whether this sticker set was archived
         * (due to too many saved stickers in the current account)
         */
        get isArchived() {
          return this.brief.archived;
        }
        /**
         * Whether this stickerset is official
         */
        get isOfficial() {
          return this.brief.official;
        }
        /**
         * Whether this sticker set was created by the current user
         */
        get isCreator() {
          return this.brief.creator;
        }
        /**
         * Type of the stickers in this set
         */
        get type() {
          if (this.brief.masks) {
            return "mask";
          }
          if (this.brief.emojis) {
            return "emoji";
          }
          return "sticker";
        }
        /**
         * Date when this sticker set was installed
         */
        get installedDate() {
          return this.brief.installedDate ? new Date(this.brief.installedDate * 1e3) : null;
        }
        /**
         * Number of stickers in this sticker set
         */
        get count() {
          return this.brief.count;
        }
        /**
         * Input sticker set to be used in other API methods
         */
        get inputStickerSet() {
          return {
            _: "inputStickerSetID",
            id: this.brief.id,
            accessHash: this.brief.accessHash
          };
        }
        /**
         * Title of the sticker set
         */
        get title() {
          return this.brief.title;
        }
        /**
         * Short name of sticker set to use in `tg://addstickers?set=short_name`
         * or `https://t.me/addstickers/short_name`
         */
        get shortName() {
          return this.brief.shortName;
        }
        /**
         * List of stickers inside this sticker set
         *
         * @throws MtEmptyError
         *     In case this object does not contain info about stickers (i.e. {@link isFull} = false)
         */
        get stickers() {
          if (!this.full)
            throw new MtEmptyError();
          const stickers = [];
          const index = new LongMap();
          this.full.documents.forEach((doc) => {
            const sticker2 = parseStickerOrThrow(doc);
            const info = {
              alt: sticker2.emoji,
              emoji: "",
              // populated later
              sticker: sticker2
            };
            stickers.push(info);
            index.set(doc.id, info);
          });
          this.full.packs.forEach((pack) => {
            pack.documents.forEach((id2) => {
              const item2 = index.get(id2);
              if (item2) {
                item2.emoji += pack.emoticon;
              }
            });
          });
          return stickers;
        }
        /** Cover stickers of the sticker set. Not the same as {@link thumbnails} */
        get covers() {
          if (!this.cover)
            return [];
          switch (this.cover._) {
            case "stickerSetCovered":
              return [parseStickerOrThrow(this.cover.cover)];
            case "stickerSetMultiCovered":
              return this.cover.covers.map((it) => parseStickerOrThrow(it));
            case "stickerSetFullCovered":
              return this.cover.documents.map((it) => parseStickerOrThrow(it));
            case "stickerSetNoCovered":
              return [];
          }
        }
        /**
         * Available sticker set thumbnails.
         *
         * Returns empty array if not available
         * (i.e. first sticker should be used as thumbnail)
         */
        get thumbnails() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.brief.thumbs) == null ? void 0 : _a3.map((sz) => new Thumbnail(this.brief, sz))) != null ? _b2 : [];
        }
        /**
         * Get a sticker set thumbnail by its type.
         *
         * Thumbnail types are described in the
         * [Telegram docs](https://core.telegram.org/api/files#image-thumbnail-types),
         * and are also available as static members of {@link Thumbnail} for convenience.
         *
         * @param type  Thumbnail type
         */
        getThumbnail(type) {
          var _a3;
          return (_a3 = this.thumbnails.find((it) => it.type === type)) != null ? _a3 : null;
        }
        /**
         * Find stickers given their emoji.
         *
         * @param emoji  Emoji to search for
         * @throws MtEmptyError
         *     In case this object does not contain info about stickers (i.e. {@link isFull} = false)
         */
        getStickersByEmoji(emoji2) {
          return this.stickers.filter((it) => it.alt === emoji2 || it.emoji.includes(emoji2));
        }
        _getInputDocument(idx) {
          if (!this.full)
            throw new MtEmptyError();
          if (idx < 0)
            idx = this.full.documents.length + idx;
          const doc = this.full.documents[idx];
          if (!doc) {
            throw new RangeError(`Sticker set does not have sticker ${idx}`);
          }
          return {
            _: "inputDocument",
            id: doc.id,
            accessHash: doc.accessHash,
            fileReference: doc.fileReference
          };
        }
      }
      exports("cQ", StickerSet);
      memoizeGetters(StickerSet, ["thumbnails", "stickers"]);
      class BusinessIntro {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Title of the intro.
         */
        get title() {
          return this.raw.title;
        }
        /**
         * Description of the intro.
         */
        get description() {
          return this.raw.description;
        }
        /**
         * Sticker of the intro.
         */
        get sticker() {
          if (!this.raw.sticker || this.raw.sticker._ === "documentEmpty")
            return null;
          const doc = parseDocument(this.raw.sticker);
          if (doc.type !== "sticker")
            return null;
          return doc;
        }
      }
      exports("bu", BusinessIntro);
      memoizeGetters(BusinessIntro, ["sticker"]);
      class BusinessLocation {
        constructor(raw) {
          this.raw = raw;
        }
        /** Address of the business */
        get address() {
          return this.raw.address;
        }
        get location() {
          if (!this.raw.geoPoint || this.raw.geoPoint._ === "geoPointEmpty")
            return null;
          return new Location(this.raw.geoPoint);
        }
      }
      memoizeGetters(BusinessLocation, ["location"]);
      const DAYS_IN_WEEK = 7;
      const MINUTES_IN_DAY = 24 * 60;
      function businessWorkHoursDaysToRaw(day) {
        const res = [];
        for(let   d of day) {
          const dayStart = d.day * MINUTES_IN_DAY;
          if (d.is24h) {
            res.push({
              _: "businessWeeklyOpen",
              startMinute: dayStart,
              endMinute: dayStart + MINUTES_IN_DAY
            });
            continue;
          }
          for(let   interval of d.intervals) {
            const start2 = dayStart + interval.startHour * 60 + interval.startMinute;
            const end = dayStart + interval.endHour * 60 + interval.endMinute;
            if (start2 >= end) {
              throw new MtArgumentError("startMinute >= endMinute");
            }
            res.push({
              _: "businessWeeklyOpen",
              startMinute: start2,
              endMinute: end
            });
          }
        }
        return res;
      }
      class BusinessWorkHours {
        constructor(raw) {
          this.raw = raw;
        }
        /** Whether the business is open right now */
        get isOpenNow() {
          return this.raw.openNow;
        }
        /**
         * Identifier of the time zone in which the {@link hours} are defined,
         * in the IANA format.
         */
        get timezoneId() {
          return this.raw.timezoneId;
        }
        /** Raw "open" intervals */
        get intervals() {
          return this.raw.weeklyOpen;
        }
        /**
         * Parsed business hours intervals per week day.
         *
         * @returns  Array of 7 elements, each representing a day of the week (starting from Monday = 0)
         */
        get days() {
          const days = Array.from({ length: DAYS_IN_WEEK }, (_, i) => ({
            day: i,
            is24h: false,
            intervals: []
          }));
          const sorted = [...this.raw.weeklyOpen].sort((a, b) => a.startMinute - b.startMinute);
          for (let i = 1; i < sorted.length; i++) {
            const prev = sorted[i - 1];
            const cur = sorted[i];
            if (prev.endMinute >= cur.startMinute) {
              prev.endMinute = cur.endMinute;
              sorted.splice(i, 1);
              i--;
            }
          }
          const mondayPrepend = [];
          for(let   interval of sorted) {
            if (interval.startMinute > interval.endMinute) {
              throw new MtArgumentError("startMinute is greater than endMinute");
            }
            const startDay = Math.floor(interval.startMinute / MINUTES_IN_DAY);
            const endDay = Math.floor(interval.endMinute / MINUTES_IN_DAY);
            if (endDay > DAYS_IN_WEEK + 1) {
              throw new MtArgumentError("interval spans more than a week");
            }
            for (let day = startDay, dayStart = startDay * MINUTES_IN_DAY; day <= endDay; day++, dayStart += MINUTES_IN_DAY) {
              const startWithin = Math.max(interval.startMinute, dayStart) - dayStart;
              const endWithin = Math.min(interval.endMinute, dayStart + MINUTES_IN_DAY) - dayStart;
              const startHour = Math.floor(startWithin / 60);
              const startMinute = startWithin % 60;
              const endHour = Math.floor(endWithin / 60);
              const endMinute = endWithin % 60;
              if (startHour === 0 && startMinute === 0 && endHour === 0 && endMinute === 0) {
                continue;
              }
              const obj = {
                startHour,
                startMinute,
                endHour,
                endMinute
              };
              if (day === DAYS_IN_WEEK) {
                mondayPrepend.push(obj);
              } else {
                days[day].intervals.push(obj);
              }
            }
          }
          if (mondayPrepend.length > 0) {
            days[0].intervals.unshift(...mondayPrepend);
          }
          for(let   day of days) {
            if (day.intervals.length !== 1)
              continue;
            const interval = day.intervals[0];
            if (interval.startHour === 0 && interval.startMinute === 0 && (interval.endHour === 24 && interval.endMinute === 0 || interval.endHour === 23 && interval.endMinute === 59)) {
              day.is24h = true;
            }
          }
          return days;
        }
      }
      exports("bw", BusinessWorkHours);
      memoizeGetters(BusinessWorkHours, ["days"]);
      class BusinessAccount {
        constructor(info) {
          this.info = info;
        }
        /** Introduction of the business account */
        get intro() {
          if (!this.info.businessIntro)
            return null;
          return new BusinessIntro(this.info.businessIntro);
        }
        /** Work hours of the business */
        get workHours() {
          if (!this.info.businessWorkHours)
            return null;
          return new BusinessWorkHours(this.info.businessWorkHours);
        }
        /** Location of the business */
        get location() {
          if (!this.info.businessLocation)
            return null;
          return new BusinessLocation(this.info.businessLocation);
        }
        /** Information about a greeting message */
        get greetingMessage() {
          var _a3;
          return (_a3 = this.info.businessGreetingMessage) != null ? _a3 : null;
        }
        /** Information about an "away" message */
        get awayMessage() {
          var _a3;
          return (_a3 = this.info.businessAwayMessage) != null ? _a3 : null;
        }
      }
      exports("bq", BusinessAccount);
      memoizeGetters(BusinessAccount, ["intro", "workHours", "location"]);
      class FullChat extends Chat {
        constructor(peer, fullPeer) {
          super(peer);
          __publicField(this, "_linkedChat");
          this.fullPeer = fullPeer;
        }
        /** @internal */
        static _parse(full) {
          var _a3;
          const peers = PeersIndex.from(full);
          if (full._ === "users.userFull") {
            const { fullUser } = full;
            const user = peers.user(full.fullUser.id);
            if (!user || user._ === "userEmpty") {
              throw new MtTypeAssertionError("Chat._parseFull", "user", (_a3 = user == null ? void 0 : user._) != null ? _a3 : "undefined");
            }
            const ret2 = new FullChat(user, fullUser);
            if (fullUser.personalChannelId) {
              ret2._linkedChat = new Chat(peers.chat(fullUser.personalChannelId));
            }
            return ret2;
          }
          const { fullChat } = full;
          const ret = new FullChat(peers.chat(fullChat.id), fullChat);
          if (fullChat._ === "channelFull" && fullChat.linkedChatId) {
            ret._linkedChat = new Chat(peers.chat(fullChat.linkedChatId));
          }
          return ret;
        }
        /**
         * Whether this chat (user) has restricted sending them voice/video messages.
         */
        get hasBlockedVoices() {
          var _a3;
          return ((_a3 = this.fullPeer) == null ? void 0 : _a3._) === "userFull" && this.fullPeer.voiceMessagesForbidden;
        }
        /** Whether paid reactions are enabled for this channel */
        get hasPaidReactions() {
          var _a3;
          return ((_a3 = this.fullPeer) == null ? void 0 : _a3._) === "channelFull" && this.fullPeer.paidReactionsAvailable;
        }
        /**
         * Full information about this chat's photo, if any.
         *
         * Unlike {@link Chat.photo}, this field contains additional information
         * about the photo, such as its date, more sizes, and is the only
         * way to get the animated profile photo.
         *
         * This field takes into account any personal/fallback photo
         * that the user may have set
         */
        get fullPhoto() {
          var _a3, _b2;
          if (!this.fullPeer)
            return null;
          let photo2;
          switch (this.fullPeer._) {
            case "userFull":
              photo2 = (_b2 = (_a3 = this.fullPeer.personalPhoto) != null ? _a3 : this.fullPeer.profilePhoto) != null ? _b2 : this.fullPeer.fallbackPhoto;
              break;
            case "chatFull":
            case "channelFull":
              photo2 = this.fullPeer.chatPhoto;
          }
          if ((photo2 == null ? void 0 : photo2._) !== "photo")
            return null;
          return new Photo(photo2);
        }
        /**
         * A custom photo (set by the current user) that should be displayed
         * instead of the actual chat photo.
         *
         * Currently only available for users.
         */
        get personalPhoto() {
          var _a3;
          if (!this.fullPeer || this.fullPeer._ !== "userFull")
            return null;
          if (((_a3 = this.fullPeer.personalPhoto) == null ? void 0 : _a3._) !== "photo")
            return null;
          return new Photo(this.fullPeer.personalPhoto);
        }
        /**
         * Actual profile photo of the user, bypassing the custom one.
         */
        get realPhoto() {
          var _a3;
          if (!this.fullPeer)
            return null;
          if (this.fullPeer._ !== "userFull")
            return this.fullPhoto;
          if (((_a3 = this.fullPeer.personalPhoto) == null ? void 0 : _a3._) !== "photo")
            return null;
          return new Photo(this.fullPeer.personalPhoto);
        }
        /**
         * A photo that the user has set to be shown
         * in case their actual profile photo is not available
         * due to privacy settings.
         *
         * Currently only available for users.
         */
        get publicPhoto() {
          var _a3;
          if (!this.fullPeer || this.fullPeer._ !== "userFull")
            return null;
          if (((_a3 = this.fullPeer.fallbackPhoto) == null ? void 0 : _a3._) !== "photo")
            return null;
          return new Photo(this.fullPeer.fallbackPhoto);
        }
        /**
         * Bio of the other party in a private chat, or description of a
         * group, supergroup or channel.
         */
        get bio() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.fullPeer) == null ? void 0 : _a3.about) != null ? _b2 : null;
        }
        /**
         * Chat's primary invite link, for groups, supergroups and channels.
         */
        get inviteLink() {
          var _a3;
          if (this.fullPeer && this.fullPeer._ !== "userFull") {
            switch ((_a3 = this.fullPeer.exportedInvite) == null ? void 0 : _a3._) {
              case "chatInvitePublicJoinRequests":
                return null;
              case "chatInviteExported":
                return new ChatInviteLink(this.fullPeer.exportedInvite);
            }
          }
          return null;
        }
        /**
         * For supergroups, information about the group sticker set.
         */
        get stickerSet() {
          var _a3;
          if (((_a3 = this.fullPeer) == null ? void 0 : _a3._) !== "channelFull" || !this.fullPeer.stickerset)
            return null;
          return new StickerSet(this.fullPeer.stickerset);
        }
        /**
         * For supergroups, information about the group emoji set.
         */
        get emojiSet() {
          var _a3;
          if (((_a3 = this.fullPeer) == null ? void 0 : _a3._) !== "channelFull" || !this.fullPeer.emojiset)
            return null;
          return new StickerSet(this.fullPeer.emojiset);
        }
        /**
         * Whether the group sticker set can be changed by you.
         */
        get canSetStickerSet() {
          var _a3;
          return this.fullPeer && this.fullPeer._ === "channelFull" ? (_a3 = this.fullPeer.canSetStickers) != null ? _a3 : null : null;
        }
        /**
         * Number of boosts applied by the current user to this chat.
         */
        get boostsApplied() {
          var _a3, _b2;
          if (!this.fullPeer || this.fullPeer._ !== "channelFull")
            return 0;
          return (_b2 = (_a3 = this.fullPeer) == null ? void 0 : _a3.boostsApplied) != null ? _b2 : 0;
        }
        /**
         * Number of boosts required for the user to be unrestricted in this chat.
         */
        get boostsForUnrestrict() {
          var _a3, _b2;
          if (!this.fullPeer || this.fullPeer._ !== "channelFull")
            return 0;
          return (_b2 = (_a3 = this.fullPeer) == null ? void 0 : _a3.boostsUnrestrict) != null ? _b2 : 0;
        }
        /** Whether the current user can view Telegram Stars revenue for this chat */
        get canViewStarsRevenue() {
          return this.fullPeer._ === "channelFull" && this.fullPeer.canViewStats;
        }
        /**
         * Chat members count, for groups, supergroups and channels only.
         */
        get membersCount() {
          var _a3;
          switch (this.fullPeer._) {
            case "userFull":
              return null;
            case "chatFull":
              if (this.fullPeer.participants._ !== "chatParticipants") {
                return null;
              }
              return this.fullPeer.participants.participants.length;
            case "channelFull":
              return (_a3 = this.fullPeer.participantsCount) != null ? _a3 : null;
          }
        }
        /**
         * Location of the chat.
         */
        get location() {
          var _a3;
          if (!this.fullPeer || this.fullPeer._ !== "channelFull" || ((_a3 = this.fullPeer.location) == null ? void 0 : _a3._) !== "channelLocation") {
            return null;
          }
          return new ChatLocation(this.fullPeer.location);
        }
        /**
         * Information about a linked chat:
         * - for channels: the discussion group
         * - for supergroups: the linked channel
         * - for users: the personal channel
         */
        get linkedChat() {
          var _a3;
          return (_a3 = this._linkedChat) != null ? _a3 : null;
        }
        /**
         * TTL of all messages in this chat, in seconds
         */
        get ttlPeriod() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.fullPeer) == null ? void 0 : _a3.ttlPeriod) != null ? _b2 : null;
        }
        /**
         * If this is a business account, information about the business.
         */
        get business() {
          if (!this.fullPeer || this.fullPeer._ !== "userFull")
            return null;
          return new BusinessAccount(this.fullPeer);
        }
      }
      exports("b_", FullChat);
      memoizeGetters(FullChat, [
        "fullPhoto",
        "personalPhoto",
        "realPhoto",
        "publicPhoto",
        "location",
        "stickerSet",
        "emojiSet",
        "business"
      ]);
      function _findMessageInUpdate(client2, res, isEdit = false, noDispatch = true, allowNull = false, randomId) {
        assertIsUpdatesGroup("_findMessageInUpdate", res);
        client2.handleClientUpdate(res, noDispatch);
        let ourMessageId = 0;
        for(let   u of res.updates) {
          if (randomId && u._ === "updateMessageID" && u.randomId.eq(randomId)) {
            ourMessageId = u.id;
            continue;
          }
          if (isEdit) {
            if (!(u._ === "updateEditMessage" || u._ === "updateEditChannelMessage" || u._ === "updateBotEditBusinessMessage" || u._ === "updateBotNewBusinessMessage")) {
              continue;
            }
          } else {
            if (!(u._ === "updateNewMessage" || u._ === "updateNewChannelMessage" || u._ === "updateNewScheduledMessage" || u._ === "updateQuickReplyMessage" || u._ === "updateBotNewBusinessMessage")) {
              continue;
            }
          }
          if (ourMessageId !== 0 && u.message.id !== ourMessageId)
            continue;
          const peers = PeersIndex.from(res);
          return new Message(u.message, peers, u._ === "updateNewScheduledMessage");
        }
        if (allowNull)
          return null;
        throw new MtTypeAssertionError(
          "_findInUpdate (@ .updates[*])",
          "updateNewMessage | updateNewChannelMessage | updateNewScheduledMessage",
          "none"
        );
      }
      function _getPeerChainId(client2, peer, prefix = "peer") {
        const id2 = peer._ === "inputPeerSelf" ? client2.storage.self.getCached().userId : getMarkedPeerId(peer);
        return `${prefix}:${id2}`;
      }
      function _getDiscussionMessage(client2, peer, message2) {
        return __async(this, null, function* () {
          const inputPeer = yield resolvePeer(client2, peer);
          const res = yield client2.call({
            _: "messages.getDiscussionMessage",
            peer: inputPeer,
            msgId: message2
          });
          if (!res.messages.length || res.messages[0]._ === "messageEmpty") {
            return [inputPeer, message2];
          }
          const msg = res.messages[0];
          const chat2 = res.chats.find((it) => it.id === msg.peerId.channelId);
          return [
            {
              _: "inputPeerChannel",
              channelId: chat2.id,
              accessHash: chat2.accessHash
            },
            msg.id
          ];
        });
      }
      function getDiscussionMessage(client2, params) {
        return __async(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const inputPeer = yield resolvePeer(client2, chatId);
          const res = yield client2.call({
            _: "messages.getDiscussionMessage",
            peer: inputPeer,
            msgId: message2
          });
          if (!res.messages.length || res.messages[0]._ === "messageEmpty") {
            return null;
          }
          const msg = res.messages[0];
          const peers = PeersIndex.from(res);
          return new Message(msg, peers);
        });
      }
      function getMessages(client2, chatId, messageIds, fromReply = false) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, chatId);
          if (!Array.isArray(messageIds))
            messageIds = [messageIds];
          const type = fromReply ? "inputMessageReplyTo" : "inputMessageID";
          const ids = messageIds.map((it) => ({
            _: type,
            id: it
          }));
          const isChannel = isInputPeerChannel(peer);
          const res = yield client2.call(
            isChannel ? {
              _: "channels.getMessages",
              id: ids,
              channel: toInputChannel(peer)
            } : {
              _: "messages.getMessages",
              id: ids
            }
          );
          assertTypeIsNot("getMessages", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          let selfId;
          return res.messages.map((msg) => {
            var _a3, _b2;
            if (msg._ === "messageEmpty")
              return null;
            if (!isChannel) {
              switch (peer._) {
                case "inputPeerSelf":
                  if (selfId === void 0)
                    selfId = (_b2 = (_a3 = client2.storage.self.getCached()) == null ? void 0 : _a3.userId) != null ? _b2 : null;
                  if (!(msg.peerId._ === "peerUser" && msg.peerId.userId === selfId)) {
                    return null;
                  }
                  break;
                case "inputPeerUser":
                case "inputPeerUserFromMessage":
                  if (!(msg.peerId._ === "peerUser" && msg.peerId.userId === peer.userId)) {
                    return null;
                  }
                  break;
                case "inputPeerChat":
                  if (!(msg.peerId._ === "peerChat" && msg.peerId.chatId === peer.chatId)) {
                    return null;
                  }
                  break;
              }
            }
            return new Message(msg, peers);
          });
        });
      }
      function _normalizeQuickReplyShortcut(shortcut) {
        if (!shortcut)
          return void 0;
        if (typeof shortcut === "number") {
          return {
            _: "inputQuickReplyShortcutId",
            shortcutId: shortcut
          };
        }
        return {
          _: "inputQuickReplyShortcut",
          shortcut
        };
      }
      function _processCommonSendParameters(client2, chatId, params) {
        return __async(this, null, function* () {
          var _a3, _b2, _c;
          let peer = yield resolvePeer(client2, chatId);
          let replyTo = normalizeMessageId(params.replyTo);
          const replyToPeer = typeof params.replyTo === "number" ? void 0 : (_a3 = params.replyTo) == null ? void 0 : _a3.chat.inputPeer;
          if (params.commentTo) {
            [peer, replyTo] = yield _getDiscussionMessage(client2, peer, normalizeMessageId(params.commentTo));
          }
          if (params.mustReply) {
            if (!replyTo) {
              throw new MtArgumentError("mustReply used, but replyTo was not passed");
            }
            const msg = yield getMessages(client2, peer, replyTo);
            if (!msg) {
              throw new MtMessageNotFoundError(getMarkedPeerId(peer), replyTo, "to reply to");
            }
          }
          if (params.replyToStory && replyTo) {
            throw new MtArgumentError("replyTo/commentTo and replyToStory cannot be used together");
          }
          let tlReplyTo;
          if (replyTo) {
            tlReplyTo = {
              _: "inputReplyToMessage",
              replyToMsgId: replyTo,
              replyToPeerId: replyToPeer,
              quoteText: (_b2 = params.quote) == null ? void 0 : _b2.text,
              quoteEntities: (_c = params.quote) == null ? void 0 : _c.entities,
              quoteOffset: params.quoteOffset
            };
          } else if (params.replyToStory) {
            tlReplyTo = {
              _: "inputReplyToStory",
              storyId: params.replyToStory,
              peer
            };
          }
          let scheduleDate;
          if (params.schedule === "online") {
            scheduleDate = 2147483646;
          } else if (params.schedule) {
            scheduleDate = normalizeDate(params.schedule);
          }
          return {
            peer,
            replyTo: tlReplyTo,
            scheduleDate,
            quickReplyShortcut: _normalizeQuickReplyShortcut(params.quickReply),
            chainId: _getPeerChainId(client2, peer, "send")
          };
        });
      }
      function sendMedia(client2, chatId, media2, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          if (typeof media2 === "string") {
            media2 = {
              type: "auto",
              file: media2
            };
          }
          const { peer, replyTo, scheduleDate, chainId, quickReplyShortcut } = yield _processCommonSendParameters(
            client2,
            chatId,
            params
          );
          const inputMedia = yield _normalizeInputMedia(client2, media2, {
            progressCallback: params.progressCallback,
            uploadPeer: peer
          });
          const [message2, entities] = yield _normalizeInputText(
            client2,
            // some types dont have `caption` field, and ts warns us,
            // but since it's JS, they'll just be `undefined` and properly handled by the method
            params.caption || media2.caption
          );
          const replyMarkup = _convertToTl$2(params.replyMarkup);
          const randomId = randomLong();
          const res = yield _maybeInvokeWithBusinessConnection(
            client2,
            params.businessConnectionId,
            {
              _: "messages.sendMedia",
              peer,
              media: inputMedia,
              silent: params.silent,
              replyTo,
              randomId,
              scheduleDate,
              replyMarkup,
              message: message2,
              entities,
              clearDraft: params.clearDraft,
              noforwards: params.forbidForwards,
              sendAs: params.sendAs ? yield resolvePeer(client2, params.sendAs) : void 0,
              invertMedia: params.invert,
              quickReplyShortcut,
              effect: params.effect
            },
            { chainId }
          );
          const msg = _findMessageInUpdate(client2, res, false, !params.shouldDispatch, false, randomId);
          return msg;
        });
      }
      function sendMediaGroup(client2, chatId, medias, params) {
        return __async(this, null, function* () {
          var _a3;
          if (!params)
            params = {};
          const { peer, replyTo, scheduleDate, chainId, quickReplyShortcut } = yield _processCommonSendParameters(
            client2,
            chatId,
            params
          );
          const multiMedia = [];
          for (let i = 0; i < medias.length; i++) {
            let media2 = medias[i];
            if (typeof media2 === "string") {
              media2 = {
                type: "auto",
                file: media2
              };
            }
            const inputMedia = yield _normalizeInputMedia(
              client2,
              media2,
              {
                progressCallback: (_a3 = params.progressCallback) == null ? void 0 : _a3.bind(null, i),
                // i have no fucking clue why we should upload it manually,
                // but otherwise Telegram throws MEDIA_INVALID
                // fuck my life
                uploadPeer: peer,
                businessConnectionId: params.businessConnectionId
              },
              true
            );
            const [message2, entities] = yield _normalizeInputText(
              client2,
              // some types dont have `caption` field, and ts warns us,
              // but since it's JS, they'll just be `undefined` and properly handled by the method
              media2.caption
            );
            multiMedia.push({
              _: "inputSingleMedia",
              randomId: randomLong(),
              media: inputMedia,
              message: message2,
              entities
            });
          }
          const res = yield _maybeInvokeWithBusinessConnection(
            client2,
            params.businessConnectionId,
            {
              _: "messages.sendMultiMedia",
              peer,
              multiMedia,
              silent: params.silent,
              replyTo,
              scheduleDate,
              clearDraft: params.clearDraft,
              noforwards: params.forbidForwards,
              sendAs: params.sendAs ? yield resolvePeer(client2, params.sendAs) : void 0,
              invertMedia: params.invertMedia,
              quickReplyShortcut,
              effect: params.effect
            },
            { chainId }
          );
          assertIsUpdatesGroup("sendMediaGroup", res);
          client2.handleClientUpdate(res);
          const peers = PeersIndex.from(res);
          const msgs = res.updates.filter(
            (u) => u._ === "updateNewMessage" || u._ === "updateNewChannelMessage" || u._ === "updateNewScheduledMessage"
          ).map((u) => new Message(u.message, peers, u._ === "updateNewScheduledMessage"));
          return msgs;
        });
      }
      function sendText(client2, chatId, text2, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          const [message2, entities] = yield _normalizeInputText(client2, text2);
          const replyMarkup = _convertToTl$2(params.replyMarkup);
          const { peer, replyTo, scheduleDate, chainId, quickReplyShortcut } = yield _processCommonSendParameters(
            client2,
            chatId,
            params
          );
          const randomId = randomLong();
          const res = yield _maybeInvokeWithBusinessConnection(
            client2,
            params.businessConnectionId,
            {
              _: "messages.sendMessage",
              peer,
              noWebpage: params.disableWebPreview,
              silent: params.silent,
              replyTo,
              randomId,
              scheduleDate,
              replyMarkup,
              message: message2,
              entities,
              clearDraft: params.clearDraft,
              noforwards: params.forbidForwards,
              sendAs: params.sendAs ? yield resolvePeer(client2, params.sendAs) : void 0,
              invertMedia: params.invertMedia,
              quickReplyShortcut,
              effect: params.effect
            },
            { chainId }
          );
          if (res._ === "updateShortSentMessage") {
            const msg2 = {
              _: "message",
              id: res.id,
              peerId: inputPeerToPeer(peer),
              fromId: { _: "peerUser", userId: client2.storage.self.getCached().userId },
              message: message2,
              date: res.date,
              out: res.out,
              replyMarkup,
              entities: res.entities
            };
            if (!params.shouldDispatch) {
              client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
            }
            const peers = new PeersIndex();
            const fetchPeer = (peer2) => __async(this, null, function* () {
              const id2 = getMarkedPeerId(peer2);
              let cached2 = yield client2.storage.peers.getCompleteById(id2);
              if (!cached2) {
                cached2 = yield _getRawPeerBatched(client2, yield resolvePeer(client2, peer2));
              }
              if (!cached2) {
                throw new MtTypeAssertionError("sendText (@ getFullPeerById)", "user | chat", "null");
              }
              switch (cached2._) {
                case "user":
                  peers.users.set(cached2.id, cached2);
                  break;
                case "chat":
                case "chatForbidden":
                case "channel":
                case "channelForbidden":
                  peers.chats.set(cached2.id, cached2);
                  break;
                default:
                  throw new MtTypeAssertionError(
                    "sendText (@ users.getUsers)",
                    "user | chat | channel",
                    // not very accurate, but good enough
                    cached2._
                  );
              }
            });
            yield Promise.all([fetchPeer(peer), fetchPeer(msg2.fromId)]);
            const ret = new Message(msg2, peers);
            return ret;
          }
          const msg = _findMessageInUpdate(client2, res, false, !params.shouldDispatch, false, randomId);
          return msg;
        });
      }
      const CONVERSATION_SYMBOL = Symbol("conversation");
      class Conversation {
        constructor(client2, chat2) {
          __publicField(this, "_inputPeer");
          __publicField(this, "_chatId");
          __publicField(this, "_started", false);
          __publicField(this, "_lastMessage");
          __publicField(this, "_lastReceivedMessage");
          __publicField(this, "_queuedNewMessage", new Deque());
          __publicField(this, "_pendingNewMessages", new Deque());
          __publicField(this, "_lock", new AsyncLock());
          __publicField(this, "_pendingEditMessage", /* @__PURE__ */ new Map());
          __publicField(this, "_recentEdits", new Deque(10));
          __publicField(this, "_pendingRead", /* @__PURE__ */ new Map());
          this.client = client2;
          this.chat = chat2;
          if (!(CONVERSATION_SYMBOL in client2)) {
            client2[CONVERSATION_SYMBOL] = {
              pendingConversations: /* @__PURE__ */ new Map(),
              hasConversations: false
            };
          }
        }
        static _getState(client2) {
          return client2[CONVERSATION_SYMBOL];
        }
        /**
         * Pass the update to the conversation manager and all registered
         * conversations on this client.
         *
         * @returns `true` if the update was handled by some conversation
         */
        static handleUpdate(client2, update) {
          const state = Conversation._getState(client2);
          if (!(state == null ? void 0 : state.hasConversations))
            return false;
          let chatId;
          switch (update.name) {
            case "new_message":
            case "edit_message":
              chatId = getMarkedPeerId(update.data.raw.peerId);
              break;
            case "history_read":
              chatId = update.data.chatId;
              break;
            default:
              return false;
          }
          const conv = state.pendingConversations.get(chatId);
          if (!conv)
            return false;
          for(let   c of conv) {
            switch (update.name) {
              case "new_message":
                c._onNewMessage(update.data);
                return true;
              case "edit_message":
                c._onEditMessage(update.data);
                return true;
              case "history_read":
                c._onHistoryRead(update.data);
                return true;
            }
          }
          return false;
        }
        /**
         * Get the input peer that this conversation is with
         */
        get inputPeer() {
          if (!this._started) {
            throw new MtArgumentError("Conversation hasn't started yet");
          }
          return this._inputPeer;
        }
        /**
         * ID of the very last message in this conversation.
         */
        get lastMessage() {
          if (!this._started) {
            throw new MtArgumentError("Conversation hasn't started yet");
          }
          return this._lastMessage;
        }
        /**
         * ID of the last incoming message in this conversation.
         *
         * Note that before any messages were received since the {@link start}
         * of the conversation, this will equal to {@link lastMessage}
         */
        get lastReceivedMessage() {
          if (!this._started) {
            throw new MtArgumentError("Conversation hasn't started yet");
          }
          return this._lastReceivedMessage;
        }
        /**
         * Start the conversation
         */
        start() {
          return __async(this, null, function* () {
            if (this._started)
              return;
            this._started = true;
            this._inputPeer = yield resolvePeer(this.client, this.chat);
            this._chatId = getMarkedPeerId(this._inputPeer);
            const [dialog2] = yield getPeerDialogs(this.client, this._inputPeer);
            const lastMessage = dialog2 == null ? void 0 : dialog2.lastMessage;
            if (lastMessage) {
              this._lastMessage = this._lastReceivedMessage = lastMessage.id;
            } else {
              this._lastMessage = this._lastReceivedMessage = 0;
            }
            const state = Conversation._getState(this.client);
            if (!state.pendingConversations.has(this._chatId)) {
              state.pendingConversations.set(this._chatId, []);
            }
            state.pendingConversations.get(this._chatId).push(this);
            state.hasConversations = true;
          });
        }
        /**
         * Stop the conversation
         */
        stop() {
          var _a3;
          if (!this._started)
            return;
          const state = Conversation._getState(this.client);
          const pending2 = state.pendingConversations.get(this._chatId);
          const pendingIdx = (_a3 = pending2 == null ? void 0 : pending2.indexOf(this)) != null ? _a3 : -1;
          if (pendingIdx > -1) {
            pending2.splice(pendingIdx, 1);
          }
          if (pending2 && !pending2.length) {
            state.pendingConversations.delete(this._chatId);
          }
          state.hasConversations = Boolean(state.pendingConversations.size);
          this._queuedNewMessage.clear();
          this._pendingNewMessages.clear();
          this._pendingEditMessage.clear();
          this._recentEdits.clear();
          this._pendingRead.clear();
          this._started = false;
        }
        _recordMessage(msg, incoming = false) {
          this._lastMessage = msg.id;
          if (incoming)
            this._lastReceivedMessage = msg.id;
          return msg;
        }
        /**
         * Send a text message to this conversation.
         *
         * Wrapper over {@link sendText}
         */
        sendText(...params) {
          return __async(this, null, function* () {
            if (!this._started) {
              throw new MtArgumentError("Conversation hasn't started yet");
            }
            return this._recordMessage(yield sendText(this.client, this._inputPeer, ...params));
          });
        }
        /**
         * Send a media to this conversation.
         *
         * Wrapper over {@link sendMedia}
         */
        sendMedia(...params) {
          return __async(this, null, function* () {
            if (!this._started) {
              throw new MtArgumentError("Conversation hasn't started yet");
            }
            return this._recordMessage(yield sendMedia(this.client, this._inputPeer, ...params));
          });
        }
        /**
         * Send a media group to this conversation.
         *
         * Wrapper over {@link sendMediaGroup}
         */
        sendMediaGroup(...params) {
          return __async(this, null, function* () {
            if (!this._started) {
              throw new MtArgumentError("Conversation hasn't started yet");
            }
            const msgs = yield sendMediaGroup(this.client, this._inputPeer, ...params);
            this._recordMessage(msgs[msgs.length - 1]);
            return msgs;
          });
        }
        /**
         * Mark the conversation as read up to a certain point.
         *
         * By default, reads until the last message.
         * You can pass `message=null` to read the entire conversation,
         * or pass message ID to read up until that ID.
         */
        markRead({
          message: message2,
          clearMentions = true
        } = {}) {
          var _a3;
          if (!this._started) {
            throw new MtArgumentError("Conversation hasn't started yet");
          }
          if (message2 === null) {
            message2 = 0;
          } else if (message2 === void 0) {
            message2 = (_a3 = this._lastMessage) != null ? _a3 : 0;
          }
          return readHistory$1(this.client, this._inputPeer, { maxId: message2, clearMentions });
        }
        /**
         * Helper method that calls {@link start},
         * the provided function and then {@link stop}.
         *
         * It is preferred that you use this function rather than
         * manually starting and stopping the conversation.
         *
         * If you don't stop the conversation when you're done,
         * it *will* lead to memory leaks.
         *
         * @param handler
         */
        with(handler) {
          return __async(this, null, function* () {
            yield this.start();
            let err;
            let res;
            try {
              res = yield handler();
            } catch (e2) {
              err = e2;
            }
            this.stop();
            if (err)
              throw err;
            return res;
          });
        }
        /**
         * Wait for a new message in the conversation
         *
         * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
         * @param [timeout]  Timeout for the handler in ms. Pass `null` to disable.
         *   When the timeout is reached, `MtTimeoutError` is thrown.
         */
        waitForNewMessage(filter, timeout = 15e3) {
          if (!this._started) {
            throw new MtArgumentError("Conversation hasn't started yet");
          }
          const promise = createControllablePromise();
          let timer;
          if (timeout !== null) {
            timer = setTimeoutWrap(() => {
              promise.reject(new MtTimeoutError(timeout));
              this._queuedNewMessage.removeBy((it) => it.promise === promise);
            }, timeout);
          }
          this._queuedNewMessage.pushBack({
            promise,
            check: filter,
            timeout: timer
          });
          this._processPendingNewMessages();
          return promise;
        }
        /**
         * Wait for a response for the given message
         * (def. the last one) in the conversation.
         *
         * A message is considered to be a response if
         * it was sent after the given one.
         *
         * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
         * @param params
         */
        waitForResponse(filter, params) {
          var _a3, _b2;
          const msgId = (_b2 = (_a3 = params == null ? void 0 : params.message) != null ? _a3 : this._lastMessage) != null ? _b2 : 0;
          const pred = filter ? (msg) => msg.id > msgId ? filter(msg) : false : (msg) => msg.id > msgId;
          return this.waitForNewMessage(pred, params == null ? void 0 : params.timeout);
        }
        /**
         * Wait for the reply for the given message'
         * (def. the last one) in the conversation.
         *
         * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
         * @param params
         */
        waitForReply(filter, params) {
          var _a3;
          const msgId = (_a3 = params == null ? void 0 : params.message) != null ? _a3 : this._lastMessage;
          if (!msgId) {
            throw new MtArgumentError("Provide message for which to wait for reply for");
          }
          const pred = filter ? (msg) => {
            var _a4;
            return ((_a4 = msg.replyToMessage) == null ? void 0 : _a4.id) === msgId ? filter(msg) : false;
          } : (msg) => {
            var _a4;
            return ((_a4 = msg.replyToMessage) == null ? void 0 : _a4.id) === msgId;
          };
          return this.waitForNewMessage(pred, params == null ? void 0 : params.timeout);
        }
        /**
         * Wait for a message to be edited in the conversation.
         * By defaults wait for the last message sent by the other party
         * (at the moment) to be edited.
         *
         * Returns the edited message.
         *
         * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
         * @param params
         */
        waitForEdit(filter, params) {
          return __async(this, null, function* () {
            var _a3;
            if (!this._started) {
              throw new MtArgumentError("Conversation hasn't started yet");
            }
            const msgId = (_a3 = params == null ? void 0 : params.message) != null ? _a3 : this._lastReceivedMessage;
            if (!msgId) {
              throw new MtArgumentError("Provide message for which to wait for edit for");
            }
            const promise = createControllablePromise();
            let timer;
            const timeout = params == null ? void 0 : params.timeout;
            if (timeout) {
              timer = setTimeoutWrap(() => {
                promise.reject(new MtTimeoutError(timeout));
                this._pendingEditMessage.delete(msgId);
              }, timeout);
            }
            this._pendingEditMessage.set(msgId, {
              promise,
              check: filter,
              timeout: timer
            });
            this._processRecentEdits();
            return promise;
          });
        }
        /**
         * Wait for the message to be read by the other party.
         *
         * Note that reading the message doesn't mean the response was sent,
         * and if the response was sent, it doesn't mean that the message was read.
         *
         * @param message  Message for which to wait for read for. Defaults to last message.
         * @param timeout  Timeout for the handler in ms, def. 15 sec. Pass `null` to disable.
         *   When the timeout is reached, `TimeoutError` is thrown.
         */
        waitForRead(message2, timeout = 15e3) {
          return __async(this, null, function* () {
            if (!this._started) {
              throw new MtArgumentError("Conversation hasn't started yet");
            }
            const msgId = message2 != null ? message2 : this._lastMessage;
            if (!msgId) {
              throw new MtArgumentError("Provide message for which to wait for read for");
            }
            const [dialog2] = yield getPeerDialogs(this.client, this._inputPeer);
            if (dialog2.lastRead >= msgId)
              return;
            const promise = createControllablePromise();
            let timer;
            if (timeout !== null) {
              timer = setTimeoutWrap(() => {
                promise.reject(new MtTimeoutError(timeout));
                this._pendingRead.delete(msgId);
              }, timeout);
            }
            this._pendingRead.set(msgId, {
              promise,
              timeout: timer
            });
            return promise;
          });
        }
        _onNewMessage(msg) {
          if (msg.chat.id !== this._chatId)
            return;
          if (!this._queuedNewMessage.length) {
            this._pendingNewMessages.pushBack(msg);
            return;
          }
          const it = this._queuedNewMessage.peekFront();
          void this._lock.acquire().then(() => __async(this, null, function* () {
            try {
              if (!it.check || (yield it.check(msg))) {
                if (it.timeout)
                  clearTimeoutWrap(it.timeout);
                it.promise.resolve(msg);
                this._queuedNewMessage.popFront();
              }
            } catch (e2) {
              this.client.emitError(e2);
            }
            this._lastMessage = this._lastReceivedMessage = msg.id;
            this._lock.release();
          }));
        }
        _onEditMessage(msg, fromRecent = false) {
          if (msg.chat.id !== this._chatId)
            return;
          const it = this._pendingEditMessage.get(msg.id);
          if (!it) {
            if (!fromRecent) {
              this._recentEdits.pushBack(msg);
            }
            return;
          }
          (() => __async(this, null, function* () {
            if (!it.check || (yield it.check(msg))) {
              if (it.timeout)
                clearTimeoutWrap(it.timeout);
              it.promise.resolve(msg);
              this._pendingEditMessage.delete(msg.id);
            }
          }))().catch((e2) => {
            this.client.emitError(e2);
          });
        }
        _onHistoryRead(upd) {
          if (upd.chatId !== this._chatId)
            return;
          const lastRead = upd.maxReadId;
          for(let   msgId of this._pendingRead.keys()) {
            if (msgId <= lastRead) {
              const it = this._pendingRead.get(msgId);
              if (it.timeout)
                clearTimeoutWrap(it.timeout);
              it.promise.resolve();
              this._pendingRead.delete(msgId);
            }
          }
        }
        _processPendingNewMessages() {
          if (!this._pendingNewMessages.length)
            return;
          let it;
          while (it = this._pendingNewMessages.popFront()) {
            this._onNewMessage(it);
          }
        }
        _processRecentEdits() {
          if (!this._recentEdits.length)
            return;
          const iter = this._recentEdits.iter();
          let it;
          while (!(it = iter.next()).done) {
            this._onEditMessage(it.value, true);
          }
        }
      }
      exports("bO", Conversation);
      const sentCodeMap = {
        "auth.sentCodeTypeApp": "app",
        "auth.sentCodeTypeCall": "call",
        "auth.sentCodeTypeFlashCall": "flash_call",
        "auth.sentCodeTypeSms": "sms",
        "auth.sentCodeTypeMissedCall": "missed_call",
        "auth.sentCodeTypeEmailCode": "email",
        "auth.sentCodeTypeSetUpEmailRequired": "email_required",
        "auth.sentCodeTypeFragmentSms": "fragment",
        "auth.sentCodeTypeFirebaseSms": "firebase",
        "auth.sentCodeTypeSmsWord": "sms_word",
        "auth.sentCodeTypeSmsPhrase": "sms_phrase"
      };
      const nextCodeMap = {
        "auth.codeTypeCall": "call",
        "auth.codeTypeFlashCall": "flash_call",
        "auth.codeTypeSms": "sms",
        "auth.codeTypeMissedCall": "missed_call",
        "auth.codeTypeFragmentSms": "fragment"
      };
      class SentCode {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Type of currently sent confirmation code
         */
        get type() {
          return sentCodeMap[this.raw.type._];
        }
        /**
         * Type of the confirmation code that will be sent
         * if you call {@link TelegramClient.resendCode}.
         */
        get nextType() {
          return this.raw.nextType ? nextCodeMap[this.raw.nextType._] : "none";
        }
        /**
         * Confirmation code identifier used for the next authorization steps
         * (like {@link TelegramClient.signIn} and {@link TelegramClient.signUp})
         */
        get phoneCodeHash() {
          return this.raw.phoneCodeHash;
        }
        /**
         * Delay in seconds to wait before calling {@link TelegramClient.resendCode}
         */
        get timeout() {
          var _a3;
          return (_a3 = this.raw.timeout) != null ? _a3 : 0;
        }
        /**
         * If the code is sent via SMS with a word/phrase, this field *may* contain the beginning of the message
         */
        get beginning() {
          switch (this.raw.type._) {
            case "auth.sentCodeTypeSmsPhrase":
            case "auth.sentCodeTypeSmsWord":
              return this.raw.type.beginning;
            default:
              return void 0;
          }
        }
        /**
         * Length of the code (0 for flash calls)
         */
        get length() {
          return "length" in this.raw.type ? this.raw.type.length : 0;
        }
      }
      exports("cK", SentCode);
      class GameHighScore {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * User who has scored this score
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * Position in the records list
         */
        get position() {
          return this.raw.pos;
        }
        /**
         * Score
         */
        get score() {
          return this.raw.score;
        }
      }
      exports("c0", GameHighScore);
      memoizeGetters(GameHighScore, ["user"]);
      function text$2(text2, params = {}) {
        const ret = params;
        ret.type = "text";
        ret.text = text2;
        return ret;
      }
      function media(params = {}) {
        const ret = params;
        ret.type = "media";
        return ret;
      }
      function geo$1(params) {
        const ret = params;
        ret.type = "geo";
        return ret;
      }
      function geoLive(params) {
        const ret = params;
        ret.type = "geo_live";
        return ret;
      }
      function venue$1(params) {
        const ret = params;
        ret.type = "venue";
        return ret;
      }
      function game$1(params) {
        const ret = params;
        ret.type = "game";
        return ret;
      }
      function contact$2(params) {
        const ret = params;
        ret.type = "contact";
        return ret;
      }
      function webpage(params) {
        const ret = params;
        ret.type = "webpage";
        return ret;
      }
      function _convertToTl$1(client2, obj) {
        return __async(this, null, function* () {
          var _a3, _b2, _c, _d, _e, _f, _g, _h;
          switch (obj.type) {
            case "text": {
              const [message2, entities] = yield _normalizeInputText(client2, obj.text);
              return {
                _: "inputBotInlineMessageText",
                message: message2,
                entities,
                replyMarkup: _convertToTl$2(obj.replyMarkup),
                invertMedia: obj.invertMedia
              };
            }
            case "media": {
              const [message2, entities] = yield _normalizeInputText(client2, obj.text);
              return {
                _: "inputBotInlineMessageMediaAuto",
                message: message2,
                entities,
                replyMarkup: _convertToTl$2(obj.replyMarkup),
                invertMedia: obj.invertMedia
              };
            }
            case "geo":
            case "geo_live":
              return {
                _: "inputBotInlineMessageMediaGeo",
                geoPoint: {
                  _: "inputGeoPoint",
                  lat: obj.latitude,
                  long: obj.longitude
                },
                // fields will be `undefined` if this is a `geo`
                heading: obj.heading,
                period: obj.period,
                proximityNotificationRadius: obj.proximityNotificationRadius,
                replyMarkup: _convertToTl$2(obj.replyMarkup)
              };
            case "venue":
              return {
                _: "inputBotInlineMessageMediaVenue",
                geoPoint: {
                  _: "inputGeoPoint",
                  lat: obj.latitude,
                  long: obj.longitude
                },
                title: obj.title,
                address: obj.address,
                provider: (_b2 = (_a3 = obj.source) == null ? void 0 : _a3.provider) != null ? _b2 : "",
                venueId: (_d = (_c = obj.source) == null ? void 0 : _c.id) != null ? _d : "",
                venueType: (_f = (_e = obj.source) == null ? void 0 : _e.type) != null ? _f : "",
                replyMarkup: _convertToTl$2(obj.replyMarkup)
              };
            case "game":
              return {
                _: "inputBotInlineMessageGame",
                replyMarkup: _convertToTl$2(obj.replyMarkup)
              };
            case "contact":
              return {
                _: "inputBotInlineMessageMediaContact",
                phoneNumber: obj.phone,
                firstName: obj.firstName,
                lastName: (_g = obj.lastName) != null ? _g : "",
                vcard: (_h = obj.vcard) != null ? _h : "",
                replyMarkup: _convertToTl$2(obj.replyMarkup)
              };
            case "webpage": {
              const [message2, entities] = yield _normalizeInputText(client2, obj.text);
              return {
                _: "inputBotInlineMessageMediaWebPage",
                message: message2,
                entities,
                replyMarkup: _convertToTl$2(obj.replyMarkup),
                invertMedia: obj.invertMedia,
                forceLargeMedia: obj.size === "large",
                forceSmallMedia: obj.size === "small",
                optional: !obj.required,
                url: obj.url
              };
            }
            default:
              assertNever$1();
          }
        });
      }
      const factories$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        _convertToTl: _convertToTl$1,
        contact: contact$2,
        game: game$1,
        geo: geo$1,
        geoLive,
        media,
        text: text$2,
        venue: venue$1,
        webpage
      }, Symbol.toStringTag, { value: "Module" }));
      exports("bk", factories$1);
      function article(id2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "article";
        return ret;
      }
      function gif$1(id2, media2, params = {}) {
        const ret = params;
        ret.id = id2;
        ret.type = "gif";
        ret.media = media2;
        return ret;
      }
      function video$1(id2, media2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "video";
        ret.media = media2;
        return ret;
      }
      function audio(id2, media2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "audio";
        ret.media = media2;
        return ret;
      }
      function voice$1(id2, media2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "voice";
        ret.media = media2;
        return ret;
      }
      function photo$3(id2, media2, params = {}) {
        const ret = params;
        ret.id = id2;
        ret.type = "photo";
        ret.media = media2;
        return ret;
      }
      function sticker$1(id2, media2) {
        return {
          id: id2,
          type: "sticker",
          media: media2
        };
      }
      function file(id2, media2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "file";
        ret.media = media2;
        return ret;
      }
      function geo(id2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "geo";
        return ret;
      }
      function venue(id2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "venue";
        return ret;
      }
      function contact$1(id2, params) {
        const ret = params;
        ret.id = id2;
        ret.type = "contact";
        return ret;
      }
      function game(id2, shortName, params = {}) {
        const ret = params;
        ret.id = id2;
        ret.type = "game";
        ret.shortName = shortName;
        return ret;
      }
      function _convertToTl(client2, results) {
        return __async(this, null, function* () {
          var _a3, _b2, _c, _d, _e;
          const normalizeThumb = (obj, fallback) => {
            var _a4, _b3;
            if (obj.type !== "voice" && obj.type !== "audio" && obj.type !== "sticker" && obj.type !== "game") {
              if (!obj.thumb || typeof obj.thumb === "string") {
                if (!obj.thumb && !fallback) {
                  return void 0;
                }
                return {
                  _: "inputWebDocument",
                  size: 0,
                  url: obj.thumb || fallback,
                  mimeType: obj.type === "gif" ? (_b3 = (_a4 = obj.thumbMime) != null ? _a4 : obj.mime) != null ? _b3 : "video/mp4" : "image/jpeg",
                  attributes: []
                };
              }
              return obj.thumb;
            }
          };
          const items = [];
          let isGallery = false;
          let forceVertical = false;
          for(let   obj of results) {
            switch (obj.type) {
              case "article": {
                forceVertical = true;
                let sendMessage2;
                if (obj.message) {
                  sendMessage2 = yield _convertToTl$1(client2, obj.message);
                } else {
                  let message2 = obj.title;
                  const entities = [
                    {
                      _: "messageEntityBold",
                      offset: 0,
                      length: message2.length
                    }
                  ];
                  if (obj.url) {
                    entities.push({
                      _: "messageEntityTextUrl",
                      url: obj.url,
                      offset: 0,
                      length: message2.length
                    });
                  }
                  if (obj.description) {
                    message2 += `
${obj.description}`;
                  }
                  sendMessage2 = {
                    _: "inputBotInlineMessageText",
                    message: message2,
                    entities
                  };
                }
                items.push({
                  _: "inputBotInlineResult",
                  id: obj.id,
                  type: obj.type,
                  title: obj.title,
                  description: obj.description,
                  url: obj.hideUrl ? void 0 : obj.url,
                  content: obj.url && obj.hideUrl ? {
                    _: "inputWebDocument",
                    url: obj.url,
                    mimeType: "text/html",
                    size: 0,
                    attributes: []
                  } : void 0,
                  thumb: typeof obj.thumb === "string" ? normalizeThumb(obj) : obj.thumb,
                  sendMessage: sendMessage2
                });
                continue;
              }
              case "game": {
                let sendMessage2;
                if (obj.message) {
                  sendMessage2 = yield _convertToTl$1(client2, obj.message);
                  if (sendMessage2._ !== "inputBotInlineMessageGame") {
                    throw new MtArgumentError("game inline result must contain a game inline message");
                  }
                } else {
                  sendMessage2 = {
                    _: "inputBotInlineMessageGame"
                  };
                }
                items.push({
                  _: "inputBotInlineResultGame",
                  id: obj.id,
                  shortName: obj.shortName,
                  sendMessage: sendMessage2
                });
                continue;
              }
              case "gif":
              case "photo":
              case "sticker":
                isGallery = true;
                break;
              case "audio":
              case "contact":
              case "voice":
                forceVertical = true;
            }
            let sendMessage;
            if (obj.message) {
              sendMessage = yield _convertToTl$1(client2, obj.message);
            } else if (obj.type === "venue") {
              if (obj.latitude && obj.longitude) {
                sendMessage = {
                  _: "inputBotInlineMessageMediaVenue",
                  title: obj.title,
                  address: obj.address,
                  geoPoint: {
                    _: "inputGeoPoint",
                    lat: obj.latitude,
                    long: obj.longitude
                  },
                  provider: "",
                  venueId: "",
                  venueType: ""
                };
              } else {
                throw new MtArgumentError("message or location (lat&lon) bust be supplied for venue inline result");
              }
            } else if (obj.type === "video" && obj.isEmbed && typeof obj.media === "string") {
              sendMessage = {
                _: "inputBotInlineMessageText",
                message: obj.media
              };
            } else if (obj.type === "geo") {
              sendMessage = {
                _: "inputBotInlineMessageMediaGeo",
                geoPoint: {
                  _: "inputGeoPoint",
                  lat: obj.latitude,
                  long: obj.longitude
                }
              };
            } else if (obj.type === "contact") {
              sendMessage = {
                _: "inputBotInlineMessageMediaContact",
                phoneNumber: obj.phone,
                firstName: obj.firstName,
                lastName: (_a3 = obj.lastName) != null ? _a3 : "",
                vcard: ""
              };
            } else {
              sendMessage = {
                _: "inputBotInlineMessageMediaAuto",
                message: ""
              };
            }
            let media2;
            if (obj.type !== "geo" && obj.type !== "venue" && obj.type !== "contact") {
              if (typeof obj.media === "string") {
                if (obj.media.match(/^https?:\/\//)) {
                  if (obj.type === "sticker") {
                    throw new MtArgumentError("sticker inline result cannot contain a URL");
                  }
                  let mime;
                  if (obj.type === "video") {
                    mime = "video/mp4";
                  } else if (obj.type === "audio") {
                    mime = (_b2 = obj.mime) != null ? _b2 : "audio/mpeg";
                  } else if (obj.type === "gif") {
                    mime = (_c = obj.mime) != null ? _c : "video/mp4";
                  } else if (obj.type === "voice") {
                    mime = "audio/ogg";
                  } else if (obj.type === "file") {
                    if (!obj.mime) {
                      throw new MtArgumentError("MIME type must be specified for file inline result");
                    }
                    mime = obj.mime;
                  } else {
                    mime = "image/jpeg";
                  }
                  const attributes = [];
                  if ((obj.type === "video" || obj.type === "gif" || obj.type === "photo") && obj.width && obj.height) {
                    if (obj.type !== "photo" && obj.duration) {
                      attributes.push({
                        _: "documentAttributeVideo",
                        w: obj.width,
                        h: obj.height,
                        duration: obj.duration
                      });
                    } else {
                      attributes.push({
                        _: "documentAttributeImageSize",
                        w: obj.width,
                        h: obj.height
                      });
                    }
                  } else if (obj.type === "audio" || obj.type === "voice") {
                    attributes.push({
                      _: "documentAttributeAudio",
                      voice: obj.type === "voice",
                      duration: (_d = obj.duration) != null ? _d : 0,
                      title: obj.type === "audio" ? obj.title : "",
                      performer: obj.type === "audio" ? obj.performer : ""
                    });
                  }
                  attributes.push({
                    _: "documentAttributeFilename",
                    fileName: extractFileName(obj.media)
                  });
                  media2 = {
                    _: "inputWebDocument",
                    url: obj.media,
                    mimeType: mime,
                    size: 0,
                    attributes
                  };
                } else if (obj.type === "photo") {
                  media2 = fileIdToInputPhoto(obj.media);
                } else {
                  media2 = fileIdToInputDocument(obj.media);
                }
              } else {
                media2 = obj.media;
              }
            }
            let title;
            let description;
            if (obj.type === "contact") {
              title = ((_e = obj.lastName) == null ? void 0 : _e.length) ? `${obj.firstName} ${obj.lastName}` : obj.firstName;
            } else if (obj.type !== "sticker") {
              title = obj.title;
            }
            if (obj.type === "audio") {
              description = obj.performer;
            } else if (obj.type === "geo") {
              description = `${obj.latitude} ${obj.longitude}`;
            } else if (obj.type === "venue") {
              description = obj.address;
            } else if (obj.type === "contact") {
              description = obj.phone;
            } else if (obj.type !== "voice" && obj.type !== "sticker") {
              description = obj.description;
            }
            if (!media2 || media2._ === "inputWebDocument") {
              items.push({
                _: "inputBotInlineResult",
                id: obj.id,
                type: obj.type,
                title,
                description,
                content: media2,
                thumb: normalizeThumb(obj, media2 == null ? void 0 : media2.url),
                sendMessage
              });
              continue;
            }
            if (media2._ === "inputPhoto" || media2._ === "inputPhotoEmpty") {
              items.push({
                _: "inputBotInlineResultPhoto",
                id: obj.id,
                type: obj.type,
                photo: media2,
                sendMessage
              });
              continue;
            }
            items.push({
              _: "inputBotInlineResultDocument",
              id: obj.id,
              type: obj.type,
              title,
              description,
              document: media2,
              sendMessage
            });
          }
          return [isGallery && !forceVertical, items];
        });
      }
      const factories = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        _convertToTl,
        article,
        audio,
        contact: contact$1,
        file,
        game,
        geo,
        gif: gif$1,
        photo: photo$3,
        sticker: sticker$1,
        venue,
        video: video$1,
        voice: voice$1
      }, Symbol.toStringTag, { value: "Module" }));
      exports("bj", factories);
      class CollectibleInfo {
        constructor(raw) {
          this.raw = raw;
        }
        /** Date when the item was purchased */
        get purchaseDate() {
          return new Date(this.raw.purchaseDate * 1e3);
        }
        /** Crypto currency used to purchase the item */
        get cryptoCurrency() {
          return this.raw.cryptoCurrency;
        }
        /**
         * Amount of crypto currency used to purchase the item,
         * in the smallest units
         */
        get cryptoAmount() {
          return this.raw.cryptoAmount;
        }
        /** Fiat currency to which the crypto currency was converted */
        get currency() {
          return this.raw.currency;
        }
        /**
         * Converted amount in fiat currency,
         * in the smallest units (e.g. cents)
         */
        get amount() {
          return this.raw.amount;
        }
        /** URL to the collectible on Fragment */
        get url() {
          return this.raw.url;
        }
      }
      exports("bM", CollectibleInfo);
      class TakeoutSession {
        constructor(client2, session) {
          /**
           * Takeout session id
           */
          __publicField(this, "id");
          this.client = client2;
          this.id = session.id;
        }
        /**
         * Make an API call using this takeout session
         *
         * This method just wraps the query into `invokeWithTakeout`
         * and passes the control down to {@link TelegramClient.call}.
         *
         * @param message  RPC method to call
         * @param params  Additional call parameters
         */
        call(message2, params) {
          return __async(this, null, function* () {
            return this.client.call(
              {
                _: "invokeWithTakeout",
                takeoutId: this.id,
                query: message2
              },
              params
            );
          });
        }
        /**
         * Create a proxy over {@link TelegramClient}
         * that will use this takeout session to call methods.
         *
         * You can optionally provide a function to check if some
         * RPC method should be called via a takeout session or directly,
         * otherwise all methods are called through the takeout session.
         *
         * > **Note**: This will return a `Proxy` object that
         * > overrides `call` method. Using this method requires
         * > that your target environment supports `Proxy` and `Reflect` APIs
         *
         * @param predicate
         *     Function that given the RPC call should determine whether
         *     that call should be called via takeout session or not.
         *     Returning `true` will use takeout session, `false` will not.
         */
        createProxy(predicate) {
          const boundCall = predicate ? (obj, params) => {
            if (predicate(obj)) {
              return this.call(obj, params);
            }
            return this.client.call(obj, params);
          } : this.call.bind(this);
          return new Proxy(this.client, {
            get(target, prop, receiver) {
              if (prop === "call")
                return boundCall;
              return Reflect.get(target, prop, receiver);
            }
          });
        }
        /**
         * Finish account takeout session
         *
         * @param success  Whether the data was successfully exported
         */
        finish(success = true) {
          return __async(this, null, function* () {
            const r2 = yield this.call({
              _: "account.finishTakeoutSession",
              success
            });
            assertTrue("account.finishTakeoutSession", r2);
          });
        }
      }
      exports("d4", TakeoutSession);
      class Boost {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Unique ID of this boost */
        get id() {
          return this.raw.id;
        }
        /** Number of boosts this boost is actually representing */
        get count() {
          var _a3;
          return (_a3 = this.raw.multiplier) != null ? _a3 : 1;
        }
        /** Date when this boost was applied */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /** Amount of Telegram Stars that were awarded along with this boost */
        get stars() {
          var _a3;
          return (_a3 = this.raw.stars) != null ? _a3 : null;
        }
        /**
         * Date when this boost will automatically expire.
         *
         * > **Note**: User can still manually cancel the boost before that date
         */
        get expireDate() {
          return new Date(this.raw.expires * 1e3);
        }
        /**
         * Whether this boost was applied because the channel
         * directly gifted a subscription to the user
         */
        get origin() {
          if (this.raw.unclaimed)
            return "unclaimed_gift";
          if (this.raw.gift)
            return "gift";
          if (this.raw.giveaway)
            return "giveaway";
          if (this.raw.userId)
            return "user";
          throw new MtUnsupportedError("Unknown boost origin");
        }
        /**
         * User who is boosting the channel.
         *
         * Only available for some origins
         */
        get user() {
          if (!this.raw.userId)
            return null;
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * ID of the message containing the giveaway where this
         * user has won
         */
        get giveawayMessageId() {
          var _a3;
          return (_a3 = this.raw.giveawayMsgId) != null ? _a3 : null;
        }
        /**
         * The created Telegram Premium gift code, only set if `origin` is not `user`,
         * AND it is either a gift code for the currently logged in user,
         * or if it was already claimed
         */
        get usedGiftSlug() {
          var _a3;
          return (_a3 = this.raw.usedGiftSlug) != null ? _a3 : null;
        }
      }
      exports("bf", Boost);
      memoizeGetters(Boost, ["user"]);
      class BoostSlot {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** ID of this slot */
        get id() {
          return this.raw.slot;
        }
        /**
         * Whether this slot is occupied
         */
        get occupied() {
          return this.raw.peer !== void 0;
        }
        /**
         * Channel that is occupying this slot, if any
         */
        get chat() {
          if (!this.raw.peer)
            return null;
          assertTypeIs("BoostSlot.chat", this.raw.peer, "peerChannel");
          return new Chat(this._peers.chat(this.raw.peer.channelId));
        }
        /**
         * Date when we started boosting this channel
         *
         * If this slot is not occupied, will be `0`
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Date when this boost will automatically expire.
         */
        get expireDate() {
          return new Date(this.raw.expires * 1e3);
        }
        /**
         * If this slot is occupied, returns the date when
         * we can reassing this slot to another channel.
         *
         * If `null`, we can reassign it immediately.
         */
        get cooldownUntil() {
          if (!this.raw.cooldownUntilDate)
            return null;
          return new Date(this.raw.cooldownUntilDate * 1e3);
        }
      }
      exports("bg", BoostSlot);
      memoizeGetters(BoostSlot, ["chat"]);
      class BoostStats {
        constructor(raw) {
          this.raw = raw;
        }
        /** Whether this channel is being boosted by the current user */
        get isBoosting() {
          return this.raw.myBoost;
        }
        /**
         * Current level of boosts in this channel.
         *
         * Currently this maps 1-to-1 to the number of stories
         * the channel can post daily
         */
        get level() {
          return this.raw.level;
        }
        /** Whether this channel is already at the maximum level */
        get isMaxLevel() {
          return this.raw.nextLevelBoosts === void 0;
        }
        /**
         * The number of boosts acquired from created Telegram Premium
         * gift codes and giveaways, only available to channel admins
         */
        get gifts() {
          var _a3;
          return (_a3 = this.raw.giftBoosts) != null ? _a3 : 0;
        }
        /**
         * Number of boosts that were needed for the current level
         */
        get currentLevelBoosts() {
          return this.raw.currentLevelBoosts;
        }
        /** Total number of boosts this channel has */
        get currentBoosts() {
          return this.raw.boosts;
        }
        /**
         * Number of boosts the channel must have to reach the next level
         *
         * `null` if the channel is already at the maximum level
         */
        get nextLevelBoosts() {
          var _a3;
          return (_a3 = this.raw.nextLevelBoosts) != null ? _a3 : null;
        }
        /**
         * Number of boosts the channel needs in addition to the current value
         * to reach the next level
         */
        get remainingBoosts() {
          if (!this.raw.nextLevelBoosts)
            return 0;
          return this.raw.nextLevelBoosts - this.raw.boosts;
        }
        /** If available, total number of subscribers this channel has */
        get totalSubscribers() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.premiumAudience) == null ? void 0 : _a3.total) != null ? _b2 : null;
        }
        /** If available, total number of Premium subscribers this channel has */
        get totalPremiumSubscribers() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.premiumAudience) == null ? void 0 : _a3.part) != null ? _b2 : null;
        }
        /** If available, percentage of this channel's subscribers that are Premium */
        get premiumSubscribersPercentage() {
          if (!this.raw.premiumAudience)
            return null;
          return this.raw.premiumAudience.part / this.raw.premiumAudience.total * 100;
        }
        /** URL that would bring up the boost interface */
        get url() {
          return this.raw.boostUrl;
        }
        /**
         * If {@link isBoosting}, IDs of the boost slots that are
         * currently occupied by this channel
         */
        get boostSlots() {
          var _a3;
          return (_a3 = this.raw.myBoostSlots) != null ? _a3 : [];
        }
      }
      exports("bh", BoostStats);
      class BusinessChatLink {
        constructor(raw) {
          this.raw = raw;
        }
        /** The link itself */
        get link() {
          return this.raw.link;
        }
        /** Text to be inserted into the message input */
        get text() {
          return this.raw.message;
        }
        /** Entities for the text */
        get entities() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.entities) == null ? void 0 : _a3.map((x) => new MessageEntity(x))) != null ? _b2 : [];
        }
        /** Custom title for the link */
        get title() {
          var _a3;
          return (_a3 = this.raw.title) != null ? _a3 : null;
        }
        /** Number of clicks on the link */
        get clicks() {
          return this.raw.views;
        }
      }
      exports("bs", BusinessChatLink);
      memoizeGetters(BusinessChatLink, ["entities"]);
      class StarsTransaction {
        constructor(raw, peers) {
          this.raw = raw;
          this.peers = peers;
        }
        /** ID of the transaction */
        get id() {
          return this.raw.id;
        }
        /** Whether this transaction is a refund */
        get isRefund() {
          return this.raw.refund;
        }
        /**
         * Whether this transaction is outgoing or incoming
         */
        get direction() {
          let isNegative = this.raw.stars.isNegative();
          if (this.raw.refund)
            isNegative = !isNegative;
          return isNegative ? "outgoing" : "incoming";
        }
        /** Absolute amount of stars in the transaction */
        get amount() {
          let res = this.raw.stars;
          if (res.isNegative()) {
            res = res.negate();
          }
          return res;
        }
        /** Date of the transaction */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /** Type of this transaction */
        get type() {
          var _a3;
          switch (this.raw.peer._) {
            case "starsTransactionPeerAppStore":
              return { type: "app_store" };
            case "starsTransactionPeerPlayMarket":
              return { type: "play_market" };
            case "starsTransactionPeerPremiumBot":
              return { type: "premium_bot" };
            case "starsTransactionPeerFragment": {
              if (this.raw.gift) {
                return { type: "fragment" };
              }
              let status;
              if (this.raw.pending) {
                status = "pending";
              } else if (this.raw.failed) {
                status = "failed";
              } else {
                status = "success";
              }
              return {
                type: "fragment_withdraw",
                status,
                date: this.raw.transactionDate ? new Date(this.raw.transactionDate * 1e3) : void 0,
                url: this.raw.transactionUrl
              };
            }
            case "starsTransactionPeerAds":
              return { type: "ads" };
            case "starsTransactionPeer": {
              const peer = parsePeer(this.raw.peer.peer, this.peers);
              if (this.raw.giveawayPostId) {
                return {
                  type: "giveaway",
                  peer,
                  messageId: this.raw.giveawayPostId
                };
              }
              if (this.raw.stargift) {
                return {
                  type: "star_gift",
                  peer,
                  gift: new StarGift(this.raw.stargift)
                };
              }
              if (this.raw.msgId) {
                if (this.raw.reaction) {
                  return {
                    type: "reaction",
                    peer,
                    messageId: this.raw.msgId
                  };
                }
                return {
                  type: "media_purchase",
                  peer,
                  messageId: this.raw.msgId,
                  media: this.raw.extendedMedia ? this.raw.extendedMedia.map((it) => _messageMediaFromTl(this.peers, it)) : void 0
                };
              }
              if (this.raw.subscriptionPeriod) {
                return {
                  type: "channel_subscription",
                  peer,
                  period: this.raw.subscriptionPeriod
                };
              }
              if (peer.type === "user") {
                if (this.raw.gift && !peer.isBot) {
                  return { type: "gift", user: peer };
                }
                if (this.raw.title || this.raw.description || this.raw.photo || this.raw.botPayload) {
                  return {
                    type: "bot_purchase",
                    user: peer,
                    title: (_a3 = this.raw.title) != null ? _a3 : "",
                    description: this.raw.description,
                    payload: this.raw.botPayload,
                    photo: this.raw.photo ? new WebDocument(this.raw.photo) : void 0
                  };
                }
                return { type: "unsupported" };
              }
              return { type: "unsupported" };
            }
            default:
              return { type: "unsupported" };
          }
        }
      }
      exports("cO", StarsTransaction);
      memoizeGetters(StarsTransaction, ["amount", "type"]);
      class StarsStatus {
        constructor(raw) {
          __publicField(this, "peers");
          this.raw = raw;
          this.peers = PeersIndex.from(raw);
        }
        /** Current Telegram Stars balance */
        get balance() {
          return this.raw.balance;
        }
        /**
         * History of Telegram Stars transactions
         */
        get transactions() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.raw.history) == null ? void 0 : _a3.map((it) => new StarsTransaction(it, this.peers))) != null ? _b2 : [];
        }
        /** Next offset of {@link transactions} for pagination */
        get transactionsNextOffset() {
          var _a3;
          return (_a3 = this.raw.nextOffset) != null ? _a3 : null;
        }
      }
      exports("cN", StarsStatus);
      memoizeGetters(StarsStatus, ["transactions"]);
      class PeerStories {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Peer that owns these stories.
         */
        get peer() {
          return parsePeer(this.raw.peer, this._peers);
        }
        /**
         * ID of the last read story of this peer.
         */
        get maxReadId() {
          var _a3;
          return (_a3 = this.raw.maxReadId) != null ? _a3 : 0;
        }
        /**
         * List of peer stories.
         */
        get stories() {
          return this.raw.stories.map((it) => {
            assertTypeIs("PeerStories#stories", it, "storyItem");
            return new Story(it, this._peers);
          });
        }
      }
      exports("cy", PeerStories);
      memoizeGetters(PeerStories, ["peer", "stories"]);
      class StoriesStealthMode {
        constructor(raw) {
          this.raw = raw;
        }
        /** Stealth mode is active until this date */
        get activeUntil() {
          if (!this.raw.activeUntilDate)
            return null;
          return new Date(this.raw.activeUntilDate * 1e3);
        }
        /** Stealth mode is having a cooldown until this date */
        get cooldownUntil() {
          if (!this.raw.cooldownUntilDate)
            return null;
          return new Date(this.raw.cooldownUntilDate * 1e3);
        }
      }
      exports("cS", StoriesStealthMode);
      class AllStories {
        constructor(raw) {
          /** Peers index */
          __publicField(this, "_peers");
          this.raw = raw;
          this._peers = PeersIndex.from(this.raw);
        }
        /** Whether there are more stories to fetch */
        get hasMore() {
          return this.raw.hasMore;
        }
        /** Next offset for pagination */
        get next() {
          return this.raw.state;
        }
        /** Total number of {@link PeerStories} available */
        get total() {
          return this.raw.count;
        }
        /** Peers with their stories */
        get peerStories() {
          return this.raw.peerStories.map((it) => new PeerStories(it, this._peers));
        }
        /** Stealth mode info */
        get stealthMode() {
          return new StoriesStealthMode(this.raw.stealthMode);
        }
      }
      exports("bb", AllStories);
      memoizeGetters(AllStories, ["peerStories", "stealthMode"]);
      class StoryViewer {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Whether this user is in current user's global blacklist */
        get isBlocked() {
          return this.raw.blocked;
        }
        /** Whether current user's stories are hidden from this user */
        get isStoriesBlocked() {
          return this.raw.blockedMyStoriesFrom;
        }
        /** Date when the view has occurred */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /** Reaction this user has left, if any */
        get reactionEmoji() {
          if (!this.raw.reaction)
            return null;
          return toReactionEmoji(this.raw.reaction, true);
        }
        /** Information about the user */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
      }
      exports("d1", StoryViewer);
      memoizeGetters(StoryViewer, ["user"]);
      class StoryRepost {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Whether this peer is in current user's global blacklist */
        get isBlocked() {
          return this.raw.blocked;
        }
        /** Whether current user's stories are hidden from this peer */
        get isStoriesBlocked() {
          return this.raw.blockedMyStoriesFrom;
        }
        /** Kind of the repost */
        get kind() {
          return this.raw._ === "storyViewPublicForward" ? "forward" : "repost";
        }
        /** Date when the repost has happened */
        get date() {
          if (this.raw._ === "storyViewPublicForward" && this.raw.message._ === "message") {
            return new Date(this.raw.message.date * 1e3);
          }
          if (this.raw._ === "storyViewPublicRepost" && this.raw.story._ === "storyItem") {
            return new Date(this.raw.story.date * 1e3);
          }
          throw new MtTypeAssertionError("StoryRepost", "date", "none");
        }
        /**
         * Message that has been forwarded/reposted.
         *
         * Only available if {@link kind} is `forward`.
         */
        get message() {
          if (this.raw._ === "storyViewPublicRepost")
            return null;
          return new Message(this.raw.message, this._peers);
        }
        /**
         * Story that has been reposted.
         *
         * Only available if {@link kind} is `repost`.
         */
        get story() {
          if (this.raw._ === "storyViewPublicForward")
            return null;
          if (this.raw.story._ !== "storyItem")
            return null;
          return new Story(this.raw.story, this._peers);
        }
        /** Information about the peer who has made the reposted */
        get peer() {
          if (this.raw._ === "storyViewPublicForward") {
            return this.message.sender;
          }
          return parsePeer(this.raw.peerId, this._peers);
        }
      }
      exports("c$", StoryRepost);
      class StoryViewersList {
        constructor(raw) {
          __publicField(this, "_peers");
          this.raw = raw;
          this._peers = PeersIndex.from(this.raw);
        }
        /** Next offset for pagination */
        get next() {
          return this.raw.nextOffset;
        }
        /** Total number of views this story has */
        get total() {
          return this.raw.count;
        }
        /** Total number of reactions this story has */
        get reactionsTotal() {
          return this.raw.reactionsCount;
        }
        /** List of viewers */
        get viewers() {
          const res = [];
          for(let   view of this.raw.views) {
            if (view._ === "storyView") {
              res.push(new StoryViewer(view, this._peers));
            }
          }
          return res;
        }
      }
      exports("d2", StoryViewersList);
      memoizeGetters(StoryViewersList, ["viewers"]);
      class BotChatJoinRequestUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Chat ID where the user is requesting to join.
         */
        get chatId() {
          return getMarkedPeerId(this.raw.peer);
        }
        /**
         * Object containing the chat information.
         */
        get chat() {
          return new Chat(this._peers.chat(getBarePeerId(this.raw.peer)));
        }
        /**
         * ID of the user who requested to join the chat.
         */
        get userId() {
          return this.raw.userId;
        }
        /**
         * Object containing the user information.
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * Bio of the user who requested to join the chat.
         */
        get userBio() {
          return this.raw.about;
        }
        /**
         * Date when the request was sent.
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Invite link used to request joining.
         */
        get invite() {
          return new ChatInviteLink(this.raw.invite);
        }
      }
      exports("bi", BotChatJoinRequestUpdate);
      memoizeGetters(BotChatJoinRequestUpdate, ["chat", "user", "invite"]);
      class BotStoppedUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * ID of the user who stopped or restarted the bot
         */
        get userId() {
          return this.raw.userId;
        }
        /**
         * User who stopped or restarted the bot
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * Whether the bot is currently stopped.
         *
         * If `true`, then the user has stopped the bot.
         * If `false`, then the user has re-started the bot.
         */
        get stopped() {
          return this.raw.stopped;
        }
      }
      exports("bp", BotStoppedUpdate);
      memoizeGetters(BotStoppedUpdate, ["user"]);
      class BaseCallbackQuery {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * ID of this callback query
         */
        get id() {
          return this.raw.queryId;
        }
        /**
         * User who has pressed the button
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * Unique ID, that represents the chat to which the inline
         * message was sent. Does *not* contain actual chat ID.
         */
        get uniqueChatId() {
          return this.raw.chatInstance;
        }
        /**
         * Data that was contained in the callback button, if any
         *
         * Note that this field is defined by the client, and a bad
         * client can send arbitrary data in this field.
         */
        get data() {
          var _a3;
          return (_a3 = this.raw.data) != null ? _a3 : null;
        }
        /**
         * Data that was contained in the callback button, if any,
         * parsed as a UTF8 string
         *
         * Note that this field is defined by the client, and a bad
         * client can send arbitrary data in this field.
         */
        get dataStr() {
          if (!this.raw.data)
            return null;
          return getPlatform().utf8Decode(this.raw.data);
        }
        /**
         * In case this message was from {@link InputInlineResultGame},
         * or the button was {@link BotKeyboard.game},
         * short name of the game that should be returned.
         */
        get game() {
          var _a3;
          if (this.raw._ === "updateBusinessBotCallbackQuery")
            return null;
          return (_a3 = this.raw.gameShortName) != null ? _a3 : null;
        }
      }
      class CallbackQuery extends BaseCallbackQuery {
        constructor(raw, _peers) {
          super(raw, _peers);
          this.raw = raw;
        }
        /**
         * Chat where the originating message was sent
         */
        get chat() {
          if (this.raw._ !== "updateBotCallbackQuery") {
            throw new MtArgumentError("Cannot get message id for inline callback");
          }
          return new Chat(this._peers.get(this.raw.peer));
        }
        /**
         * Identifier of the message containing the button which was clicked.
         */
        get messageId() {
          return this.raw.msgId;
        }
      }
      exports("bx", CallbackQuery);
      memoizeGetters(CallbackQuery, ["user", "dataStr", "chat"]);
      class InlineCallbackQuery extends BaseCallbackQuery {
        constructor(raw, _peers) {
          super(raw, _peers);
          this.raw = raw;
        }
        /**
         * Identifier of the previously sent inline message,
         * that contained the button which was clicked.
         * This ID can be used in `TelegramClient.editInlineMessage`
         */
        get inlineMessageId() {
          return this.raw.msgId;
        }
        /**
         * Identifier of the previously sent inline message,
         * that contained the button which was clicked,
         * as a TDLib and Bot API compatible string.
         * Can be used instead of {@link inlineMessageId} in
         * case you want to store it in some storage.
         */
        get inlineMessageIdStr() {
          return encodeInlineMessageId(this.raw.msgId);
        }
      }
      exports("c4", InlineCallbackQuery);
      memoizeGetters(InlineCallbackQuery, ["user", "dataStr", "inlineMessageIdStr"]);
      class BusinessCallbackQuery extends BaseCallbackQuery {
        constructor(raw, _peers) {
          super(raw, _peers);
          this.raw = raw;
        }
        /** ID of the business connection */
        get connectionId() {
          return this.raw.connectionId;
        }
        /** Message containing the button */
        get message() {
          return new Message(this.raw.message, this._peers);
        }
        /** Message that {@link message} is a reply to (if any) */
        get replyToMessage() {
          if (!this.raw.replyToMessage)
            return null;
          return new Message(this.raw.replyToMessage, this._peers);
        }
      }
      exports("br", BusinessCallbackQuery);
      memoizeGetters(BusinessCallbackQuery, ["user", "dataStr", "message", "replyToMessage"]);
      class ChatJoinRequestUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        // in this update, peers index only contains
        // recent requesters, not the chat
        /**
         * Marked ID of the chat/channel
         */
        get chatId() {
          return getMarkedPeerId(this.raw.peer);
        }
        /**
         * IDs of the users who recently requested to join the chat
         */
        get recentRequestersIds() {
          return this.raw.recentRequesters;
        }
        /**
         * Users who recently requested to join the chat
         */
        get recentRequesters() {
          return this.raw.recentRequesters.map((id2) => new User(this._peers.user(id2)));
        }
        /**
         * Total number of pending requests
         */
        get totalPending() {
          return this.raw.requestsPending;
        }
      }
      exports("bC", ChatJoinRequestUpdate);
      memoizeGetters(ChatJoinRequestUpdate, ["recentRequesters"]);
      function extractPeerId(raw) {
        if (!raw)
          return 0;
        if (tl.tl.isAnyChatParticipant(raw)) {
          return raw.userId;
        }
        switch (raw._) {
          case "channelParticipant":
          case "channelParticipantSelf":
          case "channelParticipantCreator":
          case "channelParticipantAdmin":
            return raw.userId;
          default:
            return getMarkedPeerId(raw.peer);
        }
      }
      class ChatMemberUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Date of the event
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * Whether this is an update about current user
         */
        get isSelf() {
          return this.user.isSelf;
        }
        /**
         * Type of the update
         *
         * @link ChatMemberUpdate.Type
         */
        get type() {
          const old = this.raw.prevParticipant;
          const cur = this.raw.newParticipant;
          const oldId = extractPeerId(old);
          const curId = extractPeerId(cur);
          const actorId = this.raw.actorId;
          if (!old && cur) {
            return actorId === curId ? "joined" : "added";
          }
          if (old && !cur) {
            if (actorId === oldId)
              return "left";
            if (old._ === "channelParticipantBanned") {
              return "unkicked";
            }
            return "kicked";
          }
          if (!old || !cur)
            return "other";
          switch (old._) {
            case "chatParticipant":
            case "channelParticipant":
              switch (cur._) {
                case "chatParticipantAdmin":
                case "channelParticipantAdmin":
                  return "promoted";
                case "channelParticipantBanned":
                  if (cur.left)
                    return "kicked";
                  return "restricted";
              }
              break;
            case "chatParticipantCreator":
            case "channelParticipantCreator":
              return "old_owner";
          }
          switch (cur._) {
            case "chatParticipantCreator":
            case "channelParticipantCreator":
              return "new_owner";
          }
          if (old._ === "channelParticipantBanned" && cur._ === "channelParticipant") {
            return "unrestricted";
          }
          if (old._ === "channelParticipantBanned" && cur._ === "channelParticipantAdmin") {
            return "unrestricted_promoted";
          }
          if (old._ === "channelParticipantAdmin" && cur._ === "channelParticipant") {
            return "demoted";
          }
          if (old._ === "channelParticipantAdmin" && cur._ === "channelParticipantBanned") {
            return cur.left ? "demoted_kicked" : "demoted_restricted";
          }
          if (old._ === "channelParticipantBanned" && cur._ === "channelParticipantBanned" && old.left !== cur.left) {
            if (actorId === curId) {
              return cur.left ? "left" : "joined";
            }
            return cur.left ? "kicked" : "added";
          }
          return "other";
        }
        /**
         * Chat in which this event has occurred
         */
        get chat() {
          const id2 = this.raw._ === "updateChannelParticipant" ? this.raw.channelId : this.raw.chatId;
          return new Chat(this._peers.chat(id2));
        }
        /**
         * Performer of the action which resulted in this update.
         *
         * Can be chat/channel administrator or the {@link user} themself.
         */
        get actor() {
          return new User(this._peers.user(this.raw.actorId));
        }
        /**
         * User representing the chat member whose status was changed.
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /** Whether this is a self-made action (i.e. actor == user) */
        get isSelfMade() {
          return this.raw.actorId === this.raw.userId;
        }
        /**
         * Previous (old) information about chat member.
         */
        get oldMember() {
          if (!this.raw.prevParticipant)
            return null;
          return new ChatMember(this.raw.prevParticipant, this._peers);
        }
        /**
         * Current (new) information about chat member.
         */
        get newMember() {
          if (!this.raw.newParticipant)
            return null;
          return new ChatMember(this.raw.newParticipant, this._peers);
        }
        /**
         * In case this is a "join" event, invite link that was used to join (if any)
         */
        get inviteLink() {
          if (!this.raw.invite)
            return null;
          return new ChatInviteLink(this.raw.invite);
        }
      }
      exports("bF", ChatMemberUpdate);
      memoizeGetters(ChatMemberUpdate, ["type", "chat", "actor", "user", "oldMember", "newMember", "inviteLink"]);
      const PEER_TYPE_MAP = {
        inlineQueryPeerTypeBroadcast: "channel",
        inlineQueryPeerTypeChat: "group",
        inlineQueryPeerTypeMegagroup: "supergroup",
        inlineQueryPeerTypePM: "user",
        inlineQueryPeerTypeSameBotPM: "bot",
        inlineQueryPeerTypeBotPM: "bot"
      };
      class InlineQuery {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Unique query ID
         */
        get id() {
          return this.raw.queryId;
        }
        /**
         * User who sent this query
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * Text of the query (0-512 characters)
         */
        get query() {
          return this.raw.query;
        }
        /**
         * Attached geolocation.
         *
         * Only used in case the bot requested user location
         */
        get location() {
          var _a3;
          if (((_a3 = this.raw.geo) == null ? void 0 : _a3._) !== "geoPoint")
            return null;
          return new Location(this.raw.geo);
        }
        /**
         * Inline query scroll offset, controlled by the bot
         */
        get offset() {
          return this.raw.offset;
        }
        /**
         * Peer type from which this query was sent.
         *
         * Can be:
         *  - `bot`: Query was sent in this bot's PM
         *  - `user`: Query was sent in somebody's PM
         *  - `group`: Query was sent in a legacy group
         *  - `supergroup`: Query was sent in a supergroup
         *  - `channel`: Query was sent in a channel
         *  - `null`, in case this information is not available
         */
        get peerType() {
          return this.raw.peerType ? PEER_TYPE_MAP[this.raw.peerType._] : null;
        }
      }
      exports("c5", InlineQuery);
      memoizeGetters(InlineQuery, ["user", "location"]);
      class BotReactionUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Chat where the reaction has been changed
         */
        get chat() {
          return Chat._parseFromPeer(this.raw.peer, this._peers);
        }
        /**
         * ID of the message where the reaction has been changed
         */
        get messageId() {
          return this.raw.msgId;
        }
        /**
         * Date when the reaction has been changed
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * ID of the user who has set/removed the reaction
         */
        get actor() {
          return parsePeer(this.raw.actor, this._peers);
        }
        /**
         * List of reactions before the change
         */
        get before() {
          return this.raw.oldReactions.map((it) => toReactionEmoji(it));
        }
        /**
         * List of reactions after the change
         */
        get after() {
          return this.raw.newReactions.map((it) => toReactionEmoji(it));
        }
      }
      exports("bo", BotReactionUpdate);
      memoizeGetters(BotReactionUpdate, ["chat", "actor", "before", "after"]);
      class BotReactionCountUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Chat where the reaction has been changed
         */
        get chat() {
          return Chat._parseFromPeer(this.raw.peer, this._peers);
        }
        /**
         * ID of the message where the reaction has been changed
         */
        get messageId() {
          return this.raw.msgId;
        }
        /**
         * Date when the reaction has been changed
         */
        get date() {
          return new Date(this.raw.date * 1e3);
        }
        /**
         * The new list of reactions to the message
         */
        get reactions() {
          return this.raw.reactions.map((it) => new ReactionCount(it));
        }
      }
      exports("bn", BotReactionCountUpdate);
      memoizeGetters(BotReactionCountUpdate, ["chat"]);
      class BusinessMessage extends Message {
        constructor(update, _peers) {
          super(update.message, _peers);
          this.update = update;
          this._peers = _peers;
        }
        /**
         * Unique identifier of the business connection from which the message was received.
         */
        get connectionId() {
          return this.update.connectionId;
        }
        get groupedIdUnique() {
          const superGroupedIdUnique = super.groupedIdUnique;
          if (!superGroupedIdUnique) {
            return null;
          }
          return `${super.groupedIdUnique}|${this.update.connectionId}`;
        }
        /** The replied message (if any) */
        get replyTo() {
          return this.update.replyToMessage ? new Message(this.update.replyToMessage, this._peers) : null;
        }
      }
      exports("bv", BusinessMessage);
      class ChosenInlineResult {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Unique identifier of the chosen result,
         * as set in `InputInlineResult.id`
         */
        get id() {
          return this.raw.id;
        }
        /**
         * User who has chosen the query
         */
        get user() {
          return new User(this._peers.user(this.raw.userId));
        }
        /**
         * The query that was previously sent by the user,
         * which was used to obtain this result
         */
        get query() {
          return this.raw.query;
        }
        /**
         * Sender location, only applicable to bots that requested user location
         */
        get location() {
          var _a3;
          if (((_a3 = this.raw.geo) == null ? void 0 : _a3._) !== "geoPoint")
            return null;
          return new Location(this.raw.geo);
        }
        /**
         * Identifier of the sent inline message,
         * which can be used in `TelegramClient.editInlineMessage`
         *
         * > **Note**: this is only available in case the `InputInlineMessage`
         * > contained a reply keyboard markup.
         */
        get messageId() {
          var _a3;
          return (_a3 = this.raw.msgId) != null ? _a3 : null;
        }
        /**
         * Identifier of the sent inline message
         * as a TDLib and Bot API compatible string.
         * Can be used instead of {@link messageId} in
         * case you want to store it in some storage.
         *
         * > **Note**: this is only available in case the `InputInlineMessage`
         * > contained a reply keyboard markup.
         */
        get messageIdStr() {
          if (!this.raw.msgId)
            return null;
          return encodeInlineMessageId(this.raw.msgId);
        }
      }
      exports("bL", ChosenInlineResult);
      memoizeGetters(ChosenInlineResult, ["user", "location"]);
      class DeleteBusinessMessageUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /** Unique identifier of the business connection */
        get connectionId() {
          return this.raw.connectionId;
        }
        /**
         * IDs of the messages which were deleted
         */
        get messageIds() {
          return this.raw.messages;
        }
        /**
         * Chat where the messages were deleted
         */
        get chat() {
          return Chat._parseFromPeer(this.raw.peer, this._peers);
        }
      }
      exports("bP", DeleteBusinessMessageUpdate);
      memoizeGetters(DeleteBusinessMessageUpdate, ["chat"]);
      class DeleteMessageUpdate {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * IDs of the messages which were deleted
         */
        get messageIds() {
          return this.raw.messages;
        }
        /**
         * Marked ID of the channel where the messages were deleted
         */
        get channelId() {
          return this.raw._ === "updateDeleteChannelMessages" ? toggleChannelIdMark(this.raw.channelId) : null;
        }
      }
      exports("bQ", DeleteMessageUpdate);
      class DeleteStoryUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Peer that owns these stories.
         */
        get peer() {
          return parsePeer(this.raw.peer, this._peers);
        }
        /**
         * ID of the deleted story
         */
        get storyId() {
          return this.raw.story.id;
        }
      }
      exports("bR", DeleteStoryUpdate);
      memoizeGetters(DeleteStoryUpdate, ["peer"]);
      class HistoryReadUpdate {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * Whether this update is about an "outbox" read
         * (i.e. a message you have sent earlier was read)
         */
        get isOutbox() {
          switch (this.raw._) {
            case "updateReadChannelDiscussionOutbox":
            case "updateReadHistoryOutbox":
            case "updateReadChannelOutbox":
              return true;
            default:
              return false;
          }
        }
        /**
         * Whether this update is about messages in a thread
         * (e.g. a comments thread or a topic in a forum)
         */
        get isDiscussion() {
          switch (this.raw._) {
            case "updateReadChannelDiscussionOutbox":
            case "updateReadChannelDiscussionInbox":
              return true;
            default:
              return false;
          }
        }
        /**
         * Marked peer ID of the chat where the messages were read.
         */
        get chatId() {
          switch (this.raw._) {
            case "updateReadHistoryOutbox":
            case "updateReadHistoryInbox":
              return getMarkedPeerId(this.raw.peer);
            case "updateReadChannelOutbox":
            case "updateReadChannelInbox":
            case "updateReadChannelDiscussionOutbox":
            case "updateReadChannelDiscussionInbox":
              return toggleChannelIdMark(this.raw.channelId);
          }
        }
        /**
         * For inbox updates (i.e. `isOutbox = false`),
         * number of messages that are still unread in the chat.
         *
         * For other updates, `0`
         */
        get unreadCount() {
          switch (this.raw._) {
            case "updateReadHistoryInbox":
            case "updateReadChannelInbox":
              return this.raw.stillUnreadCount;
            case "updateReadChannelDiscussionInbox":
            case "updateReadHistoryOutbox":
            case "updateReadChannelOutbox":
            case "updateReadChannelDiscussionOutbox":
              return 0;
          }
        }
        /**
         * ID of the last read message.
         *
         * Note that if `isDiscussion == true`, this contains the ID of the
         * last read message inside that thread, and not in the group itself.
         */
        get maxReadId() {
          switch (this.raw._) {
            case "updateReadHistoryOutbox":
            case "updateReadHistoryInbox":
            case "updateReadChannelOutbox":
            case "updateReadChannelInbox":
              return this.raw.maxId;
            case "updateReadChannelDiscussionOutbox":
            case "updateReadChannelDiscussionInbox":
              return this.raw.readMaxId;
          }
        }
        /**
         * ID of the thread/topic (i.e. ID of the top message).
         *
         * For non-thread updates, 0.
         */
        get threadId() {
          switch (this.raw._) {
            case "updateReadHistoryOutbox":
            case "updateReadHistoryInbox":
            case "updateReadChannelOutbox":
            case "updateReadChannelInbox":
              return 0;
            case "updateReadChannelDiscussionOutbox":
            case "updateReadChannelDiscussionInbox":
              return this.raw.topMsgId;
          }
        }
      }
      exports("c1", HistoryReadUpdate);
      class PollUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Unique poll ID
         */
        get pollId() {
          return this.raw.pollId;
        }
        /**
         * Whether this is a shortened version of update, not containing the poll itself.
         */
        get isShort() {
          return this.raw.poll === void 0;
        }
        /**
         * The poll.
         *
         * When {@link isShort} is set, mtcute creates a stub poll
         * with empty question, answers and flags
         * (like `quiz`, `public`, etc.)
         *
         * If you need access to them, you should
         * map the {@link pollId} with full poll on your side
         * (e.g. in a database) and fetch from there.
         *
         * Bot API and TDLib do basically the same internally,
         * and thus are able to always provide them,
         * but mtcute currently does not have a way to do that.
         */
        get poll() {
          var _a3, _b2;
          let poll2 = this.raw.poll;
          if (!poll2) {
            poll2 = {
              _: "poll",
              id: this.raw.pollId,
              question: { _: "textWithEntities", text: "", entities: [] },
              answers: (_b2 = (_a3 = this.raw.results.results) == null ? void 0 : _a3.map((res) => ({
                _: "pollAnswer",
                text: { _: "textWithEntities", text: "", entities: [] },
                option: res.option
              }))) != null ? _b2 : []
            };
          }
          return new Poll(poll2, this._peers, this.raw.results);
        }
      }
      exports("cD", PollUpdate);
      memoizeGetters(PollUpdate, ["poll"]);
      class PollVoteUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Unique poll ID
         */
        get pollId() {
          return this.raw.pollId;
        }
        /**
         * Peer who has voted
         */
        get peer() {
          return parsePeer(this.raw.peer, this._peers);
        }
        /**
         * Answers that the user has chosen.
         *
         * Note that due to incredible Telegram APIs, you
         * have to have the poll cached to be able to properly
         * tell which answers were chosen, since in the API
         * there are just arbitrary `Buffer`s, which are
         * defined by the client.
         *
         * However, most of the major implementations
         * (tested with TDLib and Bot API, official apps
         * for Android, Desktop, iOS/macOS) and mtcute
         * (by default) create `option` as a one-byte `Buffer`,
         * incrementing from `48` (ASCII `0`) up to `57` (ASCII `9`),
         * and ASCII representation would define index in the array.
         * Meaning, if `chosen[0][0] === 48` or `chosen[0].toString() === '0'`,
         * then the first answer (indexed with `0`) was chosen. To get the index,
         * you simply subtract `48` from the first byte.
         *
         * This might break at any time, but seems to be consistent for now.
         * To get chosen answer indexes derived as before, use {@link chosenIndexesAuto}.
         */
        get chosen() {
          return this.raw.options;
        }
        /**
         * Indexes of the chosen answers, derived based on observations
         * described in {@link chosen}.
         * This might break at any time, but seems to be consistent for now.
         *
         * If something does not add up, {@link MtUnsupportedError} is thrown
         */
        get chosenIndexesAuto() {
          return this.raw.options.map((buf) => {
            if (buf.length > 1) {
              throw new MtUnsupportedError("option had >1 byte");
            }
            if (buf[0] < 48 || buf[0] > 57) {
              throw new MtUnsupportedError("option had first byte out of 0-9 range");
            }
            return buf[0] - 48;
          });
        }
      }
      exports("cE", PollVoteUpdate);
      memoizeGetters(PollVoteUpdate, ["peer"]);
      class PreCheckoutQuery {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * ID of the query
         */
        get queryId() {
          return this.raw.queryId;
        }
        /**
         * ID of the user who sent the query
         */
        get userId() {
          return this.raw.userId;
        }
        /**
         * User who sent the query
         */
        get user() {
          return new User(this._peers.user(this.userId));
        }
        /**
         * Bot-defined payload of the original invoice
         * (see {@link InputMediaInvoice.payload})
         */
        get payload() {
          return this.raw.payload;
        }
        /**
         * User-provided payment info (like name, phone, shipping address, etc.)
         */
        get paymentInfo() {
          if (!this.raw.info)
            return null;
          return this.raw.info;
        }
        /**
         * Currency of the payment
         */
        get currency() {
          return this.raw.currency;
        }
        /**
         * Total price of the payment
         */
        get totalAmount() {
          return this.raw.totalAmount;
        }
      }
      exports("cF", PreCheckoutQuery);
      memoizeGetters(PreCheckoutQuery, ["user"]);
      class StoryUpdate {
        constructor(raw, _peers) {
          this.raw = raw;
          this._peers = _peers;
        }
        /**
         * Peer that owns these stories.
         */
        get peer() {
          return parsePeer(this.raw.peer, this._peers);
        }
        /**
         * Story that was posted or edited.
         */
        get story() {
          assertTypeIs("StoryUpdate.story", this.raw.story, "storyItem");
          return new Story(this.raw.story, this._peers);
        }
      }
      exports("d0", StoryUpdate);
      memoizeGetters(StoryUpdate, ["peer", "story"]);
      class UserStatusUpdate {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * ID of the user whose status has updated
         */
        get userId() {
          return this.raw.userId;
        }
        get _parsedStatus() {
          return User.parseStatus(this.raw.status);
        }
        /**
         * User's new Last Seen & Online status
         */
        get status() {
          return this._parsedStatus.status;
        }
        /**
         * Last time this user was seen online.
         * Only available if {@link status} is `offline`
         */
        get lastOnline() {
          return this._parsedStatus.lastOnline;
        }
        /**
         * Time when this user will automatically go offline.
         * Only available if {@link status} is `online`
         */
        get nextOffline() {
          return this._parsedStatus.nextOffline;
        }
      }
      exports("df", UserStatusUpdate);
      memoizeGetters(UserStatusUpdate, ["_parsedStatus"]);
      class UserTypingUpdate {
        constructor(raw) {
          this.raw = raw;
        }
        /**
         * ID of the user whose typing status changed
         */
        get userId() {
          return this.raw._ === "updateUserTyping" ? this.raw.userId : getBarePeerId(this.raw.fromId);
        }
        /**
         * Marked ID of the chat where the user is typing,
         *
         * If the user is typing in PMs, this will
         * equal to {@link userId}
         */
        get chatId() {
          switch (this.raw._) {
            case "updateUserTyping":
              return this.raw.userId;
            case "updateChatUserTyping":
              return -this.raw.chatId;
            case "updateChannelUserTyping":
              return toggleChannelIdMark(this.raw.channelId);
          }
        }
        /**
         * Type of the chat where this event has occurred
         */
        get chatType() {
          switch (this.raw._) {
            case "updateUserTyping":
              return "user";
            case "updateChatUserTyping":
              return "chat";
            case "updateChannelUserTyping":
              return "channel";
          }
        }
        /**
         * Current typing status
         */
        get status() {
          switch (this.raw.action._) {
            case "sendMessageTypingAction":
              return "typing";
            case "sendMessageCancelAction":
              return "cancel";
            case "sendMessageRecordVideoAction":
              return "record_video";
            case "sendMessageUploadVideoAction":
              return "upload_video";
            case "sendMessageRecordAudioAction":
              return "record_voice";
            case "sendMessageUploadAudioAction":
              return "upload_voice";
            case "sendMessageUploadPhotoAction":
              return "upload_photo";
            case "sendMessageUploadDocumentAction":
              return "upload_document";
            case "sendMessageGeoLocationAction":
              return "geo";
            case "sendMessageGamePlayAction":
              return "game";
            case "sendMessageChooseContactAction":
              return "contact";
            case "sendMessageRecordRoundAction":
              return "record_round";
            case "sendMessageUploadRoundAction":
              return "upload_round";
            case "speakingInGroupCallAction":
              return "speak_call";
            case "sendMessageHistoryImportAction":
              return "history_import";
            case "sendMessageChooseStickerAction":
              return "sticker";
            case "sendMessageEmojiInteraction":
              return "interaction";
            case "sendMessageEmojiInteractionSeen":
              return "interaction_seen";
            default:
              assertNever$1(this.raw.action);
          }
        }
      }
      exports("dg", UserTypingUpdate);
      function _parseUpdate(update, peers) {
        switch (update._) {
          case "updateNewMessage":
          case "updateNewChannelMessage":
          case "updateNewScheduledMessage":
            return {
              name: "new_message",
              data: new Message(update.message, peers, update._ === "updateNewScheduledMessage")
            };
          case "updateEditMessage":
          case "updateEditChannelMessage":
            return { name: "edit_message", data: new Message(update.message, peers) };
          case "updateChatParticipant":
          case "updateChannelParticipant":
            return { name: "chat_member", data: new ChatMemberUpdate(update, peers) };
          case "updateBotInlineQuery":
            return { name: "inline_query", data: new InlineQuery(update, peers) };
          case "updateBotInlineSend":
            return { name: "chosen_inline_result", data: new ChosenInlineResult(update, peers) };
          case "updateBotCallbackQuery":
            return { name: "callback_query", data: new CallbackQuery(update, peers) };
          case "updateInlineBotCallbackQuery":
            return { name: "inline_callback_query", data: new InlineCallbackQuery(update, peers) };
          case "updateMessagePoll":
            return { name: "poll", data: new PollUpdate(update, peers) };
          case "updateMessagePollVote":
            return { name: "poll_vote", data: new PollVoteUpdate(update, peers) };
          case "updateUserStatus":
            return { name: "user_status", data: new UserStatusUpdate(update) };
          case "updateChannelUserTyping":
          case "updateChatUserTyping":
          case "updateUserTyping":
            return { name: "user_typing", data: new UserTypingUpdate(update) };
          case "updateDeleteChannelMessages":
          case "updateDeleteMessages":
            return { name: "delete_message", data: new DeleteMessageUpdate(update) };
          case "updateReadHistoryInbox":
          case "updateReadHistoryOutbox":
          case "updateReadChannelInbox":
          case "updateReadChannelOutbox":
          case "updateReadChannelDiscussionInbox":
          case "updateReadChannelDiscussionOutbox":
            return { name: "history_read", data: new HistoryReadUpdate(update) };
          case "updateBotStopped":
            return { name: "bot_stopped", data: new BotStoppedUpdate(update, peers) };
          case "updateBotChatInviteRequester":
            return { name: "bot_chat_join_request", data: new BotChatJoinRequestUpdate(update, peers) };
          case "updatePendingJoinRequests":
            return { name: "chat_join_request", data: new ChatJoinRequestUpdate(update, peers) };
          case "updateBotPrecheckoutQuery":
            return { name: "pre_checkout_query", data: new PreCheckoutQuery(update, peers) };
          case "updateStory": {
            const story2 = update.story;
            if (story2._ === "storyItemDeleted") {
              return { name: "delete_story", data: new DeleteStoryUpdate(update, peers) };
            }
            return {
              name: "story",
              data: new StoryUpdate(update, peers)
            };
          }
          case "updateBotMessageReaction":
            return { name: "bot_reaction", data: new BotReactionUpdate(update, peers) };
          case "updateBotMessageReactions":
            return { name: "bot_reaction_count", data: new BotReactionCountUpdate(update, peers) };
          case "updateBotBusinessConnect":
            return { name: "business_connection", data: new BusinessConnection(update.connection, peers) };
          case "updateBotNewBusinessMessage":
            return { name: "new_business_message", data: new BusinessMessage(update, peers) };
          case "updateBotEditBusinessMessage":
            return { name: "edit_business_message", data: new BusinessMessage(update, peers) };
          case "updateBotDeleteBusinessMessage":
            return { name: "delete_business_message", data: new DeleteBusinessMessageUpdate(update, peers) };
          case "updateBusinessBotCallbackQuery":
            return { name: "business_callback_query", data: new BusinessCallbackQuery(update, peers) };
          default:
            return null;
        }
      }
      function makeParsedUpdateHandler(params) {
        const { messageGroupingInterval, onUpdate, onRawUpdate = () => {
        } } = params;
        if (!messageGroupingInterval) {
          return (update, peers) => {
            const parsed = _parseUpdate(update, peers);
            onRawUpdate(update, peers);
            if (parsed)
              onUpdate(parsed);
          };
        }
        const pending2 = /* @__PURE__ */ new Map();
        return (update, peers) => {
          const parsed = _parseUpdate(update, peers);
          onRawUpdate(update, peers);
          if (parsed) {
            if (parsed.name === "new_message" || parsed.name === "new_business_message") {
              const group = parsed.data.groupedIdUnique;
              if (group) {
                const isBusiness = parsed.name === "new_business_message";
                const pendingGroup = pending2.get(group);
                if (pendingGroup) {
                  pendingGroup[0].push(parsed.data);
                } else {
                  const messages = [parsed.data];
                  const timeout = setTimeoutWrap(() => {
                    pending2.delete(group);
                    if (isBusiness) {
                      onUpdate({ name: "business_message_group", data: messages });
                    } else {
                      onUpdate({ name: "message_group", data: messages });
                    }
                  }, messageGroupingInterval);
                  pending2.set(group, [messages, timeout]);
                }
                return;
              }
            }
            onUpdate(parsed);
          }
        };
      }
      function _onAuthorization(client2, auth) {
        return __async(this, null, function* () {
          const user = yield client2.notifyLoggedIn(auth);
          return new User(user);
        });
      }
      function isSelfPeer(client2, peer) {
        const state = client2.storage.self.getCached();
        if (!state)
          return false;
        switch (peer._) {
          case "inputPeerSelf":
          case "inputUserSelf":
            return true;
          case "inputPeerUser":
          case "inputPeerUserFromMessage":
          case "inputUser":
          case "inputUserFromMessage":
          case "peerUser":
            return peer.userId === state.userId;
          default:
            return false;
        }
      }
      function checkPassword(client2, password) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "auth.checkPassword",
            password: yield client2.computeSrpParams(
              yield client2.call({
                _: "account.getPassword"
              }),
              password
            )
          });
          return _onAuthorization(client2, res);
        });
      }
      function getPasswordHint(client2) {
        return client2.call({
          _: "account.getPassword"
        }).then((res) => {
          var _a3;
          return (_a3 = res.hint) != null ? _a3 : null;
        });
      }
      function logOut(client2) {
        return __async(this, null, function* () {
          const res = yield client2.call({ _: "auth.logOut" });
          yield client2.notifyLoggedOut();
          return {
            futureAuthToken: res.futureAuthToken
          };
        });
      }
      function recoverPassword(client2, params) {
        return __async(this, null, function* () {
          const { recoveryCode } = params;
          const res = yield client2.call({
            _: "auth.recoverPassword",
            code: recoveryCode
          });
          return _onAuthorization(client2, res);
        });
      }
      function resendCode(client2, params) {
        return __async(this, null, function* () {
          const { phone, phoneCodeHash, abortSignal } = params;
          const res = yield client2.call(
            {
              _: "auth.resendCode",
              phoneNumber: normalizePhoneNumber(phone),
              phoneCodeHash
            },
            { abortSignal }
          );
          assertTypeIs("sendCode", res, "auth.sentCode");
          return new SentCode(res);
        });
      }
      function getMe(client2) {
        return client2.call({
          _: "users.getUsers",
          id: [
            {
              _: "inputUserSelf"
            }
          ]
        }).then((_0) => __async(this, [_0], function* ([user]) {
          assertTypeIs("getMe (@ users.getUsers)", user, "user");
          yield client2.storage.self.storeFrom(user);
          return new User(user);
        }));
      }
      function sendCode(client2, params) {
        return __async(this, null, function* () {
          const phone = normalizePhoneNumber(params.phone);
          const { id: id2, hash } = yield client2.getApiCrenetials();
          const res = yield client2.call(
            {
              _: "auth.sendCode",
              phoneNumber: phone,
              apiId: id2,
              apiHash: hash,
              settings: __spreadValues({
                _: "codeSettings",
                logoutTokens: params.futureAuthTokens
              }, params.codeSettings)
            },
            { abortSignal: params.abortSignal }
          );
          assertTypeIs("sendCode", res, "auth.sentCode");
          return new SentCode(res);
        });
      }
      function signIn(client2, params) {
        return __async(this, null, function* () {
          const { phone, phoneCodeHash, phoneCode, abortSignal } = params;
          const res = yield client2.call(
            {
              _: "auth.signIn",
              phoneNumber: normalizePhoneNumber(phone),
              phoneCodeHash,
              phoneCode
            },
            { abortSignal }
          );
          return _onAuthorization(client2, res);
        });
      }
      function signInBot(client2, token) {
        return __async(this, null, function* () {
          const { id: id2, hash } = yield client2.getApiCrenetials();
          const res = yield client2.call({
            _: "auth.importBotAuthorization",
            flags: 0,
            apiId: id2,
            apiHash: hash,
            botAuthToken: token
          });
          return _onAuthorization(client2, res);
        });
      }
      function signInQr(client2, params) {
        return __async(this, null, function* () {
          const { onUrlUpdated, abortSignal, onQrScanned } = params;
          let waiter;
          const originalHandler = client2.getServerUpdateHandler();
          const onUpdate = (upd) => {
            if (upd._ === "updateShort" && upd.update._ === "updateLoginToken") {
              onQrScanned == null ? void 0 : onQrScanned();
              waiter == null ? void 0 : waiter.resolve();
              client2.onServerUpdate(originalHandler);
            }
          };
          client2.onServerUpdate(onUpdate);
          abortSignal == null ? void 0 : abortSignal.addEventListener("abort", () => {
            client2.onServerUpdate(originalHandler);
            waiter == null ? void 0 : waiter.reject(abortSignal.reason);
          });
          function handle2fa(input) {
            return __async(this, null, function* () {
              var _a3;
              const isDynamic = typeof input === "function";
              while (true) {
                const password = yield resolveMaybeDynamic(input);
                try {
                  return yield checkPassword(client2, password);
                } catch (e2) {
                  if (tl.tl.RpcError.is(e2, "PASSWORD_HASH_INVALID")) {
                    if (!isDynamic) {
                      throw e2;
                    }
                    if (params.invalidPasswordCallback) {
                      yield (_a3 = params.invalidPasswordCallback) == null ? void 0 : _a3.call(params);
                    } else {
                      console.log("Invalid password. Please try again");
                    }
                    continue;
                  }
                  throw e2;
                }
              }
            });
          }
          try {
            const { id: id2, hash } = yield client2.getApiCrenetials();
            const platform2 = getPlatform();
            loop:
              while (true) {
                let res;
                try {
                  res = yield client2.call(
                    {
                      _: "auth.exportLoginToken",
                      apiId: id2,
                      apiHash: hash,
                      exceptIds: []
                    },
                    { abortSignal }
                  );
                } catch (e2) {
                  if (tl.tl.RpcError.is(e2, "SESSION_PASSWORD_NEEDED") && params.password) {
                    return yield handle2fa(params.password);
                  }
                  throw e2;
                }
                switch (res._) {
                  case "auth.loginToken":
                    onUrlUpdated(
                      `tg://login?token=${platform2.base64Encode(res.token, true)}`,
                      new Date(res.expires * 1e3)
                    );
                    waiter = createControllablePromise();
                    yield Promise.race([waiter, sleepWithAbort(res.expires * 1e3 - Date.now(), client2.stopSignal)]);
                    break;
                  case "auth.loginTokenMigrateTo": {
                    yield client2.changePrimaryDc(res.dcId);
                    let res2;
                    try {
                      res2 = yield client2.call(
                        {
                          _: "auth.importLoginToken",
                          token: res.token
                        },
                        { abortSignal }
                      );
                    } catch (e2) {
                      if (tl.tl.RpcError.is(e2, "SESSION_PASSWORD_NEEDED") && params.password) {
                        return yield handle2fa(params.password);
                      }
                      throw e2;
                    }
                    assertTypeIs("auth.importLoginToken", res2, "auth.loginTokenSuccess");
                    break loop;
                  }
                  case "auth.loginTokenSuccess":
                    break loop;
                }
              }
            const [self2] = yield client2.call(
              {
                _: "users.getUsers",
                id: [{ _: "inputUserSelf" }]
              },
              { abortSignal }
            );
            assertTypeIs("users.getUsers", self2, "user");
            yield client2.notifyLoggedIn(self2);
            return new User(self2);
          } finally {
            client2.onServerUpdate(originalHandler);
          }
        });
      }
      function start(client2, params) {
        return __async(this, null, function* () {
          if (params.session) {
            yield client2.importSession(params.session, params.sessionForce);
          }
          const { abortSignal } = params;
          let has2fa = false;
          let sentCode;
          let phone = null;
          try {
            const me = yield getMe(client2);
            client2.log.info("Logged in as %s (ID: %s, username: %s, bot: %s)", me.displayName, me.id, me.username, me.isBot);
            yield client2.notifyLoggedIn(me.raw);
            return me;
          } catch (e2) {
            if (tl.tl.RpcError.is(e2)) {
              if (e2.text === "SESSION_PASSWORD_NEEDED")
                has2fa = true;
              else if (e2.text !== "AUTH_KEY_UNREGISTERED")
                throw e2;
            } else {
              throw e2;
            }
          }
          if (!has2fa && !params.qrCodeHandler) {
            if (!params.phone && !params.botToken) {
              throw new MtArgumentError("Neither phone nor bot token were provided");
            }
            phone = params.phone ? yield resolveMaybeDynamic(params.phone) : null;
            if (phone) {
              phone = normalizePhoneNumber(phone);
              if (!params.code) {
                throw new MtArgumentError("You must pass `code` to use `phone`");
              }
            } else {
              const botToken = params.botToken ? yield resolveMaybeDynamic(params.botToken) : null;
              if (!botToken) {
                throw new MtArgumentError("Either bot token or phone number must be provided");
              }
              return signInBot(client2, botToken);
            }
            try {
              sentCode = yield sendCode(client2, {
                phone,
                futureAuthTokens: params.futureAuthTokens,
                codeSettings: params.codeSettings,
                abortSignal
              });
            } catch (e2) {
              if (tl.tl.RpcError.is(e2, "SESSION_PASSWORD_NEEDED")) {
                has2fa = true;
              } else {
                throw e2;
              }
            }
          }
          if (sentCode) {
            if (params.forceSms && (sentCode.type === "app" || sentCode.type === "email")) {
              sentCode = yield resendCode(client2, {
                phone,
                phoneCodeHash: sentCode.phoneCodeHash,
                abortSignal
              });
            }
            if (params.codeSentCallback) {
              yield params.codeSentCallback(sentCode);
            } else {
              if (sentCode.type === "email_required") {
                throw new MtcuteError("Email login setup is required to sign in");
              }
              console.log(`The confirmation code has been sent via ${sentCode.type}.`);
            }
            for (; ; ) {
              const code2 = yield resolveMaybeDynamic(params.code);
              if (!code2)
                throw new tl.tl.RpcError(400, "PHONE_CODE_EMPTY");
              try {
                return yield signIn(client2, {
                  phone,
                  phoneCodeHash: sentCode.phoneCodeHash,
                  phoneCode: code2,
                  abortSignal
                });
              } catch (e2) {
                if (!tl.tl.RpcError.is(e2))
                  throw e2;
                if (e2.is("SESSION_PASSWORD_NEEDED")) {
                  has2fa = true;
                  break;
                } else if (e2.is("PHONE_CODE_EMPTY") || e2.is("PHONE_CODE_EXPIRED") || e2.is("PHONE_CODE_INVALID") || e2.is("PHONE_CODE_HASH_EMPTY")) {
                  if (typeof params.code !== "function") {
                    throw new MtArgumentError("Provided code was invalid");
                  }
                  if (params.invalidCodeCallback) {
                    yield params.invalidCodeCallback("code");
                  } else {
                    console.log("Invalid code. Please try again");
                  }
                  continue;
                } else {
                  throw e2;
                }
              }
              break;
            }
          }
          if (has2fa) {
            if (!params.password) {
              throw new MtArgumentError("2FA is enabled, but `password` was not provided.");
            }
            for (; ; ) {
              const password = yield resolveMaybeDynamic(params.password);
              try {
                return yield checkPassword(client2, password);
              } catch (e2) {
                if (typeof params.password !== "function") {
                  throw new MtArgumentError("Provided password was invalid");
                }
                if (tl.tl.RpcError.is(e2, "PASSWORD_HASH_INVALID")) {
                  if (params.invalidCodeCallback) {
                    yield params.invalidCodeCallback("password");
                  } else {
                    console.log("Invalid password. Please try again");
                  }
                  continue;
                } else {
                  throw e2;
                }
              }
            }
          }
          if (params.qrCodeHandler) {
            return signInQr(client2, {
              onUrlUpdated: params.qrCodeHandler,
              password: params.password,
              invalidPasswordCallback: params.invalidCodeCallback ? () => params.invalidCodeCallback("password") : void 0,
              abortSignal
            });
          }
          throw new MtArgumentError("Failed to log in with provided credentials");
        });
      }
      function run(client2, params, then) {
        start(client2, params).then(then).catch((err) => client2.emitError(err));
      }
      function sendRecoveryCode(client2) {
        return client2.call({
          _: "auth.requestPasswordRecovery"
        }).then((res) => res.emailPattern);
      }
      function startTest(client2, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          if (params.logout) {
            try {
              yield logOut(client2);
            } catch (e2) {
            }
          }
          const availableDcs = yield client2.call({
            _: "help.getConfig"
          }).then((res) => res.dcOptions);
          let phone = params.phone;
          if (phone) {
            if (!phone.match(/^99966\d{5}/)) {
              throw new MtArgumentError(`${phone} is an invalid test phone number`);
            }
            const id2 = Number.parseInt(phone[5]);
            if (!availableDcs.find((dc) => dc.id === id2)) {
              throw new MtArgumentError(`${phone} has invalid DC ID (${id2})`);
            }
          } else {
            let dcId = yield client2.getPrimaryDcId();
            if (params.dcId) {
              if (!availableDcs.find((dc) => dc.id === params.dcId)) {
                throw new MtArgumentError(`DC ID is invalid (${dcId})`);
              }
              dcId = params.dcId;
            }
            let numbers = Math.floor(Math.random() * 9999).toString();
            while (numbers.length !== 4)
              numbers += "0";
            phone = `99966${dcId}${numbers}`;
          }
          let code2 = "";
          return start(client2, {
            phone,
            code: () => code2,
            codeSentCallback: (sent) => {
              for (let i = 0; i < sent.length; i++) {
                code2 += phone[5];
              }
            }
          });
        });
      }
      function answerCallbackQuery(client2, queryId, params) {
        return __async(this, null, function* () {
          const { cacheTime = 0, text: text2, alert: alert2, url: url2 } = params != null ? params : {};
          const r2 = yield client2.call({
            _: "messages.setBotCallbackAnswer",
            queryId: Long.isLong(queryId) ? queryId : queryId.id,
            cacheTime,
            alert: alert2,
            message: text2,
            url: url2
          });
          assertTrue("messages.setBotCallbackAnswer", r2);
        });
      }
      function answerInlineQuery(client2, queryId, results, params) {
        return __async(this, null, function* () {
          const { cacheTime = 300, gallery, private: priv, nextOffset, switchPm, switchWebview } = params != null ? params : {};
          const [defaultGallery, tlResults] = yield _convertToTl(client2, results);
          yield client2.call({
            _: "messages.setInlineBotResults",
            queryId: Long.isLong(queryId) ? queryId : queryId.id,
            results: tlResults,
            cacheTime,
            gallery: gallery != null ? gallery : defaultGallery,
            private: priv,
            nextOffset,
            switchPm: switchPm ? {
              _: "inlineBotSwitchPM",
              text: switchPm.text,
              startParam: switchPm.parameter
            } : void 0,
            switchWebview: switchWebview ? {
              _: "inlineBotWebView",
              text: switchWebview.text,
              url: switchWebview.url
            } : void 0
          });
        });
      }
      function answerPreCheckoutQuery(client2, queryId, params) {
        return __async(this, null, function* () {
          const { error } = params != null ? params : {};
          const r2 = yield client2.call({
            _: "messages.setBotPrecheckoutResults",
            queryId: Long.isLong(queryId) ? queryId : queryId.queryId,
            success: !error,
            error
          });
          assertTrue("messages.setBotPrecheckoutResults", r2);
        });
      }
      function _normalizeCommandScope(client2, scope) {
        return __async(this, null, function* () {
          if (tl.tl.isAnyBotCommandScope(scope))
            return scope;
          switch (scope.type) {
            case "peer":
            case "peer_admins": {
              const peer = yield resolvePeer(client2, scope.peer);
              return {
                _: scope.type === "peer" ? "botCommandScopePeer" : "botCommandScopePeerAdmins",
                peer
              };
            }
            case "member": {
              const user = yield resolveUser(client2, scope.user);
              const chat2 = yield resolvePeer(client2, scope.chat);
              return {
                _: "botCommandScopePeerUser",
                peer: chat2,
                userId: user
              };
            }
            default:
              assertNever$1();
          }
        });
      }
      function deleteMyCommands(client2, params) {
        return __async(this, null, function* () {
          var _a3;
          const scope = (params == null ? void 0 : params.scope) ? yield _normalizeCommandScope(client2, params.scope) : {
            _: "botCommandScopeDefault"
          };
          yield client2.call({
            _: "bots.resetBotCommands",
            scope,
            langCode: (_a3 = params == null ? void 0 : params.langCode) != null ? _a3 : ""
          });
        });
      }
      function getBotInfo(client2, params) {
        return __async(this, null, function* () {
          const { bot, langCode = "" } = params;
          return client2.call({
            _: "bots.getBotInfo",
            bot: bot ? yield resolveUser(client2, bot) : void 0,
            langCode
          });
        });
      }
      function getBotMenuButton(client2, user) {
        return __async(this, null, function* () {
          return client2.call({
            _: "bots.getBotMenuButton",
            userId: yield resolveUser(client2, user)
          });
        });
      }
      function getCallbackAnswer(client2, params) {
        return __async(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const { data: data2, game: game2, timeout = 1e4, fireAndForget } = params;
          let password;
          if (params == null ? void 0 : params.password) {
            const pwd = yield client2.call({ _: "account.getPassword" });
            password = yield client2.computeSrpParams(pwd, params.password);
          }
          const promise = client2.call(
            {
              _: "messages.getBotCallbackAnswer",
              peer: yield resolvePeer(client2, chatId),
              msgId: message2,
              data: typeof data2 === "string" ? getPlatform().utf8Encode(data2) : data2,
              password,
              game: game2
            },
            { timeout, throw503: true }
          );
          if (fireAndForget) {
            promise.catch(() => {
            });
            return {
              _: "messages.botCallbackAnswer",
              cacheTime: 0
            };
          }
          return promise;
        });
      }
      function getGameHighScores(client2, params) {
        return __async(this, null, function* () {
          const { userId } = params;
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const chat2 = yield resolvePeer(client2, chatId);
          let user;
          if (userId) {
            user = yield resolveUser(client2, userId);
          } else {
            user = { _: "inputUserEmpty" };
          }
          const res = yield client2.call({
            _: "messages.getGameHighScores",
            peer: chat2,
            id: message2,
            userId: user
          });
          const peers = PeersIndex.from(res);
          return res.scores.map((score) => new GameHighScore(score, peers));
        });
      }
      function getInlineGameHighScores(client2, messageId, userId) {
        return __async(this, null, function* () {
          const id2 = normalizeInlineId(messageId);
          let user;
          if (userId) {
            user = yield resolveUser(client2, userId);
          } else {
            user = { _: "inputUserEmpty" };
          }
          const res = yield client2.call(
            {
              _: "messages.getInlineGameHighScores",
              id: id2,
              userId: user
            },
            { dcId: id2.dcId }
          );
          const peers = PeersIndex.from(res);
          return res.scores.map((score) => new GameHighScore(score, peers));
        });
      }
      function getMyCommands(client2, params) {
        return __async(this, null, function* () {
          var _a3;
          return client2.call({
            _: "bots.getBotCommands",
            scope: (params == null ? void 0 : params.scope) ? yield _normalizeCommandScope(client2, params.scope) : {
              _: "botCommandScopeDefault"
            },
            langCode: (_a3 = params == null ? void 0 : params.langCode) != null ? _a3 : ""
          });
        });
      }
      function setBotInfo(client2, params) {
        return __async(this, null, function* () {
          const { bot, langCode = "", name: name2, bio, description } = params;
          const r2 = yield client2.call({
            _: "bots.setBotInfo",
            bot: bot ? yield resolveUser(client2, bot) : void 0,
            langCode,
            name: name2,
            about: bio,
            description
          });
          assertTrue("bots.setBotInfo", r2);
        });
      }
      function setBotMenuButton(client2, user, button) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "bots.setBotMenuButton",
            userId: yield resolveUser(client2, user),
            button
          });
          assertTrue("bots.setBotMenuButton", r2);
        });
      }
      function setGameScore(client2, params) {
        return __async(this, null, function* () {
          const { userId, score, noEdit, force, shouldDispatch } = params;
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const user = yield resolveUser(client2, userId);
          const chat2 = yield resolvePeer(client2, chatId);
          const res = yield client2.call({
            _: "messages.setGameScore",
            peer: chat2,
            id: message2,
            userId: user,
            score,
            editMessage: !noEdit,
            force
          });
          return _findMessageInUpdate(client2, res, true, !shouldDispatch);
        });
      }
      function setInlineGameScore(client2, params) {
        return __async(this, null, function* () {
          const { messageId, userId, score, noEdit, force } = params;
          const user = yield resolveUser(client2, userId);
          const id2 = normalizeInlineId(messageId);
          const r2 = yield client2.call(
            {
              _: "messages.setInlineGameScore",
              id: id2,
              userId: user,
              score,
              editMessage: !noEdit,
              force
            },
            { dcId: id2.dcId }
          );
          assertTrue("messages.setInlineGameScore", r2);
        });
      }
      function setMyCommands(client2, params) {
        return __async(this, null, function* () {
          var _a3, _b2, _c;
          const scope = params.scope ? yield _normalizeCommandScope(client2, params.scope) : {
            _: "botCommandScopeDefault"
          };
          if ((_a3 = params.commands) == null ? void 0 : _a3.length) {
            const r2 = yield client2.call({
              _: "bots.setBotCommands",
              commands: params.commands,
              scope,
              langCode: (_b2 = params.langCode) != null ? _b2 : ""
            });
            assertTrue("bots.setBotCommands", r2);
          } else {
            const r2 = yield client2.call({
              _: "bots.resetBotCommands",
              scope,
              langCode: (_c = params.langCode) != null ? _c : ""
            });
            assertTrue("bots.resetBotCommands", r2);
          }
        });
      }
      function setMyDefaultRights(client2, params) {
        return __async(this, null, function* () {
          const { target, rights } = params;
          const r2 = yield client2.call({
            _: target === "group" ? "bots.setBotGroupDefaultAdminRights" : "bots.setBotBroadcastDefaultAdminRights",
            adminRights: __spreadValues({
              _: "chatAdminRights"
            }, rights)
          });
          assertTrue("bots.setBotGroupDefaultAdminRights", r2);
        });
      }
      function addChatMembers(client2, chatId, users, params) {
        return __async(this, null, function* () {
          const { forwardCount = 100 } = params;
          const chat2 = yield resolvePeer(client2, chatId);
          if (!Array.isArray(users))
            users = [users];
          if (isInputPeerChat(chat2)) {
            const missing = [];
            for(let   user of users) {
              const p = yield resolveUser(client2, user);
              const { updates, missingInvitees } = yield client2.call({
                _: "messages.addChatUser",
                chatId: chat2.chatId,
                userId: p,
                fwdLimit: forwardCount
              });
              client2.handleClientUpdate(updates);
              missing.push(...missingInvitees);
            }
            return missing;
          } else if (isInputPeerChannel(chat2)) {
            const { updates, missingInvitees } = yield client2.call({
              _: "channels.inviteToChannel",
              channel: toInputChannel(chat2),
              users: yield resolvePeerMany(client2, users, toInputUser)
            });
            client2.handleClientUpdate(updates);
            return missingInvitees;
          }
          throw new MtInvalidPeerTypeError(chatId, "chat or channel");
        });
      }
      function archiveChats(client2, chats) {
        return __async(this, null, function* () {
          if (!Array.isArray(chats))
            chats = [chats];
          const resolvedPeers = yield resolvePeerMany(client2, chats);
          const updates = yield client2.call({
            _: "folders.editPeerFolders",
            folderPeers: resolvedPeers.filter(isPresent).map((peer) => ({
              _: "inputFolderPeer",
              peer,
              folderId: 1
            }))
          });
          client2.handleClientUpdate(updates);
        });
      }
      function banChatMember(client2, params) {
        return __async(this, null, function* () {
          var _a3;
          const { chatId, participantId, shouldDispatch } = params;
          const chat2 = yield resolvePeer(client2, chatId);
          const peer = yield resolvePeer(client2, participantId);
          let res;
          if (isInputPeerChannel(chat2)) {
            res = yield client2.call({
              _: "channels.editBanned",
              channel: toInputChannel(chat2),
              participant: peer,
              bannedRights: {
                _: "chatBannedRights",
                untilDate: (_a3 = normalizeDate(params == null ? void 0 : params.untilDate)) != null ? _a3 : 0,
                viewMessages: true
              }
            });
          } else if (isInputPeerChat(chat2)) {
            res = yield client2.call({
              _: "messages.deleteChatUser",
              chatId: chat2.chatId,
              userId: toInputUser(peer)
            });
          } else {
            throw new MtInvalidPeerTypeError(chatId, "chat or channel");
          }
          return _findMessageInUpdate(client2, res, false, !shouldDispatch, true);
        });
      }
      function createChannel(client2, params) {
        return __async(this, null, function* () {
          const { title, description = "" } = params;
          const res = yield client2.call({
            _: "channels.createChannel",
            title,
            about: description,
            broadcast: true
          });
          assertIsUpdatesGroup("channels.createChannel", res);
          client2.handleClientUpdate(res);
          return new Chat(res.chats[0]);
        });
      }
      function createGroup(client2, params) {
        return __async(this, null, function* () {
          const { title } = params;
          let { users } = params;
          if (!Array.isArray(users))
            users = [users];
          const peers = yield resolvePeerMany(client2, users, toInputUser);
          const { updates, missingInvitees } = yield client2.call({
            _: "messages.createChat",
            title,
            users: peers
          });
          assertIsUpdatesGroup("messages.createChat", updates);
          client2.handleClientUpdate(updates);
          return {
            chat: new Chat(updates.chats[0]),
            missing: missingInvitees
          };
        });
      }
      function createSupergroup(client2, params) {
        return __async(this, null, function* () {
          const { title, description = "", forum, ttlPeriod = 0 } = params;
          const res = yield client2.call({
            _: "channels.createChannel",
            title,
            about: description,
            megagroup: true,
            forum,
            ttlPeriod
          });
          assertIsUpdatesGroup("channels.createChannel", res);
          client2.handleClientUpdate(res);
          return new Chat(res.chats[0]);
        });
      }
      function deleteChannel(client2, chatId) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "channels.deleteChannel",
            channel: yield resolveChannel(client2, chatId)
          });
          client2.handleClientUpdate(res);
        });
      }
      function deleteChatPhoto(client2, chatId) {
        return __async(this, null, function* () {
          const chat2 = yield resolvePeer(client2, chatId);
          let res;
          if (isInputPeerChat(chat2)) {
            res = yield client2.call({
              _: "messages.editChatPhoto",
              chatId: chat2.chatId,
              photo: { _: "inputChatPhotoEmpty" }
            });
          } else if (isInputPeerChannel(chat2)) {
            res = yield client2.call({
              _: "channels.editPhoto",
              channel: toInputChannel(chat2),
              photo: { _: "inputChatPhotoEmpty" }
            });
          } else {
            throw new MtInvalidPeerTypeError(chatId, "chat or channel");
          }
          client2.handleClientUpdate(res);
        });
      }
      function deleteGroup(client2, chatId) {
        return __async(this, null, function* () {
          const chat2 = yield resolvePeer(client2, chatId);
          if (!isInputPeerChat(chat2))
            throw new MtInvalidPeerTypeError(chatId, "chat");
          const res = yield client2.call({
            _: "messages.deleteChatUser",
            revokeHistory: true,
            chatId: chat2.chatId,
            userId: { _: "inputUserSelf" }
          });
          client2.handleClientUpdate(res);
          const r2 = yield client2.call({
            _: "messages.deleteChat",
            chatId: chat2.chatId
          });
          assertTrue("messages.deleteChat", r2);
        });
      }
      function deleteHistory(client2, chat2, params) {
        return __async(this, null, function* () {
          const { mode = "delete", maxId = 0 } = params != null ? params : {};
          const peer = yield resolvePeer(client2, chat2);
          const res = yield client2.call({
            _: "messages.deleteHistory",
            justClear: mode === "clear",
            revoke: mode === "revoke",
            peer,
            maxId
          });
          if (isInputPeerChannel(peer)) {
            client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, peer.channelId));
          } else {
            client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
          }
        });
      }
      function deleteUserHistory(client2, params) {
        return __async(this, null, function* () {
          const { chatId, participantId, shouldDispatch } = params;
          const channel = yield resolveChannel(client2, chatId);
          const peer = yield resolvePeer(client2, participantId);
          const res = yield client2.call({
            _: "channels.deleteParticipantHistory",
            channel,
            participant: peer
          });
          if (!shouldDispatch) {
            client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, channel.channelId));
          }
        });
      }
      function editAdminRights(client2, params) {
        return __async(this, null, function* () {
          const { chatId, userId, rights, rank = "" } = params;
          const chat2 = yield resolveChannel(client2, chatId);
          const user = yield resolveUser(client2, userId);
          const res = yield client2.call({
            _: "channels.editAdmin",
            channel: chat2,
            userId: user,
            adminRights: __spreadValues({
              _: "chatAdminRights"
            }, rights),
            rank
          });
          client2.handleClientUpdate(res);
        });
      }
      function normalizeChatEventFilters(input) {
        if (!input) {
          return {};
        }
        if (typeof input === "string" || Array.isArray(input)) {
          if (!Array.isArray(input))
            input = [input];
          const serverFilter = {
            _: "channelAdminLogEventsFilter"
          };
          const localFilter = {};
          input.forEach((type) => {
            localFilter[type] = true;
            switch (type) {
              case "user_joined":
              case "user_joined_invite":
              case "user_joined_approved":
                serverFilter.join = true;
                break;
              case "user_left":
                serverFilter.leave = true;
                break;
              case "user_invited":
                serverFilter.invite = true;
                break;
              case "title_changed":
              case "description_changed":
              case "linked_chat_changed":
              case "location_changed":
              case "photo_changed":
              case "username_changed":
              case "usernames_changed":
              case "stickerset_changed":
              case "slow_mode_changed":
              case "ttl_changed":
                serverFilter.info = true;
                break;
              case "invites_toggled":
              case "history_toggled":
              case "signatures_toggled":
              case "def_perms_changed":
              case "forum_toggled":
              case "no_forwards_toggled":
              case "signature_profiles_toggled":
                serverFilter.settings = true;
                break;
              case "msg_pinned":
                serverFilter.pinned = true;
                break;
              case "msg_edited":
              case "poll_stopped":
                serverFilter.edit = true;
                break;
              case "msg_deleted":
                serverFilter.delete = true;
                break;
              case "user_perms_changed":
                serverFilter.ban = true;
                serverFilter.unban = true;
                serverFilter.kick = true;
                serverFilter.unkick = true;
                break;
              case "user_admin_perms_changed":
                serverFilter.promote = true;
                serverFilter.demote = true;
                break;
              case "call_started":
              case "call_ended":
                serverFilter.groupCall = true;
                break;
              case "call_setting_changed":
                serverFilter.groupCall = true;
                serverFilter.settings = true;
                serverFilter.info = true;
                break;
              case "invite_deleted":
              case "invite_edited":
              case "invite_revoked":
                serverFilter.invites = true;
                break;
              case "topic_created":
              case "topic_edited":
              case "topic_deleted":
                serverFilter.forums = true;
                break;
              case "sub_extend":
                serverFilter.invite = true;
                serverFilter.invites = true;
                serverFilter.join = true;
                serverFilter.info = true;
                serverFilter.settings = true;
                break;
              default:
                assertNever$1();
            }
          });
          return {
            serverFilter,
            localFilter
          };
        }
        if ("_" in input) {
          return {
            serverFilter: input
          };
        }
        return input;
      }
      function getChatEventLog(client2, chatId, params) {
        return __async(this, null, function* () {
          const { maxId = Long.ZERO, minId = Long.ZERO, query = "", limit = 100, users, filters } = params != null ? params : {};
          const channel = yield resolveChannel(client2, chatId);
          const admins = users ? yield resolvePeerMany(client2, users, toInputUser) : void 0;
          const { serverFilter, localFilter } = normalizeChatEventFilters(filters);
          const res = yield client2.call({
            _: "channels.getAdminLog",
            channel,
            q: query,
            eventsFilter: serverFilter,
            admins,
            maxId,
            minId,
            limit
          });
          if (!res.events.length)
            return [];
          const peers = PeersIndex.from(res);
          const results = [];
          for(let   evt of res.events) {
            const parsed = new ChatEvent(evt, peers);
            if (localFilter && (!parsed.action || !localFilter[parsed.action.type])) {
              continue;
            }
            results.push(parsed);
          }
          return results;
        });
      }
      function getChatMember(client2, params) {
        return __async(this, null, function* () {
          const { chatId, userId } = params;
          const user = yield resolvePeer(client2, userId);
          const chat2 = yield resolvePeer(client2, chatId);
          if (isInputPeerChat(chat2)) {
            if (!isInputPeerUser(user)) {
              throw new MtInvalidPeerTypeError(userId, "user");
            }
            const res = yield client2.call({
              _: "messages.getFullChat",
              chatId: chat2.chatId
            });
            assertTypeIs("getChatMember (@ messages.getFullChat)", res.fullChat, "chatFull");
            const members = res.fullChat.participants._ === "chatParticipantsForbidden" ? [] : res.fullChat.participants.participants;
            const peers = PeersIndex.from(res);
            for(let   m2 of members) {
              if (user._ === "inputPeerSelf" && peers.user(m2.userId).self || user._ === "inputPeerUser" && m2.userId === user.userId) {
                return new ChatMember(m2, peers);
              }
            }
            return null;
          } else if (isInputPeerChannel(chat2)) {
            try {
              const res = yield client2.call({
                _: "channels.getParticipant",
                channel: toInputChannel(chat2),
                participant: user
              });
              const peers = PeersIndex.from(res);
              return new ChatMember(res.participant, peers);
            } catch (e2) {
              if (tl.tl.RpcError.is(e2, "USER_NOT_PARTICIPANT")) {
                return null;
              }
              throw e2;
            }
          } else {
            throw new MtInvalidPeerTypeError(chatId, "chat or channel");
          }
        });
      }
      function getChatMembers(client2, chatId, params) {
        return __async(this, null, function* () {
          const { query = "", offset = 0, limit = 200, type = "recent" } = params != null ? params : {};
          const chat2 = yield resolvePeer(client2, chatId);
          if (isInputPeerChat(chat2)) {
            const res = yield client2.call({
              _: "messages.getFullChat",
              chatId: chat2.chatId
            });
            assertTypeIs("getChatMember (@ messages.getFullChat)", res.fullChat, "chatFull");
            let members = res.fullChat.participants._ === "chatParticipantsForbidden" ? [] : res.fullChat.participants.participants;
            if (offset)
              members = members.slice(offset);
            if (limit)
              members = members.slice(0, limit);
            const peers = PeersIndex.from(res);
            const ret = members.map((m2) => new ChatMember(m2, peers));
            return makeArrayWithTotal(ret, ret.length);
          }
          if (isInputPeerChannel(chat2)) {
            const q = query;
            let filter;
            switch (type) {
              case "all":
                filter = { _: "channelParticipantsSearch", q };
                break;
              case "banned":
                filter = { _: "channelParticipantsKicked", q };
                break;
              case "restricted":
                filter = { _: "channelParticipantsBanned", q };
                break;
              case "mention":
                filter = { _: "channelParticipantsMentions", q };
                break;
              case "bots":
                filter = { _: "channelParticipantsBots" };
                break;
              case "recent":
                filter = { _: "channelParticipantsRecent" };
                break;
              case "admins":
                filter = { _: "channelParticipantsAdmins" };
                break;
              case "contacts":
                filter = { _: "channelParticipantsContacts", q };
                break;
              default:
                assertNever$1();
            }
            const res = yield client2.call({
              _: "channels.getParticipants",
              channel: toInputChannel(chat2),
              filter,
              offset,
              limit,
              hash: Long.ZERO
            });
            assertTypeIs("getChatMembers (@ channels.getParticipants)", res, "channels.channelParticipants");
            const peers = PeersIndex.from(res);
            const ret = res.participants.map((i) => new ChatMember(i, peers));
            return makeArrayWithTotal(ret, res.count);
          }
          throw new MtInvalidPeerTypeError(chatId, "chat or channel");
        });
      }
      function getChatPreview(client2, inviteLink) {
        return __async(this, null, function* () {
          const m2 = inviteLink.match(INVITE_LINK_REGEX);
          if (!m2)
            throw new MtArgumentError("Invalid invite link");
          const res = yield client2.call({
            _: "messages.checkChatInvite",
            hash: m2[1]
          });
          if (res._ !== "chatInvite") {
            throw new MtPeerNotFoundError("You have already joined this chat!");
          }
          return new ChatPreview(res, inviteLink);
        });
      }
      function getChat(client2, chatId) {
        return __async(this, null, function* () {
          if (typeof chatId === "string") {
            const m2 = chatId.match(INVITE_LINK_REGEX);
            if (m2) {
              const res2 = yield client2.call({
                _: "messages.checkChatInvite",
                hash: m2[1]
              });
              if (res2._ === "chatInvite") {
                throw new MtArgumentError(`You haven't joined ${JSON.stringify(res2.title)}`);
              }
              return new Chat(res2.chat);
            }
          }
          const peer = yield resolvePeer(client2, chatId);
          const res = yield _getRawPeerBatched(client2, peer);
          if (!res)
            throw new MtPeerNotFoundError(`Chat ${JSON.stringify(chatId)} was not found`);
          return new Chat(res);
        });
      }
      function getFullChat(client2, chatId) {
        return __async(this, null, function* () {
          if (typeof chatId === "string") {
            const m2 = chatId.match(INVITE_LINK_REGEX);
            if (m2) {
              const res2 = yield client2.call({
                _: "messages.checkChatInvite",
                hash: m2[1]
              });
              if (res2._ === "chatInvite") {
                throw new MtArgumentError(`You haven't joined ${JSON.stringify(res2.title)}`);
              }
              chatId = res2.chat.id;
            }
          }
          const peer = yield resolvePeer(client2, chatId);
          let res;
          if (isInputPeerChannel(peer)) {
            res = yield client2.call({
              _: "channels.getFullChannel",
              channel: toInputChannel(peer)
            });
          } else if (isInputPeerUser(peer)) {
            res = yield client2.call({
              _: "users.getFullUser",
              id: toInputUser(peer)
            });
          } else if (isInputPeerChat(peer)) {
            res = yield client2.call({
              _: "messages.getFullChat",
              chatId: peer.chatId
            });
          } else {
            throw new Error("should not happen");
          }
          return FullChat._parse(res);
        });
      }
      function getNearbyChats(client2, latitude, longitude) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "contacts.getLocated",
            geoPoint: {
              _: "inputGeoPoint",
              lat: latitude,
              long: longitude
            }
          });
          assertIsUpdatesGroup("contacts.getLocated", res);
          client2.handleClientUpdate(res, true);
          if (!res.updates.length)
            return [];
          assertTypeIs("contacts.getLocated (@ .updates[0])", res.updates[0], "updatePeerLocated");
          const chats = res.chats.map((it) => new Chat(it));
          const index = {};
          chats.forEach((c) => index[c.id] = c);
          res.updates[0].peers.forEach((peer) => {
            if (peer._ === "peerSelfLocated")
              return;
            const id2 = getMarkedPeerId(peer.peer);
            if (index[id2]) {
              index[id2].distance = peer.distance;
            }
          });
          return chats;
        });
      }
      function getSimilarChannels(client2, channel) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "channels.getChannelRecommendations",
            channel: yield resolveChannel(client2, channel)
          });
          const parsed = res.chats.map((chat2) => new Chat(chat2));
          switch (res._) {
            case "messages.chatsSlice":
              return makeArrayWithTotal(parsed, res.count);
            case "messages.chats":
              return makeArrayWithTotal(parsed, parsed.length);
          }
        });
      }
      function iterChatEventLog(client2, chatId, params) {
        return __asyncGenerator(this, null, function* () {
          var _a3;
          if (!params)
            params = {};
          const channel = yield new __await(resolveChannel(client2, chatId));
          const { minId = Long.ZERO, query = "", limit = Infinity, chunkSize = 100, users, filters } = params;
          const admins = users ? yield new __await(resolvePeerMany(client2, users, toInputUser)) : void 0;
          const { serverFilter, localFilter } = normalizeChatEventFilters(filters);
          let current2 = 0;
          let maxId = (_a3 = params.maxId) != null ? _a3 : Long.ZERO;
          for (; ; ) {
            const chunk = yield new __await(getChatEventLog(client2, channel, {
              minId,
              maxId,
              query,
              limit: localFilter ? chunkSize : Math.min(limit - current2, chunkSize),
              // provide already resolved users to avoid resolving them again
              users: admins,
              // local filters may mess with pagination
              filters: { serverFilter }
            }));
            if (!chunk.length)
              break;
            const last2 = chunk[chunk.length - 1];
            maxId = last2.id;
            for(let   item2 of chunk) {
              if (localFilter && (!item2.action || !localFilter[item2.action.type])) {
                continue;
              }
              current2 += 1;
              yield item2;
              if (current2 >= limit)
                break;
            }
          }
        });
      }
      function iterChatMembers(client2, chatId, params) {
        return __asyncGenerator(this, null, function* () {
          var _a3, _b2;
          if (!params)
            params = {};
          let current2 = 0;
          let total = params.limit || Infinity;
          const limit = Math.min((_a3 = params.chunkSize) != null ? _a3 : 200, total);
          let offset = (_b2 = params.offset) != null ? _b2 : 0;
          const yielded = /* @__PURE__ */ new Set();
          const chat2 = yield new __await(resolvePeer(client2, chatId));
          for (; ; ) {
            const members = yield new __await(getChatMembers(client2, chat2, {
              offset,
              limit,
              query: params.query,
              type: params.type
            }));
            if (!members.length)
              break;
            if (isInputPeerChat(chat2)) {
              total = members.length;
            }
            offset += members.length;
            for(let   m2 of members) {
              const uid2 = m2.user.id;
              if (yielded.has(uid2))
                continue;
              yielded.add(uid2);
              yield m2;
              current2 += 1;
              if (current2 >= total)
                return;
            }
          }
        });
      }
      function joinChat(client2, chatId) {
        return __async(this, null, function* () {
          if (typeof chatId === "string") {
            const m2 = chatId.match(INVITE_LINK_REGEX);
            if (m2) {
              const res2 = yield client2.call({
                _: "messages.importChatInvite",
                hash: m2[1]
              });
              assertIsUpdatesGroup("messages.importChatInvite", res2);
              client2.handleClientUpdate(res2);
              return new Chat(res2.chats[0]);
            }
          }
          const res = yield client2.call({
            _: "channels.joinChannel",
            channel: yield resolveChannel(client2, chatId)
          });
          assertIsUpdatesGroup("channels.joinChannel", res);
          client2.handleClientUpdate(res);
          return new Chat(res.chats[0]);
        });
      }
      function unbanChatMember(client2, params) {
        return __async(this, null, function* () {
          const { chatId, participantId } = params;
          const chat2 = yield resolvePeer(client2, chatId);
          const peer = yield resolvePeer(client2, participantId);
          if (isInputPeerChannel(chat2)) {
            const res = yield client2.call({
              _: "channels.editBanned",
              channel: toInputChannel(chat2),
              participant: peer,
              bannedRights: {
                _: "chatBannedRights",
                untilDate: 0
              }
            });
            client2.handleClientUpdate(res);
          } else if (isInputPeerChat(chat2))
            ;
          else {
            throw new MtInvalidPeerTypeError(chatId, "chat or channel");
          }
        });
      }
      function kickChatMember(client2, params) {
        return __async(this, null, function* () {
          const { chatId, userId } = params;
          const chat2 = yield resolvePeer(client2, chatId);
          const user = yield resolvePeer(client2, userId);
          const msg = yield banChatMember(client2, { chatId: chat2, participantId: user });
          if (isInputPeerChannel(chat2)) {
            yield sleepWithAbort(1e3, client2.stopSignal);
            yield unbanChatMember(client2, { chatId: chat2, participantId: user });
          }
          return msg;
        });
      }
      function leaveChat(client2, chatId, params) {
        return __async(this, null, function* () {
          const chat2 = yield resolvePeer(client2, chatId);
          if (isInputPeerChannel(chat2)) {
            const res = yield client2.call({
              _: "channels.leaveChannel",
              channel: toInputChannel(chat2)
            });
            client2.handleClientUpdate(res);
          } else if (isInputPeerChat(chat2)) {
            const res = yield client2.call({
              _: "messages.deleteChatUser",
              chatId: chat2.chatId,
              userId: { _: "inputUserSelf" }
            });
            client2.handleClientUpdate(res);
            if (params == null ? void 0 : params.clear) {
              yield deleteHistory(client2, chat2);
            }
          } else {
            throw new MtInvalidPeerTypeError(chatId, "chat or channel");
          }
        });
      }
      function markChatUnread(client2, chatId) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "messages.markDialogUnread",
            peer: {
              _: "inputDialogPeer",
              peer: yield resolvePeer(client2, chatId)
            },
            unread: true
          });
          assertTrue("messages.markDialogUnread", r2);
        });
      }
      function openChat(client2, chat2) {
        return __async(this, null, function* () {
          var _a3, _b2;
          const peer = yield resolvePeer(client2, chat2);
          if (isInputPeerChannel(peer)) {
            let pts;
            if (!((_a3 = client2.storage.self.getCached()) == null ? void 0 : _a3.isBot)) {
              const [dialog2] = yield getPeerDialogs(client2, peer);
              pts = dialog2.raw.pts;
            } else {
              pts = (_b2 = yield client2.storage.updates.getChannelPts(peer.channelId)) != null ? _b2 : void 0;
            }
            yield client2.notifyChannelOpened(peer.channelId, pts);
          }
        });
      }
      function closeChat(client2, chat2) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, chat2);
          if (isInputPeerChannel(peer)) {
            yield client2.notifyChannelClosed(peer.channelId);
          }
        });
      }
      function reorderUsernames(client2, peerId, order) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, peerId);
          if (isInputPeerUser(peer)) {
            if (isSelfPeer(client2, peer)) {
              const r22 = yield client2.call({
                _: "account.reorderUsernames",
                order
              });
              assertTrue("account.reorderUsernames", r22);
              return;
            }
            const r2 = yield client2.call({
              _: "bots.reorderUsernames",
              bot: toInputUser(peer, peerId),
              order
            });
            assertTrue("bots.reorderUsernames", r2);
          } else if (isInputPeerChannel(peer)) {
            const r2 = yield client2.call({
              _: "channels.reorderUsernames",
              channel: toInputChannel(peer, peerId),
              order
            });
            assertTrue("channels.reorderUsernames", r2);
          }
        });
      }
      function restrictChatMember(client2, params) {
        return __async(this, null, function* () {
          var _a3;
          const { chatId, userId, restrictions, until = 0 } = params;
          const chat2 = yield resolvePeer(client2, chatId);
          if (!isInputPeerChannel(chat2)) {
            throw new MtInvalidPeerTypeError(chatId, "channel");
          }
          const user = yield resolvePeer(client2, userId);
          const res = yield client2.call({
            _: "channels.editBanned",
            channel: toInputChannel(chat2),
            participant: user,
            bannedRights: __spreadValues({
              _: "chatBannedRights",
              untilDate: (_a3 = normalizeDate(until)) != null ? _a3 : 0
            }, restrictions)
          });
          client2.handleClientUpdate(res);
        });
      }
      function saveDraft(client2, chatId, draft) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, chatId);
          if (draft) {
            yield client2.call(__spreadValues({
              _: "messages.saveDraft",
              peer
            }, draft));
          } else {
            yield client2.call({
              _: "messages.saveDraft",
              peer,
              message: ""
            });
          }
        });
      }
      function setChatColor(client2, params) {
        return __async(this, null, function* () {
          var _a3;
          const { color: color2, backgroundEmojiId, forProfile } = params;
          const peer = yield resolvePeer(client2, (_a3 = params.peer) != null ? _a3 : "me");
          if (isInputPeerChannel(peer)) {
            const res = yield client2.call({
              _: "channels.updateColor",
              channel: toInputChannel(peer),
              color: color2,
              backgroundEmojiId
            });
            client2.handleClientUpdate(res);
            return;
          }
          if (isInputPeerUser(peer)) {
            if (!isSelfPeer(client2, peer)) {
              throw new MtTypeAssertionError("setChatColor", "self", peer._);
            }
            const r2 = yield client2.call({
              _: "account.updateColor",
              color: color2,
              backgroundEmojiId,
              forProfile
            });
            assertTrue("account.updateColor", r2);
          }
          throw new MtInvalidPeerTypeError(peer, "channel | user");
        });
      }
      function setChatDefaultPermissions(client2, chatId, restrictions) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, chatId);
          const res = yield client2.call({
            _: "messages.editChatDefaultBannedRights",
            peer,
            bannedRights: __spreadValues({
              _: "chatBannedRights",
              untilDate: 0
            }, restrictions)
          });
          assertIsUpdatesGroup("messages.editChatDefaultBannedRights", res);
          client2.handleClientUpdate(res);
          return new Chat(res.chats[0]);
        });
      }
      function setChatDescription(client2, chatId, description) {
        return __async(this, null, function* () {
          const chat2 = yield resolvePeer(client2, chatId);
          const r2 = yield client2.call({
            _: "messages.editChatAbout",
            peer: chat2,
            about: description
          });
          assertTrue("messages.editChatAbout", r2);
        });
      }
      function setChatPhoto(client2, params) {
        return __async(this, null, function* () {
          const { chatId, type, media: media2, previewSec } = params;
          const chat2 = yield resolvePeer(client2, chatId);
          if (!(isInputPeerChannel(chat2) || isInputPeerChat(chat2))) {
            throw new MtInvalidPeerTypeError(chatId, "chat or channel");
          }
          let photo2;
          let inputFile;
          if (typesInner.isFileIdLike(media2)) {
            if (typeof media2 === "string" && media2.match(/^https?:\/\//)) {
              throw new MtArgumentError("Chat photo can't be external");
            }
            if (typeof media2 === "string" && media2.match(/^file:/)) {
              const uploaded = yield uploadFile(client2, {
                file: media2.substring(5)
              });
              inputFile = uploaded.inputFile;
            } else {
              const input = fileIdToInputPhoto(media2);
              photo2 = {
                _: "inputChatPhoto",
                id: input
              };
            }
          } else if (typeof media2 === "object" && tl.tl.isAnyInputMedia(media2)) {
            if (media2._ === "inputMediaPhoto") {
              photo2 = {
                _: "inputChatPhoto",
                id: media2.id
              };
            } else {
              throw new MtArgumentError("Chat photo can't be InputMedia");
            }
          } else if (isUploadedFile(media2)) {
            inputFile = media2.inputFile;
          } else if (typeof media2 === "object" && tl.tl.isAnyInputFile(media2)) {
            inputFile = media2;
          } else {
            const uploaded = yield uploadFile(client2, {
              file: media2
            });
            inputFile = uploaded.inputFile;
          }
          if (!photo2) {
            photo2 = {
              _: "inputChatUploadedPhoto",
              [type === "photo" ? "file" : "video"]: inputFile,
              videoStartTs: previewSec
            };
          }
          let res;
          if (isInputPeerChat(chat2)) {
            res = yield client2.call({
              _: "messages.editChatPhoto",
              chatId: chat2.chatId,
              photo: photo2
            });
          } else {
            res = yield client2.call({
              _: "channels.editPhoto",
              channel: toInputChannel(chat2),
              photo: photo2
            });
          }
          client2.handleClientUpdate(res);
        });
      }
      function setChatTitle(client2, chatId, title) {
        return __async(this, null, function* () {
          const chat2 = yield resolvePeer(client2, chatId);
          let res;
          if (isInputPeerChat(chat2)) {
            res = yield client2.call({
              _: "messages.editChatTitle",
              chatId: chat2.chatId,
              title
            });
          } else if (isInputPeerChannel(chat2)) {
            res = yield client2.call({
              _: "channels.editTitle",
              channel: toInputChannel(chat2),
              title
            });
          } else {
            throw new MtInvalidPeerTypeError(chatId, "chat or channel");
          }
          client2.handleClientUpdate(res);
        });
      }
      function setChatTtl(client2, chatId, period) {
        return __async(this, null, function* () {
          yield client2.call({
            _: "messages.setHistoryTTL",
            peer: yield resolvePeer(client2, chatId),
            period
          });
        });
      }
      function setChatUsername(client2, chatId, username2) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "channels.updateUsername",
            channel: yield resolveChannel(client2, chatId),
            username: username2 || ""
          });
          assertTrue("channels.updateUsername", r2);
        });
      }
      function setSlowMode(client2, chatId, seconds = 0) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "channels.toggleSlowMode",
            channel: yield resolveChannel(client2, chatId),
            seconds
          });
          client2.handleClientUpdate(res);
        });
      }
      function toggleContentProtection(client2, chatId, enabled = false) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.toggleNoForwards",
            peer: yield resolvePeer(client2, chatId),
            enabled
          });
          client2.handleClientUpdate(res);
        });
      }
      function toggleFragmentUsername(client2, params) {
        return __async(this, null, function* () {
          const { peerId, username: username2, active } = params;
          const peer = yield resolvePeer(client2, peerId);
          if (isInputPeerUser(peer)) {
            if (isSelfPeer(client2, peer)) {
              const r22 = yield client2.call({
                _: "account.toggleUsername",
                username: username2,
                active
              });
              assertTrue("account.toggleUsername", r22);
              return;
            }
            const r2 = yield client2.call({
              _: "bots.toggleUsername",
              bot: toInputUser(peer, peerId),
              username: username2,
              active
            });
            assertTrue("bots.toggleUsername", r2);
          } else if (isInputPeerChannel(peer)) {
            const r2 = yield client2.call({
              _: "channels.toggleUsername",
              channel: toInputChannel(peer, peerId),
              username: username2,
              active
            });
            assertTrue("channels.toggleUsername", r2);
          }
        });
      }
      function toggleJoinRequests(client2, chatId, enabled = false) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "channels.toggleJoinRequest",
            channel: yield resolveChannel(client2, chatId),
            enabled
          });
          client2.handleClientUpdate(res);
        });
      }
      function toggleJoinToSend(client2, chatId, enabled = false) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "channels.toggleJoinToSend",
            channel: yield resolveChannel(client2, chatId),
            enabled
          });
          client2.handleClientUpdate(res);
        });
      }
      function unarchiveChats(client2, chats) {
        return __async(this, null, function* () {
          if (!Array.isArray(chats))
            chats = [chats];
          const folderPeers = [];
          for(let   chat2 of chats) {
            folderPeers.push({
              _: "inputFolderPeer",
              peer: yield resolvePeer(client2, chat2),
              folderId: 0
            });
          }
          const res = yield client2.call({
            _: "folders.editPeerFolders",
            folderPeers
          });
          client2.handleClientUpdate(res);
        });
      }
      function addContact(client2, params) {
        return __async(this, null, function* () {
          const { userId, firstName, lastName = "", phone = "", sharePhone = false } = params;
          const peer = yield resolveUser(client2, userId);
          const res = yield client2.call({
            _: "contacts.addContact",
            id: peer,
            firstName,
            lastName,
            phone,
            addPhonePrivacyException: sharePhone
          });
          assertIsUpdatesGroup("contacts.addContact", res);
          client2.handleClientUpdate(res);
          return new User(res.users[0]);
        });
      }
      function deleteContacts(client2, userIds) {
        return __async(this, null, function* () {
          if (!Array.isArray(userIds))
            userIds = [userIds];
          const inputPeers = yield resolvePeerMany(client2, userIds, toInputUser);
          if (!inputPeers.length) {
            throw new MtInvalidPeerTypeError("all provided ids", "user");
          }
          const res = yield client2.call({
            _: "contacts.deleteContacts",
            id: inputPeers
          });
          assertIsUpdatesGroup("contacts.deleteContacts", res);
          client2.handleClientUpdate(res);
          return res.users.map((user) => new User(user));
        });
      }
      function getContacts(client2) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "contacts.getContacts",
            hash: Long.ZERO
          });
          assertTypeIs("getContacts", res, "contacts.contacts");
          return res.users.map((user) => new User(user));
        });
      }
      function importContacts(client2, contacts) {
        return __async(this, null, function* () {
          let seq = Long.ZERO;
          const contactsNorm = contacts.map((input) => __spreadValues({
            _: "inputPhoneContact",
            clientId: seq = seq.add(1)
          }, input));
          return client2.call({
            _: "contacts.importContacts",
            contacts: contactsNorm
          });
        });
      }
      function getFolders(client2) {
        return __async(this, null, function* () {
          return client2.call({
            _: "messages.getDialogFilters"
          });
        });
      }
      function _normalizeInputFolder(client2, folder) {
        return __async(this, null, function* () {
          if (typeof folder === "string" || typeof folder === "number") {
            const folders = yield getFolders(client2);
            const found = folders.filters.find((it) => {
              if (it._ === "dialogFilterDefault") {
                return folder === 0;
              }
              return it.id === folder || it.title === folder;
            });
            if (!found) {
              throw new MtArgumentError(`Could not find folder ${folder}`);
            }
            return found;
          }
          return folder;
        });
      }
      function createFolder(client2, folder) {
        return __async(this, null, function* () {
          let id2 = folder.id;
          if (!id2) {
            const old = yield getFolders(client2);
            let max2 = 1;
            old.filters.forEach((it) => {
              if (it._ === "dialogFilter" && it.id > max2)
                max2 = it.id;
            });
            id2 = max2 + 1;
          }
          const filter = __spreadProps(__spreadValues({
            _: "dialogFilter",
            pinnedPeers: [],
            includePeers: [],
            excludePeers: []
          }, folder), {
            id: id2
          });
          const r2 = yield client2.call({
            _: "messages.updateDialogFilter",
            id: id2,
            filter
          });
          assertTrue("messages.updateDialogFilter", r2);
          return filter;
        });
      }
      function deleteFolder(client2, id2) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "messages.updateDialogFilter",
            id: typeof id2 === "number" ? id2 : id2.id
          });
          assertTrue("messages.updateDialogFilter", r2);
        });
      }
      function editFolder(client2, params) {
        return __async(this, null, function* () {
          const { modification } = params;
          let { folder } = params;
          if (folder === 0) {
            throw new MtArgumentError("Cannot modify default folder");
          }
          if (typeof folder === "number" || typeof folder === "string") {
            const old = yield getFolders(client2);
            const found = old.filters.find((it) => it._ === "dialogFilter" && (it.id === folder || it.title === folder));
            if (!found) {
              throw new MtArgumentError(`Could not find a folder ${folder}`);
            }
            folder = found;
          }
          const filter = __spreadValues(__spreadValues({}, folder), modification);
          const r2 = yield client2.call({
            _: "messages.updateDialogFilter",
            id: folder.id,
            filter
          });
          assertTrue("messages.updateDialogFilter", r2);
          return filter;
        });
      }
      function iterDialogs(client2, params) {
        return __asyncGenerator(this, null, function* () {
          var _a3;
          if (!params)
            params = {};
          const { limit = Infinity, chunkSize = 100, folder, filter, pinned = "include" } = params;
          let { offsetId = 0, offsetPeer = { _: "inputPeerEmpty" }, archived = "exclude" } = params;
          let offsetDate = (_a3 = normalizeDate(params.offsetDate)) != null ? _a3 : 0;
          let localFilters_;
          if (folder) {
            localFilters_ = yield new __await(_normalizeInputFolder(client2, folder));
          }
          if (filter) {
            if (localFilters_ && localFilters_._ !== "dialogFilterDefault") {
              localFilters_ = __spreadValues(__spreadValues({}, localFilters_), filter);
            } else {
              localFilters_ = __spreadValues({
                _: "dialogFilter",
                id: 0,
                title: "",
                pinnedPeers: [],
                includePeers: [],
                excludePeers: []
              }, params.filter);
            }
          }
          if ((localFilters_ == null ? void 0 : localFilters_._) === "dialogFilterDefault") {
            localFilters_ = void 0;
          }
          const localFilters = localFilters_;
          if ((localFilters == null ? void 0 : localFilters._) === "dialogFilterChatlist") {
            if (offsetId !== 0 || offsetDate !== 0 || offsetPeer._ !== "inputPeerEmpty") {
              throw new MtArgumentError("Cannot use offset parameters with chatlist filters");
            }
            let remaining = Math.min(limit, localFilters.includePeers.length + localFilters.pinnedPeers.length);
            if (pinned === "include" || pinned === "only") {
              const peers = [];
              for(let   peer of localFilters.pinnedPeers) {
                if (remaining <= 0)
                  break;
                remaining--;
                peers.push({
                  _: "inputDialogPeer",
                  peer
                });
              }
              const res = yield new __await(client2.call({
                _: "messages.getPeerDialogs",
                peers
              }));
              res.dialogs.forEach((dialog2) => dialog2.pinned = true);
              yield* __yieldStar(Dialog.parseTlDialogs(res));
            }
            if (pinned === "only" || remaining <= 0) {
              return;
            }
            let offset = 0;
            while (remaining > 0) {
              const peers = [];
              for (let i = 0; i < chunkSize; i++) {
                if (remaining <= 0)
                  break;
                remaining--;
                peers.push({
                  _: "inputDialogPeer",
                  peer: localFilters.includePeers[offset + i]
                });
              }
              offset += chunkSize;
              const res = yield new __await(client2.call({
                _: "messages.getPeerDialogs",
                peers
              }));
              yield* __yieldStar(Dialog.parseTlDialogs(res));
            }
            return;
          }
          if (localFilters) {
            archived = localFilters.excludeArchived ? "exclude" : "keep";
          }
          const fetchPinnedDialogsFromFolder = () => __async(this, null, function* () {
            if (!localFilters || !localFilters.pinnedPeers.length) {
              return null;
            }
            const res = yield client2.call({
              _: "messages.getPeerDialogs",
              peers: localFilters.pinnedPeers.map((peer) => ({
                _: "inputDialogPeer",
                peer
              }))
            });
            res.dialogs.forEach((dialog2) => dialog2.pinned = true);
            return res;
          });
          if (pinned === "only") {
            let res;
            if (localFilters) {
              res = yield new __await(fetchPinnedDialogsFromFolder());
            } else {
              res = yield new __await(client2.call({
                _: "messages.getPinnedDialogs",
                folderId: archived === "exclude" ? 0 : 1
              }));
            }
            if (res)
              yield* __yieldStar(Dialog.parseTlDialogs(res, limit));
            return;
          }
          let current2 = 0;
          if ((localFilters == null ? void 0 : localFilters.pinnedPeers.length) && pinned === "include" && offsetId === 0 && offsetDate === 0 && offsetPeer._ === "inputPeerEmpty") {
            const res = yield new __await(fetchPinnedDialogsFromFolder());
            if (res) {
              const dialogs2 = Dialog.parseTlDialogs(res, limit);
              for(let   d of dialogs2) {
                yield d;
                if (++current2 >= limit)
                  return;
              }
            }
          }
          const filterFolder = localFilters ? Dialog.filterFolder(localFilters, pinned !== "keep") : void 0;
          let folderId;
          if (archived === "keep") {
            folderId = void 0;
          } else if (archived === "only") {
            folderId = 1;
          } else {
            folderId = 0;
          }
          for (; ; ) {
            const dialogs2 = Dialog.parseTlDialogs(
              yield new __await(client2.call({
                _: "messages.getDialogs",
                excludePinned: params.pinned === "exclude",
                folderId,
                offsetDate,
                offsetId,
                offsetPeer,
                limit: filterFolder ? chunkSize : Math.min(limit - current2, chunkSize),
                hash: Long.ZERO
              }))
            );
            if (!dialogs2.length)
              return;
            const last2 = dialogs2[dialogs2.length - 1];
            offsetPeer = last2.chat.inputPeer;
            offsetId = last2.raw.topMessage;
            if (last2.lastMessage) {
              offsetDate = last2.lastMessage.raw.date;
            }
            for(let   d of dialogs2) {
              if (filterFolder && !filterFolder(d))
                continue;
              yield d;
              if (++current2 >= limit)
                return;
            }
          }
        });
      }
      function findDialogs(client2, peers) {
        return __async(this, null, function* () {
          if (!Array.isArray(peers))
            peers = [peers];
          const resolved = yield resolvePeerMany(client2, peers);
          const notFoundIds = /* @__PURE__ */ new Map();
          const notFoundUsernames = /* @__PURE__ */ new Map();
          let notFoundCount = 0;
          const foundInputPeers = [];
          const foundIdxToOriginalIdx = /* @__PURE__ */ new Map();
          for (let i = 0; i < peers.length; i++) {
            const input = peers[i];
            const resolvedPeer = resolved[i];
            if (!resolvedPeer) {
              if (typeof input === "number") {
                notFoundIds.set(input, i);
              } else {
                notFoundUsernames.set(input, i);
              }
              notFoundCount += 1;
              continue;
            }
            foundInputPeers.push(resolvedPeer);
            foundIdxToOriginalIdx.set(foundInputPeers.length - 1, i);
          }
          const ret = Array.from({ length: peers.length });
          if (foundInputPeers.length !== 0) {
            const dialogs2 = yield getPeerDialogs(client2, foundInputPeers);
            if (foundInputPeers.length === peers.length) {
              return dialogs2;
            }
            for(let   [idx, origIdx] of foundIdxToOriginalIdx) {
              ret[origIdx] = dialogs2[idx];
            }
          }
          try {
            for (var iter = __forAwait(iterDialogs(client2, {
              archived: "keep"
            })), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const dialog2 = temp.value;
              const chat2 = dialog2.chat;
              const idxById = notFoundIds.get(chat2.id);
              if (idxById !== void 0) {
                ret[idxById] = dialog2;
                notFoundIds.delete(chat2.id);
                notFoundCount -= 1;
              }
              if (notFoundCount === 0)
                break;
              if (!chat2.username)
                continue;
              const idxByUsername = notFoundUsernames.get(chat2.username);
              if (idxByUsername !== void 0) {
                ret[idxByUsername] = dialog2;
                notFoundUsernames.delete(chat2.username);
                notFoundCount -= 1;
              }
              if (notFoundCount === 0)
                break;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          if (notFoundCount > 0) {
            const notFound = [...notFoundIds.keys(), ...notFoundUsernames.keys()];
            throw new MtPeerNotFoundError(`Could not find dialogs with peers: ${notFound.join(", ")}`);
          }
          return ret;
        });
      }
      function findFolder(client2, params) {
        return __async(this, null, function* () {
          var _a3;
          if (!params.title && !params.emoji && !params.id) {
            throw new MtArgumentError("One of search parameters must be passed");
          }
          const folders = yield getFolders(client2);
          return (_a3 = folders.filters.find((it) => {
            if (it._ === "dialogFilterDefault")
              return false;
            if (params.id && it.id !== params.id)
              return false;
            if (params.title && it.title !== params.title)
              return false;
            if (params.emoji && it.emoticon !== params.emoji)
              return false;
            return true;
          })) != null ? _a3 : null;
        });
      }
      function getChatlistPreview(client2, link) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "chatlists.checkChatlistInvite",
            slug: link
          });
          return new ChatlistPreview(res);
        });
      }
      function joinChatlist(client2, link, params) {
        return __async(this, null, function* () {
          let peers;
          if (params == null ? void 0 : params.peers) {
            const inputs = Array.isArray(params.peers) ? params.peers : [params.peers];
            const all = yield resolvePeerMany(client2, inputs);
            peers = all.filter(isPresent);
          } else {
            const preview2 = yield getChatlistPreview(client2, link);
            peers = preview2.chats.filter((it) => !it.isUnavailable).map((it) => it.inputPeer);
          }
          const res = yield client2.call({
            _: "chatlists.joinChatlistInvite",
            slug: link,
            peers
          });
          assertIsUpdatesGroup("joinChatlist", res);
          client2.handleClientUpdate(res);
          const filter = res.updates.find((it) => it._ === "updateDialogFilter");
          if (!(filter == null ? void 0 : filter.filter)) {
            throw new MtTypeAssertionError("joinChatlist", "updateDialogFilter", "nothing");
          }
          assertTypeIs("joinChatlist", filter.filter, "dialogFilterChatlist");
          return filter.filter;
        });
      }
      function setFoldersOrder(client2, order) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "messages.updateDialogFiltersOrder",
            order
          });
          assertTrue("messages.updateDialogFiltersOrder", r2);
        });
      }
      const SMALL_FILE_MAX_SIZE = 131072;
      const REQUESTS_PER_CONNECTION = 3;
      function downloadAsIterable(client2, input, params) {
        return __asyncGenerator(this, null, function* () {
          var _a3, _b2, _c, _d, _e;
          const offset = (_a3 = params == null ? void 0 : params.offset) != null ? _a3 : 0;
          if (offset % 4096 !== 0) {
            throw new MtArgumentError(`Invalid offset: ${offset}. Must be divisible by 4096`);
          }
          let dcId = params == null ? void 0 : params.dcId;
          let fileSize = params == null ? void 0 : params.fileSize;
          const abortSignal = params == null ? void 0 : params.abortSignal;
          let aborted = false;
          let location2;
          if (input instanceof FileLocation) {
            let locationInner = input.location;
            if (typeof locationInner === "function") {
              locationInner = locationInner();
            }
            if (ArrayBuffer.isView(locationInner)) {
              yield locationInner;
              return;
            }
            if (!dcId)
              dcId = input.dcId;
            if (!fileSize)
              fileSize = input.fileSize;
            location2 = locationInner;
          } else if (typeof input === "string") {
            const parsed = parseFileId(getPlatform(), input);
            if (parsed.location._ === "web") {
              location2 = fileIdToInputWebFileLocation(parsed);
            } else {
              location2 = fileIdToInputFileLocation(parsed);
            }
          } else {
            location2 = input;
          }
          const isWeb = tl.tl.isAnyInputWebFileLocation(location2);
          const primaryDcId = yield new __await(client2.getPrimaryDcId());
          if (!dcId)
            dcId = primaryDcId;
          const partSizeKb = (_b2 = params == null ? void 0 : params.partSize) != null ? _b2 : fileSize ? determinePartSize(fileSize) : 64;
          if (partSizeKb % 4 !== 0) {
            throw new MtArgumentError(`Invalid part size: ${partSizeKb}. Must be divisible by 4.`);
          }
          const chunkSize = partSizeKb * 1024;
          let limitBytes = (_d = (_c = params == null ? void 0 : params.limit) != null ? _c : fileSize) != null ? _d : Infinity;
          if (limitBytes === 0)
            return;
          let numChunks = limitBytes === Infinity ? Infinity : ~~((limitBytes + chunkSize - offset - 1) / chunkSize);
          let nextChunkIdx = 0;
          let nextWorkerChunkIdx = 0;
          const nextChunkCv = new ConditionVariable();
          const buffer = {};
          const isSmall = fileSize && fileSize <= SMALL_FILE_MAX_SIZE;
          let connectionKind;
          if (isSmall) {
            connectionKind = dcId === primaryDcId ? "main" : "downloadSmall";
          } else {
            connectionKind = "download";
          }
          const poolSize = yield new __await(client2.getPoolSize(connectionKind, dcId));
          client2.log.debug(
            "Downloading file of size %d from dc %d using %s connection pool (pool size: %d)",
            limitBytes,
            dcId,
            connectionKind,
            poolSize
          );
          const downloadChunk = (..._0) => __async(this, [..._0], function* (chunk = nextWorkerChunkIdx++) {
            let result;
            if (aborted) {
              return;
            }
            try {
              result = yield client2.call(
                {
                  _: isWeb ? "upload.getWebFile" : "upload.getFile",
                  // eslint-disable-next-line
                  location: location2,
                  offset: chunkSize * chunk,
                  limit: chunkSize
                },
                {
                  dcId,
                  kind: connectionKind,
                  maxRetryCount: Infinity,
                  // retry until explicitly aborted (or finished)
                  abortSignal
                }
              );
            } catch (e2) {
              if (e2 instanceof DOMException && e2.name === "AbortError")
                return;
              if (!tl.tl.RpcError.is(e2))
                throw e2;
              if (e2.is("FILE_MIGRATE_%d")) {
                dcId = e2.newDc;
                return downloadChunk(chunk);
              } else if (e2.is("FILEREF_UPGRADE_NEEDED")) {
                throw new MtUnsupportedError("File ref expired!");
              } else {
                throw e2;
              }
            }
            if (result._ === "upload.fileCdnRedirect") {
              throw new MtUnsupportedError("Received CDN redirect, which is not supported (yet)");
            }
            if (aborted) {
              return;
            }
            if (result._ === "upload.webFile" && result.size && limitBytes === Infinity) {
              limitBytes = result.size;
              numChunks = ~~((limitBytes + chunkSize - offset - 1) / chunkSize);
            }
            buffer[chunk] = result.bytes;
            if (chunk === nextChunkIdx) {
              nextChunkCv.notify();
            }
            if (nextWorkerChunkIdx < numChunks && result.bytes.length === chunkSize) {
              return downloadChunk();
            }
          });
          let error;
          void Promise.all(Array.from({ length: Math.min(poolSize * REQUESTS_PER_CONNECTION, numChunks) }, downloadChunk)).catch((e2) => {
            client2.log.debug("download workers errored: %e", e2);
            error = e2;
            aborted = true;
            nextChunkCv.notify();
          }).then(() => {
            client2.log.debug("download workers finished");
          });
          abortSignal == null ? void 0 : abortSignal.addEventListener("abort", () => {
            client2.log.debug("download aborted");
            error = abortSignal.reason;
            aborted = true;
            nextChunkCv.notify();
          });
          let position = offset;
          while (position < limitBytes) {
            yield new __await(nextChunkCv.wait());
            if (error)
              throw error;
            while (nextChunkIdx in buffer) {
              const buf = buffer[nextChunkIdx];
              delete buffer[nextChunkIdx];
              position += buf.length;
              (_e = params == null ? void 0 : params.progressCallback) == null ? void 0 : _e.call(params, position, limitBytes);
              yield buf;
              nextChunkIdx++;
              if (buf.length < chunkSize) {
                return;
              }
            }
          }
        });
      }
      function downloadAsBuffer(client2, location2, params) {
        return __async(this, null, function* () {
          if (location2 instanceof FileLocation && ArrayBuffer.isView(location2.location)) {
            return location2.location;
          }
          const chunks = [];
          try {
            for (var iter = __forAwait(downloadAsIterable(client2, location2, params)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const chunk = temp.value;
              chunks.push(chunk);
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          return concatBuffers(chunks);
        });
      }
      function downloadAsStream(client2, location2, params) {
        if (location2 instanceof FileLocation && ArrayBuffer.isView(location2.location)) {
          return bufferToStream(location2.location);
        }
        const cancel = new AbortController();
        if (params == null ? void 0 : params.abortSignal) {
          params == null ? void 0 : params.abortSignal.addEventListener("abort", () => {
            cancel.abort();
          });
        }
        return new ReadableStream({
          start(controller) {
            (() => __async(this, null, function* () {
              try {
                for (var iter = __forAwait(downloadAsIterable(client2, location2, params)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                  const chunk = temp.value;
                  controller.enqueue(chunk);
                }
              } catch (temp) {
                error = [temp];
              } finally {
                try {
                  more && (temp = iter.return) && (yield temp.call(iter));
                } finally {
                  if (error)
                    throw error[0];
                }
              }
              controller.close();
            }))().catch((e2) => controller.error(e2));
          },
          cancel() {
            cancel.abort();
          }
        });
      }
      function uploadMedia(_0, _1) {
        return __async(this, arguments, function* (client2, media2, params = {}) {
          const normMedia = yield _normalizeInputMedia(client2, media2, params, false);
          switch (normMedia._) {
            case "inputMediaEmpty":
            case "inputMediaGeoPoint":
            case "inputMediaGeoLive":
            case "inputMediaContact":
            case "inputMediaVenue":
            case "inputMediaGame":
            case "inputMediaInvoice":
            case "inputMediaPoll":
            case "inputMediaDice":
            case "inputMediaPaidMedia":
              throw new MtArgumentError("This media can't be uploaded");
          }
          const res = yield client2.call({
            _: "messages.uploadMedia",
            peer: params.peer ? yield resolvePeer(client2, params.peer) : {
              _: "inputPeerSelf"
            },
            media: normMedia
          });
          assertTypeIsNot("uploadMedia", res, "messageMediaEmpty");
          switch (normMedia._) {
            case "inputMediaUploadedPhoto":
            case "inputMediaPhoto":
            case "inputMediaPhotoExternal":
              assertTypeIs("uploadMedia", res, "messageMediaPhoto");
              assertTypeIs("uploadMedia", res.photo, "photo");
              return new Photo(res.photo);
            case "inputMediaUploadedDocument":
            case "inputMediaDocument":
            case "inputMediaDocumentExternal":
              assertTypeIs("uploadMedia", res, "messageMediaDocument");
              assertTypeIs("uploadMedia", res.document, "document");
              return parseDocument(res.document, res);
            case "inputMediaStory":
            case "inputMediaWebPage":
              throw new MtArgumentError(`This media (${normMedia._}) can't be uploaded`);
            default:
              assertNever$1();
          }
        });
      }
      function createForumTopic(client2, params) {
        return __async(this, null, function* () {
          const { chatId, title, icon: icon2, sendAs, shouldDispatch } = params;
          const res = yield client2.call({
            _: "channels.createForumTopic",
            channel: yield resolveChannel(client2, chatId),
            title,
            iconColor: typeof icon2 === "number" ? icon2 : void 0,
            iconEmojiId: typeof icon2 !== "number" ? icon2 : void 0,
            sendAs: sendAs ? yield resolvePeer(client2, sendAs) : void 0,
            randomId: randomLong()
          });
          return _findMessageInUpdate(client2, res, false, !shouldDispatch);
        });
      }
      function deleteForumTopicHistory(client2, chat2, topicId, params) {
        return __async(this, null, function* () {
          const { shouldDispatch } = params != null ? params : {};
          const channel = yield resolveChannel(client2, chat2);
          assertTypeIsNot("deleteForumTopicHistory", channel, "inputChannelEmpty");
          const res = yield client2.call({
            _: "channels.deleteTopicHistory",
            channel,
            topMsgId: typeof topicId === "number" ? topicId : topicId.id
          });
          if (!shouldDispatch) {
            client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, channel.channelId));
          }
        });
      }
      function editForumTopic(client2, params) {
        return __async(this, null, function* () {
          const { chatId, topicId, title, icon: icon2, shouldDispatch } = params;
          const res = yield client2.call({
            _: "channels.editForumTopic",
            channel: yield resolveChannel(client2, chatId),
            topicId: typeof topicId === "number" ? topicId : topicId.id,
            title,
            iconEmojiId: icon2 ? icon2 != null ? icon2 : Long.ZERO : void 0
          });
          return _findMessageInUpdate(client2, res, false, shouldDispatch);
        });
      }
      function getForumTopicsById(client2, chatId, ids) {
        return __async(this, null, function* () {
          if (!Array.isArray(ids))
            ids = [ids];
          const res = yield client2.call({
            _: "channels.getForumTopicsByID",
            channel: yield resolveChannel(client2, chatId),
            topics: ids
          });
          return ForumTopic.parseTlForumTopics(res);
        });
      }
      const defaultOffset$3 = {
        date: 0,
        id: 0,
        topic: 0
      };
      function getForumTopics(client2, chatId, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          const {
            query,
            offset: { date: offsetDate, id: offsetId, topic: offsetTopic } = defaultOffset$3,
            limit = 100
          } = params;
          const res = yield client2.call({
            _: "channels.getForumTopics",
            channel: yield resolveChannel(client2, chatId),
            q: query,
            offsetDate,
            offsetId,
            offsetTopic,
            limit
          });
          const topics = ForumTopic.parseTlForumTopics(res);
          const last2 = topics[topics.length - 1];
          const next2 = last2 ? {
            date: res.orderByCreateDate ? last2.raw.date : last2.lastMessage.raw.date,
            id: last2.raw.topMessage,
            topic: last2.raw.id
          } : void 0;
          return makeArrayPaginated(topics, res.count, next2);
        });
      }
      function iterForumTopics(client2, chatId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { query, limit = Infinity, chunkSize = 100 } = params;
          const peer = yield new __await(resolveChannel(client2, chatId));
          let { offset } = params;
          let current2 = 0;
          for (; ; ) {
            const res = yield new __await(getForumTopics(client2, peer, {
              query,
              offset,
              limit: Math.min(chunkSize, limit - current2)
            }));
            for(let   topic of res) {
              yield topic;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
          }
        });
      }
      function reorderPinnedForumTopics(client2, params) {
        return __async(this, null, function* () {
          const { chatId, order, force } = params;
          yield client2.call({
            _: "channels.reorderPinnedForumTopics",
            channel: yield resolveChannel(client2, chatId),
            order: order.map((it) => typeof it === "number" ? it : it.id),
            force
          });
        });
      }
      function toggleForumTopicClosed(client2, parmas) {
        return __async(this, null, function* () {
          const { chatId, topicId, closed, shouldDispatch } = parmas;
          const res = yield client2.call({
            _: "channels.editForumTopic",
            channel: yield resolveChannel(client2, chatId),
            topicId: typeof topicId === "number" ? topicId : topicId.id,
            closed
          });
          return _findMessageInUpdate(client2, res, false, shouldDispatch);
        });
      }
      function toggleForumTopicPinned(client2, params) {
        return __async(this, null, function* () {
          const { chatId, topicId, pinned } = params;
          yield client2.call({
            _: "channels.updatePinnedForumTopic",
            channel: yield resolveChannel(client2, chatId),
            topicId: typeof topicId === "number" ? topicId : topicId.id,
            pinned
          });
        });
      }
      function toggleForum(client2, chatId, enabled = false) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "channels.toggleForum",
            channel: yield resolveChannel(client2, chatId),
            enabled
          });
          client2.handleClientUpdate(res);
        });
      }
      function toggleGeneralTopicHidden(client2, params) {
        return __async(this, null, function* () {
          const { chatId, hidden: hidden2, shouldDispatch } = params;
          const res = yield client2.call({
            _: "channels.editForumTopic",
            channel: yield resolveChannel(client2, chatId),
            topicId: 1,
            hidden: hidden2
          });
          return _findMessageInUpdate(client2, res, false, shouldDispatch);
        });
      }
      function createInviteLink(client2, chatId, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          const res = yield client2.call({
            _: "messages.exportChatInvite",
            peer: yield resolvePeer(client2, chatId),
            expireDate: normalizeDate(params.expires),
            usageLimit: params.usageLimit,
            requestNeeded: params.withApproval
          });
          return new ChatInviteLink(res);
        });
      }
      function editInviteLink(client2, params) {
        return __async(this, null, function* () {
          const { chatId, link, expires, usageLimit, withApproval } = params;
          const res = yield client2.call({
            _: "messages.editExportedChatInvite",
            peer: yield resolvePeer(client2, chatId),
            link: typeof link === "string" ? link : link.link,
            expireDate: normalizeDate(expires),
            usageLimit,
            requestNeeded: withApproval
          });
          const peers = PeersIndex.from(res);
          return new ChatInviteLink(res.invite, peers);
        });
      }
      function exportInviteLink(client2, chatId) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.exportChatInvite",
            peer: yield resolvePeer(client2, chatId),
            legacyRevokePermanent: true
          });
          return new ChatInviteLink(res);
        });
      }
      function getInviteLinkMembers(client2, chatId, params) {
        return __async(this, null, function* () {
          var _a3;
          const peer = yield resolvePeer(client2, chatId);
          if (!params)
            params = {};
          const { limit = 100, link, requestedSearch, requested = Boolean(requestedSearch) } = params;
          const { offsetUser = { _: "inputUserEmpty" } } = params;
          const offsetDate = (_a3 = normalizeDate(params.offsetDate)) != null ? _a3 : 0;
          const res = yield client2.call({
            _: "messages.getChatInviteImporters",
            limit,
            peer,
            link: typeof link === "string" ? link : link == null ? void 0 : link.link,
            requested,
            q: requestedSearch,
            offsetDate,
            offsetUser
          });
          const peers = PeersIndex.from(res);
          const members = res.importers.map((it) => new ChatInviteLinkMember(it, peers));
          const last2 = members[members.length - 1];
          const nextOffset = last2 ? {
            date: last2.raw.date,
            user: toInputUser(last2.user.inputPeer)
          } : void 0;
          return makeArrayPaginated(members, res.count, nextOffset);
        });
      }
      function getInviteLink(client2, chatId, link) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.getExportedChatInvite",
            peer: yield resolvePeer(client2, chatId),
            link
          });
          const peers = PeersIndex.from(res);
          return new ChatInviteLink(res.invite, peers);
        });
      }
      function getInviteLinks(client2, chatId, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          const { revoked = false, limit = Infinity, admin, offset } = params;
          const res = yield client2.call({
            _: "messages.getExportedChatInvites",
            peer: yield resolvePeer(client2, chatId),
            revoked,
            adminId: admin ? yield resolveUser(client2, admin) : { _: "inputUserSelf" },
            limit,
            offsetDate: offset == null ? void 0 : offset.date,
            offsetLink: offset == null ? void 0 : offset.link
          });
          const peers = PeersIndex.from(res);
          const links = res.invites.map((it) => new ChatInviteLink(it, peers));
          const last2 = links[links.length - 1];
          const nextOffset = last2 ? {
            date: last2.raw.date,
            link: last2.raw.link
          } : void 0;
          return makeArrayPaginated(links, res.count, nextOffset);
        });
      }
      function getPrimaryInviteLink(client2, chatId) {
        return __async(this, null, function* () {
          var _a3, _b2;
          const res = yield client2.call({
            _: "messages.getExportedChatInvites",
            peer: yield resolvePeer(client2, chatId),
            adminId: { _: "inputUserSelf" },
            limit: 1,
            revoked: false
          });
          if (((_a3 = res.invites[0]) == null ? void 0 : _a3._) !== "chatInviteExported") {
            throw new MtTypeAssertionError(
              "messages.getExportedChatInvites (@ .invites[0])",
              "chatInviteExported",
              (_b2 = res.invites[0]) == null ? void 0 : _b2._
            );
          }
          if (!res.invites[0].permanent) {
            throw new MtTypeAssertionError("messages.getExportedChatInvites (@ .invites[0].permanent)", "true", "false");
          }
          const peers = PeersIndex.from(res);
          return new ChatInviteLink(res.invites[0], peers);
        });
      }
      function hideAllJoinRequests(client2, params) {
        return __async(this, null, function* () {
          const { chatId, action, link } = params;
          yield client2.call({
            _: "messages.hideAllChatJoinRequests",
            approved: action === "approve",
            peer: yield resolvePeer(client2, chatId),
            link: typeof link === "string" ? link : link == null ? void 0 : link.link
          });
        });
      }
      function hideJoinRequest(client2, params) {
        return __async(this, null, function* () {
          const { chatId, user, action } = params;
          const userId = yield resolveUser(client2, user);
          yield client2.call({
            _: "messages.hideChatJoinRequest",
            approved: action === "approve",
            peer: yield resolvePeer(client2, chatId),
            userId
          });
        });
      }
      function iterInviteLinkMembers(client2, chatId, params) {
        return __asyncGenerator(this, null, function* () {
          const peer = yield new __await(resolvePeer(client2, chatId));
          if (!params)
            params = {};
          const { limit = Infinity, chunkSize = 100, link, requestedSearch, requested = Boolean(requestedSearch) } = params;
          let { offsetDate, offsetUser = { _: "inputUserEmpty" } } = params;
          let current2 = 0;
          for (; ; ) {
            const items = yield new __await(getInviteLinkMembers(client2, peer, {
              limit: Math.min(chunkSize, limit - current2),
              link,
              requested,
              requestedSearch,
              offsetDate,
              offsetUser
            }));
            if (!items.length)
              break;
            for(let   it of items) {
              yield it;
              if (++current2 >= limit)
                return;
            }
            if (!items.next)
              return;
            offsetDate = items.next.date;
            offsetUser = items.next.user;
          }
        });
      }
      function iterInviteLinks(client2, chatId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { revoked = false, limit = Infinity, chunkSize = 100, admin } = params;
          let { offset } = params;
          let current2 = 0;
          const peer = yield new __await(resolvePeer(client2, chatId));
          const adminResolved = admin ? yield new __await(resolvePeer(client2, admin)) : { _: "inputUserSelf" };
          for (; ; ) {
            const links = yield new __await(getInviteLinks(client2, peer, {
              admin: adminResolved,
              revoked,
              limit: Math.min(chunkSize, limit - current2),
              offset
            }));
            if (!links.length)
              return;
            for(let   link of links) {
              yield link;
              if (++current2 >= limit)
                break;
            }
            if (!links.next)
              return;
            offset = links.next;
          }
        });
      }
      function revokeInviteLink(client2, chatId, link) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.editExportedChatInvite",
            peer: yield resolvePeer(client2, chatId),
            link: typeof link === "string" ? link : link.link,
            revoked: true
          });
          const peers = PeersIndex.from(res);
          const invite = res._ === "messages.exportedChatInviteReplaced" ? res.newInvite : res.invite;
          return new ChatInviteLink(invite, peers);
        });
      }
      function closePoll(client2, params) {
        return __async(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const res = yield client2.call({
            _: "messages.editMessage",
            peer: yield resolvePeer(client2, chatId),
            id: message2,
            media: {
              _: "inputMediaPoll",
              poll: {
                _: "poll",
                id: Long.ZERO,
                closed: true,
                question: { _: "textWithEntities", text: "", entities: [] },
                answers: []
              }
            }
          });
          assertIsUpdatesGroup("messages.editMessage", res);
          client2.handleClientUpdate(res, !params.shouldDispatch);
          const upd = res.updates[0];
          assertTypeIs("messages.editMessage (@ .updates[0])", upd, "updateMessagePoll");
          if (!upd.poll) {
            throw new MtTypeAssertionError("messages.editMessage (@ .updates[0].poll)", "poll", "undefined");
          }
          const peers = PeersIndex.from(res);
          return new Poll(upd.poll, peers, upd.results);
        });
      }
      function deleteScheduledMessages(client2, chatId, ids) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, chatId);
          const res = yield client2.call({
            _: "messages.deleteScheduledMessages",
            peer,
            id: ids
          });
          client2.handleClientUpdate(res);
        });
      }
      function deleteMessagesById(client2, chatId, ids, params) {
        return __async(this, null, function* () {
          const { revoke = true, shouldDispatch } = params != null ? params : {};
          const peer = yield resolvePeer(client2, chatId);
          let upd;
          if (isInputPeerChannel(peer)) {
            const channel = toInputChannel(peer);
            const res = yield client2.call({
              _: "channels.deleteMessages",
              channel,
              id: ids
            });
            upd = createDummyUpdate(res.pts, res.ptsCount, peer.channelId);
          } else {
            const res = yield client2.call({
              _: "messages.deleteMessages",
              id: ids,
              revoke
            });
            upd = createDummyUpdate(res.pts, res.ptsCount);
          }
          if (!shouldDispatch) {
            client2.handleClientUpdate(upd);
          }
        });
      }
      function deleteMessages(client2, messages, params) {
        return __async(this, null, function* () {
          if (messages.length === 1) {
            return deleteMessagesById(client2, messages[0].chat.inputPeer, [messages[0].id], params);
          }
          const byChat = /* @__PURE__ */ new Map();
          const byChatScheduled = /* @__PURE__ */ new Map();
          for(let   msg of messages) {
            const map2 = msg.isScheduled ? byChatScheduled : byChat;
            if (!map2.has(msg.chat.id)) {
              map2.set(msg.chat.id, [msg.chat.inputPeer, []]);
            }
            map2.get(msg.chat.id)[1].push(msg.id);
          }
          for(let   [peer, ids] of byChat.values()) {
            yield deleteMessagesById(client2, peer, ids, params);
          }
          for(let   [peer, ids] of byChatScheduled.values()) {
            yield deleteScheduledMessages(client2, peer, ids);
          }
        });
      }
      function editInlineMessage(client2, params) {
        return __async(this, null, function* () {
          let content2;
          let entities;
          let media2;
          const id2 = normalizeInlineId(params.messageId);
          if (params.media) {
            media2 = yield _normalizeInputMedia(client2, params.media, params, true);
            if ("caption" in params.media && params.media.caption !== void 0) {
              [content2, entities] = yield _normalizeInputText(client2, params.media.caption);
            }
          } else if (params.text !== void 0) {
            [content2, entities] = yield _normalizeInputText(client2, params.text);
          }
          let retries = 3;
          while (retries--) {
            try {
              yield client2.call(
                {
                  _: "messages.editInlineBotMessage",
                  id: id2,
                  noWebpage: params.disableWebPreview,
                  replyMarkup: _convertToTl$2(params.replyMarkup),
                  message: content2,
                  entities,
                  media: media2,
                  invertMedia: params.invertMedia
                },
                { dcId: id2.dcId }
              );
              return;
            } catch (e2) {
              if (tl.tl.RpcError.is(e2, "MEDIA_EMPTY")) {
                continue;
              }
              throw e2;
            }
          }
        });
      }
      function editMessage(client2, params) {
        return __async(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          let content2;
          let entities;
          let media2;
          if (params.media) {
            media2 = yield _normalizeInputMedia(client2, params.media, params);
            if ("caption" in params.media && params.media.caption !== void 0) {
              [content2, entities] = yield _normalizeInputText(client2, params.media.caption);
            }
          }
          if (params.text !== void 0) {
            [content2, entities] = yield _normalizeInputText(client2, params.text);
          }
          const res = yield _maybeInvokeWithBusinessConnection(client2, params.businessConnectionId, {
            _: "messages.editMessage",
            id: message2,
            peer: yield resolvePeer(client2, chatId),
            noWebpage: params.disableWebPreview,
            replyMarkup: _convertToTl$2(params.replyMarkup),
            message: content2,
            entities,
            media: media2,
            invertMedia: params.invertMedia
          });
          return _findMessageInUpdate(client2, res, true, !params.shouldDispatch);
        });
      }
      function forwardMessagesById(client2, params) {
        return __async(this, null, function* () {
          const { messages, toChatId, fromChatId, silent, schedule, forbidForwards, sendAs, noAuthor, noCaption } = params;
          if (messages.length > 100) {
            throw new MtArgumentError("You can forward no more than 100 messages at once");
          }
          const toPeer = yield resolvePeer(client2, toChatId);
          const res = yield client2.call({
            _: "messages.forwardMessages",
            toPeer,
            fromPeer: yield resolvePeer(client2, fromChatId),
            id: messages,
            silent,
            scheduleDate: normalizeDate(schedule),
            randomId: Array.from({ length: messages.length }, () => randomLong()),
            dropAuthor: noAuthor,
            dropMediaCaptions: noCaption,
            noforwards: forbidForwards,
            sendAs: sendAs ? yield resolvePeer(client2, sendAs) : void 0,
            quickReplyShortcut: _normalizeQuickReplyShortcut(params.quickReply)
          });
          assertIsUpdatesGroup("messages.forwardMessages", res);
          client2.handleClientUpdate(res, !params.shouldDispatch);
          const peers = PeersIndex.from(res);
          const forwarded = [];
          res.updates.forEach((upd) => {
            switch (upd._) {
              case "updateNewMessage":
              case "updateNewChannelMessage":
              case "updateNewScheduledMessage":
                forwarded.push(new Message(upd.message, peers, upd._ === "updateNewScheduledMessage"));
                break;
            }
          });
          return forwarded;
        });
      }
      function forwardMessages(client2, params) {
        return __async(this, null, function* () {
          const _a3 = params, { messages } = _a3, rest = __objRest(_a3, ["messages"]);
          return forwardMessagesById(client2, __spreadProps(__spreadValues({}, rest), {
            fromChatId: messages[0].chat.inputPeer,
            messages: messages.map((it) => it.id)
          }));
        });
      }
      function getAllScheduledMessages(client2, chatId) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, chatId);
          const res = yield client2.call({
            _: "messages.getScheduledHistory",
            peer,
            hash: Long.ZERO
          });
          assertTypeIsNot("getScheduledMessages", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          const ret = res.messages.map((msg) => {
            assertTypeIsNot("getScheduledMessages", msg, "messageEmpty");
            return new Message(msg, peers, true);
          });
          return ret;
        });
      }
      function getAvailableMessageEffects(client2) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.getAvailableEffects",
            hash: 0
          });
          assertTypeIsNot("getAvailableMessageEffects", res, "messages.availableEffectsNotModified");
          const documentsMap = new LongMap();
          for(let   doc of res.documents) {
            if (doc._ !== "document")
              continue;
            documentsMap.set(doc.id, doc);
          }
          return res.effects.map((effect) => new MessageEffect(effect, documentsMap));
        });
      }
      function getCallbackQueryMessage(client2, id2) {
        return __async(this, null, function* () {
          let msgId;
          let queryId;
          let peer;
          if ("_" in id2) {
            msgId = id2.msgId;
            queryId = id2.queryId;
            peer = yield resolvePeer(client2, id2.peer);
          } else if ("raw" in id2) {
            msgId = id2.messageId;
            queryId = id2.id;
            peer = id2.chat.inputPeer;
          } else {
            msgId = id2.messageId;
            queryId = id2.queryId;
            peer = yield resolvePeer(client2, id2.peer);
          }
          const inputMessage = {
            _: "inputMessageCallbackQuery",
            id: msgId,
            queryId
          };
          const isChannel = isInputPeerChannel(peer);
          const res = yield client2.call(
            isChannel ? {
              _: "channels.getMessages",
              id: [inputMessage],
              channel: toInputChannel(peer)
            } : {
              _: "messages.getMessages",
              id: [inputMessage]
            }
          );
          assertTypeIsNot("getCallbackQueryMessage", res, "messages.messagesNotModified");
          if (res.messages[0]._ === "messageEmpty") {
            return null;
          }
          return new Message(res.messages[0], PeersIndex.from(res));
        });
      }
      function getFactCheck(client2, chatId, msgIds) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.getFactCheck",
            peer: yield resolvePeer(client2, chatId),
            msgId: Array.isArray(msgIds) ? msgIds : [msgIds]
          });
          return res.map((x) => {
            if (x.hash.isZero()) {
              return null;
            }
            return new FactCheck(x);
          });
        });
      }
      const defaultOffset$2 = {
        id: 0,
        date: 0
      };
      const defaultOffsetReverse = {
        id: 1,
        date: 0
      };
      function getHistory(client2, chatId, params) {
        return __async(this, null, function* () {
          var _a3;
          if (!params)
            params = {};
          const {
            reverse = false,
            limit = 100,
            offset: { id: offsetId, date: offsetDate } = reverse ? defaultOffsetReverse : defaultOffset$2,
            addOffset = 0,
            minId = 0,
            maxId = 0
          } = params;
          const addOffsetAdjusted = addOffset + (reverse ? -limit : 0);
          const peer = yield resolvePeer(client2, chatId);
          const res = yield client2.call({
            _: "messages.getHistory",
            peer,
            offsetId,
            offsetDate,
            addOffset: addOffsetAdjusted,
            limit,
            maxId,
            minId,
            hash: Long.ZERO
          });
          assertTypeIsNot("getHistory", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
          if (reverse)
            msgs.reverse();
          const last2 = msgs[msgs.length - 1];
          const next2 = last2 ? {
            id: last2.id + (reverse ? 1 : 0),
            date: last2.raw.date
          } : void 0;
          return makeArrayPaginated(msgs, (_a3 = res.count) != null ? _a3 : msgs.length, next2);
        });
      }
      function getMessageByLink(client2, link) {
        return __async(this, null, function* () {
          const parsed = message$1.parse(link);
          if (!parsed) {
            throw new MtArgumentError(`Invalid message link: ${link}`);
          }
          let peer;
          if ("username" in parsed) {
            peer = yield resolvePeer(client2, parsed.username);
          } else {
            peer = yield resolvePeer(client2, toggleChannelIdMark(parsed.channelId));
          }
          let msgId = parsed.id;
          if (parsed.commentId) {
            [peer] = yield _getDiscussionMessage(client2, peer, parsed.id);
            msgId = parsed.commentId;
          }
          const [msg] = yield getMessages(client2, peer, msgId);
          return msg;
        });
      }
      function getMessageGroup(client2, params) {
        return __async(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const peer = yield resolvePeer(client2, chatId);
          const delta = isInputPeerChannel(peer) ? 9 : 19;
          const ids = [];
          for (let i = Math.max(message2 - delta, 0); i <= message2 + delta; i++) {
            ids.push(i);
          }
          const messages = yield getMessages(client2, chatId, ids);
          const groupedId = messages.find((it) => (it == null ? void 0 : it.id) === message2).groupedId;
          if (!groupedId)
            throw new MtArgumentError("This message is not grouped");
          return messages.filter(isPresent).filter((it) => {
            var _a3;
            return (_a3 = it.groupedId) == null ? void 0 : _a3.eq(groupedId);
          });
        });
      }
      function getMessageReactionsById(client2, chatId, messages) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.getMessagesReactions",
            peer: yield resolvePeer(client2, chatId),
            id: messages
          });
          assertIsUpdatesGroup("messages.getMessagesReactions", res);
          client2.handleClientUpdate(res);
          const index = {};
          const peers = PeersIndex.from(res);
          for(let   update of res.updates) {
            assertTypeIs("messages.getMessagesReactions", update, "updateMessageReactions");
            index[update.msgId] = new MessageReactions(update.msgId, getMarkedPeerId(update.peer), update.reactions, peers);
          }
          return messages.map((messageId) => {
            var _a3;
            return (_a3 = index[messageId]) != null ? _a3 : null;
          });
        });
      }
      function getMessageReactions(client2, messages) {
        return __async(this, null, function* () {
          return getMessageReactionsById(
            client2,
            messages[0].chat.inputPeer,
            messages.map((it) => it.id)
          );
        });
      }
      function getMessagesUnsafe(client2, messageIds, fromReply = false) {
        return __async(this, null, function* () {
          if (!Array.isArray(messageIds))
            messageIds = [messageIds];
          const type = fromReply ? "inputMessageReplyTo" : "inputMessageID";
          const ids = messageIds.map((it) => ({
            _: type,
            id: it
          }));
          const res = yield client2.call({
            _: "messages.getMessages",
            id: ids
          });
          assertTypeIsNot("getMessagesUnsafe", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          return res.messages.map((msg) => {
            if (msg._ === "messageEmpty")
              return null;
            return new Message(msg, peers);
          });
        });
      }
      function getReactionUsers(client2, params) {
        return __async(this, null, function* () {
          const { limit = 100, offset, emoji: emoji2 } = params;
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const peer = yield resolvePeer(client2, chatId);
          const reaction = normalizeInputReaction(emoji2);
          const res = yield client2.call({
            _: "messages.getMessageReactionsList",
            peer,
            id: message2,
            reaction,
            limit,
            offset
          });
          const peers = PeersIndex.from(res);
          return makeArrayPaginated(
            res.reactions.map((it) => new PeerReaction(it, peers)),
            res.count,
            res.nextOffset
          );
        });
      }
      function getReplyTo(client2, message2) {
        return __async(this, null, function* () {
          var _a3;
          if (!((_a3 = message2.replyToMessage) == null ? void 0 : _a3.id)) {
            return null;
          }
          if (message2.raw.peerId._ === "peerChannel") {
            const [msg2] = yield getMessages(client2, message2.chat.inputPeer, message2.id, true);
            return msg2;
          }
          const [msg] = yield getMessagesUnsafe(client2, message2.id, true);
          return msg;
        });
      }
      function getScheduledMessages(client2, chatId, messageIds) {
        return __async(this, null, function* () {
          const peer = yield resolvePeer(client2, chatId);
          if (!Array.isArray(messageIds))
            messageIds = [messageIds];
          const res = yield client2.call({
            _: "messages.getScheduledMessages",
            peer,
            id: messageIds
          });
          assertTypeIsNot("getScheduledMessages", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          const ret = res.messages.map((msg) => {
            if (msg._ === "messageEmpty")
              return null;
            return new Message(msg, peers, true);
          });
          return ret;
        });
      }
      function iterHistory(client2, chatId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { limit = Infinity, chunkSize = 100, minId = 0, maxId = 0, reverse = false } = params;
          let { offset, addOffset = 0 } = params;
          let current2 = 0;
          const peer = yield new __await(resolvePeer(client2, chatId));
          for (; ; ) {
            const res = yield new __await(getHistory(client2, peer, {
              offset,
              addOffset,
              limit: Math.min(chunkSize, limit - current2),
              maxId,
              minId,
              reverse
            }));
            for(let   msg of res) {
              yield msg;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
            addOffset = 0;
          }
        });
      }
      function iterReactionUsers(client2, params) {
        return __asyncGenerator(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const peer = yield new __await(resolvePeer(client2, chatId));
          const { limit = Infinity, chunkSize = 100 } = params;
          let current2 = 0;
          let { offset } = params;
          const reaction = normalizeInputReaction(params.emoji);
          for (; ; ) {
            const res = yield new __await(getReactionUsers(client2, {
              chatId: peer,
              message: message2,
              emoji: reaction,
              limit: Math.min(chunkSize, limit - current2),
              offset
            }));
            offset = res.next;
            for(let   reaction2 of res) {
              yield reaction2;
              if (++current2 >= limit)
                break;
            }
          }
        });
      }
      const defaultOffset$1 = {
        rate: 0,
        peer: { _: "inputPeerEmpty" },
        id: 0
      };
      function searchGlobal(client2, params) {
        return __async(this, null, function* () {
          var _a3, _b2, _c, _d;
          if (!params)
            params = {};
          const {
            query = "",
            filter = SearchFilters.Empty,
            limit = 100,
            offset: { rate: offsetRate, peer: offsetPeer, id: offsetId } = defaultOffset$1,
            onlyChannels
          } = params;
          const minDate = (_a3 = normalizeDate(params.minDate)) != null ? _a3 : 0;
          const maxDate = (_b2 = normalizeDate(params.maxDate)) != null ? _b2 : 0;
          const res = yield client2.call({
            _: "messages.searchGlobal",
            q: query,
            filter,
            minDate,
            maxDate,
            offsetId,
            offsetRate,
            offsetPeer,
            limit,
            broadcastsOnly: onlyChannels
          });
          assertTypeIsNot("searchGlobal", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
          const last2 = msgs[msgs.length - 1];
          const next2 = last2 ? {
            rate: (_c = res.nextRate) != null ? _c : last2.raw.date,
            peer: last2.chat.inputPeer,
            id: last2.id
          } : void 0;
          return makeArrayPaginated(msgs, (_d = res.count) != null ? _d : msgs.length, next2);
        });
      }
      function iterSearchGlobal(client2, params) {
        return __asyncGenerator(this, null, function* () {
          var _a3, _b2;
          if (!params)
            params = {};
          const { query = "", filter = SearchFilters.Empty, limit = Infinity, chunkSize = 100, onlyChannels } = params;
          const minDate = (_a3 = normalizeDate(params.minDate)) != null ? _a3 : 0;
          const maxDate = (_b2 = normalizeDate(params.maxDate)) != null ? _b2 : 0;
          let { offset } = params;
          let current2 = 0;
          for (; ; ) {
            const res = yield new __await(searchGlobal(client2, {
              query,
              filter,
              limit: Math.min(chunkSize, limit - current2),
              minDate,
              maxDate,
              offset,
              onlyChannels
            }));
            if (!res.length)
              return;
            for(let   msg of res) {
              yield msg;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
          }
        });
      }
      function searchMessages(client2, params) {
        return __async(this, null, function* () {
          var _a3, _b2, _c;
          if (!params)
            params = {};
          const {
            query = "",
            chatId = { _: "inputPeerEmpty" },
            offset = 0,
            addOffset = 0,
            minId = 0,
            maxId = 0,
            threadId,
            limit = 100,
            filter = SearchFilters.Empty
          } = params;
          const minDate = (_a3 = normalizeDate(params.minDate)) != null ? _a3 : 0;
          const maxDate = (_b2 = normalizeDate(params.maxDate)) != null ? _b2 : 0;
          const peer = yield resolvePeer(client2, chatId);
          const fromUser = params.fromUser ? yield resolvePeer(client2, params.fromUser) : void 0;
          const res = yield client2.call({
            _: "messages.search",
            peer,
            q: query,
            filter,
            minDate,
            maxDate,
            offsetId: offset,
            addOffset,
            limit,
            minId,
            maxId,
            fromId: fromUser,
            topMsgId: threadId,
            hash: Long.ZERO
          });
          assertTypeIsNot("searchMessages", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
          const last2 = msgs[msgs.length - 1];
          const next2 = last2 ? last2.id : void 0;
          return makeArrayPaginated(msgs, (_c = res.count) != null ? _c : msgs.length, next2);
        });
      }
      function iterSearchMessages(client2, params) {
        return __asyncGenerator(this, null, function* () {
          var _a3, _b2;
          if (!params)
            params = {};
          const {
            query = "",
            chatId = { _: "inputPeerEmpty" },
            minId = 0,
            maxId = 0,
            threadId,
            limit = Infinity,
            chunkSize = 100,
            filter = SearchFilters.Empty
          } = params;
          const minDate = (_a3 = normalizeDate(params.minDate)) != null ? _a3 : 0;
          const maxDate = (_b2 = normalizeDate(params.maxDate)) != null ? _b2 : 0;
          const peer = yield new __await(resolvePeer(client2, chatId));
          const fromUser = params.fromUser ? yield new __await(resolvePeer(client2, params.fromUser)) : void 0;
          let { offset, addOffset } = params;
          let current2 = 0;
          for (; ; ) {
            const res = yield new __await(searchMessages(client2, {
              query,
              chatId: peer,
              offset,
              addOffset,
              minId,
              maxId,
              threadId,
              filter,
              fromUser,
              minDate,
              maxDate,
              limit: Math.min(chunkSize, limit - current2)
            }));
            if (!res.length)
              break;
            for(let   msg of res) {
              yield msg;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              break;
            offset = res.next;
            addOffset = void 0;
          }
        });
      }
      function pinMessage(client2, params) {
        return __async(this, null, function* () {
          const { notify, bothSides, shouldDispatch } = params != null ? params : {};
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const res = yield client2.call({
            _: "messages.updatePinnedMessage",
            peer: yield resolvePeer(client2, chatId),
            id: message2,
            silent: !notify,
            pmOneside: !bothSides
          });
          return _findMessageInUpdate(client2, res, false, !shouldDispatch, true);
        });
      }
      function readReactions(client2, chatId, params) {
        return __async(this, null, function* () {
          const { shouldDispatch } = params != null ? params : {};
          const res = yield client2.call({
            _: "messages.readReactions",
            peer: yield resolvePeer(client2, chatId)
          });
          if (!shouldDispatch) {
            client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
          }
        });
      }
      const defaultOffset = {
        rate: 0,
        peer: { _: "inputPeerEmpty" },
        id: 0
      };
      function searchHashtag(client2, hashtag, params) {
        return __async(this, null, function* () {
          var _a3, _b2;
          const { offset: { rate: offsetRate, peer: offsetPeer, id: offsetId } = defaultOffset, limit = 100 } = params != null ? params : {};
          const res = yield client2.call({
            _: "channels.searchPosts",
            hashtag,
            offsetId,
            offsetRate,
            offsetPeer,
            limit
          });
          assertTypeIsNot("searchHashtag", res, "messages.messagesNotModified");
          const peers = PeersIndex.from(res);
          const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
          const last2 = msgs[msgs.length - 1];
          const next2 = last2 ? {
            rate: (_a3 = res.nextRate) != null ? _a3 : last2.raw.date,
            peer: last2.chat.inputPeer,
            id: last2.id
          } : void 0;
          return makeArrayPaginated(msgs, (_b2 = res.count) != null ? _b2 : msgs.length, next2);
        });
      }
      function iterSearchHashtag(client2, hashtag, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { limit = Infinity, chunkSize = 100 } = params;
          let { offset } = params;
          let current2 = 0;
          for (; ; ) {
            const res = yield new __await(searchHashtag(client2, hashtag, {
              offset,
              limit: Math.min(chunkSize, limit - current2)
            }));
            if (!res.length)
              return;
            for(let   msg of res) {
              yield msg;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
          }
        });
      }
      function answerText(client2, message2, ...params) {
        var _a3;
        if (!message2.isTopicMessage || !((_a3 = message2.replyToMessage) == null ? void 0 : _a3.threadId)) {
          return sendText(client2, message2.chat.inputPeer, ...params);
        }
        const [text2, params_ = {}] = params;
        params_.replyTo = message2.replyToMessage.threadId;
        return sendText(client2, message2.chat.inputPeer, text2, params_);
      }
      function answerMedia(client2, message2, ...params) {
        var _a3;
        if (!message2.isTopicMessage || !((_a3 = message2.replyToMessage) == null ? void 0 : _a3.threadId)) {
          return sendMedia(client2, message2.chat.inputPeer, ...params);
        }
        const [media2, params_ = {}] = params;
        params_.replyTo = message2.replyToMessage.threadId;
        return sendMedia(client2, message2.chat.inputPeer, media2, params_);
      }
      function answerMediaGroup(client2, message2, ...params) {
        var _a3;
        if (!message2.isTopicMessage || !((_a3 = message2.replyToMessage) == null ? void 0 : _a3.threadId)) {
          return sendMediaGroup(client2, message2.chat.inputPeer, ...params);
        }
        const [media2, params_ = {}] = params;
        params_.replyTo = message2.replyToMessage.threadId;
        return sendMediaGroup(client2, message2.chat.inputPeer, media2, params_);
      }
      function replyText(client2, message2, ...params) {
        const [text2, params_ = {}] = params;
        params_.replyTo = message2.id;
        return sendText(client2, message2.chat.inputPeer, text2, params_);
      }
      function replyMedia(client2, message2, ...params) {
        const [media2, params_ = {}] = params;
        params_.replyTo = message2.id;
        return sendMedia(client2, message2.chat.inputPeer, media2, params_);
      }
      function replyMediaGroup(client2, message2, ...params) {
        const [media2, params_ = {}] = params;
        params_.replyTo = message2.id;
        return sendMediaGroup(client2, message2.chat.inputPeer, media2, params_);
      }
      function commentText(client2, message2, ...params) {
        if (message2.chat.chatType !== "channel") {
          return replyText(client2, message2, ...params);
        }
        if (!message2.replies || !message2.replies.hasComments) {
          throw new MtArgumentError("This message does not have comments section");
        }
        const [text2, params_ = {}] = params;
        params_.commentTo = message2.id;
        return sendText(client2, message2.chat.inputPeer, text2, params_);
      }
      function commentMedia(client2, message2, ...params) {
        if (message2.chat.chatType !== "channel") {
          return replyMedia(client2, message2, ...params);
        }
        if (!message2.replies || !message2.replies.hasComments) {
          throw new MtArgumentError("This message does not have comments section");
        }
        const [media2, params_ = {}] = params;
        params_.commentTo = message2.id;
        return sendMedia(client2, message2.chat.inputPeer, media2, params_);
      }
      function commentMediaGroup(client2, message2, ...params) {
        if (message2.chat.chatType !== "channel") {
          return replyMediaGroup(client2, message2, ...params);
        }
        if (!message2.replies || !message2.replies.hasComments) {
          throw new MtArgumentError("This message does not have comments section");
        }
        const [media2, params_ = {}] = params;
        params_.commentTo = message2.id;
        return sendMediaGroup(client2, message2.chat.inputPeer, media2, params_);
      }
      function sendCopyGroup(client2, params) {
        return __async(this, null, function* () {
          var _b2;
          const _a3 = params, { toChatId } = _a3, rest = __objRest(_a3, ["toChatId"]);
          let msgs;
          if ("fromChatId" in params) {
            const fromPeer = yield resolvePeer(client2, params.fromChatId);
            msgs = yield getMessages(client2, fromPeer, params.messages).then((r2) => r2.filter(isPresent));
          } else {
            msgs = params.messages;
          }
          const messageGroupId = msgs[0].groupedId;
          for (let i = 1; i < msgs.length; i++) {
            if (!((_b2 = msgs[i].groupedId) == null ? void 0 : _b2.eq(messageGroupId)) || !msgs[i].media) {
              throw new MtArgumentError("All messages must be in the same message group");
            }
          }
          return sendMediaGroup(
            client2,
            toChatId,
            msgs.map((msg) => {
              const raw = msg.raw;
              return {
                type: "auto",
                file: msg.media.inputMedia,
                caption: raw.message,
                entities: raw.entities
              };
            }),
            rest
          );
        });
      }
      function sendCopy(client2, params) {
        return __async(this, null, function* () {
          var _b2;
          const _a3 = params, { toChatId } = _a3, rest = __objRest(_a3, ["toChatId"]);
          let msg;
          if ("fromChatId" in params) {
            const fromPeer = yield resolvePeer(client2, params.fromChatId);
            [msg] = yield getMessages(client2, fromPeer, params.message);
            if (!msg) {
              throw new MtMessageNotFoundError(getMarkedPeerId(fromPeer), params.message, "to copy");
            }
          } else {
            msg = params.message;
          }
          if (msg.raw._ === "messageService") {
            throw new MtArgumentError("Service messages can't be copied");
          }
          if (msg.media && msg.media.type !== "webpage" && msg.media.type !== "invoice") {
            let caption = params.caption;
            if (!caption) {
              if ((_b2 = msg.raw.entities) == null ? void 0 : _b2.length) {
                caption = {
                  text: msg.raw.message,
                  entities: msg.raw.entities
                };
              } else {
                caption = msg.raw.message;
              }
            }
            return sendMedia(
              client2,
              toChatId,
              {
                type: "auto",
                file: msg.media.inputMedia,
                caption
              },
              rest
            );
          }
          return sendText(client2, toChatId, msg.raw.message, rest);
        });
      }
      function sendPaidReaction(client2, params) {
        return __async(this, null, function* () {
          const { anonymous, count: count2 = 1 } = params;
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const peer = yield resolvePeer(client2, chatId);
          let res;
          for (let i = 0; i < 3; i++) {
            try {
              res = yield client2.call({
                _: "messages.sendPaidReaction",
                peer,
                msgId: message2,
                count: count2,
                private: anonymous,
                randomId: yield client2.getMtprotoMessageId()
              });
              break;
            } catch (e2) {
              if (tl.tl.RpcError.is(e2, "RANDOM_ID_EXPIRED")) {
                continue;
              }
              throw e2;
            }
          }
          if (!res) {
            throw new MtcuteError("Could not send paid reaction");
          }
          assertIsUpdatesGroup("messages.sendReaction", res);
          const peers = PeersIndex.from(res);
          const upd = res.updates[0];
          assertTypeIs("messages.sendPaidReaction (@ .updates[0])", upd, "updateMessageReactions");
          return new MessageReactions(upd.msgId, getMarkedPeerId(upd.peer), upd.reactions, peers);
        });
      }
      function extractQuote(message2, from2, to) {
        const { raw } = message2;
        if (raw._ === "messageService")
          throw new MtArgumentError("Cannot quote service message");
        if (!raw.message)
          throw new MtArgumentError("Cannot quote empty message");
        const text2 = raw.message;
        if (from2 < 0)
          from2 = 0;
        if (to > text2.length)
          to = text2.length;
        if (from2 >= to)
          throw new MtArgumentError("Invalid quote range");
        if (!raw.entities)
          return { text: text2.slice(from2, to), entities: void 0 };
        const entities = [];
        for(let   ent of raw.entities) {
          const start2 = ent.offset;
          const end = ent.offset + ent.length;
          if (start2 >= to || end <= from2)
            continue;
          const newStart = Math.max(start2, from2) - from2;
          const newEnd = Math.min(end, to) - from2;
          const newEnt = __spreadProps(__spreadValues({}, ent), { offset: newStart, length: newEnd - newStart });
          entities.push(newEnt);
        }
        return { text: text2.slice(from2, to), entities };
      }
      function quoteWithText(client2, message2, params) {
        const _a3 = params, { toChatId = message2.chat, start: start2, end, text: text2 } = _a3, params__ = __objRest(_a3, ["toChatId", "start", "end", "text"]);
        const params_ = params__;
        params_.replyTo = message2;
        params_.quote = extractQuote(message2, params.start, params.end);
        params_.quoteOffset = params.start;
        return sendText(client2, toChatId, text2, params_);
      }
      function quoteWithMedia(client2, message2, params) {
        const _a3 = params, { toChatId = message2.chat, start: start2, end, media: media2 } = _a3, params__ = __objRest(_a3, ["toChatId", "start", "end", "media"]);
        const params_ = params__;
        params_.replyTo = message2;
        params_.quote = extractQuote(message2, params.start, params.end);
        params_.quoteOffset = params.start;
        return sendMedia(client2, toChatId, media2, params_);
      }
      function quoteWithMediaGroup(client2, message2, params) {
        const _a3 = params, { toChatId, start: start2, end, medias } = _a3, params__ = __objRest(_a3, ["toChatId", "start", "end", "medias"]);
        const params_ = params__;
        params_.replyTo = message2;
        params_.quote = extractQuote(message2, params.start, params.end);
        params_.quoteOffset = params.start;
        return sendMediaGroup(client2, message2.chat.inputPeer, medias, params_);
      }
      function sendReaction(client2, params) {
        return __async(this, null, function* () {
          const { emoji: emoji2, big } = params;
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const emojis2 = Array.isArray(emoji2) ? emoji2 : [emoji2];
          const reactions = emojis2.map(normalizeInputReaction);
          const res = yield client2.call({
            _: "messages.sendReaction",
            peer: yield resolvePeer(client2, chatId),
            msgId: message2,
            reaction: reactions,
            big
          });
          assertIsUpdatesGroup("messages.sendReaction", res);
          return _findMessageInUpdate(client2, res, true, !params.shouldDispatch, true);
        });
      }
      function sendScheduled(client2, peer, ids) {
        return __async(this, null, function* () {
          if (!Array.isArray(ids))
            ids = [ids];
          const res = yield client2.call({
            _: "messages.sendScheduledMessages",
            peer: yield resolvePeer(client2, peer),
            id: ids
          });
          assertIsUpdatesGroup("sendScheduled", res);
          client2.handleClientUpdate(res, true);
          const peers = PeersIndex.from(res);
          const msgs = res.updates.filter(
            (u) => u._ === "updateNewMessage" || u._ === "updateNewChannelMessage"
          ).map((u) => new Message(u.message, peers));
          return msgs;
        });
      }
      function sendTyping(client2, chatId, status = "typing", params) {
        return __async(this, null, function* () {
          var _a3;
          if (typeof status === "string") {
            const progress2 = (_a3 = params == null ? void 0 : params.progress) != null ? _a3 : 0;
            switch (status) {
              case "typing":
                status = { _: "sendMessageTypingAction" };
                break;
              case "cancel":
                status = { _: "sendMessageCancelAction" };
                break;
              case "record_video":
                status = { _: "sendMessageRecordVideoAction" };
                break;
              case "upload_video":
                status = { _: "sendMessageUploadVideoAction", progress: progress2 };
                break;
              case "record_voice":
                status = { _: "sendMessageRecordAudioAction" };
                break;
              case "upload_voice":
                status = { _: "sendMessageUploadAudioAction", progress: progress2 };
                break;
              case "upload_photo":
                status = { _: "sendMessageUploadPhotoAction", progress: progress2 };
                break;
              case "upload_document":
                status = { _: "sendMessageUploadDocumentAction", progress: progress2 };
                break;
              case "geo":
                status = { _: "sendMessageGeoLocationAction" };
                break;
              case "contact":
                status = { _: "sendMessageChooseContactAction" };
                break;
              case "game":
                status = { _: "sendMessageGamePlayAction" };
                break;
              case "record_round":
                status = { _: "sendMessageRecordRoundAction" };
                break;
              case "upload_round":
                status = { _: "sendMessageUploadRoundAction", progress: progress2 };
                break;
              case "speak_call":
                status = { _: "speakingInGroupCallAction" };
                break;
              case "history_import":
                status = { _: "sendMessageHistoryImportAction", progress: progress2 };
                break;
              case "sticker":
                status = { _: "sendMessageChooseStickerAction" };
                break;
              default:
                assertNever$1();
            }
          }
          const r2 = yield _maybeInvokeWithBusinessConnection(client2, params == null ? void 0 : params.businessConnectionId, {
            _: "messages.setTyping",
            peer: yield resolvePeer(client2, chatId),
            action: status,
            topMsgId: params == null ? void 0 : params.threadId
          });
          assertTrue("messages.setTyping", r2);
        });
      }
      function sendVote(client2, params) {
        return __async(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          let { options: options2 } = params;
          if (options2 === null)
            options2 = [];
          if (!Array.isArray(options2))
            options2 = [options2];
          const peer = yield resolvePeer(client2, chatId);
          let poll2;
          if (options2.some((it) => typeof it === "number")) {
            const [msg] = yield getMessages(client2, peer, message2);
            if (!msg) {
              throw new MtMessageNotFoundError(getMarkedPeerId(peer), message2, "to vote in");
            }
            if (!(msg.media instanceof Poll)) {
              throw new MtArgumentError("This message does not contain a poll");
            }
            poll2 = msg.media;
            options2 = options2.map((opt) => {
              if (typeof opt === "number") {
                return poll2.raw.answers[opt].option;
              }
              return opt;
            });
          }
          const res = yield client2.call({
            _: "messages.sendVote",
            peer,
            msgId: message2,
            options: options2
          });
          assertIsUpdatesGroup("messages.sendVote", res);
          client2.handleClientUpdate(res, true);
          const upd = res.updates[0];
          assertTypeIs("messages.sendVote (@ .updates[0])", upd, "updateMessagePoll");
          if (!upd.poll) {
            throw new MtTypeAssertionError("messages.sendVote (@ .updates[0].poll)", "poll", "undefined");
          }
          const peers = PeersIndex.from(res);
          return new Poll(upd.poll, peers, upd.results);
        });
      }
      function translateMessage(client2, params) {
        return __async(this, null, function* () {
          const { toLanguage } = params;
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const res = yield client2.call({
            _: "messages.translateText",
            peer: yield resolvePeer(client2, chatId),
            id: [message2],
            toLang: toLanguage
          });
          return {
            text: res.result[0].text,
            entities: res.result[0].entities
          };
        });
      }
      function translateText(client2, text2, toLanguage) {
        return __async(this, null, function* () {
          const [message2, entities] = yield _normalizeInputText(client2, text2);
          const res = yield client2.call({
            _: "messages.translateText",
            text: [
              {
                _: "textWithEntities",
                text: message2,
                entities: entities || []
              }
            ],
            toLang: toLanguage
          });
          if (!res.result[0]) {
            throw new MtTypeAssertionError("messages.translateResult#result", "not empty", "empty");
          }
          return {
            text: res.result[0].text,
            entities: res.result[0].entities
          };
        });
      }
      function unpinAllMessages(client2, chatId, params) {
        return __async(this, null, function* () {
          const { topicId, shouldDispatch } = params != null ? params : {};
          const peer = yield resolvePeer(client2, chatId);
          const res = yield client2.call({
            _: "messages.unpinAllMessages",
            peer,
            topMsgId: topicId
          });
          if (!shouldDispatch) {
            if (isInputPeerChannel(peer)) {
              client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, peer.channelId));
            } else {
              client2.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
            }
          }
        });
      }
      function unpinMessage(client2, params) {
        return __async(this, null, function* () {
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const res = yield client2.call({
            _: "messages.updatePinnedMessage",
            peer: yield resolvePeer(client2, chatId),
            id: message2,
            unpin: true
          });
          client2.handleClientUpdate(res);
        });
      }
      function getCollectibleInfo(client2, kind, item2) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "fragment.getCollectibleInfo",
            collectible: kind === "phone" ? {
              _: "inputCollectiblePhone",
              phone: normalizePhoneNumber(item2)
            } : {
              _: "inputCollectibleUsername",
              username: item2
            }
          });
          return new CollectibleInfo(res);
        });
      }
      function initTakeoutSession(client2, params) {
        return __async(this, null, function* () {
          return new TakeoutSession(
            client2,
            yield client2.call(__spreadValues({
              _: "account.initTakeoutSession"
            }, params))
          );
        });
      }
      function _normalizePrivacyRules(client2, rules) {
        return __async(this, null, function* () {
          const res = [];
          for(let   rule of rules) {
            if ("_" in rule) {
              res.push(rule);
              continue;
            }
            if ("users" in rule) {
              const users = yield resolvePeerMany(client2, rule.users, toInputUser);
              res.push({
                _: rule.allow ? "inputPrivacyValueAllowUsers" : "inputPrivacyValueDisallowUsers",
                users
              });
              continue;
            }
            if ("chats" in rule) {
              const chats = yield resolvePeerMany(client2, rule.chats);
              res.push({
                _: rule.allow ? "inputPrivacyValueAllowChatParticipants" : "inputPrivacyValueDisallowChatParticipants",
                chats: chats.filter(isPresent).map((peer) => {
                  if ("channelId" in peer)
                    return peer.channelId;
                  if ("chatId" in peer)
                    return peer.chatId;
                  throw new Error("UNREACHABLE");
                })
              });
              continue;
            }
          }
          return res;
        });
      }
      function changeCloudPassword(client2, params) {
        return __async(this, null, function* () {
          const { currentPassword, newPassword, hint } = params;
          const pwd = yield client2.call({ _: "account.getPassword" });
          if (!pwd.hasPassword) {
            throw new MtArgumentError("Cloud password is not enabled");
          }
          const algo = pwd.newAlgo;
          const oldSrp = yield client2.computeSrpParams(pwd, currentPassword);
          const newHash = yield client2.computeNewPasswordHash(algo, newPassword);
          yield client2.call({
            _: "account.updatePasswordSettings",
            password: oldSrp,
            newSettings: {
              _: "account.passwordInputSettings",
              newAlgo: algo,
              newPasswordHash: newHash,
              hint
            }
          });
        });
      }
      function enableCloudPassword(client2, params) {
        return __async(this, null, function* () {
          const { password, hint, email } = params;
          const pwd = yield client2.call({ _: "account.getPassword" });
          if (pwd.hasPassword) {
            throw new MtArgumentError("Cloud password is already enabled");
          }
          const algo = pwd.newAlgo;
          assertTypeIs("account.getPassword", algo, "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow");
          const newHash = yield client2.computeNewPasswordHash(algo, password);
          yield client2.call({
            _: "account.updatePasswordSettings",
            password: { _: "inputCheckPasswordEmpty" },
            newSettings: {
              _: "account.passwordInputSettings",
              newAlgo: algo,
              newPasswordHash: newHash,
              hint,
              email
            }
          });
        });
      }
      function verifyPasswordEmail(client2, code2) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "account.confirmPasswordEmail",
            code: code2
          });
          assertTrue("account.confirmPasswordEmail", r2);
        });
      }
      function resendPasswordEmail(client2) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "account.resendPasswordEmail"
          });
          assertTrue("account.resendPasswordEmail", r2);
        });
      }
      function cancelPasswordEmail(client2) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "account.cancelPasswordEmail"
          });
          assertTrue("account.cancelPasswordEmail", r2);
        });
      }
      function removeCloudPassword(client2, password) {
        return __async(this, null, function* () {
          const pwd = yield client2.call({ _: "account.getPassword" });
          if (!pwd.hasPassword) {
            throw new MtArgumentError("Cloud password is not enabled");
          }
          const oldSrp = yield client2.computeSrpParams(pwd, password);
          yield client2.call({
            _: "account.updatePasswordSettings",
            password: oldSrp,
            newSettings: {
              _: "account.passwordInputSettings",
              newAlgo: { _: "passwordKdfAlgoUnknown" },
              newPasswordHash: new Uint8Array(0),
              hint: ""
            }
          });
        });
      }
      function acceptStarGift(client2, params) {
        return __async(this, null, function* () {
          const { action } = params;
          const { chatId, message: message2 } = normalizeInputMessageId(params);
          const userId = yield resolveUser(client2, chatId);
          return client2.call(
            action === "convert" ? {
              _: "payments.convertStarGift",
              userId,
              msgId: message2
            } : {
              _: "payments.saveStarGift",
              unsave: action === "hide",
              userId,
              msgId: message2
            }
          );
        });
      }
      function applyBoost(client2, peerId) {
        return __async(this, null, function* () {
          yield client2.call({
            _: "premium.applyBoost",
            peer: yield resolvePeer(client2, peerId)
          });
        });
      }
      function getMyBoostSlots(client2) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "premium.getMyBoosts"
          });
          const peers = PeersIndex.from(res);
          return res.myBoosts.map((it) => new BoostSlot(it, peers));
        });
      }
      function canApplyBoost(client2) {
        return __async(this, null, function* () {
          const myBoosts = yield getMyBoostSlots(client2);
          if (!myBoosts.length) {
            return { can: false, reason: "need_premium", slots: myBoosts };
          }
          const emptySlots = myBoosts.filter((it) => !it.occupied);
          if (emptySlots.length > 0) {
            return { can: true, slots: myBoosts };
          }
          const replaceableSlots = myBoosts.filter((it) => it.cooldownUntil === null);
          if (replaceableSlots.length) {
            return { can: true, replace: replaceableSlots.map((it) => it.chat), slots: myBoosts };
          }
          return { can: false, reason: "no_slots", slots: myBoosts };
        });
      }
      function createBusinessChatLink(client2, text2, params) {
        return __async(this, null, function* () {
          const [message2, entities] = yield _normalizeInputText(client2, text2);
          const res = yield client2.call({
            _: "account.createBusinessChatLink",
            link: {
              _: "inputBusinessChatLink",
              message: message2,
              entities,
              title: params == null ? void 0 : params.title
            }
          });
          return new BusinessChatLink(res);
        });
      }
      function editBusinessChatLink(client2, link, params) {
        return __async(this, null, function* () {
          const [message2, entities] = yield _normalizeInputText(client2, params.text);
          const res = yield client2.call({
            _: "account.editBusinessChatLink",
            slug: link instanceof BusinessChatLink ? link.link : link,
            link: {
              _: "inputBusinessChatLink",
              message: message2,
              entities,
              title: params == null ? void 0 : params.title
            }
          });
          return new BusinessChatLink(res);
        });
      }
      function deleteBusinessChatLink(client2, link) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "account.deleteBusinessChatLink",
            slug: typeof link === "string" ? link : link.link
          });
          assertTrue("account.deleteBusinessChatLink", res);
        });
      }
      function getBoostStats(client2, peerId) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "premium.getBoostsStatus",
            peer: yield resolvePeer(client2, peerId)
          });
          return new BoostStats(res);
        });
      }
      function getBoosts(client2, peerId, params) {
        return __async(this, null, function* () {
          const { offset = "", limit = 100 } = params != null ? params : {};
          const res = yield client2.call({
            _: "premium.getBoostsList",
            peer: yield resolvePeer(client2, peerId),
            offset,
            limit
          });
          const peers = PeersIndex.from(res);
          return makeArrayPaginated(
            res.boosts.map((it) => new Boost(it, peers)),
            res.count,
            res.nextOffset
          );
        });
      }
      function getBusinessChatLinks(client2) {
        return __async(this, null, function* () {
          const res = yield client2.call({ _: "account.getBusinessChatLinks" });
          return res.links.map((x) => new BusinessChatLink(x));
        });
      }
      function getStarGiftOptions(client2) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "payments.getStarGifts",
            hash: 0
          });
          assertTypeIsNot("payments.getStarGifts", res, "payments.starGiftsNotModified");
          return res.gifts.map((gift) => new StarGift(gift));
        });
      }
      function getStarGifts(client2, userId, params) {
        return __async(this, null, function* () {
          const { offset = "", limit = 100 } = params != null ? params : {};
          const res = yield client2.call({
            _: "payments.getUserStarGifts",
            userId: yield resolveUser(client2, userId),
            offset,
            limit
          });
          const peers = PeersIndex.from(res);
          const gifts = res.gifts.map((gift) => new UserStarGift(gift, peers));
          return makeArrayPaginated(gifts, res.count, offset);
        });
      }
      function getStarsTransactions(client2, peerId, params) {
        return __async(this, null, function* () {
          const { direction, sort, subscriptionId, offset = "", limit = 100 } = params != null ? params : {};
          const res = yield client2.call({
            _: "payments.getStarsTransactions",
            peer: yield resolvePeer(client2, peerId),
            offset,
            limit,
            outbound: direction === "outgoing",
            inbound: direction === "incoming",
            ascending: sort === "asc",
            subscriptionId
          });
          return new StarsStatus(res);
        });
      }
      function iterBoosters(client2, peerId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { limit = Infinity, chunkSize = 100 } = params;
          let { offset } = params;
          let current2 = 0;
          const peer = yield new __await(resolvePeer(client2, peerId));
          for (; ; ) {
            const res = yield new __await(getBoosts(client2, peer, {
              offset,
              limit: Math.min(limit - current2, chunkSize)
            }));
            for(let   booster of res) {
              yield booster;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
          }
        });
      }
      function iterStarGifts(client2, peerId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { limit = Infinity, chunkSize = 100 } = params;
          let { offset } = params;
          let current2 = 0;
          const peer = yield new __await(resolvePeer(client2, peerId));
          for (; ; ) {
            const res = yield new __await(getStarGifts(client2, peer, {
              offset,
              limit: Math.min(limit - current2, chunkSize)
            }));
            for(let   gift of res) {
              yield gift;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
          }
        });
      }
      function iterStarsTransactions(client2, peerId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { limit = Infinity, chunkSize = 100 } = params;
          let { offset } = params;
          let current2 = 0;
          const peer = yield new __await(resolvePeer(client2, peerId));
          for (; ; ) {
            const res = yield new __await(getStarsTransactions(client2, peer, {
              offset,
              limit: Math.min(limit - current2, chunkSize)
            }));
            for(let   transaction of res.transactions) {
              yield transaction;
              if (++current2 >= limit)
                return;
            }
            if (!res.transactionsNextOffset)
              return;
            offset = res.transactionsNextOffset;
          }
        });
      }
      function sendStarGift(client2, params) {
        return __async(this, null, function* () {
          const { userId, gift, anonymous, message: message2, shouldDispatch } = params;
          const invoice2 = {
            _: "inputInvoiceStarGift",
            hideName: anonymous,
            userId: yield resolveUser(client2, userId),
            giftId: Long.isLong(gift) ? gift : gift.id,
            message: message2 ? inputTextToTl(message2) : void 0
          };
          const form = yield client2.call({
            _: "payments.getPaymentForm",
            invoice: invoice2
          });
          const res = yield client2.call({
            _: "payments.sendStarsForm",
            invoice: invoice2,
            formId: form.formId
          });
          assertTypeIs("payments.sendStarsForm", res, "payments.paymentResult");
          return _findMessageInUpdate(client2, res.updates, false, !shouldDispatch);
        });
      }
      function _normalizeFileToDocument(client2, file2, params) {
        return __async(this, null, function* () {
          if (typeof file2 === "object" && tl.tl.isAnyInputDocument(file2)) {
            return file2;
          }
          const media2 = yield _normalizeInputMedia(
            client2,
            {
              type: "document",
              file: file2
            },
            params,
            true
          );
          assertTypeIs("_normalizeFileToDocument", media2, "inputMediaDocument");
          assertTypeIs("_normalizeFileToDocument", media2.id, "inputDocument");
          return media2.id;
        });
      }
      function isInputMediaSticker(media2) {
        return typeof media2 === "object" && media2 !== null && "type" in media2 && media2.type === "sticker";
      }
      function setBusinessIntro(client2, intro) {
        return __async(this, null, function* () {
          var _a3, _b2;
          let tlIntro;
          if (intro) {
            let sticker2;
            if (intro.sticker) {
              if (isInputMediaSticker(intro.sticker)) {
                const media2 = yield _normalizeInputMedia(client2, intro.sticker, void 0, true);
                assertTypeIs("_normalizeInputMedia", media2, "inputMediaDocument");
                sticker2 = media2.id;
              } else {
                sticker2 = yield _normalizeFileToDocument(client2, intro.sticker, {});
              }
            }
            tlIntro = {
              _: "inputBusinessIntro",
              title: (_a3 = intro.title) != null ? _a3 : "",
              description: (_b2 = intro.description) != null ? _b2 : "",
              sticker: sticker2
            };
          }
          const res = yield client2.call({
            _: "account.updateBusinessIntro",
            intro: tlIntro
          });
          assertTrue("account.updateBusinessIntro", res);
        });
      }
      function setBusinessWorkHours(client2, params) {
        return __async(this, null, function* () {
          let businessWorkHours;
          if (params) {
            let weeklyOpen;
            if ("hours" in params) {
              weeklyOpen = businessWorkHoursDaysToRaw(params.hours);
            } else {
              weeklyOpen = params.intervals;
            }
            businessWorkHours = {
              _: "businessWorkHours",
              timezoneId: params.timezone,
              weeklyOpen
            };
          }
          const res = yield client2.call({
            _: "account.updateBusinessWorkHours",
            businessWorkHours
          });
          assertTrue("account.updateBusinessWorkHours", res);
        });
      }
      function _normalizeInputStickerSetItem(client2, sticker2, params) {
        return __async(this, null, function* () {
          return {
            _: "inputStickerSetItem",
            document: yield _normalizeFileToDocument(client2, sticker2.file, params != null ? params : {}),
            emoji: sticker2.emojis,
            maskCoords: sticker2.maskPosition ? {
              _: "maskCoords",
              n: MASK_POSITION_POINT_TO_TL[sticker2.maskPosition.point],
              x: sticker2.maskPosition.x,
              y: sticker2.maskPosition.y,
              zoom: sticker2.maskPosition.scale
            } : void 0
          };
        });
      }
      function addStickerToSet(client2, setId, sticker2, params) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "stickers.addStickerToSet",
            stickerset: normalizeInputStickerSet(setId),
            sticker: yield _normalizeInputStickerSetItem(client2, sticker2, params)
          });
          return new StickerSet(res);
        });
      }
      function createStickerSet(client2, params) {
        return __async(this, null, function* () {
          var _a3;
          const owner = yield resolveUser(client2, params.owner);
          const inputStickers = [];
          let i = 0;
          for(let   sticker2 of params.stickers) {
            const progressCallback = (_a3 = params.progressCallback) == null ? void 0 : _a3.bind(null, i);
            inputStickers.push(yield _normalizeInputStickerSetItem(client2, sticker2, { progressCallback }));
            i += 1;
          }
          const res = yield client2.call({
            _: "stickers.createStickerSet",
            masks: params.type === "mask",
            emojis: params.type === "emoji",
            textColor: params.adaptive,
            userId: owner,
            title: params.title,
            shortName: params.shortName,
            stickers: inputStickers,
            thumb: params.thumb ? yield _normalizeFileToDocument(client2, params.thumb, {}) : void 0
          });
          return new StickerSet(res);
        });
      }
      function deleteStickerFromSet(client2, sticker2) {
        return __async(this, null, function* () {
          if (typesInner.isFileIdLike(sticker2)) {
            sticker2 = fileIdToInputDocument(sticker2);
          }
          const res = yield client2.call({
            _: "stickers.removeStickerFromSet",
            sticker: sticker2
          });
          return new StickerSet(res);
        });
      }
      function getCustomEmojis(client2, ids) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.getCustomEmojiDocuments",
            documentId: ids
          });
          return res.map((it) => {
            assertTypeIs("getCustomEmojis", it, "document");
            const doc = parseDocument(it);
            if (doc.type !== "sticker") {
              throw new MtTypeAssertionError("getCustomEmojis", "sticker", doc.type);
            }
            return doc;
          });
        });
      }
      function getCustomEmojisFromMessages(client2, messages) {
        return __async(this, null, function* () {
          const set2 = new LongSet();
          if (!Array.isArray(messages))
            messages = [messages];
          for(let   { raw } of messages) {
            if (raw._ === "messageService" || !raw.entities)
              continue;
            for(let   entity of raw.entities) {
              if (entity._ === "messageEntityCustomEmoji") {
                set2.add(entity.documentId);
              }
            }
          }
          const arr = set2.toArray();
          if (!arr.length)
            return [];
          return getCustomEmojis(client2, arr);
        });
      }
      function getInstalledStickers(client2) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.getAllStickers",
            hash: Long.ZERO
          });
          assertTypeIs("getInstalledStickers", res, "messages.allStickers");
          return res.sets.map((set2) => new StickerSet(set2));
        });
      }
      function getMyStickerSets(client2, params) {
        return __async(this, null, function* () {
          var _a3, _b2, _c;
          const res = yield client2.call({
            _: "messages.getMyStickers",
            offsetId: (_a3 = params == null ? void 0 : params.offset) != null ? _a3 : Long.ZERO,
            limit: (_b2 = params == null ? void 0 : params.limit) != null ? _b2 : 100
          });
          const items = res.sets.map((x) => new StickerSet(x));
          return makeArrayPaginated(items, res.count, (_c = items[items.length - 1]) == null ? void 0 : _c.brief.id);
        });
      }
      function getStickerSet(client2, setId) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "messages.getStickerSet",
            stickerset: normalizeInputStickerSet(setId),
            hash: 0
          });
          return new StickerSet(res);
        });
      }
      function moveStickerInSet(client2, sticker2, position) {
        return __async(this, null, function* () {
          if (typesInner.isFileIdLike(sticker2)) {
            sticker2 = fileIdToInputDocument(sticker2);
          }
          const res = yield client2.call({
            _: "stickers.changeStickerPosition",
            sticker: sticker2,
            position
          });
          return new StickerSet(res);
        });
      }
      function replaceStickerInSet(client2, sticker2, newSticker, params) {
        return __async(this, null, function* () {
          if (typesInner.isFileIdLike(sticker2)) {
            sticker2 = fileIdToInputDocument(sticker2);
          }
          const res = yield client2.call({
            _: "stickers.replaceSticker",
            sticker: sticker2,
            newSticker: yield _normalizeInputStickerSetItem(client2, newSticker, params)
          });
          return new StickerSet(res);
        });
      }
      function setChatStickerSet(client2, chatId, setId) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "channels.setStickers",
            channel: yield resolveChannel(client2, chatId),
            stickerset: normalizeInputStickerSet(setId)
          });
          assertTrue("channels.setStickers", r2);
        });
      }
      function setStickerSetThumb(client2, id2, thumb2, params) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "stickers.setStickerSetThumb",
            stickerset: normalizeInputStickerSet(id2),
            thumb: yield _normalizeFileToDocument(client2, thumb2, params != null ? params : {})
          });
          return new StickerSet(res);
        });
      }
      function canSendStory(client2, peerId) {
        return __async(this, null, function* () {
          try {
            const res = yield client2.call({
              _: "stories.canSendStory",
              peer: yield resolvePeer(client2, peerId)
            });
            if (!res)
              return "need_admin";
            return true;
          } catch (e2) {
            if (tl.tl.RpcError.is(e2, "CHAT_ADMIN_REQUIRED")) {
              return "need_admin";
            }
            if (tl.tl.RpcError.is(e2, "BOOSTS_REQUIRED")) {
              return "need_boosts";
            }
            throw e2;
          }
        });
      }
      function deleteStories(client2, params) {
        return __async(this, null, function* () {
          const { ids, peer = "me" } = params;
          return client2.call({
            _: "stories.deleteStories",
            peer: yield resolvePeer(client2, peer),
            id: Array.isArray(ids) ? ids : [ids]
          });
        });
      }
      function _findStoryInUpdate(client2, res) {
        assertIsUpdatesGroup("_findStoryInUpdate", res);
        client2.handleClientUpdate(res, true);
        const peers = PeersIndex.from(res);
        const updateStory = res.updates.find(hasValueAtKey("_", "updateStory"));
        if (!updateStory) {
          throw new MtTypeAssertionError("_findStoryInUpdate (@ .updates[*])", "updateStory", "none");
        }
        assertTypeIs("updateStory.story", updateStory.story, "storyItem");
        return new Story(updateStory.story, peers);
      }
      function editStory(client2, params) {
        return __async(this, null, function* () {
          const { id: id2, peer = "me", interactiveElements } = params;
          let caption;
          let entities;
          let media2;
          if (params.media) {
            media2 = yield _normalizeInputMedia(client2, params.media);
            if ("caption" in params.media && params.media.caption !== void 0) {
              [caption, entities] = yield _normalizeInputText(client2, params.media.caption);
            }
          }
          if (params.caption) {
            [caption, entities] = yield _normalizeInputText(client2, params.caption);
          }
          const privacyRules = params.privacyRules ? yield _normalizePrivacyRules(client2, params.privacyRules) : void 0;
          const res = yield client2.call({
            _: "stories.editStory",
            peer: yield resolvePeer(client2, peer),
            id: id2,
            media: media2,
            mediaAreas: interactiveElements,
            caption,
            entities,
            privacyRules
          });
          return _findStoryInUpdate(client2, res);
        });
      }
      function getAllStories(client2, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          const { offset, archived } = params;
          const res = yield client2.call({
            _: "stories.getAllStories",
            state: offset,
            next: Boolean(offset),
            hidden: archived
          });
          assertTypeIsNot("getAllStories", res, "stories.allStoriesNotModified");
          return new AllStories(res);
        });
      }
      function getPeerStories(client2, peerId) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "stories.getPeerStories",
            peer: yield resolvePeer(client2, peerId)
          });
          const peers = PeersIndex.from(res);
          return new PeerStories(res.stories, peers);
        });
      }
      function getProfileStories(client2, peerId, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          const { kind = "pinned", offsetId = 0, limit = 100 } = params;
          const res = yield client2.call({
            _: kind === "pinned" ? "stories.getPinnedStories" : "stories.getStoriesArchive",
            peer: yield resolvePeer(client2, peerId),
            offsetId,
            limit
          });
          const peers = PeersIndex.from(res);
          const stories = res.stories.map((it) => {
            assertTypeIs("getProfileStories", it, "storyItem");
            return new Story(it, peers);
          });
          const last2 = stories[stories.length - 1];
          const next2 = last2 == null ? void 0 : last2.id;
          return makeArrayPaginated(stories, res.count, next2);
        });
      }
      function getStoriesById(client2, peerId, storyIds) {
        return __async(this, null, function* () {
          if (!Array.isArray(storyIds))
            storyIds = [storyIds];
          const res = yield client2.call({
            _: "stories.getStoriesByID",
            peer: yield resolvePeer(client2, peerId),
            id: storyIds
          });
          const peers = PeersIndex.from(res);
          const stories = res.stories.map((it) => {
            assertTypeIs("getProfileStories", it, "storyItem");
            return new Story(it, peers);
          });
          return stories;
        });
      }
      function getStoriesInteractions(client2, peerId, storyIds) {
        return __async(this, null, function* () {
          if (!Array.isArray(storyIds))
            storyIds = [storyIds];
          const res = yield client2.call({
            _: "stories.getStoriesViews",
            peer: yield resolvePeer(client2, peerId),
            id: storyIds
          });
          const peers = PeersIndex.from(res);
          const infos = res.views.map((it) => new StoryInteractions(it, peers));
          return infos;
        });
      }
      function getStoryLink(client2, peerId, storyId) {
        return __async(this, null, function* () {
          return client2.call({
            _: "stories.exportStoryLink",
            peer: yield resolvePeer(client2, peerId),
            id: storyId
          }).then((r2) => r2.link);
        });
      }
      function getStoryViewers(client2, peerId, storyId, params) {
        return __async(this, null, function* () {
          if (!params)
            params = {};
          const { onlyContacts, sortBy = "reaction", query, offset = "", limit = 100 } = params;
          const res = yield client2.call({
            _: "stories.getStoryViewsList",
            peer: yield resolvePeer(client2, peerId),
            justContacts: onlyContacts,
            reactionsFirst: sortBy === "reaction",
            q: query,
            id: storyId,
            offset,
            limit
          });
          return new StoryViewersList(res);
        });
      }
      function hideMyStoriesViews(client2, params) {
        return __async(this, null, function* () {
          const { past = true, future = true } = params != null ? params : {};
          const res = yield client2.call({
            _: "stories.activateStealthMode",
            past,
            future
          });
          assertIsUpdatesGroup("hideMyStoriesViews", res);
          client2.handleClientUpdate(res, true);
          const upd = res.updates.find(hasValueAtKey("_", "updateStoriesStealthMode"));
          if (!upd) {
            throw new MtTypeAssertionError("hideMyStoriesViews (@ res.updates[*])", "updateStoriesStealthMode", "none");
          }
          return new StoriesStealthMode(upd.stealthMode);
        });
      }
      function incrementStoriesViews(client2, peerId, ids) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "stories.incrementStoryViews",
            peer: yield resolvePeer(client2, peerId),
            id: Array.isArray(ids) ? ids : [ids]
          });
          assertTrue("stories.incrementStoryViews", r2);
        });
      }
      function iterAllStories(client2, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { archived, limit = Infinity } = params;
          let { offset } = params;
          let current2 = 0;
          for (; ; ) {
            const res = yield new __await(getAllStories(client2, {
              offset,
              archived
            }));
            for(let   peer of res.peerStories) {
              yield peer;
              if (++current2 >= limit)
                return;
            }
            if (!res.hasMore)
              return;
            offset = res.next;
          }
        });
      }
      function iterProfileStories(client2, peerId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { kind = "pinned", limit = Infinity, chunkSize = 100 } = params;
          let { offsetId } = params;
          let current2 = 0;
          const peer = yield new __await(resolvePeer(client2, peerId));
          for (; ; ) {
            const res = yield new __await(getProfileStories(client2, peer, {
              kind,
              offsetId,
              limit: Math.min(limit - current2, chunkSize)
            }));
            for(let   peer2 of res) {
              yield peer2;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offsetId = res.next;
          }
        });
      }
      function iterStoryViewers(client2, peerId, storyId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const { onlyContacts, sortBy = "reaction", query, limit = Infinity, chunkSize = 100 } = params;
          let { offset = "" } = params;
          let current2 = 0;
          const peer = yield new __await(resolvePeer(client2, peerId));
          for (; ; ) {
            const res = yield new __await(getStoryViewers(client2, peer, storyId, {
              onlyContacts,
              sortBy,
              query,
              offset,
              limit: Math.min(limit - current2, chunkSize)
            }));
            for(let   peer2 of res.viewers) {
              yield peer2;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
          }
        });
      }
      function readStories(client2, peerId, maxId) {
        return __async(this, null, function* () {
          return client2.call({
            _: "stories.readStories",
            peer: yield resolvePeer(client2, peerId),
            maxId
          });
        });
      }
      function sendStoryReaction(client2, params) {
        return __async(this, null, function* () {
          const { peerId, storyId, reaction, addToRecent } = params;
          const res = yield client2.call({
            _: "stories.sendReaction",
            peer: yield resolvePeer(client2, peerId),
            storyId,
            reaction: normalizeInputReaction(reaction),
            addToRecent
          });
          client2.handleClientUpdate(res, true);
        });
      }
      function sendStory(client2, params) {
        return __async(this, null, function* () {
          const { peer = "me", pinned, forbidForwards, interactiveElements, period } = params;
          let { media: media2 } = params;
          if (typeof media2 === "string") {
            media2 = {
              type: "auto",
              file: media2
            };
          }
          const inputMedia = yield _normalizeInputMedia(client2, media2);
          const privacyRules = params.privacyRules ? yield _normalizePrivacyRules(client2, params.privacyRules) : [{ _: "inputPrivacyValueAllowAll" }];
          const [caption, entities] = yield _normalizeInputText(
            client2,
            // some types dont have `caption` field, and ts warns us,
            // but since it's JS, they'll just be `undefined` and properly handled by the method
            params.caption || media2.caption
          );
          const res = yield client2.call({
            _: "stories.sendStory",
            pinned,
            noforwards: forbidForwards,
            peer: yield resolvePeer(client2, peer),
            media: inputMedia,
            mediaAreas: interactiveElements,
            caption,
            entities,
            privacyRules,
            randomId: randomLong(),
            period
          });
          return _findStoryInUpdate(client2, res);
        });
      }
      function togglePeerStoriesArchived(client2, peerId, archived) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "stories.togglePeerStoriesHidden",
            peer: yield resolvePeer(client2, peerId),
            hidden: archived
          });
          assertTrue("stories.togglePeerStoriesHidden", r2);
        });
      }
      function toggleStoriesPinned(client2, params) {
        return __async(this, null, function* () {
          const { ids, pinned, peer = "me" } = params;
          return client2.call({
            _: "stories.togglePinned",
            peer: yield resolvePeer(client2, peer),
            id: Array.isArray(ids) ? ids : [ids],
            pinned
          });
        });
      }
      function blockUser(client2, id2) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "contacts.block",
            id: yield resolvePeer(client2, id2)
          });
          assertTrue("contacts.block", r2);
        });
      }
      function deleteProfilePhotos(client2, ids) {
        return __async(this, null, function* () {
          if (!Array.isArray(ids))
            ids = [ids];
          const photos = ids.map((id2) => {
            if (typeof id2 === "string") {
              return fileIdToInputPhoto(id2);
            }
            return id2;
          });
          yield client2.call({
            _: "photos.deletePhotos",
            id: photos
          });
        });
      }
      function editCloseFriendsRaw(client2, ids) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "contacts.editCloseFriends",
            id: ids
          });
          assertTrue("contacts.editCloseFriends", r2);
        });
      }
      function editCloseFriends(client2, ids) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "contacts.editCloseFriends",
            id: yield resolvePeerMany(client2, ids, toInputUser).then(
              (r22) => r22.map((u) => {
                if ("userId" in u)
                  return u.userId;
                return 0;
              })
            )
          });
          assertTrue("contacts.editCloseFriends", r2);
        });
      }
      function getCommonChats(client2, userId) {
        return __async(this, null, function* () {
          return client2.call({
            _: "messages.getCommonChats",
            userId: yield resolveUser(client2, userId),
            maxId: 0,
            limit: 100
          }).then((res) => res.chats.map((it) => new Chat(it)));
        });
      }
      function getGlobalTtl(client2) {
        return __async(this, null, function* () {
          return client2.call({
            _: "messages.getDefaultHistoryTTL"
          }).then((r2) => r2.period);
        });
      }
      function getMyUsername(client2) {
        return __async(this, null, function* () {
          return client2.storage.self.fetch().then((self2) => {
            var _a3;
            return (_a3 = self2 == null ? void 0 : self2.usernames[0]) != null ? _a3 : null;
          });
        });
      }
      function getProfilePhoto(client2, userId, photoId) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "photos.getUserPhotos",
            userId: yield resolveUser(client2, userId),
            offset: -1,
            limit: 1,
            maxId: photoId
          });
          const photo2 = res.photos[0];
          assertTypeIs("getProfilePhotos", photo2, "photo");
          return new Photo(photo2);
        });
      }
      function getProfilePhotos(client2, userId, params) {
        return __async(this, null, function* () {
          var _a3;
          if (!params)
            params = {};
          const { offset = 0, limit = 100 } = params;
          const res = yield client2.call({
            _: "photos.getUserPhotos",
            userId: yield resolveUser(client2, userId),
            offset,
            limit,
            maxId: Long.ZERO
          });
          return makeArrayPaginated(
            res.photos.map((it) => {
              assertTypeIs("getProfilePhotos", it, "photo");
              return new Photo(it);
            }),
            (_a3 = res.count) != null ? _a3 : res.photos.length,
            offset + res.photos.length
          );
        });
      }
      function getUsers(client2, ids) {
        return __async(this, null, function* () {
          if (!Array.isArray(ids)) {
            const res2 = yield _getUsersBatched(client2, yield resolveUser(client2, ids));
            return [res2 ? new User(res2) : null];
          }
          const inputPeers = yield resolvePeerMany(client2, ids, toInputUser);
          const res = yield Promise.all(inputPeers.map((peer) => _getUsersBatched(client2, peer)));
          return res.map((it) => it ? new User(it) : null);
        });
      }
      function isPeerAvailable(client2, peerId) {
        return __async(this, null, function* () {
          var _a3;
          peerId = _normalizePeerId(peerId);
          if (typeof peerId === "object") {
            return true;
          }
          if (typeof peerId === "number") {
            const fromStorage = yield client2.storage.peers.getById(peerId);
            if (fromStorage)
              return true;
            const [peerType] = parseMarkedPeerId(peerId);
            if (peerType === "chat" || ((_a3 = client2.storage.self.getCached(true)) == null ? void 0 : _a3.isBot)) {
              return true;
            }
            return false;
          }
          if (typeof peerId === "string") {
            if (peerId === "self" || peerId === "me") {
              return true;
            }
            peerId = peerId.replace(/[@+\s()]/g, "");
            if (peerId.match(/^\d+$/)) {
              const fromStorage = yield client2.storage.peers.getByPhone(peerId);
              if (fromStorage)
                return true;
            } else {
              const fromStorage = yield client2.storage.peers.getByUsername(peerId);
              if (fromStorage)
                return true;
            }
            return false;
          }
          return false;
        });
      }
      function iterProfilePhotos(client2, userId, params) {
        return __asyncGenerator(this, null, function* () {
          if (!params)
            params = {};
          const peer = yield new __await(resolveUser(client2, userId));
          const { limit = Infinity, chunkSize = 100 } = params;
          let { offset } = params;
          let current2 = 0;
          for (; ; ) {
            const res = yield new __await(getProfilePhotos(client2, peer, {
              offset,
              limit: Math.min(chunkSize, limit - current2)
            }));
            for(let   it of res) {
              yield it;
              if (++current2 >= limit)
                return;
            }
            if (!res.next)
              return;
            offset = res.next;
          }
        });
      }
      function setGlobalTtl(client2, period) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "messages.setDefaultHistoryTTL",
            period
          });
          assertTrue("messages.setDefaultHistoryTTL", r2);
        });
      }
      function setMyBirthday(client2, birthday) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "account.updateBirthday",
            birthday: birthday ? __spreadValues({
              _: "birthday"
            }, birthday) : void 0
          });
          assertTrue("account.updateBirthday", res);
        });
      }
      function setMyEmojiStatus(client2, emoji2, params) {
        return __async(this, null, function* () {
          const { until } = params != null ? params : {};
          let emojiStatus;
          if (emoji2 === null) {
            emojiStatus = { _: "emojiStatusEmpty" };
          } else if (until) {
            emojiStatus = {
              _: "emojiStatusUntil",
              documentId: emoji2,
              until: normalizeDate(until)
            };
          } else {
            emojiStatus = {
              _: "emojiStatus",
              documentId: emoji2
            };
          }
          const r2 = yield client2.call({
            _: "account.updateEmojiStatus",
            emojiStatus
          });
          assertTrue("account.updateEmojiStatus", r2);
        });
      }
      function setMyProfilePhoto(client2, params) {
        return __async(this, null, function* () {
          const { type, previewSec } = params;
          let { media: media2 } = params;
          if (typesInner.isFileIdLike(media2) || typeof media2 === "object" && tl.tl.isAnyInputPhoto(media2)) {
            if (typeof media2 === "string" && media2.match(/^https?:\/\//)) {
              throw new MtArgumentError("Profile photo can't be set from URL.");
            }
            if (typeof media2 !== "string" || !media2.match(/^file:/)) {
              if (typesInner.isFileIdLike(media2)) {
                media2 = fileIdToInputPhoto(media2);
              }
              const res2 = yield client2.call({
                _: "photos.updateProfilePhoto",
                id: media2
              });
              return new Photo(res2.photo);
            }
          }
          const res = yield client2.call({
            _: "photos.uploadProfilePhoto",
            [type === "photo" ? "file" : "video"]: yield _normalizeInputFile(client2, media2, {}),
            videoStartTs: previewSec
          });
          return new Photo(res.photo);
        });
      }
      function setMyUsername(client2, username2) {
        return __async(this, null, function* () {
          if (username2 === null)
            username2 = "";
          const res = yield client2.call({
            _: "account.updateUsername",
            username: username2
          });
          yield client2.storage.self.update({ username: username2 });
          return new User(res);
        });
      }
      function setOffline(client2, offline = true) {
        return __async(this, null, function* () {
          yield client2.call({
            _: "account.updateStatus",
            offline
          });
        });
      }
      function unblockUser(client2, id2) {
        return __async(this, null, function* () {
          const r2 = yield client2.call({
            _: "contacts.unblock",
            id: yield resolvePeer(client2, id2)
          });
          assertTrue("contacts.unblock", r2);
        });
      }
      function updateProfile(client2, params) {
        return __async(this, null, function* () {
          const res = yield client2.call({
            _: "account.updateProfile",
            firstName: params.firstName,
            lastName: params.lastName,
            about: params.bio
          });
          return new User(res);
        });
      }
      function withParams(client2, params) {
        const wrappedCall = (message2, extraParams) => client2.call(message2, extraParams ? __spreadValues(__spreadValues({}, params), extraParams) : params);
        const proxy2 = new Proxy(client2, {
          get: (target, prop, receiver) => {
            if (prop === "call") {
              return wrappedCall;
            }
            if (prop === "_client") {
              return proxy2;
            }
            return Reflect.get(target, prop, receiver);
          }
        });
        return proxy2;
      }
      let TelegramClient$1 = class TelegramClient extends EventEmitter {
        constructor(opts) {
          var _a3, _b2;
          super();
          __publicField(this, "_client");
          if ("client" in opts) {
            this._client = opts.client;
          } else {
            if (!opts.storage || typeof opts.storage === "string" || !opts.transport || !opts.crypto) {
              throw new MtUnsupportedError(
                "You need to explicitly provide storage, transport and crypto for @mtcute/core"
              );
            }
            this._client = new BaseTelegramClient$1(opts);
          }
          this.log = this._client.log;
          this.storage = this._client.storage;
          Object.defineProperty(this, "stopSignal", {
            get: () => this._client.stopSignal
          });
          Object.defineProperty(this, "appConfig", {
            get: () => this._client.appConfig
          });
          if (!opts.disableUpdates) {
            const skipConversationUpdates = (_a3 = opts.skipConversationUpdates) != null ? _a3 : true;
            const { messageGroupingInterval } = (_b2 = opts.updates) != null ? _b2 : {};
            this._client.onUpdate(
              makeParsedUpdateHandler({
                messageGroupingInterval,
                onUpdate: (update) => {
                  if (Conversation.handleUpdate(this, update) && skipConversationUpdates)
                    return;
                  this.emit("update", update);
                  this.emit(update.name, update.data);
                },
                onRawUpdate: (update, peers) => {
                  this.emit("raw_update", update, peers);
                }
              })
            );
          }
        }
        withParams(params) {
          return withParams(this, params);
        }
      };
      TelegramClient$1.prototype.checkPassword = function(...args) {
        return checkPassword(this._client, ...args);
      };
      TelegramClient$1.prototype.getPasswordHint = function(...args) {
        return getPasswordHint(this._client, ...args);
      };
      TelegramClient$1.prototype.logOut = function(...args) {
        return logOut(this._client, ...args);
      };
      TelegramClient$1.prototype.recoverPassword = function(...args) {
        return recoverPassword(this._client, ...args);
      };
      TelegramClient$1.prototype.resendCode = function(...args) {
        return resendCode(this._client, ...args);
      };
      TelegramClient$1.prototype.run = function(...args) {
        return run(this._client, ...args);
      };
      TelegramClient$1.prototype.sendCode = function(...args) {
        return sendCode(this._client, ...args);
      };
      TelegramClient$1.prototype.sendRecoveryCode = function(...args) {
        return sendRecoveryCode(this._client, ...args);
      };
      TelegramClient$1.prototype.signInBot = function(...args) {
        return signInBot(this._client, ...args);
      };
      TelegramClient$1.prototype.signInQr = function(...args) {
        return signInQr(this._client, ...args);
      };
      TelegramClient$1.prototype.signIn = function(...args) {
        return signIn(this._client, ...args);
      };
      TelegramClient$1.prototype.startTest = function(...args) {
        return startTest(this._client, ...args);
      };
      TelegramClient$1.prototype.start = function(...args) {
        return start(this._client, ...args);
      };
      TelegramClient$1.prototype.isSelfPeer = function(...args) {
        return isSelfPeer(this._client, ...args);
      };
      TelegramClient$1.prototype.answerCallbackQuery = function(...args) {
        return answerCallbackQuery(this._client, ...args);
      };
      TelegramClient$1.prototype.answerInlineQuery = function(...args) {
        return answerInlineQuery(this._client, ...args);
      };
      TelegramClient$1.prototype.answerPreCheckoutQuery = function(...args) {
        return answerPreCheckoutQuery(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteMyCommands = function(...args) {
        return deleteMyCommands(this._client, ...args);
      };
      TelegramClient$1.prototype.getBotInfo = function(...args) {
        return getBotInfo(this._client, ...args);
      };
      TelegramClient$1.prototype.getBotMenuButton = function(...args) {
        return getBotMenuButton(this._client, ...args);
      };
      TelegramClient$1.prototype.getCallbackAnswer = function(...args) {
        return getCallbackAnswer(this._client, ...args);
      };
      TelegramClient$1.prototype.getGameHighScores = function(...args) {
        return getGameHighScores(this._client, ...args);
      };
      TelegramClient$1.prototype.getInlineGameHighScores = function(...args) {
        return getInlineGameHighScores(this._client, ...args);
      };
      TelegramClient$1.prototype.getMyCommands = function(...args) {
        return getMyCommands(this._client, ...args);
      };
      TelegramClient$1.prototype.setBotInfo = function(...args) {
        return setBotInfo(this._client, ...args);
      };
      TelegramClient$1.prototype.setBotMenuButton = function(...args) {
        return setBotMenuButton(this._client, ...args);
      };
      TelegramClient$1.prototype.setGameScore = function(...args) {
        return setGameScore(this._client, ...args);
      };
      TelegramClient$1.prototype.setInlineGameScore = function(...args) {
        return setInlineGameScore(this._client, ...args);
      };
      TelegramClient$1.prototype.setMyCommands = function(...args) {
        return setMyCommands(this._client, ...args);
      };
      TelegramClient$1.prototype.setMyDefaultRights = function(...args) {
        return setMyDefaultRights(this._client, ...args);
      };
      TelegramClient$1.prototype.addChatMembers = function(...args) {
        return addChatMembers(this._client, ...args);
      };
      TelegramClient$1.prototype.archiveChats = function(...args) {
        return archiveChats(this._client, ...args);
      };
      TelegramClient$1.prototype.banChatMember = function(...args) {
        return banChatMember(this._client, ...args);
      };
      TelegramClient$1.prototype.createChannel = function(...args) {
        return createChannel(this._client, ...args);
      };
      TelegramClient$1.prototype.createGroup = function(...args) {
        return createGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.createSupergroup = function(...args) {
        return createSupergroup(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteChannel = function(...args) {
        return deleteChannel(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteSupergroup = function(...args) {
        return deleteChannel(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteChatPhoto = function(...args) {
        return deleteChatPhoto(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteGroup = function(...args) {
        return deleteGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteHistory = function(...args) {
        return deleteHistory(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteUserHistory = function(...args) {
        return deleteUserHistory(this._client, ...args);
      };
      TelegramClient$1.prototype.editAdminRights = function(...args) {
        return editAdminRights(this._client, ...args);
      };
      TelegramClient$1.prototype.getChatEventLog = function(...args) {
        return getChatEventLog(this._client, ...args);
      };
      TelegramClient$1.prototype.getChatMember = function(...args) {
        return getChatMember(this._client, ...args);
      };
      TelegramClient$1.prototype.getChatMembers = function(...args) {
        return getChatMembers(this._client, ...args);
      };
      TelegramClient$1.prototype.getChatPreview = function(...args) {
        return getChatPreview(this._client, ...args);
      };
      TelegramClient$1.prototype.getChat = function(...args) {
        return getChat(this._client, ...args);
      };
      TelegramClient$1.prototype.getFullChat = function(...args) {
        return getFullChat(this._client, ...args);
      };
      TelegramClient$1.prototype.getNearbyChats = function(...args) {
        return getNearbyChats(this._client, ...args);
      };
      TelegramClient$1.prototype.getSimilarChannels = function(...args) {
        return getSimilarChannels(this._client, ...args);
      };
      TelegramClient$1.prototype.iterChatEventLog = function(...args) {
        return iterChatEventLog(this._client, ...args);
      };
      TelegramClient$1.prototype.iterChatMembers = function(...args) {
        return iterChatMembers(this._client, ...args);
      };
      TelegramClient$1.prototype.joinChat = function(...args) {
        return joinChat(this._client, ...args);
      };
      TelegramClient$1.prototype.kickChatMember = function(...args) {
        return kickChatMember(this._client, ...args);
      };
      TelegramClient$1.prototype.leaveChat = function(...args) {
        return leaveChat(this._client, ...args);
      };
      TelegramClient$1.prototype.markChatUnread = function(...args) {
        return markChatUnread(this._client, ...args);
      };
      TelegramClient$1.prototype.openChat = function(...args) {
        return openChat(this._client, ...args);
      };
      TelegramClient$1.prototype.closeChat = function(...args) {
        return closeChat(this._client, ...args);
      };
      TelegramClient$1.prototype.reorderUsernames = function(...args) {
        return reorderUsernames(this._client, ...args);
      };
      TelegramClient$1.prototype.restrictChatMember = function(...args) {
        return restrictChatMember(this._client, ...args);
      };
      TelegramClient$1.prototype.saveDraft = function(...args) {
        return saveDraft(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatColor = function(...args) {
        return setChatColor(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatDefaultPermissions = function(...args) {
        return setChatDefaultPermissions(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatDescription = function(...args) {
        return setChatDescription(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatPhoto = function(...args) {
        return setChatPhoto(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatTitle = function(...args) {
        return setChatTitle(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatTtl = function(...args) {
        return setChatTtl(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatUsername = function(...args) {
        return setChatUsername(this._client, ...args);
      };
      TelegramClient$1.prototype.setSlowMode = function(...args) {
        return setSlowMode(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleContentProtection = function(...args) {
        return toggleContentProtection(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleFragmentUsername = function(...args) {
        return toggleFragmentUsername(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleJoinRequests = function(...args) {
        return toggleJoinRequests(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleJoinToSend = function(...args) {
        return toggleJoinToSend(this._client, ...args);
      };
      TelegramClient$1.prototype.unarchiveChats = function(...args) {
        return unarchiveChats(this._client, ...args);
      };
      TelegramClient$1.prototype.unbanChatMember = function(...args) {
        return unbanChatMember(this._client, ...args);
      };
      TelegramClient$1.prototype.unrestrictChatMember = function(...args) {
        return unbanChatMember(this._client, ...args);
      };
      TelegramClient$1.prototype.addContact = function(...args) {
        return addContact(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteContacts = function(...args) {
        return deleteContacts(this._client, ...args);
      };
      TelegramClient$1.prototype.getContacts = function(...args) {
        return getContacts(this._client, ...args);
      };
      TelegramClient$1.prototype.importContacts = function(...args) {
        return importContacts(this._client, ...args);
      };
      TelegramClient$1.prototype.createFolder = function(...args) {
        return createFolder(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteFolder = function(...args) {
        return deleteFolder(this._client, ...args);
      };
      TelegramClient$1.prototype.editFolder = function(...args) {
        return editFolder(this._client, ...args);
      };
      TelegramClient$1.prototype.findDialogs = function(...args) {
        return findDialogs(this._client, ...args);
      };
      TelegramClient$1.prototype.findFolder = function(...args) {
        return findFolder(this._client, ...args);
      };
      TelegramClient$1.prototype.getChatlistPreview = function(...args) {
        return getChatlistPreview(this._client, ...args);
      };
      TelegramClient$1.prototype.getFolders = function(...args) {
        return getFolders(this._client, ...args);
      };
      TelegramClient$1.prototype.getPeerDialogs = function(...args) {
        return getPeerDialogs(this._client, ...args);
      };
      TelegramClient$1.prototype.iterDialogs = function(...args) {
        return iterDialogs(this._client, ...args);
      };
      TelegramClient$1.prototype.joinChatlist = function(...args) {
        return joinChatlist(this._client, ...args);
      };
      TelegramClient$1.prototype.setFoldersOrder = function(...args) {
        return setFoldersOrder(this._client, ...args);
      };
      TelegramClient$1.prototype.downloadAsBuffer = function(...args) {
        return downloadAsBuffer(this._client, ...args);
      };
      TelegramClient$1.prototype.downloadAsIterable = function(...args) {
        return downloadAsIterable(this._client, ...args);
      };
      TelegramClient$1.prototype.downloadAsStream = function(...args) {
        return downloadAsStream(this._client, ...args);
      };
      TelegramClient$1.prototype._normalizeInputFile = function(...args) {
        return _normalizeInputFile(this._client, ...args);
      };
      TelegramClient$1.prototype._normalizeInputMedia = function(...args) {
        return _normalizeInputMedia(this._client, ...args);
      };
      TelegramClient$1.prototype.uploadFile = function(...args) {
        return uploadFile(this._client, ...args);
      };
      TelegramClient$1.prototype.uploadMedia = function(...args) {
        return uploadMedia(this._client, ...args);
      };
      TelegramClient$1.prototype.createForumTopic = function(...args) {
        return createForumTopic(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteForumTopicHistory = function(...args) {
        return deleteForumTopicHistory(this._client, ...args);
      };
      TelegramClient$1.prototype.editForumTopic = function(...args) {
        return editForumTopic(this._client, ...args);
      };
      TelegramClient$1.prototype.getForumTopicsById = function(...args) {
        return getForumTopicsById(this._client, ...args);
      };
      TelegramClient$1.prototype.getForumTopics = function(...args) {
        return getForumTopics(this._client, ...args);
      };
      TelegramClient$1.prototype.iterForumTopics = function(...args) {
        return iterForumTopics(this._client, ...args);
      };
      TelegramClient$1.prototype.reorderPinnedForumTopics = function(...args) {
        return reorderPinnedForumTopics(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleForumTopicClosed = function(...args) {
        return toggleForumTopicClosed(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleForumTopicPinned = function(...args) {
        return toggleForumTopicPinned(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleForum = function(...args) {
        return toggleForum(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleGeneralTopicHidden = function(...args) {
        return toggleGeneralTopicHidden(this._client, ...args);
      };
      TelegramClient$1.prototype.createInviteLink = function(...args) {
        return createInviteLink(this._client, ...args);
      };
      TelegramClient$1.prototype.editInviteLink = function(...args) {
        return editInviteLink(this._client, ...args);
      };
      TelegramClient$1.prototype.exportInviteLink = function(...args) {
        return exportInviteLink(this._client, ...args);
      };
      TelegramClient$1.prototype.getInviteLinkMembers = function(...args) {
        return getInviteLinkMembers(this._client, ...args);
      };
      TelegramClient$1.prototype.getInviteLink = function(...args) {
        return getInviteLink(this._client, ...args);
      };
      TelegramClient$1.prototype.getInviteLinks = function(...args) {
        return getInviteLinks(this._client, ...args);
      };
      TelegramClient$1.prototype.getPrimaryInviteLink = function(...args) {
        return getPrimaryInviteLink(this._client, ...args);
      };
      TelegramClient$1.prototype.hideAllJoinRequests = function(...args) {
        return hideAllJoinRequests(this._client, ...args);
      };
      TelegramClient$1.prototype.hideJoinRequest = function(...args) {
        return hideJoinRequest(this._client, ...args);
      };
      TelegramClient$1.prototype.iterInviteLinkMembers = function(...args) {
        return iterInviteLinkMembers(this._client, ...args);
      };
      TelegramClient$1.prototype.iterInviteLinks = function(...args) {
        return iterInviteLinks(this._client, ...args);
      };
      TelegramClient$1.prototype.revokeInviteLink = function(...args) {
        return revokeInviteLink(this._client, ...args);
      };
      TelegramClient$1.prototype.closePoll = function(...args) {
        return closePoll(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteMessagesById = function(...args) {
        return deleteMessagesById(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteMessages = function(...args) {
        return deleteMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteScheduledMessages = function(...args) {
        return deleteScheduledMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.editInlineMessage = function(...args) {
        return editInlineMessage(this._client, ...args);
      };
      TelegramClient$1.prototype.editMessage = function(...args) {
        return editMessage(this._client, ...args);
      };
      TelegramClient$1.prototype.forwardMessagesById = function(...args) {
        return forwardMessagesById(this._client, ...args);
      };
      TelegramClient$1.prototype.forwardMessages = function(...args) {
        return forwardMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.getAllScheduledMessages = function(...args) {
        return getAllScheduledMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.getAvailableMessageEffects = function(...args) {
        return getAvailableMessageEffects(this._client, ...args);
      };
      TelegramClient$1.prototype.getCallbackQueryMessage = function(...args) {
        return getCallbackQueryMessage(this._client, ...args);
      };
      TelegramClient$1.prototype.getDiscussionMessage = function(...args) {
        return getDiscussionMessage(this._client, ...args);
      };
      TelegramClient$1.prototype.getFactCheck = function(...args) {
        return getFactCheck(this._client, ...args);
      };
      TelegramClient$1.prototype.getHistory = function(...args) {
        return getHistory(this._client, ...args);
      };
      TelegramClient$1.prototype.getMessageByLink = function(...args) {
        return getMessageByLink(this._client, ...args);
      };
      TelegramClient$1.prototype.getMessageGroup = function(...args) {
        return getMessageGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.getMessageReactionsById = function(...args) {
        return getMessageReactionsById(this._client, ...args);
      };
      TelegramClient$1.prototype.getMessageReactions = function(...args) {
        return getMessageReactions(this._client, ...args);
      };
      TelegramClient$1.prototype.getMessagesUnsafe = function(...args) {
        return getMessagesUnsafe(this._client, ...args);
      };
      TelegramClient$1.prototype.getMessages = function(...args) {
        return getMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.getReactionUsers = function(...args) {
        return getReactionUsers(this._client, ...args);
      };
      TelegramClient$1.prototype.getReplyTo = function(...args) {
        return getReplyTo(this._client, ...args);
      };
      TelegramClient$1.prototype.getScheduledMessages = function(...args) {
        return getScheduledMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.iterHistory = function(...args) {
        return iterHistory(this._client, ...args);
      };
      TelegramClient$1.prototype.iterReactionUsers = function(...args) {
        return iterReactionUsers(this._client, ...args);
      };
      TelegramClient$1.prototype.iterSearchGlobal = function(...args) {
        return iterSearchGlobal(this._client, ...args);
      };
      TelegramClient$1.prototype.iterSearchMessages = function(...args) {
        return iterSearchMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.pinMessage = function(...args) {
        return pinMessage(this._client, ...args);
      };
      TelegramClient$1.prototype.readHistory = function(...args) {
        return readHistory$1(this._client, ...args);
      };
      TelegramClient$1.prototype.readReactions = function(...args) {
        return readReactions(this._client, ...args);
      };
      TelegramClient$1.prototype.searchGlobal = function(...args) {
        return searchGlobal(this._client, ...args);
      };
      TelegramClient$1.prototype.searchHashtag = function(...args) {
        return searchHashtag(this._client, ...args);
      };
      TelegramClient$1.prototype.iterSearchHashtag = function(...args) {
        return iterSearchHashtag(this._client, ...args);
      };
      TelegramClient$1.prototype.searchMessages = function(...args) {
        return searchMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.answerText = function(...args) {
        return answerText(this._client, ...args);
      };
      TelegramClient$1.prototype.answerMedia = function(...args) {
        return answerMedia(this._client, ...args);
      };
      TelegramClient$1.prototype.answerMediaGroup = function(...args) {
        return answerMediaGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.commentText = function(...args) {
        return commentText(this._client, ...args);
      };
      TelegramClient$1.prototype.commentMedia = function(...args) {
        return commentMedia(this._client, ...args);
      };
      TelegramClient$1.prototype.commentMediaGroup = function(...args) {
        return commentMediaGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.sendCopyGroup = function(...args) {
        return sendCopyGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.sendCopy = function(...args) {
        return sendCopy(this._client, ...args);
      };
      TelegramClient$1.prototype.sendMediaGroup = function(...args) {
        return sendMediaGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.sendMedia = function(...args) {
        return sendMedia(this._client, ...args);
      };
      TelegramClient$1.prototype.sendPaidReaction = function(...args) {
        return sendPaidReaction(this._client, ...args);
      };
      TelegramClient$1.prototype.quoteWithText = function(...args) {
        return quoteWithText(this._client, ...args);
      };
      TelegramClient$1.prototype.quoteWithMedia = function(...args) {
        return quoteWithMedia(this._client, ...args);
      };
      TelegramClient$1.prototype.quoteWithMediaGroup = function(...args) {
        return quoteWithMediaGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.sendReaction = function(...args) {
        return sendReaction(this._client, ...args);
      };
      TelegramClient$1.prototype.replyText = function(...args) {
        return replyText(this._client, ...args);
      };
      TelegramClient$1.prototype.replyMedia = function(...args) {
        return replyMedia(this._client, ...args);
      };
      TelegramClient$1.prototype.replyMediaGroup = function(...args) {
        return replyMediaGroup(this._client, ...args);
      };
      TelegramClient$1.prototype.sendScheduled = function(...args) {
        return sendScheduled(this._client, ...args);
      };
      TelegramClient$1.prototype.sendText = function(...args) {
        return sendText(this._client, ...args);
      };
      TelegramClient$1.prototype.sendTyping = function(...args) {
        return sendTyping(this._client, ...args);
      };
      TelegramClient$1.prototype.sendVote = function(...args) {
        return sendVote(this._client, ...args);
      };
      TelegramClient$1.prototype.translateMessage = function(...args) {
        return translateMessage(this._client, ...args);
      };
      TelegramClient$1.prototype.translateText = function(...args) {
        return translateText(this._client, ...args);
      };
      TelegramClient$1.prototype.unpinAllMessages = function(...args) {
        return unpinAllMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.unpinMessage = function(...args) {
        return unpinMessage(this._client, ...args);
      };
      TelegramClient$1.prototype.getCollectibleInfo = function(...args) {
        return getCollectibleInfo(this._client, ...args);
      };
      TelegramClient$1.prototype.initTakeoutSession = function(...args) {
        return initTakeoutSession(this._client, ...args);
      };
      TelegramClient$1.prototype._normalizePrivacyRules = function(...args) {
        return _normalizePrivacyRules(this._client, ...args);
      };
      TelegramClient$1.prototype.changeCloudPassword = function(...args) {
        return changeCloudPassword(this._client, ...args);
      };
      TelegramClient$1.prototype.enableCloudPassword = function(...args) {
        return enableCloudPassword(this._client, ...args);
      };
      TelegramClient$1.prototype.verifyPasswordEmail = function(...args) {
        return verifyPasswordEmail(this._client, ...args);
      };
      TelegramClient$1.prototype.resendPasswordEmail = function(...args) {
        return resendPasswordEmail(this._client, ...args);
      };
      TelegramClient$1.prototype.cancelPasswordEmail = function(...args) {
        return cancelPasswordEmail(this._client, ...args);
      };
      TelegramClient$1.prototype.removeCloudPassword = function(...args) {
        return removeCloudPassword(this._client, ...args);
      };
      TelegramClient$1.prototype.acceptStarGift = function(...args) {
        return acceptStarGift(this._client, ...args);
      };
      TelegramClient$1.prototype.applyBoost = function(...args) {
        return applyBoost(this._client, ...args);
      };
      TelegramClient$1.prototype.canApplyBoost = function(...args) {
        return canApplyBoost(this._client, ...args);
      };
      TelegramClient$1.prototype.createBusinessChatLink = function(...args) {
        return createBusinessChatLink(this._client, ...args);
      };
      TelegramClient$1.prototype.editBusinessChatLink = function(...args) {
        return editBusinessChatLink(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteBusinessChatLink = function(...args) {
        return deleteBusinessChatLink(this._client, ...args);
      };
      TelegramClient$1.prototype.getBoostStats = function(...args) {
        return getBoostStats(this._client, ...args);
      };
      TelegramClient$1.prototype.getBoosts = function(...args) {
        return getBoosts(this._client, ...args);
      };
      TelegramClient$1.prototype.getBusinessChatLinks = function(...args) {
        return getBusinessChatLinks(this._client, ...args);
      };
      TelegramClient$1.prototype.getBusinessConnection = function(...args) {
        return getBusinessConnection(this._client, ...args);
      };
      TelegramClient$1.prototype.getMyBoostSlots = function(...args) {
        return getMyBoostSlots(this._client, ...args);
      };
      TelegramClient$1.prototype.getStarGiftOptions = function(...args) {
        return getStarGiftOptions(this._client, ...args);
      };
      TelegramClient$1.prototype.getStarGifts = function(...args) {
        return getStarGifts(this._client, ...args);
      };
      TelegramClient$1.prototype.getStarsTransactions = function(...args) {
        return getStarsTransactions(this._client, ...args);
      };
      TelegramClient$1.prototype.iterBoosters = function(...args) {
        return iterBoosters(this._client, ...args);
      };
      TelegramClient$1.prototype.iterStarGifts = function(...args) {
        return iterStarGifts(this._client, ...args);
      };
      TelegramClient$1.prototype.iterStarsTransactions = function(...args) {
        return iterStarsTransactions(this._client, ...args);
      };
      TelegramClient$1.prototype.sendStarGift = function(...args) {
        return sendStarGift(this._client, ...args);
      };
      TelegramClient$1.prototype.setBusinessIntro = function(...args) {
        return setBusinessIntro(this._client, ...args);
      };
      TelegramClient$1.prototype.setBusinessWorkHours = function(...args) {
        return setBusinessWorkHours(this._client, ...args);
      };
      TelegramClient$1.prototype.addStickerToSet = function(...args) {
        return addStickerToSet(this._client, ...args);
      };
      TelegramClient$1.prototype.createStickerSet = function(...args) {
        return createStickerSet(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteStickerFromSet = function(...args) {
        return deleteStickerFromSet(this._client, ...args);
      };
      TelegramClient$1.prototype.getCustomEmojis = function(...args) {
        return getCustomEmojis(this._client, ...args);
      };
      TelegramClient$1.prototype.getCustomEmojisFromMessages = function(...args) {
        return getCustomEmojisFromMessages(this._client, ...args);
      };
      TelegramClient$1.prototype.getInstalledStickers = function(...args) {
        return getInstalledStickers(this._client, ...args);
      };
      TelegramClient$1.prototype.getMyStickerSets = function(...args) {
        return getMyStickerSets(this._client, ...args);
      };
      TelegramClient$1.prototype.getStickerSet = function(...args) {
        return getStickerSet(this._client, ...args);
      };
      TelegramClient$1.prototype.moveStickerInSet = function(...args) {
        return moveStickerInSet(this._client, ...args);
      };
      TelegramClient$1.prototype.replaceStickerInSet = function(...args) {
        return replaceStickerInSet(this._client, ...args);
      };
      TelegramClient$1.prototype.setChatStickerSet = function(...args) {
        return setChatStickerSet(this._client, ...args);
      };
      TelegramClient$1.prototype.setStickerSetThumb = function(...args) {
        return setStickerSetThumb(this._client, ...args);
      };
      TelegramClient$1.prototype.canSendStory = function(...args) {
        return canSendStory(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteStories = function(...args) {
        return deleteStories(this._client, ...args);
      };
      TelegramClient$1.prototype.editStory = function(...args) {
        return editStory(this._client, ...args);
      };
      TelegramClient$1.prototype.getAllStories = function(...args) {
        return getAllStories(this._client, ...args);
      };
      TelegramClient$1.prototype.getPeerStories = function(...args) {
        return getPeerStories(this._client, ...args);
      };
      TelegramClient$1.prototype.getProfileStories = function(...args) {
        return getProfileStories(this._client, ...args);
      };
      TelegramClient$1.prototype.getStoriesById = function(...args) {
        return getStoriesById(this._client, ...args);
      };
      TelegramClient$1.prototype.getStoriesInteractions = function(...args) {
        return getStoriesInteractions(this._client, ...args);
      };
      TelegramClient$1.prototype.getStoryLink = function(...args) {
        return getStoryLink(this._client, ...args);
      };
      TelegramClient$1.prototype.getStoryViewers = function(...args) {
        return getStoryViewers(this._client, ...args);
      };
      TelegramClient$1.prototype.hideMyStoriesViews = function(...args) {
        return hideMyStoriesViews(this._client, ...args);
      };
      TelegramClient$1.prototype.incrementStoriesViews = function(...args) {
        return incrementStoriesViews(this._client, ...args);
      };
      TelegramClient$1.prototype.iterAllStories = function(...args) {
        return iterAllStories(this._client, ...args);
      };
      TelegramClient$1.prototype.iterProfileStories = function(...args) {
        return iterProfileStories(this._client, ...args);
      };
      TelegramClient$1.prototype.iterStoryViewers = function(...args) {
        return iterStoryViewers(this._client, ...args);
      };
      TelegramClient$1.prototype.readStories = function(...args) {
        return readStories(this._client, ...args);
      };
      TelegramClient$1.prototype.sendStoryReaction = function(...args) {
        return sendStoryReaction(this._client, ...args);
      };
      TelegramClient$1.prototype.sendStory = function(...args) {
        return sendStory(this._client, ...args);
      };
      TelegramClient$1.prototype.togglePeerStoriesArchived = function(...args) {
        return togglePeerStoriesArchived(this._client, ...args);
      };
      TelegramClient$1.prototype.toggleStoriesPinned = function(...args) {
        return toggleStoriesPinned(this._client, ...args);
      };
      TelegramClient$1.prototype.blockUser = function(...args) {
        return blockUser(this._client, ...args);
      };
      TelegramClient$1.prototype.deleteProfilePhotos = function(...args) {
        return deleteProfilePhotos(this._client, ...args);
      };
      TelegramClient$1.prototype.editCloseFriendsRaw = function(...args) {
        return editCloseFriendsRaw(this._client, ...args);
      };
      TelegramClient$1.prototype.editCloseFriends = function(...args) {
        return editCloseFriends(this._client, ...args);
      };
      TelegramClient$1.prototype.getCommonChats = function(...args) {
        return getCommonChats(this._client, ...args);
      };
      TelegramClient$1.prototype.getGlobalTtl = function(...args) {
        return getGlobalTtl(this._client, ...args);
      };
      TelegramClient$1.prototype.getMe = function(...args) {
        return getMe(this._client, ...args);
      };
      TelegramClient$1.prototype.getMyUsername = function(...args) {
        return getMyUsername(this._client, ...args);
      };
      TelegramClient$1.prototype.getProfilePhoto = function(...args) {
        return getProfilePhoto(this._client, ...args);
      };
      TelegramClient$1.prototype.getProfilePhotos = function(...args) {
        return getProfilePhotos(this._client, ...args);
      };
      TelegramClient$1.prototype.getUsers = function(...args) {
        return getUsers(this._client, ...args);
      };
      TelegramClient$1.prototype.isPeerAvailable = function(...args) {
        return isPeerAvailable(this._client, ...args);
      };
      TelegramClient$1.prototype.iterProfilePhotos = function(...args) {
        return iterProfilePhotos(this._client, ...args);
      };
      TelegramClient$1.prototype.resolvePeerMany = function(...args) {
        return resolvePeerMany(this._client, ...args);
      };
      TelegramClient$1.prototype.resolvePeer = function(...args) {
        return resolvePeer(this._client, ...args);
      };
      TelegramClient$1.prototype.resolveUser = function(...args) {
        return resolveUser(this._client, ...args);
      };
      TelegramClient$1.prototype.resolveChannel = function(...args) {
        return resolveChannel(this._client, ...args);
      };
      TelegramClient$1.prototype.setGlobalTtl = function(...args) {
        return setGlobalTtl(this._client, ...args);
      };
      TelegramClient$1.prototype.setMyBirthday = function(...args) {
        return setMyBirthday(this._client, ...args);
      };
      TelegramClient$1.prototype.setMyEmojiStatus = function(...args) {
        return setMyEmojiStatus(this._client, ...args);
      };
      TelegramClient$1.prototype.setMyProfilePhoto = function(...args) {
        return setMyProfilePhoto(this._client, ...args);
      };
      TelegramClient$1.prototype.setMyUsername = function(...args) {
        return setMyUsername(this._client, ...args);
      };
      TelegramClient$1.prototype.setOffline = function(...args) {
        return setOffline(this._client, ...args);
      };
      TelegramClient$1.prototype.unblockUser = function(...args) {
        return unblockUser(this._client, ...args);
      };
      TelegramClient$1.prototype.updateProfile = function(...args) {
        return updateProfile(this._client, ...args);
      };
      TelegramClient$1.prototype.prepare = function(...args) {
        return this._client.prepare(...args);
      };
      TelegramClient$1.prototype.connect = function(...args) {
        return this._client.connect(...args);
      };
      TelegramClient$1.prototype.close = function(...args) {
        return this._client.close(...args);
      };
      TelegramClient$1.prototype.notifyLoggedIn = function(...args) {
        return this._client.notifyLoggedIn(...args);
      };
      TelegramClient$1.prototype.notifyLoggedOut = function(...args) {
        return this._client.notifyLoggedOut(...args);
      };
      TelegramClient$1.prototype.notifyChannelOpened = function(...args) {
        return this._client.notifyChannelOpened(...args);
      };
      TelegramClient$1.prototype.notifyChannelClosed = function(...args) {
        return this._client.notifyChannelClosed(...args);
      };
      TelegramClient$1.prototype.startUpdatesLoop = function(...args) {
        return this._client.startUpdatesLoop(...args);
      };
      TelegramClient$1.prototype.stopUpdatesLoop = function(...args) {
        return this._client.stopUpdatesLoop(...args);
      };
      TelegramClient$1.prototype.call = function(...args) {
        return this._client.call(...args);
      };
      TelegramClient$1.prototype.importSession = function(...args) {
        return this._client.importSession(...args);
      };
      TelegramClient$1.prototype.exportSession = function(...args) {
        return this._client.exportSession(...args);
      };
      TelegramClient$1.prototype.onError = function(...args) {
        return this._client.onError(...args);
      };
      TelegramClient$1.prototype.emitError = function(...args) {
        return this._client.emitError(...args);
      };
      TelegramClient$1.prototype.handleClientUpdate = function(...args) {
        return this._client.handleClientUpdate(...args);
      };
      TelegramClient$1.prototype.getApiCrenetials = function(...args) {
        return this._client.getApiCrenetials(...args);
      };
      TelegramClient$1.prototype.getPoolSize = function(...args) {
        return this._client.getPoolSize(...args);
      };
      TelegramClient$1.prototype.getPrimaryDcId = function(...args) {
        return this._client.getPrimaryDcId(...args);
      };
      TelegramClient$1.prototype.computeSrpParams = function(...args) {
        return this._client.computeSrpParams(...args);
      };
      TelegramClient$1.prototype.computeNewPasswordHash = function(...args) {
        return this._client.computeNewPasswordHash(...args);
      };
      TelegramClient$1.prototype.onConnectionState = function(...args) {
        return this._client.onConnectionState(...args);
      };
      TelegramClient$1.prototype.getServerUpdateHandler = function(...args) {
        return this._client.getServerUpdateHandler(...args);
      };
      TelegramClient$1.prototype.changePrimaryDc = function(...args) {
        return this._client.changePrimaryDc(...args);
      };
      TelegramClient$1.prototype.getMtprotoMessageId = function(...args) {
        return this._client.getMtprotoMessageId(...args);
      };
      TelegramClient$1.prototype.onServerUpdate = function() {
        throw new Error("onServerUpdate is not available for TelegramClient, use .on() methods instead");
      };
      TelegramClient$1.prototype.onUpdate = function() {
        throw new Error("onUpdate is not available for TelegramClient, use .on() methods instead");
      };
      class WebCryptoProvider {
        constructor() {
          __publicField(this, "instance");
        }
        initialize() {
          return __async(this, null, function* () {
            {
              const m2 = yield __vitePreload(() => module.import("./crypto-DTYnQMGo.js"), false ? "__VITE_PRELOAD__" : void 0);
              this.instance = new m2.AsmCryptoProvider();
            }
            yield this.instance.initialize();
          });
        }
        pbkdf2(password, salt, iterations, keylen, algo) {
          return this.instance.pbkdf2(password, salt, iterations, keylen, algo);
        }
        createAesCtr(key, iv) {
          return this.instance.createAesCtr(key, iv);
        }
        createAesIge(key, iv) {
          return this.instance.createAesIge(key, iv);
        }
        factorizePQ(pq) {
          return this.instance.factorizePQ(pq);
        }
        gzip(data2, maxSize) {
          return this.instance.gzip(data2, maxSize);
        }
        gunzip(data2) {
          return this.instance.gunzip(data2);
        }
        randomFill(buf) {
          return this.instance.randomFill(buf);
        }
        randomBytes(size2) {
          return this.instance.randomBytes(size2);
        }
        sha1(data2) {
          return this.instance.sha1(data2);
        }
        sha256(data2) {
          return this.instance.sha256(data2);
        }
        hmacSha256(data2, key) {
          return this.instance.hmacSha256(data2, key);
        }
      }
      exports("dk", WebCryptoProvider);
      class BaseStorageDriver {
        constructor() {
          __publicField(this, "_loadedTimes", 0);
          __publicField(this, "_destroyed", false);
          __publicField(this, "_log");
        }
        setup(log) {
          this._log = log.create("sqlite");
        }
        get loaded() {
          return this._loadedTimes > 0;
        }
        load() {
          return __async(this, null, function* () {
            if (this._loadedTimes === 0) {
              yield this._load();
              this._destroyed = false;
            }
            this._loadedTimes++;
          });
        }
        destroy() {
          return __async(this, null, function* () {
            if (this._destroyed) {
              return;
            }
            this._loadedTimes--;
            if (this._loadedTimes === 0) {
              yield this._destroy();
              this._destroyed = true;
            }
          });
        }
        save() {
          var _a3;
          return (_a3 = this._save) == null ? void 0 : _a3.call(this);
        }
      }
      exports("B", BaseStorageDriver);
      function txToPromise(tx) {
        return new Promise((resolve, reject) => {
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      }
      function reqToPromise(req) {
        return new Promise((resolve, reject) => {
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      const REPO_VERSION_PREFIX = "__version:";
      class IdbStorageDriver extends BaseStorageDriver {
        constructor(_dbName) {
          super();
          __publicField(this, "db");
          __publicField(this, "_pendingWrites", []);
          __publicField(this, "_pendingWritesOses", /* @__PURE__ */ new Set());
          __publicField(this, "_migrations", /* @__PURE__ */ new Map());
          __publicField(this, "_maxVersion", /* @__PURE__ */ new Map());
          this._dbName = _dbName;
          if (typeof indexedDB === "undefined") {
            throw new MtUnsupportedError("IndexedDB is not available");
          }
        }
        registerMigration(repo, version2, migration) {
          var _a3;
          if (this.loaded) {
            throw new Error("Cannot register migrations after loading");
          }
          let map2 = this._migrations.get(repo);
          if (!map2) {
            map2 = /* @__PURE__ */ new Map();
            this._migrations.set(repo, map2);
          }
          if (map2.has(version2)) {
            throw new Error(`Migration for ${repo} version ${version2} is already registered`);
          }
          map2.set(version2, migration);
          const prevMax = (_a3 = this._maxVersion.get(repo)) != null ? _a3 : 0;
          if (version2 > prevMax) {
            this._maxVersion.set(repo, version2);
          }
        }
        writeLater(os, obj) {
          this._pendingWrites.push([os, obj]);
          this._pendingWritesOses.add(os);
        }
        _load() {
          return __async(this, null, function* () {
            this.db = yield new Promise((resolve, reject) => {
              const req = indexedDB.open(this._dbName, Date.now());
              req.onerror = () => reject(req.error);
              const postUpgrade = [];
              req.onsuccess = () => __async(this, null, function* () {
                try {
                  for(let   cb of postUpgrade) {
                    yield cb(req.result);
                  }
                  resolve(req.result);
                } catch (e2) {
                  reject(e2);
                }
              });
              req.onupgradeneeded = () => {
                const db = req.result;
                const didUpgrade = /* @__PURE__ */ new Set();
                const doUpgrade = (repo, fromVersion) => {
                  const migrations = this._migrations.get(repo);
                  if (!migrations)
                    return;
                  const targetVer = this._maxVersion.get(repo);
                  while (fromVersion < targetVer) {
                    const nextVersion = fromVersion + 1;
                    const migration = migrations.get(nextVersion);
                    if (!migration) {
                      throw new Error(`No migration for ${repo} to version ${nextVersion}`);
                    }
                    const result = migration(db);
                    if (result) {
                      postUpgrade.push(result);
                    }
                    fromVersion = nextVersion;
                  }
                  didUpgrade.add(repo);
                  db.createObjectStore(`${REPO_VERSION_PREFIX}${repo}:${targetVer}`);
                };
                for(let   key of db.objectStoreNames) {
                  if (!key.startsWith(REPO_VERSION_PREFIX))
                    continue;
                  const [, repo, version2] = key.split(":");
                  const currentVer = Number(version2);
                  db.deleteObjectStore(key);
                  doUpgrade(repo, currentVer);
                  didUpgrade.add(repo);
                }
                for(let   repo of this._migrations.keys()) {
                  if (didUpgrade.has(repo))
                    continue;
                  doUpgrade(repo, 0);
                }
              };
            });
          });
        }
        _save() {
          return __async(this, null, function* () {
            if (this._pendingWritesOses.size === 0)
              return;
            const writes = this._pendingWrites;
            const oses = this._pendingWritesOses;
            this._pendingWrites = [];
            this._pendingWritesOses = /* @__PURE__ */ new Set();
            const tx = this.db.transaction(oses, "readwrite");
            const osMap = /* @__PURE__ */ new Map();
            for(let   table of oses) {
              osMap.set(table, tx.objectStore(table));
            }
            for(let   [table, obj] of writes) {
              const os = osMap.get(table);
              if (obj === null) {
                os.delete(table);
              } else {
                os.put(obj);
              }
            }
            yield txToPromise(tx);
          });
        }
        _destroy() {
          this.db.close();
        }
      }
      exports("c3", IdbStorageDriver);
      const TABLE_AUTH_KEYS = "authKeys";
      const TABLE_TEMP_AUTH_KEYS = "tempAuthKeys";
      class IdbAuthKeysRepository {
        constructor(_driver) {
          this._driver = _driver;
          _driver.registerMigration(TABLE_AUTH_KEYS, 1, (db) => {
            db.createObjectStore(TABLE_AUTH_KEYS, { keyPath: "dc" });
            db.createObjectStore(TABLE_TEMP_AUTH_KEYS, { keyPath: ["dc", "idx"] });
          });
        }
        os(mode) {
          return this._driver.db.transaction(TABLE_AUTH_KEYS, mode).objectStore(TABLE_AUTH_KEYS);
        }
        set(dc, key) {
          return __async(this, null, function* () {
            const os = this.os("readwrite");
            if (key === null) {
              return reqToPromise(os.delete(dc));
            }
            yield reqToPromise(os.put({ dc, key }));
          });
        }
        get(dc) {
          return __async(this, null, function* () {
            const os = this.os();
            const it = yield reqToPromise(os.get(dc));
            if (it === void 0)
              return null;
            return it.key;
          });
        }
        osTemp(mode) {
          return this._driver.db.transaction(TABLE_TEMP_AUTH_KEYS, mode).objectStore(TABLE_TEMP_AUTH_KEYS);
        }
        setTemp(dc, idx, key, expires) {
          return __async(this, null, function* () {
            const os = this.osTemp("readwrite");
            if (!key) {
              return reqToPromise(os.delete([dc, idx]));
            }
            yield reqToPromise(os.put({ dc, idx, key, expiresAt: expires }));
          });
        }
        getTemp(dc, idx, now2) {
          return __async(this, null, function* () {
            const os = this.osTemp();
            const row = yield reqToPromise(os.get([dc, idx]));
            if (row === void 0 || row.expiresAt < now2)
              return null;
            return row.key;
          });
        }
        deleteByDc(dc) {
          return __async(this, null, function* () {
            return new Promise((res) => {
              const tx = this._driver.db.transaction([TABLE_AUTH_KEYS, TABLE_TEMP_AUTH_KEYS], "readwrite");
              tx.objectStore(TABLE_AUTH_KEYS).delete(dc);
              const tempOs = tx.objectStore(TABLE_TEMP_AUTH_KEYS);
              const keys2 = tempOs.getAllKeys();
              keys2.onsuccess = () => {
                for(let   key of keys2.result) {
                  if (key[0] === dc) {
                    tempOs.delete(key);
                  }
                }
                res(txToPromise(tx));
              };
            });
          });
        }
        deleteAll() {
          const tx = this._driver.db.transaction([TABLE_AUTH_KEYS, TABLE_TEMP_AUTH_KEYS], "readwrite");
          tx.objectStore(TABLE_AUTH_KEYS).clear();
          tx.objectStore(TABLE_TEMP_AUTH_KEYS).clear();
          return txToPromise(tx);
        }
      }
      const KV_TABLE = "kv";
      class IdbKvRepository {
        constructor(_driver) {
          this._driver = _driver;
          _driver.registerMigration(KV_TABLE, 1, (db) => {
            db.createObjectStore(KV_TABLE, { keyPath: "key" });
          });
        }
        set(key, value) {
          this._driver.writeLater(KV_TABLE, { key, value });
        }
        os(mode) {
          return this._driver.db.transaction(KV_TABLE, mode).objectStore(KV_TABLE);
        }
        get(key) {
          return __async(this, null, function* () {
            const os = this.os();
            const res = yield reqToPromise(os.get(key));
            if (res === void 0)
              return null;
            return res.value;
          });
        }
        delete(key) {
          return __async(this, null, function* () {
            yield reqToPromise(this.os("readwrite").delete(key));
          });
        }
        deleteAll() {
          return __async(this, null, function* () {
            yield reqToPromise(this.os("readwrite").clear());
          });
        }
      }
      const TABLE$1 = "peers";
      class IdbPeersRepository {
        constructor(_driver) {
          this._driver = _driver;
          _driver.registerMigration(TABLE$1, 1, (db) => {
            const os = db.createObjectStore(TABLE$1, { keyPath: "id" });
            os.createIndex("by_username", "usernames", { unique: true, multiEntry: true });
            os.createIndex("by_phone", "phone", { unique: true });
          });
        }
        store(peer) {
          this._driver.writeLater(TABLE$1, peer);
        }
        os(mode) {
          return this._driver.db.transaction(TABLE$1, mode).objectStore(TABLE$1);
        }
        getById(id2, allowMin) {
          return __async(this, null, function* () {
            const it = yield reqToPromise(this.os().get(id2));
            if (!it)
              return null;
            if (it.isMin && !allowMin)
              return null;
            return it;
          });
        }
        getByUsername(username2) {
          return __async(this, null, function* () {
            const it = yield reqToPromise(
              this.os().index("by_username").get(username2)
            );
            if (!it || it.isMin)
              return null;
            return it;
          });
        }
        getByPhone(phone) {
          return __async(this, null, function* () {
            const it = yield reqToPromise(this.os().index("by_phone").get(phone));
            if (!it || it.isMin)
              return null;
            return it;
          });
        }
        deleteAll() {
          return reqToPromise(this.os("readwrite").clear());
        }
      }
      const TABLE = "messageRefs";
      class IdbRefMsgRepository {
        constructor(_driver) {
          this._driver = _driver;
          _driver.registerMigration(TABLE, 1, (db) => {
            const os = db.createObjectStore(TABLE, { keyPath: ["peerId", "chatId", "msgId"] });
            os.createIndex("by_peer", "peerId");
            os.createIndex("by_msg", ["chatId", "msgId"]);
          });
        }
        os(mode) {
          return this._driver.db.transaction(TABLE, mode).objectStore(TABLE);
        }
        store(peerId, chatId, msgId) {
          return __async(this, null, function* () {
            const os = this.os("readwrite");
            yield reqToPromise(os.put({ peerId, chatId, msgId }));
          });
        }
        getByPeer(peerId) {
          return __async(this, null, function* () {
            const os = this.os();
            const index = os.index("by_peer");
            const it = yield reqToPromise(index.get(peerId));
            if (!it)
              return null;
            return [it.chatId, it.msgId];
          });
        }
        delete(chatId, msgIds) {
          return __async(this, null, function* () {
            const tx = this._driver.db.transaction(TABLE, "readwrite");
            const os = tx.objectStore(TABLE);
            const index = os.index("by_msg");
            for(let   msgId of msgIds) {
              const req = index.getAllKeys([chatId, msgId]);
              req.onsuccess = () => {
                for(let   key of req.result) {
                  os.delete(key);
                }
              };
            }
            return txToPromise(tx);
          });
        }
        deleteByPeer(peerId) {
          return __async(this, null, function* () {
            const tx = this._driver.db.transaction(TABLE, "readwrite");
            const os = tx.objectStore(TABLE);
            const index = os.index("by_peer");
            const req = index.openCursor(peerId);
            req.onsuccess = () => {
              if (req.result) {
                req.result.delete();
                req.result.continue();
              }
            };
            return txToPromise(tx);
          });
        }
        deleteAll() {
          return __async(this, null, function* () {
            yield reqToPromise(this.os("readwrite").clear());
          });
        }
      }
      class IdbStorage {
        constructor(dbName) {
          __publicField(this, "driver");
          __publicField(this, "kv");
          __publicField(this, "authKeys");
          __publicField(this, "peers");
          __publicField(this, "refMessages");
          this.dbName = dbName;
          this.driver = new IdbStorageDriver(this.dbName);
          this.kv = new IdbKvRepository(this.driver);
          this.authKeys = new IdbAuthKeysRepository(this.driver);
          this.peers = new IdbPeersRepository(this.driver);
          this.refMessages = new IdbRefMsgRepository(this.driver);
        }
      }
      exports("c2", IdbStorage);
      const lookup$1 = [];
      const revLookup = [];
      const code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (let i = 0, len = code$1.length; i < len; ++i) {
        lookup$1[i] = code$1[i];
        revLookup[code$1.charCodeAt(i)] = i;
      }
      function getLens(b64) {
        const len = b64.length;
        if (len % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        let validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len;
        const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64, arr) {
        let tmp;
        const lens = getLens(b64);
        const validLen = lens[0];
        const placeHoldersLen = lens[1];
        let curByte = 0;
        const len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        let i;
        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num2) {
        return lookup$1[num2 >> 18 & 63] + lookup$1[num2 >> 12 & 63] + lookup$1[num2 >> 6 & 63] + lookup$1[num2 & 63];
      }
      function encodeChunk(uint8, start2, end) {
        let tmp;
        const output = [];
        for (let i = start2; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        let tmp;
        const len = uint8.length;
        const extraBytes = len % 3;
        const parts = [];
        const maxChunkLength = 16383;
        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(`${lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63]}==`);
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(`${lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63]}=`);
        }
        return parts.join("");
      }
      function base64Encode(buf, url2 = false) {
        const str = fromByteArray(buf);
        if (url2)
          return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
        return str;
      }
      function base64Decode(string, url2 = false) {
        if (url2) {
          string = string.replace(/-/g, "+").replace(/_/g, "/");
          while (string.length % 4)
            string += "=";
        }
        const buf = new Uint8Array(_byteLength(string, ...getLens(string)));
        toByteArray(string, buf);
        return buf;
      }
      const hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = Array.from({ length: 256 });
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      const hexCharValueTable = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15
      };
      function hexEncode(buf) {
        let out = "";
        for (let i = 0; i < buf.byteLength; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function hexDecodeInner(buf, string) {
        const strLen = string.length;
        const length = Math.min(buf.length, strLen / 2);
        let i;
        for (i = 0; i < length; ++i) {
          const a = hexCharValueTable[string[i * 2]];
          const b = hexCharValueTable[string[i * 2 + 1]];
          if (a === void 0 || b === void 0) {
            return;
          }
          buf[i] = a << 4 | b;
        }
      }
      function hexDecode(string) {
        const buf = new Uint8Array(Math.ceil(string.length / 2));
        hexDecodeInner(buf, string);
        return buf;
      }
      const BASE_FORMAT = "%s [%c%s%c] [%c%s%c] ";
      const LEVEL_NAMES = [
        "",
        // OFF
        "ERR",
        "WRN",
        "INF",
        "DBG",
        "VRB"
      ];
      const COLORS = [
        "",
        // OFF
        "color: #7a5f9d",
        "color: #8d7041",
        "color: #396c9e",
        "color: #437761",
        "color: #7a5f9d"
      ];
      const TAG_COLORS = [
        "color: #437761",
        "color: #537a36",
        "color: #8d7041",
        "color: #396c9e",
        "color: #7a5f9d",
        "color: #7a5f9d"
      ];
      const defaultLoggingHandler = (color2, level, tag, fmt, args) => {
        console.log(
          BASE_FORMAT + fmt,
          (/* @__PURE__ */ new Date()).toISOString(),
          COLORS[level],
          LEVEL_NAMES[level],
          "",
          TAG_COLORS[color2],
          tag,
          "",
          ...args
        );
      };
      const sharedEncoder = new TextEncoder();
      const sharedDecoder = new TextDecoder("utf8");
      function utf8ByteLength(str) {
        let s = str.length;
        for (let i = str.length - 1; i >= 0; i--) {
          const code2 = str.charCodeAt(i);
          if (code2 > 127 && code2 <= 2047)
            s++;
          else if (code2 > 2047 && code2 <= 65535)
            s += 2;
          if (code2 >= 56320 && code2 <= 57343)
            i--;
        }
        return s;
      }
      function utf8Decode(buf) {
        return sharedDecoder.decode(buf);
      }
      function utf8Encode(str) {
        return sharedEncoder.encode(str);
      }
      const callbacks = /* @__PURE__ */ new Set();
      let registered = false;
      function beforeExit(fn) {
        if (typeof window === "undefined") {
          return () => {
          };
        }
        if (!registered) {
          registered = true;
          window.addEventListener("beforeunload", () => {
            for(let   callback2 of callbacks) {
              callback2();
            }
          });
        }
        callbacks.add(fn);
        return () => {
          callbacks.delete(fn);
        };
      }
      class WebPlatform {
        getDeviceModel() {
          if (typeof navigator === "undefined")
            return "Browser";
          return navigator.userAgent;
        }
        getDefaultLogLevel() {
          if (typeof localStorage !== "undefined") {
            const localLogLevel = Number.parseInt(localStorage.MTCUTE_LOG_LEVEL);
            if (!Number.isNaN(localLogLevel)) {
              return localLogLevel;
            }
          }
          return null;
        }
        onNetworkChanged(fn) {
          if (!("onLine" in navigator))
            return () => {
            };
          const onlineHandler = () => fn(navigator.onLine);
          window.addEventListener("online", onlineHandler);
          window.addEventListener("offline", onlineHandler);
          return () => {
            window.removeEventListener("online", onlineHandler);
            window.removeEventListener("offline", onlineHandler);
          };
        }
        isOnline() {
          return navigator.onLine;
        }
      }
      exports("dn", WebPlatform);
      WebPlatform.prototype.log = defaultLoggingHandler;
      WebPlatform.prototype.beforeExit = beforeExit;
      WebPlatform.prototype.utf8ByteLength = utf8ByteLength;
      WebPlatform.prototype.utf8Encode = utf8Encode;
      WebPlatform.prototype.utf8Decode = utf8Decode;
      WebPlatform.prototype.hexEncode = hexEncode;
      WebPlatform.prototype.hexDecode = hexDecode;
      WebPlatform.prototype.base64Encode = base64Encode;
      WebPlatform.prototype.base64Decode = base64Decode;
      const subdomainsMap = {
        1: "pluto",
        2: "venus",
        3: "aurora",
        4: "vesta",
        5: "flora"
      };
      class BaseWebSocketTransport extends EventEmitter {
        constructor({
          ws = WebSocket,
          baseDomain = "web.telegram.org",
          subdomains = subdomainsMap
        } = {}) {
          ws = ws != null ? ws : WebSocket;
          baseDomain = baseDomain != null ? baseDomain : "web.telegram.org";
          subdomains = subdomains != null ? subdomains : subdomainsMap;
          super();
          __publicField(this, "_currentDc", null);
          __publicField(this, "_state", TransportState.Idle);
          __publicField(this, "_socket", null);
          __publicField(this, "_crypto");
          __publicField(this, "log");
          __publicField(this, "packetCodecInitialized", false);
          __publicField(this, "_baseDomain");
          __publicField(this, "_subdomains");
          __publicField(this, "_WebSocket");
          __publicField(this, "_closeWaiters", []);
          if (!ws) {
            throw new MtUnsupportedError(
              "To use WebSocket transport with NodeJS, install `ws` package and pass it to constructor"
            );
          }
          if ("default" in ws) {
            ws = ws.default;
          }
          this._baseDomain = baseDomain;
          this._subdomains = subdomains;
          this._WebSocket = ws;
        }
        _updateLogPrefix() {
          if (this._currentDc) {
            this.log.prefix = `[WS:${this._subdomains[this._currentDc.id]}.${this._baseDomain}] `;
          } else {
            this.log.prefix = "[WS:disconnected] ";
          }
        }
        setup(crypto, log) {
          this._crypto = crypto;
          this.log = log.create("ws");
        }
        state() {
          return this._state;
        }
        currentDc() {
          return this._currentDc;
        }
        connect(dc, testMode) {
          var _a3, _b2;
          if (this._state !== TransportState.Idle) {
            throw new MtcuteError("Transport is not IDLE");
          }
          if (!this.packetCodecInitialized) {
            (_b2 = (_a3 = this._packetCodec).setup) == null ? void 0 : _b2.call(_a3, this._crypto, this.log);
            this._packetCodec.on("error", (err) => this.emit("error", err));
            this._packetCodec.on("packet", (buf) => this.emit("message", buf));
            this.packetCodecInitialized = true;
          }
          this._state = TransportState.Connecting;
          this._currentDc = dc;
          this._socket = new this._WebSocket(
            `wss://${this._subdomains[dc.id]}.${this._baseDomain}/apiws${testMode ? "_test" : ""}`,
            "binary"
          );
          this._updateLogPrefix();
          this.log.debug("connecting to %s (%j)", this._socket.url, dc);
          this._socket.binaryType = "arraybuffer";
          this._socket.addEventListener("message", (evt) => this._packetCodec.feed(new Uint8Array(evt.data)));
          this._socket.addEventListener("open", this.handleConnect.bind(this));
          this._socket.addEventListener("error", this.handleError.bind(this));
          this._socket.addEventListener("close", this.handleClosed.bind(this));
        }
        close() {
          return __async(this, null, function* () {
            if (this._state === TransportState.Idle)
              return;
            const promise = createControllablePromise();
            this._closeWaiters.push(promise);
            this._socket.close();
            return promise;
          });
        }
        handleClosed() {
          this.log.info("connection closed");
          this._state = TransportState.Idle;
          this._socket = null;
          this._currentDc = null;
          this._packetCodec.reset();
          this.emit("close");
          for(let   waiter of this._closeWaiters) {
            waiter.resolve();
          }
          this._closeWaiters = [];
        }
        handleError(event) {
          const error = "error" in event ? event.error : new Error("unknown WebSocket error");
          this.log.error("error: %s", error.stack);
          this.emit("error", error);
        }
        handleConnect() {
          this.log.info("connected");
          Promise.resolve(this._packetCodec.tag()).then((initialMessage) => {
            this._socket.send(initialMessage);
            this._state = TransportState.Ready;
            this.emit("ready");
          }).catch((err) => this.emit("error", err));
        }
        send(bytes) {
          return __async(this, null, function* () {
            if (this._state !== TransportState.Ready) {
              throw new MtcuteError("Transport is not READY");
            }
            const framed = yield this._packetCodec.encode(bytes);
            this._socket.send(framed);
          });
        }
      }
      exports("be", BaseWebSocketTransport);
      class WebSocketTransport extends BaseWebSocketTransport {
        constructor() {
          super(...arguments);
          __publicField(this, "_packetCodec", new ObfuscatedPacketCodec(new IntermediatePacketCodec()));
        }
      }
      exports("dp", WebSocketTransport);
      class BaseTelegramClient extends BaseTelegramClient$1 {
        constructor(opts) {
          var _a3;
          if (!opts.platformless)
            setPlatform(new WebPlatform());
          super(__spreadProps(__spreadValues({
            crypto: new WebCryptoProvider(),
            transport: () => new WebSocketTransport()
          }, opts), {
            storage: typeof opts.storage === "string" ? new IdbStorage(opts.storage) : (_a3 = opts.storage) != null ? _a3 : new IdbStorage("client.session")
          }));
        }
      }
      exports("bd", BaseTelegramClient);
      class TelegramClient extends TelegramClient$1 {
        constructor(opts) {
          if ("client" in opts) {
            super(opts);
            return;
          }
          super({
            client: new BaseTelegramClient(opts),
            disableUpdates: opts.disableUpdates,
            skipConversationUpdates: opts.skipConversationUpdates,
            updates: opts.updates
          });
        }
      }
      exports("d5", TelegramClient);
      class AppConfigManagerProxy {
        constructor(invoker) {
          __publicField(this, "get");
          __publicField(this, "getField");
          this.invoker = invoker;
          const bind2 = invoker.makeBinder("app-config");
          this.get = bind2("get");
          this.getField = bind2("getField");
        }
      }
      function serializeError(error) {
        if (!(error instanceof Error))
          return { name: "Error", message: String(error) };
        const res = {
          name: "Error",
          message: error.message,
          stack: error.stack
        };
        const ctor = error.constructor;
        if (ctor === MtTypeAssertionError) {
          const _error = error;
          res.name = "MtTypeAssertionError";
          res.custom = {
            context: _error.context,
            expected: _error.expected,
            actual: _error.actual
          };
        } else if (ctor === MtTimeoutError) {
          const _error = error;
          res.name = "MtTimeoutError";
          res.custom = {
            timeout: _error.timeout
          };
        } else if (ctor === MtMessageNotFoundError) {
          const _error = error;
          res.name = "MtMessageNotFoundError";
          res.custom = {
            peerId: _error.peerId,
            messageId: _error.messageId,
            context: _error.context
          };
        } else if (ctor === tl.tl.RpcError) {
          res.name = "RpcError";
          res.custom = __spreadValues({}, error);
        } else if (ctor === MtArgumentError) {
          res.name = "MtArgumentError";
        } else if (ctor === MtSecurityError) {
          res.name = "MtSecurityError";
        } else if (ctor === MtUnsupportedError) {
          res.name = "MtUnsupportedError";
        } else if (ctor === MtPeerNotFoundError) {
          res.name = "MtPeerNotFoundError";
        } else if (ctor === MtInvalidPeerTypeError) {
          res.name = "MtInvalidPeerTypeError";
        } else if (ctor === MtEmptyError) {
          res.name = "MtEmptyError";
        } else if (ctor instanceof MtcuteError) {
          res.name = "MtcuteError";
        }
        return res;
      }
      function deserializeError(error) {
        let err2;
        switch (error.name) {
          case "MtTypeAssertionError": {
            const custom = error.custom;
            err2 = new MtTypeAssertionError(custom.context, custom.expected, custom.actual);
            break;
          }
          case "MtTimeoutError": {
            const custom = error.custom;
            err2 = new MtTimeoutError(custom.timeout);
            break;
          }
          case "MtMessageNotFoundError": {
            const custom = error.custom;
            err2 = new MtMessageNotFoundError(custom.peerId, custom.messageId, custom.context);
            break;
          }
          case "RpcError": {
            const custom = error.custom;
            err2 = new tl.tl.RpcError(custom.code, custom.text);
            err2.message = error.message;
            for(let   key in custom) {
              if (key === "code" || key === "text")
                continue;
              err2[key] = custom[key];
            }
            break;
          }
          case "MtArgumentError":
            err2 = new MtArgumentError();
            break;
          case "MtSecurityError":
            err2 = new MtSecurityError();
            break;
          case "MtUnsupportedError":
            err2 = new MtUnsupportedError();
            break;
          case "MtPeerNotFoundError":
            err2 = new MtPeerNotFoundError();
            break;
          case "MtInvalidPeerTypeError":
            err2 = new MtInvalidPeerTypeError("", "");
            err2.message = error.message;
            break;
          case "MtEmptyError":
            err2 = new MtEmptyError();
            break;
          case "MtcuteError":
            err2 = new MtcuteError();
            break;
          default:
            err2 = new Error(error.message);
        }
        err2.stack = error.stack;
        return err2;
      }
      function serializeResult(result) {
        if (ArrayBuffer.isView(result))
          return result;
        if (Array.isArray(result)) {
          return result.map(serializeResult);
        }
        if (result instanceof Map) {
          for(let   [key, value] of result.entries()) {
            result.set(key, serializeResult(value));
          }
          return result;
        }
        if (result && typeof result === "object") {
          const newResult = {};
          for(let   [key, value] of Object.entries(result)) {
            if (Long.isLong(value)) {
              newResult[key] = {
                __type: "long",
                low: value.low,
                high: value.high,
                unsigned: value.unsigned
              };
            } else if (typeof value === "object") {
              newResult[key] = serializeResult(value);
            } else {
              newResult[key] = value;
            }
          }
          return newResult;
        }
        return result;
      }
      function deserializeResult(result) {
        if (ArrayBuffer.isView(result))
          return result;
        if (Array.isArray(result)) {
          return result.map(deserializeResult);
        }
        if (result instanceof Map) {
          for(let   [key, value] of result.entries()) {
            result.set(key, deserializeResult(value));
          }
          return result;
        }
        if (result && typeof result === "object") {
          for(let   [key, value] of Object.entries(result)) {
            if (value && typeof value === "object" && value.__type === "long") {
              result[key] = Long.fromValue(value);
            } else if (typeof value === "object") {
              result[key] = deserializeResult(value);
            }
          }
        }
        return result;
      }
      class WorkerInvoker {
        constructor(send) {
          __publicField(this, "_nextId", 0);
          __publicField(this, "_pending", /* @__PURE__ */ new Map());
          this.send = send;
        }
        _invoke(target, method, args, isVoid, abortSignal) {
          const id2 = this._nextId++;
          this.send({
            type: "invoke",
            id: id2,
            target,
            method,
            args: serializeResult(args),
            void: isVoid,
            withAbort: Boolean(abortSignal)
          });
          abortSignal == null ? void 0 : abortSignal.addEventListener("abort", () => {
            this.send({
              type: "abort",
              id: id2
            });
          });
          if (!isVoid) {
            const promise = createControllablePromise();
            this._pending.set(id2, promise);
            return promise;
          }
        }
        invoke(target, method, args) {
          return this._invoke(target, method, args, false);
        }
        invokeVoid(target, method, args) {
          this._invoke(target, method, args, true);
        }
        invokeWithAbort(target, method, args, abortSignal) {
          if (abortSignal.aborted)
            return Promise.reject(abortSignal.reason);
          return this._invoke(target, method, args, false, abortSignal);
        }
        handleResult(msg) {
          const promise = this._pending.get(msg.id);
          if (!promise)
            return;
          if (msg.error) {
            promise.reject(deserializeError(msg.error));
          } else {
            promise.resolve(deserializeResult(msg.result));
          }
        }
        makeBinder(target) {
          return (method, isVoid = false) => {
            let fn;
            if (isVoid) {
              fn = (...args) => this.invokeVoid(target, method, args);
            } else {
              fn = (...args) => this.invoke(target, method, args);
            }
            return fn;
          };
        }
      }
      class CurrentUserServiceProxy {
        constructor(invoker) {
          __publicField(this, "_store");
          __publicField(this, "_storeFrom");
          __publicField(this, "_fetch");
          __publicField(this, "_update");
          __publicField(this, "_cached");
          const bind2 = invoker.makeBinder("storage-self");
          this._store = bind2("store");
          this._storeFrom = bind2("storeFrom");
          this._fetch = bind2("fetch");
          this._update = bind2("update");
        }
        store(info) {
          return __async(this, null, function* () {
            yield this._store(info);
            this._cached = info;
          });
        }
        storeFrom(user) {
          return __async(this, null, function* () {
            this._cached = yield this._storeFrom(user);
            return this._cached;
          });
        }
        fetch() {
          return __async(this, null, function* () {
            if (this._cached)
              return this._cached;
            this._cached = yield this._fetch();
            return this._cached;
          });
        }
        getCached(safe) {
          if (this._cached === void 0) {
            if (safe)
              return null;
            throw new MtArgumentError("User info is not cached yet");
          }
          return this._cached;
        }
        update(params) {
          return __async(this, null, function* () {
            yield this._update(params);
            this._cached = yield this._fetch();
          });
        }
      }
      class PeersServiceProxy {
        constructor(_invoker) {
          __publicField(this, "updatePeersFrom");
          __publicField(this, "store");
          __publicField(this, "getById");
          __publicField(this, "getByPhone");
          __publicField(this, "getByUsername");
          __publicField(this, "getCompleteById");
          this._invoker = _invoker;
          const bind2 = this._invoker.makeBinder("storage-peers");
          this.updatePeersFrom = bind2("updatePeersFrom");
          this.store = bind2("store");
          this.getById = bind2("getById");
          this.getByPhone = bind2("getByPhone");
          this.getByUsername = bind2("getByUsername");
          this.getCompleteById = bind2("getCompleteById");
        }
      }
      class TelegramStorageProxy {
        constructor(_invoker) {
          __publicField(this, "self");
          __publicField(this, "peers");
          __publicField(this, "clear");
          // todo - remove once we move these to updates manager
          __publicField(this, "updates", null);
          __publicField(this, "refMsgs", null);
          this._invoker = _invoker;
          const bind2 = this._invoker.makeBinder("storage");
          this.self = new CurrentUserServiceProxy(this._invoker);
          this.peers = new PeersServiceProxy(this._invoker);
          this.clear = bind2("clear");
        }
      }
      let TelegramWorkerPort$1 = class TelegramWorkerPort {
        constructor(options2) {
          __publicField(this, "log");
          __publicField(this, "_connection");
          __publicField(this, "_invoker");
          __publicField(this, "storage");
          __publicField(this, "appConfig");
          // bound methods
          __publicField(this, "prepare");
          __publicField(this, "_connect");
          __publicField(this, "close");
          __publicField(this, "notifyLoggedIn");
          __publicField(this, "notifyLoggedOut");
          __publicField(this, "notifyChannelOpened");
          __publicField(this, "notifyChannelClosed");
          __publicField(this, "importSession");
          __publicField(this, "exportSession");
          __publicField(this, "handleClientUpdate");
          __publicField(this, "getApiCrenetials");
          __publicField(this, "getPoolSize");
          __publicField(this, "getPrimaryDcId");
          __publicField(this, "changePrimaryDc");
          __publicField(this, "computeSrpParams");
          __publicField(this, "computeNewPasswordHash");
          __publicField(this, "startUpdatesLoop");
          __publicField(this, "stopUpdatesLoop");
          __publicField(this, "getMtprotoMessageId");
          __publicField(this, "_abortController", new AbortController());
          __publicField(this, "stopSignal", this._abortController.signal);
          __publicField(this, "_serverUpdatesHandler", () => {
          });
          __publicField(this, "_errorHandler", () => {
          });
          __publicField(this, "_updateHandler", () => {
          });
          __publicField(this, "_connectionStateHandler", () => {
          });
          __publicField(this, "_onMessage", (message2) => {
            switch (message2.type) {
              case "log":
                this.log.handler(message2.color, message2.level, message2.tag, message2.fmt, message2.args);
                break;
              case "server_update":
                this._serverUpdatesHandler(deserializeResult(message2.update));
                break;
              case "conn_state":
                this._connectionStateHandler(message2.state);
                break;
              case "update": {
                const peers = new PeersIndex(deserializeResult(message2.users), deserializeResult(message2.chats));
                peers.hasMin = message2.hasMin;
                this._updateHandler(deserializeResult(message2.update), peers);
                break;
              }
              case "result":
                this._invoker.handleResult(message2);
                break;
              case "error":
                this.emitError(message2.error);
                break;
              case "stop":
                this._abortController.abort();
                break;
            }
          });
          __publicField(this, "_destroyed", false);
          this.options = options2;
          this.log = new LogManager("worker");
          this._connection = this.connectToWorker(this.options.worker, this._onMessage);
          this._invoker = new WorkerInvoker(this._connection[0]);
          this.storage = new TelegramStorageProxy(this._invoker);
          this.appConfig = new AppConfigManagerProxy(this._invoker);
          const bind2 = this._invoker.makeBinder("client");
          this.prepare = bind2("prepare");
          this._connect = bind2("connect");
          this.close = bind2("close");
          this.notifyLoggedIn = bind2("notifyLoggedIn");
          this.notifyLoggedOut = bind2("notifyLoggedOut");
          this.notifyChannelOpened = bind2("notifyChannelOpened");
          this.notifyChannelClosed = bind2("notifyChannelClosed");
          this.importSession = bind2("importSession");
          this.exportSession = bind2("exportSession");
          this.handleClientUpdate = bind2("handleClientUpdate", true);
          this.getApiCrenetials = bind2("getApiCrenetials");
          this.getPoolSize = bind2("getPoolSize");
          this.getPrimaryDcId = bind2("getPrimaryDcId");
          this.changePrimaryDc = bind2("changePrimaryDc");
          this.computeSrpParams = bind2("computeSrpParams");
          this.computeNewPasswordHash = bind2("computeNewPasswordHash");
          this.startUpdatesLoop = bind2("startUpdatesLoop");
          this.stopUpdatesLoop = bind2("stopUpdatesLoop");
          this.getMtprotoMessageId = bind2("getMtprotoMessageId");
        }
        call(message2, params) {
          if (params == null ? void 0 : params.abortSignal) {
            const _a3 = params, { abortSignal } = _a3, rest = __objRest(_a3, ["abortSignal"]);
            return this._invoker.invokeWithAbort("client", "call", [message2, rest], abortSignal);
          }
          return this._invoker.invoke("client", "call", [message2, params]);
        }
        onServerUpdate(handler) {
          this._serverUpdatesHandler = handler;
        }
        getServerUpdateHandler() {
          return this._serverUpdatesHandler;
        }
        onError(handler) {
          this._errorHandler = handler;
        }
        emitError(err) {
          this._errorHandler(err);
        }
        onUpdate(handler) {
          this._updateHandler = handler;
        }
        onConnectionState(handler) {
          this._connectionStateHandler = handler;
        }
        destroy(terminate = false) {
          if (this._destroyed)
            return;
          this._connection[1]();
          this._destroyed = true;
          if (terminate && "terminate" in this.options.worker) {
            Promise.resolve(this.options.worker.terminate()).catch(() => {
            });
          }
        }
        invokeCustom(method, ...args) {
          return this._invoker.invoke("custom", method, args);
        }
        connect() {
          return __async(this, null, function* () {
            yield this._connect();
            yield this.storage.self.fetch();
          });
        }
      };
      let TelegramWorker$1 = class TelegramWorker {
        constructor(params) {
          __publicField(this, "client");
          __publicField(this, "broadcast");
          __publicField(this, "pendingAborts", /* @__PURE__ */ new Map());
          this.params = params;
          this.broadcast = this.registerWorker((message2, respond) => {
            switch (message2.type) {
              case "invoke":
                this.onInvoke(message2, respond);
                break;
              case "abort": {
                const abort = this.pendingAborts.get(message2.id);
                if (abort) {
                  abort.abort();
                  this.pendingAborts.delete(message2.id);
                }
              }
            }
          });
          const client2 = params.client;
          this.client = client2;
          client2.log.mgr.handler = (color2, level, tag, fmt, args) => this.broadcast({
            type: "log",
            color: color2,
            level,
            tag,
            fmt,
            args
          });
          client2.onError(
            (err) => this.broadcast({
              type: "error",
              error: err
            })
          );
          client2.onConnectionState(
            (state) => this.broadcast({
              type: "conn_state",
              state
            })
          );
          client2.stopSignal.addEventListener("abort", () => this.broadcast({ type: "stop" }));
          if (client2.updates) {
            client2.onUpdate(
              (update, peers) => this.broadcast({
                type: "update",
                update: serializeResult(update),
                users: serializeResult(peers.users),
                chats: serializeResult(peers.chats),
                hasMin: peers.hasMin
              })
            );
          } else {
            client2.onServerUpdate(
              (update) => this.broadcast({
                type: "server_update",
                update: serializeResult(update)
              })
            );
          }
        }
        onInvoke(msg, respond) {
          let target;
          switch (msg.target) {
            case "custom":
              target = this.params.customMethods;
              break;
            case "client":
              target = this.client;
              break;
            case "storage":
              target = this.client.storage;
              break;
            case "storage-self":
              target = this.client.storage.self;
              break;
            case "storage-peers":
              target = this.client.storage.peers;
              break;
            case "app-config":
              target = this.client.appConfig;
              break;
            default: {
              respond({
                type: "result",
                id: msg.id,
                error: new Error(`Unknown target ${msg.target}`)
              });
              return;
            }
          }
          const method = target[msg.method];
          if (!method) {
            respond({
              type: "result",
              id: msg.id,
              error: new Error(`Method ${msg.method} not found on ${msg.target}`)
            });
            return;
          }
          let args;
          if (msg.target === "client" && msg.method === "call" && msg.withAbort) {
            const abort = new AbortController();
            this.pendingAborts.set(msg.id, abort);
            args = [
              deserializeResult(msg.args[0]),
              __spreadProps(__spreadValues({}, msg.args[1]), {
                abortSignal: abort.signal
              })
            ];
          } else {
            args = deserializeResult(msg.args);
          }
          Promise.resolve(method.apply(target, args)).then((res) => {
            if (msg.withAbort) {
              this.pendingAborts.delete(msg.id);
            }
            if (msg.void)
              return;
            respond({
              type: "result",
              id: msg.id,
              result: serializeResult(res)
            });
          }).catch((err) => {
            if (msg.withAbort) {
              this.pendingAborts.delete(msg.id);
            }
            respond({
              type: "result",
              id: msg.id,
              error: serializeError(err)
            });
          });
        }
      };
      let _registered = false;
      class TelegramWorker extends TelegramWorker$1 {
        registerWorker(handler) {
          if (_registered) {
            throw new Error("TelegramWorker must be created only once");
          }
          _registered = true;
          if (typeof SharedWorkerGlobalScope !== "undefined" && self instanceof SharedWorkerGlobalScope) {
            const connections = [];
            const broadcast = (message2) => {
              for(let   port2 of connections) {
                port2.postMessage(message2);
              }
            };
            self.onconnect = (event) => {
              const port2 = event.ports[0];
              connections.push(port2);
              const respond = port2.postMessage.bind(port2);
              const onClose = () => {
                port2.close();
                const idx = connections.indexOf(port2);
                if (idx >= 0) {
                  connections.splice(connections.indexOf(port2), 1);
                }
              };
              const onTimeout = () => {
                console.warn("some connection timed out!");
                respond({ __type__: "timeout" });
                onClose();
              };
              let timeout = setTimeout(onTimeout, 6e4);
              port2.addEventListener("message", (message2) => {
                if (message2.data.__type__ === "close") {
                  onClose();
                  return;
                }
                if (message2.data.__type__ === "ping") {
                  clearTimeout(timeout);
                  timeout = setTimeout(onTimeout, 6e4);
                  return;
                }
                handler(message2.data, respond);
              });
              port2.start();
            };
            return broadcast;
          }
          if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
            const respond = self.postMessage.bind(self);
            self.addEventListener("message", (message2) => handler(message2.data, respond));
            return respond;
          }
          throw new Error("TelegramWorker must be created from a worker");
        }
      }
      exports("d7", TelegramWorker);
      const platform = new WebPlatform();
      class TelegramWorkerPort extends TelegramWorkerPort$1 {
        constructor(options2) {
          setPlatform(platform);
          super(options2);
          this.options = options2;
        }
        connectToWorker(worker2, handler) {
          if (worker2 instanceof Worker) {
            const send = worker2.postMessage.bind(worker2);
            const messageHandler = (ev) => {
              handler(ev.data);
            };
            worker2.addEventListener("message", messageHandler);
            return [
              send,
              () => {
                worker2.removeEventListener("message", messageHandler);
              }
            ];
          }
          if (worker2 instanceof SharedWorker) {
            const send = worker2.port.postMessage.bind(worker2.port);
            const pingInterval = setInterval(() => {
              worker2.port.postMessage({ __type__: "ping" });
            }, 1e4);
            const messageHandler = (ev) => {
              if (ev.data.__type__ === "timeout") {
                location.reload();
                return;
              }
              handler(ev.data);
            };
            worker2.port.addEventListener("message", messageHandler);
            worker2.port.start();
            let cancelBeforeExit;
            const close = () => {
              clearInterval(pingInterval);
              worker2.port.postMessage({ __type__: "close" });
              worker2.port.removeEventListener("message", messageHandler);
              worker2.port.close();
              cancelBeforeExit();
            };
            cancelBeforeExit = platform.beforeExit(close);
            return [send, close];
          }
          throw new Error("Only workers and shared workers are supported");
        }
      }
      exports("d8", TelegramWorkerPort);
      /**
       * @license
       * Copyright 2019 Google LLC
       * SPDX-License-Identifier: Apache-2.0
       */
      const proxyMarker = Symbol("Comlink.proxy");
      const createEndpoint = Symbol("Comlink.endpoint");
      const releaseProxy = Symbol("Comlink.releaseProxy");
      const finalizer = Symbol("Comlink.finalizer");
      const throwMarker = Symbol("Comlink.thrown");
      const isObject$1 = (val) => typeof val === "object" && val !== null || typeof val === "function";
      const proxyTransferHandler = {
        canHandle: (val) => isObject$1(val) && val[proxyMarker],
        serialize(obj) {
          const { port1, port2 } = new MessageChannel();
          expose(obj, port1);
          return [port2, [port2]];
        },
        deserialize(port2) {
          port2.start();
          return wrap$4(port2);
        }
      };
      const throwTransferHandler = {
        canHandle: (value) => isObject$1(value) && throwMarker in value,
        serialize({ value }) {
          let serialized;
          if (value instanceof Error) {
            serialized = {
              isError: true,
              value: {
                message: value.message,
                name: value.name,
                stack: value.stack
              }
            };
          } else {
            serialized = { isError: false, value };
          }
          return [serialized, []];
        },
        deserialize(serialized) {
          if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
          }
          throw serialized.value;
        }
      };
      const transferHandlers = /* @__PURE__ */ new Map([
        ["proxy", proxyTransferHandler],
        ["throw", throwTransferHandler]
      ]);
      function isAllowedOrigin(allowedOrigins, origin) {
        for(let   allowedOrigin of allowedOrigins) {
          if (origin === allowedOrigin || allowedOrigin === "*") {
            return true;
          }
          if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
            return true;
          }
        }
        return false;
      }
      function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
        ep.addEventListener("message", function callback2(ev) {
          if (!ev || !ev.data) {
            return;
          }
          if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
            return;
          }
          const { id: id2, type, path: path2 } = Object.assign({ path: [] }, ev.data);
          const argumentList = (ev.data.argumentList || []).map(fromWireValue);
          let returnValue;
          try {
            const parent = path2.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
            const rawValue = path2.reduce((obj2, prop) => obj2[prop], obj);
            switch (type) {
              case "GET":
                {
                  returnValue = rawValue;
                }
                break;
              case "SET":
                {
                  parent[path2.slice(-1)[0]] = fromWireValue(ev.data.value);
                  returnValue = true;
                }
                break;
              case "APPLY":
                {
                  returnValue = rawValue.apply(parent, argumentList);
                }
                break;
              case "CONSTRUCT":
                {
                  const value = new rawValue(...argumentList);
                  returnValue = proxy(value);
                }
                break;
              case "ENDPOINT":
                {
                  const { port1, port2 } = new MessageChannel();
                  expose(obj, port2);
                  returnValue = transfer(port1, [port1]);
                }
                break;
              case "RELEASE":
                {
                  returnValue = void 0;
                }
                break;
              default:
                return;
            }
          } catch (value) {
            returnValue = { value, [throwMarker]: 0 };
          }
          Promise.resolve(returnValue).catch((value) => {
            return { value, [throwMarker]: 0 };
          }).then((returnValue2) => {
            const [wireValue, transferables] = toWireValue(returnValue2);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
            if (type === "RELEASE") {
              ep.removeEventListener("message", callback2);
              closeEndPoint(ep);
              if (finalizer in obj && typeof obj[finalizer] === "function") {
                obj[finalizer]();
              }
            }
          }).catch((error) => {
            const [wireValue, transferables] = toWireValue({
              value: new TypeError("Unserializable return value"),
              [throwMarker]: 0
            });
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
          });
        });
        if (ep.start) {
          ep.start();
        }
      }
      function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
      }
      function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint))
          endpoint.close();
      }
      function wrap$4(ep, target) {
        const pendingListeners = /* @__PURE__ */ new Map();
        ep.addEventListener("message", function handleMessage(ev) {
          const { data: data2 } = ev;
          if (!data2 || !data2.id) {
            return;
          }
          const resolver = pendingListeners.get(data2.id);
          if (!resolver) {
            return;
          }
          try {
            resolver(data2);
          } finally {
            pendingListeners.delete(data2.id);
          }
        });
        return createProxy(ep, pendingListeners, [], target);
      }
      function throwIfProxyReleased(isReleased) {
        if (isReleased) {
          throw new Error("Proxy has been released and is not useable");
        }
      }
      function releaseEndpoint(ep) {
        return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
          type: "RELEASE"
        }).then(() => {
          closeEndPoint(ep);
        });
      }
      const proxyCounter = /* @__PURE__ */ new WeakMap();
      const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
          releaseEndpoint(ep);
        }
      });
      function registerProxy(proxy2, ep) {
        const newCount = (proxyCounter.get(ep) || 0) + 1;
        proxyCounter.set(ep, newCount);
        if (proxyFinalizers) {
          proxyFinalizers.register(proxy2, ep, proxy2);
        }
      }
      function unregisterProxy(proxy2) {
        if (proxyFinalizers) {
          proxyFinalizers.unregister(proxy2);
        }
      }
      function createProxy(ep, pendingListeners, path2 = [], target = function() {
      }) {
        let isProxyReleased = false;
        const proxy2 = new Proxy(target, {
          get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
              return () => {
                unregisterProxy(proxy2);
                releaseEndpoint(ep);
                pendingListeners.clear();
                isProxyReleased = true;
              };
            }
            if (prop === "then") {
              if (path2.length === 0) {
                return { then: () => proxy2 };
              }
              const r2 = requestResponseMessage(ep, pendingListeners, {
                type: "GET",
                path: path2.map((p) => p.toString())
              }).then(fromWireValue);
              return r2.then.bind(r2);
            }
            return createProxy(ep, pendingListeners, [...path2, prop]);
          },
          set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, pendingListeners, {
              type: "SET",
              path: [...path2, prop].map((p) => p.toString()),
              value
            }, transferables).then(fromWireValue);
          },
          apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last2 = path2[path2.length - 1];
            if (last2 === createEndpoint) {
              return requestResponseMessage(ep, pendingListeners, {
                type: "ENDPOINT"
              }).then(fromWireValue);
            }
            if (last2 === "bind") {
              return createProxy(ep, pendingListeners, path2.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, pendingListeners, {
              type: "APPLY",
              path: path2.map((p) => p.toString()),
              argumentList
            }, transferables).then(fromWireValue);
          },
          construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, pendingListeners, {
              type: "CONSTRUCT",
              path: path2.map((p) => p.toString()),
              argumentList
            }, transferables).then(fromWireValue);
          }
        });
        registerProxy(proxy2, ep);
        return proxy2;
      }
      function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
      }
      function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
      }
      const transferCache = /* @__PURE__ */ new WeakMap();
      function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
      }
      function proxy(obj) {
        return Object.assign(obj, { [proxyMarker]: true });
      }
      function toWireValue(value) {
        for(let   [name2, handler] of transferHandlers) {
          if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
              {
                type: "HANDLER",
                name: name2,
                value: serializedValue
              },
              transferables
            ];
          }
        }
        return [
          {
            type: "RAW",
            value
          },
          transferCache.get(value) || []
        ];
      }
      function fromWireValue(value) {
        switch (value.type) {
          case "HANDLER":
            return transferHandlers.get(value.name).deserialize(value.value);
          case "RAW":
            return value.value;
        }
      }
      function requestResponseMessage(ep, pendingListeners, msg, transfers) {
        return new Promise((resolve) => {
          const id2 = generateUUID();
          pendingListeners.set(id2, resolve);
          if (ep.start) {
            ep.start();
          }
          ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
        });
      }
      function generateUUID() {
        return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
      }
      const TelegramWorkerURL = "/assets/worker-CjUOtZZB.js";
      const apiId = 25792998;
      const apiHash = "b3aed8b5d53685566b35d325a67d575c";
      let client_not_ready = null;
      const clientInit = new Deferred();
      const EE$2 = new EventEmitter();
      const worker = new Worker(TelegramWorkerURL + location.hash, {
        type: "module"
      });
      const port = new TelegramWorkerPort({
        worker
      });
      const wrapped$2 = wrap$4(worker);
      const gunzip = wrapped$2.gunzip;
      const gzip = wrapped$2.gzip;
      const webp = wrapped$2.webp;
      wrapped$2.getAvailableMemory;
      function onLogout() {
        return __async(this, null, function* () {
          if (!sessionStorage.loggedIn)
            return;
          sessionStorage.removeItem("loggedIn");
          yield toaster("You got logged out!");
          yield sleep$1(10);
        });
      }
      wrapped$2.setLogoutCallback(proxy(onLogout));
      let abortQr = null;
      let App$1 = class App {
        constructor() {
          __publicField(this, "_countriesCache", null);
        }
        startSession(onLogin, phoneNumber, password, phoneCode, qrCode2, onError2, onLoginError) {
          return __async(this, null, function* () {
            var _a3;
            this.getCountries();
            (_a3 = navigator.requestWakeLock) == null ? void 0 : _a3.call(navigator, "cpu");
            const tg = new TelegramClient({
              apiId,
              apiHash,
              client: port
            });
            Object.assign(window, { tg });
            function checkSignedIn() {
              return __async(this, null, function* () {
                return yield tg.getMe().then((user) => {
                  tg.notifyLoggedIn(user.raw);
                  tg.startUpdatesLoop();
                  return user;
                }).catch(() => null);
              });
            }
            let lastStep = 0;
            function sendCode2() {
              return __async(this, null, function* () {
                console.log("step 1 sendCode");
                yield tg.connect();
                const phone = yield phoneNumber();
                lastStep = 1;
                tg.sendCode({ phone }).then(({ phoneCodeHash }) => {
                  verifyCode(phoneCodeHash, phone);
                }).catch((e2) => {
                  onLoginError(1, e2.code || 0, e2.message);
                  sendCode2();
                });
              });
            }
            function verifyCode(phoneCodeHash, phone) {
              return __async(this, null, function* () {
                console.log("step 2 verifyCode");
                lastStep = 2;
                yield tg.connect();
                tg.signIn({
                  phone,
                  phoneCodeHash,
                  phoneCode: yield phoneCode()
                }).then((user) => {
                  console.log("login ended at step 2!!");
                  lastStep = 0;
                  tg.notifyLoggedIn(user.raw);
                  tg.startUpdatesLoop();
                  onLogin(tg);
                }).catch((e2) => __async(this, null, function* () {
                  if (tl.tl.RpcError.is(e2, "SESSION_PASSWORD_NEEDED")) {
                    signInPassword();
                    return;
                  }
                  if (tl.tl.RpcError.is(e2, "PHONE_CODE_INVALID")) {
                    verifyCode(phoneCodeHash, phone);
                  }
                  if (tl.tl.RpcError.is(e2, "PHONE_CODE_EXPIRED")) {
                    yield tg.resendCode({
                      phone,
                      phoneCodeHash
                    });
                    verifyCode(phoneCodeHash, phone);
                  }
                  onLoginError(2, e2 && e2.code || 0, e2 && e2.text || e2.message);
                }));
              });
            }
            function signInPassword() {
              return __async(this, null, function* () {
                console.log("step 3 password");
                lastStep = 3;
                yield tg.connect();
                if (yield checkSignedIn()) {
                  lastStep = 0;
                  console.log("already authorized skipping 2fa");
                  onLogin(tg);
                  return;
                }
                tg.checkPassword(yield password()).then((user) => {
                  lastStep = 0;
                  console.log("login ended at step 3");
                  tg.notifyLoggedIn(user.raw);
                  tg.startUpdatesLoop();
                  onLogin(tg);
                }).catch((e2) => {
                  if (tl.tl.RpcError.is(e2, "PASSWORD_HASH_INVALID")) {
                    onLoginError(3, e2.code || 0, e2.text || e2.message);
                  } else {
                    onLoginError(3, e2 && e2.code || 0, e2 && (e2.text || e2.message));
                    console.error(e2);
                    phoneNumber();
                  }
                });
              });
            }
            tg.onError(function(err) {
              return __async(this, null, function* () {
                onError2(err && err.message);
                if (lastStep !== 0) {
                  onLoginError(lastStep, err && (err.code || 0), err && (err.errorMessage || err.message));
                }
              });
            });
            tg.onConnectionState(console.error.bind(console));
            yield tg.connect();
            client_not_ready = tg;
            EE$2.once("qr", function qr() {
              console.log("QR login has started");
              tg.signInQr({
                password: () => {
                  qrCode2(null);
                  return password();
                },
                invalidPasswordCallback: () => {
                  qrCode2(null);
                  onLoginError(3, 333, "INVALID PASSWORD");
                },
                onQrScanned() {
                  qrCode2(null);
                },
                onUrlUpdated(url2, expires) {
                  qrCode2(url2);
                }
                // abortSignal: signal,
              }).then((user) => {
                qrCode2(null);
                console.log("login via qr success");
                abortQr = null;
                tg.notifyLoggedIn(user.raw);
                tg.startUpdatesLoop();
                onLogin(tg);
              }).catch((e2) => {
                qrCode2(null);
                EE$2.once("qr", qr);
                if (e2 instanceof Error && e2.name == "AbortError") {
                  console.log("QR was aborted");
                  return;
                }
                console.error(e2);
                alert("something went wrong with the qr login, you might need to scan again");
              });
            });
            clientInit.resolve();
            Object.assign(self, { tg });
            if (yield checkSignedIn()) {
              console.log("authorized already!");
              onLogin(tg);
            } else {
              console.log("start login process");
              sendCode2();
            }
          });
        }
        _getCountries() {
          return __async(this, null, function* () {
            yield clientInit.promise;
            if (!client_not_ready)
              return null;
            const result = yield client_not_ready.call({
              _: "help.getCountriesList",
              langCode: "en-US",
              hash: 0
            });
            return "countries" in result ? result.countries.sort((a, b) => a.defaultName.localeCompare(b.defaultName)).map((a, i) => ({
              name: a.defaultName,
              code: a.iso2,
              dial_code: "+" + a.countryCodes[0].countryCode,
              flag: "?",
              id: i
            })) : null;
          });
        }
        getCountries() {
          return this._countriesCache || (this._countriesCache = this._getCountries());
        }
        getNearestDC() {
          return __async(this, null, function* () {
            yield clientInit.promise;
            if (!client_not_ready)
              return null;
            const countries = yield this.getCountries();
            const nearest = yield client_not_ready.call({
              _: "help.getNearestDc"
            });
            const code2 = nearest.country;
            const found = countries == null ? void 0 : countries.find((a) => a.code == code2);
            if (found) {
              return found;
            }
            return {
              name: "?",
              flag: "?",
              code: code2,
              dial_code: "?",
              id: NaN
            };
          });
        }
        requestQR() {
          return __async(this, null, function* () {
            yield clientInit.promise;
            EE$2.emit("qr");
          });
        }
        abortQR() {
          return __async(this, null, function* () {
            abortQr == null ? void 0 : abortQr.abort();
          });
        }
      };
      const telegram = new App$1();
      Object.assign(self, { telegram, _tg: wrapped$2 });
      const KaiAdsUrl = "/assets/kaiads.v5.min-BqG-f2sM.js";
      var freeGlobal = exports("dT", typeof global == "object" && global && global.Object === Object && global);
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = exports("dP", freeGlobal || freeSelf || Function("return this")());
      var Symbol$1 = exports("d$", root.Symbol);
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$4.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$3.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$3 = Object.prototype;
      var nativeObjectToString = objectProto$3.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$1 = Function.prototype;
      var funcToString$1 = funcProto$1.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$1.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype, objectProto$2 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count2 = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count2 >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count2 = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      var setToString = shortOut(baseSetToString);
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + -1;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start2, transform) {
        start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start2, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start2 + index];
          }
          index = -1;
          var otherArgs = Array(start2 + 1);
          while (++index < start2) {
            otherArgs[index] = args[index];
          }
          otherArgs[start2] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result = data2[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$1.call(data2, key) ? data2[key] : void 0;
      }
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        return index < 0 ? void 0 : data2[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = exports("dW", getNative(root, "Map"));
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data2 = map2.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size2 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options2)) {
          leading = !!options2.leading;
          maxing = "maxWait" in options2;
          maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time2;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time2) : result;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time2 = now(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      var LARGE_ARRAY_SIZE = 200;
      function baseDifference(array, values2, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values2.length;
        if (!length) {
          return result;
        }
        if (values2.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = value;
            value = value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (!includes(values2, computed, comparator)) {
              result.push(value);
            }
          }
        return result;
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var dayjs_min = { exports: {} };
      (function(module2, exports2) {
        !function(t2, e2) {
          module2.exports = e2();
        }(commonjsGlobal, function() {
          var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o2 = "week", c = "month", f = "quarter", h2 = "year", d = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
            var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
            return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
          } }, m2 = function(t3, e3, n3) {
            var r3 = String(t3);
            return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
          }, v = { s: m2, z: function(t3) {
            var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
            return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
          }, m: function t3(e3, n3) {
            if (e3.date() < n3.date())
              return -t3(n3, e3);
            var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c), s2 = n3 - i2 < 0, u2 = e3.clone().add(r3 + (s2 ? -1 : 1), c);
            return +(-(r3 + (n3 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
          }, a: function(t3) {
            return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
          }, p: function(t3) {
            return { M: c, y: h2, w: o2, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
          }, u: function(t3) {
            return void 0 === t3;
          } }, g = "en", D = {};
          D[g] = M;
          var p = "$isDayjsObject", S = function(t3) {
            return t3 instanceof _ || !(!t3 || !t3[p]);
          }, w = function t3(e3, n3, r3) {
            var i2;
            if (!e3)
              return g;
            if ("string" == typeof e3) {
              var s2 = e3.toLowerCase();
              D[s2] && (i2 = s2), n3 && (D[s2] = n3, i2 = s2);
              var u2 = e3.split("-");
              if (!i2 && u2.length > 1)
                return t3(u2[0]);
            } else {
              var a2 = e3.name;
              D[a2] = e3, i2 = a2;
            }
            return !r3 && i2 && (g = i2), i2 || !r3 && g;
          }, O = function(t3, e3) {
            if (S(t3))
              return t3.clone();
            var n3 = "object" == typeof e3 ? e3 : {};
            return n3.date = t3, n3.args = arguments, new _(n3);
          }, b = v;
          b.l = w, b.i = S, b.w = function(t3, e3) {
            return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
          };
          var _ = function() {
            function M2(t3) {
              this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
            }
            var m3 = M2.prototype;
            return m3.parse = function(t3) {
              this.$d = function(t4) {
                var e3 = t4.date, n3 = t4.utc;
                if (null === e3)
                  return /* @__PURE__ */ new Date(NaN);
                if (b.u(e3))
                  return /* @__PURE__ */ new Date();
                if (e3 instanceof Date)
                  return new Date(e3);
                if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                  var r3 = e3.match($2);
                  if (r3) {
                    var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                    return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                  }
                }
                return new Date(e3);
              }(t3), this.init();
            }, m3.init = function() {
              var t3 = this.$d;
              this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
            }, m3.$utils = function() {
              return b;
            }, m3.isValid = function() {
              return !(this.$d.toString() === l2);
            }, m3.isSame = function(t3, e3) {
              var n3 = O(t3);
              return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
            }, m3.isAfter = function(t3, e3) {
              return O(t3) < this.startOf(e3);
            }, m3.isBefore = function(t3, e3) {
              return this.endOf(e3) < O(t3);
            }, m3.$g = function(t3, e3, n3) {
              return b.u(t3) ? this[e3] : this.set(n3, t3);
            }, m3.unix = function() {
              return Math.floor(this.valueOf() / 1e3);
            }, m3.valueOf = function() {
              return this.$d.getTime();
            }, m3.startOf = function(t3, e3) {
              var n3 = this, r3 = !!b.u(e3) || e3, f2 = b.p(t3), l3 = function(t4, e4) {
                var i2 = b.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
                return r3 ? i2 : i2.endOf(a);
              }, $3 = function(t4, e4) {
                return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
              }, y2 = this.$W, M3 = this.$M, m4 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
              switch (f2) {
                case h2:
                  return r3 ? l3(1, 0) : l3(31, 11);
                case c:
                  return r3 ? l3(1, M3) : l3(0, M3 + 1);
                case o2:
                  var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                  return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
                case a:
                case d:
                  return $3(v2 + "Hours", 0);
                case u:
                  return $3(v2 + "Minutes", 1);
                case s:
                  return $3(v2 + "Seconds", 2);
                case i:
                  return $3(v2 + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }, m3.endOf = function(t3) {
              return this.startOf(t3, false);
            }, m3.$set = function(t3, e3) {
              var n3, o3 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f2 + "Date", n3[d] = f2 + "Date", n3[c] = f2 + "Month", n3[h2] = f2 + "FullYear", n3[u] = f2 + "Hours", n3[s] = f2 + "Minutes", n3[i] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o3], $3 = o3 === a ? this.$D + (e3 - this.$W) : e3;
              if (o3 === c || o3 === h2) {
                var y2 = this.clone().set(d, 1);
                y2.$d[l3]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
              } else
                l3 && this.$d[l3]($3);
              return this.init(), this;
            }, m3.set = function(t3, e3) {
              return this.clone().$set(t3, e3);
            }, m3.get = function(t3) {
              return this[b.p(t3)]();
            }, m3.add = function(r3, f2) {
              var d2, l3 = this;
              r3 = Number(r3);
              var $3 = b.p(f2), y2 = function(t3) {
                var e3 = O(l3);
                return b.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
              };
              if ($3 === c)
                return this.set(c, this.$M + r3);
              if ($3 === h2)
                return this.set(h2, this.$y + r3);
              if ($3 === a)
                return y2(1);
              if ($3 === o2)
                return y2(7);
              var M3 = (d2 = {}, d2[s] = e2, d2[u] = n2, d2[i] = t2, d2)[$3] || 1, m4 = this.$d.getTime() + r3 * M3;
              return b.w(m4, this);
            }, m3.subtract = function(t3, e3) {
              return this.add(-1 * t3, e3);
            }, m3.format = function(t3) {
              var e3 = this, n3 = this.$locale();
              if (!this.isValid())
                return n3.invalidDate || l2;
              var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o3 = n3.weekdays, c2 = n3.months, f2 = n3.meridiem, h3 = function(t4, n4, i3, s3) {
                return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s3);
              }, d2 = function(t4) {
                return b.s(s2 % 12 || 12, t4, "0");
              }, $3 = f2 || function(t4, e4, n4) {
                var r4 = t4 < 12 ? "AM" : "PM";
                return n4 ? r4.toLowerCase() : r4;
              };
              return r3.replace(y, function(t4, r4) {
                return r4 || function(t5) {
                  switch (t5) {
                    case "YY":
                      return String(e3.$y).slice(-2);
                    case "YYYY":
                      return b.s(e3.$y, 4, "0");
                    case "M":
                      return a2 + 1;
                    case "MM":
                      return b.s(a2 + 1, 2, "0");
                    case "MMM":
                      return h3(n3.monthsShort, a2, c2, 3);
                    case "MMMM":
                      return h3(c2, a2);
                    case "D":
                      return e3.$D;
                    case "DD":
                      return b.s(e3.$D, 2, "0");
                    case "d":
                      return String(e3.$W);
                    case "dd":
                      return h3(n3.weekdaysMin, e3.$W, o3, 2);
                    case "ddd":
                      return h3(n3.weekdaysShort, e3.$W, o3, 3);
                    case "dddd":
                      return o3[e3.$W];
                    case "H":
                      return String(s2);
                    case "HH":
                      return b.s(s2, 2, "0");
                    case "h":
                      return d2(1);
                    case "hh":
                      return d2(2);
                    case "a":
                      return $3(s2, u2, true);
                    case "A":
                      return $3(s2, u2, false);
                    case "m":
                      return String(u2);
                    case "mm":
                      return b.s(u2, 2, "0");
                    case "s":
                      return String(e3.$s);
                    case "ss":
                      return b.s(e3.$s, 2, "0");
                    case "SSS":
                      return b.s(e3.$ms, 3, "0");
                    case "Z":
                      return i2;
                  }
                  return null;
                }(t4) || i2.replace(":", "");
              });
            }, m3.utcOffset = function() {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, m3.diff = function(r3, d2, l3) {
              var $3, y2 = this, M3 = b.p(d2), m4 = O(r3), v2 = (m4.utcOffset() - this.utcOffset()) * e2, g2 = this - m4, D2 = function() {
                return b.m(y2, m4);
              };
              switch (M3) {
                case h2:
                  $3 = D2() / 12;
                  break;
                case c:
                  $3 = D2();
                  break;
                case f:
                  $3 = D2() / 3;
                  break;
                case o2:
                  $3 = (g2 - v2) / 6048e5;
                  break;
                case a:
                  $3 = (g2 - v2) / 864e5;
                  break;
                case u:
                  $3 = g2 / n2;
                  break;
                case s:
                  $3 = g2 / e2;
                  break;
                case i:
                  $3 = g2 / t2;
                  break;
                default:
                  $3 = g2;
              }
              return l3 ? $3 : b.a($3);
            }, m3.daysInMonth = function() {
              return this.endOf(c).$D;
            }, m3.$locale = function() {
              return D[this.$L];
            }, m3.locale = function(t3, e3) {
              if (!t3)
                return this.$L;
              var n3 = this.clone(), r3 = w(t3, e3, true);
              return r3 && (n3.$L = r3), n3;
            }, m3.clone = function() {
              return b.w(this.$d, this);
            }, m3.toDate = function() {
              return new Date(this.valueOf());
            }, m3.toJSON = function() {
              return this.isValid() ? this.toISOString() : null;
            }, m3.toISOString = function() {
              return this.$d.toISOString();
            }, m3.toString = function() {
              return this.$d.toUTCString();
            }, M2;
          }(), k = _.prototype;
          return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t3) {
            k[t3[1]] = function(e3) {
              return this.$g(e3, t3[0], t3[1]);
            };
          }), O.extend = function(t3, e3) {
            return t3.$i || (t3(e3, _, O), t3.$i = true), O;
          }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
            return O(1e3 * t3);
          }, O.en = D[g], O.Ls = D, O.p = {}, O;
        });
      })(dayjs_min);
      var dayjs_minExports = dayjs_min.exports;
      const dayjs = exports("dG", /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports));
      const has = Object.prototype.hasOwnProperty;
      class QueueEvent extends Event {
        constructor(name2, detail) {
          super(name2);
          this.detail = detail;
        }
      }
      class Queue extends EventTarget {
        constructor(options2 = {}) {
          super();
          const { concurrency = Infinity, timeout = 0, autostart = false, results = null } = options2;
          this.concurrency = concurrency;
          this.timeout = timeout;
          this.autostart = autostart;
          this.results = results;
          this.pending = 0;
          this.session = 0;
          this.running = false;
          this.jobs = [];
          this.timers = [];
          this.addEventListener("error", this._errorHandler);
        }
        _errorHandler(evt) {
          this.end(evt.detail.error);
        }
        pop() {
          return this.jobs.pop();
        }
        shift() {
          return this.jobs.shift();
        }
        indexOf(searchElement, fromIndex) {
          return this.jobs.indexOf(searchElement, fromIndex);
        }
        lastIndexOf(searchElement, fromIndex) {
          if (fromIndex !== void 0)
            return this.jobs.lastIndexOf(searchElement, fromIndex);
          return this.jobs.lastIndexOf(searchElement);
        }
        slice(start2, end) {
          this.jobs = this.jobs.slice(start2, end);
          return this;
        }
        reverse() {
          this.jobs.reverse();
          return this;
        }
        push(...workers) {
          const methodResult = this.jobs.push(...workers);
          if (this.autostart)
            this._start();
          return methodResult;
        }
        unshift(...workers) {
          const methodResult = this.jobs.unshift(...workers);
          if (this.autostart)
            this._start();
          return methodResult;
        }
        splice(start2, deleteCount, ...workers) {
          this.jobs.splice(start2, deleteCount, ...workers);
          if (this.autostart)
            this._start();
          return this;
        }
        get length() {
          return this.pending + this.jobs.length;
        }
        start(callback2) {
          if (this.running)
            throw new Error("already started");
          let awaiter;
          if (callback2) {
            this._addCallbackToEndEvent(callback2);
          } else {
            awaiter = this._createPromiseToEndEvent();
          }
          this._start();
          return awaiter;
        }
        _start() {
          this.running = true;
          if (this.pending >= this.concurrency) {
            return;
          }
          if (this.jobs.length === 0) {
            if (this.pending === 0) {
              this.done();
            }
            return;
          }
          const job = this.jobs.shift();
          const session = this.session;
          const timeout = job !== void 0 && has.call(job, "timeout") ? job.timeout : this.timeout;
          let once = true;
          let timeoutId = null;
          let didTimeout = false;
          let resultIndex = null;
          const next2 = (error, ...result) => {
            if (once && this.session === session) {
              once = false;
              this.pending--;
              if (timeoutId !== null) {
                this.timers = this.timers.filter((tID) => tID !== timeoutId);
                clearTimeout(timeoutId);
              }
              if (error) {
                this.dispatchEvent(new QueueEvent("error", { error, job }));
              } else if (!didTimeout) {
                if (resultIndex !== null && this.results !== null) {
                  this.results[resultIndex] = [...result];
                }
                this.dispatchEvent(new QueueEvent("success", { result: [...result], job }));
              }
              if (this.session === session) {
                if (this.pending === 0 && this.jobs.length === 0) {
                  this.done();
                } else if (this.running) {
                  this._start();
                }
              }
            }
          };
          if (timeout) {
            timeoutId = setTimeout(() => {
              didTimeout = true;
              this.dispatchEvent(new QueueEvent("timeout", { next: next2, job }));
              next2();
            }, timeout);
            this.timers.push(timeoutId);
          }
          if (this.results != null) {
            resultIndex = this.results.length;
            this.results[resultIndex] = null;
          }
          this.pending++;
          this.dispatchEvent(new QueueEvent("start", { job }));
          job.promise = job(next2);
          if (job.promise !== void 0 && typeof job.promise.then === "function") {
            job.promise.then(function(result) {
              return next2(void 0, result);
            }).catch(function(err) {
              return next2(err || true);
            });
          }
          if (this.running && this.jobs.length > 0) {
            this._start();
          }
        }
        stop() {
          this.running = false;
        }
        end(error) {
          this.clearTimers();
          this.jobs.length = 0;
          this.pending = 0;
          this.done(error);
        }
        clearTimers() {
          this.timers.forEach((timer) => {
            clearTimeout(timer);
          });
          this.timers = [];
        }
        _addCallbackToEndEvent(cb) {
          const onend = (evt) => {
            this.removeEventListener("end", onend);
            cb(evt.detail.error, this.results);
          };
          this.addEventListener("end", onend);
        }
        _createPromiseToEndEvent() {
          return new Promise((resolve, reject) => {
            this._addCallbackToEndEvent((error, results) => {
              if (error)
                reject(error);
              else
                resolve(results);
            });
          });
        }
        done(error) {
          this.session++;
          this.running = false;
          this.dispatchEvent(new QueueEvent("end", { error }));
        }
      }
      var duration$1 = { exports: {} };
      (function(module2, exports2) {
        !function(t2, s) {
          module2.exports = s();
        }(commonjsGlobal, function() {
          var t2, s, n2 = 1e3, i = 6e4, e2 = 36e5, r2 = 864e5, o2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u = 31536e6, d = 2628e6, a = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, h2 = { years: u, months: d, days: r2, hours: e2, minutes: i, seconds: n2, milliseconds: 1, weeks: 6048e5 }, c = function(t3) {
            return t3 instanceof g;
          }, f = function(t3, s2, n3) {
            return new g(t3, n3, s2.$l);
          }, m2 = function(t3) {
            return s.p(t3) + "s";
          }, l2 = function(t3) {
            return t3 < 0;
          }, $2 = function(t3) {
            return l2(t3) ? Math.ceil(t3) : Math.floor(t3);
          }, y = function(t3) {
            return Math.abs(t3);
          }, v = function(t3, s2) {
            return t3 ? l2(t3) ? { negative: true, format: "" + y(t3) + s2 } : { negative: false, format: "" + t3 + s2 } : { negative: false, format: "" };
          }, g = function() {
            function l3(t3, s2, n3) {
              var i2 = this;
              if (this.$d = {}, this.$l = n3, void 0 === t3 && (this.$ms = 0, this.parseFromMilliseconds()), s2)
                return f(t3 * h2[m2(s2)], this);
              if ("number" == typeof t3)
                return this.$ms = t3, this.parseFromMilliseconds(), this;
              if ("object" == typeof t3)
                return Object.keys(t3).forEach(function(s3) {
                  i2.$d[m2(s3)] = t3[s3];
                }), this.calMilliseconds(), this;
              if ("string" == typeof t3) {
                var e3 = t3.match(a);
                if (e3) {
                  var r3 = e3.slice(2).map(function(t4) {
                    return null != t4 ? Number(t4) : 0;
                  });
                  return this.$d.years = r3[0], this.$d.months = r3[1], this.$d.weeks = r3[2], this.$d.days = r3[3], this.$d.hours = r3[4], this.$d.minutes = r3[5], this.$d.seconds = r3[6], this.calMilliseconds(), this;
                }
              }
              return this;
            }
            var y2 = l3.prototype;
            return y2.calMilliseconds = function() {
              var t3 = this;
              this.$ms = Object.keys(this.$d).reduce(function(s2, n3) {
                return s2 + (t3.$d[n3] || 0) * h2[n3];
              }, 0);
            }, y2.parseFromMilliseconds = function() {
              var t3 = this.$ms;
              this.$d.years = $2(t3 / u), t3 %= u, this.$d.months = $2(t3 / d), t3 %= d, this.$d.days = $2(t3 / r2), t3 %= r2, this.$d.hours = $2(t3 / e2), t3 %= e2, this.$d.minutes = $2(t3 / i), t3 %= i, this.$d.seconds = $2(t3 / n2), t3 %= n2, this.$d.milliseconds = t3;
            }, y2.toISOString = function() {
              var t3 = v(this.$d.years, "Y"), s2 = v(this.$d.months, "M"), n3 = +this.$d.days || 0;
              this.$d.weeks && (n3 += 7 * this.$d.weeks);
              var i2 = v(n3, "D"), e3 = v(this.$d.hours, "H"), r3 = v(this.$d.minutes, "M"), o3 = this.$d.seconds || 0;
              this.$d.milliseconds && (o3 += this.$d.milliseconds / 1e3, o3 = Math.round(1e3 * o3) / 1e3);
              var u2 = v(o3, "S"), d2 = t3.negative || s2.negative || i2.negative || e3.negative || r3.negative || u2.negative, a2 = e3.format || r3.format || u2.format ? "T" : "", h3 = (d2 ? "-" : "") + "P" + t3.format + s2.format + i2.format + a2 + e3.format + r3.format + u2.format;
              return "P" === h3 || "-P" === h3 ? "P0D" : h3;
            }, y2.toJSON = function() {
              return this.toISOString();
            }, y2.format = function(t3) {
              var n3 = t3 || "YYYY-MM-DDTHH:mm:ss", i2 = { Y: this.$d.years, YY: s.s(this.$d.years, 2, "0"), YYYY: s.s(this.$d.years, 4, "0"), M: this.$d.months, MM: s.s(this.$d.months, 2, "0"), D: this.$d.days, DD: s.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: s.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: s.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: s.s(this.$d.seconds, 2, "0"), SSS: s.s(this.$d.milliseconds, 3, "0") };
              return n3.replace(o2, function(t4, s2) {
                return s2 || String(i2[t4]);
              });
            }, y2.as = function(t3) {
              return this.$ms / h2[m2(t3)];
            }, y2.get = function(t3) {
              var s2 = this.$ms, n3 = m2(t3);
              return "milliseconds" === n3 ? s2 %= 1e3 : s2 = "weeks" === n3 ? $2(s2 / h2[n3]) : this.$d[n3], s2 || 0;
            }, y2.add = function(t3, s2, n3) {
              var i2;
              return i2 = s2 ? t3 * h2[m2(s2)] : c(t3) ? t3.$ms : f(t3, this).$ms, f(this.$ms + i2 * (n3 ? -1 : 1), this);
            }, y2.subtract = function(t3, s2) {
              return this.add(t3, s2, true);
            }, y2.locale = function(t3) {
              var s2 = this.clone();
              return s2.$l = t3, s2;
            }, y2.clone = function() {
              return f(this.$ms, this);
            }, y2.humanize = function(s2) {
              return t2().add(this.$ms, "ms").locale(this.$l).fromNow(!s2);
            }, y2.valueOf = function() {
              return this.asMilliseconds();
            }, y2.milliseconds = function() {
              return this.get("milliseconds");
            }, y2.asMilliseconds = function() {
              return this.as("milliseconds");
            }, y2.seconds = function() {
              return this.get("seconds");
            }, y2.asSeconds = function() {
              return this.as("seconds");
            }, y2.minutes = function() {
              return this.get("minutes");
            }, y2.asMinutes = function() {
              return this.as("minutes");
            }, y2.hours = function() {
              return this.get("hours");
            }, y2.asHours = function() {
              return this.as("hours");
            }, y2.days = function() {
              return this.get("days");
            }, y2.asDays = function() {
              return this.as("days");
            }, y2.weeks = function() {
              return this.get("weeks");
            }, y2.asWeeks = function() {
              return this.as("weeks");
            }, y2.months = function() {
              return this.get("months");
            }, y2.asMonths = function() {
              return this.as("months");
            }, y2.years = function() {
              return this.get("years");
            }, y2.asYears = function() {
              return this.as("years");
            }, l3;
          }(), p = function(t3, s2, n3) {
            return t3.add(s2.years() * n3, "y").add(s2.months() * n3, "M").add(s2.days() * n3, "d").add(s2.hours() * n3, "h").add(s2.minutes() * n3, "m").add(s2.seconds() * n3, "s").add(s2.milliseconds() * n3, "ms");
          };
          return function(n3, i2, e3) {
            t2 = e3, s = e3().$utils(), e3.duration = function(t3, s2) {
              var n4 = e3.locale();
              return f(t3, { $l: n4 }, s2);
            }, e3.isDuration = c;
            var r3 = i2.prototype.add, o3 = i2.prototype.subtract;
            i2.prototype.add = function(t3, s2) {
              return c(t3) ? p(this, t3, 1) : r3.bind(this)(t3, s2);
            }, i2.prototype.subtract = function(t3, s2) {
              return c(t3) ? p(this, t3, -1) : o3.bind(this)(t3, s2);
            };
          };
        });
      })(duration$1);
      var durationExports = duration$1.exports;
      const duration = /* @__PURE__ */ getDefaultExportFromCjs(durationExports);
      var relativeTime$1 = { exports: {} };
      (function(module2, exports2) {
        !function(r2, e2) {
          module2.exports = e2();
        }(commonjsGlobal, function() {
          return function(r2, e2, t2) {
            r2 = r2 || {};
            var n2 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
            function i(r3, e3, t3, o3) {
              return n2.fromToBase(r3, e3, t3, o3);
            }
            t2.en.relativeTime = o2, n2.fromToBase = function(e3, n3, i2, d2, u) {
              for (var f, a, s, l2 = i2.$locale().relativeTime || o2, h2 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m2 = h2.length, c = 0; c < m2; c += 1) {
                var y = h2[c];
                y.d && (f = d2 ? t2(e3).diff(i2, y.d, true) : i2.diff(e3, y.d, true));
                var p = (r2.rounding || Math.round)(Math.abs(f));
                if (s = f > 0, p <= y.r || !y.r) {
                  p <= 1 && c > 0 && (y = h2[c - 1]);
                  var v = l2[y.l];
                  u && (p = u("" + p)), a = "string" == typeof v ? v.replace("%d", p) : v(p, n3, y.l, s);
                  break;
                }
              }
              if (n3)
                return a;
              var M = s ? l2.future : l2.past;
              return "function" == typeof M ? M(a) : M.replace("%s", a);
            }, n2.to = function(r3, e3) {
              return i(r3, e3, this, true);
            }, n2.from = function(r3, e3) {
              return i(r3, e3, this);
            };
            var d = function(r3) {
              return r3.$u ? t2.utc() : t2();
            };
            n2.toNow = function(r3) {
              return this.to(d(this), r3);
            }, n2.fromNow = function(r3) {
              return this.from(d(this), r3);
            };
          };
        });
      })(relativeTime$1);
      var relativeTimeExports = relativeTime$1.exports;
      const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
      var __assign = function() {
        __assign = Object.assign || function __assign2(t2) {
          for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t2[p] = s[p];
          }
          return t2;
        };
        return __assign.apply(this, arguments);
      };
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n2) {
          return function(v) {
            return step([n2, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _)
            try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y = 0;
            } finally {
              f = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      function __values(o2) {
        var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o2[s], i = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i++], done: !o2 };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __read(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i["return"]))
              m2.call(i);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
        var e2 = new Error(message2);
        return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
      };
      var ENTRIES = "ENTRIES";
      var KEYS = "KEYS";
      var VALUES = "VALUES";
      var LEAF = "";
      var TreeIterator = (
        /** @class */
        function() {
          function TreeIterator2(set2, type) {
            var node = set2._tree;
            var keys2 = Array.from(node.keys());
            this.set = set2;
            this._type = type;
            this._path = keys2.length > 0 ? [{ node, keys: keys2 }] : [];
          }
          TreeIterator2.prototype.next = function() {
            var value = this.dive();
            this.backtrack();
            return value;
          };
          TreeIterator2.prototype.dive = function() {
            if (this._path.length === 0) {
              return { done: true, value: void 0 };
            }
            var _a3 = last$1(this._path), node = _a3.node, keys2 = _a3.keys;
            if (last$1(keys2) === LEAF) {
              return { done: false, value: this.result() };
            }
            var child = node.get(last$1(keys2));
            this._path.push({ node: child, keys: Array.from(child.keys()) });
            return this.dive();
          };
          TreeIterator2.prototype.backtrack = function() {
            if (this._path.length === 0) {
              return;
            }
            var keys2 = last$1(this._path).keys;
            keys2.pop();
            if (keys2.length > 0) {
              return;
            }
            this._path.pop();
            this.backtrack();
          };
          TreeIterator2.prototype.key = function() {
            return this.set._prefix + this._path.map(function(_a3) {
              var keys2 = _a3.keys;
              return last$1(keys2);
            }).filter(function(key) {
              return key !== LEAF;
            }).join("");
          };
          TreeIterator2.prototype.value = function() {
            return last$1(this._path).node.get(LEAF);
          };
          TreeIterator2.prototype.result = function() {
            switch (this._type) {
              case VALUES:
                return this.value();
              case KEYS:
                return this.key();
              default:
                return [this.key(), this.value()];
            }
          };
          TreeIterator2.prototype[Symbol.iterator] = function() {
            return this;
          };
          return TreeIterator2;
        }()
      );
      var last$1 = function(array) {
        return array[array.length - 1];
      };
      var fuzzySearch = function(node, query, maxDistance) {
        var results = /* @__PURE__ */ new Map();
        if (query === void 0)
          return results;
        var n2 = query.length + 1;
        var m2 = n2 + maxDistance;
        var matrix = new Uint8Array(m2 * n2).fill(maxDistance + 1);
        for (var j = 0; j < n2; ++j)
          matrix[j] = j;
        for (var i = 1; i < m2; ++i)
          matrix[i * n2] = i;
        recurse(node, query, maxDistance, results, matrix, 1, n2, "");
        return results;
      };
      var recurse = function(node, query, maxDistance, results, matrix, m2, n2, prefix) {
        var e_1, _a3;
        var offset = m2 * n2;
        try {
          key:
            for (var _b2 = __values(node.keys()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
              var key = _c.value;
              if (key === LEAF) {
                var distance = matrix[offset - 1];
                if (distance <= maxDistance) {
                  results.set(prefix, [node.get(key), distance]);
                }
              } else {
                var i = m2;
                for (var pos = 0; pos < key.length; ++pos, ++i) {
                  var char = key[pos];
                  var thisRowOffset = n2 * i;
                  var prevRowOffset = thisRowOffset - n2;
                  var minDistance = matrix[thisRowOffset];
                  var jmin = Math.max(0, i - maxDistance - 1);
                  var jmax = Math.min(n2 - 1, i + maxDistance);
                  for (var j = jmin; j < jmax; ++j) {
                    var different = char !== query[j];
                    var rpl = matrix[prevRowOffset + j] + +different;
                    var del = matrix[prevRowOffset + j + 1] + 1;
                    var ins = matrix[thisRowOffset + j] + 1;
                    var dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);
                    if (dist < minDistance)
                      minDistance = dist;
                  }
                  if (minDistance > maxDistance) {
                    continue key;
                  }
                }
                recurse(node.get(key), query, maxDistance, results, matrix, i, n2, prefix + key);
              }
            }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      var SearchableMap = (
        /** @class */
        function() {
          function SearchableMap2(tree, prefix) {
            if (tree === void 0) {
              tree = /* @__PURE__ */ new Map();
            }
            if (prefix === void 0) {
              prefix = "";
            }
            this._size = void 0;
            this._tree = tree;
            this._prefix = prefix;
          }
          SearchableMap2.prototype.atPrefix = function(prefix) {
            var e_1, _a3;
            if (!prefix.startsWith(this._prefix)) {
              throw new Error("Mismatched prefix");
            }
            var _b2 = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2), node = _b2[0], path2 = _b2[1];
            if (node === void 0) {
              var _c = __read(last(path2), 2), parentNode = _c[0], key = _c[1];
              try {
                for (var _d = __values(parentNode.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
                  var k = _e.value;
                  if (k !== LEAF && k.startsWith(key)) {
                    var node_1 = /* @__PURE__ */ new Map();
                    node_1.set(k.slice(key.length), parentNode.get(k));
                    return new SearchableMap2(node_1, prefix);
                  }
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_e && !_e.done && (_a3 = _d.return))
                    _a3.call(_d);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            }
            return new SearchableMap2(node, prefix);
          };
          SearchableMap2.prototype.clear = function() {
            this._size = void 0;
            this._tree.clear();
          };
          SearchableMap2.prototype.delete = function(key) {
            this._size = void 0;
            return remove(this._tree, key);
          };
          SearchableMap2.prototype.entries = function() {
            return new TreeIterator(this, ENTRIES);
          };
          SearchableMap2.prototype.forEach = function(fn) {
            var e_2, _a3;
            try {
              for (var _b2 = __values(this), _c = _b2.next(); !_c.done; _c = _b2.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                fn(key, value, this);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a3 = _b2.return))
                  _a3.call(_b2);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          };
          SearchableMap2.prototype.fuzzyGet = function(key, maxEditDistance) {
            return fuzzySearch(this._tree, key, maxEditDistance);
          };
          SearchableMap2.prototype.get = function(key) {
            var node = lookup(this._tree, key);
            return node !== void 0 ? node.get(LEAF) : void 0;
          };
          SearchableMap2.prototype.has = function(key) {
            var node = lookup(this._tree, key);
            return node !== void 0 && node.has(LEAF);
          };
          SearchableMap2.prototype.keys = function() {
            return new TreeIterator(this, KEYS);
          };
          SearchableMap2.prototype.set = function(key, value) {
            if (typeof key !== "string") {
              throw new Error("key must be a string");
            }
            this._size = void 0;
            var node = createPath(this._tree, key);
            node.set(LEAF, value);
            return this;
          };
          Object.defineProperty(SearchableMap2.prototype, "size", {
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size
             */
            get: function() {
              if (this._size) {
                return this._size;
              }
              this._size = 0;
              var iter = this.entries();
              while (!iter.next().done)
                this._size += 1;
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          SearchableMap2.prototype.update = function(key, fn) {
            if (typeof key !== "string") {
              throw new Error("key must be a string");
            }
            this._size = void 0;
            var node = createPath(this._tree, key);
            node.set(LEAF, fn(node.get(LEAF)));
            return this;
          };
          SearchableMap2.prototype.fetch = function(key, initial) {
            if (typeof key !== "string") {
              throw new Error("key must be a string");
            }
            this._size = void 0;
            var node = createPath(this._tree, key);
            var value = node.get(LEAF);
            if (value === void 0) {
              node.set(LEAF, value = initial());
            }
            return value;
          };
          SearchableMap2.prototype.values = function() {
            return new TreeIterator(this, VALUES);
          };
          SearchableMap2.prototype[Symbol.iterator] = function() {
            return this.entries();
          };
          SearchableMap2.from = function(entries) {
            var e_3, _a3;
            var tree = new SearchableMap2();
            try {
              for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                var _b2 = __read(entries_1_1.value, 2), key = _b2[0], value = _b2[1];
                tree.set(key, value);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (entries_1_1 && !entries_1_1.done && (_a3 = entries_1.return))
                  _a3.call(entries_1);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
            return tree;
          };
          SearchableMap2.fromObject = function(object) {
            return SearchableMap2.from(Object.entries(object));
          };
          return SearchableMap2;
        }()
      );
      var trackDown = function(tree, key, path2) {
        var e_4, _a3;
        if (path2 === void 0) {
          path2 = [];
        }
        if (key.length === 0 || tree == null) {
          return [tree, path2];
        }
        try {
          for (var _b2 = __values(tree.keys()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var k = _c.value;
            if (k !== LEAF && key.startsWith(k)) {
              path2.push([tree, k]);
              return trackDown(tree.get(k), key.slice(k.length), path2);
            }
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        path2.push([tree, key]);
        return trackDown(void 0, "", path2);
      };
      var lookup = function(tree, key) {
        var e_5, _a3;
        if (key.length === 0 || tree == null) {
          return tree;
        }
        try {
          for (var _b2 = __values(tree.keys()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var k = _c.value;
            if (k !== LEAF && key.startsWith(k)) {
              return lookup(tree.get(k), key.slice(k.length));
            }
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
      };
      var createPath = function(node, key) {
        var e_6, _a3;
        var keyLength = key.length;
        outer:
          for (var pos = 0; node && pos < keyLength; ) {
            try {
              for (var _b2 = (e_6 = void 0, __values(node.keys())), _c = _b2.next(); !_c.done; _c = _b2.next()) {
                var k = _c.value;
                if (k !== LEAF && key[pos] === k[0]) {
                  var len = Math.min(keyLength - pos, k.length);
                  var offset = 1;
                  while (offset < len && key[pos + offset] === k[offset])
                    ++offset;
                  var child_1 = node.get(k);
                  if (offset === k.length) {
                    node = child_1;
                  } else {
                    var intermediate = /* @__PURE__ */ new Map();
                    intermediate.set(k.slice(offset), child_1);
                    node.set(key.slice(pos, pos + offset), intermediate);
                    node.delete(k);
                    node = intermediate;
                  }
                  pos += offset;
                  continue outer;
                }
              }
            } catch (e_6_1) {
              e_6 = { error: e_6_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a3 = _b2.return))
                  _a3.call(_b2);
              } finally {
                if (e_6)
                  throw e_6.error;
              }
            }
            var child = /* @__PURE__ */ new Map();
            node.set(key.slice(pos), child);
            return child;
          }
        return node;
      };
      var remove = function(tree, key) {
        var _a3 = __read(trackDown(tree, key), 2), node = _a3[0], path2 = _a3[1];
        if (node === void 0) {
          return;
        }
        node.delete(LEAF);
        if (node.size === 0) {
          cleanup(path2);
        } else if (node.size === 1) {
          var _b2 = __read(node.entries().next().value, 2), key_1 = _b2[0], value = _b2[1];
          merge(path2, key_1, value);
        }
      };
      var cleanup = function(path2) {
        if (path2.length === 0) {
          return;
        }
        var _a3 = __read(last(path2), 2), node = _a3[0], key = _a3[1];
        node.delete(key);
        if (node.size === 0) {
          cleanup(path2.slice(0, -1));
        } else if (node.size === 1) {
          var _b2 = __read(node.entries().next().value, 2), key_2 = _b2[0], value = _b2[1];
          if (key_2 !== LEAF) {
            merge(path2.slice(0, -1), key_2, value);
          }
        }
      };
      var merge = function(path2, key, value) {
        if (path2.length === 0) {
          return;
        }
        var _a3 = __read(last(path2), 2), node = _a3[0], nodeKey = _a3[1];
        node.set(nodeKey + key, value);
        node.delete(nodeKey);
      };
      var last = function(array) {
        return array[array.length - 1];
      };
      var _a;
      var OR = "or";
      var AND = "and";
      var AND_NOT = "and_not";
      var MiniSearch = (
        /** @class */
        function() {
          function MiniSearch2(options2) {
            if ((options2 === null || options2 === void 0 ? void 0 : options2.fields) == null) {
              throw new Error('MiniSearch: option "fields" must be provided');
            }
            var autoVacuum = options2.autoVacuum == null || options2.autoVacuum === true ? defaultAutoVacuumOptions : options2.autoVacuum;
            this._options = __assign(__assign(__assign({}, defaultOptions), options2), { autoVacuum, searchOptions: __assign(__assign({}, defaultSearchOptions), options2.searchOptions || {}), autoSuggestOptions: __assign(__assign({}, defaultAutoSuggestOptions), options2.autoSuggestOptions || {}) });
            this._index = new SearchableMap();
            this._documentCount = 0;
            this._documentIds = /* @__PURE__ */ new Map();
            this._idToShortId = /* @__PURE__ */ new Map();
            this._fieldIds = {};
            this._fieldLength = /* @__PURE__ */ new Map();
            this._avgFieldLength = [];
            this._nextId = 0;
            this._storedFields = /* @__PURE__ */ new Map();
            this._dirtCount = 0;
            this._currentVacuum = null;
            this._enqueuedVacuum = null;
            this._enqueuedVacuumConditions = defaultVacuumConditions;
            this.addFields(this._options.fields);
          }
          MiniSearch2.prototype.add = function(document2) {
            var e_1, _a3, e_2, _b2, e_3, _c;
            var _d = this._options, extractField = _d.extractField, tokenize = _d.tokenize, processTerm = _d.processTerm, fields = _d.fields, idField = _d.idField;
            var id2 = extractField(document2, idField);
            if (id2 == null) {
              throw new Error('MiniSearch: document does not have ID field "'.concat(idField, '"'));
            }
            if (this._idToShortId.has(id2)) {
              throw new Error("MiniSearch: duplicate ID ".concat(id2));
            }
            var shortDocumentId = this.addDocumentId(id2);
            this.saveStoredFields(shortDocumentId, document2);
            try {
              for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
                var field = fields_1_1.value;
                var fieldValue = extractField(document2, field);
                if (fieldValue == null)
                  continue;
                var tokens = tokenize(fieldValue.toString(), field);
                var fieldId = this._fieldIds[field];
                var uniqueTerms = new Set(tokens).size;
                this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);
                try {
                  for (var tokens_1 = (e_2 = void 0, __values(tokens)), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
                    var term = tokens_1_1.value;
                    var processedTerm = processTerm(term, field);
                    if (Array.isArray(processedTerm)) {
                      try {
                        for (var processedTerm_1 = (e_3 = void 0, __values(processedTerm)), processedTerm_1_1 = processedTerm_1.next(); !processedTerm_1_1.done; processedTerm_1_1 = processedTerm_1.next()) {
                          var t2 = processedTerm_1_1.value;
                          this.addTerm(fieldId, shortDocumentId, t2);
                        }
                      } catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                      } finally {
                        try {
                          if (processedTerm_1_1 && !processedTerm_1_1.done && (_c = processedTerm_1.return))
                            _c.call(processedTerm_1);
                        } finally {
                          if (e_3)
                            throw e_3.error;
                        }
                      }
                    } else if (processedTerm) {
                      this.addTerm(fieldId, shortDocumentId, processedTerm);
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (tokens_1_1 && !tokens_1_1.done && (_b2 = tokens_1.return))
                      _b2.call(tokens_1);
                  } finally {
                    if (e_2)
                      throw e_2.error;
                  }
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (fields_1_1 && !fields_1_1.done && (_a3 = fields_1.return))
                  _a3.call(fields_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          };
          MiniSearch2.prototype.addAll = function(documents) {
            var e_4, _a3;
            try {
              for (var documents_1 = __values(documents), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
                var document_1 = documents_1_1.value;
                this.add(document_1);
              }
            } catch (e_4_1) {
              e_4 = { error: e_4_1 };
            } finally {
              try {
                if (documents_1_1 && !documents_1_1.done && (_a3 = documents_1.return))
                  _a3.call(documents_1);
              } finally {
                if (e_4)
                  throw e_4.error;
              }
            }
          };
          MiniSearch2.prototype.addAllAsync = function(documents, options2) {
            var _this = this;
            if (options2 === void 0) {
              options2 = {};
            }
            var _a3 = options2.chunkSize, chunkSize = _a3 === void 0 ? 10 : _a3;
            var acc = { chunk: [], promise: Promise.resolve() };
            var _b2 = documents.reduce(function(_a4, document2, i) {
              var chunk2 = _a4.chunk, promise2 = _a4.promise;
              chunk2.push(document2);
              if ((i + 1) % chunkSize === 0) {
                return {
                  chunk: [],
                  promise: promise2.then(function() {
                    return new Promise(function(resolve) {
                      return setTimeout(resolve, 0);
                    });
                  }).then(function() {
                    return _this.addAll(chunk2);
                  })
                };
              } else {
                return { chunk: chunk2, promise: promise2 };
              }
            }, acc), chunk = _b2.chunk, promise = _b2.promise;
            return promise.then(function() {
              return _this.addAll(chunk);
            });
          };
          MiniSearch2.prototype.remove = function(document2) {
            var e_5, _a3, e_6, _b2, e_7, _c;
            var _d = this._options, tokenize = _d.tokenize, processTerm = _d.processTerm, extractField = _d.extractField, fields = _d.fields, idField = _d.idField;
            var id2 = extractField(document2, idField);
            if (id2 == null) {
              throw new Error('MiniSearch: document does not have ID field "'.concat(idField, '"'));
            }
            var shortId = this._idToShortId.get(id2);
            if (shortId == null) {
              throw new Error("MiniSearch: cannot remove document with ID ".concat(id2, ": it is not in the index"));
            }
            try {
              for (var fields_2 = __values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
                var field = fields_2_1.value;
                var fieldValue = extractField(document2, field);
                if (fieldValue == null)
                  continue;
                var tokens = tokenize(fieldValue.toString(), field);
                var fieldId = this._fieldIds[field];
                var uniqueTerms = new Set(tokens).size;
                this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);
                try {
                  for (var tokens_2 = (e_6 = void 0, __values(tokens)), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
                    var term = tokens_2_1.value;
                    var processedTerm = processTerm(term, field);
                    if (Array.isArray(processedTerm)) {
                      try {
                        for (var processedTerm_2 = (e_7 = void 0, __values(processedTerm)), processedTerm_2_1 = processedTerm_2.next(); !processedTerm_2_1.done; processedTerm_2_1 = processedTerm_2.next()) {
                          var t2 = processedTerm_2_1.value;
                          this.removeTerm(fieldId, shortId, t2);
                        }
                      } catch (e_7_1) {
                        e_7 = { error: e_7_1 };
                      } finally {
                        try {
                          if (processedTerm_2_1 && !processedTerm_2_1.done && (_c = processedTerm_2.return))
                            _c.call(processedTerm_2);
                        } finally {
                          if (e_7)
                            throw e_7.error;
                        }
                      }
                    } else if (processedTerm) {
                      this.removeTerm(fieldId, shortId, processedTerm);
                    }
                  }
                } catch (e_6_1) {
                  e_6 = { error: e_6_1 };
                } finally {
                  try {
                    if (tokens_2_1 && !tokens_2_1.done && (_b2 = tokens_2.return))
                      _b2.call(tokens_2);
                  } finally {
                    if (e_6)
                      throw e_6.error;
                  }
                }
              }
            } catch (e_5_1) {
              e_5 = { error: e_5_1 };
            } finally {
              try {
                if (fields_2_1 && !fields_2_1.done && (_a3 = fields_2.return))
                  _a3.call(fields_2);
              } finally {
                if (e_5)
                  throw e_5.error;
              }
            }
            this._storedFields.delete(shortId);
            this._documentIds.delete(shortId);
            this._idToShortId.delete(id2);
            this._fieldLength.delete(shortId);
            this._documentCount -= 1;
          };
          MiniSearch2.prototype.removeAll = function(documents) {
            var e_8, _a3;
            if (documents) {
              try {
                for (var documents_2 = __values(documents), documents_2_1 = documents_2.next(); !documents_2_1.done; documents_2_1 = documents_2.next()) {
                  var document_2 = documents_2_1.value;
                  this.remove(document_2);
                }
              } catch (e_8_1) {
                e_8 = { error: e_8_1 };
              } finally {
                try {
                  if (documents_2_1 && !documents_2_1.done && (_a3 = documents_2.return))
                    _a3.call(documents_2);
                } finally {
                  if (e_8)
                    throw e_8.error;
                }
              }
            } else if (arguments.length > 0) {
              throw new Error("Expected documents to be present. Omit the argument to remove all documents.");
            } else {
              this._index = new SearchableMap();
              this._documentCount = 0;
              this._documentIds = /* @__PURE__ */ new Map();
              this._idToShortId = /* @__PURE__ */ new Map();
              this._fieldLength = /* @__PURE__ */ new Map();
              this._avgFieldLength = [];
              this._storedFields = /* @__PURE__ */ new Map();
              this._nextId = 0;
            }
          };
          MiniSearch2.prototype.discard = function(id2) {
            var _this = this;
            var shortId = this._idToShortId.get(id2);
            if (shortId == null) {
              throw new Error("MiniSearch: cannot discard document with ID ".concat(id2, ": it is not in the index"));
            }
            this._idToShortId.delete(id2);
            this._documentIds.delete(shortId);
            this._storedFields.delete(shortId);
            (this._fieldLength.get(shortId) || []).forEach(function(fieldLength, fieldId) {
              _this.removeFieldLength(shortId, fieldId, _this._documentCount, fieldLength);
            });
            this._fieldLength.delete(shortId);
            this._documentCount -= 1;
            this._dirtCount += 1;
            this.maybeAutoVacuum();
          };
          MiniSearch2.prototype.maybeAutoVacuum = function() {
            if (this._options.autoVacuum === false) {
              return;
            }
            var _a3 = this._options.autoVacuum, minDirtFactor = _a3.minDirtFactor, minDirtCount = _a3.minDirtCount, batchSize = _a3.batchSize, batchWait = _a3.batchWait;
            this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });
          };
          MiniSearch2.prototype.discardAll = function(ids) {
            var e_9, _a3;
            var autoVacuum = this._options.autoVacuum;
            try {
              this._options.autoVacuum = false;
              try {
                for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
                  var id2 = ids_1_1.value;
                  this.discard(id2);
                }
              } catch (e_9_1) {
                e_9 = { error: e_9_1 };
              } finally {
                try {
                  if (ids_1_1 && !ids_1_1.done && (_a3 = ids_1.return))
                    _a3.call(ids_1);
                } finally {
                  if (e_9)
                    throw e_9.error;
                }
              }
            } finally {
              this._options.autoVacuum = autoVacuum;
            }
            this.maybeAutoVacuum();
          };
          MiniSearch2.prototype.replace = function(updatedDocument) {
            var _a3 = this._options, idField = _a3.idField, extractField = _a3.extractField;
            var id2 = extractField(updatedDocument, idField);
            this.discard(id2);
            this.add(updatedDocument);
          };
          MiniSearch2.prototype.vacuum = function(options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            return this.conditionalVacuum(options2);
          };
          MiniSearch2.prototype.conditionalVacuum = function(options2, conditions) {
            var _this = this;
            if (this._currentVacuum) {
              this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;
              if (this._enqueuedVacuum != null) {
                return this._enqueuedVacuum;
              }
              this._enqueuedVacuum = this._currentVacuum.then(function() {
                var conditions2 = _this._enqueuedVacuumConditions;
                _this._enqueuedVacuumConditions = defaultVacuumConditions;
                return _this.performVacuuming(options2, conditions2);
              });
              return this._enqueuedVacuum;
            }
            if (this.vacuumConditionsMet(conditions) === false) {
              return Promise.resolve();
            }
            this._currentVacuum = this.performVacuuming(options2);
            return this._currentVacuum;
          };
          MiniSearch2.prototype.performVacuuming = function(options2, conditions) {
            return __awaiter(this, void 0, void 0, function() {
              var initialDirtCount, batchSize, batchWait_1, i, _a3, _b2, _c, term, fieldsData, fieldsData_1, fieldsData_1_1, _d, fieldId, fieldIndex, fieldIndex_1, fieldIndex_1_1, _e, shortId, e_10_1;
              var e_10, _f, e_11, _g, e_12, _h;
              return __generator(this, function(_j) {
                switch (_j.label) {
                  case 0:
                    initialDirtCount = this._dirtCount;
                    if (!this.vacuumConditionsMet(conditions))
                      return [3, 10];
                    batchSize = options2.batchSize || defaultVacuumOptions.batchSize;
                    batchWait_1 = options2.batchWait || defaultVacuumOptions.batchWait;
                    i = 1;
                    _j.label = 1;
                  case 1:
                    _j.trys.push([1, 7, 8, 9]);
                    _a3 = __values(this._index), _b2 = _a3.next();
                    _j.label = 2;
                  case 2:
                    if (!!_b2.done)
                      return [3, 6];
                    _c = __read(_b2.value, 2), term = _c[0], fieldsData = _c[1];
                    try {
                      for (fieldsData_1 = (e_11 = void 0, __values(fieldsData)), fieldsData_1_1 = fieldsData_1.next(); !fieldsData_1_1.done; fieldsData_1_1 = fieldsData_1.next()) {
                        _d = __read(fieldsData_1_1.value, 2), fieldId = _d[0], fieldIndex = _d[1];
                        try {
                          for (fieldIndex_1 = (e_12 = void 0, __values(fieldIndex)), fieldIndex_1_1 = fieldIndex_1.next(); !fieldIndex_1_1.done; fieldIndex_1_1 = fieldIndex_1.next()) {
                            _e = __read(fieldIndex_1_1.value, 1), shortId = _e[0];
                            if (this._documentIds.has(shortId)) {
                              continue;
                            }
                            if (fieldIndex.size <= 1) {
                              fieldsData.delete(fieldId);
                            } else {
                              fieldIndex.delete(shortId);
                            }
                          }
                        } catch (e_12_1) {
                          e_12 = { error: e_12_1 };
                        } finally {
                          try {
                            if (fieldIndex_1_1 && !fieldIndex_1_1.done && (_h = fieldIndex_1.return))
                              _h.call(fieldIndex_1);
                          } finally {
                            if (e_12)
                              throw e_12.error;
                          }
                        }
                      }
                    } catch (e_11_1) {
                      e_11 = { error: e_11_1 };
                    } finally {
                      try {
                        if (fieldsData_1_1 && !fieldsData_1_1.done && (_g = fieldsData_1.return))
                          _g.call(fieldsData_1);
                      } finally {
                        if (e_11)
                          throw e_11.error;
                      }
                    }
                    if (this._index.get(term).size === 0) {
                      this._index.delete(term);
                    }
                    if (!(i % batchSize === 0))
                      return [3, 4];
                    return [4, new Promise(function(resolve) {
                      return setTimeout(resolve, batchWait_1);
                    })];
                  case 3:
                    _j.sent();
                    _j.label = 4;
                  case 4:
                    i += 1;
                    _j.label = 5;
                  case 5:
                    _b2 = _a3.next();
                    return [3, 2];
                  case 6:
                    return [3, 9];
                  case 7:
                    e_10_1 = _j.sent();
                    e_10 = { error: e_10_1 };
                    return [3, 9];
                  case 8:
                    try {
                      if (_b2 && !_b2.done && (_f = _a3.return))
                        _f.call(_a3);
                    } finally {
                      if (e_10)
                        throw e_10.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 9:
                    this._dirtCount -= initialDirtCount;
                    _j.label = 10;
                  case 10:
                    return [4, null];
                  case 11:
                    _j.sent();
                    this._currentVacuum = this._enqueuedVacuum;
                    this._enqueuedVacuum = null;
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          MiniSearch2.prototype.vacuumConditionsMet = function(conditions) {
            if (conditions == null) {
              return true;
            }
            var minDirtCount = conditions.minDirtCount, minDirtFactor = conditions.minDirtFactor;
            minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;
            minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;
            return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;
          };
          Object.defineProperty(MiniSearch2.prototype, "isVacuuming", {
            /**
             * Is `true` if a vacuuming operation is ongoing, `false` otherwise
             */
            get: function() {
              return this._currentVacuum != null;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(MiniSearch2.prototype, "dirtCount", {
            /**
             * The number of documents discarded since the most recent vacuuming
             */
            get: function() {
              return this._dirtCount;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(MiniSearch2.prototype, "dirtFactor", {
            /**
             * A number between 0 and 1 giving an indication about the proportion of
             * documents that are discarded, and can therefore be cleaned up by vacuuming.
             * A value close to 0 means that the index is relatively clean, while a higher
             * value means that the index is relatively dirty, and vacuuming could release
             * memory.
             */
            get: function() {
              return this._dirtCount / (1 + this._documentCount + this._dirtCount);
            },
            enumerable: false,
            configurable: true
          });
          MiniSearch2.prototype.has = function(id2) {
            return this._idToShortId.has(id2);
          };
          MiniSearch2.prototype.getStoredFields = function(id2) {
            var shortId = this._idToShortId.get(id2);
            if (shortId == null) {
              return void 0;
            }
            return this._storedFields.get(shortId);
          };
          MiniSearch2.prototype.search = function(query, searchOptions) {
            var e_13, _a3;
            if (searchOptions === void 0) {
              searchOptions = {};
            }
            var rawResults = this.executeQuery(query, searchOptions);
            var results = [];
            try {
              for (var rawResults_1 = __values(rawResults), rawResults_1_1 = rawResults_1.next(); !rawResults_1_1.done; rawResults_1_1 = rawResults_1.next()) {
                var _b2 = __read(rawResults_1_1.value, 2), docId = _b2[0], _c = _b2[1], score = _c.score, terms = _c.terms, match2 = _c.match;
                var quality = terms.length || 1;
                var result = {
                  id: this._documentIds.get(docId),
                  score: score * quality,
                  terms: Object.keys(match2),
                  queryTerms: terms,
                  match: match2
                };
                Object.assign(result, this._storedFields.get(docId));
                if (searchOptions.filter == null || searchOptions.filter(result)) {
                  results.push(result);
                }
              }
            } catch (e_13_1) {
              e_13 = { error: e_13_1 };
            } finally {
              try {
                if (rawResults_1_1 && !rawResults_1_1.done && (_a3 = rawResults_1.return))
                  _a3.call(rawResults_1);
              } finally {
                if (e_13)
                  throw e_13.error;
              }
            }
            if (query === MiniSearch2.wildcard && searchOptions.boostDocument == null && this._options.searchOptions.boostDocument == null) {
              return results;
            }
            results.sort(byScore);
            return results;
          };
          MiniSearch2.prototype.autoSuggest = function(queryString, options2) {
            var e_14, _a3, e_15, _b2;
            if (options2 === void 0) {
              options2 = {};
            }
            options2 = __assign(__assign({}, this._options.autoSuggestOptions), options2);
            var suggestions = /* @__PURE__ */ new Map();
            try {
              for (var _c = __values(this.search(queryString, options2)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = _d.value, score = _e.score, terms = _e.terms;
                var phrase = terms.join(" ");
                var suggestion = suggestions.get(phrase);
                if (suggestion != null) {
                  suggestion.score += score;
                  suggestion.count += 1;
                } else {
                  suggestions.set(phrase, { score, terms, count: 1 });
                }
              }
            } catch (e_14_1) {
              e_14 = { error: e_14_1 };
            } finally {
              try {
                if (_d && !_d.done && (_a3 = _c.return))
                  _a3.call(_c);
              } finally {
                if (e_14)
                  throw e_14.error;
              }
            }
            var results = [];
            try {
              for (var suggestions_1 = __values(suggestions), suggestions_1_1 = suggestions_1.next(); !suggestions_1_1.done; suggestions_1_1 = suggestions_1.next()) {
                var _f = __read(suggestions_1_1.value, 2), suggestion = _f[0], _g = _f[1], score = _g.score, terms = _g.terms, count2 = _g.count;
                results.push({ suggestion, terms, score: score / count2 });
              }
            } catch (e_15_1) {
              e_15 = { error: e_15_1 };
            } finally {
              try {
                if (suggestions_1_1 && !suggestions_1_1.done && (_b2 = suggestions_1.return))
                  _b2.call(suggestions_1);
              } finally {
                if (e_15)
                  throw e_15.error;
              }
            }
            results.sort(byScore);
            return results;
          };
          Object.defineProperty(MiniSearch2.prototype, "documentCount", {
            /**
             * Total number of documents available to search
             */
            get: function() {
              return this._documentCount;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(MiniSearch2.prototype, "termCount", {
            /**
             * Number of terms in the index
             */
            get: function() {
              return this._index.size;
            },
            enumerable: false,
            configurable: true
          });
          MiniSearch2.loadJSON = function(json, options2) {
            if (options2 == null) {
              throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
            }
            return this.loadJS(JSON.parse(json), options2);
          };
          MiniSearch2.getDefault = function(optionName) {
            if (defaultOptions.hasOwnProperty(optionName)) {
              return getOwnProperty(defaultOptions, optionName);
            } else {
              throw new Error('MiniSearch: unknown option "'.concat(optionName, '"'));
            }
          };
          MiniSearch2.loadJS = function(js, options2) {
            var e_16, _a3, e_17, _b2, e_18, _c;
            var index = js.index, documentCount = js.documentCount, nextId = js.nextId, documentIds = js.documentIds, fieldIds = js.fieldIds, fieldLength = js.fieldLength, averageFieldLength = js.averageFieldLength, storedFields = js.storedFields, dirtCount = js.dirtCount, serializationVersion = js.serializationVersion;
            if (serializationVersion !== 1 && serializationVersion !== 2) {
              throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");
            }
            var miniSearch = new MiniSearch2(options2);
            miniSearch._documentCount = documentCount;
            miniSearch._nextId = nextId;
            miniSearch._documentIds = objectToNumericMap(documentIds);
            miniSearch._idToShortId = /* @__PURE__ */ new Map();
            miniSearch._fieldIds = fieldIds;
            miniSearch._fieldLength = objectToNumericMap(fieldLength);
            miniSearch._avgFieldLength = averageFieldLength;
            miniSearch._storedFields = objectToNumericMap(storedFields);
            miniSearch._dirtCount = dirtCount || 0;
            miniSearch._index = new SearchableMap();
            try {
              for (var _d = __values(miniSearch._documentIds), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 2), shortId = _f[0], id2 = _f[1];
                miniSearch._idToShortId.set(id2, shortId);
              }
            } catch (e_16_1) {
              e_16 = { error: e_16_1 };
            } finally {
              try {
                if (_e && !_e.done && (_a3 = _d.return))
                  _a3.call(_d);
              } finally {
                if (e_16)
                  throw e_16.error;
              }
            }
            try {
              for (var index_1 = __values(index), index_1_1 = index_1.next(); !index_1_1.done; index_1_1 = index_1.next()) {
                var _g = __read(index_1_1.value, 2), term = _g[0], data2 = _g[1];
                var dataMap = /* @__PURE__ */ new Map();
                try {
                  for (var _h = (e_18 = void 0, __values(Object.keys(data2))), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var fieldId = _j.value;
                    var indexEntry = data2[fieldId];
                    if (serializationVersion === 1) {
                      indexEntry = indexEntry.ds;
                    }
                    dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));
                  }
                } catch (e_18_1) {
                  e_18 = { error: e_18_1 };
                } finally {
                  try {
                    if (_j && !_j.done && (_c = _h.return))
                      _c.call(_h);
                  } finally {
                    if (e_18)
                      throw e_18.error;
                  }
                }
                miniSearch._index.set(term, dataMap);
              }
            } catch (e_17_1) {
              e_17 = { error: e_17_1 };
            } finally {
              try {
                if (index_1_1 && !index_1_1.done && (_b2 = index_1.return))
                  _b2.call(index_1);
              } finally {
                if (e_17)
                  throw e_17.error;
              }
            }
            return miniSearch;
          };
          MiniSearch2.prototype.executeQuery = function(query, searchOptions) {
            var _this = this;
            if (searchOptions === void 0) {
              searchOptions = {};
            }
            if (query === MiniSearch2.wildcard) {
              return this.executeWildcardQuery(searchOptions);
            }
            if (typeof query !== "string") {
              var options_1 = __assign(__assign(__assign({}, searchOptions), query), { queries: void 0 });
              var results_1 = query.queries.map(function(subquery) {
                return _this.executeQuery(subquery, options_1);
              });
              return this.combineResults(results_1, options_1.combineWith);
            }
            var _a3 = this._options, tokenize = _a3.tokenize, processTerm = _a3.processTerm, globalSearchOptions = _a3.searchOptions;
            var options2 = __assign(__assign({ tokenize, processTerm }, globalSearchOptions), searchOptions);
            var searchTokenize = options2.tokenize, searchProcessTerm = options2.processTerm;
            var terms = searchTokenize(query).flatMap(function(term) {
              return searchProcessTerm(term);
            }).filter(function(term) {
              return !!term;
            });
            var queries = terms.map(termToQuerySpec(options2));
            var results = queries.map(function(query2) {
              return _this.executeQuerySpec(query2, options2);
            });
            return this.combineResults(results, options2.combineWith);
          };
          MiniSearch2.prototype.executeQuerySpec = function(query, searchOptions) {
            var e_19, _a3, e_20, _b2;
            var options2 = __assign(__assign({}, this._options.searchOptions), searchOptions);
            var boosts = (options2.fields || this._options.fields).reduce(function(boosts2, field) {
              var _a4;
              return __assign(__assign({}, boosts2), (_a4 = {}, _a4[field] = getOwnProperty(options2.boost, field) || 1, _a4));
            }, {});
            var boostDocument = options2.boostDocument, weights = options2.weights, maxFuzzy = options2.maxFuzzy, bm25params = options2.bm25;
            var _c = __assign(__assign({}, defaultSearchOptions.weights), weights), fuzzyWeight = _c.fuzzy, prefixWeight = _c.prefix;
            var data2 = this._index.get(query.term);
            var results = this.termResults(query.term, query.term, 1, data2, boosts, boostDocument, bm25params);
            var prefixMatches;
            var fuzzyMatches;
            if (query.prefix) {
              prefixMatches = this._index.atPrefix(query.term);
            }
            if (query.fuzzy) {
              var fuzzy = query.fuzzy === true ? 0.2 : query.fuzzy;
              var maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;
              if (maxDistance)
                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);
            }
            if (prefixMatches) {
              try {
                for (var prefixMatches_1 = __values(prefixMatches), prefixMatches_1_1 = prefixMatches_1.next(); !prefixMatches_1_1.done; prefixMatches_1_1 = prefixMatches_1.next()) {
                  var _d = __read(prefixMatches_1_1.value, 2), term = _d[0], data_1 = _d[1];
                  var distance = term.length - query.term.length;
                  if (!distance) {
                    continue;
                  }
                  fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);
                  var weight = prefixWeight * term.length / (term.length + 0.3 * distance);
                  this.termResults(query.term, term, weight, data_1, boosts, boostDocument, bm25params, results);
                }
              } catch (e_19_1) {
                e_19 = { error: e_19_1 };
              } finally {
                try {
                  if (prefixMatches_1_1 && !prefixMatches_1_1.done && (_a3 = prefixMatches_1.return))
                    _a3.call(prefixMatches_1);
                } finally {
                  if (e_19)
                    throw e_19.error;
                }
              }
            }
            if (fuzzyMatches) {
              try {
                for (var _e = __values(fuzzyMatches.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var term = _f.value;
                  var _g = __read(fuzzyMatches.get(term), 2), data_2 = _g[0], distance = _g[1];
                  if (!distance) {
                    continue;
                  }
                  var weight = fuzzyWeight * term.length / (term.length + distance);
                  this.termResults(query.term, term, weight, data_2, boosts, boostDocument, bm25params, results);
                }
              } catch (e_20_1) {
                e_20 = { error: e_20_1 };
              } finally {
                try {
                  if (_f && !_f.done && (_b2 = _e.return))
                    _b2.call(_e);
                } finally {
                  if (e_20)
                    throw e_20.error;
                }
              }
            }
            return results;
          };
          MiniSearch2.prototype.executeWildcardQuery = function(searchOptions) {
            var e_21, _a3;
            var results = /* @__PURE__ */ new Map();
            var options2 = __assign(__assign({}, this._options.searchOptions), searchOptions);
            try {
              for (var _b2 = __values(this._documentIds), _c = _b2.next(); !_c.done; _c = _b2.next()) {
                var _d = __read(_c.value, 2), shortId = _d[0], id2 = _d[1];
                var score = options2.boostDocument ? options2.boostDocument(id2, "", this._storedFields.get(shortId)) : 1;
                results.set(shortId, {
                  score,
                  terms: [],
                  match: {}
                });
              }
            } catch (e_21_1) {
              e_21 = { error: e_21_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a3 = _b2.return))
                  _a3.call(_b2);
              } finally {
                if (e_21)
                  throw e_21.error;
              }
            }
            return results;
          };
          MiniSearch2.prototype.combineResults = function(results, combineWith) {
            if (combineWith === void 0) {
              combineWith = OR;
            }
            if (results.length === 0) {
              return /* @__PURE__ */ new Map();
            }
            var operator = combineWith.toLowerCase();
            return results.reduce(combinators[operator]) || /* @__PURE__ */ new Map();
          };
          MiniSearch2.prototype.toJSON = function() {
            var e_22, _a3, e_23, _b2;
            var index = [];
            try {
              for (var _c = __values(this._index), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), term = _e[0], fieldIndex = _e[1];
                var data2 = {};
                try {
                  for (var fieldIndex_2 = (e_23 = void 0, __values(fieldIndex)), fieldIndex_2_1 = fieldIndex_2.next(); !fieldIndex_2_1.done; fieldIndex_2_1 = fieldIndex_2.next()) {
                    var _f = __read(fieldIndex_2_1.value, 2), fieldId = _f[0], freqs = _f[1];
                    data2[fieldId] = Object.fromEntries(freqs);
                  }
                } catch (e_23_1) {
                  e_23 = { error: e_23_1 };
                } finally {
                  try {
                    if (fieldIndex_2_1 && !fieldIndex_2_1.done && (_b2 = fieldIndex_2.return))
                      _b2.call(fieldIndex_2);
                  } finally {
                    if (e_23)
                      throw e_23.error;
                  }
                }
                index.push([term, data2]);
              }
            } catch (e_22_1) {
              e_22 = { error: e_22_1 };
            } finally {
              try {
                if (_d && !_d.done && (_a3 = _c.return))
                  _a3.call(_c);
              } finally {
                if (e_22)
                  throw e_22.error;
              }
            }
            return {
              documentCount: this._documentCount,
              nextId: this._nextId,
              documentIds: Object.fromEntries(this._documentIds),
              fieldIds: this._fieldIds,
              fieldLength: Object.fromEntries(this._fieldLength),
              averageFieldLength: this._avgFieldLength,
              storedFields: Object.fromEntries(this._storedFields),
              dirtCount: this._dirtCount,
              index,
              serializationVersion: 2
            };
          };
          MiniSearch2.prototype.termResults = function(sourceTerm, derivedTerm, termWeight, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results) {
            var e_24, _a3, e_25, _b2, _c;
            if (results === void 0) {
              results = /* @__PURE__ */ new Map();
            }
            if (fieldTermData == null)
              return results;
            try {
              for (var _d = __values(Object.keys(fieldBoosts)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var field = _e.value;
                var fieldBoost = fieldBoosts[field];
                var fieldId = this._fieldIds[field];
                var fieldTermFreqs = fieldTermData.get(fieldId);
                if (fieldTermFreqs == null)
                  continue;
                var matchingFields = fieldTermFreqs.size;
                var avgFieldLength = this._avgFieldLength[fieldId];
                try {
                  for (var _f = (e_25 = void 0, __values(fieldTermFreqs.keys())), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var docId = _g.value;
                    if (!this._documentIds.has(docId)) {
                      this.removeTerm(fieldId, docId, derivedTerm);
                      matchingFields -= 1;
                      continue;
                    }
                    var docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;
                    if (!docBoost)
                      continue;
                    var termFreq = fieldTermFreqs.get(docId);
                    var fieldLength = this._fieldLength.get(docId)[fieldId];
                    var rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);
                    var weightedScore = termWeight * fieldBoost * docBoost * rawScore;
                    var result = results.get(docId);
                    if (result) {
                      result.score += weightedScore;
                      assignUniqueTerm(result.terms, sourceTerm);
                      var match2 = getOwnProperty(result.match, derivedTerm);
                      if (match2) {
                        match2.push(field);
                      } else {
                        result.match[derivedTerm] = [field];
                      }
                    } else {
                      results.set(docId, {
                        score: weightedScore,
                        terms: [sourceTerm],
                        match: (_c = {}, _c[derivedTerm] = [field], _c)
                      });
                    }
                  }
                } catch (e_25_1) {
                  e_25 = { error: e_25_1 };
                } finally {
                  try {
                    if (_g && !_g.done && (_b2 = _f.return))
                      _b2.call(_f);
                  } finally {
                    if (e_25)
                      throw e_25.error;
                  }
                }
              }
            } catch (e_24_1) {
              e_24 = { error: e_24_1 };
            } finally {
              try {
                if (_e && !_e.done && (_a3 = _d.return))
                  _a3.call(_d);
              } finally {
                if (e_24)
                  throw e_24.error;
              }
            }
            return results;
          };
          MiniSearch2.prototype.addTerm = function(fieldId, documentId, term) {
            var indexData = this._index.fetch(term, createMap);
            var fieldIndex = indexData.get(fieldId);
            if (fieldIndex == null) {
              fieldIndex = /* @__PURE__ */ new Map();
              fieldIndex.set(documentId, 1);
              indexData.set(fieldId, fieldIndex);
            } else {
              var docs = fieldIndex.get(documentId);
              fieldIndex.set(documentId, (docs || 0) + 1);
            }
          };
          MiniSearch2.prototype.removeTerm = function(fieldId, documentId, term) {
            if (!this._index.has(term)) {
              this.warnDocumentChanged(documentId, fieldId, term);
              return;
            }
            var indexData = this._index.fetch(term, createMap);
            var fieldIndex = indexData.get(fieldId);
            if (fieldIndex == null || fieldIndex.get(documentId) == null) {
              this.warnDocumentChanged(documentId, fieldId, term);
            } else if (fieldIndex.get(documentId) <= 1) {
              if (fieldIndex.size <= 1) {
                indexData.delete(fieldId);
              } else {
                fieldIndex.delete(documentId);
              }
            } else {
              fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);
            }
            if (this._index.get(term).size === 0) {
              this._index.delete(term);
            }
          };
          MiniSearch2.prototype.warnDocumentChanged = function(shortDocumentId, fieldId, term) {
            var e_26, _a3;
            try {
              for (var _b2 = __values(Object.keys(this._fieldIds)), _c = _b2.next(); !_c.done; _c = _b2.next()) {
                var fieldName = _c.value;
                if (this._fieldIds[fieldName] === fieldId) {
                  this._options.logger("warn", "MiniSearch: document with ID ".concat(this._documentIds.get(shortDocumentId), ' has changed before removal: term "').concat(term, '" was not present in field "').concat(fieldName, '". Removing a document after it has changed can corrupt the index!'), "version_conflict");
                  return;
                }
              }
            } catch (e_26_1) {
              e_26 = { error: e_26_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a3 = _b2.return))
                  _a3.call(_b2);
              } finally {
                if (e_26)
                  throw e_26.error;
              }
            }
          };
          MiniSearch2.prototype.addDocumentId = function(documentId) {
            var shortDocumentId = this._nextId;
            this._idToShortId.set(documentId, shortDocumentId);
            this._documentIds.set(shortDocumentId, documentId);
            this._documentCount += 1;
            this._nextId += 1;
            return shortDocumentId;
          };
          MiniSearch2.prototype.addFields = function(fields) {
            for (var i = 0; i < fields.length; i++) {
              this._fieldIds[fields[i]] = i;
            }
          };
          MiniSearch2.prototype.addFieldLength = function(documentId, fieldId, count2, length) {
            var fieldLengths = this._fieldLength.get(documentId);
            if (fieldLengths == null)
              this._fieldLength.set(documentId, fieldLengths = []);
            fieldLengths[fieldId] = length;
            var averageFieldLength = this._avgFieldLength[fieldId] || 0;
            var totalFieldLength = averageFieldLength * count2 + length;
            this._avgFieldLength[fieldId] = totalFieldLength / (count2 + 1);
          };
          MiniSearch2.prototype.removeFieldLength = function(documentId, fieldId, count2, length) {
            if (count2 === 1) {
              this._avgFieldLength[fieldId] = 0;
              return;
            }
            var totalFieldLength = this._avgFieldLength[fieldId] * count2 - length;
            this._avgFieldLength[fieldId] = totalFieldLength / (count2 - 1);
          };
          MiniSearch2.prototype.saveStoredFields = function(documentId, doc) {
            var e_27, _a3;
            var _b2 = this._options, storeFields = _b2.storeFields, extractField = _b2.extractField;
            if (storeFields == null || storeFields.length === 0) {
              return;
            }
            var documentFields = this._storedFields.get(documentId);
            if (documentFields == null)
              this._storedFields.set(documentId, documentFields = {});
            try {
              for (var storeFields_1 = __values(storeFields), storeFields_1_1 = storeFields_1.next(); !storeFields_1_1.done; storeFields_1_1 = storeFields_1.next()) {
                var fieldName = storeFields_1_1.value;
                var fieldValue = extractField(doc, fieldName);
                if (fieldValue !== void 0)
                  documentFields[fieldName] = fieldValue;
              }
            } catch (e_27_1) {
              e_27 = { error: e_27_1 };
            } finally {
              try {
                if (storeFields_1_1 && !storeFields_1_1.done && (_a3 = storeFields_1.return))
                  _a3.call(storeFields_1);
              } finally {
                if (e_27)
                  throw e_27.error;
              }
            }
          };
          MiniSearch2.wildcard = Symbol("*");
          return MiniSearch2;
        }()
      );
      var getOwnProperty = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : void 0;
      };
      var combinators = (_a = {}, _a[OR] = function(a, b) {
        var e_28, _a3;
        try {
          for (var _b2 = __values(b.keys()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var docId = _c.value;
            var existing = a.get(docId);
            if (existing == null) {
              a.set(docId, b.get(docId));
            } else {
              var _d = b.get(docId), score = _d.score, terms = _d.terms, match2 = _d.match;
              existing.score = existing.score + score;
              existing.match = Object.assign(existing.match, match2);
              assignUniqueTerms(existing.terms, terms);
            }
          }
        } catch (e_28_1) {
          e_28 = { error: e_28_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_28)
              throw e_28.error;
          }
        }
        return a;
      }, _a[AND] = function(a, b) {
        var e_29, _a3;
        var combined = /* @__PURE__ */ new Map();
        try {
          for (var _b2 = __values(b.keys()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var docId = _c.value;
            var existing = a.get(docId);
            if (existing == null)
              continue;
            var _d = b.get(docId), score = _d.score, terms = _d.terms, match2 = _d.match;
            assignUniqueTerms(existing.terms, terms);
            combined.set(docId, {
              score: existing.score + score,
              terms: existing.terms,
              match: Object.assign(existing.match, match2)
            });
          }
        } catch (e_29_1) {
          e_29 = { error: e_29_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_29)
              throw e_29.error;
          }
        }
        return combined;
      }, _a[AND_NOT] = function(a, b) {
        var e_30, _a3;
        try {
          for (var _b2 = __values(b.keys()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var docId = _c.value;
            a.delete(docId);
          }
        } catch (e_30_1) {
          e_30 = { error: e_30_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_30)
              throw e_30.error;
          }
        }
        return a;
      }, _a);
      var defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };
      var calcBM25Score = function(termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) {
        var k = bm25params.k, b = bm25params.b, d = bm25params.d;
        var invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));
        return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));
      };
      var termToQuerySpec = function(options2) {
        return function(term, i, terms) {
          var fuzzy = typeof options2.fuzzy === "function" ? options2.fuzzy(term, i, terms) : options2.fuzzy || false;
          var prefix = typeof options2.prefix === "function" ? options2.prefix(term, i, terms) : options2.prefix === true;
          return { term, fuzzy, prefix };
        };
      };
      var defaultOptions = {
        idField: "id",
        extractField: function(document2, fieldName) {
          return document2[fieldName];
        },
        tokenize: function(text2) {
          return text2.split(SPACE_OR_PUNCTUATION);
        },
        processTerm: function(term) {
          return term.toLowerCase();
        },
        fields: void 0,
        searchOptions: void 0,
        storeFields: [],
        logger: function(level, message2) {
          if (typeof (console === null || console === void 0 ? void 0 : console[level]) === "function")
            console[level](message2);
        },
        autoVacuum: true
      };
      var defaultSearchOptions = {
        combineWith: OR,
        prefix: false,
        fuzzy: false,
        maxFuzzy: 6,
        boost: {},
        weights: { fuzzy: 0.45, prefix: 0.375 },
        bm25: defaultBM25params
      };
      var defaultAutoSuggestOptions = {
        combineWith: AND,
        prefix: function(term, i, terms) {
          return i === terms.length - 1;
        }
      };
      var defaultVacuumOptions = { batchSize: 1e3, batchWait: 10 };
      var defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };
      var defaultAutoVacuumOptions = __assign(__assign({}, defaultVacuumOptions), defaultVacuumConditions);
      var assignUniqueTerm = function(target, term) {
        if (!target.includes(term))
          target.push(term);
      };
      var assignUniqueTerms = function(target, source) {
        var e_31, _a3;
        try {
          for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
            var term = source_1_1.value;
            if (!target.includes(term))
              target.push(term);
          }
        } catch (e_31_1) {
          e_31 = { error: e_31_1 };
        } finally {
          try {
            if (source_1_1 && !source_1_1.done && (_a3 = source_1.return))
              _a3.call(source_1);
          } finally {
            if (e_31)
              throw e_31.error;
          }
        }
      };
      var byScore = function(_a3, _b2) {
        var a = _a3.score;
        var b = _b2.score;
        return b - a;
      };
      var createMap = function() {
        return /* @__PURE__ */ new Map();
      };
      var objectToNumericMap = function(object) {
        var e_32, _a3;
        var map2 = /* @__PURE__ */ new Map();
        try {
          for (var _b2 = __values(Object.keys(object)), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var key = _c.value;
            map2.set(parseInt(key, 10), object[key]);
          }
        } catch (e_32_1) {
          e_32 = { error: e_32_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_32)
              throw e_32.error;
          }
        }
        return map2;
      };
      var SPACE_OR_PUNCTUATION = /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;
      const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
      let idbProxyableTypes;
      let cursorAdvanceMethods;
      function getIdbProxyableTypes() {
        return idbProxyableTypes || (idbProxyableTypes = [
          IDBDatabase,
          IDBObjectStore,
          IDBIndex,
          IDBCursor,
          IDBTransaction
        ]);
      }
      function getCursorAdvanceMethods() {
        return cursorAdvanceMethods || (cursorAdvanceMethods = [
          IDBCursor.prototype.advance,
          IDBCursor.prototype.continue,
          IDBCursor.prototype.continuePrimaryKey
        ]);
      }
      const transactionDoneMap = /* @__PURE__ */ new WeakMap();
      const transformCache = /* @__PURE__ */ new WeakMap();
      const reverseTransformCache = /* @__PURE__ */ new WeakMap();
      function promisifyRequest(request) {
        const promise = new Promise((resolve, reject) => {
          const unlisten = () => {
            request.removeEventListener("success", success);
            request.removeEventListener("error", error);
          };
          const success = () => {
            resolve(wrap$3(request.result));
            unlisten();
          };
          const error = () => {
            reject(request.error);
            unlisten();
          };
          request.addEventListener("success", success);
          request.addEventListener("error", error);
        });
        reverseTransformCache.set(promise, request);
        return promise;
      }
      function cacheDonePromiseForTransaction(tx) {
        if (transactionDoneMap.has(tx))
          return;
        const done = new Promise((resolve, reject) => {
          const unlisten = () => {
            tx.removeEventListener("complete", complete);
            tx.removeEventListener("error", error);
            tx.removeEventListener("abort", error);
          };
          const complete = () => {
            resolve();
            unlisten();
          };
          const error = () => {
            reject(tx.error || new DOMException("AbortError", "AbortError"));
            unlisten();
          };
          tx.addEventListener("complete", complete);
          tx.addEventListener("error", error);
          tx.addEventListener("abort", error);
        });
        transactionDoneMap.set(tx, done);
      }
      let idbProxyTraps = {
        get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
            if (prop === "done")
              return transactionDoneMap.get(target);
            if (prop === "store") {
              return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
            }
          }
          return wrap$3(target[prop]);
        },
        set(target, prop, value) {
          target[prop] = value;
          return true;
        },
        has(target, prop) {
          if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
            return true;
          }
          return prop in target;
        }
      };
      function replaceTraps(callback2) {
        idbProxyTraps = callback2(idbProxyTraps);
      }
      function wrapFunction(func) {
        if (getCursorAdvanceMethods().includes(func)) {
          return function(...args) {
            func.apply(unwrap$1(this), args);
            return wrap$3(this.request);
          };
        }
        return function(...args) {
          return wrap$3(func.apply(unwrap$1(this), args));
        };
      }
      function transformCachableValue(value) {
        if (typeof value === "function")
          return wrapFunction(value);
        if (value instanceof IDBTransaction)
          cacheDonePromiseForTransaction(value);
        if (instanceOfAny(value, getIdbProxyableTypes()))
          return new Proxy(value, idbProxyTraps);
        return value;
      }
      function wrap$3(value) {
        if (value instanceof IDBRequest)
          return promisifyRequest(value);
        if (transformCache.has(value))
          return transformCache.get(value);
        const newValue = transformCachableValue(value);
        if (newValue !== value) {
          transformCache.set(value, newValue);
          reverseTransformCache.set(newValue, value);
        }
        return newValue;
      }
      const unwrap$1 = (value) => reverseTransformCache.get(value);
      function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
        const request = indexedDB.open(name2, version2);
        const openPromise = wrap$3(request);
        if (upgrade) {
          request.addEventListener("upgradeneeded", (event) => {
            upgrade(wrap$3(request.result), event.oldVersion, event.newVersion, wrap$3(request.transaction), event);
          });
        }
        if (blocked) {
          request.addEventListener("blocked", (event) => blocked(
            // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
            event.oldVersion,
            event.newVersion,
            event
          ));
        }
        openPromise.then((db) => {
          if (terminated)
            db.addEventListener("close", () => terminated());
          if (blocking) {
            db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
          }
        }).catch(() => {
        });
        return openPromise;
      }
      const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
      const writeMethods = ["put", "add", "delete", "clear"];
      const cachedMethods = /* @__PURE__ */ new Map();
      function getMethod(target, prop) {
        if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
          return;
        }
        if (cachedMethods.get(prop))
          return cachedMethods.get(prop);
        const targetFuncName = prop.replace(/FromIndex$/, "");
        const useIndex = prop !== targetFuncName;
        const isWrite = writeMethods.includes(targetFuncName);
        if (
          // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
          !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
        ) {
          return;
        }
        const method = function(storeName, ...args) {
          return __async(this, null, function* () {
            const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
            let target2 = tx.store;
            if (useIndex)
              target2 = target2.index(args.shift());
            return (yield Promise.all([
              target2[targetFuncName](...args),
              isWrite && tx.done
            ]))[0];
          });
        };
        cachedMethods.set(prop, method);
        return method;
      }
      replaceTraps((oldTraps) => __spreadProps(__spreadValues({}, oldTraps), {
        get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
        has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
      }));
      const advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
      const methodMap = {};
      const advanceResults = /* @__PURE__ */ new WeakMap();
      const ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
      const cursorIteratorTraps = {
        get(target, prop) {
          if (!advanceMethodProps.includes(prop))
            return target[prop];
          let cachedFunc = methodMap[prop];
          if (!cachedFunc) {
            cachedFunc = methodMap[prop] = function(...args) {
              advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
            };
          }
          return cachedFunc;
        }
      };
      function iterate(...args) {
        return __asyncGenerator(this, null, function* () {
          let cursor = this;
          if (!(cursor instanceof IDBCursor)) {
            cursor = yield new __await(cursor.openCursor(...args));
          }
          if (!cursor)
            return;
          cursor = cursor;
          const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
          ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
          reverseTransformCache.set(proxiedCursor, unwrap$1(cursor));
          while (cursor) {
            yield proxiedCursor;
            cursor = yield new __await(advanceResults.get(proxiedCursor) || cursor.continue());
            advanceResults.delete(proxiedCursor);
          }
        });
      }
      function isIteratorProp(target, prop) {
        return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
      }
      replaceTraps((oldTraps) => __spreadProps(__spreadValues({}, oldTraps), {
        get(target, prop, receiver) {
          if (isIteratorProp(target, prop))
            return iterate;
          return oldTraps.get(target, prop, receiver);
        },
        has(target, prop) {
          return isIteratorProp(target, prop) || oldTraps.has(target, prop);
        }
      }));
      const cachedDatabase = openDB("solid-telekram", 5, {
        upgrade: (db, oldVersion, newVersion) => {
          const tables = ["appPreferences"];
          tables.forEach((n2) => {
            if (!db.objectStoreNames.contains(n2))
              db.createObjectStore(n2);
          });
        }
      });
      if ("serviceWorker" in navigator) {
        console.log("START SERVICE WORKER");
        navigator.serviceWorker.register("/sw.js").then(() => {
          if (navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage({ type: 1, visibilityState: document.visibilityState });
            navigator.serviceWorker.addEventListener("message", (event) => {
              console.log("[SW]addEventListener:", event.data);
            });
          }
        }).catch((error) => {
          console.error("Service Worker", error);
        });
      } else {
        console.warn("Service Worker not supported");
      }
      if ("mozSetMessageHandler" in navigator) {
        navigator.mozSetMessageHandler("serviceworker-notification", () => {
          if (navigator.mozApps) {
            let request = navigator.mozApps.getSelf();
            request.onsuccess = () => {
              if (request.result) {
                request.result.launch();
              }
            };
          } else {
            window.open(document.location.origin, "_blank");
          }
        });
      }
      document.addEventListener("visibilitychange", () => {
        var _a3;
        (_a3 = navigator.serviceWorker.controller) == null ? void 0 : _a3.postMessage({ type: 1, visibilityState: document.visibilityState });
      });
      function subscribePush() {
        return new Promise((resolve, reject) => {
          Notification.requestPermission().then((result) => {
            if (result === "granted")
              return navigator.serviceWorker.ready;
            return Promise.reject("Denied");
          }).then((reg) => {
            return reg.pushManager.subscribe({ userVisibleOnly: true });
          }).then((subscription) => {
            if (subscription)
              resolve(subscription);
            else
              reject(subscription);
          }).catch((err) => {
            reject(err);
          });
        });
      }
      function unsubscribePush() {
        return new Promise((resolve, reject) => {
          getPushSubscription().then((subscription) => {
            if (!subscription)
              reject("Please subscribe");
            else
              return subscription.unsubscribe();
          }).then((result) => {
            resolve(result);
          }).catch((err) => {
            reject(err);
          });
        });
      }
      function getPushSubscription() {
        return new Promise((resolve, reject) => {
          navigator.serviceWorker.ready.then((reg) => {
            return reg.pushManager.getSubscription();
          }).then((subscription) => {
            if (!subscription)
              reject("Please subscribe");
            else
              resolve(subscription);
          }).catch((err) => {
            reject(err);
          });
        });
      }
      function registerDevice(tg, subscription) {
        return __async(this, null, function* () {
          const data2 = readStringSession(yield tg.exportSession());
          console.error("REGISTER DEVICE", subscription);
          const result = yield tg.call({
            _: "account.registerDevice",
            tokenType: 10,
            token: JSON.stringify(subscription),
            otherUids: [],
            appSandbox: false,
            secret: data2.authKey
          });
          yield (yield cachedDatabase).put("appPreferences", subscription, "pushSubscription");
          return result;
        });
      }
      function unregisterDevice(tg, subscription) {
        return __async(this, null, function* () {
          console.error("UNREGISTER DEVICE", subscription);
          const result = yield tg.call({
            _: "account.unregisterDevice",
            tokenType: 10,
            token: JSON.stringify(subscription),
            otherUids: []
          });
          yield (yield cachedDatabase).delete("appPreferences", "pushSubscription");
          return result;
        });
      }
      function manuallySubscribePushNotification(client2) {
        return __async(this, null, function* () {
          try {
            (yield cachedDatabase).delete("appPreferences", "updatedPushSubscription");
            let pushSubscription = yield (yield cachedDatabase).get("appPreferences", "pushSubscription");
            if (pushSubscription) {
              yield unregisterDevice(client2, pushSubscription);
            }
            try {
              yield unsubscribePush();
            } catch (err) {
            }
            pushSubscription = yield subscribePush();
            pushSubscription = pushSubscription.toJSON();
            delete pushSubscription["expirationTime"];
            yield registerDevice(client2, pushSubscription);
            return Promise.resolve(true);
          } catch (err) {
            return Promise.reject(err);
          }
        });
      }
      dayjs.extend(duration);
      dayjs.extend(relativeTime);
      const [softleft, setSoftleft] = createSignal("");
      const [softcenter, setSoftcenter] = createSignal("");
      const [softright, setSoftright] = createSignal("");
      const [softkeysLoading, setSoftkeysLoading] = createSignal(false);
      const [softkeysBlack, setSoftkeysBlack] = createSignal(false);
      const [statusbarColor, setStatusbarColor] = createSignal("#000");
      observable(statusbarColor).subscribe((color2) => {
        var _a3;
        (_a3 = document.head.querySelector(`meta[name="theme-color"]`)) == null ? void 0 : _a3.setAttribute("content", color2);
      });
      function setSoftkeys(left, center, right, loading2, black) {
        batch(() => {
          left != void 0 && setSoftleft(left);
          center != void 0 && setSoftcenter(center);
          right != void 0 && setSoftright(right);
          loading2 == void 0 ? setSoftkeysLoading(false) : setSoftkeysLoading(Boolean(loading2));
          black == void 0 ? setSoftkeysBlack(false) : setSoftkeysBlack(Boolean(black));
        });
      }
      const [currentView, setView] = createSignal("loading");
      const [previousView, setPreviousView] = createSignal("home");
      const [messageInfo, setMessageInfo] = createSignal(null);
      const [replyingMessage, setReplyingMessage] = createSignal(null);
      const [editingMessage, setEditingMessage] = createSignal(null);
      const [room$1, setRoom] = createSignal(null);
      const [uiDialog, setUIDialog] = createSignal(null);
      const [cachedContacts, setCachedContacts] = createSignal([]);
      function reloadCachedContacts() {
        return __async(this, null, function* () {
          let contacts;
          try {
            setCachedContacts(contacts = yield client().getContacts());
            return contacts;
          } catch (e2) {
            toaster("Error occured while trying to reload contacts!");
            return [];
          }
        });
      }
      const chat = createMemo(() => {
        const _room = room$1();
        return _room && "$" in _room ? _room.$.chat : _room;
      });
      const EE$1 = new EventEmitter();
      var LoginState = /* @__PURE__ */ ((LoginState2) => {
        LoginState2[LoginState2["Phone"] = 0] = "Phone";
        LoginState2[LoginState2["Password"] = 1] = "Password";
        LoginState2[LoginState2["Code"] = 2] = "Code";
        return LoginState2;
      })(LoginState || {});
      const [loginState, setLoginState] = createSignal(
        0
        /* Phone */
      );
      const [qrLink, setQrLink] = createSignal(null);
      const [client, setClient] = createSignal(null);
      class UITypingIndicatorUser {
        constructor(id2) {
          __publicField(this, "status", writable(null));
          __publicField(this, "timeout");
          this.id = id2;
        }
        update(newStatus) {
          clearTimeout(this.timeout);
          if (newStatus == "cancel") {
            this.status.set(null);
            return;
          }
          this.status.set(newStatus);
          this.timeout = setTimeout(() => {
            this.status.set(null);
          }, 6e3);
        }
      }
      class TypingIndicatorUserJar extends Map {
        get(id2) {
          const has2 = super.get(id2);
          if (has2) {
            return has2;
          }
          const indicator = new UITypingIndicatorUser(id2);
          this.set(id2, indicator);
          return indicator;
        }
      }
      const typingIndicatorUserJar = new TypingIndicatorUserJar();
      class UIPoll {
        constructor($2) {
          __publicField(this, "closed", writable(false));
          __publicField(this, "results", writable(null));
          this.$ = $2;
          this.update($2);
          pollJar.set($2.id.toInt(), this);
        }
        update($2) {
          this.$ = $2;
          $2.results && this.results.set($2.results);
          this.closed.set($2.isClosed);
        }
        resultsUpdate($2) {
          this.results.set($2);
        }
      }
      class PollJar extends Map {
        add($2) {
          const id2 = $2.id.toInt();
          const has2 = this.get(id2);
          if (has2) {
            has2.update($2);
            return has2;
          }
          const uiPoll = new UIPoll($2);
          this.set(id2, uiPoll);
          return uiPoll;
        }
      }
      const pollJar = new PollJar();
      class UIMessage {
        constructor($2, cache = false) {
          __publicField(this, "text");
          __publicField(this, "entities");
          __publicField(this, "editDate");
          __publicField(this, "date");
          __publicField(this, "id");
          __publicField(this, "sender");
          __publicField(this, "isOutgoing");
          __publicField(this, "isSticker", false);
          __publicField(this, "__replyToCache");
          __publicField(this, "__deferredReply", new Deferred());
          __publicField(this, "__isGettingUser", false);
          __publicField(this, "isLocation", false);
          __publicField(this, "isUnsupported", writable(false));
          /**
           * this means this will render synchrously (no scroll jumps)
           */
          __publicField(this, "sync", true);
          __publicField(this, "poll", null);
          var _a3;
          this.$ = $2;
          this.cache = cache;
          this.entities = writable($2.textWithEntities);
          this.text = writable($2.text);
          this.updateText($2);
          this.editDate = writable($2.editDate);
          this.date = $2.date;
          this.id = $2.id;
          this.sender = $2.sender;
          this.isOutgoing = $2.chat.isSelf && !$2.isOutgoing ? true : $2.isOutgoing;
          this.poll = ((_a3 = $2.media) == null ? void 0 : _a3.type) == "poll" ? pollJar.add($2.media) : null;
        }
        updateText($2) {
          let newText = $2.text;
          this.sync = true;
          if ($2.action) {
            switch ($2.action.type) {
              case "chat_created": {
                newText = ($2.isOutgoing ? "You" : $2.sender.displayName) + " created the group";
                break;
              }
              case "title_changed": {
                newText = $2.sender.displayName + ' changed the group name to "' + $2.action.title + '"';
                break;
              }
              case "message_pinned": {
                this.sync = false;
                this.getReply().then((msg) => {
                  if (msg) {
                    const text2 = msg.$.text;
                    const ellipses = (text22) => {
                      const e2 = text22.slice(0, 52);
                      if (e2.length != text22.length) {
                        return e2 + "...";
                      }
                      return text22;
                    };
                    this.text.set($2.sender.displayName + ' pinned "' + ellipses(text2) + '"');
                  }
                });
                newText = $2.sender.displayName + " pinned a message";
                break;
              }
              case "users_added": {
                const sender2 = $2.isOutgoing ? "You" : $2.sender.displayName;
                if ($2.action.users[0] === $2.sender.id) {
                  newText = sender2 + " joined the group";
                  break;
                }
                this.sync = false;
                client().getUsers($2.action.users[0]).then((_user) => {
                  const user = _user[0];
                  if (user) {
                    this.text.set(sender2 + " added " + user.displayName);
                  } else {
                    console.error("USER NOT FOUND", $2.action.users);
                  }
                });
                if (!this.__isGettingUser) {
                  newText = sender2 + " added a user";
                  this.__isGettingUser = true;
                } else {
                  return;
                }
                break;
              }
              case "user_removed": {
                const sender2 = $2.isOutgoing ? "You" : $2.sender.displayName;
                if ($2.action.user === $2.sender.id) {
                  newText = sender2 + " left the group";
                  break;
                }
                this.sync = false;
                client().getUsers($2.action.user).then((_user) => {
                  const user = _user[0];
                  if (user) {
                    this.text.set(sender2 + " removed " + user.displayName);
                  } else {
                    console.error("USER NOT FOUND", $2.action.user);
                  }
                });
                if (!this.__isGettingUser) {
                  newText = sender2 + " removed a user";
                  this.__isGettingUser = true;
                } else {
                  return;
                }
                break;
              }
              case "user_left":
                newText = $2.sender.displayName + " left the group";
                break;
              case "topic_created":
                newText = $2.action.title + " was created";
                break;
              case "topic_edited":
                if ($2.action.closed) {
                  newText = $2.sender.displayName + " closed the topic";
                }
                break;
              case "call":
                if ($2.action.duration) {
                  newText = ($2.isOutgoing ? "Outgoing Call" : "Incoming Call") + ` (${dayjs.duration($2.action.duration, "s").humanize()})`;
                } else if ($2.action.reason) {
                  switch ($2.action.reason) {
                    case "busy":
                      newText = "Call Busy";
                      break;
                    case "disconnect":
                      newText = "Call Disconnected";
                      break;
                    case "hangup":
                      newText = "Call Ended";
                      break;
                    case "missed":
                      newText = "Missed Call";
                      break;
                  }
                }
                break;
              case "user_joined_link":
                newText = $2.sender.displayName + "  joined the group via invite link";
                break;
              case "custom":
                newText = $2.action.action;
                break;
              case "contact_joined":
                newText = "Joined Telegram";
                break;
              default: {
                newText = "Unsupported Message Action: " + $2.action.type;
              }
            }
          }
          if ($2.media) {
            switch ($2.media.type) {
              case "location": {
                newText = "Location";
                this.isLocation = true;
                break;
              }
              case "photo": {
                newText = "Photo";
                break;
              }
              case "webpage": {
                break;
              }
              case "sticker": {
                newText = $2.media.emoji + " Sticker";
                this.isSticker = true;
                break;
              }
              case "video": {
                newText = "Video";
                if ($2.media.isAnimation || $2.media.isLegacyGif) {
                  newText = "GIF";
                }
                break;
              }
              case "voice":
                newText = `🎤 Voice (${formatTime($2.media.duration)})`;
                break;
              default: {
                this.isUnsupported.set(true);
                console.log("unsupported media type:", $2.media.type, $2);
                newText = capitalizeFirstLetter($2.media.type.split("_").join(" "));
              }
            }
          }
          this.text.set(newText);
        }
        getReply(_dialog) {
          return __async(this, null, function* () {
            if (!this.$.replyToMessage)
              return null;
            if (this.__replyToCache) {
              return this.__deferredReply.promise;
            }
            const promise = client().getReplyTo(this.$).then((msg) => {
              if (msg) {
                const dialog2 = _dialog || dialogsJar.get(msg.chat.peer.id);
                if (dialog2) {
                  const _msg = dialog2.messages.addCached(msg);
                  this.__deferredReply.resolve(_msg);
                  this.__replyToCache = _msg;
                  return _msg;
                }
                return new UIMessage(msg);
              } else {
                this.__replyToCache = null;
                this.__deferredReply.resolve(null);
                return null;
              }
            });
            this.__replyToCache = 1;
            return promise;
          });
        }
        update($2) {
          this.$ = $2;
          this.entities.set($2.textWithEntities);
          this.updateText($2);
          this.editDate.set($2.editDate);
        }
        getDialog() {
          return dialogsJar.get(this.$.chat.peer.id) || null;
        }
        // decide whether the reply thing should show up idk
        isReply() {
          var _a3, _b2;
          const replyToMessage = this.$.replyToMessage;
          if (!replyToMessage)
            return false;
          if (replyToMessage.threadId === replyToMessage.id)
            return false;
          const isForum = this.$.chat.isForum;
          const raw = (_a3 = this.$.replyToMessage) == null ? void 0 : _a3.raw;
          (_b2 = this.$.replyToMessage) == null ? void 0 : _b2.origin;
          if (raw && isForum && raw.forumTopic && !raw.replyToTopId) {
            return false;
          }
          return !!this.$.replyToMessage;
        }
        // thanks mtcute guy
        canEdit() {
          var _a3;
          const messsage = this.$;
          if (messsage.raw._ != "message")
            return false;
          if (this.cache)
            return false;
          if (this.$.forward)
            return false;
          if (this.$.chat.isSelf && this.$.sender.isSelf) {
            return true;
          }
          if (!this.isOutgoing)
            return false;
          if (messsage.chat.chatType == "channel" && messsage.chat.isAdmin) {
            return true;
          }
          const diff = dayjs().diff(dayjs(messsage.date), "day");
          const hasPinnedPermission = (() => {
            const dialog2 = this.getDialog();
            const permissions = dialog2 && get_store_value(dialog2.permissions) || this.$.chat.permissions;
            if ((permissions == null ? void 0 : permissions.canPinMessages) === true) {
              return true;
            }
            return null;
          })();
          switch ((_a3 = messsage.media) == null ? void 0 : _a3.type) {
            case "game":
            case "paid":
            case "sticker":
            case "document":
            case "poll":
            case "contact":
            case "dice":
            case "venue":
            case "invoice":
            case "location":
            case "story":
              return false;
            case "webpage":
            case "audio":
            case "photo":
            case "video":
            case "voice":
              break;
            case "live_location":
              return Date.now() - messsage.date.getTime() < messsage.media.period;
          }
          if (hasPinnedPermission === true) {
            return true;
          }
          return diff < 2;
        }
      }
      class MessagesJar extends Map {
        constructor(dialog2) {
          super();
          __publicField(this, "sorted", writable([]));
          __publicField(this, "isLoading", writable(false));
          __publicField(this, "isLoadingMore", writable(false));
          __publicField(this, "lastOffset");
          __publicField(this, "hasLoadedBefore", false);
          this.dialog = dialog2;
        }
        /* add cached message, aka message that should not be shown in the UI */
        addCached($2) {
          return this.add($2, false, true);
        }
        add($2, sort = true, cache = false) {
          let message2;
          if (this.has($2.id)) {
            const has2 = this.get($2.id);
            has2.update($2 instanceof UIMessage ? $2.$ : $2);
            if (has2.cache && !cache) {
              has2.cache = false;
            }
            message2 = has2;
          } else {
            message2 = $2 instanceof UIMessage ? $2 : new UIMessage($2, cache);
          }
          this.set($2.id, message2);
          sort && this.sort();
          return message2;
        }
        addBulk(messages) {
          const _ = messages.map((a) => this.add(a, false));
          this.sort();
          return _;
        }
        list() {
          const arr = [];
          for(let   m2 of this.values()) {
            if (!m2.cache)
              arr.push(m2);
          }
          return arr;
        }
        sort() {
          const messages = this.list();
          messages.sort((a, b) => {
            return a.date.getTime() - b.date.getTime();
          });
          this.sorted.set(messages);
        }
        delete(id2) {
          const deleted = super.delete(id2);
          this.sort();
          return deleted;
        }
        deleteBulk(ids) {
          const deleted = ids.map((id2) => super.delete(id2));
          this.sort();
          return deleted;
        }
        /**
         * updates a message inside the jar, if it doesn't exist in the jar it adds it
         */
        update(id2, $2, cache = false) {
          const has2 = this.get(id2);
          if (has2) {
            has2.update($2);
            return has2;
          }
          return this.add(new UIMessage($2, cache));
        }
        loadMore() {
          return __async(this, null, function* () {
            const tg = client();
            if (!tg) {
              throw new Error("CLIENT IS NOT READY!");
            }
            if (get_store_value(this.isLoadingMore)) {
              return;
            }
            if (this.hasLoadedBefore && !this.lastOffset) {
              console.log("last offset is undefined, end has reached maybe?");
              toaster("You have reached the end of chat.");
              return;
            }
            const hasLoadedBefore = this.hasLoadedBefore;
            this[hasLoadedBefore ? "isLoadingMore" : "isLoading"].set(true);
            if (hasLoadedBefore) {
              toaster("Loading more messages...");
            }
            try {
              const e2 = yield tg.getHistory(this.dialog.$.chat, {
                limit: localStorage.getItem("low_memory") ? 10 : 40,
                offset: this.lastOffset
              });
              this.hasLoadedBefore = true;
              this.lastOffset = e2.next;
              this.addBulk(e2);
            } catch (e2) {
              toaster(((e2 == null ? void 0 : e2.name) || "Unknown Error") + ": " + ((e2 == null ? void 0 : e2.message) || "???"));
            }
            this[hasLoadedBefore ? "isLoadingMore" : "isLoading"].set(false);
          });
        }
      }
      let visibilityTimeout;
      document.addEventListener("visibilitychange", () => {
        var _a3;
        const hidden2 = () => document.visibilityState == "hidden";
        console.error("visibilityState", hidden2());
        clearTimeout(visibilityTimeout);
        if (!hidden2()) {
          (_a3 = client()) == null ? void 0 : _a3.setOffline(false);
        }
        visibilityTimeout = setTimeout(() => {
          var _a4;
          if (hidden2()) {
            (_a4 = client()) == null ? void 0 : _a4.setOffline(true);
          }
        }, 25e3);
      });
      class DialogsJar extends Map {
        list() {
          return Array.from(this.values());
        }
        add($2) {
          if ("id" in $2) {
            this.set($2.id, $2);
            return $2;
          }
          const id2 = $2.chat.peer.id;
          const has2 = this.get(id2);
          if (has2) {
            has2.update($2);
            return has2;
          } else {
            return this.add(new UIDialog($2));
          }
        }
      }
      const dialogsJar = new DialogsJar();
      const readHistoryQueue = new Queue({
        autostart: true,
        concurrency: 1
      });
      function _readHistory(dialog2) {
        return __async(this, null, function* () {
          const tg = client();
          let changed = false;
          if (get_store_value(dialog2.count) || get_store_value(dialog2.countMention)) {
            yield tg.readHistory(dialog2.$.chat, {
              maxId: 0,
              clearMentions: true
            });
            changed = true;
          }
          if (get_store_value(dialog2.countReaction)) {
            yield tg.readReactions(dialog2);
            changed = true;
          }
          yield sleep$1(100);
          if (changed)
            yield dialog2.refreshByPeer();
        });
      }
      function readHistory(dialog2) {
        return new Promise((res) => {
          readHistoryQueue.push(() => __async(this, null, function* () {
            yield _readHistory(dialog2);
            res();
          }));
        });
      }
      class UIDialog {
        constructor($2) {
          __publicField(this, "lastMessage");
          __publicField(this, "pinned");
          __publicField(this, "count");
          __publicField(this, "countMention");
          __publicField(this, "countReaction");
          __publicField(this, "muted");
          __publicField(this, "messages", new MessagesJar(this));
          __publicField(this, "lastReadOutgoing");
          __publicField(this, "lastReadIngoing");
          __publicField(this, "id");
          __publicField(this, "joinDate", null);
          __publicField(this, "memberCount", writable(null));
          __publicField(this, "inputPeer");
          __publicField(this, "permissions");
          this.$ = $2;
          const peer = $2.chat.peer;
          if ("status" in peer && peer.status) {
            const update = new UserStatusUpdate({
              _: "updateUserStatus",
              userId: peer.id,
              status: peer.status
            });
            userStatusJar.get(peer.id).update(update);
          }
          this.permissions = writable($2.chat.permissions);
          this.lastMessage = writable($2.lastMessage ? this.messages.add(new UIMessage($2.lastMessage)) : null);
          this.inputPeer = $2.chat.inputPeer;
          this.pinned = writable($2.isPinned);
          this.count = writable($2.unreadCount);
          this.countMention = writable($2.unreadMentionsCount);
          this.countReaction = writable($2.unreadReactionsCount);
          this.muted = writable(typeof $2.raw.notifySettings.muteUntil == "number");
          this.lastReadOutgoing = writable($2.lastReadOutgoing);
          this.lastReadIngoing = writable($2.lastReadIngoing);
          this.id = peer.id;
          if ("date" in peer) {
            this.joinDate = new Date(peer.date * 1e3);
          }
          if ("participantsCount" in peer && peer.participantsCount) {
            this.memberCount.set(peer.participantsCount);
          }
        }
        update($2) {
          const peer = $2.chat.peer;
          this.lastMessage.set($2.lastMessage ? this.messages.update($2.lastMessage.id, $2.lastMessage) : null);
          this.$ = $2;
          this.inputPeer = $2.chat.inputPeer;
          this.pinned.set($2.isPinned);
          this.count.set($2.unreadCount);
          this.countMention.set($2.unreadMentionsCount);
          this.countReaction.set($2.unreadReactionsCount);
          this.muted.set(typeof $2.raw.notifySettings.muteUntil == "number");
          this.lastReadOutgoing.set($2.lastReadOutgoing);
          this.lastReadIngoing.set($2.lastReadIngoing);
          if ("participantsCount" in peer && peer.participantsCount) {
            this.memberCount.set(peer.participantsCount);
          }
          this.permissions.set($2.chat.permissions);
        }
        refreshByPeer() {
          return refreshDialogsByPeer([this.$.chat]);
        }
        readHistory() {
          return readHistory(this);
        }
      }
      function sortDialogs(dialogs2) {
        const pinned = [];
        const unpinned = [];
        for (let i = 0; i < dialogs2.length; i++) {
          const dialog2 = dialogs2[i];
          if (get_store_value(dialog2.pinned)) {
            pinned.push(dialog2);
          } else {
            unpinned.push(dialog2);
          }
        }
        unpinned.sort((a, b) => {
          var _a4, _b3, _c, _d;
          const _a3 = (_a4 = get_store_value(a.lastMessage)) == null ? void 0 : _a4.date.getTime();
          const _b2 = (_b3 = get_store_value(b.lastMessage)) == null ? void 0 : _b3.date.getTime();
          const a_date = (_c = a.joinDate) == null ? void 0 : _c.getTime();
          const b_date = (_d = b.joinDate) == null ? void 0 : _d.getTime();
          let compare1 = null;
          let compare2 = null;
          if (_a3) {
            compare1 = _a3;
          }
          if (a_date && (_a3 || 0) < a_date) {
            compare1 = a_date;
          }
          if (_b2) {
            compare2 = _b2;
          }
          if (b_date && (_b2 || 0) < b_date) {
            compare2 = b_date;
          }
          if (!compare1 || !compare2)
            return 0;
          return compare2 - compare1;
        });
        return pinned.concat(unpinned);
      }
      const [dialogs$1, setDialogs] = createSignal([]);
      function initDialogs(tg) {
        return __async(this, null, function* () {
          const dialogs2 = [];
          try {
            for (var iter = __forAwait(tg.iterDialogs({
              pinned: "keep",
              archived: "exclude"
            })), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const dialog2 = temp.value;
              if ("left" in dialog2.chat.peer && dialog2.chat.peer.left) {
                continue;
              }
              if ("deactivated" in dialog2.chat.peer && dialog2.chat.peer.deactivated) {
                continue;
              }
              const _dialog = new UIDialog(dialog2);
              dialogsJar.set(_dialog.id, _dialog);
              dialogs2.push(_dialog);
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          setDialogs(sortDialogs(dialogs2));
        });
      }
      class UIDialogFilter {
        constructor(a) {
          __publicField(this, "$");
          __publicField(this, "id");
          __publicField(this, "title", writable(""));
          __publicField(this, "filterPredicate", null);
          this.$ = a;
          this.update(a);
        }
        filter(a) {
          var _a3;
          return ((_a3 = this.filterPredicate) == null ? void 0 : _a3.call(this, a.$)) || false;
        }
        update(a) {
          var _a3, _b2;
          if (this.filterPredicate) {
            (_b2 = (_a3 = this.filterPredicate.cache).clear) == null ? void 0 : _b2.call(_a3);
          }
          this.$ = a;
          this.id = a.id;
          this.title.set(a.title);
          this.filterPredicate = memoize(
            (() => {
              const folder = a;
              const excludePinned = false;
              if (folder._ === "dialogFilterDefault") {
                return () => true;
              }
              const pinned = /* @__PURE__ */ new Set();
              const include = /* @__PURE__ */ new Set();
              const exclude2 = /* @__PURE__ */ new Set();
              folder.includePeers.forEach((peer) => {
                include.add(getMarkedPeerId(peer));
              });
              if (folder._ === "dialogFilterChatlist") {
                return (dialog2) => {
                  const chatId = dialog2.chat.id;
                  return include.has(chatId) || pinned.has(chatId);
                };
              }
              folder.excludePeers.forEach((peer) => {
                exclude2.add(getMarkedPeerId(peer));
              });
              return (dialog2) => {
                const chat2 = dialog2.chat;
                const chatId = dialog2.chat.id;
                const chatType = dialog2.chat.chatType;
                if (include.has(chatId))
                  return true;
                if (exclude2.has(chatId) || excludePinned) {
                  return false;
                }
                if (folder.excludeRead && !dialog2.isUnread)
                  return false;
                if (folder.excludeMuted && dialog2.isMuted)
                  return false;
                if (folder.excludeArchived && dialog2.isArchived)
                  return false;
                if (folder.contacts && chatType === "private" && chat2.isContact) {
                  return true;
                }
                if (folder.nonContacts && chatType === "private" && !chat2.isContact) {
                  return true;
                }
                if (folder.groups && (chatType === "group" || chatType === "supergroup")) {
                  return true;
                }
                if (folder.broadcasts && chatType === "channel")
                  return true;
                if (folder.bots && chatType === "bot")
                  return true;
                return false;
              };
            })()
          );
        }
      }
      class UIDialogFilterJar extends Map {
        list() {
          return Array.from(this.values());
        }
        add(a) {
          let has2 = this.get(a.id);
          if (has2) {
            has2.update(a);
          } else {
            this.set(a.id, has2 = new UIDialogFilter(a));
          }
          return has2;
        }
      }
      const [currentTab, setTab] = createSignal(null);
      const dialogsFilterJar = new UIDialogFilterJar();
      const [dialogFilters, setDialogFilters] = createSignal([]);
      function initTabs(tg) {
        return __async(this, null, function* () {
          const folders = yield tg.getFolders();
          folders.filters.forEach((a) => {
            if (a._ == "dialogFilter") {
              dialogsFilterJar.add(a);
            }
          });
          setDialogFilters(dialogsFilterJar.list());
        });
      }
      function refreshDialogsByPeer(peers) {
        return __async(this, null, function* () {
          const tg = client();
          if (!tg) {
            throw new Error("CLIENT IS NOT READY!");
          }
          yield tg.getPeerDialogs(peers).then((a) => {
            a.forEach((dialog2) => {
              if ("left" in dialog2.chat.peer && dialog2.chat.peer.left) {
                return;
              }
              dialogsJar.add(dialog2);
            });
          });
          setDialogs(sortDialogs(dialogsJar.list()));
        });
      }
      function refreshDialogs() {
        return __async(this, null, function* () {
          const tg = client();
          if (!tg) {
            throw new Error("CLIENT IS NOT READY!");
          }
          const _dialogs = dialogsJar.list();
          const ids_to_keep = /* @__PURE__ */ new Set();
          try {
            for (var iter = __forAwait(tg.iterDialogs({
              pinned: "keep",
              archived: "exclude"
            })), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const dialog2 = temp.value;
              if ("left" in dialog2.chat.peer && dialog2.chat.peer.left) {
                continue;
              }
              if ("deactivated" in dialog2.chat.peer && dialog2.chat.peer.deactivated) {
                continue;
              }
              const found = dialogsJar.get(dialog2.chat.peer.id);
              if (found) {
                found.update(dialog2);
                ids_to_keep.add(found.id);
              } else {
                const _dialog = dialogsJar.add(new UIDialog(dialog2));
                _dialogs.push(_dialog);
                ids_to_keep.add(_dialog.id);
              }
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          setDialogs(sortDialogs(_dialogs.filter((a) => ids_to_keep.has(a.id))));
        });
      }
      class UIStatus {
        constructor($2) {
          __publicField(this, "userId");
          __publicField(this, "status", writable("offline"));
          __publicField(this, "lastOnline", writable(null));
          this.$ = $2;
          this.userId = $2.userId;
          this.update($2);
        }
        update($2) {
          this.status.set($2.status);
          this.lastOnline.set($2.lastOnline);
          return this;
        }
      }
      class UserStatusJar extends Map {
        get(id2) {
          const has2 = super.get(id2);
          if (has2)
            return has2;
          const _ = new UIStatus(
            new UserStatusUpdate({
              _: "updateUserStatus",
              userId: id2,
              status: {
                _: "userStatusEmpty"
              }
            })
          );
          this.set(_.userId, _);
          return _;
        }
      }
      const userStatusJar = new UserStatusJar();
      function resetLocalStorage() {
        const localStorage2 = window.localStorage;
        delete window.localStorage;
        localStorage2.removeItem("state");
        location.reload();
      }
      function telegramReady(tg) {
        return __async(this, null, function* () {
          sessionStorage.loggedIn = 1;
          setClient(tg);
          initTabs(tg);
          yield initDialogs(tg);
          tg.setOffline(false);
          tg.on("raw_update", (upd) => {
            console.log("RAW_UPDATE", upd);
            switch (upd._) {
              case "updateChatParticipants": {
                if (upd.participants._ == "chatParticipants") {
                  const has2 = dialogsJar.get(upd.participants.chatId);
                  if (has2) {
                    has2.memberCount.set(upd.participants.participants.length);
                  } else {
                    console.error("chat participant was not found, refreshing dialogs");
                    refreshDialogsByPeer([upd.participants.chatId]);
                  }
                }
                break;
              }
              case "updateChannel": {
                refreshDialogsByPeer([upd.channelId]);
                break;
              }
              case "updateFolderPeers":
              case "updatePinnedDialogs": {
                refreshDialogs();
                break;
              }
            }
          });
          tg.on("update", function e2(update) {
            switch (update.name) {
              case "new_message": {
                const message2 = update.data;
                const found = dialogsJar.get(message2.chat.peer.id);
                if (found) {
                  console.log("UPDATING LAST MESSAGE");
                  found.lastMessage.set(found.messages.add(new UIMessage(message2)));
                  refreshDialogsByPeer([found.$.chat]);
                } else {
                  console.error("dialog was not found for message, refreshing");
                  refreshDialogsByPeer([message2.chat]);
                }
                break;
              }
              case "history_read": {
                const data2 = update.data;
                const peerId = data2.chatId;
                const found = dialogsJar.get(peerId);
                if (found) {
                  if (data2.isOutbox == true) {
                    found.lastReadOutgoing.set(data2.maxReadId);
                  }
                  if (data2.isOutbox == false && data2.isDiscussion == false) {
                    found.count.set(data2.unreadCount);
                  }
                } else {
                  console.error("dialog was not found for history read refreshing");
                  refreshDialogsByPeer([peerId]);
                }
                break;
              }
              case "delete_message": {
                const message2 = update.data;
                const _dialogs = dialogs$1();
                const found = _dialogs.find((a) => {
                  return message2.messageIds.find((b) => a.messages.has(b));
                });
                if (found) {
                  const messages = found.messages;
                  messages.deleteBulk(message2.messageIds);
                  refreshDialogsByPeer([found.$.chat]);
                } else {
                  console.error("dialog was not found for message, refreshing", message2);
                  if (message2.channelId) {
                    refreshDialogsByPeer([message2.channelId]);
                  } else
                    refreshDialogs();
                }
                break;
              }
              case "edit_message": {
                const message2 = update.data;
                const _dialogs = dialogs$1();
                const found = _dialogs.find((a) => a.$.chat.peer.id == message2.chat.peer.id);
                if (found) {
                  found.messages.update(message2.id, message2);
                } else {
                  console.error("dialog was not found for message, refreshing", message2);
                  refreshDialogsByPeer([message2.chat]);
                }
                break;
              }
              case "user_status": {
                const status = update.data;
                const _ = userStatusJar.get(status.userId).update(status);
                console.log("STATUS", _);
                break;
              }
              case "poll": {
                const pollUpdate = update.data;
                const id2 = pollUpdate.pollId.toInt();
                if (pollUpdate.isShort) {
                  const pollCached = pollJar.get(id2);
                  if (!pollCached) {
                    console.error("isShort poll update and poll not cached", pollUpdate);
                    break;
                  }
                  if (!pollUpdate.poll.results) {
                    console.error("isShort poll does not have results, useless", pollUpdate);
                    break;
                  }
                  pollCached.resultsUpdate(pollUpdate.poll.results);
                } else {
                  const pollCached = pollJar.add(pollUpdate.poll);
                  pollCached.update(pollUpdate.poll);
                }
                break;
              }
              case "user_typing": {
                const data2 = update.data;
                if (data2.chatType == "user") {
                  console.error("USER TYPING OMG", data2);
                  typingIndicatorUserJar.get(data2.userId).update(data2.status);
                }
                break;
              }
            }
            console.log("PARSED UPDATEEEE", update);
          });
          setView("home");
        });
      }
      telegram.startSession(
        // LOGIN SUCESSFUL
        telegramReady,
        // WORKER REQUEST FOR PHONE
        () => {
          setView("login");
          setLoginState(
            0
            /* Phone */
          );
          return new Promise((res) => {
            EE$1.once("phone", res);
          });
        },
        // WORKER REQUEST FOR PASSWORD
        () => {
          setView("login");
          console.log("worker is requesting 2FA");
          setLoginState(
            1
            /* Password */
          );
          return new Promise((res) => {
            EE$1.once("password", res);
          });
        },
        // WORKER REQUEST FOR CODE
        () => {
          setView("login");
          setLoginState(
            2
            /* Code */
          );
          return new Promise((res) => {
            EE$1.once("code", res);
          });
        },
        (url2) => {
          setQrLink(url2);
        },
        // CLIENT ERRORS
        (message2) => {
          console.error("CLIENT ERROR", message2);
        },
        // LOGIN ERRORS
        (step, code2, message2) => {
          console.error(`step: ${step},  ${code2}:${message2}`);
          if (code2 != 0) {
            alert(`Error Occured: ${message2}`);
            EE$1.emit("loginError", { code: code2, message: message2 });
          }
        }
      );
      const emptyCombo = "0".repeat(10);
      let combo = emptyCombo;
      const comboMap = /* @__PURE__ */ new Map();
      function handleCombo(combo2, callback2) {
        var _a3;
        comboMap.get(combo2) || ((_a3 = comboMap.set(combo2, /* @__PURE__ */ new Set()).get(combo2)) == null ? void 0 : _a3.add(callback2));
      }
      handleCombo("911", () => {
        confirm("emergency? do you want to close the app?") && window.close();
      });
      handleCombo("555", () => {
        navigator.spatialNavigationEnabled = !navigator.spatialNavigationEnabled;
      });
      handleCombo("38598", () => {
        localStorage.setItem("NO_ADS", "1");
      });
      handleCombo("7569", () => __async(this, null, function* () {
        localStorage.low_memory = "1";
        yield toaster("Low memory mode doesn't do anything right now.");
      }));
      handleCombo("0000", () => __async(this, null, function* () {
        localStorage.localforage_cache = 1;
        yield toaster("localforage is now being used as cache storage!");
        yield sleep$1(10);
        window.close();
      }));
      const keydownEM = new EventEmitter();
      window.addEventListener("keydown", (e2) => {
        keydownEM.emit("keydown", e2);
        if (e2.key === "Call" || e2.key === "F1") {
          const _combo = combo;
          comboMap.forEach((val, key) => {
            if (_combo.endsWith(key)) {
              val.forEach((cb) => cb());
              combo = emptyCombo;
            }
          });
        } else {
          combo = (combo + e2.key).slice(-10);
        }
      });
      const integrityCheck = __vitePreload(() => module.import("./checkIntegrity-DHFp9fZs.js"), false ? "__VITE_PRELOAD__" : void 0).then((m2) => m2.default(module.meta.url));
      const [appIntegrity, setAppIntegrity] = createSignal(true);
      integrityCheck.then((integrity) => {
        console.log("INTEGRITY CHECK PASSED:", integrity);
        if (!integrity) {
          setAppIntegrity(false);
          alert(
            "The app failed its integrity check, this means the app could have been modified maliciously, please don't use it."
          );
        }
      });
      const toastConnections = (_b = navigator.mozApps) == null ? void 0 : _b.getSelf().then((a) => a.connect("systoaster")).catch(() => void 0);
      function toaster(text2, latency) {
        return __async(this, null, function* () {
          if (typeof WebActivity != "undefined") {
            const s = new WebActivity("show-toast", {
              text: text2,
              timeout: latency
            });
            s.start();
            return;
          }
          const conns = yield toastConnections;
          if (!conns) {
            const notif = new Notification(text2, {
              tag: "kaigram",
              data: {},
              silent: true
            });
            setTimeout(() => {
              notif.close();
            }, latency != null ? latency : 2e3);
            return;
          }
          conns.forEach((conn) => conn.postMessage({ message: text2, latency }));
        });
      }
      const chatMinisearch = new MiniSearch({
        fields: ["name"]
      });
      const contactsMinisearch = new MiniSearch({
        fields: ["name"]
      });
      observable(cachedContacts).subscribe((contacts) => __async(this, null, function* () {
        contactsMinisearch.removeAll();
        contactsMinisearch.addAllAsync(
          contacts.map((a) => ({
            id: a.id,
            name: a.displayName
          }))
        );
      }));
      let __previousDialogs = /* @__PURE__ */ new Set();
      observable(dialogs$1).subscribe((dialogs2) => __async(this, null, function* () {
        const prevState = __previousDialogs;
        const newState = new Set(dialogs2);
        __previousDialogs = newState;
        yield sleep$1(0);
        const added = newState.difference(prevState);
        yield sleep$1(0);
        const removed = prevState.difference(newState);
        yield sleep$1(0);
        if (removed.size)
          chatMinisearch.discardAll(Array.from(removed).map((a) => a.id));
        yield sleep$1(0);
        if (added.size)
          chatMinisearch.addAllAsync(
            Array.from(added).map((dialog2) => ({
              name: (dialog2.$.chat.isSelf ? "Saved Messages" : dialog2.$.chat.displayName).toLowerCase(),
              id: dialog2.id
            }))
          );
      }));
      console.error("KAIADS", KaiAdsUrl);
      const _getKaiAd = () => Promise.resolve(
        System.import(KaiAdsUrl).then((m2) => m2.default)
      );
      let cached;
      const initGetKaiAd = () => cached || (cached = _getKaiAd());
      function getKaiAd$1(opts) {
        return __async(this, null, function* () {
          const e2 = yield initGetKaiAd();
          e2(opts);
        });
      }
      function showKaiAd() {
        getKaiAd$1({
          publisher: "f76b7e40-cd70-4a3a-b98f-f03ad252de83",
          app: "kaigram",
          slot: "kaigram",
          onerror: (err) => console.error("Custom catch:", err),
          onready: (ad) => {
            console.error("KAIADS READY");
            ad.call("display");
          }
        });
      }
      const signals = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        EE: EE$1,
        LoginState,
        UIDialog,
        UIDialogFilter,
        UIMessage,
        UIPoll,
        UITypingIndicatorUser,
        appIntegrity,
        cachedContacts,
        chat,
        chatMinisearch,
        client,
        contactsMinisearch,
        currentTab,
        currentView,
        dialogFilters,
        dialogs: dialogs$1,
        dialogsFilterJar,
        dialogsJar,
        editingMessage,
        handleCombo,
        integrityCheck,
        loginState,
        messageInfo,
        pollJar,
        previousView,
        qrLink,
        readHistory,
        refreshDialogsByPeer,
        reloadCachedContacts,
        replyingMessage,
        resetLocalStorage,
        room: room$1,
        setCachedContacts,
        setClient,
        setDialogFilters,
        setDialogs,
        setEditingMessage,
        setLoginState,
        setMessageInfo,
        setPreviousView,
        setQrLink,
        setReplyingMessage,
        setRoom,
        setSoftkeys,
        setStatusbarColor,
        setTab,
        setUIDialog,
        setView,
        showKaiAd,
        softcenter,
        softkeysBlack,
        softkeysLoading,
        softleft,
        softright,
        statusbarColor,
        telegram,
        toaster,
        typingIndicatorUserJar,
        uiDialog,
        userStatusJar
      }, Symbol.toStringTag, { value: "Module" }));
      exports("dN", signals);
      var module$1 = { exports: {} };
      var GlobalConfig = {
        selector: "",
        // can be a valid <extSelector> except "@" syntax.
        straightOnly: false,
        straightOverlapThreshold: 0.5,
        rememberSource: false,
        disabled: false,
        defaultElement: "",
        // <extSelector> except "@" syntax.
        enterTo: "",
        // '', 'last-focused', 'default-element'
        leaveFor: null,
        // {left: <extSelector>, right: <extSelector>,
        //  up: <extSelector>, down: <extSelector>}
        restrict: "self-first",
        // 'self-first', 'self-only', 'none'
        tabIndexIgnoreList: "a, input, select, textarea, button, iframe, [contentEditable=true]",
        navigableFilter: null
      };
      var KEYMAPPING = {
        37: "left",
        38: "up",
        39: "right",
        40: "down"
      };
      var REVERSE = {
        left: "right",
        up: "down",
        right: "left",
        down: "up"
      };
      var EVENT_PREFIX = "sn-";
      var ID_POOL_PREFIX = "section-";
      var _idPool = 0;
      var _ready = false;
      var _pause = false;
      var _sections = {};
      var _sectionCount = 0;
      var _defaultSectionId = "";
      var _lastSectionId = "";
      var _duringFocusChange = false;
      var elementMatchesSelector = Element.prototype.matches;
      function getRect(elem) {
        var cr = elem.getBoundingClientRect();
        var rect = {
          left: cr.left,
          top: cr.top,
          right: cr.right,
          bottom: cr.bottom,
          width: cr.width,
          height: cr.height
        };
        rect.element = elem;
        rect.center = {
          x: rect.left + Math.floor(rect.width / 2),
          y: rect.top + Math.floor(rect.height / 2)
        };
        rect.center.left = rect.center.right = rect.center.x;
        rect.center.top = rect.center.bottom = rect.center.y;
        return rect;
      }
      function partition(rects, targetRect, straightOverlapThreshold) {
        var groups = [[], [], [], [], [], [], [], [], []];
        for (var i = 0; i < rects.length; i++) {
          var rect = rects[i];
          var center = rect.center;
          var x, y, groupId;
          if (center.x < targetRect.left) {
            x = 0;
          } else if (center.x <= targetRect.right) {
            x = 1;
          } else {
            x = 2;
          }
          if (center.y < targetRect.top) {
            y = 0;
          } else if (center.y <= targetRect.bottom) {
            y = 1;
          } else {
            y = 2;
          }
          groupId = y * 3 + x;
          groups[groupId].push(rect);
          if ([0, 2, 6, 8].indexOf(groupId) !== -1) {
            var threshold = straightOverlapThreshold;
            if (rect.left <= targetRect.right - targetRect.width * threshold) {
              if (groupId === 2) {
                groups[1].push(rect);
              } else if (groupId === 8) {
                groups[7].push(rect);
              }
            }
            if (rect.right >= targetRect.left + targetRect.width * threshold) {
              if (groupId === 0) {
                groups[1].push(rect);
              } else if (groupId === 6) {
                groups[7].push(rect);
              }
            }
            if (rect.top <= targetRect.bottom - targetRect.height * threshold) {
              if (groupId === 6) {
                groups[3].push(rect);
              } else if (groupId === 8) {
                groups[5].push(rect);
              }
            }
            if (rect.bottom >= targetRect.top + targetRect.height * threshold) {
              if (groupId === 0) {
                groups[3].push(rect);
              } else if (groupId === 2) {
                groups[5].push(rect);
              }
            }
          }
        }
        return groups;
      }
      function generateDistanceFunction(targetRect) {
        return {
          nearPlumbLineIsBetter: function(rect) {
            var d;
            if (rect.center.x < targetRect.center.x) {
              d = targetRect.center.x - rect.right;
            } else {
              d = rect.left - targetRect.center.x;
            }
            return d < 0 ? 0 : d;
          },
          nearHorizonIsBetter: function(rect) {
            var d;
            if (rect.center.y < targetRect.center.y) {
              d = targetRect.center.y - rect.bottom;
            } else {
              d = rect.top - targetRect.center.y;
            }
            return d < 0 ? 0 : d;
          },
          nearTargetLeftIsBetter: function(rect) {
            var d;
            if (rect.center.x < targetRect.center.x) {
              d = targetRect.left - rect.right;
            } else {
              d = rect.left - targetRect.left;
            }
            return d < 0 ? 0 : d;
          },
          nearTargetTopIsBetter: function(rect) {
            var d;
            if (rect.center.y < targetRect.center.y) {
              d = targetRect.top - rect.bottom;
            } else {
              d = rect.top - targetRect.top;
            }
            return d < 0 ? 0 : d;
          },
          topIsBetter: function(rect) {
            return rect.top;
          },
          bottomIsBetter: function(rect) {
            return -1 * rect.bottom;
          },
          leftIsBetter: function(rect) {
            return rect.left;
          },
          rightIsBetter: function(rect) {
            return -1 * rect.right;
          }
        };
      }
      function prioritize(priorities) {
        var destPriority = null;
        for (var i = 0; i < priorities.length; i++) {
          if (priorities[i].group.length) {
            destPriority = priorities[i];
            break;
          }
        }
        if (!destPriority) {
          return null;
        }
        var destDistance = destPriority.distance;
        destPriority.group.sort(function(a, b) {
          for (var i2 = 0; i2 < destDistance.length; i2++) {
            var distance = destDistance[i2];
            var delta = distance(a) - distance(b);
            if (delta) {
              return delta;
            }
          }
          return 0;
        });
        return destPriority.group;
      }
      function navigate(target, direction, candidates, config) {
        if (!target || !direction || !candidates || !candidates.length) {
          return null;
        }
        var rects = [];
        for (var i = 0; i < candidates.length; i++) {
          var rect = getRect(candidates[i]);
          if (rect) {
            rects.push(rect);
          }
        }
        if (!rects.length) {
          return null;
        }
        var targetRect = getRect(target);
        if (!targetRect) {
          return null;
        }
        var distanceFunction = generateDistanceFunction(targetRect);
        var groups = partition(rects, targetRect, config.straightOverlapThreshold);
        var internalGroups = partition(groups[4], targetRect.center, config.straightOverlapThreshold);
        var priorities;
        switch (direction) {
          case "left":
            priorities = [
              {
                group: internalGroups[0].concat(internalGroups[3]).concat(internalGroups[6]),
                distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter]
              },
              {
                group: groups[3],
                distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter]
              },
              {
                group: groups[0].concat(groups[6]),
                distance: [
                  distanceFunction.nearHorizonIsBetter,
                  distanceFunction.rightIsBetter,
                  distanceFunction.nearTargetTopIsBetter
                ]
              }
            ];
            break;
          case "right":
            priorities = [
              {
                group: internalGroups[2].concat(internalGroups[5]).concat(internalGroups[8]),
                distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter]
              },
              {
                group: groups[5],
                distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter]
              },
              {
                group: groups[2].concat(groups[8]),
                distance: [
                  distanceFunction.nearHorizonIsBetter,
                  distanceFunction.leftIsBetter,
                  distanceFunction.nearTargetTopIsBetter
                ]
              }
            ];
            break;
          case "up":
            priorities = [
              {
                group: internalGroups[0].concat(internalGroups[1]).concat(internalGroups[2]),
                distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter]
              },
              {
                group: groups[1],
                distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter]
              },
              {
                group: groups[0].concat(groups[2]),
                distance: [
                  distanceFunction.nearPlumbLineIsBetter,
                  distanceFunction.bottomIsBetter,
                  distanceFunction.nearTargetLeftIsBetter
                ]
              }
            ];
            break;
          case "down":
            priorities = [
              {
                group: internalGroups[6].concat(internalGroups[7]).concat(internalGroups[8]),
                distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter]
              },
              {
                group: groups[7],
                distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter]
              },
              {
                group: groups[6].concat(groups[8]),
                distance: [
                  distanceFunction.nearPlumbLineIsBetter,
                  distanceFunction.topIsBetter,
                  distanceFunction.nearTargetLeftIsBetter
                ]
              }
            ];
            break;
          default:
            return null;
        }
        if (config.straightOnly) {
          priorities.pop();
        }
        var destGroup = prioritize(priorities);
        if (!destGroup) {
          return null;
        }
        var dest = null;
        if (config.rememberSource && config.previous && config.previous.destination === target && config.previous.reverse === direction) {
          for (var j = 0; j < destGroup.length; j++) {
            if (destGroup[j].element === config.previous.target) {
              dest = destGroup[j].element;
              break;
            }
          }
        }
        if (!dest) {
          dest = destGroup[0].element;
        }
        return dest;
      }
      function generateId() {
        var id2;
        while (true) {
          id2 = ID_POOL_PREFIX + String(++_idPool);
          if (!_sections[id2]) {
            break;
          }
        }
        return id2;
      }
      function parseSelector(selector) {
        var result;
        if (typeof selector === "string") {
          result = [].slice.call(document.querySelectorAll(selector));
        } else if (typeof selector === "object" && selector.length) {
          result = [].slice.call(selector);
        } else if (typeof selector === "object" && selector.nodeType === 1) {
          result = [selector];
        } else {
          result = [];
        }
        return result;
      }
      function matchSelector(elem, selector) {
        if (typeof selector === "string") {
          return elementMatchesSelector.call(elem, selector);
        } else if (typeof selector === "object" && selector.length) {
          return selector.indexOf(elem) >= 0;
        } else if (typeof selector === "object" && selector.nodeType === 1) {
          return elem === selector;
        }
        return false;
      }
      function getCurrentFocusedElement() {
        var activeElement = document.activeElement;
        if (activeElement && activeElement !== document.body) {
          return activeElement;
        }
      }
      function extend(out) {
        out = out || {};
        for (var i = 1; i < arguments.length; i++) {
          if (!arguments[i]) {
            continue;
          }
          for (var key in arguments[i]) {
            if (arguments[i].hasOwnProperty(key) && arguments[i][key] !== void 0) {
              out[key] = arguments[i][key];
            }
          }
        }
        return out;
      }
      function exclude(elemList, excludedElem) {
        if (!Array.isArray(excludedElem)) {
          excludedElem = [excludedElem];
        }
        for (var i = 0, index; i < excludedElem.length; i++) {
          index = elemList.indexOf(excludedElem[i]);
          if (index >= 0) {
            elemList.splice(index, 1);
          }
        }
        return elemList;
      }
      function isNavigable(elem, sectionId, verifySectionSelector) {
        if (!elem || !sectionId || !_sections[sectionId] || _sections[sectionId].disabled) {
          return false;
        }
        if (elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || elem.hasAttribute("disabled")) {
          return false;
        }
        if (verifySectionSelector && !matchSelector(elem, _sections[sectionId].selector)) {
          return false;
        }
        if (typeof _sections[sectionId].navigableFilter === "function") {
          if (_sections[sectionId].navigableFilter(elem, sectionId) === false) {
            return false;
          }
        } else if (typeof GlobalConfig.navigableFilter === "function") {
          if (GlobalConfig.navigableFilter(elem, sectionId) === false) {
            return false;
          }
        }
        return true;
      }
      function getSectionId(elem) {
        for (var id2 in _sections) {
          if (!_sections[id2].disabled && matchSelector(elem, _sections[id2].selector)) {
            return id2;
          }
        }
      }
      function getSectionNavigableElements(sectionId) {
        return parseSelector(_sections[sectionId].selector).filter(function(elem) {
          return isNavigable(elem, sectionId);
        });
      }
      function getSectionDefaultElement(sectionId) {
        var defaultElement = _sections[sectionId].defaultElement;
        if (!defaultElement) {
          return null;
        }
        if (typeof defaultElement === "string") {
          defaultElement = parseSelector(defaultElement)[0];
        }
        if (isNavigable(defaultElement, sectionId, true)) {
          return defaultElement;
        }
        return null;
      }
      function getSectionLastFocusedElement(sectionId) {
        var lastFocusedElement = _sections[sectionId].lastFocusedElement;
        if (!isNavigable(lastFocusedElement, sectionId, true)) {
          return null;
        }
        return lastFocusedElement;
      }
      function fireEvent(elem, type, details2, cancelable) {
        if (arguments.length < 4) {
          cancelable = true;
        }
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(EVENT_PREFIX + type, true, cancelable, details2);
        return elem.dispatchEvent(evt);
      }
      function focusElement(elem, sectionId, direction) {
        if (!elem) {
          return false;
        }
        var currentFocusedElement = getCurrentFocusedElement();
        var silentFocus = function() {
          if (currentFocusedElement) {
            currentFocusedElement.blur();
          }
          elem.focus();
          focusChanged(elem, sectionId);
        };
        if (_duringFocusChange) {
          silentFocus();
          return true;
        }
        _duringFocusChange = true;
        if (_pause) {
          silentFocus();
          _duringFocusChange = false;
          return true;
        }
        if (currentFocusedElement) {
          var unfocusProperties = {
            nextElement: elem,
            nextSectionId: sectionId,
            direction,
            native: false
          };
          if (!fireEvent(currentFocusedElement, "willunfocus", unfocusProperties)) {
            _duringFocusChange = false;
            return false;
          }
          currentFocusedElement.blur();
          fireEvent(currentFocusedElement, "unfocused", unfocusProperties, false);
        }
        var focusProperties = {
          previousElement: currentFocusedElement,
          sectionId,
          direction,
          native: false
        };
        if (!fireEvent(elem, "willfocus", focusProperties)) {
          _duringFocusChange = false;
          return false;
        }
        elem.focus();
        fireEvent(elem, "focused", focusProperties, false);
        _duringFocusChange = false;
        focusChanged(elem, sectionId);
        return true;
      }
      function focusChanged(elem, sectionId) {
        if (!sectionId) {
          sectionId = getSectionId(elem);
        }
        if (sectionId) {
          _sections[sectionId].lastFocusedElement = elem;
          _lastSectionId = sectionId;
        }
      }
      function focusExtendedSelector(selector, direction) {
        if (selector.charAt(0) == "@") {
          if (selector.length == 1) {
            return focusSection();
          } else {
            var sectionId = selector.substr(1);
            return focusSection(sectionId);
          }
        } else {
          var next2 = parseSelector(selector)[0];
          if (next2) {
            var nextSectionId = getSectionId(next2);
            if (isNavigable(next2, nextSectionId)) {
              return focusElement(next2, nextSectionId, direction);
            }
          }
        }
        return false;
      }
      function focusSection(sectionId) {
        var range = [];
        var addRange = function(id3) {
          if (id3 && range.indexOf(id3) < 0 && _sections[id3] && !_sections[id3].disabled) {
            range.push(id3);
          }
        };
        if (sectionId) {
          addRange(sectionId);
        } else {
          addRange(_defaultSectionId);
          addRange(_lastSectionId);
          Object.keys(_sections).map(addRange);
        }
        for (var i = 0; i < range.length; i++) {
          var id2 = range[i];
          var next2;
          if (_sections[id2].enterTo == "last-focused") {
            next2 = getSectionLastFocusedElement(id2) || getSectionDefaultElement(id2) || getSectionNavigableElements(id2)[0];
          } else {
            next2 = getSectionDefaultElement(id2) || getSectionLastFocusedElement(id2) || getSectionNavigableElements(id2)[0];
          }
          if (next2) {
            return focusElement(next2, id2);
          }
        }
        return false;
      }
      function fireNavigatefailed(elem, direction) {
        fireEvent(
          elem,
          "navigatefailed",
          {
            direction
          },
          false
        );
      }
      function gotoLeaveFor(sectionId, direction) {
        if (_sections[sectionId].leaveFor && _sections[sectionId].leaveFor[direction] !== void 0) {
          var next2 = _sections[sectionId].leaveFor[direction];
          if (typeof next2 === "string") {
            if (next2 === "") {
              return null;
            }
            return focusExtendedSelector(next2, direction);
          }
          var nextSectionId = getSectionId(next2);
          if (isNavigable(next2, nextSectionId)) {
            return focusElement(next2, nextSectionId, direction);
          }
        }
        return false;
      }
      function focusNext(direction, currentFocusedElement, currentSectionId) {
        var extSelector = currentFocusedElement.getAttribute("data-sn-" + direction);
        if (typeof extSelector === "string") {
          if (extSelector === "" || !focusExtendedSelector(extSelector, direction)) {
            fireNavigatefailed(currentFocusedElement, direction);
            return false;
          }
          return true;
        }
        var sectionNavigableElements = {};
        var allNavigableElements = [];
        for (var id2 in _sections) {
          sectionNavigableElements[id2] = getSectionNavigableElements(id2);
          allNavigableElements = allNavigableElements.concat(sectionNavigableElements[id2]);
        }
        var config = extend({}, GlobalConfig, _sections[currentSectionId]);
        var next2;
        if (config.restrict == "self-only" || config.restrict == "self-first") {
          var currentSectionNavigableElements = sectionNavigableElements[currentSectionId];
          next2 = navigate(
            currentFocusedElement,
            direction,
            exclude(currentSectionNavigableElements, currentFocusedElement),
            config
          );
          if (!next2 && config.restrict == "self-first") {
            next2 = navigate(
              currentFocusedElement,
              direction,
              exclude(allNavigableElements, currentSectionNavigableElements),
              config
            );
          }
        } else {
          next2 = navigate(
            currentFocusedElement,
            direction,
            exclude(allNavigableElements, currentFocusedElement),
            config
          );
        }
        if (next2) {
          _sections[currentSectionId].previous = {
            target: currentFocusedElement,
            destination: next2,
            reverse: REVERSE[direction]
          };
          var nextSectionId = getSectionId(next2);
          if (currentSectionId != nextSectionId) {
            var result = gotoLeaveFor(currentSectionId, direction);
            if (result) {
              return true;
            } else if (result === null) {
              fireNavigatefailed(currentFocusedElement, direction);
              return false;
            }
            var enterToElement;
            switch (_sections[nextSectionId].enterTo) {
              case "last-focused":
                enterToElement = getSectionLastFocusedElement(nextSectionId) || getSectionDefaultElement(nextSectionId);
                break;
              case "default-element":
                enterToElement = getSectionDefaultElement(nextSectionId);
                break;
            }
            if (enterToElement) {
              next2 = enterToElement;
            }
          }
          return focusElement(next2, nextSectionId, direction);
        } else if (gotoLeaveFor(currentSectionId, direction)) {
          return true;
        }
        fireNavigatefailed(currentFocusedElement, direction);
        return false;
      }
      function onKeyDown(evt) {
        if (!_sectionCount || _pause || evt.altKey || evt.ctrlKey || evt.metaKey || evt.shiftKey) {
          return;
        }
        var currentFocusedElement;
        var preventDefault = function() {
          evt.preventDefault();
          evt.stopPropagation();
          return false;
        };
        var direction = KEYMAPPING[evt.keyCode];
        if (!direction) {
          if (evt.keyCode == 13) {
            currentFocusedElement = getCurrentFocusedElement();
            if (currentFocusedElement && getSectionId(currentFocusedElement)) {
              if (!fireEvent(currentFocusedElement, "enter-down")) {
                return preventDefault();
              }
            }
          }
          return;
        }
        currentFocusedElement = getCurrentFocusedElement();
        if (!currentFocusedElement) {
          if (_lastSectionId) {
            currentFocusedElement = getSectionLastFocusedElement(_lastSectionId);
          }
          if (!currentFocusedElement) {
            focusSection();
            return preventDefault();
          }
        }
        var currentSectionId = getSectionId(currentFocusedElement);
        if (!currentSectionId) {
          return;
        }
        var willmoveProperties = {
          direction,
          sectionId: currentSectionId,
          cause: "keydown"
        };
        if (fireEvent(currentFocusedElement, "willmove", willmoveProperties)) {
          focusNext(direction, currentFocusedElement, currentSectionId);
        }
        return preventDefault();
      }
      function onKeyUp(evt) {
        if (evt.altKey || evt.ctrlKey || evt.metaKey || evt.shiftKey) {
          return;
        }
        if (!_pause && _sectionCount && evt.keyCode == 13) {
          var currentFocusedElement = getCurrentFocusedElement();
          if (currentFocusedElement && getSectionId(currentFocusedElement)) {
            if (!fireEvent(currentFocusedElement, "enter-up")) {
              evt.preventDefault();
              evt.stopPropagation();
            }
          }
        }
      }
      function onFocus(evt) {
        var target = evt.target;
        if (target !== window && target !== document && _sectionCount && !_duringFocusChange) {
          var sectionId = getSectionId(target);
          if (sectionId) {
            if (_pause) {
              focusChanged(target, sectionId);
              return;
            }
            var focusProperties = {
              sectionId,
              native: true
            };
            if (!fireEvent(target, "willfocus", focusProperties)) {
              _duringFocusChange = true;
              target.blur();
              _duringFocusChange = false;
            } else {
              fireEvent(target, "focused", focusProperties, false);
              focusChanged(target, sectionId);
            }
          }
        }
      }
      function onBlur(evt) {
        var target = evt.target;
        if (target !== window && target !== document && !_pause && _sectionCount && !_duringFocusChange && getSectionId(target)) {
          var unfocusProperties = {
            native: true
          };
          if (!fireEvent(target, "willunfocus", unfocusProperties)) {
            _duringFocusChange = true;
            setTimeout(function() {
              target.focus();
              _duringFocusChange = false;
            });
          } else {
            fireEvent(target, "unfocused", unfocusProperties, false);
          }
        }
      }
      var SpatialNavigation = {
        init: function() {
          if (!_ready) {
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);
            window.addEventListener("focus", onFocus, true);
            window.addEventListener("blur", onBlur, true);
            _ready = true;
          }
        },
        uninit: function() {
          window.removeEventListener("blur", onBlur, true);
          window.removeEventListener("focus", onFocus, true);
          window.removeEventListener("keyup", onKeyUp);
          window.removeEventListener("keydown", onKeyDown);
          SpatialNavigation.clear();
          _idPool = 0;
          _ready = false;
        },
        clear: function() {
          _sections = {};
          _sectionCount = 0;
          _defaultSectionId = "";
          _lastSectionId = "";
          _duringFocusChange = false;
        },
        // set(<config>);
        // set(<sectionId>, <config>);
        set: function() {
          var sectionId, config;
          if (typeof arguments[0] === "object") {
            config = arguments[0];
          } else if (typeof arguments[0] === "string" && typeof arguments[1] === "object") {
            sectionId = arguments[0];
            config = arguments[1];
            if (!_sections[sectionId]) {
              throw new Error('Section "' + sectionId + `" doesn't exist!`);
            }
          } else {
            return;
          }
          for (var key in config) {
            if (GlobalConfig[key] !== void 0) {
              if (sectionId) {
                _sections[sectionId][key] = config[key];
              } else if (config[key] !== void 0) {
                GlobalConfig[key] = config[key];
              }
            }
          }
          if (sectionId) {
            _sections[sectionId] = extend({}, _sections[sectionId]);
          }
        },
        // add(<config>);
        // add(<sectionId>, <config>);
        add: function() {
          var sectionId;
          var config = {};
          if (typeof arguments[0] === "object") {
            config = arguments[0];
          } else if (typeof arguments[0] === "string" && typeof arguments[1] === "object") {
            sectionId = arguments[0];
            config = arguments[1];
          }
          if (!sectionId) {
            sectionId = typeof config.id === "string" ? config.id : generateId();
          }
          if (_sections[sectionId]) {
            throw new Error('Section "' + sectionId + '" has already existed!');
          }
          _sections[sectionId] = {};
          _sectionCount++;
          SpatialNavigation.set(sectionId, config);
          return sectionId;
        },
        remove: function(sectionId) {
          if (!sectionId || typeof sectionId !== "string") {
            throw new Error('Please assign the "sectionId"!');
          }
          if (_sections[sectionId]) {
            _sections[sectionId] = void 0;
            _sections = extend({}, _sections);
            _sectionCount--;
            if (_lastSectionId === sectionId) {
              _lastSectionId = "";
            }
            return true;
          }
          return false;
        },
        disable: function(sectionId) {
          if (_sections[sectionId]) {
            _sections[sectionId].disabled = true;
            return true;
          }
          return false;
        },
        enable: function(sectionId) {
          if (_sections[sectionId]) {
            _sections[sectionId].disabled = false;
            return true;
          }
          return false;
        },
        pause: function() {
          _pause = true;
        },
        resume: function() {
          _pause = false;
        },
        // focus([silent])
        // focus(<sectionId>, [silent])
        // focus(<extSelector>, [silent])
        // Note: "silent" is optional and default to false
        focus: function(elem, silent) {
          var result = false;
          if (silent === void 0 && typeof elem === "boolean") {
            silent = elem;
            elem = void 0;
          }
          var autoPause = !_pause && silent;
          if (autoPause) {
            SpatialNavigation.pause();
          }
          if (!elem) {
            result = focusSection();
          } else {
            if (typeof elem === "string") {
              if (_sections[elem]) {
                result = focusSection(elem);
              } else {
                result = focusExtendedSelector(elem);
              }
            } else {
              var nextSectionId = getSectionId(elem);
              if (isNavigable(elem, nextSectionId)) {
                result = focusElement(elem, nextSectionId);
              }
            }
          }
          if (autoPause) {
            SpatialNavigation.resume();
          }
          return result;
        },
        // move(<direction>)
        // move(<direction>, <selector>)
        move: function(direction, selector) {
          direction = direction.toLowerCase();
          if (!REVERSE[direction]) {
            return false;
          }
          var elem = selector ? parseSelector(selector)[0] : getCurrentFocusedElement();
          if (!elem) {
            return false;
          }
          var sectionId = getSectionId(elem);
          if (!sectionId) {
            return false;
          }
          var willmoveProperties = {
            direction,
            sectionId,
            cause: "api"
          };
          if (!fireEvent(elem, "willmove", willmoveProperties)) {
            return false;
          }
          return focusNext(direction, elem, sectionId);
        },
        // makeFocusable()
        // makeFocusable(<sectionId>)
        makeFocusable: function(sectionId) {
          var doMakeFocusable = function(section) {
            var tabIndexIgnoreList = section.tabIndexIgnoreList !== void 0 ? section.tabIndexIgnoreList : GlobalConfig.tabIndexIgnoreList;
            parseSelector(section.selector).forEach(function(elem) {
              if (!matchSelector(elem, tabIndexIgnoreList)) {
                if (!elem.getAttribute("tabindex")) {
                  elem.setAttribute("tabindex", "-1");
                }
              }
            });
          };
          if (sectionId) {
            if (_sections[sectionId]) {
              doMakeFocusable(_sections[sectionId]);
            } else {
              throw new Error('Section "' + sectionId + `" doesn't exist!`);
            }
          } else {
            for (var id2 in _sections) {
              doMakeFocusable(_sections[id2]);
            }
          }
        },
        setDefaultSection: function(sectionId) {
          if (!sectionId) {
            _defaultSectionId = "";
          } else if (!_sections[sectionId]) {
            throw new Error('Section "' + sectionId + `" doesn't exist!`);
          } else {
            _defaultSectionId = sectionId;
          }
        }
      };
      window.SpatialNavigation = SpatialNavigation;
      module$1.exports = SpatialNavigation;
      const __CJS__export_default__ = (module$1.exports == null ? {} : module$1.exports).default || module$1.exports;
      const login = "_login_1hpvg_1";
      const item$4 = "_item_1hpvg_6";
      const focus = "_focus_1hpvg_8";
      const header$3 = "_header_1hpvg_13";
      const heading = "_heading_1hpvg_19";
      const text$1 = "_text_1hpvg_25";
      const select = "_select_1hpvg_30";
      const input_wrap = "_input_wrap_1hpvg_47";
      const styles$r = {
        login,
        item: item$4,
        focus,
        header: header$3,
        heading,
        text: text$1,
        select,
        input_wrap
      };
      const content$2 = "_content_owesc_1";
      const main = "_main_owesc_12";
      const styles$q = {
        content: content$2,
        main
      };
      var _tmpl$$v = /* @__PURE__ */ template(`<div><div>`);
      function Content(props) {
        return (() => {
          var _el$ = _tmpl$$v(), _el$2 = _el$.firstChild;
          insert(_el$, () => props.before, _el$2);
          insert(_el$2, () => props.children);
          insert(_el$, () => props.after, null);
          createRenderEffect((_p$) => {
            var _v$ = props.hidden ? "hidden" : void 0, _v$2 = styles$q.content, _v$3 = styles$q.main + (props.mainClass ? " " + props.mainClass : "");
            _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$.style.setProperty("visibility", _v$) : _el$.style.removeProperty("visibility"));
            _v$2 !== _p$.t && className(_el$, _p$.t = _v$2);
            _v$3 !== _p$.a && className(_el$2, _p$.a = _v$3);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          return _el$;
        })();
      }
      const search_wrap = "_search_wrap_1uluy_1";
      const focused$1 = "_focused_1uluy_30";
      const styles$p = {
        search_wrap,
        focused: focused$1
      };
      var _tmpl$$u = /* @__PURE__ */ template(`<div><div><svg viewBox="0 0 18 18"><path d="M11.625 10.5h-.592l-.21-.203A4.853 4.853 0 0012 7.125 4.875 4.875 0 107.125 12a4.853 4.853 0 003.172-1.178l.203.21v.593l3.75 3.742 1.117-1.117-3.742-3.75zm-4.5 0A3.37 3.37 0 013.75 7.125 3.37 3.37 0 017.125 3.75 3.37 3.37 0 0110.5 7.125 3.37 3.37 0 017.125 10.5z"></path></svg><input>`);
      function Search(props) {
        const [local, rest] = splitProps(props, ["onFocus", "onBlur", "onKeyDown"]);
        const [focused2, setFocused] = createSignal(false);
        return (() => {
          var _el$ = _tmpl$$u(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling;
          spread(_el$4, mergeProps(rest, {
            "onFocus": (e2) => {
              var _a3;
              setFocused(true);
              (_a3 = local.onFocus) == null ? void 0 : _a3.call(local, e2);
            },
            "onBlur": (e2) => {
              var _a3;
              setFocused(false);
              (_a3 = local.onBlur) == null ? void 0 : _a3.call(local, e2);
            },
            "onKeyDown": (e2) => {
              if (typeof local.onKeyDown == "function") {
                local.onKeyDown(e2);
              }
              if (e2.currentTarget.value !== "" && (e2.key === "ArrowLeft" || e2.key === "ArrowRight")) {
                e2.stopImmediatePropagation();
                e2.stopPropagation();
              }
            }
          }), false, false);
          createRenderEffect((_$p) => classList$1(_el$, {
            [styles$p.search_wrap]: true,
            [styles$p.focused]: focused2()
          }, _$p));
          return _el$;
        })();
      }
      const CountryDialInfoURL = "/assets/country_dial_info-BidEMnIs.json";
      const country = "_country_p5usf_1";
      const code = "_code_p5usf_13";
      const noresult = "_noresult_p5usf_26";
      const styles$o = {
        country,
        code,
        noresult
      };
      const wrap$2 = "_wrap_etx6a_1";
      const inner$1 = "_inner_etx6a_28";
      const marquee = "_marquee_etx6a_8";
      const styles$n = {
        wrap: wrap$2,
        inner: inner$1,
        marquee
      };
      var _tmpl$$t = /* @__PURE__ */ template(`<div><div>`);
      function isElementOverflowing(element) {
        var overflowX = element.offsetWidth < element.scrollWidth, overflowY = element.offsetHeight < element.scrollHeight;
        return overflowX || overflowY;
      }
      function Marquee(props) {
        let innerEl;
        const [marquee2, setMarquee] = createSignal(false);
        const [transform, setTransform] = createSignal("");
        const [time2, setTime] = createSignal(void 0);
        createEffect(() => {
          props.children;
          const element = innerEl;
          setMarquee(isElementOverflowing(element) && element.scrollWidth - element.offsetWidth);
          onCleanup(() => setMarquee(false));
        });
        createEffect(() => {
          var _a3;
          let timeout;
          const string = (_a3 = innerEl == null ? void 0 : innerEl.innerText) != null ? _a3 : "e".repeat(20);
          const preciseTime = string.length / 15;
          const time22 = Math.ceil(preciseTime) * 1e3 + 2e3;
          setTransform("");
          setTime(void 0);
          const _setTransform = () => {
            setTransform(`translateX(${-untrack(marquee2) + "px"})`);
            setTime(preciseTime.toFixed(2) + "s");
            timeout = setTimeout(() => {
              setTransform("");
              timeout = setTimeout(_setTransform, time22);
            }, time22);
          };
          if (typeof marquee2() == "number") {
            timeout = setTimeout(_setTransform, 2e3);
          }
          onCleanup(() => {
            clearTimeout(timeout);
          });
        });
        return (() => {
          var _el$ = _tmpl$$t(), _el$2 = _el$.firstChild;
          var _ref$ = innerEl;
          typeof _ref$ === "function" ? use(_ref$, _el$2) : innerEl = _el$2;
          insert(_el$2, () => props.children);
          createRenderEffect((_p$) => {
            var _v$ = {
              [styles$n.wrap]: true,
              [styles$n.marquee]: typeof marquee2() == "number"
            }, _v$2 = time2(), _v$3 = transform(), _v$4 = {
              [styles$n.marquee]: typeof marquee2() == "number",
              [styles$n.inner]: true
            };
            _p$.e = classList$1(_el$, _v$, _p$.e);
            _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$2.style.setProperty("--time", _v$2) : _el$2.style.removeProperty("--time"));
            _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$2.style.setProperty("transform", _v$3) : _el$2.style.removeProperty("transform"));
            _p$.o = classList$1(_el$2, _v$4, _p$.o);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0
          });
          return _el$;
        })();
      }
      function MarqueeOrNot(props) {
        return createComponent(Show, {
          get when() {
            return props.marquee;
          },
          get fallback() {
            return props.children;
          },
          get children() {
            return createComponent(Marquee, {
              get children() {
                return props.children;
              }
            });
          }
        });
      }
      const header$2 = "_header_1fanu_1";
      const styles$m = {
        header: header$2
      };
      var _tmpl$$s = /* @__PURE__ */ template(`<div>`);
      function Header(props) {
        return (() => {
          var _el$ = _tmpl$$s();
          insert(_el$, () => props.children);
          createRenderEffect(() => className(_el$, styles$m.header));
          return _el$;
        })();
      }
      var _tmpl$$r = /* @__PURE__ */ template(`<div tabindex=-1><div></div><div>`), _tmpl$2$j = /* @__PURE__ */ template(`<div><div>`), _tmpl$3$9 = /* @__PURE__ */ template(`<div class=country_picker>`), _tmpl$4$8 = /* @__PURE__ */ template(`<div>No results found`);
      const minisearch = new MiniSearch({
        fields: ["name", "code", "dial_code"],
        searchOptions: {
          prefix: true
        }
      });
      function CountryItem(props) {
        const [focused2, setFocused] = createSignal(false);
        return (() => {
          var _el$ = _tmpl$$r(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
          _el$.addEventListener("blur", () => setFocused(false));
          addEventListener(_el$, "sn-enter-down", () => {
            props.onSelect(props.$);
          });
          addEventListener(_el$, "sn-willfocus", (e2) => {
            setSoftkeys("Cancel", "SELECT", "");
            setFocused(true);
            scrollIntoView(e2.currentTarget);
          });
          insert(_el$2, createComponent(MarqueeOrNot, {
            get marquee() {
              return focused2();
            },
            get children() {
              return props.$.name;
            }
          }));
          insert(_el$3, () => props.$.dial_code);
          createRenderEffect((_p$) => {
            var _v$ = styles$o.country, _v$2 = styles$o.code;
            _v$ !== _p$.e && className(_el$, _p$.e = _v$);
            _v$2 !== _p$.t && className(_el$3, _p$.t = _v$2);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$;
        })();
      }
      const SN_ID$1 = "country_picker";
      let countriesCache = null;
      function CountryCodePicker(props) {
        const [result, setResult] = createSignal([]);
        const [inputValue, setInputValue] = createSignal("");
        const [countries, setCountries] = createSignal([]);
        onMount(() => {
          if (countriesCache) {
            setCountries(countriesCache);
          } else {
            telegram.getCountries().then((countries2) => __async(this, null, function* () {
              if (countries2) {
                countriesCache = countries2;
                setCountries(countries2);
                minisearch.addAll(countries2);
              } else {
                yield fetch(CountryDialInfoURL).then((e2) => e2.json()).then((json) => {
                  countriesCache = json;
                  setCountries(json);
                  minisearch.addAll(json);
                });
              }
            }));
          }
          __CJS__export_default__.add(SN_ID$1, {
            selector: `.${SN_ID$1} input, .${SN_ID$1} .${styles$o.country}`,
            restrict: "self-only"
          });
          __CJS__export_default__.focus(SN_ID$1);
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID$1);
        });
        const debounced = debounce((val) => {
          setResult(minisearch.search(val).map(({
            id: id2
          }) => countries()[id2]));
        }, 100);
        return (() => {
          var _el$4 = _tmpl$3$9();
          _el$4.$$keydown = (e2) => {
            if (e2.key == "Backspace" && false)
              ;
            if (e2.key == "SoftLeft" || e2.key == "Backspace") {
              props.onClose();
              e2.preventDefault();
            }
          };
          insert(_el$4, createComponent(Content, {
            get before() {
              return createComponent(Header, {
                children: "Select a country"
              });
            },
            get children() {
              var _el$5 = _tmpl$2$j(), _el$6 = _el$5.firstChild;
              _el$5.style.setProperty("background-color", "white");
              _el$5.style.setProperty("height", "100%");
              insert(_el$5, createComponent(Search, {
                onFocus: () => __async(this, null, function* () {
                  setSoftkeys("Cancel", "", "");
                  document.activeElement.scrollIntoView(false);
                }),
                onKeyDown: (e2) => {
                  if (["ArrowLeft", "ArrowRight"].includes(e2.key)) {
                    e2.stopImmediatePropagation();
                    e2.stopPropagation();
                  }
                },
                onInput: (e2) => {
                  const target = e2.currentTarget;
                  setInputValue(target.value);
                  if (!target.value) {
                    setResult([]);
                    return;
                  }
                  debounced(target.value);
                },
                placeholder: "Search"
              }), _el$6);
              insert(_el$5, createComponent(For, {
                get each() {
                  return result();
                },
                get fallback() {
                  return createComponent(Show, {
                    get when() {
                      return inputValue().length;
                    },
                    get children() {
                      var _el$7 = _tmpl$4$8();
                      createRenderEffect(() => className(_el$7, styles$o.noresult));
                      return _el$7;
                    }
                  });
                },
                children: (country2) => createComponent(CountryItem, {
                  get onSelect() {
                    return props.onSelect;
                  },
                  $: country2
                })
              }), _el$6);
              insert(_el$6, createComponent(For, {
                get each() {
                  return countries();
                },
                children: (country2) => createComponent(CountryItem, {
                  get onSelect() {
                    return props.onSelect;
                  },
                  $: country2
                })
              }));
              createRenderEffect((_$p) => (_$p = inputValue().length ? "none" : void 0) != null ? _el$6.style.setProperty("display", _$p) : _el$6.style.removeProperty("display"));
              return _el$5;
            }
          }));
          return _el$4;
        })();
      }
      delegateEvents(["keydown"]);
      const header$1 = "_header_15exo_1";
      const wrap = "_wrap_15exo_7";
      const content$1 = "_content_15exo_16";
      const background = "_background_15exo_20";
      const styles$l = {
        header: header$1,
        wrap,
        content: content$1,
        background
      };
      var _tmpl$$q = /* @__PURE__ */ template(`<div>`), _tmpl$2$i = /* @__PURE__ */ template(`<div><div><div>`);
      function Options(props) {
        return createComponent(Content, {
          get children() {
            var _el$ = _tmpl$2$i(), _el$2 = _el$.firstChild, _el$4 = _el$2.firstChild;
            _el$.$$keydown = (e2) => {
              var _a3;
              if (e2.key == "Backspace") {
                (_a3 = props.onClose) == null ? void 0 : _a3.call(props);
                e2.preventDefault();
              }
            };
            insert(_el$2, createComponent(Show, {
              get when() {
                return props.title;
              },
              get children() {
                var _el$3 = _tmpl$$q();
                insert(_el$3, () => props.title);
                createRenderEffect(() => className(_el$3, styles$l.header));
                return _el$3;
              }
            }), _el$4);
            insert(_el$4, () => props.children);
            createRenderEffect((_p$) => {
              var _v$ = styles$l.background, _v$2 = props.maxHeight === void 0 ? "80%" : props.maxHeight || void 0, _v$3 = styles$l.wrap, _v$4 = styles$l.content;
              _v$ !== _p$.e && className(_el$, _p$.e = _v$);
              _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$2.style.setProperty("max-height", _v$2) : _el$2.style.removeProperty("max-height"));
              _v$3 !== _p$.a && className(_el$2, _p$.a = _v$3);
              _v$4 !== _p$.o && className(_el$4, _p$.o = _v$4);
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0,
              o: void 0
            });
            return _el$;
          }
        });
      }
      delegateEvents(["keydown"]);
      const item$3 = "_item_xk4hw_1";
      const tick$1 = "_tick_xk4hw_6";
      const styles$k = {
        item: item$3,
        tick: tick$1
      };
      var _tmpl$$p = /* @__PURE__ */ template(`<svg viewBox="0 0 18 18"class=Cv><path d="M7.142 4 6 5.175 9.709 9 6 12.825 7.142 14 12 9z">`), _tmpl$2$h = /* @__PURE__ */ template(`<div>`);
      function OptionsItem(props) {
        const [local, rest] = splitProps(props, ["classList", "children"]);
        return (() => {
          var _el$ = _tmpl$2$h();
          spread(_el$, mergeProps(rest, {
            get classList() {
              return __spreadProps(__spreadValues({}, local.classList), {
                [styles$k.item]: true,
                [styles$k.tick]: props.arrow
              });
            }
          }), false, true);
          insert(_el$, () => local.children, null);
          insert(_el$, createComponent(Show, {
            get when() {
              return props.arrow;
            },
            get children() {
              return _tmpl$$p();
            }
          }), null);
          return _el$;
        })();
      }
      var _tmpl$$o = /* @__PURE__ */ template(`<svg>`), _tmpl$2$g = /* @__PURE__ */ template(`<svg><rect></svg>`, false, true, false);
      function getBytes(buffer) {
        const result = [];
        while (result.length * 8 < buffer.length)
          result.push(0);
        buffer.forEach((b, i) => result[i >>> 3] |= b << 7 - (i & 7));
        return result;
      }
      function appendBits(buffer, val, len) {
        if (len < 0 || len > 31 || val >>> len != 0)
          throw "Value out of range";
        for (let i = len - 1; i >= 0; i--)
          buffer.push(val >>> i & 1);
      }
      var ECC_CODEWORDS_PER_BLOCK = Object.freeze([
        // Version: (note that index 0 is for padding, and is set to an illegal value)
        //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
        [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
        [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
        [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
        [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
        // High
      ]);
      var MIN_VERSION = 1;
      var MAX_VERSION = 40;
      var NUM_ERROR_CORRECTION_BLOCKS = Object.freeze([
        // Version: (note that index 0 is for padding, and is set to an illegal value)
        //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
        [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
        [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
        [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
        [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
        // High
      ]);
      function errorCorrection(ordinal, formatBits) {
        return {
          ordinal,
          formatBits
        };
      }
      var CONSTANTS = Object.freeze({
        LOW: errorCorrection(0, 1),
        MEDIUM: errorCorrection(1, 0),
        QUARTILE: errorCorrection(2, 3),
        HIGH: errorCorrection(3, 2)
      });
      function toErrorCorrectionLevel(level) {
        return CONSTANTS[level.toUpperCase()];
      }
      function multiply(x, y) {
        if (x >>> 8 != 0 || y >>> 8 != 0)
          throw "Byte out of range";
        let z = 0;
        for (let i = 7; i >= 0; i--) {
          z = z << 1 ^ (z >>> 7) * 285;
          z ^= (y >>> i & 1) * x;
        }
        if (z >>> 8 != 0)
          throw "Assertion error";
        return z;
      }
      var ReedSolomonGenerator = class {
        // Creates a Reed-Solomon ECC generator for the given degree. This could be implemented
        // as a lookup table over all possible parameter values, instead of as an algorithm.
        constructor(degree) {
          // Coefficients of the divisor polynomial, stored from highest to lowest power, excluding the leading term which
          // is always 1. For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.
          __publicField(this, "coefficients", []);
          if (degree < 1 || degree > 255)
            throw new RangeError("Degree out of range (1 to 255)");
          const coefs = this.coefficients;
          for (let i = 0; i < degree - 1; i++)
            coefs.push(0);
          coefs.push(1);
          let root2 = 1;
          for (let i = 0; i < degree; i++) {
            for (let j = 0; j < coefs.length; j++) {
              coefs[j] = multiply(coefs[j], root2);
              if (j + 1 < coefs.length)
                coefs[j] ^= coefs[j + 1];
            }
            root2 = multiply(root2, 2);
          }
        }
        // Computes and returns the Reed-Solomon error correction codewords for the given
        // sequence of data codewords. The returned object is always a new byte array.
        // This method does not alter this object's state (because it is immutable).
        getRemainder(data2) {
          const result = [...this.coefficients].fill(0);
          data2.forEach((b) => {
            const factor = b ^ result.shift();
            result.push(0);
            for (let i = 0; i < result.length; i++)
              result[i] ^= multiply(this.coefficients[i], factor);
          });
          return result;
        }
      };
      function segmentMode(modeBits, numBitsCharCount) {
        return {
          modeBits,
          numBitsCharCount
        };
      }
      function numCharCountBits(segment, ver) {
        if (1 <= ver && ver <= 9)
          return segment.numBitsCharCount[0];
        else if (10 <= ver && ver <= 26)
          return segment.numBitsCharCount[1];
        else if (27 <= ver && ver <= 40)
          return segment.numBitsCharCount[2];
        else
          throw RangeError("Version number out of range (1-40)");
      }
      var CONSTANTS2 = Object.freeze({
        NUMERIC: segmentMode(1, [10, 12, 14]),
        ALPHANUMERIC: segmentMode(2, [9, 11, 13]),
        BYTE: segmentMode(4, [8, 16, 16]),
        KANJI: segmentMode(8, [8, 10, 12]),
        ECI: segmentMode(7, [0, 0, 0])
      });
      var NUMERIC_REGEX = /^[0-9]*$/;
      var ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+./:-]*$/;
      var ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
      function qrSegment(mode, numChars, bitData) {
        if (numChars < 0)
          throw "Invalid argument";
        return {
          mode,
          numChars,
          bitData
        };
      }
      function makeBytes(data2) {
        const bb = [];
        data2.forEach((b) => appendBits(bb, b, 8));
        return qrSegment(CONSTANTS2.BYTE, data2.length, bb);
      }
      function makeNumeric(digits) {
        if (!NUMERIC_REGEX.test(digits))
          throw "String contains non-numeric characters";
        const bb = [];
        let i;
        for (i = 0; i + 3 <= digits.length; i += 3)
          appendBits(bb, parseInt(digits.substr(i, 3), 10), 10);
        const rem = digits.length - i;
        if (rem > 0)
          appendBits(bb, parseInt(digits.substring(i), 10), rem * 3 + 1);
        return qrSegment(CONSTANTS2.NUMERIC, digits.length, bb);
      }
      function makeAlphanumeric(text2) {
        if (!ALPHANUMERIC_REGEX.test(text2))
          throw "String contains unencodable characters in alphanumeric mode";
        const bb = [];
        let i;
        for (i = 0; i + 2 <= text2.length; i += 2) {
          let temp = ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)) * 45;
          temp += ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i + 1));
          appendBits(bb, temp, 11);
        }
        if (i < text2.length)
          appendBits(bb, ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)), 6);
        return qrSegment(CONSTANTS2.ALPHANUMERIC, text2.length, bb);
      }
      function getTotalBits(segs, version2) {
        if (version2 < MIN_VERSION || version2 > MAX_VERSION)
          throw "Version number out of range";
        let result = 0;
        for(let   seg of segs) {
          const ccbits = numCharCountBits(seg.mode, version2);
          if (seg.numChars >= 1 << ccbits)
            return null;
          result += 4 + ccbits + seg.bitData.length;
        }
        return result;
      }
      function toUtf8ByteArray(str) {
        str = encodeURI(str);
        const result = [];
        for (let i = 0; i < str.length; i++) {
          if (str.charAt(i) != "%")
            result.push(str.charCodeAt(i));
          else {
            result.push(parseInt(str.substr(i + 1, 2), 16));
            i += 2;
          }
        }
        return result;
      }
      function makeSegments(text2) {
        if (text2 == "")
          return [];
        else if (NUMERIC_REGEX.test(text2))
          return [makeNumeric(text2)];
        else if (ALPHANUMERIC_REGEX.test(text2))
          return [makeAlphanumeric(text2)];
        else
          return [makeBytes(toUtf8ByteArray(text2))];
      }
      function getBit(x, i) {
        return (x >>> i & 1) != 0;
      }
      function getAlignmentPatternPositions(version2) {
        if (version2 < MIN_VERSION || version2 > MAX_VERSION)
          throw "Version number out of range";
        else if (version2 == 1)
          return [];
        else {
          const size2 = version2 * 4 + 17;
          const numAlign = Math.floor(version2 / 7) + 2;
          const step = version2 == 32 ? 26 : Math.ceil((size2 - 13) / (numAlign * 2 - 2)) * 2;
          const result = [6];
          for (let i = 0, pos = size2 - 7; i < numAlign - 1; i++, pos -= step)
            result.splice(1, 0, pos);
          return result;
        }
      }
      function getNumRawDataModules(ver) {
        if (ver < MIN_VERSION || ver > MAX_VERSION)
          throw "Version number out of range";
        let result = (16 * ver + 128) * ver + 64;
        if (ver >= 2) {
          const numAlign = Math.floor(ver / 7) + 2;
          result -= (25 * numAlign - 10) * numAlign - 55;
          if (ver >= 7)
            result -= 18 * 2;
        }
        return result;
      }
      function getNumDataCodewords(ver, ecl) {
        if (ver < MIN_VERSION || ver > MAX_VERSION)
          throw "Version number out of range";
        return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      }
      var PENALTY_N1 = 3;
      var PENALTY_N2 = 3;
      var PENALTY_N3 = 40;
      var PENALTY_N4 = 10;
      function setFunctionModule(x, y, isBlack, modules, isFunction2) {
        modules[y][x] = isBlack;
        isFunction2[y][x] = true;
      }
      function drawFormatBits(mask, errorCorrectionLevel, size2, modules, isFunction2) {
        const data2 = errorCorrectionLevel.formatBits << 3 | mask;
        let rem = data2;
        for (let i = 0; i < 10; i++)
          rem = rem << 1 ^ (rem >>> 9) * 1335;
        const bits = (data2 << 10 | rem) ^ 21522;
        if (bits >>> 15 != 0)
          throw "Assertion error";
        for (let i = 0; i <= 5; i++)
          setFunctionModule(8, i, getBit(bits, i), modules, isFunction2);
        setFunctionModule(8, 7, getBit(bits, 6), modules, isFunction2);
        setFunctionModule(8, 8, getBit(bits, 7), modules, isFunction2);
        setFunctionModule(7, 8, getBit(bits, 8), modules, isFunction2);
        for (let i = 9; i < 15; i++)
          setFunctionModule(14 - i, 8, getBit(bits, i), modules, isFunction2);
        for (let i = 0; i <= 7; i++)
          setFunctionModule(size2 - 1 - i, 8, getBit(bits, i), modules, isFunction2);
        for (let i = 8; i < 15; i++)
          setFunctionModule(8, size2 - 15 + i, getBit(bits, i), modules, isFunction2);
        setFunctionModule(8, size2 - 8, true, modules, isFunction2);
      }
      function drawVersion(version2, size2, modules, isFunction2) {
        if (version2 < 7)
          return;
        let rem = version2;
        for (let i = 0; i < 12; i++)
          rem = rem << 1 ^ (rem >>> 11) * 7973;
        const bits = version2 << 12 | rem;
        if (bits >>> 18 != 0)
          throw "Assertion error";
        for (let i = 0; i < 18; i++) {
          const bt = getBit(bits, i);
          const a = size2 - 11 + i % 3;
          const b = Math.floor(i / 3);
          setFunctionModule(a, b, bt, modules, isFunction2);
          setFunctionModule(b, a, bt, modules, isFunction2);
        }
      }
      function drawFinderPattern(x, y, size2, modules, isFunction2) {
        for (let i = -4; i <= 4; i++) {
          for (let j = -4; j <= 4; j++) {
            const dist = Math.max(Math.abs(i), Math.abs(j));
            const xx = x + j;
            const yy = y + i;
            if (0 <= xx && xx < size2 && 0 <= yy && yy < size2)
              setFunctionModule(xx, yy, dist != 2 && dist != 4, modules, isFunction2);
          }
        }
      }
      function drawAlignmentPattern(x, y, modules, isFunction2) {
        for (let i = -2; i <= 2; i++) {
          for (let j = -2; j <= 2; j++)
            setFunctionModule(x + j, y + i, Math.max(Math.abs(i), Math.abs(j)) != 1, modules, isFunction2);
        }
      }
      function drawFunctionPatterns(size2, version2, errorCorrectionLevel, modules, isFunction2) {
        for (let i = 0; i < size2; i++) {
          setFunctionModule(6, i, i % 2 == 0, modules, isFunction2);
          setFunctionModule(i, 6, i % 2 == 0, modules, isFunction2);
        }
        drawFinderPattern(3, 3, size2, modules, isFunction2);
        drawFinderPattern(size2 - 4, 3, size2, modules, isFunction2);
        drawFinderPattern(3, size2 - 4, size2, modules, isFunction2);
        const alignPatPos = getAlignmentPatternPositions(version2);
        const numAlign = alignPatPos.length;
        for (let i = 0; i < numAlign; i++) {
          for (let j = 0; j < numAlign; j++) {
            if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
              drawAlignmentPattern(alignPatPos[i], alignPatPos[j], modules, isFunction2);
          }
        }
        drawFormatBits(0, errorCorrectionLevel, size2, modules, isFunction2);
        drawVersion(version2, size2, modules, isFunction2);
      }
      function addEccAndInterleave(data2, version2, errorCorrectionLevel) {
        if (data2.length != getNumDataCodewords(version2, errorCorrectionLevel))
          throw "Invalid argument";
        const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[errorCorrectionLevel.ordinal][version2];
        const blockEccLen = ECC_CODEWORDS_PER_BLOCK[errorCorrectionLevel.ordinal][version2];
        const rawCodewords = Math.floor(getNumRawDataModules(version2) / 8);
        const numShortBlocks = numBlocks - rawCodewords % numBlocks;
        const shortBlockLen = Math.floor(rawCodewords / numBlocks);
        const blocks = [];
        const rs = new ReedSolomonGenerator(blockEccLen);
        for (let i = 0, k = 0; i < numBlocks; i++) {
          const dat = data2.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
          k += dat.length;
          const ecc = rs.getRemainder(dat);
          if (i < numShortBlocks)
            dat.push(0);
          ecc.forEach((b) => dat.push(b));
          blocks.push(dat);
        }
        const result = [];
        for (let i = 0; i < blocks[0].length; i++) {
          for (let j = 0; j < blocks.length; j++) {
            if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
              result.push(blocks[j][i]);
          }
        }
        if (result.length != rawCodewords)
          throw "Assertion error";
        return result;
      }
      function drawCodewords(data2, version2, size2, isFunction2, modules) {
        if (data2.length != Math.floor(getNumRawDataModules(version2) / 8))
          throw "Invalid argument";
        let i = 0;
        for (let right = size2 - 1; right >= 1; right -= 2) {
          if (right == 6)
            right = 5;
          for (let vert = 0; vert < size2; vert++) {
            for (let j = 0; j < 2; j++) {
              const x = right - j;
              const upward = (right + 1 & 2) == 0;
              const y = upward ? size2 - 1 - vert : vert;
              if (!isFunction2[y][x] && i < data2.length * 8) {
                modules[y][x] = getBit(data2[i >>> 3], 7 - (i & 7));
                i++;
              }
            }
          }
        }
        if (i != data2.length * 8)
          throw "Assertion error";
      }
      function applyMask(mask, size2, modules, isFunction2) {
        if (mask < 0 || mask > 7)
          throw "Mask value out of range";
        for (let y = 0; y < size2; y++) {
          for (let x = 0; x < size2; x++) {
            let invert;
            switch (mask) {
              case 0:
                invert = (x + y) % 2 == 0;
                break;
              case 1:
                invert = y % 2 == 0;
                break;
              case 2:
                invert = x % 3 == 0;
                break;
              case 3:
                invert = (x + y) % 3 == 0;
                break;
              case 4:
                invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
                break;
              case 5:
                invert = x * y % 2 + x * y % 3 == 0;
                break;
              case 6:
                invert = (x * y % 2 + x * y % 3) % 2 == 0;
                break;
              case 7:
                invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
                break;
              default:
                throw "Assertion error";
            }
            if (invert && !isFunction2[y][x])
              modules[y][x] = !modules[y][x];
          }
        }
      }
      function getPenaltyScore(size2, modules) {
        let result = 0;
        for (let y = 0; y < size2; y++) {
          for (let x = 0, runX = 0, colorX = false; x < size2; x++) {
            if (x == 0 || modules[y][x] != colorX) {
              colorX = modules[y][x];
              runX = 1;
            } else {
              runX++;
              if (runX == 5)
                result += PENALTY_N1;
              else if (runX > 5)
                result++;
            }
          }
        }
        for (let x = 0; x < size2; x++) {
          for (let y = 0, runY = 0, colorY = false; y < size2; y++) {
            if (y == 0 || modules[y][x] != colorY) {
              colorY = modules[y][x];
              runY = 1;
            } else {
              runY++;
              if (runY == 5)
                result += PENALTY_N1;
              else if (runY > 5)
                result++;
            }
          }
        }
        for (let y = 0; y < size2 - 1; y++) {
          for (let x = 0; x < size2 - 1; x++) {
            const color2 = modules[y][x];
            if (color2 == modules[y][x + 1] && color2 == modules[y + 1][x] && color2 == modules[y + 1][x + 1])
              result += PENALTY_N2;
          }
        }
        for (let y = 0; y < size2; y++) {
          for (let x = 0, bits = 0; x < size2; x++) {
            bits = bits << 1 & 2047 | (modules[y][x] ? 1 : 0);
            if (x >= 10 && (bits == 93 || bits == 1488))
              result += PENALTY_N3;
          }
        }
        for (let x = 0; x < size2; x++) {
          for (let y = 0, bits = 0; y < size2; y++) {
            bits = bits << 1 & 2047 | (modules[y][x] ? 1 : 0);
            if (y >= 10 && (bits == 93 || bits == 1488))
              result += PENALTY_N3;
          }
        }
        let black = 0;
        modules.forEach((row) => {
          row.forEach((color2) => {
            if (color2)
              black++;
          });
        });
        const total = size2 * size2;
        const k = Math.ceil(Math.abs(black * 20 - total * 10) / total) - 1;
        result += k * PENALTY_N4;
        return result;
      }
      function qrCode(datacodewords, mask, version2, errorCorrectionLevel) {
        if (mask < -1 || mask > 7)
          throw "Mask value out of range";
        if (version2 < MIN_VERSION || version2 > MAX_VERSION)
          throw "Version value out of range";
        const size2 = version2 * 4 + 17;
        const modules = [];
        const isFunction2 = [];
        const row = [];
        for (let i = 0; i < size2; i++)
          row.push(false);
        for (let i = 0; i < size2; i++) {
          modules.push(row.slice());
          isFunction2.push(row.slice());
        }
        drawFunctionPatterns(size2, version2, errorCorrectionLevel, modules, isFunction2);
        const allCodewords = addEccAndInterleave(datacodewords, version2, errorCorrectionLevel);
        drawCodewords(allCodewords, version2, size2, isFunction2, modules);
        if (mask == -1) {
          let minPenalty = Number.MAX_SAFE_INTEGER;
          for (let i = 0; i < 8; i++) {
            drawFormatBits(i, errorCorrectionLevel, size2, modules, isFunction2);
            applyMask(i, size2, modules, isFunction2);
            const penalty = getPenaltyScore(size2, modules);
            if (penalty < minPenalty) {
              mask = i;
              minPenalty = penalty;
            }
            applyMask(i, size2, modules, isFunction2);
          }
        }
        if (mask < 0 || mask > 7)
          throw "Assertion error";
        drawFormatBits(mask, errorCorrectionLevel, size2, modules, isFunction2);
        applyMask(mask, size2, modules, isFunction2);
        return {
          version: version2,
          size: size2,
          mask,
          errorCorrectionLevel,
          modules,
          isFunction: isFunction2
        };
      }
      function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
        if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
          throw "Invalid value";
        let version2;
        let dataUsedBits;
        for (version2 = minVersion; ; version2++) {
          const dataCapacityBits2 = getNumDataCodewords(version2, ecl) * 8;
          const usedBits = getTotalBits(segs, version2);
          if (usedBits != null && usedBits <= dataCapacityBits2) {
            dataUsedBits = usedBits;
            break;
          }
          if (version2 >= maxVersion)
            throw `Data too long (> ${dataCapacityBits2 / 8} bytes)`;
        }
        [CONSTANTS.MEDIUM, CONSTANTS.QUARTILE, CONSTANTS.HIGH].forEach((newEcl) => {
          if (boostEcl && dataUsedBits <= getNumDataCodewords(version2, newEcl) * 8)
            ecl = newEcl;
        });
        const bb = [];
        segs.forEach((seg) => {
          appendBits(bb, seg.mode.modeBits, 4);
          appendBits(bb, seg.numChars, numCharCountBits(seg.mode, version2));
          seg.bitData.forEach((b) => bb.push(b));
        });
        const dataCapacityBits = getNumDataCodewords(version2, ecl) * 8;
        if (bb.length > dataCapacityBits)
          throw "Assertion error";
        appendBits(bb, 0, Math.min(4, dataCapacityBits - bb.length));
        appendBits(bb, 0, (8 - bb.length % 8) % 8);
        if (bb.length % 8 != 0)
          throw "Assertion error";
        for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
          appendBits(bb, padByte, 8);
        return qrCode(getBytes(bb), mask, version2, ecl);
      }
      function encodeText(text2, ecl) {
        const segs = makeSegments(text2);
        return encodeSegments(segs, ecl);
      }
      var MaskType;
      (function(MaskType3) {
        MaskType3[MaskType3["ALTERNATING_TILES"] = 0] = "ALTERNATING_TILES";
        MaskType3[MaskType3["ALTERNATING_HORIZONTAL_LINES"] = 1] = "ALTERNATING_HORIZONTAL_LINES";
        MaskType3[MaskType3["ALTERNATING_VERTICAL_LINES_TWO_GAP"] = 2] = "ALTERNATING_VERTICAL_LINES_TWO_GAP";
        MaskType3[MaskType3["DIAGONAL"] = 3] = "DIAGONAL";
        MaskType3[MaskType3["FOUR_BY_TWO_RECTANGLE_ALTERNATING"] = 4] = "FOUR_BY_TWO_RECTANGLE_ALTERNATING";
        MaskType3[MaskType3["FLOWER_IN_SQAURE"] = 5] = "FLOWER_IN_SQAURE";
        MaskType3[MaskType3["DIAGONAL_SQUARE"] = 6] = "DIAGONAL_SQUARE";
        MaskType3[MaskType3["ALTERNATING_PUZZLE_PIECE"] = 7] = "ALTERNATING_PUZZLE_PIECE";
      })(MaskType || (MaskType = {}));
      var defaultFrameOptions = Object.freeze({
        level: CONSTANTS.LOW
      });
      function generateFrame(options2) {
        var _a3;
        const level = (_a3 = options2.level) != null ? _a3 : defaultFrameOptions.level;
        const qrCode2 = encodeText(options2.value, typeof level == "string" ? toErrorCorrectionLevel(level) : level);
        return {
          buffer: Uint8Array.from(qrCode2.modules.map((row) => row.map((bit) => bit ? 1 : 0)).flat()),
          size: qrCode2.size,
          version: qrCode2.version
        };
      }
      var QRCodeSVG = (_props) => {
        const props = mergeProps(__spreadProps(__spreadValues({}, defaultFrameOptions), {
          backgroundColor: "white",
          backgroundAlpha: 1,
          foregroundColor: "black",
          foregroundAlpha: 1,
          width: 100,
          height: 100
        }), _props);
        const frame = createMemo(() => generateFrame(props));
        const moduleSizeWidth = createMemo(() => props.width / frame().size);
        const moduleSizeHeight = createMemo(() => props.height / frame().size);
        const rectangles = createMemo(() => {
          let rects = [];
          for (let i = 0; i < frame().size; i++) {
            for (let j = 0; j < frame().size; j++) {
              rects = [...rects, {
                x: moduleSizeWidth() * i,
                y: moduleSizeHeight() * j,
                enabled: frame().buffer[j * frame().size + i] === 1
              }];
            }
          }
          return rects;
        });
        return (() => {
          var _el$ = _tmpl$$o();
          insert(_el$, createComponent(For, {
            get each() {
              return rectangles();
            },
            children: (rectangle) => (() => {
              var _el$2 = _tmpl$2$g();
              createRenderEffect((_p$) => {
                var _v$3 = moduleSizeWidth(), _v$4 = moduleSizeHeight(), _v$5 = rectangle.x, _v$6 = rectangle.y, _v$7 = rectangle.enabled ? props.foregroundColor : props.backgroundColor, _v$8 = rectangle.enabled ? props.foregroundAlpha : props.backgroundAlpha;
                _v$3 !== _p$.e && setAttribute(_el$2, "width", _p$.e = _v$3);
                _v$4 !== _p$.t && setAttribute(_el$2, "height", _p$.t = _v$4);
                _v$5 !== _p$.a && setAttribute(_el$2, "x", _p$.a = _v$5);
                _v$6 !== _p$.o && setAttribute(_el$2, "y", _p$.o = _v$6);
                _v$7 !== _p$.i && ((_p$.i = _v$7) != null ? _el$2.style.setProperty("fill", _v$7) : _el$2.style.removeProperty("fill"));
                _v$8 !== _p$.n && ((_p$.n = _v$8) != null ? _el$2.style.setProperty("opacity", _v$8) : _el$2.style.removeProperty("opacity"));
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0,
                o: void 0,
                i: void 0,
                n: void 0
              });
              return _el$2;
            })()
          }));
          createRenderEffect((_p$) => {
            var _v$ = props.width, _v$2 = props.height;
            _v$ !== _p$.e && setAttribute(_el$, "width", _p$.e = _v$);
            _v$2 !== _p$.t && setAttribute(_el$, "height", _p$.t = _v$2);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$;
        })();
      };
      var _tmpl$$n = /* @__PURE__ */ template(`<div>Please wait this may take a while...`), _tmpl$2$f = /* @__PURE__ */ template(`<div>`), _tmpl$3$8 = /* @__PURE__ */ template(`<div tabindex=-1><div></div><svg viewBox="0 0 18 18"><path d="M7.142 4 6 5.175 9.709 9 6 12.825 7.142 14 12 9z">`), _tmpl$4$7 = /* @__PURE__ */ template(`<div><input>`), _tmpl$5$5 = /* @__PURE__ */ template(`<div><div><div></div><div>`);
      let countryCache = null;
      const SN_ID = "login";
      const SN_ID_OPTIONS$3 = "options";
      const LoadingThing = () => (() => {
        var _el$ = _tmpl$$n();
        _el$.style.setProperty("padding", "1rem");
        return _el$;
      })();
      function QRCode(props) {
        onMount(() => {
          setSoftkeys("Cancel", "", "");
          blur();
        });
        createRenderEffect(() => {
          const link = qrLink();
          if (link === null) {
            telegram.requestQR();
            return;
          }
        });
        useKeypress(["Backspace", "SoftLeft"], (e2) => {
          e2.preventDefault();
          props.onCancel();
        });
        return createComponent(Options, {
          maxHeight: null,
          get title() {
            return qrLink() === null ? "Loading" : "QRCode";
          },
          get children() {
            return [createComponent(Show, {
              get when() {
                return qrLink() === null;
              },
              get children() {
                return createComponent(LoadingThing, {});
              }
            }), (() => {
              var _el$2 = _tmpl$2$f();
              _el$2.style.setProperty("background", "white");
              _el$2.style.setProperty("align-content", "center");
              _el$2.style.setProperty("justify-content", "center");
              _el$2.style.setProperty("padding", "1rem");
              insert(_el$2, createComponent(Show, {
                get when() {
                  return qrLink();
                },
                children: (link) => (
                  // @ts-ignore
                  createComponent(QRCodeSVG, {
                    width: 200,
                    height: 200,
                    get value() {
                      return link();
                    }
                  })
                )
              }));
              createRenderEffect((_$p) => (_$p = qrLink() ? "flex" : "none") != null ? _el$2.style.setProperty("display", _$p) : _el$2.style.removeProperty("display"));
              return _el$2;
            })()];
          }
        });
      }
      function LoadingScreen() {
        onMount(() => {
          setSoftkeys("", "", "");
        });
        return createComponent(Options, {
          title: "Loading",
          get children() {
            return createComponent(LoadingThing, {});
          }
        });
      }
      function HomeOptions(props) {
        onMount(() => {
          __CJS__export_default__.add(SN_ID_OPTIONS$3, {
            selector: ".option",
            restrict: "self-only"
          });
          __CJS__export_default__.focus(SN_ID_OPTIONS$3);
          setSoftkeys("", "OK", "");
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID_OPTIONS$3);
        });
        return createComponent(Options, {
          get onClose() {
            return props.onClose;
          },
          title: "Options",
          get children() {
            return [createComponent(OptionsItem, {
              get classList() {
                return {
                  option: true,
                  [styles$r.item]: true
                };
              },
              "on:sn-enter-down": () => {
                props.showQr();
              },
              tabIndex: -1,
              children: "Log in by QR Code"
            }), createComponent(Show, {
              get when() {
                return !localStorage.getItem("NO_ADS");
              },
              get children() {
                return createComponent(OptionsItem, {
                  get classList() {
                    return {
                      option: true,
                      [styles$r.item]: true
                    };
                  },
                  tabIndex: -1,
                  "on:sn-enter-down": () => {
                    showKaiAd();
                    props.onClose();
                  },
                  children: "Show Ad"
                });
              }
            })];
          }
        });
      }
      function blur() {
        var _a3;
        (_a3 = document.activeElement) == null ? void 0 : _a3.blur();
        __CJS__export_default__.pause();
      }
      function Login() {
        let inputRef;
        const [country2, setCountry] = createSignal(countryCache);
        const [value, setValue] = createSignal("");
        onMount(() => __async(this, null, function* () {
          if (countryCache)
            return setCountry(countryCache);
          const nearest = yield telegram.getNearestDC();
          if (nearest && nearest.dial_code != "?") {
            countryCache = nearest;
            setCountry(nearest);
          }
        }));
        const [loading2, setLoading] = createSignal(false);
        const [placeholder, setPlaceholder] = createSignal("Phone number");
        const [inputType, setInputType] = createSignal("tel");
        createEffect(() => {
          inputType();
          untrack(updateSoftkeys);
        });
        const [showQR, setShowQR] = createSignal(false);
        function resetLoading() {
          __CJS__export_default__.resume();
          setLoading(false);
          __CJS__export_default__.focus(SN_ID);
          untrack(updateSoftkeys);
        }
        EE$1.on("loginError", resetLoading);
        onCleanup(() => {
          EE$1.off("loginError", resetLoading);
        });
        createEffect(() => {
          const state = loginState();
          batch(() => {
            setValue("");
            setShowPicker(false);
            setShowOptions(false);
            setShowQR(false);
            resetLoading();
            switch (state) {
              case LoginState.Phone:
                setPlaceholder("Phone number");
                setInputType("tel");
                break;
              case LoginState.Code:
                setInputType("tel");
                setPlaceholder("Code");
                break;
              case LoginState.Password:
                setInputType("password");
                setPlaceholder("Password");
                break;
            }
          });
        });
        const [inputFocused, setInputFocused] = createSignal(false);
        function updateSoftkeys() {
          setStatusbarColor("#1c96c3");
          switch (loginState()) {
            case LoginState.Phone:
              setSoftkeys("Options", inputFocused() ? "" : "Select", value() ? "Next" : "");
              break;
            case LoginState.Code:
              setSoftkeys("", "", "Next");
              break;
            case LoginState.Password:
              setSoftkeys(inputType() == "password" ? "Show" : "Hide", "", "Next");
              break;
          }
        }
        const [showPicker, setShowPicker] = createSignal(false);
        onMount(() => {
          __CJS__export_default__.add(SN_ID, {
            selector: `.${styles$r.login} .${styles$r.select}, .${styles$r.login} input`,
            restrict: "self-only",
            defaultElement: `.${styles$r.login} input`
          });
          __CJS__export_default__.focus(SN_ID);
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID);
        });
        createEffect(() => {
          const passwordThing = loginState() == LoginState.Password && inputType() != "tel";
          if (passwordThing) {
            sleep$1(0).then(() => {
              const e2 = document.activeElement;
              e2 == null ? void 0 : e2.blur();
              __CJS__export_default__.focus(SN_ID);
            });
          }
        });
        const [phone, setPhone] = createSignal("");
        const [showOptions, setShowOptions] = createSignal(false);
        return [(() => {
          var _el$3 = _tmpl$5$5(), _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;
          _el$3.$$keydown = (e2) => {
            switch (e2.key) {
              case "SoftLeft":
                switch (loginState()) {
                  case LoginState.Phone:
                    setShowOptions(true);
                    break;
                  case LoginState.Password:
                    setInputType((e22) => e22 == "text" ? "password" : "text");
                    break;
                }
                break;
              case "SoftRight":
                switch (loginState()) {
                  case LoginState.Phone:
                    const $country = country2();
                    if (!showPicker() && $country && value()) {
                      const phone2 = $country.dial_code + value();
                      setPhone(phone2);
                      EE$1.emit("phone", phone2);
                      blur();
                      setLoading(true);
                    }
                    break;
                  case LoginState.Code:
                    EE$1.emit("code", value());
                    blur();
                    setLoading(true);
                    break;
                  case LoginState.Password:
                    EE$1.emit("password", value());
                    blur();
                    setLoading(true);
                    break;
                }
                break;
            }
          };
          insert(_el$5, createComponent(Switch, {
            get children() {
              return [createComponent(Match, {
                get when() {
                  return loginState() == LoginState.Phone;
                },
                children: "Sign in to Telegram"
              }), createComponent(Match, {
                get when() {
                  return loginState() == LoginState.Code;
                },
                get children() {
                  return phone();
                }
              }), createComponent(Match, {
                get when() {
                  return loginState() == LoginState.Password;
                },
                children: "Enter Your Password"
              })];
            }
          }));
          insert(_el$6, createComponent(Switch, {
            get children() {
              return [createComponent(Match, {
                get when() {
                  return loginState() == LoginState.Phone;
                },
                children: "Please confirm your country code and enter your phone number."
              }), createComponent(Match, {
                get when() {
                  return loginState() == LoginState.Code;
                },
                children: "We've sent the code to the Telegram app on your other device."
              }), createComponent(Match, {
                get when() {
                  return loginState() == LoginState.Password;
                },
                children: "Your account is protected with an additional password"
              })];
            }
          }));
          insert(_el$3, createComponent(Show, {
            get when() {
              return loginState() == LoginState.Phone;
            },
            get children() {
              var _el$7 = _tmpl$3$8(), _el$8 = _el$7.firstChild;
              addEventListener(_el$7, "sn-enter-down", () => {
                setShowPicker(true);
              });
              _el$7.addEventListener("focus", () => {
                setInputFocused(false);
                updateSoftkeys();
              });
              insert(_el$8, createComponent(Show, {
                get when() {
                  return country2();
                },
                fallback: "Loading...",
                children: (country22) => [createMemo(() => country22().dial_code), " ", createMemo(() => country22().name)]
              }));
              createRenderEffect(() => className(_el$7, styles$r.select));
              return _el$7;
            }
          }), null);
          insert(_el$3, createComponent(Show, {
            get when() {
              return loginState() != LoginState.Password;
            },
            get children() {
              var _el$9 = _tmpl$4$7(), _el$10 = _el$9.firstChild;
              _el$10.$$input = (e2) => {
                setValue(e2.currentTarget.value);
                updateSoftkeys();
              };
              _el$10.$$keydown = (e2) => {
                if (["ArrowLeft", "ArrowRight"].includes(e2.key)) {
                  e2.stopImmediatePropagation();
                  e2.stopPropagation();
                }
              };
              _el$10.addEventListener("focus", () => {
                setInputFocused(true);
                updateSoftkeys();
              });
              var _ref$ = inputRef;
              typeof _ref$ === "function" ? use(_ref$, _el$10) : inputRef = _el$10;
              createRenderEffect((_p$) => {
                var _v$ = {
                  [styles$r.input_wrap]: true,
                  [styles$r.focus]: inputFocused()
                }, _v$2 = inputType(), _v$3 = placeholder();
                _p$.e = classList$1(_el$9, _v$, _p$.e);
                _v$2 !== _p$.t && setAttribute(_el$10, "type", _p$.t = _v$2);
                _v$3 !== _p$.a && setAttribute(_el$10, "placeholder", _p$.a = _v$3);
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0
              });
              createRenderEffect(() => _el$10.value = value());
              return _el$9;
            }
          }), null);
          insert(_el$3, createComponent(Show, {
            get when() {
              return createMemo(() => loginState() == LoginState.Password)() && inputType() != "tel";
            },
            get children() {
              var _el$11 = _tmpl$4$7(), _el$12 = _el$11.firstChild;
              _el$12.$$input = (e2) => {
                setValue(e2.currentTarget.value);
                updateSoftkeys();
              };
              _el$12.$$keydown = (e2) => {
                if (e2.key.includes("Arrow")) {
                  e2.stopImmediatePropagation();
                  e2.stopPropagation();
                }
              };
              _el$12.addEventListener("focus", () => {
                setInputFocused(true);
                updateSoftkeys();
              });
              createRenderEffect((_p$) => {
                var _v$4 = {
                  [styles$r.input_wrap]: true,
                  [styles$r.focus]: inputFocused()
                }, _v$5 = inputType(), _v$6 = placeholder();
                _p$.e = classList$1(_el$11, _v$4, _p$.e);
                _v$5 !== _p$.t && setAttribute(_el$12, "type", _p$.t = _v$5);
                _v$6 !== _p$.a && setAttribute(_el$12, "placeholder", _p$.a = _v$6);
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0
              });
              createRenderEffect(() => _el$12.value = value());
              return _el$11;
            }
          }), null);
          createRenderEffect((_p$) => {
            var _v$7 = styles$r.login, _v$8 = styles$r.header, _v$9 = styles$r.heading, _v$10 = styles$r.text;
            _v$7 !== _p$.e && className(_el$3, _p$.e = _v$7);
            _v$8 !== _p$.t && className(_el$4, _p$.t = _v$8);
            _v$9 !== _p$.a && className(_el$5, _p$.a = _v$9);
            _v$10 !== _p$.o && className(_el$6, _p$.o = _v$10);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0
          });
          return _el$3;
        })(), createComponent(Show, {
          get when() {
            return showPicker();
          },
          get children() {
            return createComponent(CountryCodePicker, {
              onSelect: (e2) => {
                setCountry(e2);
                setShowPicker(false);
                inputRef.focus();
              },
              onClose: () => {
                setShowPicker(false);
                inputRef.focus();
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return showOptions();
          },
          get children() {
            return createComponent(HomeOptions, {
              onClose: () => {
                __CJS__export_default__.focus(SN_ID);
                setShowOptions(false);
                updateSoftkeys();
              },
              showQr: () => {
                setShowOptions(false);
                setShowQR(true);
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return loading2();
          },
          get children() {
            return createComponent(LoadingScreen, {});
          }
        }), createComponent(Show, {
          get when() {
            return showQR();
          },
          get children() {
            return createComponent(QRCode, {
              onCancel: () => {
                setShowQR(false);
                telegram.abortQR();
                resetLoading();
              }
            });
          }
        })];
      }
      delegateEvents(["keydown", "input"]);
      const loading = "_loading_gxj9g_1";
      const progressRing = "_progressRing_gxj9g_26";
      const styles$j = {
        loading,
        progressRing
      };
      var _tmpl$$m = /* @__PURE__ */ template(`<svg height=24 width=24 viewBox="0 0 16 16"><circle cx=8px cy=8px r=7px>`), _tmpl$2$e = /* @__PURE__ */ template(`<div>`);
      function Loading() {
        setStatusbarColor("rgb(0,0,0)");
        useKeypress("Backspace", () => {
          window.close();
        });
        const [showSpinner, setShowSpinner] = createSignal(false);
        onMount(() => {
          const timeout = setTimeout(() => {
            setShowSpinner(true);
          }, 11e3);
          onCleanup(() => clearTimeout(timeout));
        });
        return (() => {
          var _el$ = _tmpl$2$e();
          insert(_el$, createComponent(Show, {
            get when() {
              return showSpinner();
            },
            get children() {
              var _el$2 = _tmpl$$m();
              createRenderEffect(() => setAttribute(_el$2, "class", styles$j.progressRing));
              return _el$2;
            }
          }));
          createRenderEffect((_p$) => {
            var _v$ = window.outerHeight ? window.outerHeight + "px" : void 0, _v$2 = styles$j.loading;
            _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$.style.setProperty("height", _v$) : _el$.style.removeProperty("height"));
            _v$2 !== _p$.t && className(_el$, _p$.t = _v$2);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$;
        })();
      }
      const home = "_home_lofjm_1";
      const icon$4 = "_icon_lofjm_8";
      const details$1 = "_details_lofjm_19";
      const top$1 = "_top_lofjm_29";
      const bottom$1 = "_bottom_lofjm_30";
      const meta = "_meta_lofjm_38";
      const count = "_count_lofjm_44";
      const muted = "_muted_lofjm_57";
      const name$1 = "_name_lofjm_61";
      const time$3 = "_time_lofjm_69";
      const desc = "_desc_lofjm_87";
      const sender = "_sender_lofjm_100";
      const check = "_check_lofjm_104";
      const icons$1 = "_icons_lofjm_118";
      const verified = "_verified_lofjm_118";
      const dialog = "_dialog_lofjm_130";
      const dialogs = "_dialogs_lofjm_150";
      const item$2 = "_item_lofjm_159";
      const styles$i = {
        home,
        icon: icon$4,
        details: details$1,
        top: top$1,
        bottom: bottom$1,
        meta,
        count,
        muted,
        name: name$1,
        time: time$3,
        desc,
        sender,
        check,
        icons: icons$1,
        verified,
        dialog,
        dialogs,
        item: item$2
      };
      const tabs = "_tabs_iw4r9_1";
      const tab = "_tab_iw4r9_1";
      const selected$1 = "_selected_iw4r9_23";
      const styles$h = {
        tabs,
        tab,
        selected: selected$1
      };
      const t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e$1 = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n = (t2, n2) => {
        if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
          const o2 = getComputedStyle(t2, null);
          return e$1(o2.overflowY, n2) || e$1(o2.overflowX, n2) || ((t3) => {
            const e2 = ((t4) => {
              if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
                return null;
              try {
                return t4.ownerDocument.defaultView.frameElement;
              } catch (t5) {
                return null;
              }
            })(t3);
            return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
          })(t2);
        }
        return false;
      }, o$1 = (t2, e2, n2, o2, l2, r2, i, s) => r2 < t2 && i > e2 || r2 > t2 && i < e2 ? 0 : r2 <= t2 && s <= n2 || i >= e2 && s >= n2 ? r2 - t2 - o2 : i > e2 && s < n2 || r2 < t2 && s > n2 ? i - e2 + l2 : 0, l = (t2) => {
        const e2 = t2.parentElement;
        return null == e2 ? t2.getRootNode().host || null : e2;
      }, r = (e2, r2) => {
        var i, s, d, h2;
        if ("undefined" == typeof document)
          return [];
        const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t2) => t2 !== a;
        if (!t(e2))
          throw new TypeError("Invalid target");
        const m2 = document.scrollingElement || document.documentElement, w = [];
        let W = e2;
        for (; t(W) && p(W); ) {
          if (W = l(W), W === m2) {
            w.push(W);
            break;
          }
          null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
        }
        const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h2 = null == (d = window.visualViewport) ? void 0 : d.height) ? h2 : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e2.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
          const e3 = window.getComputedStyle(t2);
          return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
        })(e2);
        let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
        const L = [];
        for (let t2 = 0; t2 < w.length; t2++) {
          const e3 = w[t2], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h3 } = e3.getBoundingClientRect();
          if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e3 === m2 && !n(e3) || x >= i2 && I <= d2 && R >= h3 && C <= s2))
            return L;
          const a2 = getComputedStyle(e3), g2 = parseInt(a2.borderLeftWidth, 10), p2 = parseInt(a2.borderTopWidth, 10), W2 = parseInt(a2.borderRightWidth, 10), T2 = parseInt(a2.borderBottomWidth, 10);
          let B2 = 0, F2 = 0;
          const V2 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - g2 - W2 : 0, S = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - p2 - T2 : 0, X = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : r3 / e3.offsetWidth : 0, Y = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : l2 / e3.offsetHeight : 0;
          if (m2 === e3)
            B2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o$1(M, M + H, H, p2, T2, M + k, M + k + v, v) : k - H / 2, F2 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o$1(y, y + b, b, g2, W2, y + D, y + D + E, E), B2 = Math.max(0, B2 + M), F2 = Math.max(0, F2 + y);
          else {
            B2 = "start" === f ? k - i2 - p2 : "end" === f ? k - d2 + T2 + S : "nearest" === f ? o$1(i2, d2, l2, p2, T2 + S, k, k + v, v) : k - (i2 + l2 / 2) + S / 2, F2 = "start" === u ? D - h3 - g2 : "center" === u ? D - (h3 + r3 / 2) + V2 / 2 : "end" === u ? D - s2 + W2 + V2 : o$1(h3, s2, r3, g2, W2 + V2, D, D + E, E);
            const { scrollLeft: t3, scrollTop: n2 } = e3;
            B2 = 0 === Y ? 0 : Math.max(0, Math.min(n2 + B2 / Y, e3.scrollHeight - l2 / Y + S)), F2 = 0 === X ? 0 : Math.max(0, Math.min(t3 + F2 / X, e3.scrollWidth - r3 / X + V2)), k += n2 - B2, D += t3 - F2;
          }
          L.push({ el: e3, top: B2, left: F2 });
        }
        return L;
      };
      const o = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
      function e(e2, r$1) {
        if (!e2.isConnected || !((t2) => {
          let o2 = t2;
          for (; o2 && o2.parentNode; ) {
            if (o2.parentNode === document)
              return true;
            o2 = o2.parentNode instanceof ShadowRoot ? o2.parentNode.host : o2.parentNode;
          }
          return false;
        })(e2))
          return;
        const n2 = ((t2) => {
          const o2 = window.getComputedStyle(t2);
          return { top: parseFloat(o2.scrollMarginTop) || 0, right: parseFloat(o2.scrollMarginRight) || 0, bottom: parseFloat(o2.scrollMarginBottom) || 0, left: parseFloat(o2.scrollMarginLeft) || 0 };
        })(e2);
        if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r$1))
          return r$1.behavior(r(e2, r$1));
        const l2 = "boolean" == typeof r$1 || null == r$1 ? void 0 : r$1.behavior;
        for(let   { el: a, top: i, left: s } of r(e2, o(r$1))) {
          const t2 = i - n2.top + n2.bottom, o2 = s - n2.left + n2.right;
          a.scroll({ top: t2, left: o2, behavior: l2 });
        }
      }
      var _tmpl$$l = /* @__PURE__ */ template(`<div>`);
      function Tab(props) {
        let divRef;
        createEffect(() => {
          if (props.selected) {
            e(divRef, {
              block: "center",
              inline: "center"
            });
          }
        });
        return (() => {
          var _el$ = _tmpl$$l();
          addEventListener(_el$, "click", props.onClick, true);
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$) : divRef = _el$;
          insert(_el$, () => props.children);
          createRenderEffect((_$p) => classList$1(_el$, {
            [styles$h.tab]: true,
            [styles$h.selected]: props.selected
          }, _$p));
          return _el$;
        })();
      }
      function Tabs(props) {
        return (() => {
          var _el$2 = _tmpl$$l();
          insert(_el$2, () => props.children);
          createRenderEffect(() => className(_el$2, styles$h.tabs));
          return _el$2;
        })();
      }
      delegateEvents(["click"]);
      const color = "_color_s70px_22";
      const photo$2 = "_photo_s70px_84";
      const thumb$3 = "_thumb_s70px_94";
      const animate = "_animate_s70px_97";
      const styles$g = {
        color,
        photo: photo$2,
        thumb: thumb$3,
        animate
      };
      function commonjsRequire(path2) {
        throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
      }
      var localforage$1 = { exports: {} };
      /*!
          localForage -- Offline Storage, Improved
          Version 1.10.0
          https://localforage.github.io/localForage
          (c) 2013-2017 Mozilla, Apache License 2.0
      */
      (function(module2, exports2) {
        (function(f) {
          {
            module2.exports = f();
          }
        })(function() {
          return function e2(t2, n2, r2) {
            function s(o3, u) {
              if (!n2[o3]) {
                if (!t2[o3]) {
                  var a = typeof commonjsRequire == "function" && commonjsRequire;
                  if (!u && a)
                    return a(o3, true);
                  if (i)
                    return i(o3, true);
                  var f = new Error("Cannot find module '" + o3 + "'");
                  throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l2 = n2[o3] = { exports: {} };
                t2[o3][0].call(l2.exports, function(e3) {
                  var n3 = t2[o3][1][e3];
                  return s(n3 ? n3 : e3);
                }, l2, l2.exports, e2, t2, n2, r2);
              }
              return n2[o3].exports;
            }
            var i = typeof commonjsRequire == "function" && commonjsRequire;
            for (var o2 = 0; o2 < r2.length; o2++)
              s(r2[o2]);
            return s;
          }({ 1: [function(_dereq_, module3, exports3) {
            (function(global2) {
              var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
              var scheduleDrain;
              {
                if (Mutation) {
                  var called2 = 0;
                  var observer = new Mutation(nextTick);
                  var element = global2.document.createTextNode("");
                  observer.observe(element, {
                    characterData: true
                  });
                  scheduleDrain = function() {
                    element.data = called2 = ++called2 % 2;
                  };
                } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
                  var channel = new global2.MessageChannel();
                  channel.port1.onmessage = nextTick;
                  scheduleDrain = function() {
                    channel.port2.postMessage(0);
                  };
                } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
                  scheduleDrain = function() {
                    var scriptEl = global2.document.createElement("script");
                    scriptEl.onreadystatechange = function() {
                      nextTick();
                      scriptEl.onreadystatechange = null;
                      scriptEl.parentNode.removeChild(scriptEl);
                      scriptEl = null;
                    };
                    global2.document.documentElement.appendChild(scriptEl);
                  };
                } else {
                  scheduleDrain = function() {
                    setTimeout(nextTick, 0);
                  };
                }
              }
              var draining;
              var queue2 = [];
              function nextTick() {
                draining = true;
                var i, oldQueue;
                var len = queue2.length;
                while (len) {
                  oldQueue = queue2;
                  queue2 = [];
                  i = -1;
                  while (++i < len) {
                    oldQueue[i]();
                  }
                  len = queue2.length;
                }
                draining = false;
              }
              module3.exports = immediate;
              function immediate(task) {
                if (queue2.push(task) === 1 && !draining) {
                  scheduleDrain();
                }
              }
            }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
          }, {}], 2: [function(_dereq_, module3, exports3) {
            var immediate = _dereq_(1);
            function INTERNAL() {
            }
            var handlers = {};
            var REJECTED = ["REJECTED"];
            var FULFILLED = ["FULFILLED"];
            var PENDING2 = ["PENDING"];
            module3.exports = Promise2;
            function Promise2(resolver) {
              if (typeof resolver !== "function") {
                throw new TypeError("resolver must be a function");
              }
              this.state = PENDING2;
              this.queue = [];
              this.outcome = void 0;
              if (resolver !== INTERNAL) {
                safelyResolveThenable(this, resolver);
              }
            }
            Promise2.prototype["catch"] = function(onRejected) {
              return this.then(null, onRejected);
            };
            Promise2.prototype.then = function(onFulfilled, onRejected) {
              if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
                return this;
              }
              var promise = new this.constructor(INTERNAL);
              if (this.state !== PENDING2) {
                var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                unwrap2(promise, resolver, this.outcome);
              } else {
                this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
              }
              return promise;
            };
            function QueueItem(promise, onFulfilled, onRejected) {
              this.promise = promise;
              if (typeof onFulfilled === "function") {
                this.onFulfilled = onFulfilled;
                this.callFulfilled = this.otherCallFulfilled;
              }
              if (typeof onRejected === "function") {
                this.onRejected = onRejected;
                this.callRejected = this.otherCallRejected;
              }
            }
            QueueItem.prototype.callFulfilled = function(value) {
              handlers.resolve(this.promise, value);
            };
            QueueItem.prototype.otherCallFulfilled = function(value) {
              unwrap2(this.promise, this.onFulfilled, value);
            };
            QueueItem.prototype.callRejected = function(value) {
              handlers.reject(this.promise, value);
            };
            QueueItem.prototype.otherCallRejected = function(value) {
              unwrap2(this.promise, this.onRejected, value);
            };
            function unwrap2(promise, func, value) {
              immediate(function() {
                var returnValue;
                try {
                  returnValue = func(value);
                } catch (e2) {
                  return handlers.reject(promise, e2);
                }
                if (returnValue === promise) {
                  handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
                } else {
                  handlers.resolve(promise, returnValue);
                }
              });
            }
            handlers.resolve = function(self2, value) {
              var result = tryCatch(getThen, value);
              if (result.status === "error") {
                return handlers.reject(self2, result.value);
              }
              var thenable = result.value;
              if (thenable) {
                safelyResolveThenable(self2, thenable);
              } else {
                self2.state = FULFILLED;
                self2.outcome = value;
                var i = -1;
                var len = self2.queue.length;
                while (++i < len) {
                  self2.queue[i].callFulfilled(value);
                }
              }
              return self2;
            };
            handlers.reject = function(self2, error) {
              self2.state = REJECTED;
              self2.outcome = error;
              var i = -1;
              var len = self2.queue.length;
              while (++i < len) {
                self2.queue[i].callRejected(error);
              }
              return self2;
            };
            function getThen(obj) {
              var then = obj && obj.then;
              if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
                return function appyThen() {
                  then.apply(obj, arguments);
                };
              }
            }
            function safelyResolveThenable(self2, thenable) {
              var called2 = false;
              function onError2(value) {
                if (called2) {
                  return;
                }
                called2 = true;
                handlers.reject(self2, value);
              }
              function onSuccess(value) {
                if (called2) {
                  return;
                }
                called2 = true;
                handlers.resolve(self2, value);
              }
              function tryToUnwrap() {
                thenable(onSuccess, onError2);
              }
              var result = tryCatch(tryToUnwrap);
              if (result.status === "error") {
                onError2(result.value);
              }
            }
            function tryCatch(func, value) {
              var out = {};
              try {
                out.value = func(value);
                out.status = "success";
              } catch (e2) {
                out.status = "error";
                out.value = e2;
              }
              return out;
            }
            Promise2.resolve = resolve;
            function resolve(value) {
              if (value instanceof this) {
                return value;
              }
              return handlers.resolve(new this(INTERNAL), value);
            }
            Promise2.reject = reject;
            function reject(reason) {
              var promise = new this(INTERNAL);
              return handlers.reject(promise, reason);
            }
            Promise2.all = all;
            function all(iterable) {
              var self2 = this;
              if (Object.prototype.toString.call(iterable) !== "[object Array]") {
                return this.reject(new TypeError("must be an array"));
              }
              var len = iterable.length;
              var called2 = false;
              if (!len) {
                return this.resolve([]);
              }
              var values2 = new Array(len);
              var resolved = 0;
              var i = -1;
              var promise = new this(INTERNAL);
              while (++i < len) {
                allResolver(iterable[i], i);
              }
              return promise;
              function allResolver(value, i2) {
                self2.resolve(value).then(resolveFromAll, function(error) {
                  if (!called2) {
                    called2 = true;
                    handlers.reject(promise, error);
                  }
                });
                function resolveFromAll(outValue) {
                  values2[i2] = outValue;
                  if (++resolved === len && !called2) {
                    called2 = true;
                    handlers.resolve(promise, values2);
                  }
                }
              }
            }
            Promise2.race = race;
            function race(iterable) {
              var self2 = this;
              if (Object.prototype.toString.call(iterable) !== "[object Array]") {
                return this.reject(new TypeError("must be an array"));
              }
              var len = iterable.length;
              var called2 = false;
              if (!len) {
                return this.resolve([]);
              }
              var i = -1;
              var promise = new this(INTERNAL);
              while (++i < len) {
                resolver(iterable[i]);
              }
              return promise;
              function resolver(value) {
                self2.resolve(value).then(function(response) {
                  if (!called2) {
                    called2 = true;
                    handlers.resolve(promise, response);
                  }
                }, function(error) {
                  if (!called2) {
                    called2 = true;
                    handlers.reject(promise, error);
                  }
                });
              }
            }
          }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
            (function(global2) {
              if (typeof global2.Promise !== "function") {
                global2.Promise = _dereq_(2);
              }
            }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
          }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function getIDB() {
              try {
                if (typeof indexedDB !== "undefined") {
                  return indexedDB;
                }
                if (typeof webkitIndexedDB !== "undefined") {
                  return webkitIndexedDB;
                }
                if (typeof mozIndexedDB !== "undefined") {
                  return mozIndexedDB;
                }
                if (typeof OIndexedDB !== "undefined") {
                  return OIndexedDB;
                }
                if (typeof msIndexedDB !== "undefined") {
                  return msIndexedDB;
                }
              } catch (e2) {
                return;
              }
            }
            var idb = getIDB();
            function isIndexedDBValid() {
              try {
                if (!idb || !idb.open) {
                  return false;
                }
                var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
                var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
                return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
                // and HTC Android devices <4.4 are missing IDBKeyRange
                // See: https://github.com/mozilla/localForage/issues/128
                // See: https://github.com/mozilla/localForage/issues/272
                typeof IDBKeyRange !== "undefined";
              } catch (e2) {
                return false;
              }
            }
            function createBlob(parts, properties) {
              parts = parts || [];
              properties = properties || {};
              try {
                return new Blob(parts, properties);
              } catch (e2) {
                if (e2.name !== "TypeError") {
                  throw e2;
                }
                var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
                var builder2 = new Builder();
                for (var i = 0; i < parts.length; i += 1) {
                  builder2.append(parts[i]);
                }
                return builder2.getBlob(properties.type);
              }
            }
            if (typeof Promise === "undefined") {
              _dereq_(3);
            }
            var Promise$1 = Promise;
            function executeCallback(promise, callback2) {
              if (callback2) {
                promise.then(function(result) {
                  callback2(null, result);
                }, function(error) {
                  callback2(error);
                });
              }
            }
            function executeTwoCallbacks(promise, callback2, errorCallback) {
              if (typeof callback2 === "function") {
                promise.then(callback2);
              }
              if (typeof errorCallback === "function") {
                promise["catch"](errorCallback);
              }
            }
            function normalizeKey(key2) {
              if (typeof key2 !== "string") {
                console.warn(key2 + " used as a key, but it is not a string.");
                key2 = String(key2);
              }
              return key2;
            }
            function getCallback() {
              if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
                return arguments[arguments.length - 1];
              }
            }
            var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
            var supportsBlobs = void 0;
            var dbContexts = {};
            var toString2 = Object.prototype.toString;
            var READ_ONLY = "readonly";
            var READ_WRITE = "readwrite";
            function _binStringToArrayBuffer(bin) {
              var length2 = bin.length;
              var buf = new ArrayBuffer(length2);
              var arr = new Uint8Array(buf);
              for (var i = 0; i < length2; i++) {
                arr[i] = bin.charCodeAt(i);
              }
              return buf;
            }
            function _checkBlobSupportWithoutCaching(idb2) {
              return new Promise$1(function(resolve) {
                var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
                var blob = createBlob([""]);
                txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
                txn.onabort = function(e2) {
                  e2.preventDefault();
                  e2.stopPropagation();
                  resolve(false);
                };
                txn.oncomplete = function() {
                  var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                  var matchedEdge = navigator.userAgent.match(/Edge\//);
                  resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
                };
              })["catch"](function() {
                return false;
              });
            }
            function _checkBlobSupport(idb2) {
              if (typeof supportsBlobs === "boolean") {
                return Promise$1.resolve(supportsBlobs);
              }
              return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
                supportsBlobs = value;
                return supportsBlobs;
              });
            }
            function _deferReadiness(dbInfo) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = {};
              deferredOperation.promise = new Promise$1(function(resolve, reject) {
                deferredOperation.resolve = resolve;
                deferredOperation.reject = reject;
              });
              dbContext.deferredOperations.push(deferredOperation);
              if (!dbContext.dbReady) {
                dbContext.dbReady = deferredOperation.promise;
              } else {
                dbContext.dbReady = dbContext.dbReady.then(function() {
                  return deferredOperation.promise;
                });
              }
            }
            function _advanceReadiness(dbInfo) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = dbContext.deferredOperations.pop();
              if (deferredOperation) {
                deferredOperation.resolve();
                return deferredOperation.promise;
              }
            }
            function _rejectReadiness(dbInfo, err) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = dbContext.deferredOperations.pop();
              if (deferredOperation) {
                deferredOperation.reject(err);
                return deferredOperation.promise;
              }
            }
            function _getConnection(dbInfo, upgradeNeeded) {
              return new Promise$1(function(resolve, reject) {
                dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
                if (dbInfo.db) {
                  if (upgradeNeeded) {
                    _deferReadiness(dbInfo);
                    dbInfo.db.close();
                  } else {
                    return resolve(dbInfo.db);
                  }
                }
                var dbArgs = [dbInfo.name];
                if (upgradeNeeded) {
                  dbArgs.push(dbInfo.version);
                }
                var openreq = idb.open.apply(idb, dbArgs);
                if (upgradeNeeded) {
                  openreq.onupgradeneeded = function(e2) {
                    var db = openreq.result;
                    try {
                      db.createObjectStore(dbInfo.storeName);
                      if (e2.oldVersion <= 1) {
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                      }
                    } catch (ex) {
                      if (ex.name === "ConstraintError") {
                        console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                      } else {
                        throw ex;
                      }
                    }
                  };
                }
                openreq.onerror = function(e2) {
                  e2.preventDefault();
                  reject(openreq.error);
                };
                openreq.onsuccess = function() {
                  var db = openreq.result;
                  db.onversionchange = function(e2) {
                    e2.target.close();
                  };
                  resolve(db);
                  _advanceReadiness(dbInfo);
                };
              });
            }
            function _getOriginalConnection(dbInfo) {
              return _getConnection(dbInfo, false);
            }
            function _getUpgradedConnection(dbInfo) {
              return _getConnection(dbInfo, true);
            }
            function _isUpgradeNeeded(dbInfo, defaultVersion) {
              if (!dbInfo.db) {
                return true;
              }
              var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
              var isDowngrade = dbInfo.version < dbInfo.db.version;
              var isUpgrade = dbInfo.version > dbInfo.db.version;
              if (isDowngrade) {
                if (dbInfo.version !== defaultVersion) {
                  console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
                }
                dbInfo.version = dbInfo.db.version;
              }
              if (isUpgrade || isNewStore) {
                if (isNewStore) {
                  var incVersion = dbInfo.db.version + 1;
                  if (incVersion > dbInfo.version) {
                    dbInfo.version = incVersion;
                  }
                }
                return true;
              }
              return false;
            }
            function _encodeBlob(blob) {
              return new Promise$1(function(resolve, reject) {
                var reader2 = new FileReader();
                reader2.onerror = reject;
                reader2.onloadend = function(e2) {
                  var base64 = btoa(e2.target.result || "");
                  resolve({
                    __local_forage_encoded_blob: true,
                    data: base64,
                    type: blob.type
                  });
                };
                reader2.readAsBinaryString(blob);
              });
            }
            function _decodeBlob(encodedBlob) {
              var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
              return createBlob([arrayBuff], { type: encodedBlob.type });
            }
            function _isEncodedBlob(value) {
              return value && value.__local_forage_encoded_blob;
            }
            function _fullyReady(callback2) {
              var self2 = this;
              var promise = self2._initReady().then(function() {
                var dbContext = dbContexts[self2._dbInfo.name];
                if (dbContext && dbContext.dbReady) {
                  return dbContext.dbReady;
                }
              });
              executeTwoCallbacks(promise, callback2, callback2);
              return promise;
            }
            function _tryReconnect(dbInfo) {
              _deferReadiness(dbInfo);
              var dbContext = dbContexts[dbInfo.name];
              var forages = dbContext.forages;
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                if (forage._dbInfo.db) {
                  forage._dbInfo.db.close();
                  forage._dbInfo.db = null;
                }
              }
              dbInfo.db = null;
              return _getOriginalConnection(dbInfo).then(function(db) {
                dbInfo.db = db;
                if (_isUpgradeNeeded(dbInfo)) {
                  return _getUpgradedConnection(dbInfo);
                }
                return db;
              }).then(function(db) {
                dbInfo.db = dbContext.db = db;
                for (var i2 = 0; i2 < forages.length; i2++) {
                  forages[i2]._dbInfo.db = db;
                }
              })["catch"](function(err) {
                _rejectReadiness(dbInfo, err);
                throw err;
              });
            }
            function createTransaction(dbInfo, mode, callback2, retries) {
              if (retries === void 0) {
                retries = 1;
              }
              try {
                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                callback2(null, tx);
              } catch (err) {
                if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
                  return Promise$1.resolve().then(function() {
                    if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                      if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                      }
                      return _getUpgradedConnection(dbInfo);
                    }
                  }).then(function() {
                    return _tryReconnect(dbInfo).then(function() {
                      createTransaction(dbInfo, mode, callback2, retries - 1);
                    });
                  })["catch"](callback2);
                }
                callback2(err);
              }
            }
            function createDbContext() {
              return {
                // Running localForages sharing a database.
                forages: [],
                // Shared database.
                db: null,
                // Database readiness (promise).
                dbReady: null,
                // Deferred operations on the database.
                deferredOperations: []
              };
            }
            function _initStorage(options2) {
              var self2 = this;
              var dbInfo = {
                db: null
              };
              if (options2) {
                for (var i in options2) {
                  dbInfo[i] = options2[i];
                }
              }
              var dbContext = dbContexts[dbInfo.name];
              if (!dbContext) {
                dbContext = createDbContext();
                dbContexts[dbInfo.name] = dbContext;
              }
              dbContext.forages.push(self2);
              if (!self2._initReady) {
                self2._initReady = self2.ready;
                self2.ready = _fullyReady;
              }
              var initPromises = [];
              function ignoreErrors() {
                return Promise$1.resolve();
              }
              for (var j = 0; j < dbContext.forages.length; j++) {
                var forage = dbContext.forages[j];
                if (forage !== self2) {
                  initPromises.push(forage._initReady()["catch"](ignoreErrors));
                }
              }
              var forages = dbContext.forages.slice(0);
              return Promise$1.all(initPromises).then(function() {
                dbInfo.db = dbContext.db;
                return _getOriginalConnection(dbInfo);
              }).then(function(db) {
                dbInfo.db = db;
                if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
                  return _getUpgradedConnection(dbInfo);
                }
                return db;
              }).then(function(db) {
                dbInfo.db = dbContext.db = db;
                self2._dbInfo = dbInfo;
                for (var k = 0; k < forages.length; k++) {
                  var forage2 = forages[k];
                  if (forage2 !== self2) {
                    forage2._dbInfo.db = dbInfo.db;
                    forage2._dbInfo.version = dbInfo.version;
                  }
                }
              });
            }
            function getItem(key2, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store2.get(key2);
                      req.onsuccess = function() {
                        var value = req.result;
                        if (value === void 0) {
                          value = null;
                        }
                        if (_isEncodedBlob(value)) {
                          value = _decodeBlob(value);
                        }
                        resolve(value);
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function iterate2(iterator, callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store2.openCursor();
                      var iterationNumber = 1;
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (cursor) {
                          var value = cursor.value;
                          if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                          }
                          var result = iterator(value, cursor.key, iterationNumber++);
                          if (result !== void 0) {
                            resolve(result);
                          } else {
                            cursor["continue"]();
                          }
                        } else {
                          resolve();
                        }
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function setItem(key2, value, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                var dbInfo;
                self2.ready().then(function() {
                  dbInfo = self2._dbInfo;
                  if (toString2.call(value) === "[object Blob]") {
                    return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                      if (blobSupport) {
                        return value;
                      }
                      return _encodeBlob(value);
                    });
                  }
                  return value;
                }).then(function(value2) {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      if (value2 === null) {
                        value2 = void 0;
                      }
                      var req = store2.put(value2, key2);
                      transaction.oncomplete = function() {
                        if (value2 === void 0) {
                          value2 = null;
                        }
                        resolve(value2);
                      };
                      transaction.onabort = transaction.onerror = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function removeItem(key2, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store2["delete"](key2);
                      transaction.oncomplete = function() {
                        resolve();
                      };
                      transaction.onerror = function() {
                        reject(req.error);
                      };
                      transaction.onabort = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function clear(callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store2.clear();
                      transaction.oncomplete = function() {
                        resolve();
                      };
                      transaction.onabort = transaction.onerror = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function length(callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store2.count();
                      req.onsuccess = function() {
                        resolve(req.result);
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function key(n2, callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                if (n2 < 0) {
                  resolve(null);
                  return;
                }
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      var advanced = false;
                      var req = store2.openKeyCursor();
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (!cursor) {
                          resolve(null);
                          return;
                        }
                        if (n2 === 0) {
                          resolve(cursor.key);
                        } else {
                          if (!advanced) {
                            advanced = true;
                            cursor.advance(n2);
                          } else {
                            resolve(cursor.key);
                          }
                        }
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function keys2(callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store2 = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store2.openKeyCursor();
                      var keys3 = [];
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (!cursor) {
                          resolve(keys3);
                          return;
                        }
                        keys3.push(cursor.key);
                        cursor["continue"]();
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e2) {
                      reject(e2);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function dropInstance(options2, callback2) {
              callback2 = getCallback.apply(this, arguments);
              var currentConfig = this.config();
              options2 = typeof options2 !== "function" && options2 || {};
              if (!options2.name) {
                options2.name = options2.name || currentConfig.name;
                options2.storeName = options2.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options2.name) {
                promise = Promise$1.reject("Invalid arguments");
              } else {
                var isCurrentDb = options2.name === currentConfig.name && self2._dbInfo.db;
                var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options2).then(function(db) {
                  var dbContext = dbContexts[options2.name];
                  var forages = dbContext.forages;
                  dbContext.db = db;
                  for (var i = 0; i < forages.length; i++) {
                    forages[i]._dbInfo.db = db;
                  }
                  return db;
                });
                if (!options2.storeName) {
                  promise = dbPromise.then(function(db) {
                    _deferReadiness(options2);
                    var dbContext = dbContexts[options2.name];
                    var forages = dbContext.forages;
                    db.close();
                    for (var i = 0; i < forages.length; i++) {
                      var forage = forages[i];
                      forage._dbInfo.db = null;
                    }
                    var dropDBPromise = new Promise$1(function(resolve, reject) {
                      var req = idb.deleteDatabase(options2.name);
                      req.onerror = function() {
                        var db2 = req.result;
                        if (db2) {
                          db2.close();
                        }
                        reject(req.error);
                      };
                      req.onblocked = function() {
                        console.warn('dropInstance blocked for database "' + options2.name + '" until all open connections are closed');
                      };
                      req.onsuccess = function() {
                        var db2 = req.result;
                        if (db2) {
                          db2.close();
                        }
                        resolve(db2);
                      };
                    });
                    return dropDBPromise.then(function(db2) {
                      dbContext.db = db2;
                      for (var i2 = 0; i2 < forages.length; i2++) {
                        var _forage = forages[i2];
                        _advanceReadiness(_forage._dbInfo);
                      }
                    })["catch"](function(err) {
                      (_rejectReadiness(options2, err) || Promise$1.resolve())["catch"](function() {
                      });
                      throw err;
                    });
                  });
                } else {
                  promise = dbPromise.then(function(db) {
                    if (!db.objectStoreNames.contains(options2.storeName)) {
                      return;
                    }
                    var newVersion = db.version + 1;
                    _deferReadiness(options2);
                    var dbContext = dbContexts[options2.name];
                    var forages = dbContext.forages;
                    db.close();
                    for (var i = 0; i < forages.length; i++) {
                      var forage = forages[i];
                      forage._dbInfo.db = null;
                      forage._dbInfo.version = newVersion;
                    }
                    var dropObjectPromise = new Promise$1(function(resolve, reject) {
                      var req = idb.open(options2.name, newVersion);
                      req.onerror = function(err) {
                        var db2 = req.result;
                        db2.close();
                        reject(err);
                      };
                      req.onupgradeneeded = function() {
                        var db2 = req.result;
                        db2.deleteObjectStore(options2.storeName);
                      };
                      req.onsuccess = function() {
                        var db2 = req.result;
                        db2.close();
                        resolve(db2);
                      };
                    });
                    return dropObjectPromise.then(function(db2) {
                      dbContext.db = db2;
                      for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db2;
                        _advanceReadiness(_forage2._dbInfo);
                      }
                    })["catch"](function(err) {
                      (_rejectReadiness(options2, err) || Promise$1.resolve())["catch"](function() {
                      });
                      throw err;
                    });
                  });
                }
              }
              executeCallback(promise, callback2);
              return promise;
            }
            var asyncStorage = {
              _driver: "asyncStorage",
              _initStorage,
              _support: isIndexedDBValid(),
              iterate: iterate2,
              getItem,
              setItem,
              removeItem,
              clear,
              length,
              key,
              keys: keys2,
              dropInstance
            };
            function isWebSQLValid() {
              return typeof openDatabase === "function";
            }
            var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var BLOB_TYPE_PREFIX = "~~local_forage_type~";
            var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
            var SERIALIZED_MARKER = "__lfsc__:";
            var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
            var TYPE_ARRAYBUFFER = "arbf";
            var TYPE_BLOB = "blob";
            var TYPE_INT8ARRAY = "si08";
            var TYPE_UINT8ARRAY = "ui08";
            var TYPE_UINT8CLAMPEDARRAY = "uic8";
            var TYPE_INT16ARRAY = "si16";
            var TYPE_INT32ARRAY = "si32";
            var TYPE_UINT16ARRAY = "ur16";
            var TYPE_UINT32ARRAY = "ui32";
            var TYPE_FLOAT32ARRAY = "fl32";
            var TYPE_FLOAT64ARRAY = "fl64";
            var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
            var toString$12 = Object.prototype.toString;
            function stringToBuffer(serializedString) {
              var bufferLength = serializedString.length * 0.75;
              var len = serializedString.length;
              var i;
              var p = 0;
              var encoded1, encoded2, encoded3, encoded4;
              if (serializedString[serializedString.length - 1] === "=") {
                bufferLength--;
                if (serializedString[serializedString.length - 2] === "=") {
                  bufferLength--;
                }
              }
              var buffer = new ArrayBuffer(bufferLength);
              var bytes = new Uint8Array(buffer);
              for (i = 0; i < len; i += 4) {
                encoded1 = BASE_CHARS.indexOf(serializedString[i]);
                encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
                encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
                encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
                bytes[p++] = encoded1 << 2 | encoded2 >> 4;
                bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
              }
              return buffer;
            }
            function bufferToString(buffer) {
              var bytes = new Uint8Array(buffer);
              var base64String = "";
              var i;
              for (i = 0; i < bytes.length; i += 3) {
                base64String += BASE_CHARS[bytes[i] >> 2];
                base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                base64String += BASE_CHARS[bytes[i + 2] & 63];
              }
              if (bytes.length % 3 === 2) {
                base64String = base64String.substring(0, base64String.length - 1) + "=";
              } else if (bytes.length % 3 === 1) {
                base64String = base64String.substring(0, base64String.length - 2) + "==";
              }
              return base64String;
            }
            function serialize2(value, callback2) {
              var valueType = "";
              if (value) {
                valueType = toString$12.call(value);
              }
              if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$12.call(value.buffer) === "[object ArrayBuffer]")) {
                var buffer;
                var marker = SERIALIZED_MARKER;
                if (value instanceof ArrayBuffer) {
                  buffer = value;
                  marker += TYPE_ARRAYBUFFER;
                } else {
                  buffer = value.buffer;
                  if (valueType === "[object Int8Array]") {
                    marker += TYPE_INT8ARRAY;
                  } else if (valueType === "[object Uint8Array]") {
                    marker += TYPE_UINT8ARRAY;
                  } else if (valueType === "[object Uint8ClampedArray]") {
                    marker += TYPE_UINT8CLAMPEDARRAY;
                  } else if (valueType === "[object Int16Array]") {
                    marker += TYPE_INT16ARRAY;
                  } else if (valueType === "[object Uint16Array]") {
                    marker += TYPE_UINT16ARRAY;
                  } else if (valueType === "[object Int32Array]") {
                    marker += TYPE_INT32ARRAY;
                  } else if (valueType === "[object Uint32Array]") {
                    marker += TYPE_UINT32ARRAY;
                  } else if (valueType === "[object Float32Array]") {
                    marker += TYPE_FLOAT32ARRAY;
                  } else if (valueType === "[object Float64Array]") {
                    marker += TYPE_FLOAT64ARRAY;
                  } else {
                    callback2(new Error("Failed to get type for BinaryArray"));
                  }
                }
                callback2(marker + bufferToString(buffer));
              } else if (valueType === "[object Blob]") {
                var fileReader = new FileReader();
                fileReader.onload = function() {
                  var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
                  callback2(SERIALIZED_MARKER + TYPE_BLOB + str);
                };
                fileReader.readAsArrayBuffer(value);
              } else {
                try {
                  callback2(JSON.stringify(value));
                } catch (e2) {
                  console.error("Couldn't convert value into a JSON string: ", value);
                  callback2(null, e2);
                }
              }
            }
            function deserialize(value) {
              if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
                return JSON.parse(value);
              }
              var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
              var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
              var blobType;
              if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
                var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
                blobType = matcher[1];
                serializedString = serializedString.substring(matcher[0].length);
              }
              var buffer = stringToBuffer(serializedString);
              switch (type) {
                case TYPE_ARRAYBUFFER:
                  return buffer;
                case TYPE_BLOB:
                  return createBlob([buffer], { type: blobType });
                case TYPE_INT8ARRAY:
                  return new Int8Array(buffer);
                case TYPE_UINT8ARRAY:
                  return new Uint8Array(buffer);
                case TYPE_UINT8CLAMPEDARRAY:
                  return new Uint8ClampedArray(buffer);
                case TYPE_INT16ARRAY:
                  return new Int16Array(buffer);
                case TYPE_UINT16ARRAY:
                  return new Uint16Array(buffer);
                case TYPE_INT32ARRAY:
                  return new Int32Array(buffer);
                case TYPE_UINT32ARRAY:
                  return new Uint32Array(buffer);
                case TYPE_FLOAT32ARRAY:
                  return new Float32Array(buffer);
                case TYPE_FLOAT64ARRAY:
                  return new Float64Array(buffer);
                default:
                  throw new Error("Unkown type: " + type);
              }
            }
            var localforageSerializer = {
              serialize: serialize2,
              deserialize,
              stringToBuffer,
              bufferToString
            };
            function createDbTable(t2, dbInfo, callback2, errorCallback) {
              t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback2, errorCallback);
            }
            function _initStorage$1(options2) {
              var self2 = this;
              var dbInfo = {
                db: null
              };
              if (options2) {
                for (var i in options2) {
                  dbInfo[i] = typeof options2[i] !== "string" ? options2[i].toString() : options2[i];
                }
              }
              var dbInfoPromise = new Promise$1(function(resolve, reject) {
                try {
                  dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
                } catch (e2) {
                  return reject(e2);
                }
                dbInfo.db.transaction(function(t2) {
                  createDbTable(t2, dbInfo, function() {
                    self2._dbInfo = dbInfo;
                    resolve();
                  }, function(t3, error) {
                    reject(error);
                  });
                }, reject);
              });
              dbInfo.serializer = localforageSerializer;
              return dbInfoPromise;
            }
            function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback2, errorCallback) {
              t2.executeSql(sqlStatement, args, callback2, function(t3, error) {
                if (error.code === error.SYNTAX_ERR) {
                  t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
                    if (!results.rows.length) {
                      createDbTable(t4, dbInfo, function() {
                        t4.executeSql(sqlStatement, args, callback2, errorCallback);
                      }, errorCallback);
                    } else {
                      errorCallback(t4, error);
                    }
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            }
            function getItem$1(key2, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                      var result = results.rows.length ? results.rows.item(0).value : null;
                      if (result) {
                        result = dbInfo.serializer.deserialize(result);
                      }
                      resolve(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function iterate$12(iterator, callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                      var rows = results.rows;
                      var length2 = rows.length;
                      for (var i = 0; i < length2; i++) {
                        var item2 = rows.item(i);
                        var result = item2.value;
                        if (result) {
                          result = dbInfo.serializer.deserialize(result);
                        }
                        result = iterator(result, item2.key, i + 1);
                        if (result !== void 0) {
                          resolve(result);
                          return;
                        }
                      }
                      resolve();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function _setItem(key2, value, callback2, retriesLeft) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  if (value === void 0) {
                    value = null;
                  }
                  var originalValue = value;
                  var dbInfo = self2._dbInfo;
                  dbInfo.serializer.serialize(value, function(value2, error) {
                    if (error) {
                      reject(error);
                    } else {
                      dbInfo.db.transaction(function(t2) {
                        tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                          resolve(originalValue);
                        }, function(t3, error2) {
                          reject(error2);
                        });
                      }, function(sqlError) {
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                          if (retriesLeft > 0) {
                            resolve(_setItem.apply(self2, [key2, originalValue, callback2, retriesLeft - 1]));
                            return;
                          }
                          reject(sqlError);
                        }
                      });
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function setItem$1(key2, value, callback2) {
              return _setItem.apply(this, [key2, value, callback2, 1]);
            }
            function removeItem$1(key2, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                      resolve();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function clear$1(callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                      resolve();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function length$1(callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                      var result = results.rows.item(0).c;
                      resolve(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function key$1(n2, callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n2 + 1], function(t3, results) {
                      var result = results.rows.length ? results.rows.item(0).key : null;
                      resolve(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function keys$12(callback2) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                      var keys3 = [];
                      for (var i = 0; i < results.rows.length; i++) {
                        keys3.push(results.rows.item(i).key);
                      }
                      resolve(keys3);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function getAllStoreNames(db) {
              return new Promise$1(function(resolve, reject) {
                db.transaction(function(t2) {
                  t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
                    var storeNames = [];
                    for (var i = 0; i < results.rows.length; i++) {
                      storeNames.push(results.rows.item(i).name);
                    }
                    resolve({
                      db,
                      storeNames
                    });
                  }, function(t3, error) {
                    reject(error);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            }
            function dropInstance$1(options2, callback2) {
              callback2 = getCallback.apply(this, arguments);
              var currentConfig = this.config();
              options2 = typeof options2 !== "function" && options2 || {};
              if (!options2.name) {
                options2.name = options2.name || currentConfig.name;
                options2.storeName = options2.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options2.name) {
                promise = Promise$1.reject("Invalid arguments");
              } else {
                promise = new Promise$1(function(resolve) {
                  var db;
                  if (options2.name === currentConfig.name) {
                    db = self2._dbInfo.db;
                  } else {
                    db = openDatabase(options2.name, "", "", 0);
                  }
                  if (!options2.storeName) {
                    resolve(getAllStoreNames(db));
                  } else {
                    resolve({
                      db,
                      storeNames: [options2.storeName]
                    });
                  }
                }).then(function(operationInfo) {
                  return new Promise$1(function(resolve, reject) {
                    operationInfo.db.transaction(function(t2) {
                      function dropTable(storeName) {
                        return new Promise$1(function(resolve2, reject2) {
                          t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                            resolve2();
                          }, function(t3, error) {
                            reject2(error);
                          });
                        });
                      }
                      var operations = [];
                      for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                      }
                      Promise$1.all(operations).then(function() {
                        resolve();
                      })["catch"](function(e2) {
                        reject(e2);
                      });
                    }, function(sqlError) {
                      reject(sqlError);
                    });
                  });
                });
              }
              executeCallback(promise, callback2);
              return promise;
            }
            var webSQLStorage = {
              _driver: "webSQLStorage",
              _initStorage: _initStorage$1,
              _support: isWebSQLValid(),
              iterate: iterate$12,
              getItem: getItem$1,
              setItem: setItem$1,
              removeItem: removeItem$1,
              clear: clear$1,
              length: length$1,
              key: key$1,
              keys: keys$12,
              dropInstance: dropInstance$1
            };
            function isLocalStorageValid() {
              try {
                return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
                !!localStorage.setItem;
              } catch (e2) {
                return false;
              }
            }
            function _getKeyPrefix(options2, defaultConfig) {
              var keyPrefix = options2.name + "/";
              if (options2.storeName !== defaultConfig.storeName) {
                keyPrefix += options2.storeName + "/";
              }
              return keyPrefix;
            }
            function checkIfLocalStorageThrows() {
              var localStorageTestKey = "_localforage_support_test";
              try {
                localStorage.setItem(localStorageTestKey, true);
                localStorage.removeItem(localStorageTestKey);
                return false;
              } catch (e2) {
                return true;
              }
            }
            function _isLocalStorageUsable() {
              return !checkIfLocalStorageThrows() || localStorage.length > 0;
            }
            function _initStorage$2(options2) {
              var self2 = this;
              var dbInfo = {};
              if (options2) {
                for (var i in options2) {
                  dbInfo[i] = options2[i];
                }
              }
              dbInfo.keyPrefix = _getKeyPrefix(options2, self2._defaultConfig);
              if (!_isLocalStorageUsable()) {
                return Promise$1.reject();
              }
              self2._dbInfo = dbInfo;
              dbInfo.serializer = localforageSerializer;
              return Promise$1.resolve();
            }
            function clear$2(callback2) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var keyPrefix = self2._dbInfo.keyPrefix;
                for (var i = localStorage.length - 1; i >= 0; i--) {
                  var key2 = localStorage.key(i);
                  if (key2.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key2);
                  }
                }
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function getItem$2(key2, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var result = localStorage.getItem(dbInfo.keyPrefix + key2);
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                return result;
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function iterate$22(iterator, callback2) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var keyPrefix = dbInfo.keyPrefix;
                var keyPrefixLength = keyPrefix.length;
                var length2 = localStorage.length;
                var iterationNumber = 1;
                for (var i = 0; i < length2; i++) {
                  var key2 = localStorage.key(i);
                  if (key2.indexOf(keyPrefix) !== 0) {
                    continue;
                  }
                  var value = localStorage.getItem(key2);
                  if (value) {
                    value = dbInfo.serializer.deserialize(value);
                  }
                  value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
                  if (value !== void 0) {
                    return value;
                  }
                }
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function key$2(n2, callback2) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var result;
                try {
                  result = localStorage.key(n2);
                } catch (error) {
                  result = null;
                }
                if (result) {
                  result = result.substring(dbInfo.keyPrefix.length);
                }
                return result;
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function keys$2(callback2) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var length2 = localStorage.length;
                var keys3 = [];
                for (var i = 0; i < length2; i++) {
                  var itemKey = localStorage.key(i);
                  if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                    keys3.push(itemKey.substring(dbInfo.keyPrefix.length));
                  }
                }
                return keys3;
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function length$2(callback2) {
              var self2 = this;
              var promise = self2.keys().then(function(keys3) {
                return keys3.length;
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function removeItem$2(key2, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                localStorage.removeItem(dbInfo.keyPrefix + key2);
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function setItem$2(key2, value, callback2) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = self2.ready().then(function() {
                if (value === void 0) {
                  value = null;
                }
                var originalValue = value;
                return new Promise$1(function(resolve, reject) {
                  var dbInfo = self2._dbInfo;
                  dbInfo.serializer.serialize(value, function(value2, error) {
                    if (error) {
                      reject(error);
                    } else {
                      try {
                        localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                        resolve(originalValue);
                      } catch (e2) {
                        if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                          reject(e2);
                        }
                        reject(e2);
                      }
                    }
                  });
                });
              });
              executeCallback(promise, callback2);
              return promise;
            }
            function dropInstance$2(options2, callback2) {
              callback2 = getCallback.apply(this, arguments);
              options2 = typeof options2 !== "function" && options2 || {};
              if (!options2.name) {
                var currentConfig = this.config();
                options2.name = options2.name || currentConfig.name;
                options2.storeName = options2.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options2.name) {
                promise = Promise$1.reject("Invalid arguments");
              } else {
                promise = new Promise$1(function(resolve) {
                  if (!options2.storeName) {
                    resolve(options2.name + "/");
                  } else {
                    resolve(_getKeyPrefix(options2, self2._defaultConfig));
                  }
                }).then(function(keyPrefix) {
                  for (var i = localStorage.length - 1; i >= 0; i--) {
                    var key2 = localStorage.key(i);
                    if (key2.indexOf(keyPrefix) === 0) {
                      localStorage.removeItem(key2);
                    }
                  }
                });
              }
              executeCallback(promise, callback2);
              return promise;
            }
            var localStorageWrapper = {
              _driver: "localStorageWrapper",
              _initStorage: _initStorage$2,
              _support: isLocalStorageValid(),
              iterate: iterate$22,
              getItem: getItem$2,
              setItem: setItem$2,
              removeItem: removeItem$2,
              clear: clear$2,
              length: length$2,
              key: key$2,
              keys: keys$2,
              dropInstance: dropInstance$2
            };
            var sameValue = function sameValue2(x, y) {
              return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
            };
            var includes = function includes2(array, searchElement) {
              var len = array.length;
              var i = 0;
              while (i < len) {
                if (sameValue(array[i], searchElement)) {
                  return true;
                }
                i++;
              }
              return false;
            };
            var isArray2 = Array.isArray || function(arg) {
              return Object.prototype.toString.call(arg) === "[object Array]";
            };
            var DefinedDrivers = {};
            var DriverSupport = {};
            var DefaultDrivers = {
              INDEXEDDB: asyncStorage,
              WEBSQL: webSQLStorage,
              LOCALSTORAGE: localStorageWrapper
            };
            var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
            var OptionalDriverMethods = ["dropInstance"];
            var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
            var DefaultConfig = {
              description: "",
              driver: DefaultDriverOrder.slice(),
              name: "localforage",
              // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
              // we can use without a prompt.
              size: 4980736,
              storeName: "keyvaluepairs",
              version: 1
            };
            function callWhenReady(localForageInstance, libraryMethod) {
              localForageInstance[libraryMethod] = function() {
                var _args = arguments;
                return localForageInstance.ready().then(function() {
                  return localForageInstance[libraryMethod].apply(localForageInstance, _args);
                });
              };
            }
            function extend2() {
              for (var i = 1; i < arguments.length; i++) {
                var arg = arguments[i];
                if (arg) {
                  for (var _key in arg) {
                    if (arg.hasOwnProperty(_key)) {
                      if (isArray2(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                      } else {
                        arguments[0][_key] = arg[_key];
                      }
                    }
                  }
                }
              }
              return arguments[0];
            }
            var LocalForage = function() {
              function LocalForage2(options2) {
                _classCallCheck(this, LocalForage2);
                for (var driverTypeKey in DefaultDrivers) {
                  if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                    var driver = DefaultDrivers[driverTypeKey];
                    var driverName = driver._driver;
                    this[driverTypeKey] = driverName;
                    if (!DefinedDrivers[driverName]) {
                      this.defineDriver(driver);
                    }
                  }
                }
                this._defaultConfig = extend2({}, DefaultConfig);
                this._config = extend2({}, this._defaultConfig, options2);
                this._driverSet = null;
                this._initDriver = null;
                this._ready = false;
                this._dbInfo = null;
                this._wrapLibraryMethodsWithReady();
                this.setDriver(this._config.driver)["catch"](function() {
                });
              }
              LocalForage2.prototype.config = function config(options2) {
                if ((typeof options2 === "undefined" ? "undefined" : _typeof(options2)) === "object") {
                  if (this._ready) {
                    return new Error("Can't call config() after localforage has been used.");
                  }
                  for (var i in options2) {
                    if (i === "storeName") {
                      options2[i] = options2[i].replace(/\W/g, "_");
                    }
                    if (i === "version" && typeof options2[i] !== "number") {
                      return new Error("Database version must be a number.");
                    }
                    this._config[i] = options2[i];
                  }
                  if ("driver" in options2 && options2.driver) {
                    return this.setDriver(this._config.driver);
                  }
                  return true;
                } else if (typeof options2 === "string") {
                  return this._config[options2];
                } else {
                  return this._config;
                }
              };
              LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback2, errorCallback) {
                var promise = new Promise$1(function(resolve, reject) {
                  try {
                    var driverName = driverObject._driver;
                    var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                    if (!driverObject._driver) {
                      reject(complianceError);
                      return;
                    }
                    var driverMethods = LibraryMethods.concat("_initStorage");
                    for (var i = 0, len = driverMethods.length; i < len; i++) {
                      var driverMethodName = driverMethods[i];
                      var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                      if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                        reject(complianceError);
                        return;
                      }
                    }
                    var configureMissingMethods = function configureMissingMethods2() {
                      var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                        return function() {
                          var error = new Error("Method " + methodName + " is not implemented by the current driver");
                          var promise2 = Promise$1.reject(error);
                          executeCallback(promise2, arguments[arguments.length - 1]);
                          return promise2;
                        };
                      };
                      for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                          driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                      }
                    };
                    configureMissingMethods();
                    var setDriverSupport = function setDriverSupport2(support) {
                      if (DefinedDrivers[driverName]) {
                        console.info("Redefining LocalForage driver: " + driverName);
                      }
                      DefinedDrivers[driverName] = driverObject;
                      DriverSupport[driverName] = support;
                      resolve();
                    };
                    if ("_support" in driverObject) {
                      if (driverObject._support && typeof driverObject._support === "function") {
                        driverObject._support().then(setDriverSupport, reject);
                      } else {
                        setDriverSupport(!!driverObject._support);
                      }
                    } else {
                      setDriverSupport(true);
                    }
                  } catch (e2) {
                    reject(e2);
                  }
                });
                executeTwoCallbacks(promise, callback2, errorCallback);
                return promise;
              };
              LocalForage2.prototype.driver = function driver() {
                return this._driver || null;
              };
              LocalForage2.prototype.getDriver = function getDriver(driverName, callback2, errorCallback) {
                var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
                executeTwoCallbacks(getDriverPromise, callback2, errorCallback);
                return getDriverPromise;
              };
              LocalForage2.prototype.getSerializer = function getSerializer(callback2) {
                var serializerPromise = Promise$1.resolve(localforageSerializer);
                executeTwoCallbacks(serializerPromise, callback2);
                return serializerPromise;
              };
              LocalForage2.prototype.ready = function ready(callback2) {
                var self2 = this;
                var promise = self2._driverSet.then(function() {
                  if (self2._ready === null) {
                    self2._ready = self2._initDriver();
                  }
                  return self2._ready;
                });
                executeTwoCallbacks(promise, callback2, callback2);
                return promise;
              };
              LocalForage2.prototype.setDriver = function setDriver(drivers, callback2, errorCallback) {
                var self2 = this;
                if (!isArray2(drivers)) {
                  drivers = [drivers];
                }
                var supportedDrivers = this._getSupportedDrivers(drivers);
                function setDriverToConfig() {
                  self2._config.driver = self2.driver();
                }
                function extendSelfWithDriver(driver) {
                  self2._extend(driver);
                  setDriverToConfig();
                  self2._ready = self2._initStorage(self2._config);
                  return self2._ready;
                }
                function initDriver(supportedDrivers2) {
                  return function() {
                    var currentDriverIndex = 0;
                    function driverPromiseLoop() {
                      while (currentDriverIndex < supportedDrivers2.length) {
                        var driverName = supportedDrivers2[currentDriverIndex];
                        currentDriverIndex++;
                        self2._dbInfo = null;
                        self2._ready = null;
                        return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                      }
                      setDriverToConfig();
                      var error = new Error("No available storage method found.");
                      self2._driverSet = Promise$1.reject(error);
                      return self2._driverSet;
                    }
                    return driverPromiseLoop();
                  };
                }
                var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
                  return Promise$1.resolve();
                }) : Promise$1.resolve();
                this._driverSet = oldDriverSetDone.then(function() {
                  var driverName = supportedDrivers[0];
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(function(driver) {
                    self2._driver = driver._driver;
                    setDriverToConfig();
                    self2._wrapLibraryMethodsWithReady();
                    self2._initDriver = initDriver(supportedDrivers);
                  });
                })["catch"](function() {
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                });
                executeTwoCallbacks(this._driverSet, callback2, errorCallback);
                return this._driverSet;
              };
              LocalForage2.prototype.supports = function supports(driverName) {
                return !!DriverSupport[driverName];
              };
              LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
                extend2(this, libraryMethodsAndProperties);
              };
              LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
                var supportedDrivers = [];
                for (var i = 0, len = drivers.length; i < len; i++) {
                  var driverName = drivers[i];
                  if (this.supports(driverName)) {
                    supportedDrivers.push(driverName);
                  }
                }
                return supportedDrivers;
              };
              LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
                for (var i = 0, len = LibraryMethods.length; i < len; i++) {
                  callWhenReady(this, LibraryMethods[i]);
                }
              };
              LocalForage2.prototype.createInstance = function createInstance(options2) {
                return new LocalForage2(options2);
              };
              return LocalForage2;
            }();
            var localforage_js = new LocalForage();
            module3.exports = localforage_js;
          }, { "3": 3 }] }, {}, [4])(4);
        });
      })(localforage$1);
      var localforageExports = localforage$1.exports;
      const localforage = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports);
      function createDownloaderLocalForage(hash) {
        const filename = "file:" + hash;
        const temp_filename = "_" + filename;
        let init = false;
        let finalized = false;
        let blobFinalizeEarly;
        return {
          get finalized() {
            return finalized;
          },
          append(a) {
            return __async(this, null, function* () {
              if (finalized)
                return;
              if (!init) {
                yield localforage.removeItem(temp_filename);
                init = true;
                const fileCached = yield localforage.getItem(filename);
                if (fileCached) {
                  finalized = true;
                  return blobFinalizeEarly = fileCached;
                }
              }
              const blob = yield localforage.getItem(temp_filename);
              yield localforage.removeItem(temp_filename);
              if (blob) {
                yield localforage.setItem(temp_filename, new Blob([blob, a]));
                return;
              }
              yield localforage.setItem(temp_filename, new Blob([a]));
            });
          },
          finalize() {
            return __async(this, null, function* () {
              if (blobFinalizeEarly)
                return blobFinalizeEarly;
              if (finalized)
                throw new Error("Can only finalize once.");
              const blob = yield localforage.getItem(temp_filename);
              yield localforage.removeItem(temp_filename);
              yield localforage.setItem(filename, blob);
              finalized = true;
              return blob;
            });
          },
          cancel() {
            return __async(this, null, function* () {
              if (finalized)
                return;
              yield localforage.removeItem(temp_filename);
            });
          }
        };
      }
      function getFileFromCacheLocalforage(hash) {
        const filename = "file:" + hash;
        return localforage.getItem(filename);
      }
      function addToCacheLocalforage(hash, ...buffer) {
        return __async(this, null, function* () {
          const filename = "file:" + hash;
          yield localforage.setItem(filename, new Blob(buffer));
          return localforage.getItem(filename);
        });
      }
      function addToCache(hash, ...buffer) {
        return __async(this, null, function* () {
          return addToCacheLocalforage(hash, ...buffer);
        });
      }
      function getFileFromCache(hash) {
        return __async(this, null, function* () {
          return getFileFromCacheLocalforage(hash);
        });
      }
      function createDownloader(hash) {
        return __async(this, null, function* () {
          return createDownloaderLocalForage(hash);
        });
      }
      function hashFile(fileLocation) {
        const location2 = fileLocation.location;
        if ("uniqueFileId" in fileLocation) {
          return simpleHash(String(fileLocation.uniqueFileId));
        }
        if ("geoPoint" in location2) {
          let str = "";
          str += location2.w;
          str += location2.h;
          str += location2.scale;
          str += location2.zoom;
          if ("lat" in location2.geoPoint) {
            str += location2.geoPoint.lat;
            str += location2.geoPoint.long;
          }
          return simpleHash(str);
        }
        if ("photoId" in location2) {
          const long = location2.photoId;
          return simpleHash(long.toString(36));
        }
        if ("id" in location2) {
          const long = location2.id;
          return simpleHash(location2._ + long.toString(36));
        }
        return null;
      }
      const EE = new EventEmitter();
      function tick() {
        setTimeout(() => {
          EE.emit("tick");
        }, 0);
      }
      const cacheMap = /* @__PURE__ */ new Map();
      const pending = /* @__PURE__ */ new Map();
      const queue$1 = /* @__PURE__ */ new Map();
      EE.on("tick", () => {
        for(let   _ of queue$1.values()) {
          if (_.state == "aborted" || _.state == "done") {
            queue$1.delete(_.hash);
          }
        }
        if (queue$1.size < 5) {
          for(let   [hash, _] of pending.entries()) {
            pending.delete(hash);
            queue$1.set(hash, _);
            if (queue$1.size == 5) {
              break;
            }
          }
        }
        for(let   _ of queue$1.values()) {
          if (_.state == "idle") {
            _.start();
          }
        }
      });
      class Download extends EventEmitter {
        constructor(hash, location2) {
          super();
          __publicField(this, "downloader");
          __publicField(this, "tg");
          __publicField(this, "aborted", false);
          __publicField(this, "result");
          __publicField(this, "state", "idle");
          __publicField(this, "abortController", new AbortController());
          /**
           * Number 0 - 100
           */
          __publicField(this, "progress", 0);
          this.hash = hash;
          this.location = location2;
          this.tg = client();
          if (!this.tg)
            throw new Error("Telegram not initialized properly!");
        }
        emitStateChange() {
          this.emit("state", this.state);
        }
        set _state(val) {
          this.state = val;
          if (val == "aborting") {
            this.abortController.abort();
          }
          if (val == "aborted") {
            this.emit("done", null);
          }
          if (val == "done") {
            cacheMap.set(this.hash, this);
            this.emit("done", this.result);
            tick();
          }
          this.emitStateChange();
        }
        start() {
          return __async(this, null, function* () {
            if (this.aborted)
              return;
            if (this.state == "done")
              return;
            this._state = "started";
            yield sleep$1(50);
            const cached2 = yield getFileFromCache(this.hash);
            if (cached2) {
              this.result = cached2;
              this._state = "done";
              return;
            }
            const download = this.downloader = yield createDownloader(this.hash);
            try {
              for (var iter = __forAwait(this.tg.downloadAsIterable(this.location, {
                abortSignal: this.abortController.signal,
                progressCallback: (downloaded, _total) => {
                  const total = (Number.isFinite(_total) ? _total : this.location.fileSize) || 0;
                  if (total) {
                    this.emit("progress", this.progress = Math.floor(downloaded / total * 100));
                  }
                }
              })), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                const chunk = temp.value;
                this._state = "downloading";
                const res = yield download.append(chunk);
                if (res) {
                  this.result = res;
                  this._state = "done";
                  return;
                }
              }
            } catch (temp) {
              error = [temp];
            } finally {
              try {
                more && (temp = iter.return) && (yield temp.call(iter));
              } finally {
                if (error)
                  throw error[0];
              }
            }
            this.result = yield download.finalize();
            this.emit("progress", this.progress = 100);
            yield sleep$1(50);
            this._state = "done";
          });
        }
        abort() {
          return __async(this, null, function* () {
            var _a3;
            if (this.state == "done")
              return;
            this.aborted = true;
            this._state = "aborting";
            yield (_a3 = this.downloader) == null ? void 0 : _a3.cancel();
            this._state = "aborted";
            tick();
          });
        }
      }
      function downloadFile(file2) {
        const hash = hashFile(file2);
        if (hash === null) {
          console.error("HASH FAILED FOR FILE", file2);
          throw new Error("HASH FAILED");
        }
        if (cacheMap.has(hash)) {
          return cacheMap.get(hash);
        }
        if (pending.has(hash)) {
          return pending.get(hash);
        }
        if (queue$1.has(hash)) {
          return queue$1.get(hash);
        }
        const download = new Download(hash, file2);
        pending.set(hash, download);
        tick();
        return download;
      }
      const files = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        Download,
        downloadFile
      }, Symbol.toStringTag, { value: "Module" }));
      exports("dM", files);
      var _tmpl$$k = /* @__PURE__ */ template(`<div>`), _tmpl$2$d = /* @__PURE__ */ template(`<img>`);
      function ChatPhotoWithIcon(props) {
        const [placeholder, setPlaceholder] = createSignal(null);
        createEffect(() => {
          const src2 = props.src.thumb;
          if (src2) {
            const url2 = URL.createObjectURL(new Blob([src2]));
            setPlaceholder(url2);
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
          } else {
            setPlaceholder(null);
          }
        });
        const [src, setSrc] = createSignal(null);
        const [sampleSize, setSampleSize] = createSignal("");
        let divRef;
        let mounted = true;
        onMount(() => {
          mounted = true;
        });
        onCleanup(() => {
          mounted = false;
        });
        createEffect(() => {
          const file2 = props.src.small;
          const download = downloadFile(file2);
          setSampleSize(calculateSampleSize(160, 160, divRef.offsetWidth, divRef.offsetHeight));
          let url2;
          function stateChange() {
            if (download.state == "done") {
              if (mounted) {
                setSrc(url2 = URL.createObjectURL(download.result));
              }
            }
          }
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          download.on("state", stateChange);
          onCleanup(() => {
            download.off("state", stateChange);
            URL.revokeObjectURL(url2);
          });
        });
        return (() => {
          var _el$ = _tmpl$$k();
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$) : divRef = _el$;
          insert(_el$, createComponent(Show, {
            get when() {
              return placeholder();
            },
            children: (src2) => (() => {
              var _el$2 = _tmpl$2$d();
              createRenderEffect((_p$) => {
                var _v$ = {
                  [styles$g.thumb]: true,
                  [styles$g.photo]: true
                }, _v$2 = src2();
                _p$.e = classList$1(_el$2, _v$, _p$.e);
                _v$2 !== _p$.t && setAttribute(_el$2, "src", _p$.t = _v$2);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$2;
            })()
          }), null);
          insert(_el$, createComponent(Show, {
            get when() {
              return createMemo(() => !!sampleSize())() && src();
            },
            children: (src2) => (() => {
              var _el$3 = _tmpl$2$d();
              createRenderEffect((_p$) => {
                var _v$3 = {
                  [styles$g.animate]: true,
                  [styles$g.photo]: true
                }, _v$4 = src2() + sampleSize();
                _p$.e = classList$1(_el$3, _v$3, _p$.e);
                _v$4 !== _p$.t && setAttribute(_el$3, "src", _p$.t = _v$4);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$3;
            })()
          }), null);
          createRenderEffect(() => className(_el$, styles$g.photo));
          return _el$;
        })();
      }
      function ChatPhotoColor(props) {
        return (() => {
          var _el$4 = _tmpl$$k();
          insert(_el$4, () => props.children);
          createRenderEffect((_p$) => {
            var _v$5 = props.color, _v$6 = {
              [styles$g.color]: true
            }, _v$7 = props.color;
            _v$5 !== _p$.e && ((_p$.e = _v$5) != null ? _el$4.style.setProperty("background-color", _v$5) : _el$4.style.removeProperty("background-color"));
            _p$.t = classList$1(_el$4, _v$6, _p$.t);
            _v$7 !== _p$.a && setAttribute(_el$4, "data-color", _p$.a = _v$7);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          return _el$4;
        })();
      }
      function ChatPhotoIcon(props) {
        return createComponent(Show, {
          get when() {
            return props.showSavedIcon === void 0 || props.showSavedIcon;
          },
          get fallback() {
            return createComponent(Show, {
              get when() {
                return props.chat.photo;
              },
              get fallback() {
                return createComponent(ChatPhotoColor, {
                  get color() {
                    return getColorFromPeer(props.chat.peer);
                  },
                  get children() {
                    return props.chat.displayName.split(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]|\s/gi).map((a) => Array.from(a)[0]).join("").slice(0, 2);
                  }
                });
              },
              get children() {
                return createComponent(Show, {
                  get when() {
                    return props.chat.photo;
                  },
                  children: (photo2) => createComponent(ChatPhotoWithIcon, {
                    get chat() {
                      return props.chat;
                    },
                    get src() {
                      return photo2();
                    }
                  })
                });
              }
            });
          },
          get children() {
            return createComponent(Show, {
              get when() {
                return props.chat.photo && !props.chat.isSelf;
              },
              get fallback() {
                return createComponent(ChatPhotoColor, {
                  get color() {
                    return createMemo(() => !!props.chat.isSelf)() ? "saved" : getColorFromPeer(props.chat.peer);
                  },
                  get children() {
                    return createComponent(Show, {
                      get when() {
                        return props.chat.isSelf;
                      },
                      get fallback() {
                        return props.chat.displayName.split(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]|\s/gi).map((a) => Array.from(a)[0]).join("").slice(0, 2);
                      },
                      get children() {
                        return createComponent(TelegramIcon, {
                          style: {
                            "font-size": "1.1rem"
                          },
                          name: "saved"
                        });
                      }
                    });
                  }
                });
              },
              get children() {
                return createComponent(Show, {
                  get when() {
                    return props.chat.photo;
                  },
                  children: (photo2) => createComponent(ChatPhotoWithIcon, {
                    get chat() {
                      return props.chat;
                    },
                    get src() {
                      return photo2();
                    }
                  })
                });
              }
            });
          }
        });
      }
      function _unparse(text2, entities, params, entitiesOffset = 0, offset = 0, length = text2.length) {
        if (!text2)
          return [text2];
        if (!entities.length || entities.length === entitiesOffset) {
          return [text2];
        }
        const end = offset + length;
        const html2 = [];
        let lastOffset = 0;
        for (let i = entitiesOffset; i < entities.length; i++) {
          const entity = entities[i];
          if (entity.offset >= end)
            break;
          let entOffset = entity.offset;
          let length2 = entity.length;
          if (entOffset < 0) {
            length2 += entOffset;
            entOffset = 0;
          }
          let relativeOffset = entOffset - offset;
          if (relativeOffset > lastOffset) {
            html2.push(text2.substring(lastOffset, relativeOffset));
          } else if (relativeOffset < lastOffset) {
            length2 -= lastOffset - relativeOffset;
            relativeOffset = lastOffset;
          }
          if (length2 <= 0 || relativeOffset >= end || relativeOffset < 0) {
            continue;
          }
          let skip = false;
          const substr = text2.substr(relativeOffset, length2);
          if (!substr)
            continue;
          const type = entity._;
          let entityText;
          if (type === "messageEntityPre") {
            entityText = [substr];
          } else {
            entityText = _unparse(substr, entities, params, i + 1, offset + relativeOffset, length2);
          }
          switch (type) {
            case "messageEntityBold":
            case "messageEntityItalic":
            case "messageEntityUnderline":
            case "messageEntityStrike":
            case "messageEntityCode":
            case "messageEntitySpoiler":
              {
                const tag = {
                  messageEntityBold: "b",
                  messageEntityItalic: "i",
                  messageEntityUnderline: "u",
                  messageEntityStrike: "s",
                  messageEntityCode: "code",
                  messageEntitySpoiler: "spoiler"
                }[type];
                html2.push({ type, entity, tag, children: entityText, props: {}, source: substr });
              }
              break;
            case "messageEntityBlockquote":
              html2.push({
                type,
                tag: "blockquote",
                props: { collapsible: entity.collapsed ? true : void 0 },
                children: entityText,
                entity,
                source: substr
              });
              break;
            case "messageEntityPre":
              html2.push({
                type,
                tag: "pre",
                props: { lang: entity.language },
                children: params.syntaxHighlighter && entity.language ? params.syntaxHighlighter(entityText[0], entity.language) : entityText,
                entity,
                source: substr
              });
              break;
            case "messageEntityEmail":
              html2.push({
                type,
                entity,
                tag: "a",
                props: { href: `mailto:${entityText[0]}` },
                children: entityText,
                source: substr
              });
              break;
            case "messageEntityUrl":
              html2.push(
                {
                  type,
                  entity,
                  tag: "a",
                  props: { href: entityText[0] },
                  children: entityText,
                  source: substr
                }
                //  `<a href="${entityText}">${entityText}</a>`
              );
              break;
            case "messageEntityTextUrl":
              html2.push(
                {
                  type,
                  entity,
                  tag: "a",
                  props: { href: entity.url },
                  children: entityText,
                  source: substr
                }
                // `<a href="${escape(entity.url, true)}">${entityText}</a>`
              );
              break;
            case "messageEntityMentionName":
              html2.push(
                {
                  type,
                  entity,
                  tag: "a",
                  props: { href: `tg://user?id=${entity.userId}` },
                  children: entityText,
                  source: substr
                }
                //  `<a href="tg://user?id=${entity.userId}">${entityText}</a>`
              );
              break;
            case "messageEntityMention":
              html2.push(
                {
                  type,
                  entity,
                  tag: "a",
                  props: { href: `javascript:void(0)` },
                  children: entityText,
                  source: substr
                }
                //  `<a href="tg://user?id=${entity.userId}">${entityText}</a>`
              );
              break;
            default:
              skip = true;
              break;
          }
          lastOffset = relativeOffset + (skip ? 0 : length2);
        }
        html2.push(text2.substr(lastOffset));
        return html2;
      }
      function unparse$1(input, options2) {
        var _a3;
        if (typeof input === "string") {
          return _unparse(input, [], {});
        }
        return _unparse(input.text, (_a3 = input.entities) != null ? _a3 : [], {});
      }
      const emoji_wrap = "_emoji_wrap_1rg15_2";
      const emoji$2 = "_emoji_1rg15_2";
      const mention = "_mention_1rg15_20";
      const markdown = "_markdown_1rg15_28";
      const spoiler = "_spoiler_1rg15_28";
      const styles$f = {
        emoji_wrap,
        emoji: emoji$2,
        mention,
        markdown,
        spoiler
      };
      const $RAW = Symbol("store-raw"), $NODE = Symbol("store-node"), $HAS = Symbol("store-has"), $SELF = Symbol("store-self");
      function wrap$1(value) {
        let p = value[$PROXY];
        if (!p) {
          Object.defineProperty(value, $PROXY, {
            value: p = new Proxy(value, proxyTraps$1)
          });
          if (!Array.isArray(value)) {
            const keys2 = Object.keys(value), desc2 = Object.getOwnPropertyDescriptors(value);
            for (let i = 0, l2 = keys2.length; i < l2; i++) {
              const prop = keys2[i];
              if (desc2[prop].get) {
                Object.defineProperty(value, prop, {
                  enumerable: desc2[prop].enumerable,
                  get: desc2[prop].get.bind(p)
                });
              }
            }
          }
        }
        return p;
      }
      function isWrappable(obj) {
        let proto;
        return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
      }
      function unwrap(item2, set2 = /* @__PURE__ */ new Set()) {
        let result, unwrapped, v, prop;
        if (result = item2 != null && item2[$RAW])
          return result;
        if (!isWrappable(item2) || set2.has(item2))
          return item2;
        if (Array.isArray(item2)) {
          if (Object.isFrozen(item2))
            item2 = item2.slice(0);
          else
            set2.add(item2);
          for (let i = 0, l2 = item2.length; i < l2; i++) {
            v = item2[i];
            if ((unwrapped = unwrap(v, set2)) !== v)
              item2[i] = unwrapped;
          }
        } else {
          if (Object.isFrozen(item2))
            item2 = Object.assign({}, item2);
          else
            set2.add(item2);
          const keys2 = Object.keys(item2), desc2 = Object.getOwnPropertyDescriptors(item2);
          for (let i = 0, l2 = keys2.length; i < l2; i++) {
            prop = keys2[i];
            if (desc2[prop].get)
              continue;
            v = item2[prop];
            if ((unwrapped = unwrap(v, set2)) !== v)
              item2[prop] = unwrapped;
          }
        }
        return item2;
      }
      function getNodes(target, symbol) {
        let nodes = target[symbol];
        if (!nodes)
          Object.defineProperty(target, symbol, {
            value: nodes = /* @__PURE__ */ Object.create(null)
          });
        return nodes;
      }
      function getNode(nodes, property, value) {
        if (nodes[property])
          return nodes[property];
        const [s, set2] = createSignal(value, {
          equals: false,
          internal: true
        });
        s.$ = set2;
        return nodes[property] = s;
      }
      function proxyDescriptor$1(target, property) {
        const desc2 = Reflect.getOwnPropertyDescriptor(target, property);
        if (!desc2 || desc2.get || !desc2.configurable || property === $PROXY || property === $NODE)
          return desc2;
        delete desc2.value;
        delete desc2.writable;
        desc2.get = () => target[$PROXY][property];
        return desc2;
      }
      function trackSelf(target) {
        getListener() && getNode(getNodes(target, $NODE), $SELF)();
      }
      function ownKeys(target) {
        trackSelf(target);
        return Reflect.ownKeys(target);
      }
      const proxyTraps$1 = {
        get(target, property, receiver) {
          if (property === $RAW)
            return target;
          if (property === $PROXY)
            return receiver;
          if (property === $TRACK) {
            trackSelf(target);
            return receiver;
          }
          const nodes = getNodes(target, $NODE);
          const tracked = nodes[property];
          let value = tracked ? tracked() : target[property];
          if (property === $NODE || property === $HAS || property === "__proto__")
            return value;
          if (!tracked) {
            const desc2 = Object.getOwnPropertyDescriptor(target, property);
            if (getListener() && (typeof value !== "function" || target.hasOwnProperty(property)) && !(desc2 && desc2.get))
              value = getNode(nodes, property, value)();
          }
          return isWrappable(value) ? wrap$1(value) : value;
        },
        has(target, property) {
          if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === "__proto__")
            return true;
          getListener() && getNode(getNodes(target, $HAS), property)();
          return property in target;
        },
        set() {
          return true;
        },
        deleteProperty() {
          return true;
        },
        ownKeys,
        getOwnPropertyDescriptor: proxyDescriptor$1
      };
      function setProperty(state, property, value, deleting = false) {
        if (!deleting && state[property] === value)
          return;
        const prev = state[property], len = state.length;
        if (value === void 0) {
          delete state[property];
          if (state[$HAS] && state[$HAS][property] && prev !== void 0)
            state[$HAS][property].$();
        } else {
          state[property] = value;
          if (state[$HAS] && state[$HAS][property] && prev === void 0)
            state[$HAS][property].$();
        }
        let nodes = getNodes(state, $NODE), node;
        if (node = getNode(nodes, property, prev))
          node.$(() => value);
        if (Array.isArray(state) && state.length !== len) {
          for (let i = state.length; i < len; i++)
            (node = nodes[i]) && node.$();
          (node = getNode(nodes, "length", len)) && node.$(state.length);
        }
        (node = nodes[$SELF]) && node.$();
      }
      function mergeStoreNode(state, value) {
        const keys2 = Object.keys(value);
        for (let i = 0; i < keys2.length; i += 1) {
          const key = keys2[i];
          setProperty(state, key, value[key]);
        }
      }
      function updateArray(current2, next2) {
        if (typeof next2 === "function")
          next2 = next2(current2);
        next2 = unwrap(next2);
        if (Array.isArray(next2)) {
          if (current2 === next2)
            return;
          let i = 0, len = next2.length;
          for (; i < len; i++) {
            const value = next2[i];
            if (current2[i] !== value)
              setProperty(current2, i, value);
          }
          setProperty(current2, "length", len);
        } else
          mergeStoreNode(current2, next2);
      }
      function updatePath(current2, path2, traversed = []) {
        let part, prev = current2;
        if (path2.length > 1) {
          part = path2.shift();
          const partType = typeof part, isArray2 = Array.isArray(current2);
          if (Array.isArray(part)) {
            for (let i = 0; i < part.length; i++) {
              updatePath(current2, [part[i]].concat(path2), traversed);
            }
            return;
          } else if (isArray2 && partType === "function") {
            for (let i = 0; i < current2.length; i++) {
              if (part(current2[i], i))
                updatePath(current2, [i].concat(path2), traversed);
            }
            return;
          } else if (isArray2 && partType === "object") {
            const { from: from2 = 0, to = current2.length - 1, by = 1 } = part;
            for (let i = from2; i <= to; i += by) {
              updatePath(current2, [i].concat(path2), traversed);
            }
            return;
          } else if (path2.length > 1) {
            updatePath(current2[part], path2, [part].concat(traversed));
            return;
          }
          prev = current2[part];
          traversed = [part].concat(traversed);
        }
        let value = path2[0];
        if (typeof value === "function") {
          value = value(prev, traversed);
          if (value === prev)
            return;
        }
        if (part === void 0 && value == void 0)
          return;
        value = unwrap(value);
        if (part === void 0 || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {
          mergeStoreNode(prev, value);
        } else
          setProperty(current2, part, value);
      }
      function createStore(store2, options2) {
        const unwrappedStore = unwrap(store2 || {});
        const isArray2 = Array.isArray(unwrappedStore);
        const wrappedStore = wrap$1(unwrappedStore);
        function setStore(...args) {
          batch(() => {
            isArray2 && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);
          });
        }
        return [wrappedStore, setStore];
      }
      const $ROOT = Symbol("store-root");
      function applyState(target, parent, property, merge2, key) {
        const previous2 = parent[property];
        if (target === previous2)
          return;
        const isArray2 = Array.isArray(target);
        if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous2) || isArray2 !== Array.isArray(previous2) || key && target[key] !== previous2[key])) {
          setProperty(parent, property, target);
          return;
        }
        if (isArray2) {
          if (target.length && previous2.length && (!merge2 || key && target[0] && target[0][key] != null)) {
            let i, j, start2, end, newEnd, item2, newIndicesNext, keyVal;
            for (start2 = 0, end = Math.min(previous2.length, target.length); start2 < end && (previous2[start2] === target[start2] || key && previous2[start2] && target[start2] && previous2[start2][key] === target[start2][key]); start2++) {
              applyState(target[start2], previous2, start2, merge2, key);
            }
            const temp = new Array(target.length), newIndices = /* @__PURE__ */ new Map();
            for (end = previous2.length - 1, newEnd = target.length - 1; end >= start2 && newEnd >= start2 && (previous2[end] === target[newEnd] || key && previous2[end] && target[newEnd] && previous2[end][key] === target[newEnd][key]); end--, newEnd--) {
              temp[newEnd] = previous2[end];
            }
            if (start2 > newEnd || start2 > end) {
              for (j = start2; j <= newEnd; j++)
                setProperty(previous2, j, target[j]);
              for (; j < target.length; j++) {
                setProperty(previous2, j, temp[j]);
                applyState(target[j], previous2, j, merge2, key);
              }
              if (previous2.length > target.length)
                setProperty(previous2, "length", target.length);
              return;
            }
            newIndicesNext = new Array(newEnd + 1);
            for (j = newEnd; j >= start2; j--) {
              item2 = target[j];
              keyVal = key && item2 ? item2[key] : item2;
              i = newIndices.get(keyVal);
              newIndicesNext[j] = i === void 0 ? -1 : i;
              newIndices.set(keyVal, j);
            }
            for (i = start2; i <= end; i++) {
              item2 = previous2[i];
              keyVal = key && item2 ? item2[key] : item2;
              j = newIndices.get(keyVal);
              if (j !== void 0 && j !== -1) {
                temp[j] = previous2[i];
                j = newIndicesNext[j];
                newIndices.set(keyVal, j);
              }
            }
            for (j = start2; j < target.length; j++) {
              if (j in temp) {
                setProperty(previous2, j, temp[j]);
                applyState(target[j], previous2, j, merge2, key);
              } else
                setProperty(previous2, j, target[j]);
            }
          } else {
            for (let i = 0, len = target.length; i < len; i++) {
              applyState(target[i], previous2, i, merge2, key);
            }
          }
          if (previous2.length > target.length)
            setProperty(previous2, "length", target.length);
          return;
        }
        const targetKeys = Object.keys(target);
        for (let i = 0, len = targetKeys.length; i < len; i++) {
          applyState(target[targetKeys[i]], previous2, targetKeys[i], merge2, key);
        }
        const previousKeys = Object.keys(previous2);
        for (let i = 0, len = previousKeys.length; i < len; i++) {
          if (target[previousKeys[i]] === void 0)
            setProperty(previous2, previousKeys[i], void 0);
        }
      }
      function reconcile(value, options2 = {}) {
        const { merge: merge2, key = "id" } = options2, v = unwrap(value);
        return (state) => {
          if (!isWrappable(state) || !isWrappable(v))
            return v;
          const res = applyState(
            v,
            {
              [$ROOT]: state
            },
            $ROOT,
            merge2,
            key
          );
          return res === void 0 ? state : res;
        };
      }
      var _tmpl$$j = /* @__PURE__ */ template(`<span>`), _tmpl$2$c = /* @__PURE__ */ template(`<span><img>`);
      function EntityChildren(props) {
        return createComponent(For, {
          get each() {
            return props.$;
          },
          children: (e2) => createComponent(Entity, {
            $: e2,
            get customRenderer() {
              return props.customRenderer;
            }
          })
        });
      }
      function EntityNode(props) {
        return createComponent(Switch, {
          get fallback() {
            return createComponent(Dynamic, mergeProps({
              get component() {
                return props.$.tag;
              },
              get ["class"]() {
                return props.$.entity._ == "messageEntityMention" ? styles$f.mention : void 0;
              }
            }, () => props.$.props, {
              get children() {
                return createComponent(EntityChildren, {
                  get $() {
                    return props.$.children;
                  },
                  get customRenderer() {
                    return props.customRenderer;
                  }
                });
              }
            }));
          },
          get children() {
            return [createComponent(Match, {
              get when() {
                var _a3;
                return (_a3 = props.customRenderer) == null ? void 0 : _a3.call(props, props.$, () => createComponent(Dynamic, mergeProps({
                  get component() {
                    return props.$.tag;
                  },
                  get ["class"]() {
                    return props.$.entity._ == "messageEntityMention" ? styles$f.mention : void 0;
                  }
                }, () => props.$.props, {
                  get children() {
                    return createComponent(EntityChildren, {
                      get $() {
                        return props.$.children;
                      },
                      get customRenderer() {
                        return props.customRenderer;
                      }
                    });
                  }
                })));
              },
              children: (e2) => createComponent(Dynamic, mergeProps(() => props.$, {
                get component() {
                  return e2();
                }
              }))
            }), createComponent(Match, {
              get when() {
                return props.$.tag == "spoiler";
              },
              get children() {
                var _el$ = _tmpl$$j();
                insert(_el$, createComponent(EntityChildren, {
                  get $() {
                    return props.$.children;
                  },
                  get customRenderer() {
                    return props.customRenderer;
                  }
                }));
                createRenderEffect(() => className(_el$, styles$f.spoiler));
                return _el$;
              }
            })];
          }
        });
      }
      const twemojiMatcher = /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
      function extractMatchesAndUnmatched(input, globalRegex) {
        const result = [];
        let lastIndex = 0;
        let match2;
        while ((match2 = globalRegex.exec(input)) !== null) {
          if (match2.index > lastIndex) {
            result.push(input.slice(lastIndex, match2.index));
          }
          result.push({
            match: match2[0]
            // index: match.index
          });
          lastIndex = globalRegex.lastIndex;
        }
        if (lastIndex < input.length) {
          result.push(input.slice(lastIndex));
        }
        return result;
      }
      function encodeEmoji(emojiText) {
        const codepoints = toCodePoints(emojiText).join("-");
        return codepoints;
      }
      function toCodePoints(unicodeSurrogates) {
        const points = [];
        let char = 0;
        let previous2 = 0;
        let i = 0;
        while (i < unicodeSurrogates.length) {
          char = unicodeSurrogates.charCodeAt(i++);
          if (previous2) {
            points.push((65536 + (previous2 - 55296 << 10) + (char - 56320)).toString(16));
            previous2 = 0;
          } else if (char > 55296 && char <= 56319) {
            previous2 = char;
          } else {
            points.push(char.toString(16));
          }
        }
        if (points.length && points[0].length == 2) {
          points[0] = "00" + points[0];
        }
        return points;
      }
      const toCodePoint = memoize(function toCodePoint2(unicodeSurrogates) {
        return encodeEmoji(unicodeSurrogates);
      });
      function Twemoji(props) {
        let [show, setShow] = createSignal(false);
        return (() => {
          var _el$2 = _tmpl$2$c(), _el$3 = _el$2.firstChild;
          _el$3.addEventListener("load", () => {
            setShow(true);
          });
          _el$3.addEventListener("error", () => {
            setTimeout(() => {
              setShow(true);
            }, 1e3);
          });
          createRenderEffect((_p$) => {
            var _v$ = styles$f.emoji_wrap, _v$2 = show() ? void 0 : 0, _v$3 = styles$f.emoji, _v$4 = "https://cyan-2048.github.io/kaigram-assets/emoji2/" + toCodePoint(props.text) + ".png", _v$5 = props.text;
            _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
            _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$3.style.setProperty("opacity", _v$2) : _el$3.style.removeProperty("opacity"));
            _v$3 !== _p$.a && className(_el$3, _p$.a = _v$3);
            _v$4 !== _p$.o && setAttribute(_el$3, "src", _p$.o = _v$4);
            _v$5 !== _p$.i && setAttribute(_el$3, "alt", _p$.i = _v$5);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0
          });
          return _el$2;
        })();
      }
      function ModifyString(props) {
        const parsed = () => extractMatchesAndUnmatched(props.text, twemojiMatcher);
        return createComponent(For, {
          get each() {
            return parsed();
          },
          children: (match2) => createComponent(Show, {
            when: typeof match2 == "string",
            get fallback() {
              return createComponent(Twemoji, {
                get text() {
                  return match2.match;
                }
              });
            },
            children: match2
          })
        });
      }
      function Entity(props) {
        return createComponent(Show, {
          get when() {
            return typeof props.$ == "string";
          },
          get fallback() {
            return createComponent(EntityNode, {
              get $() {
                return props.$;
              },
              get customRenderer() {
                return props.customRenderer;
              }
            });
          },
          get children() {
            return createComponent(ModifyString, {
              get text() {
                return props.$;
              }
            });
          }
        });
      }
      function Markdown(props) {
        const [ast, setAst] = createStore([]);
        createRenderEffect(() => {
          setAst(reconcile(unparse$1(props.entities), {
            merge: true
          }));
        });
        return (() => {
          var _el$4 = _tmpl$$j();
          insert(_el$4, createComponent(EntityChildren, {
            $: ast,
            get customRenderer() {
              return props.customRenderer;
            }
          }));
          createRenderEffect(() => className(_el$4, styles$f.markdown));
          return _el$4;
        })();
      }
      const changelog = "_changelog_mor8a_1";
      const inner = "_inner_mor8a_9";
      const styles$e = {
        changelog,
        inner
      };
      var _tmpl$$i = /* @__PURE__ */ template(`<div> Integrity Check failed!`), _tmpl$2$b = /* @__PURE__ */ template(`<div tabindex=-1><div></div><div>First Release</div><div><span>(expect missing features)</span></div><div>Source code available at: https://github.com/cyan-2048/solid-telekram`), _tmpl$3$7 = /* @__PURE__ */ template(`<div>`);
      const CHANGELOG_VERSION = "1";
      function Changelog(props) {
        let divRef;
        onMount(() => {
          localStorage.setItem("CHANGELOG_VERSION", CHANGELOG_VERSION);
          __CJS__export_default__.pause();
          divRef.focus();
          setSoftkeys("", "OK", "");
        });
        onCleanup(() => {
          __CJS__export_default__.resume();
        });
        return createComponent(Portal, {
          get children() {
            var _el$ = _tmpl$3$7();
            insert(_el$, createComponent(Options, {
              get onClose() {
                return props.onClose;
              },
              title: "Changelog",
              get children() {
                var _el$2 = _tmpl$2$b(), _el$5 = _el$2.firstChild, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild, _el$9 = _el$7.nextSibling;
                var _ref$ = divRef;
                typeof _ref$ === "function" ? use(_ref$, _el$2) : divRef = _el$2;
                _el$2.$$keydown = (e2) => {
                  if (e2.key == "Enter") {
                    props.onClose();
                  }
                };
                insert(_el$2, createComponent(Show, {
                  get when() {
                    return !appIntegrity();
                  },
                  get children() {
                    var _el$3 = _tmpl$$i(), _el$4 = _el$3.firstChild;
                    _el$3.style.setProperty("font-size", "14px");
                    _el$3.style.setProperty("margin-bottom", "4px");
                    insert(_el$3, createComponent(ModifyString, {
                      text: "🚫"
                    }), _el$4);
                    return _el$3;
                  }
                }), _el$5);
                _el$5.style.setProperty("text-align", "center");
                _el$5.style.setProperty("font-size", "32px");
                insert(_el$5, createComponent(ModifyString, {
                  text: "🎉"
                }));
                _el$6.style.setProperty("text-align", "center");
                _el$7.style.setProperty("text-align", "center");
                _el$8.style.setProperty("font-size", "10px");
                _el$9.style.setProperty("font-size", "12px");
                createRenderEffect(() => className(_el$2, styles$e.inner));
                return _el$2;
              }
            }));
            createRenderEffect(() => className(_el$, styles$e.changelog));
            return _el$;
          }
        });
      }
      delegateEvents(["keydown"]);
      var _tmpl$$h = /* @__PURE__ */ template(`<div>`), _tmpl$2$a = /* @__PURE__ */ template(`<span>: `), _tmpl$3$6 = /* @__PURE__ */ template(`<div tabindex=-1><div></div><div><div><div></div><div></div></div><div><div></div><div>`), _tmpl$4$6 = /* @__PURE__ */ template(`<div><div><div>`);
      const focusable = true;
      const BRAILE = "⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠩⠝⠕⠏⠟⠗⠎⠞⠥⠼⠺⠭⠽⠵";
      function generateHiddenCodeThing(length = 5) {
        let e2 = "";
        while (e2.length < length) {
          e2 = e2 + BRAILE[Math.floor(Math.random() * BRAILE.length)];
        }
        return e2;
      }
      function getWeek(d) {
        var target = new Date(d.valueOf());
        var dayNr = (d.getDay() + 6) % 7;
        target.setDate(target.getDate() - dayNr + 3);
        var jan4 = new Date(target.getFullYear(), 0, 4);
        var dayDiff = (+target - +jan4) / 864e5;
        var weekNr = 1 + Math.ceil(dayDiff / 7);
        return weekNr;
      }
      function timeStamp(date2) {
        const today2 = /* @__PURE__ */ new Date();
        const isSameYear = today2.getFullYear() == date2.getFullYear();
        if (isSameYear) {
          if (isToday(date2, today2)) {
            return date2.toLocaleTimeString(navigator.language, {
              hour: "numeric",
              minute: "numeric"
            });
          } else {
            const isSameWeek = getWeek(date2) == getWeek(today2);
            if (isSameWeek) {
              return date2.toLocaleDateString(navigator.language, {
                weekday: "short"
              });
            } else {
              return date2.toLocaleDateString(navigator.language, {
                month: "short",
                day: "numeric"
              });
            }
          }
        } else {
          return date2.toLocaleDateString(navigator.language);
        }
      }
      function DialogDate(props) {
        const [text2, setText] = createSignal("");
        createRenderEffect(() => {
          const date2 = props.$;
          setText(timeStamp(date2));
        });
        return createMemo(text2);
      }
      function DialogSender(props) {
        const chat2 = () => props.$.$.chat;
        const lastMessage = useStore(() => props.$.lastMessage);
        const check2 = useMessageChecks(lastMessage, () => props.$);
        return createComponent(Show, {
          get when() {
            return createMemo(() => !!lastMessage())() && !lastMessage().$.action;
          },
          get children() {
            return [createComponent(Show, {
              get when() {
                var _a3;
                return (_a3 = lastMessage()) == null ? void 0 : _a3.isOutgoing;
              },
              get children() {
                var _el$ = _tmpl$$h();
                insert(_el$, createComponent(TelegramIcon, {
                  get name() {
                    return check2() ? "check" : "checks";
                  }
                }));
                createRenderEffect(() => className(_el$, styles$i.check));
                return _el$;
              }
            }), createComponent(Show, {
              get when() {
                return createMemo(() => !!(lastMessage() && !lastMessage().isOutgoing))() && (chat2().isGroup || chat2().isForum);
              },
              get children() {
                var _el$2 = _tmpl$2$a(), _el$3 = _el$2.firstChild;
                insert(_el$2, () => lastMessage().sender.firstName || lastMessage().sender.displayName, _el$3);
                createRenderEffect(() => className(_el$2, styles$i.sender));
                return _el$2;
              }
            })];
          }
        });
      }
      const SN_ID_OPTIONS$2 = "dialog_options";
      function DialogOptions(props) {
        onMount(() => {
          __CJS__export_default__.add(SN_ID_OPTIONS$2, {
            selector: ".option",
            restrict: "self-only"
          });
          __CJS__export_default__.focus(SN_ID_OPTIONS$2);
          setSoftkeys("", "OK", "");
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID_OPTIONS$2);
        });
        return createComponent(Options, {
          onClose: () => {
            props.onSelect(null);
          },
          title: "Options",
          get children() {
            return [createComponent(OptionsItem, {
              get classList() {
                return {
                  option: true,
                  [styles$i.item]: true
                };
              },
              tabIndex: -1,
              "on:sn-enter-down": () => {
                props.onSelect(
                  6
                  /* CHANGELOG */
                );
              },
              children: "Changelog"
            }), createComponent(OptionsItem, {
              get classList() {
                return {
                  option: true,
                  [styles$i.item]: true
                };
              },
              tabIndex: -1,
              "on:sn-enter-down": () => {
                props.onSelect(
                  7
                  /* SETTINGS */
                );
              },
              children: "Settings"
            }), createComponent(OptionsItem, {
              get classList() {
                return {
                  option: true,
                  [styles$i.item]: true
                };
              },
              tabIndex: -1,
              "on:sn-enter-down": () => {
                props.onSelect(
                  8
                  /* EXIT */
                );
              },
              children: "Exit"
            }), createComponent(Show, {
              get when() {
                return !localStorage.getItem("NO_ADS");
              },
              get children() {
                return createComponent(OptionsItem, {
                  get classList() {
                    return {
                      option: true,
                      [styles$i.item]: true
                    };
                  },
                  tabIndex: -1,
                  "on:sn-enter-down": () => {
                    props.onSelect(
                      5
                      /* KAIAD */
                    );
                  },
                  children: "Show Ad"
                });
              }
            })];
          }
        });
      }
      function DialogItem(props) {
        const [focused2, setFocused] = createSignal(false);
        const lastMessage = useStore(() => props.$.lastMessage);
        let divRef;
        const text2 = from(readable("", (set2) => {
          const unsubs = [];
          const sub = props.$.lastMessage.subscribe((lastMsg) => {
            if (lastMsg) {
              unsubs.push(lastMsg.entities.subscribe((str) => {
                str.entities ? set2(unparse$1(str).map((a) => typeof a == "string" ? a : a.entity._ == "messageEntitySpoiler" ? generateHiddenCodeThing(a.source.length) : a.source).join("") || get_store_value(lastMsg.text)) : set2(get_store_value(lastMsg.text));
              }));
            } else {
              set2("");
            }
          });
          unsubs.push(sub);
          return () => {
            unsubs.forEach((a) => a());
          };
        }));
        const pinned = useStore(() => props.$.pinned);
        const count2 = useStore(() => props.$.count);
        const muted2 = useStore(() => props.$.muted);
        const textFactory = () => {
          const _text = text2();
          const isSupport = props.$.$.chat.isSupport;
          return _text && (isSupport ? _text.replace(/Login code: \d\d\d\d\d/, "Login code: " + generateHiddenCodeThing()) : _text);
        };
        createRenderEffect(() => {
          if (props.isSearchResult) {
            console.error("search result dialog");
            return;
          }
        });
        const [showChangelog, setShowChangelog] = createSignal(false);
        const [showOptions, setShowOptions] = createSignal(false);
        return [(() => {
          var _el$4 = _tmpl$3$6(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling, _el$10 = _el$7.nextSibling, _el$11 = _el$10.firstChild, _el$12 = _el$11.nextSibling;
          addEventListener(_el$4, "sn-willfocus", (e$12) => {
            e(e$12.currentTarget, {
              scrollMode: "if-needed",
              block: "nearest",
              inline: "nearest"
            });
          });
          addEventListener(_el$4, "sn-enter-down", () => __async(this, null, function* () {
            if (!props.$.messages.hasLoadedBefore) {
              props.$.messages.loadMore();
            }
            batch(() => {
              setUIDialog(props.$);
              setRoom(props.$.$.chat);
              setView("room");
            });
            if (props.$.$.chat.isForum) {
              toaster("Forum supergroups are currently unstable!");
            }
          }));
          _el$4.$$keydown = (e2) => {
            if (e2.key == "SoftRight") {
              setShowOptions(true);
            }
            if (e2.key == "SoftLeft") {
              batch(() => {
                setPreviousView("home");
                setView("new_chat");
              });
            }
          };
          _el$4.addEventListener("blur", () => {
            setFocused(false);
          });
          _el$4.addEventListener("focus", () => {
            setStatusbarColor("#1c96c3");
            setSoftkeys("New chat", "OPEN", "tg:more");
            setFocused(true);
          });
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$4) : divRef = _el$4;
          insert(_el$5, createComponent(ChatPhotoIcon, {
            get chat() {
              return props.$.$.chat;
            }
          }));
          insert(_el$8, createComponent(MarqueeOrNot, {
            get marquee() {
              return focused2();
            },
            get children() {
              return props.$.$.chat.isSelf ? "Saved Messages" : props.$.$.chat.displayName;
            }
          }));
          insert(_el$9, createComponent(Show, {
            get when() {
              return "verified" in props.$.$.chat.peer && props.$.$.chat.peer.verified;
            },
            get children() {
              return createComponent(VerifiedIcon, {
                width: 14,
                height: 14,
                get ["class"]() {
                  return styles$i.verified;
                }
              });
            }
          }), null);
          insert(_el$9, createComponent(Show, {
            get when() {
              return muted2();
            },
            get children() {
              return createComponent(TelegramIcon, {
                get classList() {
                  return {
                    [styles$i.icons]: true
                  };
                },
                name: "muted"
              });
            }
          }), null);
          insert(_el$9, createComponent(Show, {
            get when() {
              return lastMessage();
            },
            children: (message2) => createComponent(DialogDate, {
              get $() {
                return message2().date;
              }
            })
          }), null);
          insert(_el$11, createComponent(DialogSender, {
            get $() {
              return props.$;
            }
          }), null);
          insert(_el$11, createComponent(ModifyString, {
            get text() {
              var _a3;
              return ((_a3 = textFactory()) == null ? void 0 : _a3.slice(0, 30)) || "__";
            }
          }), null);
          insert(_el$12, createComponent(Show, {
            get when() {
              return createMemo(() => !!pinned())() && !count2();
            },
            get children() {
              return createComponent(TelegramIcon, {
                name: "chatspinned"
              });
            }
          }), null);
          insert(_el$12, createComponent(Show, {
            get when() {
              return count2();
            },
            get children() {
              var _el$13 = _tmpl$$h();
              insert(_el$13, count2);
              createRenderEffect((_$p) => classList$1(_el$13, {
                [styles$i.count]: true,
                [styles$i.muted]: muted2()
              }, _$p));
              return _el$13;
            }
          }), null);
          createRenderEffect((_p$) => {
            var _v$ = {
              [styles$i.dialog]: true,
              focusable
            }, _v$2 = styles$i.icon, _v$3 = styles$i.details, _v$4 = styles$i.top, _v$5 = styles$i.name, _v$6 = styles$i.time, _v$7 = styles$i.bottom, _v$8 = styles$i.desc, _v$9 = styles$i.meta;
            _p$.e = classList$1(_el$4, _v$, _p$.e);
            _v$2 !== _p$.t && className(_el$5, _p$.t = _v$2);
            _v$3 !== _p$.a && className(_el$6, _p$.a = _v$3);
            _v$4 !== _p$.o && className(_el$7, _p$.o = _v$4);
            _v$5 !== _p$.i && className(_el$8, _p$.i = _v$5);
            _v$6 !== _p$.n && className(_el$9, _p$.n = _v$6);
            _v$7 !== _p$.s && className(_el$10, _p$.s = _v$7);
            _v$8 !== _p$.h && className(_el$11, _p$.h = _v$8);
            _v$9 !== _p$.r && className(_el$12, _p$.r = _v$9);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0,
            n: void 0,
            s: void 0,
            h: void 0,
            r: void 0
          });
          return _el$4;
        })(), createComponent(Show, {
          get when() {
            return showOptions();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(DialogOptions, {
                  onSelect: (e2) => __async(this, null, function* () {
                    const tg = client();
                    setShowOptions(false);
                    switch (e2) {
                      case 5:
                        showKaiAd();
                        break;
                      case 4:
                        yield sleep$1(100);
                        const sure = confirm("Are you sure you want to logout?");
                        if (!sure)
                          break;
                        const success = yield tg.logOut();
                        if (!success) {
                          alert("Logout was not successful!");
                          yield tg.storage.clear(true);
                        }
                        location.reload();
                        return;
                      case 7:
                        batch(() => {
                          setPreviousView("home");
                          setView("settings");
                        });
                        return;
                      case 6:
                        setShowChangelog(true);
                        return;
                      case 8:
                        window.close();
                        return;
                    }
                    yield sleep$1(100);
                    __CJS__export_default__.focus("dialogs");
                  }),
                  get $() {
                    return props.$;
                  },
                  get muted() {
                    return muted2();
                  },
                  get pinned() {
                    return pinned();
                  }
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return showChangelog();
          },
          get children() {
            return createComponent(Changelog, {
              onClose: () => __async(this, null, function* () {
                setShowChangelog(false);
                yield sleep$1(100);
                __CJS__export_default__.focus("dialogs");
              })
            });
          }
        })];
      }
      function DialogFilterTab(props) {
        const text2 = useStore(() => props.$.title);
        return createComponent(Tab, {
          onClick: () => {
            setTab(props.$);
          },
          get selected() {
            return currentTab() == props.$;
          },
          get children() {
            return text2();
          }
        });
      }
      const ONE_FOCUSABLE$1 = ".focusable";
      const TWO_FOCUSABLE$1 = ONE_FOCUSABLE$1.repeat(2);
      let lastUsedFocusableClass$1 = TWO_FOCUSABLE$1;
      function refreshFocusables$1() {
        __CJS__export_default__.remove("dialogs");
        const focusableToUse = lastUsedFocusableClass$1 = lastUsedFocusableClass$1 == ONE_FOCUSABLE$1 ? TWO_FOCUSABLE$1 : ONE_FOCUSABLE$1;
        __CJS__export_default__.add("dialogs", {
          selector: `.${styles$i.dialogs} ${focusableToUse}`,
          rememberSource: true,
          restrict: "self-only",
          defaultElement: `.${styles$i.dialog}`,
          enterTo: "last-focused"
        });
      }
      function Home(props) {
        const [mounted, setMounted] = createSignal(false);
        onMount(() => {
          refreshFocusables$1();
          setMounted(true);
        });
        onCleanup(() => {
          setMounted(false);
          __CJS__export_default__.remove("dialogs");
        });
        createEffect(() => {
          const hidden2 = props.hidden;
          if (!mounted())
            return;
          if (!hidden2) {
            resumeKeypress();
            __CJS__export_default__.resume();
            __CJS__export_default__.focus("dialogs");
            e(document.activeElement, {
              scrollMode: "if-needed",
              block: "nearest",
              inline: "nearest"
            });
          }
        });
        const [searchText, setSearchText] = createSignal("");
        const [searchResults, setSearchResults] = createSignal([]);
        const debounced_search = debounce((str) => {
          if (searchText()) {
            setSearchResults(chatMinisearch.search(str).map((a) => dialogsJar.get(a.id)));
          }
        }, 150);
        createEffect(() => {
          const toSearch = searchText();
          debounced_search(toSearch.toLowerCase());
        });
        const [currentSlice, setCurrentSlice] = createSignal(20);
        const tabFiltered = createMemo(() => {
          const _tab = currentTab();
          const slice = currentSlice();
          const _dialogs = dialogs$1();
          if (_tab == null)
            return _dialogs.slice(0, slice);
          console.time("dialog filter");
          const filtered = [];
          for (let i = 0; i < _dialogs.length; i++) {
            const d = _dialogs[i];
            if (_tab.filter(d)) {
              filtered.push(d);
              if (filtered.length >= slice)
                break;
            }
          }
          console.timeEnd("dialog filter");
          return filtered;
        });
        return createComponent(Content, {
          get hidden() {
            return props.hidden;
          },
          get before() {
            return createComponent(Tabs, {
              get children() {
                return [createComponent(Tab, {
                  get selected() {
                    return currentTab() == null;
                  },
                  children: "Chats"
                }), createComponent(For, {
                  get each() {
                    return dialogFilters();
                  },
                  children: (a) => createComponent(DialogFilterTab, {
                    $: a
                  })
                })];
              }
            });
          },
          get children() {
            var _el$14 = _tmpl$4$6(), _el$15 = _el$14.firstChild, _el$17 = _el$15.firstChild;
            insert(_el$15, createComponent(Search, {
              onInput: (e2) => {
                setSearchText(e2.currentTarget.value);
              },
              onFocus: (e2) => {
                e2.currentTarget.scrollIntoView(false);
                setStatusbarColor("#1c96c3");
                setSoftkeys("New chat", "", "tg:more");
              },
              onKeyDown: (e2) => {
                if (e2.key == "SoftLeft") {
                  batch(() => {
                    setPreviousView("home");
                    setView("new_chat");
                  });
                }
              },
              classList: {
                focusable
              },
              placeholder: "Search"
            }), _el$17);
            insert(_el$15, createComponent(Show, {
              get when() {
                return createMemo(() => !!searchText())() && searchResults().length;
              },
              get children() {
                var _el$16 = _tmpl$$h();
                insert(_el$16, createComponent(For, {
                  get each() {
                    return searchResults();
                  },
                  children: (dialog2) => createComponent(DialogItem, {
                    $: dialog2,
                    isSearchResult: true
                  })
                }));
                return _el$16;
              }
            }), _el$17);
            addEventListener(_el$17, "sn-navigatefailed", (e2) => {
              const direction = e2.detail.direction;
              switch (direction) {
                case "down":
                  if (currentSlice() < dialogs$1().length) {
                    setCurrentSlice((e22) => e22 + 20);
                  }
                  break;
                case "right":
                case "left":
                  const filters = dialogFilters();
                  if (!filters.length)
                    break;
                  const current2 = currentTab();
                  if (direction == "right") {
                    if (current2 === null) {
                      setTab(filters[0]);
                    } else {
                      setTab(filters[Math.min(filters.indexOf(current2) + 1, filters.length - 1)]);
                    }
                  } else {
                    if (current2 !== null) {
                      const index = filters.indexOf(current2);
                      if (index)
                        setTab(filters[Math.max(0, index - 1)]);
                      else
                        setTab(null);
                    }
                  }
                  refreshFocusables$1();
                  __CJS__export_default__.focus("dialogs");
                  break;
              }
            });
            insert(_el$17, createComponent(For, {
              get fallback() {
                return (() => {
                  var _el$18 = _tmpl$$h();
                  insert(_el$18, createComponent(ModifyString, {
                    text: "👀"
                  }));
                  return _el$18;
                })();
              },
              get each() {
                return tabFiltered();
              },
              children: (dialog2) => createComponent(DialogItem, {
                $: dialog2
              })
            }));
            createRenderEffect((_p$) => {
              var _v$10 = styles$i.home, _v$11 = styles$i.dialogs, _v$12 = searchText() ? {
                display: "none"
              } : void 0;
              _v$10 !== _p$.e && className(_el$14, _p$.e = _v$10);
              _v$11 !== _p$.t && className(_el$15, _p$.t = _v$11);
              _p$.a = style(_el$17, _v$12, _p$.a);
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0
            });
            return _el$14;
          }
        });
      }
      delegateEvents(["keydown"]);
      const room_wrap = "_room_wrap_163b5_5";
      const info_date = "_info_date_163b5_11";
      const date = "_date_163b5_17";
      const icon$3 = "_icon_163b5_23";
      const upload_image = "_upload_image_163b5_28";
      const caption_softkeys = "_caption_softkeys_163b5_50";
      const emoji$1 = "_emoji_163b5_62";
      const options = "_options_163b5_67";
      const caption_textbox = "_caption_textbox_163b5_87";
      const spinner = "_spinner_163b5_100";
      const view_message_info = "_view_message_info_163b5_111";
      const container$2 = "_container_163b5_120";
      const message_inner = "_message_inner_163b5_125";
      const photo$1 = "_photo_163b5_125";
      const video = "_video_163b5_126";
      const text_container = "_text_container_163b5_138";
      const media_checks = "_media_checks_163b5_146";
      const voice = "_voice_163b5_152";
      const waveform = "_waveform_163b5_159";
      const wavy = "_wavy_163b5_163";
      const wave = "_wave_163b5_159";
      const time$2 = "_time_163b5_175";
      const speed = "_speed_163b5_201";
      const location$1 = "_location_163b5_217";
      const pin = "_pin_163b5_225";
      const thumb$2 = "_thumb_163b5_255";
      const text_wrap = "_text_wrap_163b5_262";
      const gif = "_gif_163b5_266";
      const play = "_play_163b5_267";
      const isReply = "_isReply_163b5_317";
      const header = "_header_163b5_322";
      const avatar = "_avatar_163b5_337";
      const details = "_details_163b5_345";
      const top = "_top_163b5_354";
      const bottom = "_bottom_163b5_355";
      const option_item = "_option_item_163b5_378";
      const room = "_room_163b5_5";
      const message = "_message_163b5_125";
      const action_message = "_action_message_163b5_399";
      const action_message_inner = "_action_message_inner_163b5_419";
      const username = "_username_163b5_445";
      const outgoing = "_outgoing_163b5_448";
      const reply = "_reply_163b5_475";
      const showUsername = "_showUsername_163b5_486";
      const isSticker = "_isSticker_163b5_489";
      const tail = "_tail_163b5_507";
      const text = "_text_163b5_138";
      const more_container = "_more_container_163b5_525";
      const more_fade = "_more_fade_163b5_532";
      const more_button = "_more_button_163b5_536";
      const padTop = "_padTop_163b5_551";
      const username_inner = "_username_inner_163b5_593";
      const reply_border = "_reply_border_163b5_616";
      const reply_details = "_reply_details_163b5_626";
      const reply_username = "_reply_username_163b5_635";
      const reply_text = "_reply_text_163b5_644";
      const textarea_container = "_textarea_container_163b5_652";
      const floating_textbox = "_floating_textbox_163b5_652";
      const focused = "_focused_163b5_656";
      const extra_width = "_extra_width_163b5_660";
      const message_info = "_message_info_163b5_664";
      const edited = "_edited_163b5_670";
      const info_check = "_info_check_163b5_677";
      const sticker = "_sticker_163b5_685";
      const svg = "_svg_163b5_693";
      const styles$d = {
        room_wrap,
        info_date,
        date,
        icon: icon$3,
        upload_image,
        caption_softkeys,
        emoji: emoji$1,
        options,
        caption_textbox,
        spinner,
        view_message_info,
        container: container$2,
        message_inner,
        photo: photo$1,
        video,
        text_container,
        media_checks,
        voice,
        waveform,
        wavy,
        wave,
        time: time$2,
        speed,
        location: location$1,
        pin,
        thumb: thumb$2,
        text_wrap,
        gif,
        play,
        isReply,
        header,
        avatar,
        details,
        top,
        bottom,
        option_item,
        room,
        message,
        action_message,
        action_message_inner,
        username,
        outgoing,
        reply,
        showUsername,
        isSticker,
        tail,
        text,
        more_container,
        more_fade,
        more_button,
        padTop,
        username_inner,
        reply_border,
        reply_details,
        reply_username,
        reply_text,
        textarea_container,
        floating_textbox,
        focused,
        extra_width,
        message_info,
        edited,
        info_check,
        sticker,
        svg
      };
      const container$1 = "_container_1qy9h_2";
      const styles$c = {
        container: container$1
      };
      var _tmpl$$g = /* @__PURE__ */ template(`<div><pre><br>`);
      function AutoResizeTextbox(props) {
        const [local, _props] = splitProps(props, ["onInput", "placeholder"]);
        const [show, setShow] = createSignal(true);
        return (() => {
          var _el$ = _tmpl$$g(), _el$2 = _el$.firstChild;
          _el$2.$$input = (e2) => {
            if (typeof local.onInput == "function") {
              local.onInput(e2);
            }
            const target = e2.currentTarget;
            setShow(!getTextFromContentEditable(target));
          };
          spread(_el$2, mergeProps(_props, {
            "contentEditable": ""
          }), false, true);
          createRenderEffect((_p$) => {
            var _v$ = styles$c.container, _v$2 = props.placeholder && show() ? {
              "--placeholder": `"${props.placeholder}"`
            } : void 0;
            _v$ !== _p$.e && className(_el$, _p$.e = _v$);
            _p$.t = style(_el$, _v$2, _p$.t);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$;
        })();
      }
      delegateEvents(["input"]);
      const content = "_content_ndkpe_1";
      const styles$b = {
        content
      };
      var _tmpl$$f = /* @__PURE__ */ template(`<div>`);
      function OptionsMenuMaxHeight(props) {
        return (() => {
          var _el$ = _tmpl$$f();
          insert(_el$, () => props.children);
          createRenderEffect(() => className(_el$, styles$b.content));
          return _el$;
        })();
      }
      const MENTION_REGEX = /^tg:\/\/user\?id=(\d+)(?:&hash=(-?[0-9a-fA-F]+)(?:&|$)|&|$)/;
      const EMOJI_REGEX = /^tg:\/\/emoji\?id=(-?\d+)/;
      const TAG_BOLD = "**";
      const TAG_ITALIC = "__";
      const TAG_UNDERLINE = "--";
      const TAG_STRIKE = "~~";
      const TAG_SPOILER = "||";
      const TAG_CODE = "`";
      const TAG_PRE = "```";
      const TO_BE_ESCAPED = /[*_\-~`[\\\]|]/g;
      function escape(str) {
        return str.replace(TO_BE_ESCAPED, (s) => `\\${s}`);
      }
      function unparse(input) {
        var _a3;
        if (typeof input === "string")
          return escape(input);
        let text2 = input.text;
        const entities = (_a3 = input.entities) != null ? _a3 : [];
        const escaped = [];
        text2 = text2.replace(TO_BE_ESCAPED, (s, pos) => {
          escaped.push(pos);
          return `\\${s}`;
        });
        const hasEscaped = escaped.length > 0;
        const insert2 = [];
        for(let   entity of entities) {
          const type = entity._;
          let start2 = entity.offset;
          let end = start2 + entity.length;
          if (start2 > text2.length)
            continue;
          if (start2 < 0)
            start2 = 0;
          if (end > text2.length)
            end = text2.length;
          if (hasEscaped) {
            let escapedPos = 0;
            while (escapedPos < escaped.length && escaped[escapedPos] < start2) {
              escapedPos += 1;
            }
            start2 += escapedPos;
            while (escapedPos < escaped.length && escaped[escapedPos] <= end) {
              escapedPos += 1;
            }
            end += escapedPos;
          }
          let startTag;
          let endTag;
          switch (type) {
            case "messageEntityBold":
              startTag = endTag = TAG_BOLD;
              break;
            case "messageEntityItalic":
              startTag = endTag = TAG_ITALIC;
              break;
            case "messageEntityUnderline":
              startTag = endTag = TAG_UNDERLINE;
              break;
            case "messageEntityStrike":
              startTag = endTag = TAG_STRIKE;
              break;
            case "messageEntitySpoiler":
              startTag = endTag = TAG_SPOILER;
              break;
            case "messageEntityCode":
              startTag = endTag = TAG_CODE;
              break;
            case "messageEntityPre":
              startTag = TAG_PRE;
              if (entity.language) {
                startTag += entity.language;
              }
              startTag += "\n";
              endTag = `
${TAG_PRE}`;
              break;
            case "messageEntityTextUrl":
              startTag = "[";
              endTag = `](${entity.url})`;
              break;
            case "messageEntityMentionName":
              startTag = "[";
              endTag = `](tg://user?id=${entity.userId})`;
              break;
            case "messageEntityCustomEmoji":
              startTag = "[";
              endTag = `](tg://emoji?id=${entity.documentId.toString()})`;
              break;
            default:
              continue;
          }
          insert2.push([start2, startTag]);
          insert2.push([end, endTag]);
        }
        insert2.sort((a, b) => b[0] - a[0]);
        for(let   [offset, tag] of insert2) {
          text2 = text2.substr(0, offset) + tag + text2.substr(offset);
        }
        return text2;
      }
      function parse(strings, ...sub) {
        const entities = [];
        let result = "";
        const stacks = {};
        let insideCode = false;
        let insidePre = false;
        let insideLink = false;
        let insideLinkUrl = false;
        let pendingLinkUrl = "";
        function feed(text2) {
          const len = text2.length;
          let pos = 0;
          while (pos < len) {
            const c = text2[pos];
            if (c === "\\") {
              if (insideLinkUrl) {
                pendingLinkUrl += text2[pos + 1];
              } else {
                result += text2[pos + 1];
              }
              pos += 2;
              continue;
            }
            if (insideCode) {
              if (c === "`") {
                const ent = stacks.code.pop();
                ent.length = result.length - ent.offset;
                entities.push(ent);
                insideCode = false;
                pos += 1;
              } else {
                pos += 1;
                result += c;
              }
              continue;
            }
            if (insidePre) {
              if (c === "`" || c === "\n" && text2[pos + 1] === "`") {
                if (c === "\n")
                  pos += 1;
                if (text2[pos + 1] === "`" && text2[pos + 2] === "`") {
                  const ent = stacks.pre.pop();
                  ent.length = result.length - ent.offset;
                  entities.push(ent);
                  insidePre = false;
                  pos += 3;
                  continue;
                } else if (c === "\n") {
                  pos -= 1;
                }
              }
              pos += 1;
              result += c;
              continue;
            }
            if (insideLink && c === "]") {
              const ent = stacks.link.pop();
              if (text2[pos + 1] !== "(") {
                result = `${result.substr(0, ent.offset)}[${result.substr(ent.offset)}]`;
                pos += 1;
                insideLink = false;
                continue;
              }
              pos += 2;
              insideLink = false;
              insideLinkUrl = true;
              stacks.link.push(ent);
              continue;
            }
            if (insideLinkUrl) {
              pos += 1;
              if (c !== ")") {
                pendingLinkUrl += c;
                continue;
              }
              const ent = stacks.link.pop();
              let url2 = pendingLinkUrl;
              pendingLinkUrl = "";
              insideLinkUrl = false;
              if (!url2.length)
                continue;
              ent.length = result.length - ent.offset;
              let m2 = url2.match(MENTION_REGEX);
              if (m2) {
                const userId = Number.parseInt(m2[1]);
                const accessHash = m2[2];
                if (accessHash) {
                  ent._ = "inputMessageEntityMentionName";
                  ent.userId = {
                    _: "inputUser",
                    userId,
                    accessHash: Long.fromString(accessHash, false, 16)
                  };
                } else {
                  ent._ = "messageEntityMentionName";
                  ent.userId = userId;
                }
              } else if (m2 = EMOJI_REGEX.exec(url2)) {
                ent._ = "messageEntityCustomEmoji";
                ent.documentId = Long.fromString(m2[1]);
              } else {
                if (url2.match(/^\/\//))
                  url2 = `http:${url2}`;
                ent._ = "messageEntityTextUrl";
                ent.url = url2;
              }
              entities.push(ent);
              continue;
            }
            if (c === "[" && !insideLink) {
              pos += 1;
              insideLink = true;
              if (!("link" in stacks))
                stacks.link = [];
              stacks.link.push({
                offset: result.length,
                length: 0
              });
              continue;
            }
            if (c === "`") {
              const isPre = text2[pos + 1] === "`" && text2[pos + 2] === "`";
              if (isPre) {
                pos += 3;
                let language = "";
                while (pos < text2.length && text2[pos] !== "\n") {
                  language += text2[pos++];
                }
                pos += 1;
                if (pos > text2.length) {
                  throw new Error("Malformed PRE entity, expected LF after ```");
                }
                if (!("pre" in stacks))
                  stacks.pre = [];
                stacks.pre.push({
                  _: "messageEntityPre",
                  offset: result.length,
                  length: 0,
                  language
                });
                insidePre = true;
              } else {
                pos += 1;
                if (!("code" in stacks))
                  stacks.code = [];
                stacks.code.push({
                  _: "messageEntityCode",
                  offset: result.length,
                  length: 0
                });
                insideCode = true;
              }
              continue;
            }
            if (c === text2[pos + 1]) {
              let type = null;
              switch (c) {
                case "_":
                  type = "Italic";
                  break;
                case "*":
                  type = "Bold";
                  break;
                case "-":
                  type = "Underline";
                  break;
                case "~":
                  type = "Strike";
                  break;
                case "|":
                  type = "Spoiler";
                  break;
              }
              if (type) {
                if (!(type in stacks))
                  stacks[type] = [];
                const isBegin = stacks[type].length === 0;
                if (isBegin) {
                  stacks[type].push({
                    _: `messageEntity${type}`,
                    offset: result.length,
                    length: 0
                  });
                } else {
                  const ent = stacks[type].pop();
                  ent.length = result.length - ent.offset;
                  entities.push(ent);
                }
                pos += 2;
                continue;
              }
            }
            if (c === "\n") {
              if (pos !== 0) {
                result += "\n";
              }
              const nonWhitespace = text2.slice(pos + 1).search(/[^ \t]/);
              if (nonWhitespace !== -1) {
                pos += nonWhitespace + 1;
              } else {
                pos = len;
                result = result.trimEnd();
              }
              continue;
            }
            result += c;
            pos += 1;
          }
        }
        if (typeof strings === "string")
          strings = [strings];
        sub.forEach((it, idx) => {
          feed(strings[idx]);
          if (typeof it === "boolean" || !it)
            return;
          if (insideLinkUrl) {
            if (typeof it === "string" || typeof it === "number") {
              pendingLinkUrl += it;
            } else if (Long.isLong(it)) {
              pendingLinkUrl += it.toString(10);
            } else {
              pendingLinkUrl += it.text;
            }
            return;
          }
          if (typeof it === "string" || typeof it === "number") {
            result += it;
          } else if (Long.isLong(it)) {
            result += it.toString(10);
          } else {
            const text2 = it.text;
            const innerEntities = "raw" in it ? [it.raw] : it.entities;
            const baseOffset = result.length;
            result += text2;
            if (innerEntities) {
              for(let   ent of innerEntities) {
                entities.push(__spreadProps(__spreadValues({}, ent), { offset: ent.offset + baseOffset }));
              }
            }
          }
        });
        feed(strings[strings.length - 1]);
        for(let   [name2, stack] of Object.entries(stacks)) {
          if (stack.length) {
            throw new Error(`Unterminated ${name2} entity`);
          }
        }
        return {
          text: result,
          entities
        };
      }
      const md = exports("dI", Object.assign(parse, {
        escape,
        unparse
      }));
      function WorkerWrapper$1(options2) {
        return new Worker(
          "/assets/heavy-tasks.worker-ChzjhN7l.js",
          {
            name: options2 == null ? void 0 : options2.name
          }
        );
      }
      const wrapped$1 = wrap$4(new WorkerWrapper$1());
      var EmojiCategory = /* @__PURE__ */ ((EmojiCategory2) => {
        EmojiCategory2[EmojiCategory2["Smileys"] = 0] = "Smileys";
        EmojiCategory2[EmojiCategory2["People"] = 1] = "People";
        EmojiCategory2[EmojiCategory2["Animals"] = 2] = "Animals";
        EmojiCategory2[EmojiCategory2["Food"] = 3] = "Food";
        EmojiCategory2[EmojiCategory2["Travel"] = 4] = "Travel";
        EmojiCategory2[EmojiCategory2["Activities"] = 5] = "Activities";
        EmojiCategory2[EmojiCategory2["Objects"] = 6] = "Objects";
        EmojiCategory2[EmojiCategory2["Symbols"] = 7] = "Symbols";
        EmojiCategory2[EmojiCategory2["Flags"] = 8] = "Flags";
        EmojiCategory2[EmojiCategory2["Component"] = 9] = "Component";
        return EmojiCategory2;
      })(EmojiCategory || {});
      const categories$1 = {
        Symbols: 7,
        Activities: 5,
        Flags: 8,
        "Travel & Places": 4,
        "Food & Drink": 3,
        "Animals & Nature": 2,
        "People & Body": 1,
        Objects: 6,
        "Smileys & Emotion": 0
        /* Smileys */
      };
      Object.entries(categories$1).forEach((e2) => {
        categories$1[e2[1]] = e2[0];
      });
      const md5 = wrapped$1.md5;
      const getEmojiPage = wrapped$1.getEmojiPage;
      const getLastEmojiPage = wrapped$1.getLastEmojiPage;
      const getOptimizedSticker = wrapped$1.getOptimizedSticker;
      const taskQueue = new Queue({
        concurrency: 1,
        autostart: true
      });
      function processWebpToCanvas(canvas, bufferLike, width, height) {
        return __async(this, null, function* () {
          console.warn(`WebP: processing webp as device doesn't support Webp natively`);
          const hash = yield md5(bufferLike);
          const filename = "sticker-" + hash;
          const deferred = new Deferred();
          const fromCache = yield new Promise((res) => {
            taskQueue.push(() => __async(this, null, function* () {
              res(getFileFromCache(filename));
              yield deferred.promise;
            }));
          });
          if (fromCache) {
            deferred.resolve();
            return fromCache;
          }
          let result = yield wrapped$1.decodeWebP(bufferLike, 1);
          if (!result) {
            console.error("libwebpjs didn't work, using libwebp asm.js");
            result = yield webp(bufferLike, width, height);
            if (!result) {
              console.error("asm.js libwebp didn't work as well!!!");
              deferred.resolve();
              return null;
            }
          }
          performance.now();
          canvas.width = result.width;
          canvas.height = result.height;
          const imageData = new ImageData(new Uint8ClampedArray(result.rgba), result.width, result.height);
          canvas.getContext("2d").putImageData(imageData, 0, 0);
          canvas.toBlob(
            (blob) => __async(this, null, function* () {
              if (blob) {
                yield addToCache(filename, blob);
                deferred.resolve();
              }
            }),
            "image/png",
            1
          );
          return null;
        });
      }
      const heavyTasks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        EmojiCategory,
        default: processWebpToCanvas,
        getEmojiPage,
        getLastEmojiPage,
        getOptimizedSticker,
        gunzip,
        gzip,
        md5
      }, Symbol.toStringTag, { value: "Module" }));
      exports("dH", heavyTasks);
      const categories = "_categories_wbisi_1";
      const category = "_category_wbisi_10";
      const selected = "_selected_wbisi_25";
      const emojis = "_emojis_wbisi_33";
      const emojiItem = "_emojiItem_wbisi_41";
      const num = "_num_wbisi_56";
      const emoji = "_emoji_wbisi_33";
      const scrollbar = "_scrollbar_wbisi_74";
      const scrollbar_container = "_scrollbar_container_wbisi_82";
      const styles$a = {
        categories,
        category,
        selected,
        emojis,
        emojiItem,
        num,
        emoji,
        scrollbar,
        scrollbar_container
      };
      var _tmpl$$e = /* @__PURE__ */ template(`<svg viewBox="0 0 22 22"><path d="M11 5.7a.7.7 0 00-.7.7V11c0 .216.098.409.251.537.046.048.099.09.16.125l3.983 2.3a.7.7 0 10.7-1.212L11.7 10.617V6.4a.7.7 0 00-.7-.7z"></path><path clip-rule=evenodd d="M11 2a9 9 0 100 18 9 9 0 000-18zm-7.6 9a7.6 7.6 0 1015.2 0 7.6 7.6 0 00-15.2 0z"fill-rule=evenodd>`), _tmpl$2$9 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="M12 22.1C6.4 22.1 1.9 17.6 1.9 12S6.4 1.9 12 1.9 22.1 6.4 22.1 12 17.6 22.1 12 22.1zm0-18.6c-4.7 0-8.5 3.8-8.5 8.5s3.8 8.5 8.5 8.5 8.5-3.8 8.5-8.5-3.8-8.5-8.5-8.5z"></path><path d="M8.9 11.6c.7 0 1.3-.7 1.3-1.5s-.6-1.5-1.3-1.5-1.3.7-1.3 1.5.6 1.5 1.3 1.5zm8.2 2c-1.1.1-3 .4-5 .4s-4-.3-5-.4c-.4 0-.6.3-.4.7 1.1 2 3.1 3.5 5.5 3.5 2.3 0 4.4-1.5 5.5-3.5.1-.3-.2-.7-.6-.7zM12.3 16c-2.6 0-4.1-1-4.2-1.6 0 0 4.4.9 8 0 0 0-.5 1.6-3.8 1.6zm2.8-4.4c.7 0 1.3-.7 1.3-1.5s-.6-1.5-1.3-1.5-1.3.7-1.3 1.5.6 1.5 1.3 1.5z">`), _tmpl$3$5 = /* @__PURE__ */ template(`<svg viewBox="0 -960 960 960"><path d="M360-390q-21 0-35.5-14.5T310-440q0-21 14.5-35.5T360-490q21 0 35.5 14.5T410-440q0 21-14.5 35.5T360-390Zm240 0q-21 0-35.5-14.5T550-440q0-21 14.5-35.5T600-490q21 0 35.5 14.5T650-440q0 21-14.5 35.5T600-390ZM480-160q134 0 227-93t93-227q0-24-3-46.5T786-570q-21 5-42 7.5t-44 2.5q-91 0-172-39T390-708q-32 78-91.5 135.5T160-486v6q0 134 93 227t227 93Zm.07 60q-78.84 0-148.21-29.92t-120.68-81.21q-51.31-51.29-81.25-120.63Q100-401.1 100-479.93q0-78.84 29.92-148.21t81.21-120.68q51.29-51.31 120.63-81.25Q401.1-860 479.93-860q78.84 0 148.21 29.92t120.68 81.21q51.31 51.29 81.25 120.63Q860-558.9 860-480.07q0 78.84-29.92 148.21t-81.21 120.68q-51.29 51.31-120.63 81.25Q558.9-100 480.07-100Zm-72.92-691.15q45.46 83.84 126.12 127.5Q613.92-620 700-620q16.31 0 31.81-1.69t31.42-4.85q-40.08-79.61-116.11-126.54Q571.08-800 480-800q-20.15 0-37.58 2.27-17.42 2.27-35.27 6.58ZM171.23-556.38q56.39-28.23 107.08-82.5Q329-693.15 343.77-769q-65.62 29.77-110.92 85.58-45.31 55.81-61.62 127.04Zm235.92-234.77ZM343.77-769Z">`), _tmpl$4$5 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="M7.2 12.2c.608 0 1.1.627 1.1 1.4S7.808 15 7.2 15s-1.1-.627-1.1-1.4.492-1.4 1.1-1.4zm9.7 0c.608 0 1.1.627 1.1 1.4s-.492 1.4-1.1 1.4-1.1-.627-1.1-1.4.492-1.4 1.1-1.4zm4.6-1.1-1.2-2.4c.9-.4 1.7-1.3 2-2.2.3-.7.4-2.1-1-3.5-1-.9-2-1.2-2.9-1-1.1.3-1.9 1.2-2.3 1.9-1.4-.7-2.9-.8-4.1-.8-1.5 0-2.8.3-4 .9-.5-.9-1.2-1.8-2.3-2.1-1-.2-2 .1-2.9 1-1 1-1.4 2.2-1 3.4.4 1.1 1.2 1.9 2 2.3-.2.5-.4 1-.6 1.6l-.2.2c-.3.7-.5 1.3-.8 1.9-.4 1-.9 1.9-.9 3.1 0 1.6.8 6.7 10.5 6.7 3.8 0 6.6-.7 8.5-2.2s2.2-3.4 2.2-4.3c.2-2.1-.2-2.9-1-4.5zm-2.7-7.6c.4-.1.9.1 1.5.6.6.6.8 1.2.6 1.8-.2.6-.7 1.1-1.2 1.3-.6-1.2-1.3-2-2.1-2.6.2-.4.6-1 1.2-1.1zM3.3 5.9c-.2-.6 0-1.2.6-1.8.5-.5 1.1-.7 1.5-.6.5.1 1.1.7 1.3 1.2-.9.7-1.6 1.5-2.2 2.6C4 7 3.4 6.5 3.3 5.9zm17.8 9.7c0 .7-.2 2-1.6 3.1-1.5 1.2-4.1 1.8-7.5 1.8-8.3 0-8.9-3.9-8.9-5.1 0-.8.3-1.5.7-2.4.3-.6.6-1.2.8-2.1l.1-.2c.5-1.5 2-6.2 7.3-6.2 1.2 0 2.5.2 3.7.9.1.1.5.3.5.3.9.7 1.7 1.7 2.4 3.2.6 1.3 1 2.2 1.4 2.9.8 1.6 1.1 2.1 1.1 3.8zM14.6 17c-.1.1-.6.4-1.2.3-.4-.1-.7-.3-.9-.8 0-.1-.1-.1-.1-.2.8-.1 1.3-.6 1.3-1.3s-.7 0-1.7 0c-.9 0-1.7-.7-1.7 0 0 .6.6 1.2 1.4 1.3l-.1.1c-.3.4-.5.7-.9.8-.5.1-1.1-.1-1.3-.3-.2-.2-.5-.1-.7.1s-.1.5.1.7c.1.1.8.5 1.6.5.2 0 .4 0 .5-.1.4-.1.8-.3 1.1-.7.4.4.9.6 1.2.7.8.2 1.7-.2 2-.5.2-.2.2-.5 0-.7-.1 0-.4-.1-.6.1z">`), _tmpl$5$4 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="M7.4 11.4c-.4 0-.8.4-.8.8V14c0 .4.4.8.8.8s.8-.4.6-.8v-1.8c0-.6-.2-.8-.6-.8zm-2.8-1c-.4 0-.8.4-.8.8V15c0 .4.4.8.8.8s.8-.4.8-.8v-3.8c0-.6-.4-.8-.8-.8z"></path><path d="M23 7.2c-.6-.6-1.6-.8-2.8-.6-.2 0-.4.2-.6.2V4.2c0-.6-.6-1.2-1.2-1.2h-17C.8 3 .2 3.6.2 4.2v7.4c0 5.4 3.2 9.6 8.4 9.6h2.2c4.2 0 7-2.6 8-6h.4c2.2-.4 4-2.6 4.4-4.8.4-1.4.2-2.4-.6-3.2zm-4.8-2.8v3H1.6v-3h16.6zM11 19.8H8.8c-5.2 0-7-4.4-7-8.2V8.8h16.6v2.8c-.2 4-2.4 8.2-7.4 8.2zm8.4-6.2c.2-.6.2-1.4.2-2V8.4c.4-.2.6-.4 1-.4.6-.2 1.2 0 1.4.4.4.4.6 1 .4 1.8-.2 1.4-1.6 3-3 3.4z">`), _tmpl$6$3 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="m14.8 15.3 1.3-3.8c.1-.2 0-.5-.2-.6l-3.3-2.4c-.2-.1-.5-.1-.6 0l-3.3 2.4c-.2.1-.3.4-.2.6l1.3 3.8c.1.2.3.4.5.4h4c.2 0 .4-.2.5-.4z"></path><path d="M12 1.9C6.4 1.9 1.9 6.4 1.9 12S6.4 22.1 12 22.1 22.1 17.6 22.1 12 17.6 1.9 12 1.9zM9.8 20.3c.1-.2.1-.4 0-.6l-1.4-2.3c-.1-.1-.2-.2-.4-.3l-2.5-.6c-.2-.1-.5.1-.6.2-.9-1.3-1.4-2.9-1.5-4.5.2 0 .4 0 .5-.2l1.7-2c.1 0 .2-.2.2-.3l-.3-2.6c0-.2-.1-.3-.3-.4C6.2 5.4 7.5 4.5 9 4c0 .1.2.3.3.3l2.5 1.1c.1.1.3.1.4 0l2.5-1.1.3-.3c1.5.6 2.7 1.5 3.7 2.7-.1.1-.2.2-.2.4l-.2 2.6c0 .2 0 .3.1.4l1.7 2c.1.1.3.2.4.2 0 1.6-.5 3.1-1.3 4.4-.1-.1-.2-.1-.4-.1l-2.5.6c-.1 0-.3.1-.4.3l-1.4 2.3c-.1.2-.1.3 0 .5-.8.2-1.6.4-2.5.4-.7-.1-1.5-.2-2.2-.4z">`), _tmpl$7$3 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="M21.5 11.5c0-.7-.1-1.4-.3-2l-1.5-4.3C19.2 3.9 18 3 16.6 3H7.3c-1.4 0-2.6.9-3.1 2.2L2.6 9.9c-.1.4-.2.7-.2 1.1v8.6c0 .6.5 1.1 1.1 1.1h1.1c.6 0 1.1-.5 1.1-1.1v-1.1h12.7v1.1c0 .6.5 1.1 1.1 1.1h1.1c.6 0 1.1-.5 1.1-1.1v-7.4l-.2-.7zM4.1 10.4l1.6-4.7c.2-.7.9-1.2 1.7-1.2h9.2c.7 0 1.4.5 1.6 1.2l1.5 4.3c.1.3.2.6.2.8H4c-.1-.1 0-.3.1-.4zm1.4 5.7c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5c-.1.8-.7 1.5-1.5 1.5zm9.4-.6H9.3c-.5 0-1-.4-1-1 0-.5.4-1 1-1h5.6c.5 0 1 .4 1 1-.1.6-.5 1-1 1zm3.7.6c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5z">`), _tmpl$8$3 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="M18.8 6.7c-.9-2.6-3.2-4.6-6-4.9h-1.6c-2.8.3-5.1 2.2-6 4.9-1 3 .1 6.2 2.7 8H8c.2.1.3.4.3.6v2c0 .8.6 1.4 1.4 1.4h4.6c.8 0 1.4-.6 1.4-1.4v-2c0-.2.1-.5.3-.6l.1-.1c2.5-1.8 3.6-5 2.7-7.9zm-3.5 6.9-.1.1c-.5.4-.9 1-.9 1.7v2s0 .1-.1.1H9.8s-.1 0-.1-.1v-2c0-.7-.3-1.3-.9-1.7l-.1-.1c-2-1.4-3-4-2.2-6.5.7-2.1 2.6-3.7 4.9-3.9h1.3c2.2.2 4.2 1.8 4.9 3.9.7 2.4-.2 5-2.3 6.5zm-6.1 7.6c0 .6.5 1 1 1h3.7c.6 0 1-.5 1-1v-1H9.2v1z"></path><path d="M13.6 10.5c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3-.2.3-.5.5-.8.5s-.6-.2-.8-.5c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8-.4 0-.8.3-.8.8 0 .4.3.7.7.8.3.4.7.7 1.1.8V15c0 .2.2.4.4.4s.4-.2.4-.4v-2.1c.4-.1.8-.4 1.1-.8.4 0 .8-.3.8-.8s-.3-.8-.7-.8z">`), _tmpl$9$2 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="M14.5 12.9V11h2.2l-.2-1.3h-2V7.3H13v2.5h-2V7.4H9.5v2.4H7.2l.2 1.2h2.1v1.9H7.3l.2 1.3h2v2.4H11v-2.4h2v2.4h1.5v-2.4h2.3l-.2-1.3h-2.1zM11 11h2v1.9h-2V11z"></path><path d="M16.1 2.6H7.9C5 2.6 2.6 5 2.6 7.9V16c0 3 2.4 5.3 5.3 5.3H16c3 0 5.3-2.4 5.3-5.3V7.9c.1-2.9-2.3-5.3-5.2-5.3zm3.7 13.5c0 2.1-1.6 3.8-3.7 3.8H7.9c-2.1 0-3.8-1.7-3.8-3.8V7.9c0-2.1 1.7-3.8 3.8-3.8H16c2.1 0 3.8 1.7 3.8 3.8v8.2z">`), _tmpl$10$2 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"><path d="M5.5 3.8v-.2c0-.3-.2-.5-.5-.5h-.5c-.3 0-.5.2-.5.5V21c0 .3.2.5.5.5H5c.3 0 .5-.2.5-.5v-6.2c5 1.8 9.3-2.7 14.5.6V4.1C14.9 1 10.3 5.6 5.5 3.8zm10.3 8.8c-1.4 0-2.8.3-4.1.6-1.2.3-2.4.5-3.5.5-.9 0-1.8-.2-2.6-.5V5.4c.8.2 1.5.3 2.3.3 1.5 0 2.9-.4 4.3-.7 1.3-.3 2.5-.6 3.8-.6.9 0 1.7.2 2.5.5V13c-.9-.2-1.8-.4-2.7-.4z">`), _tmpl$11$1 = /* @__PURE__ */ template(`<div tabindex=-1>`), _tmpl$12$1 = /* @__PURE__ */ template(`<div tabindex=-1><div></div><div>`), _tmpl$13$1 = /* @__PURE__ */ template(`<div><div>`), _tmpl$14$1 = /* @__PURE__ */ template(`<div><div></div><div>`);
      const recent_icon = _tmpl$$e();
      const icons = {
        [EmojiCategory.Smileys]: _tmpl$2$9(),
        [EmojiCategory.People]: (() => {
          var _el$3 = _tmpl$3$5();
          _el$3.style.setProperty("transform", "scale(1.05)");
          return _el$3;
        })(),
        [EmojiCategory.Animals]: _tmpl$4$5(),
        [EmojiCategory.Food]: _tmpl$5$4(),
        [EmojiCategory.Activities]: _tmpl$6$3(),
        [EmojiCategory.Travel]: _tmpl$7$3(),
        [EmojiCategory.Objects]: _tmpl$8$3(),
        [EmojiCategory.Symbols]: _tmpl$9$2(),
        [EmojiCategory.Flags]: _tmpl$10$2()
      };
      function EmojiCategoryItem(props) {
        let divRef;
        createEffect(() => {
          if (props.selected === props.category) {
            e(divRef, {
              inline: "center",
              block: "center"
            });
          }
        });
        return (() => {
          var _el$11 = _tmpl$11$1();
          addEventListener(_el$11, "sn-navigatefailed", (e2) => {
            const direction = e2.detail.direction;
            if (direction == "down") {
              __CJS__export_default__.focus("emojis");
            }
          });
          _el$11.addEventListener("focus", (e2) => {
            props.setSelected(props.category);
            setSoftkeys("tg:up", "", "tg:down");
          });
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$11) : divRef = _el$11;
          insert(_el$11, createComponent(Show, {
            get when() {
              return props.category !== null;
            },
            fallback: recent_icon,
            get children() {
              return icons[props.category];
            }
          }));
          createRenderEffect((_$p) => classList$1(_el$11, {
            [styles$a.category]: true,
            [styles$a.selected]: props.selected === props.category
          }, _$p));
          return _el$11;
        })();
      }
      function EmojiItem(props) {
        return (() => {
          var _el$12 = _tmpl$12$1(), _el$13 = _el$12.firstChild, _el$14 = _el$13.nextSibling;
          addEventListener(_el$12, "sn-enter-down", () => {
            props.onSelect(props.emoji);
          });
          _el$12.addEventListener("focus", () => {
            setSoftkeys("tg:up", props.emoji ? "SELECT" : "", "tg:down");
          });
          addEventListener(_el$12, "sn-navigatefailed", (e2) => {
            const direction = e2.detail.direction;
            if (direction == "up") {
              __CJS__export_default__.focus("emoji_categories");
            }
          });
          insert(_el$13, createComponent(Show, {
            get when() {
              return props.emoji;
            },
            children: (str) => createComponent(ModifyString, {
              get text() {
                return str();
              }
            })
          }));
          insert(_el$14, () => props.num);
          createRenderEffect((_p$) => {
            var _v$ = styles$a.emojiItem, _v$2 = styles$a.emoji, _v$3 = styles$a.num;
            _v$ !== _p$.e && className(_el$12, _p$.e = _v$);
            _v$2 !== _p$.t && className(_el$13, _p$.t = _v$2);
            _v$3 !== _p$.a && className(_el$14, _p$.a = _v$3);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          return _el$12;
        })();
      }
      const map = {
        "1": 0,
        "2": 1,
        "3": 2,
        "4": 3,
        "5": 4,
        "6": 5,
        "7": 6,
        "8": 7,
        "9": 8,
        "*": 9,
        "0": 10,
        "#": 11
      };
      const indexedKeys = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "*", "0", "#"];
      let EmojiHistory = JSON.parse(localStorage.getItem("EMOJI_HISTORY")) || [];
      function EmojiPicker(props) {
        const [selected2, setSelected] = createSignal(null);
        const [page, setPage] = createSignal(0);
        const [emojis2, setEmojis] = createSignal([]);
        const [lastPage, setLastPage] = createSignal(0);
        function renderFirstPage() {
          const _selected = selected2();
          if (_selected !== null) {
            getEmojiPage(_selected, 0).then((emojis22) => {
              if (emojis22) {
                setEmojis(emojis22);
              }
            });
            getLastEmojiPage(_selected).then((num2) => {
              setLastPage(num2);
            });
          }
        }
        createEffect(() => {
          setPage(0);
          renderFirstPage();
        });
        function tryNextEmoji() {
          const category2 = selected2();
          const nextPage = page() + 1;
          if (category2 !== null) {
            if (nextPage > lastPage()) {
              setPage(0);
              renderFirstPage();
            }
            getEmojiPage(category2, nextPage).then((emojis22) => {
              if (emojis22) {
                setEmojis(emojis22);
                setPage(nextPage);
              } else {
                setPage(0);
                renderFirstPage();
              }
            });
          }
        }
        function tryPreviousEmoji() {
          const category2 = selected2();
          const previousPage = page() - 1;
          if (category2 !== null) {
            if (previousPage == -1) {
              getLastEmojiPage(category2).then((num2) => {
                setPage(num2);
                getEmojiPage(category2, num2).then((emojis22) => {
                  setEmojis(emojis22);
                });
              });
            } else {
              getEmojiPage(category2, previousPage).then((emojis22) => {
                setPage(previousPage);
                setEmojis(emojis22);
              });
            }
          }
        }
        createEffect(() => {
          const category2 = selected2();
          page();
          if (category2 === null) {
            setEmojis(EmojiHistory);
            setLastPage(0);
            return;
          }
        });
        onMount(() => {
          setSoftkeys("tg:up", "", "tg:down");
          __CJS__export_default__.add("emoji_categories", {
            selector: `.${styles$a.category}`,
            restrict: "self-only",
            rememberSource: true,
            defaultElement: `.${styles$a.selected}`
          });
          __CJS__export_default__.add("emojis", {
            selector: `.${styles$a.emojiItem}`,
            restrict: "self-only",
            rememberSource: true
          });
          __CJS__export_default__.focus("emoji_categories");
        });
        onCleanup(() => {
          __CJS__export_default__.remove("emoji_categories");
          __CJS__export_default__.remove("emojis");
        });
        return createComponent(Options, {
          onClose: () => {
            props.onSelect(null);
          },
          title: "",
          maxHeight: null,
          get children() {
            var _el$15 = _tmpl$14$1(), _el$16 = _el$15.firstChild, _el$17 = _el$16.nextSibling;
            _el$15.$$keydown = (e2) => {
              if (e2.key == "SoftRight") {
                tryNextEmoji();
              }
              if (e2.key == "SoftLeft") {
                tryPreviousEmoji();
              }
              if (typeof map[e2.key] == "number") {
                const result = emojis2()[map[e2.key]];
                if (result) {
                  props.onSelect(result);
                }
              }
            };
            _el$15.style.setProperty("position", "fixed");
            _el$15.style.setProperty("bottom", "30px");
            addEventListener(_el$16, "sn-navigatefailed", (e2) => {
              const direction = e2.detail.direction;
              if (direction == "up") {
                tryPreviousEmoji();
              }
            });
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              category: null
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Smileys;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.People;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Animals;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Food;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Activities;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Travel;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Objects;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Symbols;
              }
            }), null);
            insert(_el$16, createComponent(EmojiCategoryItem, {
              setSelected,
              get selected() {
                return selected2();
              },
              get category() {
                return EmojiCategory.Flags;
              }
            }), null);
            addEventListener(_el$17, "sn-navigatefailed", (e2) => {
              const direction = e2.detail.direction;
              if (direction == "down") {
                tryNextEmoji();
              }
              if (direction == "right") {
                setSelected((e22) => {
                  if (e22 == 8)
                    return null;
                  if (e22 === null)
                    return 0;
                  return Math.min(8, e22 + 1);
                });
              }
              if (direction == "left") {
                setSelected((e22) => {
                  if (e22 == 0)
                    return null;
                  if (e22 === null)
                    return 8;
                  return Math.max(0, e22 - 1);
                });
              }
            });
            insert(_el$17, createComponent(Index, {
              each: indexedKeys,
              children: (num2, index) => createComponent(EmojiItem, {
                get onSelect() {
                  return props.onSelect;
                },
                get emoji() {
                  return emojis2()[index];
                },
                get num() {
                  return num2();
                }
              })
            }));
            insert(_el$15, createComponent(Show, {
              get when() {
                return lastPage() != 0;
              },
              get children() {
                var _el$18 = _tmpl$13$1(), _el$19 = _el$18.firstChild;
                createRenderEffect((_p$) => {
                  var _v$4 = styles$a.scrollbar_container, _v$5 = 1 / (lastPage() + 1) * 100 + "%", _v$6 = page() / (lastPage() + 1) * 100 + "%", _v$7 = styles$a.scrollbar;
                  _v$4 !== _p$.e && className(_el$18, _p$.e = _v$4);
                  _v$5 !== _p$.t && ((_p$.t = _v$5) != null ? _el$19.style.setProperty("height", _v$5) : _el$19.style.removeProperty("height"));
                  _v$6 !== _p$.a && ((_p$.a = _v$6) != null ? _el$19.style.setProperty("top", _v$6) : _el$19.style.removeProperty("top"));
                  _v$7 !== _p$.o && className(_el$19, _p$.o = _v$7);
                  return _p$;
                }, {
                  e: void 0,
                  t: void 0,
                  a: void 0,
                  o: void 0
                });
                return _el$18;
              }
            }), null);
            createRenderEffect((_p$) => {
              var _v$8 = styles$a.categories, _v$9 = styles$a.emojis;
              _v$8 !== _p$.e && className(_el$16, _p$.e = _v$8);
              _v$9 !== _p$.t && className(_el$17, _p$.t = _v$9);
              return _p$;
            }, {
              e: void 0,
              t: void 0
            });
            return _el$15;
          }
        });
      }
      delegateEvents(["keydown"]);
      const grid = "_grid_aelli_1";
      const gridItem = "_gridItem_aelli_9";
      const icon$2 = "_icon_aelli_21";
      const icon_container = "_icon_container_aelli_33";
      const iconText = "_iconText_aelli_44";
      const styles$9 = {
        grid,
        gridItem,
        icon: icon$2,
        icon_container,
        iconText
      };
      var _tmpl$$d = /* @__PURE__ */ template(`<div tabindex=-1><div><div></div></div><div>`), _tmpl$2$8 = /* @__PURE__ */ template(`<div>`);
      var InsertMenuSelected = /* @__PURE__ */ ((InsertMenuSelected2) => {
        InsertMenuSelected2[InsertMenuSelected2["EMOJI"] = 0] = "EMOJI";
        InsertMenuSelected2[InsertMenuSelected2["PHOTO"] = 1] = "PHOTO";
        InsertMenuSelected2[InsertMenuSelected2["VIDEO"] = 2] = "VIDEO";
        InsertMenuSelected2[InsertMenuSelected2["GIF"] = 3] = "GIF";
        InsertMenuSelected2[InsertMenuSelected2["CONTACTS"] = 4] = "CONTACTS";
        InsertMenuSelected2[InsertMenuSelected2["AUDIO"] = 5] = "AUDIO";
        InsertMenuSelected2[InsertMenuSelected2["LOCATION"] = 6] = "LOCATION";
        InsertMenuSelected2[InsertMenuSelected2["VOICE"] = 7] = "VOICE";
        return InsertMenuSelected2;
      })(InsertMenuSelected || {});
      function GridItem(props) {
        return (() => {
          var _el$ = _tmpl$$d(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$2.nextSibling;
          _el$.addEventListener("focus", () => {
            setSoftkeys("Cancel", props.name, "");
          });
          addEventListener(_el$, "sn-enter-down", () => {
            sleep$1(10).then(() => props.onSelect(props.value));
          });
          insert(_el$3, () => props.icon);
          insert(_el$4, () => props.name);
          createRenderEffect((_p$) => {
            var _v$ = styles$9.gridItem, _v$2 = styles$9.icon, _v$3 = props.color, _v$4 = styles$9.icon_container, _v$5 = styles$9.iconText;
            _v$ !== _p$.e && className(_el$, _p$.e = _v$);
            _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
            _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$2.style.setProperty("background-color", _v$3) : _el$2.style.removeProperty("background-color"));
            _v$4 !== _p$.o && className(_el$3, _p$.o = _v$4);
            _v$5 !== _p$.i && className(_el$4, _p$.i = _v$5);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0
          });
          return _el$;
        })();
      }
      function InsertMenu(props) {
        onMount(() => {
          __CJS__export_default__.add("insertMenu", {
            selector: `.${styles$9.gridItem}`,
            restrict: "self-only"
          });
          __CJS__export_default__.focus("insertMenu");
        });
        onCleanup(() => {
          __CJS__export_default__.remove("insertMenu");
        });
        return createComponent(Options, {
          onClose: () => {
            sleep$1(10).then(() => props.onSelect(null));
          },
          maxHeight: null,
          get children() {
            var _el$5 = _tmpl$2$8();
            _el$5.$$keydown = (e2) => {
              if (e2.key == "SoftLeft") {
                sleep$1(10).then(() => props.onSelect(null));
              }
            };
            insert(_el$5, createComponent(GridItem, {
              get value() {
                return 0;
              },
              get onSelect() {
                return props.onSelect;
              },
              get icon() {
                return createComponent(TelegramIcon, {
                  name: "smile"
                });
              },
              color: "#f7aa21",
              name: "Emoji"
            }), null);
            insert(_el$5, createComponent(GridItem, {
              get value() {
                return 1;
              },
              get onSelect() {
                return props.onSelect;
              },
              get icon() {
                return createComponent(TelegramIcon, {
                  name: "camera"
                });
              },
              color: "#e62d73",
              name: "Photo"
            }), null);
            insert(_el$5, createComponent(GridItem, {
              get value() {
                return 2;
              },
              get onSelect() {
                return props.onSelect;
              },
              get icon() {
                return createComponent(TelegramIcon, {
                  name: "videocamera"
                });
              },
              color: "#5f33ea",
              name: "Video"
            }), null);
            insert(_el$5, createComponent(GridItem, {
              get value() {
                return 7;
              },
              get onSelect() {
                return props.onSelect;
              },
              get icon() {
                return createComponent(TelegramIcon, {
                  name: "microphone_filled"
                });
              },
              color: "#ff57d5",
              name: "Voice Message"
            }), null);
            createRenderEffect(() => className(_el$5, styles$9.grid));
            return _el$5;
          }
        });
      }
      delegateEvents(["keydown"]);
      function PeerPhotoIcon(props) {
        return createComponent(ChatPhotoIcon, {
          get showSavedIcon() {
            return props.showSavedIcon;
          },
          get chat() {
            return props.peer;
          }
        });
      }
      const you_spin_me_right_round_baby_right_round = "_you_spin_me_right_round_baby_right_round_2iuvj_6";
      const path = "_path_2iuvj_14";
      const spinner_container = "_spinner_container_2iuvj_22";
      const styles$8 = {
        you_spin_me_right_round_baby_right_round,
        path,
        spinner_container
      };
      var _tmpl$$c = /* @__PURE__ */ template(`<div><div><div><svg xmlns=http://www.w3.org/2000/svg viewBox="27 27 54 54"><circle cx=54 cy=54 r=24 fill=rgba(0,0,0,0) stroke-miterlimit=10></circle></svg></div><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"><g fill=none fill-rule=evenodd><polygon points="0 0 24 0 24 24 0 24"></polygon><path fill=currentColor fill-rule=nonzero d="M5.20970461,5.38710056 L5.29289322,5.29289322 C5.65337718,4.93240926 6.22060824,4.90467972 6.61289944,5.20970461 L6.70710678,5.29289322 L12,10.585 L17.2928932,5.29289322 C17.6834175,4.90236893 18.3165825,4.90236893 18.7071068,5.29289322 C19.0976311,5.68341751 19.0976311,6.31658249 18.7071068,6.70710678 L13.415,12 L18.7071068,17.2928932 C19.0675907,17.6533772 19.0953203,18.2206082 18.7902954,18.6128994 L18.7071068,18.7071068 C18.3466228,19.0675907 17.7793918,19.0953203 17.3871006,18.7902954 L17.2928932,18.7071068 L12,13.415 L6.70710678,18.7071068 C6.31658249,19.0976311 5.68341751,19.0976311 5.29289322,18.7071068 C4.90236893,18.3165825 4.90236893,17.6834175 5.29289322,17.2928932 L10.585,12 L5.29289322,6.70710678 C4.93240926,6.34662282 4.90467972,5.77939176 5.20970461,5.38710056 L5.29289322,5.29289322 L5.20970461,5.38710056 Z">`);
      function ProgressSpinner(props) {
        const [local, rest] = splitProps(props, ["progress", "size", "showClose"]);
        return (() => {
          var _el$ = _tmpl$$c(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild;
          spread(_el$, rest, false, true);
          createRenderEffect((_p$) => {
            var _v$ = props.size + "px", _v$2 = props.size + "px", _v$3 = styles$8.spinner_container, _v$4 = styles$8.you_spin_me_right_round_baby_right_round, _v$5 = styles$8.path, _v$6 = `stroke-dasharray: ${149.825 * (local.progress / 100)}px, 149.825px;`;
            _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$2.style.setProperty("width", _v$) : _el$2.style.removeProperty("width"));
            _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$2.style.setProperty("height", _v$2) : _el$2.style.removeProperty("height"));
            _v$3 !== _p$.a && className(_el$2, _p$.a = _v$3);
            _v$4 !== _p$.o && className(_el$3, _p$.o = _v$4);
            _v$5 !== _p$.i && setAttribute(_el$5, "class", _p$.i = _v$5);
            _p$.n = style(_el$5, _v$6, _p$.n);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0,
            n: void 0
          });
          return _el$;
        })();
      }
      function WorkerWrapper(options2) {
        return new Worker(
          "/assets/worker-CjdOwrSf.js",
          {
            name: options2 == null ? void 0 : options2.name
          }
        );
      }
      const wrapped = wrap$4(new WorkerWrapper());
      const rLottieLoaded = wrapped.loadRlottie();
      function loadRlottie() {
        return rLottieLoaded;
      }
      const queue = new Queue({
        concurrency: 1,
        autostart: true
      });
      function isCached(id2) {
        return new Promise((res) => {
          queue.push(() => __async(this, null, function* () {
            const cached2 = yield wrapped.isCached(id2);
            yield sleep$1(0);
            res(cached2);
          }));
        });
      }
      function loadAnimation(id2, data2) {
        return new Promise((res) => {
          queue.push(() => __async(this, null, function* () {
            const frames = yield wrapped.loadAnimation(id2, data2);
            console.error("FRAMES LOADED FROM LOAD ANIMATION!!", frames);
            yield sleep$1(0);
            res(frames);
          }));
        });
      }
      function requestFrame(id2, frame, width, height) {
        return new Promise((res) => {
          queue.push(() => __async(this, null, function* () {
            const clamped = yield wrapped.requestFrame(id2, frame, width, height);
            yield sleep$1(0);
            res(clamped);
          }));
        });
      }
      var _tmpl$$b = /* @__PURE__ */ template(`<div><svg version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path fill="rgba(0, 0, 0, 0.08)">`), _tmpl$2$7 = /* @__PURE__ */ template(`<canvas width=128 height=128>`), _tmpl$3$4 = /* @__PURE__ */ template(`<img alt=" ">`), _tmpl$4$4 = /* @__PURE__ */ template(`<canvas class=EEE width=128 height=128>`), _tmpl$5$3 = /* @__PURE__ */ template(`<div>`), _tmpl$6$2 = /* @__PURE__ */ template(`<video loop>`), _tmpl$7$2 = /* @__PURE__ */ template(`<img width=128>`), _tmpl$8$2 = /* @__PURE__ */ template(`<img>`), _tmpl$9$1 = /* @__PURE__ */ template(`<div><div>`), _tmpl$10$1 = /* @__PURE__ */ template(`<div>GIF`), _tmpl$11 = /* @__PURE__ */ template(`<div><svg viewBox="0 0 20 20"class=MX><path d="M4 3.1v13.8c0 .9 1 1.5 1.8 1 3.1-1.7 9.4-5.2 12.5-6.9.8-.5.8-1.6 0-2.1L5.8 2C5 1.6 4 2.2 4 3.1z">`), _tmpl$12 = /* @__PURE__ */ template(`<div><svg viewBox="0 0 18 18"class=PL><path d="M13.518 7.626v-2.82a.72.72 0 00-.247-.583.905.905 0 00-.65-.222H1.9a.905.905 0 00-.651.222.72.72 0 00-.247.584v8.386a.72.72 0 00.247.584.905.905 0 00.651.222h10.72a.905.905 0 00.65-.222.72.72 0 00.247-.584v-2.82l.1.09 2.613 2.44a.49.49 0 00.49.088.408.408 0 00.28-.372V5.382a.407.407 0 00-.279-.374.49.49 0 00-.492.089l-2.591 2.421-.122.109h.002z"fill-rule=evenodd>`), _tmpl$13 = /* @__PURE__ */ template(`<video autoplay loop>`), _tmpl$14 = /* @__PURE__ */ template(`<div>x`), _tmpl$15 = /* @__PURE__ */ template(`<div><div><svg height=18 width=18 viewBox="0 0 20 20"><path></path></svg></div><div><div></div><div></div></div><div>`), _tmpl$16 = /* @__PURE__ */ template(`<audio>`), _tmpl$17 = /* @__PURE__ */ template(`<div>Unsupported Media Type: `);
      function toMidnight(date2) {
        return date2.set("hour", 0).set("minute", 0).set("second", 0);
      }
      function today() {
        return toMidnight(dayjs());
      }
      function decideDateSepatator(dateBefore, dateAfter) {
        if (!dateBefore)
          return true;
        const day1 = toMidnight(dayjs(dateBefore));
        const day2 = toMidnight(dayjs(dateAfter));
        const diff = Math.abs(day1.diff(day2, "day"));
        if (diff > 0) {
          const diffToday = today().diff(day2, "day");
          if (diffToday === 1)
            return 1;
          if (diffToday === 0)
            return 2;
          return true;
        }
        return false;
      }
      function decideTail(before, after) {
        if (!before)
          return true;
        const hasDateSeparator = decideDateSepatator(before.date, after.date);
        if (hasDateSeparator)
          return true;
        const chat2 = before.$.chat;
        if (chat2.chatType === "channel") {
          return true;
        }
        if (before.sender.id !== after.sender.id) {
          return true;
        }
        const day1 = dayjs(before.date);
        const day2 = dayjs(after.date);
        const minuteDiff = Math.abs(day1.diff(day2, "minutes"));
        if (minuteDiff > 0) {
          return true;
        }
        return false;
      }
      function decideShowUsername(before, after) {
        const chat2 = after.$.chat;
        if (
          // broadcast groups don't seem to show who sent messages?? idk
          chat2.chatType === "channel" || chat2.chatType === "private" || after.isOutgoing
        ) {
          return false;
        }
        return decideTail(before, after);
      }
      const MessageContext = createContext();
      function MessageProvider(props) {
        const tg = client();
        if (!tg)
          throw new Error("CLIENT NOT READY");
        const [focused2, setFocused] = createSignal(false);
        const [reply2] = createResource(() => __async(this, null, function* () {
          const _ = props.$.isReply();
          if (_) {
            const msg = yield props.$.getReply(props.dialog);
            return msg != null ? msg : 0;
          } else {
            return void 0;
          }
        }));
        const text2 = useStore(() => props.$.text);
        const entities = useStore(() => props.$.entities);
        const mediaType = createMemo(() => {
          var _a3;
          return (_a3 = props.$.$.media) == null ? void 0 : _a3.type;
        });
        const showChecks = createMemo(() => props.$.isOutgoing && !(entities().entities || entities().text));
        const showTail = createMemo(() => decideTail(props.before, props.$));
        const showUsername2 = createMemo(() => decideShowUsername(props.before, props.$));
        const showContainerTail = createMemo(() => props.$.isSticker ? props.$.isReply() ? showTail() : false : showTail());
        const actionType = () => {
          var _a3;
          return (_a3 = props.$.$.action) == null ? void 0 : _a3.type;
        };
        const showDateSeparator = createMemo(() => {
          var _a3;
          return decideDateSepatator((_a3 = props.before) == null ? void 0 : _a3.date, props.$.date);
        });
        const [audioPlaying, setAudioPlaying] = createSignal(false);
        const [audioSpeed, setAudioSpeed] = createSignal(1);
        return createComponent(MessageContext.Provider, {
          value: {
            tg,
            audioSpeed,
            setAudioSpeed,
            audioPlaying,
            setAudioPlaying,
            actionType,
            media: () => props.$.$.media,
            action: () => props.$.$.action,
            focused: focused2,
            setFocused,
            reply: reply2,
            text: text2,
            entities,
            mediaType,
            showChecks,
            showTail,
            showUsername: showUsername2,
            showContainerTail,
            showDateSeparator,
            dialog: () => props.dialog,
            last: () => {
              var _a3;
              return props.last && ((_a3 = chat()) == null ? void 0 : _a3.chatType) == "channel";
            },
            actualLast: () => props.last,
            isOutgoing: () => props.$.isOutgoing,
            rawMessage: () => props.$.$,
            message: () => props.$,
            isSticker: () => props.$.isSticker,
            isReply: () => props.$.isReply()
          },
          get children() {
            return props.children;
          }
        });
      }
      function useMessageContext() {
        return useContext(MessageContext);
      }
      function StickerThumbnail() {
        const {
          media: media2
        } = useMessageContext();
        const thumbnail = createMemo(() => media2().getThumbnail(Thumbnail.THUMB_OUTLINE));
        const photoSize = createMemo(() => media2().attr2);
        return createComponent(Show, {
          get when() {
            return thumbnail();
          },
          get children() {
            var _el$ = _tmpl$$b(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;
            createRenderEffect((_p$) => {
              var _a3, _b2;
              var _v$ = styles$d.svg, _v$2 = `0 0 ${((_a3 = photoSize()) == null ? void 0 : _a3.w) || 512} ${((_b2 = photoSize()) == null ? void 0 : _b2.h) || 512}`, _v$3 = thumbnail().path;
              _v$ !== _p$.e && className(_el$, _p$.e = _v$);
              _v$2 !== _p$.t && setAttribute(_el$2, "viewBox", _p$.t = _v$2);
              _v$3 !== _p$.a && setAttribute(_el$3, "d", _p$.a = _v$3);
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0
            });
            return _el$;
          }
        });
      }
      function StickerRlottieFirstFrame(props) {
        let canvasRef;
        onMount(() => {
          const context = canvasRef.getContext("2d");
          context.putImageData(props.data, 0, 0);
        });
        return (() => {
          var _el$4 = _tmpl$2$7();
          var _ref$ = canvasRef;
          typeof _ref$ === "function" ? use(_ref$, _el$4) : canvasRef = _el$4;
          return _el$4;
        })();
      }
      function StickerRlottieFirstFrameWebp() {
        let canvasRef;
        const {
          message: message2,
          focused: focused2,
          media: media2
        } = useMessageContext();
        let mounted = true;
        const [src, setSrc] = createSignal("");
        const [loading2, setLoading] = createSignal(true);
        onCleanup(() => {
          mounted = false;
        });
        onMount(() => {
          const media22 = message2().$.media;
          if (!media22)
            return;
          if (media22.mimeType != "application/x-tgsticker")
            return;
          const file2 = media22.getThumbnail("m");
          if (!file2)
            return;
          const download = downloadFile(file2);
          let url2;
          const stateChange = () => __async(this, null, function* () {
            if (download.state == "done") {
              if (mounted) {
                const buffer = yield download.result.arrayBuffer();
                processWebpToCanvas(canvasRef, new Uint8Array(buffer), media22.width, media22.height).then((res) => {
                  if (res != null) {
                    setSrc(url2 = URL.createObjectURL(res));
                  } else {
                    setLoading(false);
                  }
                });
              }
            }
          });
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          download.on("state", stateChange);
          onCleanup(() => {
            download.off("state", stateChange);
            URL.revokeObjectURL(url2);
          });
        });
        return [(() => {
          var _el$5 = _tmpl$2$7();
          var _ref$2 = canvasRef;
          typeof _ref$2 === "function" ? use(_ref$2, _el$5) : canvasRef = _el$5;
          return _el$5;
        })(), createComponent(Show, {
          get when() {
            return src();
          },
          get children() {
            var _el$6 = _tmpl$3$4();
            createRenderEffect(() => setAttribute(_el$6, "src", src()));
            return _el$6;
          }
        }), createComponent(Show, {
          get when() {
            return loading2();
          },
          get children() {
            return createComponent(StickerThumbnail, {});
          }
        })];
      }
      const decoder = new TextDecoder();
      const fps = 60;
      const frameDuration = 1e3 / fps;
      function StickerMedia(props) {
        const {
          message: message2,
          focused: focused2,
          media: media2
        } = useMessageContext();
        let canvasRef;
        const [src, setSrc] = createSignal("");
        const [video2, setVideo] = createSignal("");
        const [loading2, setLoading] = createSignal(true);
        const [rlottie, setRlottie] = createSignal(false);
        const [rlottieCanvasRef, setRlottieCanvasRef] = createSignal(null);
        const [videoRef, setVideoRef] = createSignal(null);
        const [rLottieData, setRlottieData] = createSignal("");
        const [rLottieReady, setRlottieReady] = createSignal(false);
        const [rLottieFirstFrame, setRlottieFirstFrame] = createSignal(null);
        createEffect(() => {
          const videoEl = videoRef();
          const _focused = focused2();
          if (!videoEl)
            return;
          if (_focused) {
            videoEl.play();
          } else {
            videoEl.pause();
            videoEl.currentTime = 0;
          }
        });
        let frames = 0;
        let currentFrame = 0;
        createEffect(() => {
          const ready = rLottieReady();
          const isFocused = focused2();
          const canvas = rlottieCanvasRef();
          const id2 = media2().uniqueFileId;
          if (!ready)
            return;
          if (!isFocused)
            return;
          if (!canvas)
            return;
          const context = canvas.getContext("2d");
          let destroyed = false;
          let animFrame;
          let timeout;
          let startTime;
          function tick_cb(timestamp) {
            return __async(this, null, function* () {
              if (destroyed)
                return;
              if (!startTime)
                startTime = timestamp;
              const elapsed = timestamp - startTime;
              const frameIndex = Math.floor(elapsed / frameDuration);
              if (frameIndex !== currentFrame) {
                currentFrame = frameIndex % frames;
                if (currentFrame >= frames)
                  currentFrame = 0;
                const clampedBuffer = yield requestFrame(id2, currentFrame, 128, 128);
                const imageData = new ImageData(clampedBuffer, 128, 128);
                context.putImageData(imageData, 0, 0);
              }
              animFrame = requestAnimationFrame((e2) => {
                tick_cb(e2);
              });
            });
          }
          animFrame = requestAnimationFrame((e2) => {
            tick_cb(e2);
          });
          onCleanup(() => {
            destroyed = true;
            clearTimeout(timeout);
            cancelAnimationFrame(animFrame);
            currentFrame = 0;
          });
        });
        createEffect(() => __async(this, null, function* () {
          const isRlottie = rlottie();
          const canvas = rlottieCanvasRef();
          const data2 = rLottieData();
          const sticker2 = media2();
          if (!isRlottie)
            return;
          if (!canvas)
            return;
          if (!data2)
            return;
          yield loadRlottie();
          const cached2 = yield isCached(sticker2.uniqueFileId);
          if (cached2 === false) {
            frames = yield loadAnimation(sticker2.uniqueFileId, data2);
          } else {
            frames = cached2;
          }
          const clampedBuffer = yield requestFrame(sticker2.uniqueFileId, 0, 128, 128);
          const imageData = new ImageData(clampedBuffer, 128, 128);
          setRlottieFirstFrame(imageData);
          setRlottieReady(true);
        }));
        createEffect(() => {
          const isRlottie = rlottie();
          if (!isRlottie)
            return;
          const media22 = message2().$.media;
          if (media22.mimeType != "application/x-tgsticker")
            return;
          const download = downloadFile(media22);
          let url2;
          function stateChange() {
            return __async(this, null, function* () {
              if (download.state == "done") {
                if (mounted) {
                  const data2 = yield gunzip(new Uint8Array(yield download.result.arrayBuffer()));
                  if (!mounted)
                    return;
                  setRlottieData(decoder.decode(data2));
                }
              }
            });
          }
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          download.on("state", stateChange);
          onCleanup(() => {
            download.off("state", stateChange);
            URL.revokeObjectURL(url2);
          });
        });
        let mounted = true;
        onCleanup(() => {
          setVideoRef(null);
          mounted = false;
        });
        onMount(() => {
          const media22 = message2().$.media;
          if (!media22)
            return;
          if (media22.type !== "sticker")
            return;
          if (media22.mimeType.includes("webm")) {
            let stateChange = function() {
              if (download.state == "done") {
                if (mounted) {
                  setVideo(url2 = URL.createObjectURL(download.result));
                }
              }
            };
            const download = downloadFile(media22);
            let url2;
            if (download.state == "done") {
              stateChange();
              onCleanup(() => {
                URL.revokeObjectURL(url2);
              });
              return;
            }
            download.on("state", stateChange);
            onCleanup(() => {
              download.off("state", stateChange);
              URL.revokeObjectURL(url2);
            });
            return;
          }
          if (media22.mimeType.includes("webp"))
            return;
          if (media22.hasStickerSet) {
            console.error("non-webp sticker set", media22.mimeType, media22.emoji, media22.uniqueFileId);
            getOptimizedSticker(media22.uniqueFileId).then((hasPrecompiled) => {
              if (hasPrecompiled) {
                setSrc(hasPrecompiled);
              } else {
                setRlottie(true);
              }
            });
          }
        });
        onMount(() => {
          const media22 = message2().$.media;
          if (!media22)
            return;
          if (media22.type !== "sticker")
            return;
          if (!media22.mimeType.includes("webp"))
            return;
          const file2 = media22.getThumbnail("x") || media22;
          const download = downloadFile(file2);
          let url2;
          const stateChange = () => __async(this, null, function* () {
            if (download.state == "done") {
              if (mounted) {
                const buffer = yield download.result.arrayBuffer();
                processWebpToCanvas(canvasRef, new Uint8Array(buffer), media22.width, media22.height).then((res) => {
                  if (res != null) {
                    setSrc(url2 = URL.createObjectURL(res));
                  } else {
                    setLoading(false);
                  }
                });
              }
            }
          });
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          download.on("state", stateChange);
          onCleanup(() => {
            download.off("state", stateChange);
            URL.revokeObjectURL(url2);
          });
        });
        return (() => {
          var _el$7 = _tmpl$5$3();
          insert(_el$7, createComponent(Show, {
            get when() {
              return rlottie();
            },
            get fallback() {
              return createComponent(Show, {
                get when() {
                  return video2();
                },
                get fallback() {
                  return [createComponent(Show, {
                    get when() {
                      return loading2();
                    },
                    get children() {
                      return createComponent(StickerThumbnail, {});
                    }
                  }), createComponent(Show, {
                    get when() {
                      return src();
                    },
                    get fallback() {
                      return (() => {
                        var _el$10 = _tmpl$2$7();
                        var _ref$3 = canvasRef;
                        typeof _ref$3 === "function" ? use(_ref$3, _el$10) : canvasRef = _el$10;
                        return _el$10;
                      })();
                    },
                    children: (src2) => (() => {
                      var _el$11 = _tmpl$7$2();
                      _el$11.addEventListener("error", (e2) => {
                        console.error("ERROR OCCURED STICKER", e2.currentTarget);
                      });
                      _el$11.addEventListener("load", () => {
                        setLoading(false);
                      });
                      createRenderEffect(() => setAttribute(_el$11, "src", src2() + "#-moz-samplesize=2"));
                      return _el$11;
                    })()
                  })];
                },
                get children() {
                  var _el$9 = _tmpl$6$2();
                  _el$9.addEventListener("error", (e2) => {
                    var _a3;
                    const err = ["Unknown", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED"][((_a3 = e2.currentTarget.error) == null ? void 0 : _a3.code) || 0];
                    console.error("VIDEO ERROR", err, e2.target);
                  });
                  use(setVideoRef, _el$9);
                  createRenderEffect(() => setAttribute(_el$9, "src", video2()));
                  return _el$9;
                }
              });
            },
            get children() {
              return [createComponent(Show, {
                get when() {
                  return !focused2();
                },
                get children() {
                  return createComponent(Show, {
                    get when() {
                      return rLottieFirstFrame();
                    },
                    get fallback() {
                      return createComponent(StickerRlottieFirstFrameWebp, {});
                    },
                    children: (d) => createComponent(StickerRlottieFirstFrame, {
                      get data() {
                        return d();
                      }
                    })
                  });
                }
              }), createComponent(Show, {
                get when() {
                  return focused2();
                },
                get children() {
                  var _el$8 = _tmpl$4$4();
                  use(setRlottieCanvasRef, _el$8);
                  return _el$8;
                }
              })];
            }
          }));
          createRenderEffect(() => className(_el$7, styles$d.sticker));
          return _el$7;
        })();
      }
      function PhotoMedia(props) {
        const {
          message: message2,
          showChecks
        } = useMessageContext();
        const [src, setSrc] = createSignal("");
        const [loading2, setLoading] = createSignal(true);
        const [showUnsupported, setShowUnsupported] = createSignal(false);
        const [thumb2, setThumb] = createSignal("");
        const [progress2, setProgress] = createSignal(0);
        let mounted = true;
        onCleanup(() => {
          mounted = false;
        });
        onMount(() => {
          const media2 = message2().$.media;
          const thumb22 = media2.getThumbnail(Thumbnail.THUMB_STRIP);
          let url2;
          if (thumb22 && "byteLength" in thumb22.location) {
            setThumb(url2 = URL.createObjectURL(new Blob([thumb22.location])));
          }
          onCleanup(() => {
            URL.revokeObjectURL(url2);
          });
        });
        onMount(() => {
          var _a3, _b2;
          const media2 = message2().$.media;
          (_a3 = props.mediaRef) == null ? void 0 : _a3.call(props, media2);
          const thumb22 = media2.getThumbnail(Thumbnail.THUMB_320x320_BOX);
          if (!thumb22) {
            console.error("THUMB M IS NOT PRESENT, SKIPPING");
            return;
          }
          const download = downloadFile(thumb22);
          (_b2 = props.downloadRef) == null ? void 0 : _b2.call(props, download);
          let url2;
          const stateChange = () => {
            if (download.state == "done") {
              if (mounted) {
                setLoading(false);
                setSrc(url2 = URL.createObjectURL(download.result));
              }
            }
          };
          if (download.state == "done") {
            stateChange();
            setProgress(100);
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          download.on("state", stateChange);
          function progressChange() {
            setProgress(download.progress);
          }
          download.on("progress", progressChange);
          onCleanup(() => {
            download.off("state", stateChange);
            download.off("progress", progressChange);
            URL.revokeObjectURL(url2);
          });
        });
        return (() => {
          var _el$12 = _tmpl$5$3();
          addEventListener(_el$12, "sn-enter-down", () => {
            var _a3;
            const media2 = message2().$.media;
            (_a3 = props.onSelect) == null ? void 0 : _a3.call(props, media2);
          });
          insert(_el$12, createComponent(Show, {
            get when() {
              return createMemo(() => !!thumb2())() && (loading2() || !src() || showUnsupported());
            },
            get children() {
              return [(() => {
                var _el$13 = _tmpl$8$2();
                createRenderEffect((_p$) => {
                  var _v$4 = styles$d.thumb, _v$5 = thumb2();
                  _v$4 !== _p$.e && className(_el$13, _p$.e = _v$4);
                  _v$5 !== _p$.t && setAttribute(_el$13, "src", _p$.t = _v$5);
                  return _p$;
                }, {
                  e: void 0,
                  t: void 0
                });
                return _el$13;
              })(), createComponent(ProgressSpinner, {
                get ["class"]() {
                  return styles$d.spinner;
                },
                size: 40,
                get progress() {
                  return progress2();
                },
                showClose: true
              })];
            }
          }), null);
          insert(_el$12, createComponent(Show, {
            get when() {
              return src();
            },
            get children() {
              var _el$14 = _tmpl$8$2();
              createRenderEffect(() => setAttribute(_el$14, "src", src() + "#-moz-samplesize=2"));
              return _el$14;
            }
          }), null);
          insert(_el$12, createComponent(Show, {
            get when() {
              return showChecks();
            },
            get children() {
              return createComponent(MediaChecks, {});
            }
          }), null);
          createRenderEffect((_p$) => {
            var _v$6 = props.focusable ? -1 : void 0, _v$7 = {
              [styles$d.photo]: true,
              focusable: !!props.focusable
            };
            _v$6 !== _p$.e && setAttribute(_el$12, "tabindex", _p$.e = _v$6);
            _p$.t = classList$1(_el$12, _v$7, _p$.t);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$12;
        })();
      }
      function MediaChecks() {
        const {
          message: message2,
          dialog: dialog2
        } = useMessageContext();
        const check2 = useMessageChecks(message2, dialog2);
        return (() => {
          var _el$15 = _tmpl$9$1(), _el$16 = _el$15.firstChild;
          insert(_el$16, createComponent(TelegramIcon, {
            get name() {
              return check2() ? "check" : "checks";
            }
          }));
          createRenderEffect((_p$) => {
            var _v$8 = styles$d.media_checks, _v$9 = styles$d.info_check;
            _v$8 !== _p$.e && className(_el$15, _p$.e = _v$8);
            _v$9 !== _p$.t && className(_el$16, _p$.t = _v$9);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$15;
        })();
      }
      function VideoMedia(props) {
        const {
          message: message2,
          focused: focused2,
          showChecks,
          media: media2
        } = useMessageContext();
        const round = () => message2().$.media.isRound;
        const [src, setSrc] = createSignal("");
        const [loading2, setLoading] = createSignal(true);
        const [showUnsupported, setShowUnsupported] = createSignal(false);
        const [thumb2, setThumb] = createSignal("");
        const [preview2, setPreview] = createSignal("");
        const [isGif, setIsGif] = createSignal(false);
        let mounted = true;
        onCleanup(() => {
          mounted = false;
        });
        onMount(() => {
          const media22 = message2().$.media;
          setIsGif(media22.isLegacyGif ? 1 : media22.isAnimation);
          const thumb22 = media22.getThumbnail(Thumbnail.THUMB_STRIP);
          let url2;
          if (thumb22 && "byteLength" in thumb22.location) {
            setThumb(url2 = URL.createObjectURL(new Blob([thumb22.location])));
          }
          onCleanup(() => {
            URL.revokeObjectURL(url2);
          });
        });
        onMount(() => {
          var _a3;
          const media22 = message2().$.media;
          (_a3 = props.mediaRef) == null ? void 0 : _a3.call(props, media22);
          const thumb22 = media22.getThumbnail("m");
          if (thumb22) {
            const download = downloadFile(thumb22);
            let url2;
            const stateChange = () => {
              if (download.state == "done") {
                if (mounted) {
                  setPreview(url2 = URL.createObjectURL(download.result));
                }
              }
            };
            if (download.state == "done") {
              stateChange();
              onCleanup(() => {
                URL.revokeObjectURL(url2);
              });
              return;
            }
            download.on("state", stateChange);
            onCleanup(() => {
              download.off("state", stateChange);
              URL.revokeObjectURL(url2);
            });
          }
        });
        onMount(() => {
          var _a3;
          const media22 = message2().$.media;
          const fileSize = media22.fileSize;
          if (!media22.fileSize) {
            return;
          }
          if (media22.fileSize > 5242880) {
            console.error("SKIPPING DOWNLOAD BECAUSE FILE SIZE TOO BIG", fileSize);
            return;
          }
          const isGif2 = media22.isLegacyGif ? 1 : media22.isAnimation;
          if (!isGif2) {
            console.error("SKIPPING DOWNLOAD BECAUSE IT IS NOT A GIF???");
            return;
          }
          const download = downloadFile(media22);
          (_a3 = props.downloadRef) == null ? void 0 : _a3.call(props, download);
          let url2;
          const stateChange = () => {
            if (download.state == "done") {
              if (mounted) {
                setLoading(false);
                setSrc(url2 = URL.createObjectURL(download.result));
              }
            }
          };
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          download.on("state", stateChange);
          onCleanup(() => {
            download.off("state", stateChange);
            URL.revokeObjectURL(url2);
          });
        });
        const [width, setWidth] = createSignal(0);
        return (() => {
          var _el$17 = _tmpl$5$3();
          addEventListener(_el$17, "sn-enter-down", () => {
            var _a3;
            const media22 = message2().$.media;
            if (!isGif())
              (_a3 = props.onSelect) == null ? void 0 : _a3.call(props, media22);
          });
          insert(_el$17, createComponent(Show, {
            get when() {
              return isGif();
            },
            get fallback() {
              return [createComponent(Show, {
                get when() {
                  return preview2();
                },
                get fallback() {
                  return (() => {
                    var _el$24 = _tmpl$8$2();
                    _el$24.addEventListener("load", (e2) => {
                      setWidth(e2.currentTarget.clientWidth);
                    });
                    createRenderEffect((_p$) => {
                      var _v$17 = styles$d.thumb, _v$18 = thumb2() + "#-moz-samplesize=2";
                      _v$17 !== _p$.e && className(_el$24, _p$.e = _v$17);
                      _v$18 !== _p$.t && setAttribute(_el$24, "src", _p$.t = _v$18);
                      return _p$;
                    }, {
                      e: void 0,
                      t: void 0
                    });
                    return _el$24;
                  })();
                },
                get children() {
                  var _el$20 = _tmpl$8$2();
                  _el$20.addEventListener("load", (e2) => {
                    setWidth(e2.currentTarget.clientWidth);
                  });
                  createRenderEffect((_p$) => {
                    var _v$15 = round() ? {
                      "border-radius": "50%"
                    } : void 0, _v$16 = preview2() + "#-moz-samplesize=2";
                    _p$.e = style(_el$20, _v$15, _p$.e);
                    _v$16 !== _p$.t && setAttribute(_el$20, "src", _p$.t = _v$16);
                    return _p$;
                  }, {
                    e: void 0,
                    t: void 0
                  });
                  return _el$20;
                }
              }), (() => {
                var _el$21 = _tmpl$11();
                createRenderEffect(() => className(_el$21, styles$d.play));
                return _el$21;
              })(), (() => {
                var _el$22 = _tmpl$12();
                _el$22.firstChild;
                insert(_el$22, () => formatTime(media2().duration), null);
                createRenderEffect(() => className(_el$22, styles$d.time));
                return _el$22;
              })()];
            },
            get children() {
              return [createComponent(Show, {
                get when() {
                  return createMemo(() => !!focused2())() && src();
                },
                get fallback() {
                  return createComponent(Show, {
                    get when() {
                      return preview2();
                    },
                    get fallback() {
                      return (() => {
                        var _el$26 = _tmpl$8$2();
                        _el$26.addEventListener("load", (e2) => {
                          setWidth(e2.currentTarget.clientWidth);
                        });
                        createRenderEffect((_p$) => {
                          var _v$19 = styles$d.thumb, _v$20 = thumb2() + "#-moz-samplesize=2";
                          _v$19 !== _p$.e && className(_el$26, _p$.e = _v$19);
                          _v$20 !== _p$.t && setAttribute(_el$26, "src", _p$.t = _v$20);
                          return _p$;
                        }, {
                          e: void 0,
                          t: void 0
                        });
                        return _el$26;
                      })();
                    },
                    get children() {
                      var _el$25 = _tmpl$8$2();
                      _el$25.addEventListener("load", (e2) => {
                        setWidth(e2.currentTarget.clientWidth);
                      });
                      createRenderEffect(() => setAttribute(_el$25, "src", preview2() + "#-moz-samplesize=2"));
                      return _el$25;
                    }
                  });
                },
                get children() {
                  return createComponent(Show, {
                    get when() {
                      return isGif() === 1;
                    },
                    get fallback() {
                      return (() => {
                        var _el$27 = _tmpl$13();
                        _el$27.addEventListener("loadedmetadata", (e2) => {
                          setWidth(e2.currentTarget.clientWidth);
                        });
                        createRenderEffect((_p$) => {
                          var _v$21 = width() ? {
                            width: width() + "px"
                          } : void 0, _v$22 = src();
                          _p$.e = style(_el$27, _v$21, _p$.e);
                          _v$22 !== _p$.t && setAttribute(_el$27, "src", _p$.t = _v$22);
                          return _p$;
                        }, {
                          e: void 0,
                          t: void 0
                        });
                        return _el$27;
                      })();
                    },
                    get children() {
                      var _el$18 = _tmpl$8$2();
                      _el$18.addEventListener("load", (e2) => {
                        setWidth(e2.currentTarget.clientWidth);
                      });
                      createRenderEffect((_p$) => {
                        var _v$10 = width() ? {
                          width: width() + "px"
                        } : void 0, _v$11 = src();
                        _p$.e = style(_el$18, _v$10, _p$.e);
                        _v$11 !== _p$.t && setAttribute(_el$18, "src", _p$.t = _v$11);
                        return _p$;
                      }, {
                        e: void 0,
                        t: void 0
                      });
                      return _el$18;
                    }
                  });
                }
              }), createComponent(Show, {
                get when() {
                  return !focused2();
                },
                get children() {
                  var _el$19 = _tmpl$10$1();
                  createRenderEffect(() => className(_el$19, styles$d.gif));
                  return _el$19;
                }
              })];
            }
          }), null);
          insert(_el$17, createComponent(Show, {
            get when() {
              return showChecks();
            },
            get children() {
              return createComponent(MediaChecks, {});
            }
          }), null);
          createRenderEffect((_p$) => {
            var _v$12 = props.focusable ? -1 : void 0, _v$13 = {
              [styles$d.video]: true,
              focusable: !!props.focusable
            }, _v$14 = preview2() && isGif() ? {
              "background-image": `url(${preview2()})`
            } : void 0;
            _v$12 !== _p$.e && setAttribute(_el$17, "tabindex", _p$.e = _v$12);
            _p$.t = classList$1(_el$17, _v$13, _p$.t);
            _p$.a = style(_el$17, _v$14, _p$.a);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          return _el$17;
        })();
      }
      function downsampleWaveform(waveform2, targetLength = 32) {
        const originalLength = waveform2.length;
        const result = [];
        const factor = originalLength / targetLength;
        for (let i = 0; i < targetLength; i++) {
          const start2 = Math.floor(i * factor);
          const end = Math.floor((i + 1) * factor);
          const segment = waveform2.slice(start2, end);
          const average = segment.reduce((sum, value) => sum + value, 0) / segment.length;
          result.push(average);
        }
        return result;
      }
      function VoiceMedia(props) {
        const {
          showChecks,
          message: message2,
          media: media2,
          isOutgoing,
          audioPlaying,
          audioSpeed,
          setAudioPlaying
        } = useMessageContext();
        const [src, setSrc] = createSignal("");
        const [waveform2, setWaveform] = createSignal(null);
        const [playing, setPlaying] = createSignal(false);
        let audioRef;
        const [duration2, setDuration] = createSignal(0);
        const [downloadState, setDownloadState] = createSignal(0);
        const [currentTime, setCurrentTime] = createSignal(0);
        const [waveformIndex, setWaveformIndex] = createSignal(0);
        let download;
        function downloadProgress(num2) {
          setDownloadState(num2);
        }
        onCleanup(() => {
          if (src()) {
            URL.revokeObjectURL(src());
          }
          if ((download == null ? void 0 : download.state) == "downloading") {
            download.abort();
          }
        });
        function startDownload() {
          return __async(this, null, function* () {
            const voice2 = media2();
            download = downloadFile(voice2);
            if (download.state == "done") {
              setSrc(URL.createObjectURL(download.result));
              setDownloadState(100);
              yield sleep$1(2);
              if (audioPlaying()) {
                audioRef.play();
              }
              return;
            }
            download.on("progress", downloadProgress);
            download.once("done", (result) => __async(this, null, function* () {
              setDownloadState(100);
              download == null ? void 0 : download.off("progress", downloadProgress);
              if (!result && download) {
                download = void 0;
              }
              if (result) {
                setSrc(URL.createObjectURL(result));
                yield sleep$1(2);
                if (audioPlaying()) {
                  audioRef.play();
                }
              }
            }));
          });
        }
        function onRewind() {
          audioRef && (audioRef.currentTime = 0);
        }
        createRenderEffect(() => untrack(() => {
          const voice2 = media2();
          setWaveform(downsampleWaveform(voice2.waveform));
          setDuration(voice2.duration);
        }));
        onMount(() => {
          const voice2 = media2();
          console.log(voice2);
        });
        createEffect(() => {
          const audioIsPlaying = audioPlaying();
          if (audioIsPlaying) {
            setSoftkeys("Rewind", "PAUSE", (untrack(audioSpeed) == 2 ? 1 : untrack(audioSpeed) + 0.5) + "x");
            if (!download) {
              untrack(startDownload);
            }
            if (untrack(src)) {
              sleep$1(2).then(() => {
                audioRef.play();
              });
            }
            EE$1.on("audio_rewind", onRewind);
            onCleanup(() => {
              __CJS__export_default__.resume();
              setPlaying(false);
              setSoftkeys("tg:arrow_down", "PLAY", "tg:more");
              audioRef == null ? void 0 : audioRef.pause();
              EE$1.off("audio_rewind", onRewind);
            });
          }
        });
        const pausePath = "M6.7 2.1H4.4c-.7 0-1.2.5-1.2 1.2v13.5c0 .7.5 1.2 1.2 1.2h2.3c.7 0 1.2-.5 1.2-1.2V3.3c0-.7-.5-1.2-1.2-1.2zm8.9 0h-2.3c-.7 0-1.2.5-1.2 1.2v13.5c0 .7.5 1.2 1.2 1.2h2.3c.7 0 1.2-.5 1.2-1.2V3.3c0-.7-.5-1.2-1.2-1.2z";
        const playPath = "M4 3.1v13.8c0 .9 1 1.5 1.8 1 3.1-1.7 9.4-5.2 12.5-6.9.8-.5.8-1.6 0-2.1L5.8 2C5 1.6 4 2.2 4 3.1z";
        return [(() => {
          var _el$28 = _tmpl$15(), _el$29 = _el$28.firstChild, _el$30 = _el$29.firstChild, _el$31 = _el$30.firstChild, _el$32 = _el$29.nextSibling, _el$33 = _el$32.firstChild, _el$34 = _el$33.nextSibling, _el$35 = _el$32.nextSibling;
          _el$29.$$click = () => {
            setPlaying((a) => !a);
          };
          insert(_el$33, createComponent(Index, {
            get each() {
              return waveform2();
            },
            children: (num2, index) => (() => {
              var _el$39 = _tmpl$5$3();
              createRenderEffect((_p$) => {
                var _v$35 = Math.min(100, Math.max(12, num2() / 30 * 100)) + "%", _v$36 = waveformIndex() != 0 && index <= waveformIndex() ? "var(--accent)" : void 0, _v$37 = styles$d.wave;
                _v$35 !== _p$.e && ((_p$.e = _v$35) != null ? _el$39.style.setProperty("height", _v$35) : _el$39.style.removeProperty("height"));
                _v$36 !== _p$.t && ((_p$.t = _v$36) != null ? _el$39.style.setProperty("background", _v$36) : _el$39.style.removeProperty("background"));
                _v$37 !== _p$.a && className(_el$39, _p$.a = _v$37);
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0
              });
              return _el$39;
            })()
          }));
          insert(_el$34, (() => {
            var _c$ = createMemo(() => !!audioPlaying());
            return () => _c$() ? createMemo(() => downloadState() != 100)() ? "Loading..." : formatTime(currentTime()) : formatTime(duration2());
          })());
          insert(_el$35, createComponent(Show, {
            get when() {
              return audioPlaying();
            },
            get fallback() {
              return createComponent(PeerPhotoIcon, {
                showSavedIcon: false,
                get peer() {
                  return message2().sender;
                }
              });
            },
            get children() {
              var _el$36 = _tmpl$14(), _el$37 = _el$36.firstChild;
              insert(_el$36, audioSpeed, _el$37);
              createRenderEffect(() => className(_el$36, styles$d.speed));
              return _el$36;
            }
          }));
          createRenderEffect((_p$) => {
            var _v$23 = styles$d.voice, _v$24 = styles$d.icon, _v$25 = playing() ? pausePath : playPath, _v$26 = styles$d.waveform, _v$27 = styles$d.wavy, _v$28 = styles$d.time, _v$29 = isOutgoing() ? -1 : void 0, _v$30 = audioPlaying() ? 0 : void 0, _v$31 = isOutgoing() ? "8px" : void 0, _v$32 = styles$d.photo;
            _v$23 !== _p$.e && className(_el$28, _p$.e = _v$23);
            _v$24 !== _p$.t && className(_el$29, _p$.t = _v$24);
            _v$25 !== _p$.a && setAttribute(_el$31, "d", _p$.a = _v$25);
            _v$26 !== _p$.o && className(_el$32, _p$.o = _v$26);
            _v$27 !== _p$.i && className(_el$33, _p$.i = _v$27);
            _v$28 !== _p$.n && className(_el$34, _p$.n = _v$28);
            _v$29 !== _p$.s && ((_p$.s = _v$29) != null ? _el$35.style.setProperty("order", _v$29) : _el$35.style.removeProperty("order"));
            _v$30 !== _p$.h && ((_p$.h = _v$30) != null ? _el$35.style.setProperty("border-radius", _v$30) : _el$35.style.removeProperty("border-radius"));
            _v$31 !== _p$.r && ((_p$.r = _v$31) != null ? _el$35.style.setProperty("margin-right", _v$31) : _el$35.style.removeProperty("margin-right"));
            _v$32 !== _p$.d && className(_el$35, _p$.d = _v$32);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0,
            n: void 0,
            s: void 0,
            h: void 0,
            r: void 0,
            d: void 0
          });
          return _el$28;
        })(), createComponent(Show, {
          get when() {
            return showChecks();
          },
          get children() {
            return createComponent(MediaChecks, {});
          }
        }), (() => {
          var _el$38 = _tmpl$16();
          _el$38.addEventListener("ended", () => {
            setWaveformIndex(0);
            setAudioPlaying(false);
          });
          _el$38.addEventListener("timeupdate", (e2) => {
            setCurrentTime(Math.floor(e2.currentTarget.currentTime));
            if (audioPlaying())
              setPlaying(true);
            setWaveformIndex(Math.floor(e2.currentTarget.currentTime / e2.currentTarget.duration * 31));
          });
          _el$38.addEventListener("canplay", () => {
          });
          var _ref$4 = audioRef;
          typeof _ref$4 === "function" ? use(_ref$4, _el$38) : audioRef = _el$38;
          createRenderEffect((_p$) => {
            var _v$33 = audioSpeed(), _v$34 = src();
            _v$33 !== _p$.e && (_el$38.playbackRate = _p$.e = _v$33);
            _v$34 !== _p$.t && setAttribute(_el$38, "src", _p$.t = _v$34);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$38;
        })()];
      }
      function LocationMedia(props) {
        const {
          message: message2
        } = useMessageContext();
        const [src, setSrc] = createSignal("");
        const [loading2, setLoading] = createSignal(true);
        let mounted = true;
        onCleanup(() => {
          mounted = false;
        });
        onMount(() => {
          const _message = message2();
          const media2 = _message.$.media;
          const download = downloadFile(media2.preview({
            width: 192,
            height: 160
          }));
          let url2;
          const stateChange = () => {
            if (download.state == "done") {
              if (mounted) {
                setLoading(false);
                setSrc(url2 = URL.createObjectURL(download.result));
              }
            }
          };
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          download.on("state", stateChange);
          onCleanup(() => {
            download.off("state", stateChange);
            URL.revokeObjectURL(url2);
          });
        });
        return (() => {
          var _el$40 = _tmpl$9$1(), _el$41 = _el$40.firstChild;
          createRenderEffect((_p$) => {
            var _v$38 = styles$d.location, _v$39 = `url(${src()})`, _v$40 = styles$d.pin;
            _v$38 !== _p$.e && className(_el$40, _p$.e = _v$38);
            _v$39 !== _p$.t && ((_p$.t = _v$39) != null ? _el$40.style.setProperty("background-image", _v$39) : _el$40.style.removeProperty("background-image"));
            _v$40 !== _p$.a && className(_el$41, _p$.a = _v$40);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          return _el$40;
        })();
      }
      function UnsupportedMedia() {
        const {
          message: message2,
          mediaType
        } = useMessageContext();
        const unsupported = useStore(() => message2().isUnsupported);
        return createComponent(Show, {
          get when() {
            return unsupported();
          },
          get children() {
            var _el$42 = _tmpl$17();
            _el$42.firstChild;
            insert(_el$42, mediaType, null);
            return _el$42;
          }
        });
      }
      function switchMessageMedia(mediaType) {
        switch (mediaType) {
          case "location":
            return LocationMedia;
          case "voice":
            return VoiceMedia;
          case "video":
            return VideoMedia;
          case "sticker":
            return StickerMedia;
          case "photo":
            return PhotoMedia;
        }
        return UnsupportedMedia;
      }
      delegateEvents(["click"]);
      const recorder = "_recorder_8xw7z_1";
      const recording = "_recording_8xw7z_7";
      const animateMicrophone = "_animateMicrophone_8xw7z_16";
      const preview = "_preview_8xw7z_31";
      const microphone = "_microphone_8xw7z_39";
      const icon$1 = "_icon_8xw7z_43";
      const progress$1 = "_progress_8xw7z_48";
      const bar = "_bar_8xw7z_54";
      const drinks = "_drinks_8xw7z_59";
      const meat = "_meat_8xw7z_67";
      const balls = "_balls_8xw7z_76";
      const time$1 = "_time_8xw7z_84";
      const styles$7 = {
        recorder,
        recording,
        animateMicrophone,
        preview,
        microphone,
        icon: icon$1,
        progress: progress$1,
        bar,
        drinks,
        meat,
        balls,
        time: time$1
      };
      var _tmpl$$a = /* @__PURE__ */ template(`<div><svg viewBox="0 0 14 20"><path d="M7.979 15.462v3.131a.652.652 0 01-.643.657h-.657a.652.652 0 01-.642-.657v-3.131a6.667 6.667 0 01-2.694-1.031 6.97 6.97 0 01-3.029-4.7 4.96 4.96 0 01-.063-.476.633.633 0 01.17-.463.607.607 0 01.446-.193h.652a.742.742 0 01.713.652c.058.474.178.939.357 1.38a4.929 4.929 0 002.602 2.56 4.766 4.766 0 003.58.03 4.927 4.927 0 002.602-2.437 5.639 5.639 0 00.421-1.534.753.753 0 01.72-.65h.652a.577.577 0 01.433.194.6.6 0 01.148.459 8.296 8.296 0 01-.357 1.735c-.87 2.41-2.96 4.113-5.411 4.474zM9.165.913c.574.586.896 1.38.896 2.207v5.462a3.135 3.135 0 01-1.514 2.745 3.003 3.003 0 01-3.086 0 3.135 3.135 0 01-1.513-2.745V3.12C3.948 1.397 5.316 0 7.004 0c.81 0 1.588.328 2.161.913z"></path></svg><svg viewBox="0 0 20 20"><path d="M4 3.1v13.8c0 .9 1 1.5 1.8 1 3.1-1.7 9.4-5.2 12.5-6.9.8-.5.8-1.6 0-2.1L5.8 2C5 1.6 4 2.2 4 3.1z"></path></svg><div><div><div><div></div><div></div></div></div><div>`), _tmpl$2$6 = /* @__PURE__ */ template(`<div tabindex=-1><audio>`), _tmpl$3$3 = /* @__PURE__ */ template(`<div>Press again to record`), _tmpl$4$3 = /* @__PURE__ */ template(`<div><svg viewBox="0 0 14 20"><path d="M7.979 15.462v3.131a.652.652 0 01-.643.657h-.657a.652.652 0 01-.642-.657v-3.131a6.667 6.667 0 01-2.694-1.031 6.97 6.97 0 01-3.029-4.7 4.96 4.96 0 01-.063-.476.633.633 0 01.17-.463.607.607 0 01.446-.193h.652a.742.742 0 01.713.652c.058.474.178.939.357 1.38a4.929 4.929 0 002.602 2.56 4.766 4.766 0 003.58.03 4.927 4.927 0 002.602-2.437 5.639 5.639 0 00.421-1.534.753.753 0 01.72-.65h.652a.577.577 0 01.433.194.6.6 0 01.148.459 8.296 8.296 0 01-.357 1.735c-.87 2.41-2.96 4.113-5.411 4.474zM9.165.913c.574.586.896 1.38.896 2.207v5.462a3.135 3.135 0 01-1.514 2.745 3.003 3.003 0 01-3.086 0 3.135 3.135 0 01-1.513-2.745V3.12C3.948 1.397 5.316 0 7.004 0c.81 0 1.588.328 2.161.913z">`);
      function blobToArrayBuffer(blob) {
        if ("arrayBuffer" in blob) {
          return blob.arrayBuffer();
        }
        return new Promise((resolve, reject) => {
          const reader2 = new FileReader();
          reader2.onload = () => {
            resolve(reader2.result);
          };
          reader2.onerror = reject;
          reader2.readAsArrayBuffer(blob);
        });
      }
      const VoiceRecorderWeb = (props) => {
        const [recording2, setRecording] = createSignal(false);
        const [paused, setPaused] = createSignal(false);
        const [time2, setTime] = createSignal(0);
        const [audioPreview, setAudioPreview] = createSignal(null);
        let divRef;
        let recorder2;
        let chunks = [];
        let currentStream;
        let audioRef;
        onMount(() => {
          __CJS__export_default__.pause();
          divRef.focus();
        });
        onCleanup(() => {
          audioRef.pause();
          URL.revokeObjectURL(audioRef.src);
          divRef.blur();
          __CJS__export_default__.resume();
        });
        const changeRecording = (recording22) => {
          setRecording(recording22);
        };
        let shouldSendImmediately = false;
        function toggleRecording() {
          const nowRecording = !recording2();
          if (nowRecording) {
            setTime(0);
            navigator.mediaDevices.getUserMedia({
              audio: {
                echoCancellation: true,
                noiseSuppression: true
              }
            }).then((stream) => {
              currentStream = stream;
              const _chunks = [];
              chunks = _chunks;
              const _recorder = new MediaRecorder(stream);
              recorder2 = _recorder;
              _recorder.addEventListener("dataavailable", (e2) => {
                _chunks.push(e2.data);
              });
              _recorder.start();
              changeRecording(true);
            });
          } else {
            if (recorder2) {
              recorder2.addEventListener("stop", () => __async(this, null, function* () {
                const blob = new Blob(chunks, {
                  type: "audio/ogg; codecs=opus"
                });
                const audioContext = new AudioContext();
                const audioBuffer = yield audioContext.decodeAudioData(yield blobToArrayBuffer(blob));
                const rawData = audioBuffer.getChannelData(0);
                const samples = 100;
                const blockSize = Math.floor(rawData.length / samples);
                const filteredData = [];
                for (let i = 0; i < samples; i++) {
                  let blockStart = blockSize * i;
                  let sum = 0;
                  for (let j = 0; j < blockSize; j++) {
                    sum = sum + Math.abs(rawData[blockStart + j]);
                  }
                  filteredData.push(sum / blockSize);
                }
                const multiplier = Math.pow(Math.max(...filteredData), -1);
                props.setAudioBlob(blob, filteredData.map((n2) => Math.floor(n2 * multiplier * 31)), audioBuffer.duration);
                changeRecording(false);
                if (shouldSendImmediately) {
                  props.onComplete(true);
                }
              }));
              recorder2.stop();
              currentStream == null ? void 0 : currentStream.getTracks().forEach((track) => track.stop());
            }
          }
        }
        createEffect(() => {
          let interval;
          const _recording = recording2();
          const _paused = paused();
          if (_recording && _paused === false) {
            interval = setInterval(() => {
              setTime((time22) => time22 + 1);
            }, 1e3);
          } else {
            clearInterval(interval);
          }
          onCleanup(() => {
            clearInterval(interval);
          });
        });
        createEffect(() => {
          let left = "", center = "", right = "";
          if (!audioPreview() && !recording2() && !!time2())
            left = "Preview";
          if (audioPreview())
            left = "Stop";
          if (recording2()) {
            left = "Send";
            center = paused() ? "Resume" : "Pause";
            right = "Stop";
          } else {
            center = "Record";
            if (time2()) {
              right = "Send";
            }
          }
          setSoftkeys(left, center, right);
        });
        const [previewTime, setPreviewTime] = createSignal(0);
        const previewWidth = createMemo(() => Math.min(previewTime() / time2() * 100, 100) + "px");
        return (() => {
          var _el$ = _tmpl$2$6(), _el$2 = _el$.firstChild;
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$) : divRef = _el$;
          _el$.$$keydown = (e2) => {
            if (e2.currentTarget !== divRef)
              return;
            if (e2.currentTarget !== document.activeElement)
              return;
            switch (e2.key) {
              case "Backspace":
                e2.preventDefault();
                props.onComplete(false);
                break;
              case "SoftRight":
                {
                  if (recording2()) {
                    toggleRecording();
                  }
                  if (!recording2() && !!time2()) {
                    props.onComplete(true);
                  }
                }
                break;
              case "Enter": {
                if (recording2()) {
                  if (untrack(paused))
                    recorder2 == null ? void 0 : recorder2.resume();
                  else
                    recorder2 == null ? void 0 : recorder2.pause();
                  setPaused((a) => !a);
                } else {
                  toggleRecording();
                }
                break;
              }
              case "SoftLeft": {
                if (recording2()) {
                  shouldSendImmediately = true;
                  toggleRecording();
                }
                if (!recording2() && !!time2()) {
                  const _audioPreview = audioPreview();
                  if (_audioPreview) {
                    _audioPreview.pause();
                    _audioPreview.currentTime = 0;
                    setAudioPreview(null);
                  } else {
                    const audio2 = audioRef;
                    if (!audio2.src) {
                      const src = URL.createObjectURL(new Blob(chunks, {
                        type: "audio/ogg; codecs=opus"
                      }));
                      audio2.src = src;
                    }
                    audio2.play();
                    audio2.onended = () => {
                      setAudioPreview(null);
                      setPreviewTime(0);
                    };
                    setAudioPreview(audio2);
                  }
                }
                break;
              }
            }
          };
          var _ref$2 = audioRef;
          typeof _ref$2 === "function" ? use(_ref$2, _el$2) : audioRef = _el$2;
          _el$2.addEventListener("timeupdate", (e2) => {
            setPreviewTime(e2.currentTarget.currentTime);
          });
          insert(_el$, createComponent(Show, {
            get when() {
              return createMemo(() => !!!recording2())() && !!time2();
            },
            get fallback() {
              return (() => {
                var _el$12 = _tmpl$4$3(), _el$13 = _el$12.firstChild;
                _el$13.style.setProperty("fill", "#fff");
                _el$13.style.setProperty("margin-right", "9px");
                _el$13.style.setProperty("height", "20px");
                insert(_el$12, createComponent(Show, {
                  get when() {
                    return !recording2();
                  },
                  get fallback() {
                    return createMemo(() => formatTime(time2()));
                  },
                  get children() {
                    return _tmpl$3$3();
                  }
                }), null);
                createRenderEffect((_p$) => {
                  var _v$12 = recording2() ? "rgb(229, 57, 53)" : void 0, _v$13 = styles$7.recording, _v$14 = recording2() && !paused() ? styles$7.animateMicrophone : void 0;
                  _v$12 !== _p$.e && ((_p$.e = _v$12) != null ? _el$12.style.setProperty("background", _v$12) : _el$12.style.removeProperty("background"));
                  _v$13 !== _p$.t && className(_el$12, _p$.t = _v$13);
                  _v$14 !== _p$.a && setAttribute(_el$13, "class", _p$.a = _v$14);
                  return _p$;
                }, {
                  e: void 0,
                  t: void 0,
                  a: void 0
                });
                return _el$12;
              })();
            },
            get children() {
              var _el$3 = _tmpl$$a(), _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.firstChild, _el$9 = _el$8.firstChild, _el$10 = _el$9.nextSibling, _el$11 = _el$7.nextSibling;
              insert(_el$11, (() => {
                var _c$ = createMemo(() => !!audioPreview());
                return () => _c$() ? formatTime(previewTime()) : formatTime(time2());
              })());
              createRenderEffect((_p$) => {
                var _v$ = styles$7.preview, _v$2 = styles$7.microphone, _v$3 = styles$7.icon, _v$4 = styles$7.progress, _v$5 = styles$7.bar, _v$6 = styles$7.drinks, _v$7 = previewWidth(), _v$8 = styles$7.meat, _v$9 = previewWidth(), _v$10 = styles$7.balls, _v$11 = styles$7.time;
                _v$ !== _p$.e && className(_el$3, _p$.e = _v$);
                _v$2 !== _p$.t && setAttribute(_el$4, "class", _p$.t = _v$2);
                _v$3 !== _p$.a && setAttribute(_el$5, "class", _p$.a = _v$3);
                _v$4 !== _p$.o && className(_el$6, _p$.o = _v$4);
                _v$5 !== _p$.i && className(_el$7, _p$.i = _v$5);
                _v$6 !== _p$.n && className(_el$8, _p$.n = _v$6);
                _v$7 !== _p$.s && ((_p$.s = _v$7) != null ? _el$9.style.setProperty("left", _v$7) : _el$9.style.removeProperty("left"));
                _v$8 !== _p$.h && className(_el$9, _p$.h = _v$8);
                _v$9 !== _p$.r && ((_p$.r = _v$9) != null ? _el$10.style.setProperty("width", _v$9) : _el$10.style.removeProperty("width"));
                _v$10 !== _p$.d && className(_el$10, _p$.d = _v$10);
                _v$11 !== _p$.l && className(_el$11, _p$.l = _v$11);
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0,
                o: void 0,
                i: void 0,
                n: void 0,
                s: void 0,
                h: void 0,
                r: void 0,
                d: void 0,
                l: void 0
              });
              return _el$3;
            }
          }), null);
          createRenderEffect(() => className(_el$, styles$7.recorder));
          return _el$;
        })();
      };
      delegateEvents(["keydown"]);
      function startVolumeManager() {
        const session = new lib_session.Session();
        const sessionstate = {};
        navigator.volumeManager = null;
        sessionstate.onsessionconnected = function() {
          lib_audiovolume.AudioVolumeManager.get(session).then((AudioVolumeManagerService) => {
            navigator.volumeManager = AudioVolumeManagerService;
          }).catch((e2) => {
            navigator.volumeManager = null;
          });
        };
        sessionstate.onsessiondisconnected = function() {
          startVolumeManager();
        };
        session.open("websocket", "localhost:8081", "secrettoken", sessionstate, true);
      }
      const loadScripts = (() => {
        if (navigator.b2g) {
          const head = document.head;
          const scripts = [
            "http://127.0.0.1:8081/api/v1/shared/core.js",
            "http://127.0.0.1:8081/api/v1/shared/session.js",
            "http://127.0.0.1:8081/api/v1/audiovolumemanager/service.js"
          ];
          const promises = scripts.map((path2) => {
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.src = path2;
            const promise = new Promise((res) => {
              script.onload = () => {
                res(true);
                script.remove();
              };
            });
            head.appendChild(script);
            return promise;
          });
          return Promise.all(promises).then(() => true);
        }
        return Promise.resolve(false);
      })();
      loadScripts.then((polyfill2) => {
        if (polyfill2)
          startVolumeManager();
      });
      function volumeUp() {
        if (navigator.b2g && navigator.b2g.audioChannelManager && navigator.volumeManager) {
          navigator.volumeManager.requestVolumeUp();
        } else if (navigator.mozAudioChannelManager) {
          navigator.volumeManager.requestUp();
        }
      }
      function volumeDown() {
        if (navigator.b2g && navigator.b2g.audioChannelManager && navigator.volumeManager) {
          navigator.volumeManager.requestVolumeDown();
        } else if (navigator.mozAudioChannelManager) {
          navigator.volumeManager.requestDown();
        }
      }
      var _tmpl$$9 = /* @__PURE__ */ template(`<div><input placeholder="Add a caption..."><div><div><svg viewBox="0 0 24 24"><path d="M12 22.1C6.4 22.1 1.9 17.6 1.9 12S6.4 1.9 12 1.9 22.1 6.4 22.1 12 17.6 22.1 12 22.1zm0-18.6c-4.7 0-8.5 3.8-8.5 8.5s3.8 8.5 8.5 8.5 8.5-3.8 8.5-8.5-3.8-8.5-8.5-8.5z"></path><path d="M8.9 11.6c.7 0 1.3-.7 1.3-1.5s-.6-1.5-1.3-1.5-1.3.7-1.3 1.5.6 1.5 1.3 1.5zm8.2 2c-1.1.1-3 .4-5 .4s-4-.3-5-.4c-.4 0-.6.3-.4.7 1.1 2 3.1 3.5 5.5 3.5 2.3 0 4.4-1.5 5.5-3.5.1-.3-.2-.7-.6-.7zM12.3 16c-2.6 0-4.1-1-4.2-1.6 0 0 4.4.9 8 0 0 0-.5 1.6-3.8 1.6zm2.8-4.4c.7 0 1.3-.7 1.3-1.5s-.6-1.5-1.3-1.5-1.3.7-1.3 1.5.6 1.5 1.3 1.5z"></path></svg></div><div class="p n"><span class=s>Send</span></div><div class="q n"><svg viewBox="0 0 16 16"fill=currentColor><path d="M9.5 13a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zm0-5a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zm0-5a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z">`);
      function ImageUpload(props) {
        let inputRef;
        const [src, setSrc] = createSignal("");
        onMount(() => {
          setSoftkeys("", "", "");
          inputRef.focus();
          let url2;
          setSrc(url2 = URL.createObjectURL(props.image));
          onCleanup(() => {
            URL.revokeObjectURL(url2);
          });
        });
        const [showEmojiPicker, setShowEmojiPicker] = createSignal(false);
        const [showOptions, setShowOptions] = createSignal(false);
        let itemRef;
        return [(() => {
          var _el$ = _tmpl$$9(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$4.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild;
          insert(_el$, createComponent(Dynamic, {
            get component() {
              return props.isVideo ? "video" : "img";
            },
            get style() {
              return showEmojiPicker() || showOptions() ? {
                top: "30px"
              } : void 0;
            },
            preload: "metadata",
            get src() {
              return src();
            },
            onLoadedMetadata: (e2) => __async(this, null, function* () {
              if (!props.isVideo)
                return;
              console.error("VIDEO PREVIEW AVAILABLE");
              const target = e2.currentTarget;
              yield sleep$1(0);
              target.currentTime = 1e-11;
            })
          }), _el$2);
          _el$2.$$keydown = (e2) => {
            const value = e2.currentTarget.value;
            if (e2.key == "Enter") {
              sleep$1(10).then(() => props.onSend(value));
            }
            if (e2.key == "Backspace" && value === "") {
              e2.preventDefault();
              sleep$1(10).then(() => props.onSend(false));
            }
            if (e2.key == "SoftLeft") {
              setSoftkeys("", "", "");
              sleep$1(10).then(() => {
                setShowEmojiPicker(true);
              });
            }
            if (e2.key == "SoftRight") {
              setShowOptions(true);
              sleep$1(0).then(() => {
                itemRef.focus();
              });
              setSoftkeys("", "OK", "");
            }
          };
          var _ref$ = inputRef;
          typeof _ref$ === "function" ? use(_ref$, _el$2) : inputRef = _el$2;
          createRenderEffect((_p$) => {
            var _v$ = showEmojiPicker() || showOptions() ? {
              bottom: "30px"
            } : void 0, _v$2 = styles$d.upload_image, _v$3 = styles$d.caption_textbox, _v$4 = styles$d.caption_softkeys, _v$5 = styles$d.emoji, _v$6 = styles$d.options;
            _p$.e = style(_el$, _v$, _p$.e);
            _v$2 !== _p$.t && className(_el$, _p$.t = _v$2);
            _v$3 !== _p$.a && className(_el$2, _p$.a = _v$3);
            _v$4 !== _p$.o && className(_el$3, _p$.o = _v$4);
            _v$5 !== _p$.i && setAttribute(_el$5, "class", _p$.i = _v$5);
            _v$6 !== _p$.n && setAttribute(_el$8, "class", _p$.n = _v$6);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0,
            n: void 0
          });
          return _el$;
        })(), createComponent(Show, {
          get when() {
            return showEmojiPicker();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(EmojiPicker, {
                  onSelect: (e2) => __async(this, null, function* () {
                    setSoftkeys("", "", "");
                    setShowEmojiPicker(false);
                    yield sleep$1(10);
                    if (e2) {
                      typeInTextbox(e2, inputRef);
                    }
                    inputRef.focus();
                  })
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return showOptions();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(Options, {
                  onClose: () => {
                    setShowOptions(false);
                    sleep$1(10).then(() => {
                      inputRef.focus();
                    });
                  },
                  title: "Options",
                  get children() {
                    return createComponent(OptionsMenuMaxHeight, {
                      get children() {
                        return createComponent(OptionsItem, {
                          ref(r$) {
                            var _ref$2 = itemRef;
                            typeof _ref$2 === "function" ? _ref$2(r$) : itemRef = r$;
                          },
                          get classList() {
                            return {
                              option: true,
                              [styles$d.option_item]: true
                            };
                          },
                          tabIndex: -1,
                          onKeyDown: (e2) => {
                            if (e2.key == "Enter") {
                              setSoftkeys("", "", "");
                              sleep$1(10).then(() => {
                                props.onSend(false);
                              });
                            }
                          },
                          children: "Cancel"
                        });
                      }
                    });
                  }
                });
              }
            });
          }
        })];
      }
      delegateEvents(["keydown"]);
      const container = "_container_176l7_1";
      const styles$6 = {
        container
      };
      var _tmpl$$8 = /* @__PURE__ */ template(`<div>`);
      let counter = 0;
      class TempFileUploading {
        constructor() {
          __publicField(this, "progress", writable(0));
          __publicField(this, "error", writable(false));
          __publicField(this, "id", ++counter);
        }
      }
      const [temp_uploadingFiles, temp_setUploadingFiles] = createSignal([]);
      function UploadingIndicator(props) {
        const progress2 = useStore(() => props.fileUpload.progress);
        const error = useStore(() => props.fileUpload.error);
        createEffect(() => {
          const errored = error();
          let timeout;
          if (errored) {
            timeout = setTimeout(() => {
              props.done();
            }, 2e3);
          }
          onCleanup(() => {
            clearTimeout(timeout);
          });
        });
        createEffect(() => {
          if (progress2() >= 100) {
            props.done();
          }
        });
        return (() => {
          var _el$ = _tmpl$$8();
          insert(_el$, createComponent(Show, {
            get when() {
              return error();
            },
            get fallback() {
              return ["Uploading ", createMemo(() => props.fileUpload.id), ": ", createMemo(progress2), "%"];
            },
            children: "Error!"
          }));
          return _el$;
        })();
      }
      function TemporaryUploadingIndicator() {
        return (() => {
          var _el$2 = _tmpl$$8();
          insert(_el$2, createComponent(For, {
            get each() {
              return temp_uploadingFiles();
            },
            children: (e2) => createComponent(UploadingIndicator, {
              done: () => {
                temp_setUploadingFiles((a) => without(a, e2));
              },
              fileUpload: e2
            })
          }));
          createRenderEffect(() => className(_el$2, styles$6.container));
          return _el$2;
        })();
      }
      var _tmpl$$7 = /* @__PURE__ */ template(`<div><div><span>`), _tmpl$2$5 = /* @__PURE__ */ template(`<div tabindex=-1><div>`), _tmpl$3$2 = /* @__PURE__ */ template(`<div><div></div><div><div><span></span></div><div><span>`), _tmpl$4$2 = /* @__PURE__ */ template(`<span>`), _tmpl$5$2 = /* @__PURE__ */ template(`<div>edited`), _tmpl$6$1 = /* @__PURE__ */ template(`<div>`), _tmpl$7$1 = /* @__PURE__ */ template(`<div><div></div><div>more<span>`), _tmpl$8$1 = /* @__PURE__ */ template(`<div><div><div><span>`), _tmpl$9 = /* @__PURE__ */ template(`<br>`), _tmpl$10 = /* @__PURE__ */ template(`<div><div>`);
      function getMembersCount(chat2) {
        if (chat2.peer.participantsCount) {
          return chat2.peer.participantsCount;
        }
        return null;
      }
      const isOverflown = ({
        clientHeight,
        scrollHeight
      }) => {
        return scrollHeight - 8 > clientHeight;
      };
      function ActionMessage(props) {
        return (() => {
          var _el$ = _tmpl$$7(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;
          insert(_el$3, () => props.children);
          createRenderEffect((_p$) => {
            var _v$ = styles$d.action_message, _v$2 = styles$d.action_message_inner;
            _v$ !== _p$.e && className(_el$, _p$.e = _v$);
            _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$;
        })();
      }
      const SN_ID_OPTIONS$1 = "options";
      function willFocusScrollIfNeeded(e$12) {
        e(e$12.currentTarget, {
          scrollMode: "if-needed",
          block: "nearest",
          inline: "nearest"
        });
      }
      function TextboxOptions(props) {
        onMount(() => {
          __CJS__export_default__.add(SN_ID_OPTIONS$1, {
            selector: ".option",
            restrict: "self-only"
          });
          __CJS__export_default__.focus(SN_ID_OPTIONS$1);
          setSoftkeys("", "OK", "");
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID_OPTIONS$1);
        });
        const interacting = createMemo(() => {
          const editing = editingMessage();
          const replying = replyingMessage();
          return editing || replying;
        });
        const isEditing = () => Boolean(editingMessage());
        return createComponent(Options, {
          onClose: () => {
            props.onSelect(null);
          },
          title: "Options",
          get children() {
            return createComponent(OptionsMenuMaxHeight, {
              get children() {
                return [createComponent(Show, {
                  get when() {
                    return props.canSend;
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          0
                          /* SEND */
                        );
                      },
                      children: "Send"
                    });
                  }
                }), createComponent(Show, {
                  get when() {
                    return interacting();
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          1
                          /* CANCEL */
                        );
                      },
                      get children() {
                        return ["Cancel ", createMemo(() => isEditing() ? "Edit" : "Reply")];
                      }
                    });
                  }
                }), createComponent(Show, {
                  get when() {
                    return sessionStorage.getItem("copy");
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          3
                          /* PASTE */
                        );
                      },
                      children: "Paste"
                    });
                  }
                }), createComponent(Show, {
                  get when() {
                    return props.canSend;
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          4
                          /* COPY */
                        );
                      },
                      children: "Copy"
                    });
                  }
                }), createComponent(OptionsItem, {
                  "on:sn-willfocus": willFocusScrollIfNeeded,
                  get classList() {
                    return {
                      option: true,
                      [styles$d.option_item]: true
                    };
                  },
                  tabIndex: -1,
                  "on:sn-enter-down": () => {
                    props.onSelect(
                      6
                      /* SETTINGS */
                    );
                  },
                  ref: (ref) => {
                    if (localStorage.getItem("NO_ADS"))
                      ;
                  },
                  children: "Settings"
                }), createComponent(Show, {
                  get when() {
                    return !localStorage.getItem("NO_ADS");
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          5
                          /* KAIAD */
                        );
                      },
                      ref: (ref) => {
                      },
                      children: "Show Ad"
                    });
                  }
                })];
              }
            });
          }
        });
      }
      function MessageOptions(props) {
        const {
          dialog: dialog2,
          message: message2,
          rawMessage,
          entities
        } = useMessageContext();
        onMount(() => {
          __CJS__export_default__.add(SN_ID_OPTIONS$1, {
            selector: ".option",
            restrict: "self-only"
          });
          __CJS__export_default__.focus(SN_ID_OPTIONS$1);
          setSoftkeys("", "OK", "");
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID_OPTIONS$1);
        });
        let lastRef;
        return createComponent(Options, {
          onClose: () => {
            props.onSelect(null);
          },
          get children() {
            return createComponent(OptionsMenuMaxHeight, {
              get children() {
                return [createComponent(OptionsItem, {
                  "on:sn-willfocus": willFocusScrollIfNeeded,
                  get classList() {
                    return {
                      option: true,
                      [styles$d.option_item]: true
                    };
                  },
                  tabIndex: -1,
                  "on:sn-enter-down": () => {
                    props.onSelect(
                      0
                      /* INFO */
                    );
                  },
                  children: "Message info"
                }), createComponent(Show, {
                  get when() {
                    return chat().chatType !== "channel";
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          1
                          /* REPLY */
                        );
                      },
                      children: "Reply"
                    });
                  }
                }), createComponent(Show, {
                  get when() {
                    return message2().canEdit();
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          2
                          /* EDIT */
                        );
                      },
                      children: "Edit"
                    });
                  }
                }), createComponent(Show, {
                  get when() {
                    return canDeleteForEverone(rawMessage(), dialog2()) || canDeleteForMe(dialog2());
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          3
                          /* DELETE */
                        );
                      },
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      tabIndex: -1,
                      arrow: true,
                      children: "Delete"
                    });
                  }
                }), createComponent(Show, {
                  get when() {
                    return entities().entities || entities().text;
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        props.onSelect(
                          4
                          /* COPY */
                        );
                      },
                      children: "Copy"
                    });
                  }
                }), createComponent(OptionsItem, {
                  "on:sn-willfocus": willFocusScrollIfNeeded,
                  get classList() {
                    return {
                      option: true,
                      [styles$d.option_item]: true
                    };
                  },
                  tabIndex: -1,
                  "on:sn-enter-down": () => {
                    props.onSelect(
                      6
                      /* JUMP */
                    );
                  },
                  ref(r$) {
                    var _ref$ = lastRef;
                    typeof _ref$ === "function" ? _ref$(r$) : lastRef = r$;
                  },
                  children: "Jump to bottom"
                })];
              }
            });
          }
        });
      }
      function canDeleteForEverone(message2, dialog2) {
        const chat2 = dialog2.$.chat;
        if (message2.isOutgoing)
          return true;
        if (chat2.chatType == "private")
          return true;
        return false;
      }
      function canDeleteForMe(dialog2) {
        const chat2 = dialog2.$.chat;
        if (chat2.chatType == "private")
          return true;
        return false;
      }
      function DeleteOptions(props) {
        const {
          dialog: dialog2,
          rawMessage
        } = useMessageContext();
        onMount(() => {
          __CJS__export_default__.add(SN_ID_OPTIONS$1, {
            selector: ".option",
            restrict: "self-only"
          });
          __CJS__export_default__.focus(SN_ID_OPTIONS$1);
          setSoftkeys("", "OK", "");
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID_OPTIONS$1);
        });
        const tg = client();
        return createComponent(Options, {
          onClose: () => {
            props.onSelect();
          },
          title: "Delete",
          get children() {
            return createComponent(OptionsMenuMaxHeight, {
              get children() {
                return [createComponent(Show, {
                  get when() {
                    return canDeleteForMe(dialog2());
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        sleep$1(2).then(() => __async(this, null, function* () {
                          const message2 = rawMessage();
                          yield tg.deleteMessages([message2], {
                            revoke: false
                          }).then(() => {
                            dialog2().messages.delete(message2.id);
                            refreshDialogsByPeer([dialog2().$.chat.inputPeer]);
                          });
                        }));
                        props.onSelect();
                      },
                      "on:sn-navigatefailed": (e2) => {
                        const direction = e2.detail.direction;
                        if (direction == "up" && canDeleteForEverone(rawMessage(), dialog2())) {
                          __CJS__export_default__.move("down");
                        }
                      },
                      children: "Delete for me"
                    });
                  }
                }), createComponent(Show, {
                  get when() {
                    return canDeleteForEverone(rawMessage(), dialog2());
                  },
                  get children() {
                    return createComponent(OptionsItem, {
                      "on:sn-willfocus": willFocusScrollIfNeeded,
                      get classList() {
                        return {
                          option: true,
                          [styles$d.option_item]: true
                        };
                      },
                      tabIndex: -1,
                      "on:sn-enter-down": () => {
                        sleep$1(2).then(() => __async(this, null, function* () {
                          const message2 = rawMessage();
                          yield tg.deleteMessages([message2], {
                            revoke: true
                          }).then(() => {
                            dialog2().messages.delete(message2.id);
                            refreshDialogsByPeer([dialog2().id]);
                          });
                        }));
                        props.onSelect();
                      },
                      "on:sn-navigatefailed": (e2) => {
                        const direction = e2.detail.direction;
                        if (direction == "down" && canDeleteForMe(dialog2())) {
                          __CJS__export_default__.move("up");
                        }
                      },
                      children: "Delete for everyone"
                    });
                  }
                })];
              }
            });
          }
        });
      }
      function MessageContainer(props) {
        const {
          dialog: dialog2,
          actualLast,
          setFocused,
          showContainerTail,
          last: last2,
          isOutgoing,
          isSticker: isSticker2,
          isReply: isReply2,
          showUsername: showUsername2,
          message: message2,
          rawMessage,
          mediaType,
          audioPlaying,
          setAudioPlaying,
          setAudioSpeed,
          audioSpeed,
          entities
        } = useMessageContext();
        onMount(() => {
          if (actualLast()) {
            console.error("last Message mounted!!!");
            const actEl = document.activeElement;
            if (actEl && actEl.classList.contains("roomTextbox")) {
              refreshFocusables();
              const _dialog = dialog2();
              setTimeout(() => {
                if (actEl !== document.activeElement)
                  return;
                _dialog.readHistory();
              }, 500);
              e(actEl, {
                behavior: "instant",
                block: "center",
                inline: "center"
              });
            }
          }
        });
        onCleanup(() => {
          const actEl = document.activeElement;
          if (currentView() == "room" && actEl && actEl.classList.contains(styles$d.message)) {
            __CJS__export_default__.move("down") || __CJS__export_default__.move("up");
          }
        });
        const [showOptions, setShowOptions] = createSignal(false);
        const [showDeleteOptions, setShowDeleteOptions] = createSignal(false);
        let divRef;
        onMount(() => {
          const cb = (msgId, chatId) => {
            const message22 = rawMessage();
            if (message22.id === msgId && chatId === message22.chat.id) {
              divRef.focus();
            }
          };
          EE$1.on("requestJump", cb);
          onCleanup(() => EE$1.off("requestJump", cb));
        });
        function jumpToBottom() {
          sleep$1(2).then(() => {
            var _a3;
            (_a3 = divRef.parentElement.querySelector(".last")) == null ? void 0 : _a3.focus();
          });
        }
        return [(() => {
          var _el$4 = _tmpl$2$5(), _el$5 = _el$4.firstChild;
          _el$4.$$keydown = (e2) => {
            if (audioPlaying()) {
              if (e2.key == "Enter") {
                sleep$1(10).then(() => {
                  setAudioPlaying(false);
                });
              }
              if (e2.key == "Backspace") {
                e2.preventDefault();
                setAudioPlaying(false);
              }
              if (e2.key.includes("Arrow")) {
                e2.preventDefault();
                switch (e2.key) {
                  case "ArrowUp":
                    volumeUp();
                    break;
                  case "ArrowDown":
                    volumeDown();
                    break;
                }
              }
              if (e2.key == "SoftLeft") {
                EE$1.emit("audio_rewind");
              }
              if (e2.key == "SoftRight") {
                if (mediaType() == "voice") {
                  setAudioSpeed((prev) => {
                    if (prev == 2)
                      return 1;
                    return prev + 0.5;
                  });
                  setSoftkeys(null, null, (audioSpeed() == 2 ? "1" : audioSpeed() + 0.5) + "x");
                } else {
                  EE$1.emit("audio_stop");
                }
              }
              return;
            }
            if (e2.key == "Backspace") {
              setView("home");
              e2.preventDefault();
              return;
            }
            if (e2.key == "SoftLeft") {
              jumpToBottom();
            }
            if (e2.key == "SoftRight") {
              setShowOptions(true);
            }
          };
          addEventListener(_el$4, "sn-navigatefailed", (e$12) => __async(this, null, function* () {
            const direction = e$12.detail.direction;
            if (direction == "up") {
              yield dialog2().messages.loadMore();
              e(e$12.target, {
                behavior: "instant",
                block: "center",
                inline: "center"
              });
            }
          }));
          addEventListener(_el$4, "sn-enter-down", () => {
            if (mediaType() == "audio" || mediaType() == "voice") {
              setAudioPlaying(true);
              __CJS__export_default__.pause();
            } else {
              setMessageInfo(message2());
            }
          });
          _el$4.addEventListener("blur", () => {
            setFocused(false);
          });
          _el$4.addEventListener("focus", (e$12) => {
            if (actualLast()) {
              dialog2().readHistory();
            }
            if (e$12.currentTarget == e$12.target) {
              e(e$12.currentTarget, {
                behavior: "instant",
                block: "center",
                inline: "center"
              });
              setFocused(true);
            }
            if (mediaType() == "voice" || mediaType() == "audio") {
              setSoftkeys("tg:arrow_down", "PLAY", "tg:more");
              return;
            }
            setSoftkeys("tg:arrow_down", "INFO", "tg:more");
          });
          var _ref$2 = divRef;
          typeof _ref$2 === "function" ? use(_ref$2, _el$4) : divRef = _el$4;
          insert(_el$5, () => props.children);
          createRenderEffect((_p$) => {
            var _v$3 = {
              [styles$d.message]: true,
              [styles$d.padTop]: showContainerTail(),
              focusable: true,
              last: last2()
            }, _v$4 = {
              [styles$d.message_inner]: true,
              [styles$d.outgoing]: isOutgoing(),
              [styles$d.tail]: showContainerTail(),
              [styles$d.isSticker]: isSticker2(),
              [styles$d.isReply]: isReply2(),
              [styles$d.showUsername]: showUsername2()
            };
            _p$.e = classList$1(_el$4, _v$3, _p$.e);
            _p$.t = classList$1(_el$5, _v$4, _p$.t);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$4;
        })(), createComponent(Show, {
          get when() {
            return showOptions();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(MessageOptions, {
                  onSelect: (e2) => {
                    setShowOptions(false);
                    if (e2 == 3) {
                      setShowDeleteOptions(true);
                      return;
                    }
                    switch (e2) {
                      case 6:
                        jumpToBottom();
                        break;
                      case 0:
                        __CJS__export_default__.focus("room");
                        setMessageInfo(message2());
                        return;
                      case 4:
                        sessionStorage.setItem("copy", md.unparse(entities()));
                        break;
                      case 2:
                      case 1:
                        const edit = e2 == 2;
                        batch(() => {
                          setEditingMessage(null);
                          setReplyingMessage(null);
                          if (edit) {
                            setEditingMessage(message2());
                          } else {
                            setReplyingMessage(message2());
                          }
                        });
                        return;
                    }
                    __CJS__export_default__.focus("room");
                  }
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return showDeleteOptions();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(DeleteOptions, {
                  onSelect: () => {
                    __CJS__export_default__.focus("room");
                    setShowDeleteOptions(false);
                  }
                });
              }
            });
          }
        })];
      }
      function ReplyBase$1(props) {
        return (() => {
          var _el$6 = _tmpl$3$2(), _el$7 = _el$6.firstChild, _el$8 = _el$7.nextSibling, _el$9 = _el$8.firstChild, _el$10 = _el$9.firstChild, _el$11 = _el$9.nextSibling, _el$12 = _el$11.firstChild;
          insert(_el$10, () => props.title);
          insert(_el$12, () => props.children);
          createRenderEffect((_p$) => {
            var _v$5 = styles$d.reply, _v$6 = styles$d.reply_border, _v$7 = styles$d.reply_details, _v$8 = styles$d.reply_username, _v$9 = styles$d.reply_text;
            _v$5 !== _p$.e && className(_el$6, _p$.e = _v$5);
            _v$6 !== _p$.t && className(_el$7, _p$.t = _v$6);
            _v$7 !== _p$.a && className(_el$8, _p$.a = _v$7);
            _v$8 !== _p$.o && className(_el$9, _p$.o = _v$8);
            _v$9 !== _p$.i && className(_el$11, _p$.i = _v$9);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0
          });
          return _el$6;
        })();
      }
      function ReplyMessage$1(props) {
        const text2 = useStore(() => props.$.text);
        return createComponent(ReplyBase$1, {
          get title() {
            return (() => {
              var _el$13 = _tmpl$4$2();
              insert(_el$13, () => props.$.sender.displayName);
              createRenderEffect((_$p) => (_$p = `var(--peer-avatar-${getColorFromPeer(props.$.sender.raw)}-bottom)`) != null ? _el$13.style.setProperty("color", _$p) : _el$13.style.removeProperty("color"));
              return _el$13;
            })();
          },
          get children() {
            return createComponent(ModifyString, {
              get text() {
                return text2();
              }
            });
          }
        });
      }
      function DeletedReplyMessage$1() {
        return createComponent(ReplyBase$1, {
          title: "Deleted Message",
          children: "???"
        });
      }
      function LoadingReplyMessage$1() {
        return createComponent(ReplyBase$1, {
          title: "Loading...",
          children: "???"
        });
      }
      function UsernameContainer(props) {
        return (() => {
          var _el$14 = _tmpl$$7(), _el$15 = _el$14.firstChild, _el$16 = _el$15.firstChild;
          insert(_el$16, () => props.children);
          createRenderEffect((_p$) => {
            var _v$10 = styles$d.username, _v$11 = styles$d.username_inner, _v$12 = `var(--peer-avatar-${getColorFromPeer(props.peer)}-bottom)`;
            _v$10 !== _p$.e && className(_el$14, _p$.e = _v$10);
            _v$11 !== _p$.t && className(_el$15, _p$.t = _v$11);
            _v$12 !== _p$.a && ((_p$.a = _v$12) != null ? _el$16.style.setProperty("color", _v$12) : _el$16.style.removeProperty("color"));
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          return _el$14;
        })();
      }
      function MessageAdditionalInfo$1(props) {
        const {
          message: message2,
          dialog: dialog2,
          isOutgoing
        } = useMessageContext();
        const edited2 = useStore(() => message2().editDate);
        const check2 = useMessageChecks(message2, dialog2);
        let divRef;
        createEffect(() => {
          edited2();
          check2();
          props.setWidth(divRef.offsetWidth);
        });
        return (() => {
          var _el$17 = _tmpl$6$1();
          var _ref$3 = divRef;
          typeof _ref$3 === "function" ? use(_ref$3, _el$17) : divRef = _el$17;
          insert(_el$17, createComponent(Show, {
            get when() {
              return createMemo(() => !!edited2())() && !message2().$.hideEditMark;
            },
            get children() {
              var _el$18 = _tmpl$5$2();
              createRenderEffect(() => className(_el$18, styles$d.edited));
              return _el$18;
            }
          }), null);
          insert(_el$17, createComponent(Show, {
            get when() {
              return isOutgoing();
            },
            get children() {
              var _el$19 = _tmpl$6$1();
              insert(_el$19, createComponent(TelegramIcon, {
                get name() {
                  return check2() ? "check" : "checks";
                }
              }));
              createRenderEffect(() => className(_el$19, styles$d.info_check));
              return _el$19;
            }
          }), null);
          createRenderEffect(() => className(_el$17, styles$d.message_info));
          return _el$17;
        })();
      }
      function MessageAction() {
        const {
          text: text2,
          actionType
        } = useMessageContext();
        return createComponent(Show, {
          get when() {
            return createMemo(() => actionType() != "history_cleared")() && actionType() != "contact_joined";
          },
          get children() {
            return createComponent(ActionMessage, {
              get children() {
                return text2();
              }
            });
          }
        });
      }
      function MessageItem(props) {
        const {
          text: text2,
          entities,
          reply: reply2,
          mediaType,
          showUsername: showUsername2,
          showDateSeparator
        } = useMessageContext();
        const [isOverflowing, setOverflowing] = createSignal(false);
        let textWrapRef;
        createEffect(() => {
          text2();
          textWrapRef && setOverflowing(isOverflown(textWrapRef));
        });
        const [infoWidth, setInfoWidth] = createSignal(0);
        return [createComponent(Show, {
          get when() {
            return showDateSeparator();
          },
          children: (res) => createComponent(ActionMessage, {
            get children() {
              return createMemo(() => res() === 1)() ? "YESTERDAY" : createMemo(() => res() == 2)() ? "TODAY" : props.$.date.toLocaleDateString(navigator.language, {
                month: "long",
                day: "2-digit",
                year: "numeric"
              }).toUpperCase();
            }
          })
        }), createComponent(Show, {
          get when() {
            return props.$.$.action;
          },
          get fallback() {
            return createComponent(MessageContainer, {
              get children() {
                return [createComponent(Show, {
                  get when() {
                    return showUsername2();
                  },
                  get children() {
                    return createComponent(UsernameContainer, {
                      get peer() {
                        return props.$.sender.raw;
                      },
                      get children() {
                        return props.$.sender.displayName;
                      }
                    });
                  }
                }), createComponent(Switch, {
                  get children() {
                    return [createComponent(Match, {
                      get when() {
                        return createMemo(() => !!props.$.isReply())() && reply2() === void 0;
                      },
                      get children() {
                        return createComponent(LoadingReplyMessage$1, {});
                      }
                    }), createComponent(Match, {
                      get when() {
                        return reply2() === 0;
                      },
                      get children() {
                        return createComponent(DeletedReplyMessage$1, {});
                      }
                    }), createComponent(Match, {
                      get when() {
                        return reply2();
                      },
                      get children() {
                        return createComponent(ReplyMessage$1, {
                          get $() {
                            return reply2();
                          }
                        });
                      }
                    })];
                  }
                }), createComponent(Dynamic, {
                  get component() {
                    return switchMessageMedia(mediaType());
                  }
                }), createComponent(Show, {
                  get when() {
                    return createMemo(() => !!!props.$.isSticker)() && (entities().entities || entities().text);
                  },
                  get children() {
                    return [(() => {
                      var _el$20 = _tmpl$8$1(), _el$21 = _el$20.firstChild, _el$22 = _el$21.firstChild, _el$23 = _el$22.firstChild;
                      var _ref$4 = textWrapRef;
                      typeof _ref$4 === "function" ? use(_ref$4, _el$21) : textWrapRef = _el$21;
                      insert(_el$22, () => createComponent(Markdown, {
                        get entities() {
                          return entities();
                        }
                      }), _el$23);
                      insert(_el$21, createComponent(Show, {
                        get when() {
                          return isOverflowing();
                        },
                        get children() {
                          var _el$24 = _tmpl$7$1(), _el$25 = _el$24.firstChild, _el$26 = _el$25.nextSibling, _el$27 = _el$26.firstChild, _el$28 = _el$27.nextSibling;
                          createRenderEffect((_p$) => {
                            var _v$13 = styles$d.more_container, _v$14 = styles$d.more_fade, _v$15 = styles$d.more_button, _v$16 = styles$d.extra_width, _v$17 = infoWidth() + "px";
                            _v$13 !== _p$.e && className(_el$24, _p$.e = _v$13);
                            _v$14 !== _p$.t && className(_el$25, _p$.t = _v$14);
                            _v$15 !== _p$.a && className(_el$26, _p$.a = _v$15);
                            _v$16 !== _p$.o && className(_el$28, _p$.o = _v$16);
                            _v$17 !== _p$.i && ((_p$.i = _v$17) != null ? _el$28.style.setProperty("width", _v$17) : _el$28.style.removeProperty("width"));
                            return _p$;
                          }, {
                            e: void 0,
                            t: void 0,
                            a: void 0,
                            o: void 0,
                            i: void 0
                          });
                          return _el$24;
                        }
                      }), null);
                      createRenderEffect((_p$) => {
                        var _v$18 = styles$d.text_container, _v$19 = styles$d.text_wrap, _v$20 = styles$d.text, _v$21 = styles$d.extra_width, _v$22 = infoWidth() + "px";
                        _v$18 !== _p$.e && className(_el$20, _p$.e = _v$18);
                        _v$19 !== _p$.t && className(_el$21, _p$.t = _v$19);
                        _v$20 !== _p$.a && className(_el$22, _p$.a = _v$20);
                        _v$21 !== _p$.o && className(_el$23, _p$.o = _v$21);
                        _v$22 !== _p$.i && ((_p$.i = _v$22) != null ? _el$23.style.setProperty("width", _v$22) : _el$23.style.removeProperty("width"));
                        return _p$;
                      }, {
                        e: void 0,
                        t: void 0,
                        a: void 0,
                        o: void 0,
                        i: void 0
                      });
                      return _el$20;
                    })(), createComponent(MessageAdditionalInfo$1, {
                      setWidth: setInfoWidth
                    })];
                  }
                })];
              }
            });
          },
          get children() {
            return createComponent(MessageAction, {});
          }
        })];
      }
      function WhenMounted(props) {
        onMount(() => {
          props.onMount();
        });
        return createMemo(() => props.children);
      }
      function TextBoxOptionsWrap(props) {
        const tg = client();
        const text2 = () => props.text;
        const showOptions = () => props.showOptions;
        const showEmojiPicker = () => props.showEmojiPicker;
        const showInsertMenu = () => props.showInsertMenu;
        const interacting = createMemo(() => {
          const editing = editingMessage();
          const replying = replyingMessage();
          return editing || replying;
        });
        const [showVoiceRecorder, setShowVoiceRecorder] = createSignal(false);
        let audioBlob;
        let audioWaveform;
        let audioDuration;
        return [createComponent(Show, {
          get when() {
            return showVoiceRecorder();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(VoiceRecorderWeb, {
                  setAudioBlob: (blob, waveform2, duration2) => {
                    audioBlob = blob;
                    audioWaveform = waveform2;
                    audioDuration = duration2;
                  },
                  onComplete: (send) => __async(this, null, function* () {
                    setShowVoiceRecorder(false);
                    yield sleep$1(5);
                    props.textboxRef.focus();
                    if (send) {
                      const dialog2 = props.dialog;
                      const replying = replyingMessage();
                      batch(() => {
                        setEditingMessage(null);
                        setReplyingMessage(null);
                      });
                      sleep$1(0).then(() => {
                        var _a3;
                        (_a3 = document.querySelector(".roomTextbox")) == null ? void 0 : _a3.focus();
                      });
                      if (replying) {
                        tg.replyMedia(replying.$, voice$2(audioBlob, {
                          duration: audioDuration,
                          waveform: audioWaveform
                        })).then((msg) => {
                          dialog2.lastMessage.set(dialog2.messages.add(msg));
                        });
                        return;
                      }
                      tg.sendMedia(props.dialog.$.chat, voice$2(audioBlob, {
                        duration: audioDuration,
                        waveform: audioWaveform
                      })).then((msg) => {
                        dialog2.lastMessage.set(dialog2.messages.add(msg));
                      });
                    }
                  })
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return showOptions();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(TextboxOptions, {
                  get canSend() {
                    return !!text2();
                  },
                  onSelect: (e2) => __async(this, null, function* () {
                    yield sleep$1(100);
                    props.setShowOptions(false);
                    if (e2 == 6) {
                      batch(() => {
                        setPreviousView("room");
                        setView("settings");
                      });
                      return;
                    }
                    if (!interacting()) {
                      __CJS__export_default__.focus("room");
                    }
                    if (e2 === null) {
                      props.textboxRef.focus();
                      return;
                    }
                    const dialog2 = props.dialog;
                    switch (e2) {
                      case 3: {
                        const text22 = sessionStorage.getItem("copy");
                        sessionStorage.removeItem("copy");
                        if (text22)
                          typeInTextbox(text22, props.textboxRef);
                        break;
                      }
                      case 4: {
                        sessionStorage.setItem("copy", text2());
                        break;
                      }
                      case 5: {
                        showKaiAd();
                        break;
                      }
                      case 0:
                        if (!interacting()) {
                          tg.sendText(props.dialog.$.chat, md(text2()), {}).then((msg) => {
                            dialog2.lastMessage.set(dialog2.messages.add(msg));
                          });
                        } else {
                          const editing = editingMessage();
                          const replying = replyingMessage();
                          batch(() => {
                            setEditingMessage(null);
                            setReplyingMessage(null);
                          });
                          if (editing) {
                            tg.editMessage({
                              message: editing.$,
                              text: md(text2())
                            }).then((msg) => {
                              dialog2.messages.update(msg.id, msg);
                            });
                          } else if (replying) {
                            tg.replyText(replying.$, md(text2()), {
                              shouldDispatch: true
                            }).then((msg) => {
                            });
                            sleep$1(0).then(() => {
                              var _a3;
                              (_a3 = document.querySelector(".roomTextbox")) == null ? void 0 : _a3.focus();
                            });
                          }
                        }
                        props.textboxRef.textContent = "";
                        props.textboxRef.appendChild(_tmpl$9());
                        props.textboxRef.dispatchEvent(new Event("input", {
                          bubbles: true
                        }));
                        __CJS__export_default__.focus("room");
                        break;
                      case 1:
                        batch(() => {
                          setEditingMessage(null);
                          setReplyingMessage(null);
                        });
                        __CJS__export_default__.focus("room");
                        break;
                    }
                  })
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return showEmojiPicker();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(EmojiPicker, {
                  onSelect: (e2) => __async(this, null, function* () {
                    yield sleep$1(100);
                    props.setShowEmojiPicker(false);
                    props.textboxRef.focus();
                    yield sleep$1(1);
                    if (e2) {
                      typeInTextbox(e2, props.textboxRef);
                    }
                  })
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return showInsertMenu();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(InsertMenu, {
                  onSelect: (e2) => __async(this, null, function* () {
                    yield sleep$1(2);
                    props.setShowInsertMenu(false);
                    switch (e2) {
                      case InsertMenuSelected.EMOJI:
                        props.setShowEmojiPicker(true);
                        return;
                      case InsertMenuSelected.PHOTO: {
                        const input = document.createElement("input");
                        input.type = "file";
                        input.accept = "image/*";
                        input.onchange = () => {
                          props.onPhotoSelect(input.files[0]);
                        };
                        input.click();
                        break;
                      }
                      case InsertMenuSelected.VIDEO: {
                        const input = document.createElement("input");
                        input.type = "file";
                        input.accept = "video/*";
                        input.onchange = () => {
                          props.onVideoSelect(input.files[0]);
                        };
                        input.click();
                        break;
                      }
                      case InsertMenuSelected.VOICE:
                        props.textboxRef.textContent = "";
                        props.textboxRef.appendChild(_tmpl$9());
                        props.textboxRef.dispatchEvent(new Event("input", {
                          bubbles: true
                        }));
                        setShowVoiceRecorder(true);
                        return;
                    }
                    props.textboxRef.focus();
                  })
                });
              }
            });
          }
        })];
      }
      function TextBox(props) {
        const [focused2, setFocused] = createSignal(false);
        let divRef;
        const [showOptions, setShowOptions] = createSignal(false);
        const [showEmojiPicker, setShowEmojiPicker] = createSignal(false);
        const [showInsertMenu, setShowInsertMenu] = createSignal(false);
        const [photoBlob, setPhotoBlob] = createSignal(null);
        const [videoBlob, setVideoBlob] = createSignal(null);
        const tg = client();
        const [text2, setText] = createSignal("");
        let textboxRef;
        const debounced_sendTyping = debounce(() => {
          console.log("SENDING TYPING STATE");
          tg.sendTyping(props.dialog.$.chat);
        }, 2e3);
        const interacting = createMemo(() => {
          const editing = editingMessage();
          const replying = replyingMessage();
          return editing || replying;
        });
        return [createComponent(Show, {
          get when() {
            return photoBlob();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(ImageUpload, {
                  get image() {
                    return photoBlob();
                  },
                  onSend: (e2) => __async(this, null, function* () {
                    const blob = photoBlob();
                    setPhotoBlob(null);
                    yield sleep$1(0);
                    textboxRef.focus();
                    if (e2 === false)
                      return;
                    const dialog2 = props.dialog;
                    tg.sendMedia(dialog2.$.chat, photo$4(blob, e2 ? {
                      caption: e2
                    } : {})).then((msg) => {
                      dialog2.lastMessage.set(dialog2.messages.add(msg));
                    });
                  })
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return videoBlob();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(ImageUpload, {
                  get image() {
                    return videoBlob();
                  },
                  isVideo: true,
                  onSend: (e2) => __async(this, null, function* () {
                    const originalBlob = videoBlob();
                    const blob = originalBlob.type.includes("3gp") ? new File([originalBlob], originalBlob.name ? originalBlob.name.slice(0, -4) + ".mp4" : "video.mp4", {
                      type: "video/mp4"
                    }) : originalBlob;
                    setVideoBlob(null);
                    yield sleep$1(0);
                    textboxRef.focus();
                    if (e2 === false)
                      return;
                    const dialog2 = props.dialog;
                    console.error(e2);
                    const upload = new TempFileUploading();
                    temp_setUploadingFiles((e22) => e22.concat(upload));
                    tg.sendMedia(dialog2.$.chat, video$2(blob, e2 ? {
                      caption: e2
                    } : {}), {
                      progressCallback(uploaded, total) {
                        upload.progress.set(Math.ceil(uploaded / total * 100));
                      }
                    }).then((msg) => {
                      dialog2.lastMessage.set(dialog2.messages.add(msg));
                    });
                  })
                });
              }
            });
          }
        }), (() => {
          var _el$31 = _tmpl$6$1();
          var _ref$5 = divRef;
          typeof _ref$5 === "function" ? use(_ref$5, _el$31) : divRef = _el$31;
          insert(_el$31, createComponent(AutoResizeTextbox, {
            onBlur: () => {
              setFocused(false);
            },
            ref(r$) {
              var _ref$6 = textboxRef;
              typeof _ref$6 === "function" ? _ref$6(r$) : textboxRef = r$;
            },
            onFocus: () => {
              setFocused(true);
              divRef.scrollIntoView(true);
              setSoftkeys("tg:add", "Enter", "tg:more");
              const dialog2 = props.dialog;
              dialog2.$.chat.isAdmin;
              dialog2.readHistory();
            },
            onInput: (e2) => {
              debounced_sendTyping();
              divRef.scrollIntoView(true);
              setText(getTextFromContentEditable(e2.currentTarget));
              sleep$1(0).then(() => {
                divRef.scrollIntoView(true);
              });
            },
            classList: {
              focusable: true,
              last: true,
              roomTextbox: true
            },
            placeholder: "Message",
            onKeyDown: (e2) => {
              const canUseKeyboard = !getTextFromContentEditable(e2.currentTarget) || isSelectionAtStart();
              if (e2.key == "Backspace" && canUseKeyboard) {
                setView("home");
                e2.preventDefault();
                return;
              }
              if (e2.key.includes("Arrow")) {
                if (e2.key == "ArrowUp" && canUseKeyboard)
                  return;
                e2.stopImmediatePropagation();
                e2.stopPropagation();
              }
              if (e2.key == "SoftRight") {
                setShowOptions(true);
              }
              if (e2.key == "SoftLeft") {
                setShowInsertMenu(true);
              }
            }
          }));
          createRenderEffect((_p$) => {
            var _v$23 = interacting() ? {
              display: "none"
            } : void 0, _v$24 = {
              [styles$d.textarea_container]: true,
              [styles$d.focused]: focused2()
            };
            _p$.e = style(_el$31, _v$23, _p$.e);
            _p$.t = classList$1(_el$31, _v$24, _p$.t);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$31;
        })(), createComponent(TextBoxOptionsWrap, {
          get text() {
            return text2();
          },
          onPhotoSelect: setPhotoBlob,
          onVideoSelect: setVideoBlob,
          get showOptions() {
            return showOptions();
          },
          setShowOptions,
          get showEmojiPicker() {
            return showEmojiPicker();
          },
          setShowEmojiPicker,
          get showInsertMenu() {
            return showInsertMenu();
          },
          setShowInsertMenu,
          get dialog() {
            return props.dialog;
          },
          textboxRef
        })];
      }
      const ONE_FOCUSABLE = ".focusable";
      const TWO_FOCUSABLE = ONE_FOCUSABLE.repeat(2);
      let lastUsedFocusableClass = TWO_FOCUSABLE;
      function refreshFocusables() {
        __CJS__export_default__.remove("room");
        const focusableToUse = lastUsedFocusableClass = lastUsedFocusableClass == ONE_FOCUSABLE ? TWO_FOCUSABLE : ONE_FOCUSABLE;
        __CJS__export_default__.add("room", {
          selector: `.${styles$d.room} ${focusableToUse}, .${styles$d.room} .last${focusableToUse}`,
          rememberSource: true,
          enterTo: "last-focused",
          restrict: "self-only",
          defaultElement: `.${styles$d.room} .last${focusableToUse}`
        });
      }
      function Messages(props) {
        const messages = useStore(() => props.dialog.messages.sorted);
        const loading2 = useStore(() => props.dialog.messages.isLoading);
        createEffect(() => {
          const _ = loading2();
          if (_) {
            setSoftkeys("", "Loading...", "", true);
          }
        });
        let divRef;
        onMount(() => {
          refreshFocusables();
        });
        createEffect(() => {
          const inView = currentView() == "room";
          if (inView && !loading2()) {
            sleep$1(100).then(() => __CJS__export_default__.focus("room"));
          }
        });
        onCleanup(() => {
          __CJS__export_default__.remove("room");
        });
        return (() => {
          var _el$32 = _tmpl$6$1();
          var _ref$7 = divRef;
          typeof _ref$7 === "function" ? use(_ref$7, _el$32) : divRef = _el$32;
          insert(_el$32, createComponent(Show, {
            get when() {
              return !loading2();
            },
            get children() {
              return [createComponent(WhenMounted, {
                onMount: () => {
                  divRef.scrollTop = divRef.scrollHeight;
                  sleep$1(10).then(() => {
                    __CJS__export_default__.focus("room");
                  });
                },
                get children() {
                  return createComponent(For, {
                    get each() {
                      return messages();
                    },
                    children: (e2, index) => createComponent(MessageProvider, {
                      get last() {
                        return index() == messages().length - 1;
                      },
                      get dialog() {
                        return props.dialog;
                      },
                      $: e2,
                      get before() {
                        return messages()[index() - 1];
                      },
                      get children() {
                        return createComponent(MessageItem, {
                          get last() {
                            return index() == messages().length - 1;
                          },
                          get dialog() {
                            return props.dialog;
                          },
                          $: e2,
                          get before() {
                            return messages()[index() - 1];
                          }
                        });
                      }
                    })
                  });
                }
              }), createComponent(Show, {
                get when() {
                  return chat().chatType !== "channel";
                },
                get children() {
                  return createComponent(TextBox, {
                    get dialog() {
                      return props.dialog;
                    }
                  });
                }
              })];
            }
          }));
          createRenderEffect((_p$) => {
            var _v$25 = styles$d.room, _v$26 = void 0;
            _v$25 !== _p$.e && className(_el$32, _p$.e = _v$25);
            _p$.t = style(_el$32, _v$26, _p$.t);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$32;
        })();
      }
      function UserStatusIndicator(props) {
        const userStatus = () => userStatusJar.get(props.userId);
        const lastOnline = useStore(() => userStatus().lastOnline);
        const status = useStore(() => userStatus().status);
        return createComponent(Show, {
          get when() {
            return lastOnline();
          },
          get fallback() {
            return createMemo(() => status() == "long_time_ago")() ? "offline" : status();
          },
          get children() {
            return ["Last online on ", createMemo(() => timeStamp(lastOnline()))];
          }
        });
      }
      function FloatingTextbox(props) {
        const [showOptions, setShowOptions] = createSignal(false);
        const [showEmojiPicker, setShowEmojiPicker] = createSignal(false);
        const [showInsertMenu, setShowInsertMenu] = createSignal(false);
        const tg = client();
        let textboxRef;
        const [text2, setText] = createSignal("");
        const [photoBlob, setPhotoBlob] = createSignal(null);
        const [videoBlob, setVideoBlob] = createSignal(null);
        const debounced_sendTyping = debounce(() => {
          console.log("SENDING TYPING STATE");
          tg.sendTyping(props.dialog.$.chat);
        }, 2e3, {
          leading: true,
          maxWait: 1
        });
        onMount(() => {
          setTimeout(() => {
            textboxRef.focus();
            const edit = editingMessage();
            if (edit) {
              typeInTextbox(md.unparse(edit.$.textWithEntities), textboxRef);
            }
          }, 100);
        });
        return [createComponent(Show, {
          get when() {
            return photoBlob();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(ImageUpload, {
                  get image() {
                    return photoBlob();
                  },
                  onSend: (e2) => __async(this, null, function* () {
                    const blob = photoBlob();
                    setPhotoBlob(null);
                    yield sleep$1(0);
                    textboxRef.focus();
                    if (e2 === false)
                      return;
                    const dialog2 = props.dialog;
                    const replying = replyingMessage();
                    batch(() => {
                      setEditingMessage(null);
                      setReplyingMessage(null);
                    });
                    sleep$1(0).then(() => {
                      var _a3;
                      (_a3 = document.querySelector(".roomTextbox")) == null ? void 0 : _a3.focus();
                    });
                    if (replying) {
                      tg.replyMedia(replying.$, photo$4(blob, e2 ? {
                        caption: e2
                      } : {})).then((msg) => {
                        dialog2.lastMessage.set(dialog2.messages.add(msg));
                      });
                      return;
                    }
                    tg.sendMedia(dialog2.$.chat, photo$4(blob, e2 ? {
                      caption: e2
                    } : {})).then((msg) => {
                      dialog2.lastMessage.set(dialog2.messages.add(msg));
                    });
                  })
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return videoBlob();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(ImageUpload, {
                  get image() {
                    return videoBlob();
                  },
                  isVideo: true,
                  onSend: (e2) => __async(this, null, function* () {
                    const originalBlob = videoBlob();
                    const blob = originalBlob.type.includes("3gp") ? new File([originalBlob], originalBlob.name ? originalBlob.name.slice(0, -4) + ".mp4" : "video.mp4", {
                      type: "video/mp4"
                    }) : originalBlob;
                    setVideoBlob(null);
                    yield sleep$1(0);
                    textboxRef.focus();
                    if (e2 === false)
                      return;
                    const dialog2 = props.dialog;
                    const replying = replyingMessage();
                    batch(() => {
                      setEditingMessage(null);
                      setReplyingMessage(null);
                    });
                    sleep$1(0).then(() => {
                      var _a3;
                      (_a3 = document.querySelector(".roomTextbox")) == null ? void 0 : _a3.focus();
                    });
                    const upload = new TempFileUploading();
                    temp_setUploadingFiles((e22) => e22.concat(upload));
                    if (replying) {
                      tg.replyMedia(replying.$, video$2(blob, e2 ? {
                        caption: e2
                      } : {}), {
                        progressCallback(uploaded, total) {
                          upload.progress.set(Math.ceil(uploaded / total * 100));
                        }
                      }).then((msg) => {
                        dialog2.lastMessage.set(dialog2.messages.add(msg));
                      });
                    } else {
                      tg.sendMedia(dialog2.$.chat, video$2(blob, e2 ? {
                        caption: e2
                      } : {}), {
                        progressCallback(uploaded, total) {
                          upload.progress.set(Math.ceil(uploaded / total * 100));
                        }
                      }).then((msg) => {
                        dialog2.lastMessage.set(dialog2.messages.add(msg));
                      });
                    }
                  })
                });
              }
            });
          }
        }), (() => {
          var _el$33 = _tmpl$10(), _el$34 = _el$33.firstChild;
          insert(_el$34, createComponent(ReplyMessage$1, {
            get $() {
              return props.message;
            }
          }));
          insert(_el$33, createComponent(AutoResizeTextbox, {
            ref(r$) {
              var _ref$8 = textboxRef;
              typeof _ref$8 === "function" ? _ref$8(r$) : textboxRef = r$;
            },
            onInput: (e2) => {
              debounced_sendTyping();
              setText(getTextFromContentEditable(e2.currentTarget));
            },
            placeholder: "Message",
            onFocus: () => {
              setSoftkeys("tg:add", "Enter", "tg:more");
            },
            onKeyDown: (e2) => {
              const canUseKeyboard = !getTextFromContentEditable(e2.currentTarget) || isSelectionAtStart();
              if (e2.key == "Backspace" && canUseKeyboard) {
                batch(() => {
                  setEditingMessage(null);
                  setReplyingMessage(null);
                });
                __CJS__export_default__.focus("room");
                e2.preventDefault();
                return;
              }
              if (e2.key.includes("Arrow")) {
                if (e2.key == "ArrowUp" && canUseKeyboard)
                  return;
                e2.stopImmediatePropagation();
                e2.stopPropagation();
              }
              if (e2.key == "SoftRight") {
                setShowOptions(true);
              }
              if (e2.key == "SoftLeft") {
                setShowInsertMenu(true);
              }
            }
          }), null);
          createRenderEffect((_p$) => {
            var _v$27 = {
              [styles$d.floating_textbox]: true,
              [styles$d.focused]: true
            }, _v$28 = `var(--peer-avatar-${getColorFromPeer(props.message.sender.raw)}-bottom)`;
            _p$.e = classList$1(_el$33, _v$27, _p$.e);
            _v$28 !== _p$.t && ((_p$.t = _v$28) != null ? _el$34.style.setProperty("--border", _v$28) : _el$34.style.removeProperty("--border"));
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$33;
        })(), createComponent(TextBoxOptionsWrap, {
          get text() {
            return text2();
          },
          onPhotoSelect: setPhotoBlob,
          get showOptions() {
            return showOptions();
          },
          setShowOptions,
          get showEmojiPicker() {
            return showEmojiPicker();
          },
          setShowEmojiPicker,
          get showInsertMenu() {
            return showInsertMenu();
          },
          setShowInsertMenu,
          get dialog() {
            return props.dialog;
          },
          textboxRef,
          onVideoSelect: setVideoBlob
        })];
      }
      const typingStatusDictionaryForPrivateChats = {
        typing: "typing",
        upload_voice: "sending file",
        upload_document: "sending file",
        upload_photo: "sending a photo",
        upload_video: "sending a video",
        upload_round: "sending a video",
        record_video: "recording video",
        record_voice: "recording voice",
        record_round: "recording video",
        game: "playing a game",
        sticker: "choosing a sticker"
      };
      function typingStatusToEnglish(status) {
        return typingStatusDictionaryForPrivateChats[status] || status;
      }
      function PrivateChatBottomHeader(props) {
        const typingStatus = useStore(() => typingIndicatorUserJar.get(props.userId).status);
        return createComponent(Show, {
          get when() {
            return typingStatus() === null;
          },
          get fallback() {
            return [createMemo(() => typingStatusToEnglish(typingStatus())), "..."];
          },
          get children() {
            return createComponent(UserStatusIndicator, {
              get userId() {
                return props.userId;
              }
            });
          }
        });
      }
      function Room(props) {
        const interacting = createMemo(() => {
          const editing = editingMessage();
          const replying = replyingMessage();
          return editing || replying;
        });
        createEffect(() => {
          const tg = client();
          if (!tg)
            return;
          const _room = room$1();
          if (_room) {
            tg.openChat(_room);
            onCleanup(() => {
              tg.closeChat(_room);
            });
          }
        });
        return createComponent(Show, {
          get when() {
            return chat();
          },
          children: (chat2) => createComponent(Content, {
            get before() {
              return (() => {
                var _el$35 = _tmpl$3$2(), _el$36 = _el$35.firstChild, _el$37 = _el$36.nextSibling, _el$38 = _el$37.firstChild, _el$39 = _el$38.firstChild, _el$40 = _el$38.nextSibling, _el$41 = _el$40.firstChild;
                insert(_el$36, createComponent(ChatPhotoIcon, {
                  get chat() {
                    return chat2();
                  }
                }));
                insert(_el$39, (() => {
                  var _c$ = createMemo(() => !!chat2().isSelf);
                  return () => _c$() ? "Saved Messages" : chat2().displayName;
                })());
                insert(_el$41, createComponent(Show, {
                  get when() {
                    return chat2().chatType != "private";
                  },
                  get fallback() {
                    return createComponent(Show, {
                      get when() {
                        return createMemo(() => !!(!chat2().isSupport && chat2().peer._ == "user"))() && !chat2().peer.bot;
                      },
                      get children() {
                        return createComponent(PrivateChatBottomHeader, {
                          get userId() {
                            return chat2().peer.id;
                          }
                        });
                      }
                    });
                  },
                  get children() {
                    return [createMemo(() => getMembersCount(chat2())), " ", createMemo(() => chat2().chatType == "channel" ? "Subscribers" : "Members")];
                  }
                }));
                createRenderEffect((_p$) => {
                  var _v$29 = styles$d.header, _v$30 = styles$d.avatar, _v$31 = styles$d.details, _v$32 = styles$d.top, _v$33 = styles$d.bottom;
                  _v$29 !== _p$.e && className(_el$35, _p$.e = _v$29);
                  _v$30 !== _p$.t && className(_el$36, _p$.t = _v$30);
                  _v$31 !== _p$.a && className(_el$37, _p$.a = _v$31);
                  _v$32 !== _p$.o && className(_el$38, _p$.o = _v$32);
                  _v$33 !== _p$.i && className(_el$40, _p$.i = _v$33);
                  return _p$;
                }, {
                  e: void 0,
                  t: void 0,
                  a: void 0,
                  o: void 0,
                  i: void 0
                });
                return _el$35;
              })();
            },
            get hidden() {
              return props.hidden;
            },
            get after() {
              return createComponent(Show, {
                get when() {
                  return uiDialog();
                },
                children: (dialog2) => createComponent(Show, {
                  get when() {
                    return interacting();
                  },
                  children: (msg) => createComponent(FloatingTextbox, {
                    get dialog() {
                      return dialog2();
                    },
                    get message() {
                      return msg();
                    }
                  })
                })
              });
            },
            get mainClass() {
              return styles$d.room_wrap;
            },
            get children() {
              return createComponent(Show, {
                get when() {
                  return uiDialog();
                },
                children: (dialog2) => createComponent(Messages, {
                  get dialog() {
                    return dialog2();
                  }
                })
              });
            }
          })
        });
      }
      delegateEvents(["keydown"]);
      const zoom = "_zoom_723zn_1";
      const contain = "_contain_723zn_10";
      const no_contain = "_no_contain_723zn_14";
      const transition = "_transition_723zn_18";
      const visible = "_visible_723zn_22";
      const hidden = "_hidden_723zn_26";
      const styles$5 = {
        zoom,
        contain,
        no_contain,
        transition,
        visible,
        hidden
      };
      class Matrix {
        constructor(svg2) {
          this.svg = svg2 || document.createElementNS("http://www.w3.org/2000/svg", "svg");
          this.vtm = this.createSVGMatrix();
          this.x = 0;
          this.y = 0;
          this.captureScale = 1;
        }
        clamp(scale, in_x, in_y, ratio) {
          let xx = (window.innerWidth - ratio.width) / 2;
          let yy = (window.innerHeight - ratio.height) / 2;
          let limit_max_right_formula = xx * scale + ratio.width * scale - window.innerWidth;
          let same_x = Math.min(this.vtm.e * 1, 0);
          let same_y = Math.min(this.vtm.f * 1, 0);
          let value1 = in_x > 0 ? same_x : -(xx * scale);
          let value2 = in_x > 0 ? same_x : -limit_max_right_formula;
          let limit_x_axis = this.vtm.e;
          limit_x_axis = Math.max(value2, this.vtm.e);
          limit_x_axis = Math.min(value1, limit_x_axis);
          let limit_max_bottom_formula = yy * scale + ratio.height * scale - window.innerHeight;
          let limit_max_top = in_y > 0 ? same_y : -(yy * scale);
          let limit_max_bottom = in_y > 0 ? same_y : -limit_max_bottom_formula;
          let limit_y_axis = this.vtm.f;
          limit_y_axis = Math.min(limit_max_top, limit_y_axis);
          limit_y_axis = Math.max(limit_y_axis, limit_max_bottom);
          this.vtm = this.createSVGMatrix().translate(limit_x_axis, limit_y_axis).scale(Math.max(this.vtm.a, 1));
        }
        createSVGMatrix() {
          return this.svg.createSVGMatrix();
        }
        move(x, y, in_x, in_y, ratio) {
          this.vtm = this.createSVGMatrix().translate(this.x - x, this.y - y).scale(this.vtm.a);
          this.clamp(this.vtm.a, in_x, in_y, ratio);
          return this.vtm;
        }
        scale(xFactor, yFactor, origin, in_x, in_y, ratio, max2, value, dir) {
          if ((value >= max2 || this.stop) && dir === 1) {
            this.stop = true;
            if (!this.deb) {
              this.captureScale = this.vtm.a;
              this.vtm = this.createSVGMatrix().translate(origin.x, origin.y).scale(max2 / this.captureScale).translate(-origin.x, -origin.y).translate(this.vtm.e, this.vtm.f).scale(this.captureScale);
              this.deb = true;
            }
            return this.vtm;
          } else {
            this.stop = false;
          }
          this.vtm = this.createSVGMatrix().translate(origin.x, origin.y).scale(xFactor, yFactor).translate(-origin.x, -origin.y).multiply(this.vtm);
          let pre_scale = Math.min(Math.max(1, this.vtm.a), max2);
          this.clamp(pre_scale, in_x, in_y, ratio);
          return this.vtm;
        }
      }
      function calculateAspectRatioFit(srcWidth, srcHeight, maxWidth, maxHeight) {
        var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
        return { width: srcWidth * ratio, height: srcHeight * ratio, ratio };
      }
      var _tmpl$$6 = /* @__PURE__ */ template(`<img alt=svelte-zoom>`);
      function Zoom(props) {
        var _a3, _b2;
        const [_props, $$props] = splitProps(props, ["maxScale", "scaleValue", "src"]);
        let imgEl;
        const maxScale = (_a3 = _props.maxScale) != null ? _a3 : 11;
        const [transform, setTransform] = createSignal(void 0);
        const [scaleValue, setScaleValue] = createSignal((_b2 = _props.scaleValue) != null ? _b2 : 1);
        const [src, setSrc] = createSignal("");
        createEffect(() => {
          setSrc(_props.src || "");
          let timeout;
          const img = imgEl;
          if (!img)
            return;
          const loaded = () => img.complete && img.naturalHeight !== 0;
          if (!loaded()) {
            timeout = setTimeout(() => __async(this, null, function* () {
              if (!loaded()) {
                setSrc("");
                yield sleep$1(100);
                setSrc(_props.src || "");
              }
            }), 1e3);
          }
          onCleanup(() => {
            clearTimeout(timeout);
          });
        });
        const xY = {
          initX: 0,
          initY: 0,
          newX: 0,
          newY: 0
        };
        const matrix = new Matrix();
        let ratio;
        const [contain2, setContain] = createSignal(null);
        const [smooth, setSmooth] = createSignal(true);
        const [scaling, setScaling] = createSignal(false);
        const fireManualZoom = function(dir) {
          const _matrix = matrix, _ratio = ratio;
          const {
            innerHeight: innerHeight2,
            innerWidth: innerWidth2
          } = window;
          const xFactor = 1 + 0.2 * dir;
          const yFactor = xFactor * innerHeight2 / innerWidth2;
          let in_x = (innerWidth2 - _ratio.width * _matrix.vtm.a) / 2;
          let in_y = (innerHeight2 - _ratio.height * _matrix.vtm.a) / 2;
          const origin = {
            x: innerWidth2 / 2,
            y: innerHeight2 / 2
          };
          const mat = _matrix.scale(xFactor, yFactor, origin, in_x, in_y, _ratio, maxScale, untrack(scaleValue) * xFactor, dir);
          setTransform(`translate(${mat.e}px,${mat.f}px) scale(${mat.d})`);
          setScaleValue(mat.d);
        };
        const moveImage = function(x, y) {
          const {
            innerWidth: innerWidth2,
            innerHeight: innerHeight2
          } = window;
          const [a, b] = [innerWidth2 / 2, innerHeight2 / 2];
          fireDown(a, b);
          setSmooth(false);
          fireMove(a + x, b + y);
          fireUp();
        };
        const zoomIn = () => fireManualZoom(1);
        const zoomOut = () => fireManualZoom(-1);
        const fireUp = function() {
          const _xY = xY, _matrix = matrix;
          _matrix.x -= _xY.newX;
          _matrix.y -= _xY.newY;
          setScaling(false);
          setSmooth(true);
        };
        const fireMove = function(x, y) {
          const _xY = xY, _matrix = matrix, _ratio = ratio;
          if (untrack(scaling))
            return;
          let in_x = (window.innerWidth - _ratio.width * _matrix.vtm.a) / 2;
          let in_y = (window.innerHeight - _ratio.height * _matrix.vtm.a) / 2;
          _xY.newX = _xY.initX - x;
          _xY.newY = _xY.initY - y;
          const mat = _matrix.move(in_x >= 0 ? 0 : _xY.newX, in_y >= 0 ? 0 : _xY.newY, in_x, in_y, _ratio);
          setTransform(`matrix(${mat.a},${mat.b},${mat.c},${mat.d},${mat.e}, ${mat.f})`);
        };
        const fireDown = function(x, y) {
          const _matrix = matrix, _xY = xY;
          _xY.initX = x;
          _xY.initY = y;
          _matrix.x = _matrix.vtm.e;
          _matrix.y = _matrix.vtm.f;
        };
        const zoomRef = {
          zoomIn,
          zoomOut,
          moveImage,
          fireManualZoom,
          scaleValue: scaleValue()
        };
        createEffect(() => {
          zoomRef.scaleValue = scaleValue();
          typeof props.ref == "function" && props.ref(zoomRef);
        });
        onMount(() => {
          const onLoad = (e2) => {
            const {
              naturalWidth,
              naturalHeight
            } = e2.currentTarget;
            const {
              innerHeight: innerHeight2,
              innerWidth: innerWidth2
            } = window;
            setContain(naturalWidth > innerWidth2 || naturalHeight > innerHeight2);
            ratio = calculateAspectRatioFit(naturalWidth, naturalHeight, innerWidth2, innerHeight2);
          };
          imgEl.addEventListener("load", onLoad);
          onCleanup(() => {
            imgEl.removeEventListener("load", onLoad);
          });
        });
        return (() => {
          var _el$ = _tmpl$$6();
          var _ref$ = imgEl;
          typeof _ref$ === "function" ? use(_ref$, _el$) : imgEl = _el$;
          spread(_el$, mergeProps({
            get classList() {
              return {
                [styles$5.zoom]: true,
                [styles$5.contain]: !!contain2(),
                [styles$5.no_contain]: !contain2(),
                [styles$5.transition]: smooth(),
                [styles$5.visible]: !!contain2(),
                [styles$5.hidden]: contain2() === null
              };
            },
            get style() {
              return {
                transform: transform()
              };
            },
            get src() {
              return src();
            }
          }, $$props), false, false);
          return _el$;
        })();
      }
      const viewer$1 = "_viewer_1v3zo_1";
      const pixelated = "_pixelated_1v3zo_13";
      const thumb$1 = "_thumb_1v3zo_21";
      const styles$4 = {
        viewer: viewer$1,
        pixelated,
        thumb: thumb$1
      };
      var _tmpl$$5 = /* @__PURE__ */ template(`<img>`), _tmpl$2$4 = /* @__PURE__ */ template(`<div tabindex=-1>`);
      function ImageViewer(props) {
        let divRef;
        const [progress2, setProgress] = createSignal(0);
        const [src, setSrc] = createSignal("");
        const [thumb2, setThumb] = createSignal("");
        let mounted = true;
        onMount(() => {
          const media2 = props.photo;
          const thumb22 = media2.getThumbnail(Thumbnail.THUMB_STRIP);
          let url2;
          if (thumb22 && "byteLength" in thumb22.location) {
            setThumb(url2 = URL.createObjectURL(new Blob([thumb22.location])));
          }
          onCleanup(() => {
            URL.revokeObjectURL(url2);
          });
        });
        onCleanup(() => {
          mounted = false;
        });
        onMount(() => {
          const download = downloadFile(props.photo.getThumbnail(Thumbnail.THUMB_800x800_BOX) || props.photo);
          let url2;
          const stateChange = () => {
            if (download.state == "done") {
              setProgress(100);
              if (mounted) {
                setSrc(url2 = URL.createObjectURL(download.result));
              }
            }
          };
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
            });
            return;
          }
          function progressChange() {
            setProgress(download.progress);
          }
          download.on("state", stateChange);
          download.on("progress", progressChange);
          onCleanup(() => {
            download.off("progress", progressChange);
            download.off("state", stateChange);
            URL.revokeObjectURL(url2);
          });
          return;
        });
        onMount(() => {
          pauseKeypress();
          __CJS__export_default__.add("image-viewer", {
            restrict: "self-only",
            selector: `.${styles$4.viewer}`
          });
          __CJS__export_default__.focus("image-viewer");
        });
        onCleanup(() => {
          __CJS__export_default__.remove("image-viewer");
          divRef == null ? void 0 : divRef.blur();
          resumeKeypress();
        });
        let zoomRef;
        const [pixelated2, setPixelated] = createSignal(false);
        useKeypress("SoftRight", () => {
          if (zoomRef) {
            if (zoomRef.scaleValue >= 3)
              setPixelated(true);
            if (zoomRef.scaleValue <= 11)
              zoomRef.zoomIn();
          }
        }, true);
        useKeypress("SoftLeft", () => {
          if (zoomRef) {
            if (zoomRef.scaleValue <= 3)
              setPixelated(false);
            zoomRef.zoomOut();
          }
        }, true);
        useKeypress(["Up", "Down", "Left", "Right"].map((a) => "Arrow" + a), ({
          key
        }) => {
          const offset = 50;
          const moveImage = zoomRef == null ? void 0 : zoomRef.moveImage;
          if (!moveImage)
            return;
          switch (key.slice(5)) {
            case "Up":
              moveImage(0, offset);
              break;
            case "Down":
              moveImage(0, -50);
              break;
            case "Left":
              moveImage(offset, 0);
              break;
            case "Right":
              moveImage(-50, -0);
              break;
          }
        }, true);
        useKeypress("Backspace", (e2) => {
          var _a3;
          e2.preventDefault();
          (_a3 = props.onClose) == null ? void 0 : _a3.call(props);
        }, true);
        return (() => {
          var _el$ = _tmpl$2$4();
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$) : divRef = _el$;
          insert(_el$, createComponent(Show, {
            get when() {
              return !src();
            },
            get children() {
              return createComponent(Show, {
                get when() {
                  return thumb2();
                },
                get children() {
                  var _el$2 = _tmpl$$5();
                  createRenderEffect((_p$) => {
                    var _v$ = styles$4.thumb, _v$2 = thumb2();
                    _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
                    _v$2 !== _p$.t && setAttribute(_el$2, "src", _p$.t = _v$2);
                    return _p$;
                  }, {
                    e: void 0,
                    t: void 0
                  });
                  return _el$2;
                }
              });
            }
          }), null);
          insert(_el$, createComponent(Show, {
            get when() {
              return src();
            },
            get children() {
              return createComponent(Zoom, {
                ref: (e2) => {
                  zoomRef = e2;
                },
                get src() {
                  return src();
                }
              });
            }
          }), null);
          insert(_el$, createComponent(Show, {
            get when() {
              return !src();
            },
            get children() {
              return createComponent(ProgressSpinner, {
                size: 50,
                get progress() {
                  return progress2() || 1;
                }
              });
            }
          }), null);
          createRenderEffect((_$p) => classList$1(_el$, {
            [styles$4.viewer]: true,
            [styles$4.pixelated]: pixelated2()
          }, _$p));
          return _el$;
        })();
      }
      const viewer = "_viewer_b2kpr_1";
      const controls = "_controls_b2kpr_15";
      const icon = "_icon_b2kpr_29";
      const progress_wrap = "_progress_wrap_b2kpr_39";
      const progress = "_progress_b2kpr_39";
      const time = "_time_b2kpr_63";
      const progress_spin = "_progress_spin_b2kpr_70";
      const thumb = "_thumb_b2kpr_81";
      const styles$3 = {
        viewer,
        controls,
        icon,
        progress_wrap,
        progress,
        time,
        progress_spin,
        thumb
      };
      var _tmpl$$4 = /* @__PURE__ */ template(`<video>`), _tmpl$2$3 = /* @__PURE__ */ template(`<img>`), _tmpl$3$1 = /* @__PURE__ */ template(`<svg role=img xmlns=http://www.w3.org/2000/svg width=16 height=16 fill=none viewBox="0 0 24 24"><path fill=currentColor d="M9.25 3.35C7.87 2.45 6 3.38 6 4.96v14.08c0 1.58 1.87 2.5 3.25 1.61l10.85-7.04a1.9 1.9 0 0 0 0-3.22L9.25 3.35Z"class>`), _tmpl$4$1 = /* @__PURE__ */ template(`<div tabindex=-1><div><div></div><div> / </div><div><div></div></div><div><svg role=img xmlns=http://www.w3.org/2000/svg width=16 height=16 fill=none viewBox="0 0 24 24"><path fill=currentColor d="M4 6c0-1.1.9-2 2-2h3a1 1 0 0 0 0-2H6a4 4 0 0 0-4 4v3a1 1 0 0 0 2 0V6ZM4 18c0 1.1.9 2 2 2h3a1 1 0 1 1 0 2H6a4 4 0 0 1-4-4v-3a1 1 0 1 1 2 0v3ZM18 4a2 2 0 0 1 2 2v3a1 1 0 1 0 2 0V6a4 4 0 0 0-4-4h-3a1 1 0 1 0 0 2h3ZM20 18a2 2 0 0 1-2 2h-3a1 1 0 1 0 0 2h3a4 4 0 0 0 4-4v-3a1 1 0 1 0-2 0v3Z"class>`), _tmpl$5$1 = /* @__PURE__ */ template(`<svg role=img xmlns=http://www.w3.org/2000/svg width=16 height=16 fill=none viewBox="0 0 24 24"><path fill=currentColor d="M6 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H6ZM15 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-3Z"class>`);
      function rotateScreen(horizontal) {
        return __async(this, null, function* () {
          if ("orientation" in window.screen) {
            try {
              if (horizontal) {
                yield window.screen.orientation.lock("landscape-primary");
              } else {
                yield window.screen.orientation.lock("portrait-primary");
              }
              return true;
            } catch (e2) {
            }
          }
          return false;
        });
      }
      function exitFullscreen() {
        return __async(this, null, function* () {
          rotateScreen(false);
          try {
            if ("exitFullscreen" in document) {
              yield document.exitFullscreen();
            } else if ("mozCancelFullScreen" in document) {
              yield document.mozCancelFullScreen();
            }
          } catch (e2) {
          }
        });
      }
      function toggleFullScreen() {
        if (!document.fullscreenElement && // alternative standard method
        // @ts-ignore
        !document.mozFullScreenElement) {
          if ("requestFullscreen" in document.body) {
            document.body.requestFullscreen();
          } else if ("mozRequestFullScreen" in document.body) {
            document.body.mozRequestFullScreen();
          }
          return true;
        } else {
          exitFullscreen();
          return false;
        }
      }
      function VideoViewer(props) {
        let divRef;
        let player;
        const [duration2, setDuration] = createSignal(0);
        const [time2, setTime] = createSignal(0);
        const [paused, setPaused] = createSignal(true);
        const [poster, setPoster] = createSignal("");
        const [progress2, setProgress] = createSignal(0);
        const [src, setSrc] = createSignal("");
        let mounted = true;
        onMount(() => {
          const media2 = props.video;
          const thumb2 = media2.getThumbnail(Thumbnail.THUMB_320x320_BOX) || media2.getThumbnail(Thumbnail.THUMB_VIDEO_PREVIEW);
          const download = downloadFile(thumb2);
          let url2;
          const stateChange = () => {
            if (download.state == "done" && mounted) {
              setPoster(url2 = URL.createObjectURL(download.result));
            }
          };
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
              download.abort();
            });
            return;
          }
          download.on("state", stateChange);
          onCleanup(() => {
            download.off("state", stateChange);
            download.abort();
            URL.revokeObjectURL(url2);
          });
        });
        onCleanup(() => {
          mounted = false;
        });
        onMount(() => {
          const download = downloadFile(props.video);
          let url2;
          const stateChange = () => {
            if (download.state == "done") {
              setProgress(100);
              if (mounted) {
                setSrc(url2 = URL.createObjectURL(download.result));
              }
            }
          };
          if (download.state == "done") {
            stateChange();
            onCleanup(() => {
              URL.revokeObjectURL(url2);
              download.abort();
            });
            return;
          }
          function progressChange() {
            setProgress(download.progress);
          }
          download.on("state", stateChange);
          download.on("progress", progressChange);
          onCleanup(() => {
            download.off("progress", progressChange);
            download.off("state", stateChange);
            download.abort();
            URL.revokeObjectURL(url2);
          });
        });
        onMount(() => {
          pauseKeypress();
          __CJS__export_default__.add("video-viewer", {
            restrict: "self-only",
            selector: `.${styles$3.viewer}`
          });
          __CJS__export_default__.focus("video-viewer");
        });
        onCleanup(() => {
          __CJS__export_default__.remove("video-viewer");
          divRef == null ? void 0 : divRef.blur();
          clearTimeout(timeout);
          clearTimeout(controlsTimeout);
          resumeKeypress();
        });
        let timeout;
        function handleKeydown(event) {
          var _a3, _b2;
          if (!player)
            return;
          const {
            key
          } = event;
          var step = Math.max(player.duration / 20, 2);
          if (key === "ArrowLeft") {
            player.fastSeek(player.currentTime - step);
          } else if (key === "ArrowRight") {
            player.fastSeek(player.currentTime + step);
          } else if (key == "ArrowUp") {
            (_a3 = navigator.volumeManager) == null ? void 0 : _a3.requestUp();
          } else if (key == "ArrowDown") {
            (_b2 = navigator.volumeManager) == null ? void 0 : _b2.requestDown();
          }
        }
        const progressTime = () => {
          if (time2() && duration2()) {
            return time2() / duration2() * 100;
          }
          return 0;
        };
        const [show, setShow] = createSignal(true);
        let controlsTimeout;
        const controls2 = () => {
          controlsTimeout = setTimeout(() => {
            setShow(paused());
          }, 1e4);
        };
        return (() => {
          var _el$ = _tmpl$4$1(), _el$4 = _el$.firstChild, _el$5 = _el$4.firstChild, _el$7 = _el$5.nextSibling, _el$8 = _el$7.firstChild, _el$9 = _el$7.nextSibling, _el$10 = _el$9.firstChild, _el$11 = _el$9.nextSibling;
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$) : divRef = _el$;
          _el$.$$keyup = () => {
            clearTimeout(controlsTimeout);
            controls2();
          };
          _el$.$$keydown = (e2) => {
            var _a3;
            console.log("KEYDOWWNNN");
            setShow(true);
            clearTimeout(controlsTimeout);
            handleKeydown(e2);
            if (e2.key == "Backspace") {
              e2.preventDefault();
              {
                if (!document.fullscreenElement && // alternative standard method
                // @ts-ignore
                !document.mozFullScreenElement)
                  (_a3 = props.onClose) == null ? void 0 : _a3.call(props);
                exitFullscreen();
              }
              return;
            }
            if (e2.key == "Enter" || e2.key == "SoftLeft") {
              player.paused ? player.play() : player.pause();
              setPaused(player.paused);
            }
            if (e2.key == "SoftRight") {
              const isFullscreen = toggleFullScreen();
              if (isFullscreen && player.videoHeight < player.videoWidth) {
                rotateScreen(true);
              }
            }
          };
          insert(_el$, createComponent(Show, {
            get when() {
              return src();
            },
            get children() {
              var _el$2 = _tmpl$$4();
              _el$2.addEventListener("loadedmetadata", () => {
                setDuration(player.duration != Infinity && !Number.isNaN(player.duration) ? player.duration : 0);
              });
              _el$2.addEventListener("timeupdate", () => {
                clearTimeout(timeout);
                setTime(player.currentTime);
                setPaused(player.paused);
                timeout = setTimeout(() => {
                  if (player.paused) {
                    setPaused(player.paused);
                  }
                }, 1e3);
              });
              var _ref$2 = player;
              typeof _ref$2 === "function" ? use(_ref$2, _el$2) : player = _el$2;
              _el$2.addEventListener("error", function(evt) {
                switch (evt.currentTarget.error.code) {
                  case MediaError.MEDIA_ERR_ABORTED:
                    return;
                  case MediaError.MEDIA_ERR_NETWORK:
                    toaster("Network error occured when loading the video");
                    break;
                  case MediaError.MEDIA_ERR_DECODE:
                  case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    toaster("Video file type is unsupported");
                    break;
                  default:
                    toaster("Unknown error occured when loading the video");
                    break;
                }
              });
              createRenderEffect((_p$) => {
                var _v$ = poster(), _v$2 = src();
                _v$ !== _p$.e && setAttribute(_el$2, "poster", _p$.e = _v$);
                _v$2 !== _p$.t && setAttribute(_el$2, "src", _p$.t = _v$2);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$2;
            }
          }), _el$4);
          insert(_el$, createComponent(Show, {
            get when() {
              return !src();
            },
            get children() {
              return [createComponent(Show, {
                get when() {
                  return poster();
                },
                get children() {
                  var _el$3 = _tmpl$2$3();
                  createRenderEffect((_p$) => {
                    var _v$3 = styles$3.thumb, _v$4 = poster();
                    _v$3 !== _p$.e && className(_el$3, _p$.e = _v$3);
                    _v$4 !== _p$.t && setAttribute(_el$3, "src", _p$.t = _v$4);
                    return _p$;
                  }, {
                    e: void 0,
                    t: void 0
                  });
                  return _el$3;
                }
              }), createComponent(ProgressSpinner, {
                get ["class"]() {
                  return styles$3.progress_spin;
                },
                size: 50,
                get progress() {
                  return progress2() || 1;
                }
              })];
            }
          }), _el$4);
          insert(_el$5, createComponent(Show, {
            get when() {
              return paused();
            },
            get fallback() {
              return _tmpl$5$1();
            },
            get children() {
              return _tmpl$3$1();
            }
          }));
          insert(_el$7, () => formatTime(time2()), _el$8);
          insert(_el$7, () => formatTime(duration2()), null);
          createRenderEffect((_p$) => {
            var _v$5 = styles$3.viewer, _v$6 = show() ? 1 : 0, _v$7 = styles$3.controls, _v$8 = styles$3.icon, _v$9 = styles$3.time, _v$10 = styles$3.progress_wrap, _v$11 = styles$3.progress, _v$12 = progressTime() + "%", _v$13 = styles$3.icon;
            _v$5 !== _p$.e && className(_el$, _p$.e = _v$5);
            _v$6 !== _p$.t && ((_p$.t = _v$6) != null ? _el$4.style.setProperty("opacity", _v$6) : _el$4.style.removeProperty("opacity"));
            _v$7 !== _p$.a && className(_el$4, _p$.a = _v$7);
            _v$8 !== _p$.o && className(_el$5, _p$.o = _v$8);
            _v$9 !== _p$.i && className(_el$7, _p$.i = _v$9);
            _v$10 !== _p$.n && className(_el$9, _p$.n = _v$10);
            _v$11 !== _p$.s && className(_el$10, _p$.s = _v$11);
            _v$12 !== _p$.h && ((_p$.h = _v$12) != null ? _el$10.style.setProperty("width", _v$12) : _el$10.style.removeProperty("width"));
            _v$13 !== _p$.r && className(_el$11, _p$.r = _v$13);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0,
            n: void 0,
            s: void 0,
            h: void 0,
            r: void 0
          });
          return _el$;
        })();
      }
      delegateEvents(["keydown", "keyup"]);
      const separator = "_separator_1h80a_1";
      const styles$2 = {
        separator
      };
      var _tmpl$$3 = /* @__PURE__ */ template(`<div>`);
      function Separator(props) {
        return (() => {
          var _el$ = _tmpl$$3();
          insert(_el$, () => props.children);
          createRenderEffect(() => className(_el$, styles$2.separator));
          return _el$;
        })();
      }
      var _tmpl$$2 = /* @__PURE__ */ template(`<div><div></div><div><div><span></span></div><div><span>`), _tmpl$2$2 = /* @__PURE__ */ template(`<span>`), _tmpl$3 = /* @__PURE__ */ template(`<div>edited`), _tmpl$4 = /* @__PURE__ */ template(`<div>`), _tmpl$5 = /* @__PURE__ */ template(`<span tabindex=-1 class=focusable>`), _tmpl$6 = /* @__PURE__ */ template(`<div><div style="max-height:unset !important;"><div><span>`), _tmpl$7 = /* @__PURE__ */ template(`<div tabindex=-1><div><div><div></div></div></div><div><div>`), _tmpl$8 = /* @__PURE__ */ template(`<div><div>`);
      function ReplyBase(props) {
        return (() => {
          var _el$ = _tmpl$$2(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$4.nextSibling, _el$7 = _el$6.firstChild;
          insert(_el$5, () => props.title);
          insert(_el$7, () => props.children);
          createRenderEffect((_p$) => {
            var _v$ = styles$d.reply, _v$2 = styles$d.reply_border, _v$3 = styles$d.reply_details, _v$4 = styles$d.reply_username, _v$5 = styles$d.reply_text;
            _v$ !== _p$.e && className(_el$, _p$.e = _v$);
            _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
            _v$3 !== _p$.a && className(_el$3, _p$.a = _v$3);
            _v$4 !== _p$.o && className(_el$4, _p$.o = _v$4);
            _v$5 !== _p$.i && className(_el$6, _p$.i = _v$5);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0
          });
          return _el$;
        })();
      }
      function ReplyMessage(props) {
        const text2 = useStore(() => props.$.text);
        return createComponent(ReplyBase, {
          get title() {
            return (() => {
              var _el$8 = _tmpl$2$2();
              insert(_el$8, () => props.$.sender.displayName);
              createRenderEffect((_$p) => (_$p = `var(--peer-avatar-${getColorFromPeer(props.$.sender.raw)}-bottom)`) != null ? _el$8.style.setProperty("color", _$p) : _el$8.style.removeProperty("color"));
              return _el$8;
            })();
          },
          get children() {
            return createComponent(ModifyString, {
              get text() {
                return text2();
              }
            });
          }
        });
      }
      function DeletedReplyMessage() {
        return createComponent(ReplyBase, {
          title: "Deleted Message",
          children: "???"
        });
      }
      function LoadingReplyMessage() {
        return createComponent(ReplyBase, {
          title: "Loading...",
          children: "???"
        });
      }
      function MessageAdditionalInfo(props) {
        const message2 = () => props.$;
        const dialog2 = () => dialogsJar.get(props.$.$.chat.peer.id);
        const edited2 = useStore(() => message2().editDate);
        const check2 = useMessageChecks(message2, dialog2);
        let divRef;
        createEffect(() => {
          edited2();
          check2();
          props.setWidth(divRef.offsetWidth);
        });
        return (() => {
          var _el$9 = _tmpl$4();
          var _ref$ = divRef;
          typeof _ref$ === "function" ? use(_ref$, _el$9) : divRef = _el$9;
          insert(_el$9, createComponent(Show, {
            get when() {
              return createMemo(() => !!edited2())() && !message2().$.hideEditMark;
            },
            get children() {
              var _el$10 = _tmpl$3();
              createRenderEffect(() => className(_el$10, styles$d.edited));
              return _el$10;
            }
          }), null);
          insert(_el$9, createComponent(Show, {
            get when() {
              return message2().isOutgoing;
            },
            get children() {
              var _el$11 = _tmpl$4();
              insert(_el$11, createComponent(TelegramIcon, {
                get name() {
                  return check2() ? "check" : "checks";
                }
              }));
              createRenderEffect(() => className(_el$11, styles$d.info_check));
              return _el$11;
            }
          }), null);
          createRenderEffect(() => className(_el$9, styles$d.message_info));
          return _el$9;
        })();
      }
      function formatHref(str) {
        if (str.startsWith("http")) {
          return str;
        }
        return "https://" + str;
      }
      function FocusableLink(props) {
        let spanRef;
        console.error("MESSAGE CONTEXT IN HEREE OMFG", useMessageContext());
        return (() => {
          var _el$12 = _tmpl$5();
          addEventListener(_el$12, "sn-enter-down", () => {
            var _a3;
            const href = (_a3 = spanRef.querySelector("a")) == null ? void 0 : _a3.getAttribute("href");
            href && window.open(formatHref(href), "_blank");
          });
          var _ref$2 = spanRef;
          typeof _ref$2 === "function" ? use(_ref$2, _el$12) : spanRef = _el$12;
          insert(_el$12, () => props.children);
          return _el$12;
        })();
      }
      let lastFocused;
      function formatDate($2) {
        const _today = today();
        const __today = _today.toDate();
        let date2 = "";
        if (isToday($2, __today)) {
          date2 = "Today";
        } else if (_today.diff(toMidnight(dayjs($2)), "day") === 1) {
          date2 = "Yesterday";
        } else {
          date2 = $2.toLocaleDateString(navigator.language);
        }
        return date2 + ", " + $2.toLocaleTimeString(navigator.language, {
          hour: "numeric",
          minute: "numeric"
        });
      }
      function MessageInfo(props) {
        let viewRef;
        const entities = useStore(() => props.$.entities);
        const edited2 = useStore(() => props.$.editDate);
        const [infoWidth, setInfoWidth] = createSignal(0);
        const dialog2 = () => dialogsJar.get(props.$.$.chat.peer.id);
        const check2 = useMessageChecks(() => props.$, dialog2);
        const [reply2] = createResource(() => __async(this, null, function* () {
          const _ = props.$.isReply();
          if (_) {
            const msg = yield props.$.getReply(dialog2());
            return msg != null ? msg : 0;
          } else {
            return void 0;
          }
        }));
        const [selectedPhoto, setSelectedPhoto] = createSignal(null);
        const [selectedVideo, setSelectedVideo] = createSignal(null);
        const showUsername2 = createMemo(() => decideShowUsername(void 0, props.$));
        let hasFocusable = false;
        let isFocusing = false;
        onMount(() => {
          if (!lastFocused)
            lastFocused = document.activeElement;
          hasFocusable = !!viewRef.querySelector(".focusable");
          viewRef.focus();
          __CJS__export_default__.add("view_message_info", {
            restrict: "self-only",
            rememberSource: true,
            selector: `.${styles$d.container} .focusable`
          });
        });
        onCleanup(() => {
          __CJS__export_default__.remove("view_message_info");
        });
        return [(() => {
          var _el$13 = _tmpl$7(), _el$14 = _el$13.firstChild, _el$15 = _el$14.firstChild, _el$16 = _el$15.firstChild, _el$24 = _el$14.nextSibling, _el$25 = _el$24.firstChild;
          _el$13.$$keydown = (e2) => {
            if (isFocusing) {
              if (e2.key == "Backspace") {
                e2.preventDefault();
                viewRef.focus();
                isFocusing = false;
              }
              return;
            }
            if (hasFocusable && !isFocusing && e2.key == "Enter") {
              isFocusing = true;
              sleep$1(10).then(() => {
                __CJS__export_default__.focus("view_message_info");
              });
              return;
            }
            if (e2.key == "Backspace" || e2.key == "SoftLeft") {
              e2.preventDefault();
              setMessageInfo(null);
              sleep$1(10).then(() => {
                lastFocused.focus();
                lastFocused = void 0;
              });
            }
          };
          _el$13.addEventListener("focus", () => {
            setSoftkeys("Back", hasFocusable ? "SELECT" : "", "");
          });
          var _ref$3 = viewRef;
          typeof _ref$3 === "function" ? use(_ref$3, _el$13) : viewRef = _el$13;
          _el$13.addEventListener("sn-willfocus", (e$12) => {
            setSoftkeys("", "VIEW", "");
            e(e$12.target, {
              behavior: "instant",
              block: "center",
              inline: "center"
            });
          }, true);
          _el$15.style.setProperty("margin-top", "0");
          insert(_el$16, createComponent(Show, {
            get when() {
              return showUsername2();
            },
            get children() {
              return createComponent(UsernameContainer, {
                get peer() {
                  return props.$.sender.raw;
                },
                get children() {
                  return props.$.sender.displayName;
                }
              });
            }
          }), null);
          insert(_el$16, createComponent(Switch, {
            get children() {
              return [createComponent(Match, {
                get when() {
                  return createMemo(() => !!props.$.isReply())() && reply2() === void 0;
                },
                get children() {
                  return createComponent(LoadingReplyMessage, {});
                }
              }), createComponent(Match, {
                get when() {
                  return reply2() === 0;
                },
                get children() {
                  return createComponent(DeletedReplyMessage, {});
                }
              }), createComponent(Match, {
                get when() {
                  return reply2();
                },
                get children() {
                  return createComponent(ReplyMessage, {
                    get $() {
                      return reply2();
                    }
                  });
                }
              })];
            }
          }), null);
          insert(_el$16, createComponent(MessageProvider, {
            last: true,
            get $() {
              return props.$;
            },
            get dialog() {
              return dialog2();
            },
            get children() {
              return [createComponent(Dynamic, {
                focusable: true,
                downloadRef: (e2) => {
                },
                mediaRef: (e2) => {
                },
                onSelect: (e2) => {
                  console.error("MESSAGE INFO ONSELECT");
                  isFocusing = false;
                  switch (e2.type) {
                    case "photo":
                      setSelectedPhoto(e2);
                      break;
                    case "video":
                      setSelectedVideo(e2);
                      break;
                  }
                },
                get component() {
                  var _a3;
                  return switchMessageMedia((_a3 = props.$.$.media) == null ? void 0 : _a3.type);
                }
              }), createComponent(Show, {
                get when() {
                  return createMemo(() => !!!props.$.isSticker)() && (entities().entities || entities().text);
                },
                get children() {
                  return [(() => {
                    var _el$17 = _tmpl$6(), _el$18 = _el$17.firstChild, _el$19 = _el$18.firstChild, _el$20 = _el$19.firstChild;
                    insert(_el$19, () => createComponent(Markdown, {
                      customRenderer: (e2, _default) => {
                        if (e2.tag == "a" && e2.entity._.includes("Url")) {
                          return () => createComponent(FocusableLink, {
                            get children() {
                              return createComponent(Dynamic, {
                                component: _default
                              });
                            }
                          });
                        }
                      },
                      get entities() {
                        return entities();
                      }
                    }), _el$20);
                    createRenderEffect((_p$) => {
                      var _v$6 = styles$d.text_container, _v$7 = styles$d.text_wrap, _v$8 = styles$d.text, _v$9 = styles$d.extra_width, _v$10 = infoWidth() + "px";
                      _v$6 !== _p$.e && className(_el$17, _p$.e = _v$6);
                      _v$7 !== _p$.t && className(_el$18, _p$.t = _v$7);
                      _v$8 !== _p$.a && className(_el$19, _p$.a = _v$8);
                      _v$9 !== _p$.o && className(_el$20, _p$.o = _v$9);
                      _v$10 !== _p$.i && ((_p$.i = _v$10) != null ? _el$20.style.setProperty("width", _v$10) : _el$20.style.removeProperty("width"));
                      return _p$;
                    }, {
                      e: void 0,
                      t: void 0,
                      a: void 0,
                      o: void 0,
                      i: void 0
                    });
                    return _el$17;
                  })(), (() => {
                    var _el$21 = _tmpl$4();
                    insert(_el$21, createComponent(Show, {
                      get when() {
                        return edited2() && !props.$.$.hideEditMark;
                      },
                      get children() {
                        var _el$22 = _tmpl$3();
                        createRenderEffect(() => className(_el$22, styles$d.edited));
                        return _el$22;
                      }
                    }), null);
                    insert(_el$21, createComponent(Show, {
                      get when() {
                        return props.$.isOutgoing;
                      },
                      get children() {
                        var _el$23 = _tmpl$4();
                        insert(_el$23, createComponent(TelegramIcon, {
                          get name() {
                            return check2() ? "check" : "checks";
                          }
                        }));
                        createRenderEffect(() => className(_el$23, styles$d.info_check));
                        return _el$23;
                      }
                    }), null);
                    createRenderEffect(() => className(_el$21, styles$d.message_info));
                    return _el$21;
                  })(), createComponent(MessageAdditionalInfo, {
                    get $() {
                      return props.$;
                    },
                    setWidth: setInfoWidth
                  })];
                }
              })];
            }
          }), null);
          insert(_el$13, createComponent(Separator, {
            children: "Sent"
          }), _el$24);
          insert(_el$25, () => formatDate(props.$.date));
          insert(_el$13, createComponent(Show, {
            get when() {
              return edited2();
            },
            children: (date2) => [createComponent(Separator, {
              children: "Edited"
            }), (() => {
              var _el$26 = _tmpl$8(), _el$27 = _el$26.firstChild;
              insert(_el$27, () => formatDate(date2()));
              createRenderEffect((_p$) => {
                var _v$17 = styles$d.info_date, _v$18 = styles$d.date;
                _v$17 !== _p$.e && className(_el$26, _p$.e = _v$17);
                _v$18 !== _p$.t && className(_el$27, _p$.t = _v$18);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$26;
            })()]
          }), null);
          createRenderEffect((_p$) => {
            var _v$11 = styles$d.view_message_info, _v$12 = styles$d.container, _v$13 = {
              [styles$d.message]: true,
              [styles$d.padTop]: true
            }, _v$14 = {
              [styles$d.message_inner]: true,
              [styles$d.outgoing]: props.$.isOutgoing,
              [styles$d.tail]: true,
              [styles$d.isSticker]: props.$.isSticker,
              [styles$d.isReply]: props.$.isReply(),
              [styles$d.showUsername]: showUsername2()
            }, _v$15 = styles$d.info_date, _v$16 = styles$d.date;
            _v$11 !== _p$.e && className(_el$13, _p$.e = _v$11);
            _v$12 !== _p$.t && className(_el$14, _p$.t = _v$12);
            _p$.a = classList$1(_el$15, _v$13, _p$.a);
            _p$.o = classList$1(_el$16, _v$14, _p$.o);
            _v$15 !== _p$.i && className(_el$24, _p$.i = _v$15);
            _v$16 !== _p$.n && className(_el$25, _p$.n = _v$16);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0,
            i: void 0,
            n: void 0
          });
          return _el$13;
        })(), createComponent(Show, {
          get when() {
            return selectedPhoto();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(ImageViewer, {
                  get photo() {
                    return selectedPhoto();
                  },
                  onClose: () => __async(this, null, function* () {
                    setSelectedPhoto(null);
                    yield sleep$1(2);
                    viewRef.focus();
                  })
                });
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return selectedVideo();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(VideoViewer, {
                  get video() {
                    return selectedVideo();
                  },
                  onClose: () => __async(this, null, function* () {
                    setSelectedVideo(null);
                    yield sleep$1(2);
                    viewRef.focus();
                  })
                });
              }
            });
          }
        })];
      }
      delegateEvents(["keydown"]);
      const item$1 = "_item_7ycfu_1";
      const styles$1 = {
        item: item$1
      };
      var _tmpl$$1 = /* @__PURE__ */ template(`<div tabindex=-1>`), _tmpl$2$1 = /* @__PURE__ */ template(`<div>`);
      function SettingsItem(props) {
        return (() => {
          var _el$ = _tmpl$$1();
          addEventListener(_el$, "sn-willfocus", (e$12) => {
            e(e$12.currentTarget, {
              scrollMode: "if-needed",
              block: "nearest",
              inline: "nearest"
            });
          });
          addEventListener(_el$, "sn-enter-down", props.onEnterDown);
          insert(_el$, () => props.children);
          createRenderEffect(() => className(_el$, styles$1.item));
          return _el$;
        })();
      }
      function Settings(props) {
        onMount(() => {
          __CJS__export_default__.add("settings", {
            selector: "." + styles$1.item,
            restrict: "self-only"
          });
          __CJS__export_default__.focus("settings");
          setStatusbarColor("#0a323f");
        });
        onCleanup(() => {
          __CJS__export_default__.remove("settings");
        });
        return createComponent(Content, {
          get before() {
            return createComponent(Header, {
              children: "Settings"
            });
          },
          get children() {
            var _el$2 = _tmpl$2$1();
            _el$2.$$keydown = (e2) => {
              if (e2.key == "Backspace") {
                e2.preventDefault();
                props.onClose();
              }
            };
            _el$2.style.setProperty("background-color", "white");
            _el$2.style.setProperty("height", "100%");
            insert(_el$2, createComponent(SettingsItem, {
              onEnterDown: () => __async(this, null, function* () {
                const tg = client();
                yield sleep$1(100);
                const sure = confirm("Are you sure you want to logout?");
                if (!sure)
                  return;
                const success = yield tg.logOut();
                if (!success) {
                  alert("Logout was not successful!");
                  yield tg.storage.clear(true);
                }
                location.reload();
              }),
              children: "Logout"
            }), null);
            insert(_el$2, createComponent(SettingsItem, {
              onEnterDown: () => __async(this, null, function* () {
                const result = yield manuallySubscribePushNotification(client());
                alert(result ? "Sucessfully enabled Push Notifications." : "Something went wrong. :(");
              }),
              children: "Enable Push Notifications"
            }), null);
            return _el$2;
          }
        });
      }
      delegateEvents(["keydown"]);
      const item = "_item_1m5yn_1";
      const option = "_option_1m5yn_9";
      const contact = "_contact_1m5yn_14";
      const photo = "_photo_1m5yn_18";
      const name = "_name_1m5yn_27";
      const styles = {
        item,
        option,
        contact,
        photo,
        name
      };
      function importKaiContact(tg, cachedContacts2, contact2) {
        return __async(this, null, function* () {
          const contactsForTelegram = [];
          const numbersAlreadySaved = new Set(cachedContacts2.map((a) => "+" + a.phoneNumber));
          const isFullname = contact2.givenName && contact2.familyName;
          const firstName = isFullname ? contact2.givenName[0] : contact2.name[0];
          const lastName = isFullname ? contact2.familyName[0] : "";
          contact2.tel.forEach((field) => {
            if (!numbersAlreadySaved.has(field.value))
              contactsForTelegram.push({
                firstName,
                lastName,
                phone: field.value
              });
          });
          if (!contactsForTelegram.length)
            return null;
          const users = (yield tg.importContacts(contactsForTelegram)).users;
          if (!users.length)
            return [];
          const idSet = new Set(cachedContacts2.map((a) => a.id));
          return users.filter((a) => !idSet.has(a.id)).map((a) => new User(a));
        });
      }
      function importKaiContacts(tg, cachedContacts2) {
        return __async(this, null, function* () {
          const contactsFromKai = yield Array_from_DOMCursor(navigator.mozContacts.getAll());
          const contactsForTelegram = [];
          const numbersAlreadySaved = new Set(cachedContacts2.map((a) => "+" + a.phoneNumber));
          contactsFromKai.forEach((contact2) => {
            const isFullname = contact2.givenName && contact2.familyName;
            const firstName = isFullname ? contact2.givenName[0] : contact2.name[0];
            const lastName = isFullname ? contact2.familyName[0] : "";
            contact2.tel.forEach((field) => {
              if (!numbersAlreadySaved.has(field.value))
                contactsForTelegram.push({
                  firstName,
                  lastName,
                  phone: field.value
                });
            });
          });
          if (!contactsForTelegram.length)
            return null;
          const users = (yield tg.importContacts(contactsForTelegram)).users;
          if (!users.length)
            return [];
          const idSet = new Set(cachedContacts2.map((a) => a.id));
          return users.filter((a) => !idSet.has(a.id)).map((a) => new User(a));
        });
      }
      function startActivity(name2, data2) {
        if (typeof MozActivity !== "undefined") {
          return new Promise((resolve, reject) => {
            new MozActivity({ name: name2, data: data2 }).then(resolve, reject);
          });
        } else if (typeof WebActivity !== "undefined") {
          let activity = new WebActivity(name2, data2);
          return activity.start();
        }
        return Promise.resolve(null);
      }
      var _tmpl$ = /* @__PURE__ */ template(`<div tabindex=0><div></div><div>`), _tmpl$2 = /* @__PURE__ */ template(`<div>`);
      const SUPPORTS_IMPORT_CONTACTS = Boolean(navigator.mozContacts);
      const SN_ID_OPTIONS = "dialog_options_contacts";
      function OptionsContactItem(props) {
        onMount(() => {
          __CJS__export_default__.add(SN_ID_OPTIONS, {
            selector: "." + styles.option,
            restrict: "self-only"
          });
          __CJS__export_default__.focus(SN_ID_OPTIONS);
          setSoftkeys("", "OK", "");
        });
        onCleanup(() => {
          __CJS__export_default__.remove(SN_ID_OPTIONS);
        });
        return createComponent(Options, {
          get onClose() {
            return props.onClose;
          },
          title: "Options",
          get children() {
            return [createComponent(OptionsItem, {
              get classList() {
                return {
                  [styles.option]: true
                };
              },
              tabIndex: -1,
              "on:sn-enter-down": () => __async(this, null, function* () {
                startActivity("pick", {
                  type: ["webcontacts/contact"]
                }).then((data2) => __async(this, null, function* () {
                  const contact2 = data2 == null ? void 0 : data2.contact;
                  if (contact2) {
                    const cached2 = cachedContacts();
                    const result = yield importKaiContact(client(), cached2.length ? cached2 : yield reloadCachedContacts(), contact2);
                    if (!result)
                      return;
                    if (result.length) {
                      setCachedContacts((a) => a.concat(result));
                    }
                  }
                }));
                props.onClose();
              }),
              children: "Add new contact"
            }), createComponent(OptionsItem, {
              get classList() {
                return {
                  [styles.option]: true
                };
              },
              "on:sn-enter-down": () => __async(this, null, function* () {
                setCachedContacts([]);
                yield sleep$1();
                reloadCachedContacts();
                props.onClose();
              }),
              tabIndex: -1,
              children: "Reload contacts"
            }), createComponent(Show, {
              when: SUPPORTS_IMPORT_CONTACTS,
              get children() {
                return createComponent(OptionsItem, {
                  get classList() {
                    return {
                      [styles.option]: true
                    };
                  },
                  "on:sn-enter-down": () => __async(this, null, function* () {
                    const count2 = yield navigator.mozContacts.getCount().then((a) => a);
                    if (count2 > 100) {
                      if (!confirm("You have more than 100 contacts, are you sure you want to import them all?"))
                        return;
                    }
                    const cached2 = cachedContacts();
                    const result = yield importKaiContacts(client(), cached2.length ? cached2 : yield reloadCachedContacts());
                    if (!result)
                      return;
                    if (result.length) {
                      setCachedContacts((a) => a.concat(result));
                    }
                    props.onClose();
                  }),
                  tabIndex: -1,
                  children: "Import contacts"
                });
              }
            })];
          }
        });
      }
      function ContactItem(props) {
        const [showOptions, setShowOptions] = createSignal(false);
        return [(() => {
          var _el$ = _tmpl$(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
          _el$.$$keydown = (e2) => __async(this, null, function* () {
            const tg = client();
            if (e2.key == "Enter") {
              const dialog2 = (yield tg.getPeerDialogs(props.user))[0];
              if (!dialog2)
                return;
              const uiDialog2 = dialogsJar.add(dialog2);
              if (!uiDialog2.messages.hasLoadedBefore) {
                uiDialog2.messages.loadMore();
              }
              batch(() => {
                setStatusbarColor("#1c96c3");
                setUIDialog(uiDialog2);
                setRoom(uiDialog2.$.chat);
                setView("room");
              });
            }
            if (e2.key == "SoftRight") {
              setShowOptions(true);
            }
          });
          addEventListener(_el$, "sn-willfocus", (e$12) => {
            e(e$12.currentTarget, {
              scrollMode: "if-needed",
              block: "nearest",
              inline: "nearest"
            });
            setSoftkeys("Cancel", "OPEN", "tg:more");
          });
          insert(_el$2, createComponent(PeerPhotoIcon, {
            get peer() {
              return props.user;
            }
          }));
          insert(_el$3, createComponent(ModifyString, {
            get text() {
              return props.user.displayName;
            }
          }));
          createRenderEffect((_p$) => {
            var _v$ = {
              [styles.item]: true,
              [styles.contact]: true
            }, _v$2 = styles.photo, _v$3 = styles.name;
            _p$.e = classList$1(_el$, _v$, _p$.e);
            _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
            _v$3 !== _p$.a && className(_el$3, _p$.a = _v$3);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          return _el$;
        })(), createComponent(Show, {
          get when() {
            return showOptions();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(OptionsContactItem, {
                  onClose: () => __async(this, null, function* () {
                    setShowOptions(false);
                    __CJS__export_default__.focus("new_chat");
                  }),
                  get user() {
                    return props.user;
                  }
                });
              }
            });
          }
        })];
      }
      function NewChat(props) {
        onMount(() => __async(this, null, function* () {
          __CJS__export_default__.add("new_chat", {
            selector: "." + styles.item + ", .new_chat_search",
            restrict: "self-only"
          });
          __CJS__export_default__.focus("new_chat");
          setStatusbarColor("#0a323f");
          if (!cachedContacts().length) {
            yield sleep$1();
            yield reloadCachedContacts();
          }
        }));
        onCleanup(() => {
          __CJS__export_default__.remove("new_chat");
        });
        const [showOptions, setShowOptions] = createSignal(false);
        const [searchText, setSearchText] = createSignal("");
        const [searchResults, setSearchResults] = createSignal([]);
        const debounced_search = debounce((str) => {
          if (searchText()) {
            setSearchResults(contactsMinisearch.search(str).map((a) => cachedContacts().find((e2) => e2.id == a.id)));
          }
        }, 150);
        createEffect(() => {
          const toSearch = searchText();
          debounced_search(toSearch.toLowerCase());
        });
        return [createComponent(Content, {
          get before() {
            return createComponent(Header, {
              get children() {
                return ["New chat", createMemo(() => createMemo(() => !!cachedContacts().length)() ? ` (${cachedContacts().length})` : "")];
              }
            });
          },
          get children() {
            var _el$4 = _tmpl$2();
            _el$4.$$keydown = (e2) => {
              if (e2.key == "SoftLeft") {
                props.onClose();
              }
              if (e2.key == "Backspace") {
                const actEl = document.activeElement;
                if ((actEl == null ? void 0 : actEl.tagName) == "INPUT" && actEl.value != "") {
                  return;
                }
                e2.preventDefault();
                props.onClose();
              }
            };
            _el$4.style.setProperty("background-color", "white");
            _el$4.style.setProperty("height", "100%");
            insert(_el$4, createComponent(Search, {
              "class": "new_chat_search",
              onFocus: (e2) => {
                setSoftkeys("Cancel", "", "tg:more");
              },
              "on:sn-willfocus": (e2) => {
                e2.currentTarget.scrollIntoView(false);
              },
              onKeyDown: (e2) => {
                if (e2.key == "SoftRight") {
                  setShowOptions(true);
                }
              },
              onInput: (e2) => {
                setSearchText(e2.currentTarget.value);
              },
              placeholder: "Search"
            }), null);
            insert(_el$4, createComponent(Show, {
              get when() {
                return !searchResults().length || searchText() === "";
              },
              get fallback() {
                return createComponent(For, {
                  get each() {
                    return searchResults();
                  },
                  children: (r2) => createComponent(ContactItem, {
                    user: r2
                  })
                });
              },
              get children() {
                return createComponent(For, {
                  get each() {
                    return cachedContacts();
                  },
                  children: (r2) => createComponent(ContactItem, {
                    user: r2
                  })
                });
              }
            }), null);
            return _el$4;
          }
        }), createComponent(Show, {
          get when() {
            return showOptions();
          },
          get children() {
            return createComponent(Portal, {
              get children() {
                return createComponent(OptionsContactItem, {
                  onClose: () => __async(this, null, function* () {
                    setShowOptions(false);
                    __CJS__export_default__.focus("new_chat");
                  }),
                  user: null
                });
              }
            });
          }
        })];
      }
      delegateEvents(["keydown"]);
      function App() {
        var _a3;
        (_a3 = document.querySelector(".LOADING")) == null ? void 0 : _a3.remove();
        onMount(() => {
          __CJS__export_default__.init();
        });
        onCleanup(() => {
          __CJS__export_default__.uninit();
        });
        return [createComponent(TemporaryUploadingIndicator, {}), createComponent(Switch, {
          get children() {
            return [createComponent(Match, {
              get when() {
                return currentView() == "login";
              },
              get children() {
                return createComponent(Login, {});
              }
            }), createComponent(Match, {
              get when() {
                return currentView() == "loading";
              },
              get children() {
                return createComponent(Loading, {});
              }
            }), createComponent(Match, {
              get when() {
                return currentView() == "settings";
              },
              get children() {
                return createComponent(Settings, {
                  onClose: () => {
                    setView(previousView());
                    setStatusbarColor("#1c96c3");
                  }
                });
              }
            }), createComponent(Match, {
              get when() {
                return currentView() == "new_chat";
              },
              get children() {
                return createComponent(NewChat, {
                  onClose: () => {
                    setView(previousView());
                    setStatusbarColor("#1c96c3");
                  }
                });
              }
            })];
          }
        }), createComponent(Show, {
          get when() {
            return client();
          },
          get children() {
            return createComponent(Home, {
              get hidden() {
                return currentView() != "home";
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return client();
          },
          get children() {
            return createComponent(Room, {
              get hidden() {
                return currentView() != "room";
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return messageInfo();
          },
          children: (e2) => createComponent(MessageInfo, {
            get $() {
              return e2();
            }
          })
        }), createComponent(Softkeys, {
          get left() {
            return softleft();
          },
          get center() {
            return softcenter();
          },
          get right() {
            return softright();
          },
          get loading() {
            return softkeysLoading();
          },
          get black() {
            return softkeysBlack();
          }
        })];
      }
      __vitePreload(() => module.import("./dev-CAjNfqdX.js"), false ? "__VITE_PRELOAD__" : void 0);
      Object.assign(window, {
        localforage,
        importKaiContacts
      });
      render(() => createComponent(App, {}), document.body);
    }
  };
});
