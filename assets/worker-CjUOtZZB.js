self.__POLYFILL__||(importScripts("/polyfills.js"),self.__POLYFILL__=!0);var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  };
  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
  var it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
(function() {
  "use strict";
  var _a;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var check = function(it) {
    return it && it.Math === Math && it;
  };
  var globalThis_1 = (
    // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")()
  );
  var objectGetOwnPropertyDescriptor = {};
  var fails$g = function(exec2) {
    try {
      return !!exec2();
    } catch (error) {
      return true;
    }
  };
  var fails$f = fails$g;
  var descriptors = !fails$f(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  });
  var fails$e = fails$g;
  var functionBindNative = !fails$e(function() {
    var test2 = function() {
    }.bind();
    return typeof test2 != "function" || test2.hasOwnProperty("prototype");
  });
  var NATIVE_BIND$3 = functionBindNative;
  var call$9 = Function.prototype.call;
  var functionCall = NATIVE_BIND$3 ? call$9.bind(call$9) : function() {
    return call$9.apply(call$9, arguments);
  };
  var objectPropertyIsEnumerable = {};
  var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor2 = getOwnPropertyDescriptor$3(this, V);
    return !!descriptor2 && descriptor2.enumerable;
  } : $propertyIsEnumerable$1;
  var createPropertyDescriptor$5 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var NATIVE_BIND$2 = functionBindNative;
  var FunctionPrototype$3 = Function.prototype;
  var call$8 = FunctionPrototype$3.call;
  var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$3.bind.bind(call$8, call$8);
  var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function(fn) {
    return function() {
      return call$8.apply(fn, arguments);
    };
  };
  var uncurryThis$i = functionUncurryThis;
  var toString$6 = uncurryThis$i({}.toString);
  var stringSlice$2 = uncurryThis$i("".slice);
  var classofRaw$2 = function(it) {
    return stringSlice$2(toString$6(it), 8, -1);
  };
  var uncurryThis$h = functionUncurryThis;
  var fails$d = fails$g;
  var classof$7 = classofRaw$2;
  var $Object$4 = Object;
  var split = uncurryThis$h("".split);
  var indexedObject = fails$d(function() {
    return !$Object$4("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof$7(it) === "String" ? split(it, "") : $Object$4(it);
  } : $Object$4;
  var isNullOrUndefined$2 = function(it) {
    return it === null || it === void 0;
  };
  var isNullOrUndefined$1 = isNullOrUndefined$2;
  var $TypeError$7 = TypeError;
  var requireObjectCoercible$3 = function(it) {
    if (isNullOrUndefined$1(it))
      throw new $TypeError$7("Can't call method on " + it);
    return it;
  };
  var IndexedObject$1 = indexedObject;
  var requireObjectCoercible$2 = requireObjectCoercible$3;
  var toIndexedObject$7 = function(it) {
    return IndexedObject$1(requireObjectCoercible$2(it));
  };
  var documentAll = typeof document == "object" && document.all;
  var isCallable$i = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
  } : function(argument) {
    return typeof argument == "function";
  };
  var isCallable$h = isCallable$i;
  var isObject$b = function(it) {
    return typeof it == "object" ? it !== null : isCallable$h(it);
  };
  var globalThis$j = globalThis_1;
  var isCallable$g = isCallable$i;
  var aFunction = function(argument) {
    return isCallable$g(argument) ? argument : void 0;
  };
  var getBuiltIn$8 = function(namespace, method) {
    return arguments.length < 2 ? aFunction(globalThis$j[namespace]) : globalThis$j[namespace] && globalThis$j[namespace][method];
  };
  var uncurryThis$g = functionUncurryThis;
  var objectIsPrototypeOf = uncurryThis$g({}.isPrototypeOf);
  var globalThis$i = globalThis_1;
  var navigator$1 = globalThis$i.navigator;
  var userAgent$1 = navigator$1 && navigator$1.userAgent;
  var environmentUserAgent = userAgent$1 ? String(userAgent$1) : "";
  var globalThis$h = globalThis_1;
  var userAgent = environmentUserAgent;
  var process = globalThis$h.process;
  var Deno = globalThis$h.Deno;
  var versions = process && process.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version$1;
  if (v8) {
    match = v8.split(".");
    version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version$1 && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match)
        version$1 = +match[1];
    }
  }
  var environmentV8Version = version$1;
  var V8_VERSION$2 = environmentV8Version;
  var fails$c = fails$g;
  var globalThis$g = globalThis_1;
  var $String$6 = globalThis$g.String;
  var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$c(function() {
    var symbol = Symbol("symbol detection");
    return !$String$6(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;
  });
  var NATIVE_SYMBOL$6 = symbolConstructorDetection;
  var useSymbolAsUid = NATIVE_SYMBOL$6 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  var getBuiltIn$7 = getBuiltIn$8;
  var isCallable$f = isCallable$i;
  var isPrototypeOf$2 = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
  var $Object$3 = Object;
  var isSymbol$4 = USE_SYMBOL_AS_UID$1 ? function(it) {
    return typeof it == "symbol";
  } : function(it) {
    var $Symbol2 = getBuiltIn$7("Symbol");
    return isCallable$f($Symbol2) && isPrototypeOf$2($Symbol2.prototype, $Object$3(it));
  };
  var $String$5 = String;
  var tryToString$2 = function(argument) {
    try {
      return $String$5(argument);
    } catch (error) {
      return "Object";
    }
  };
  var isCallable$e = isCallable$i;
  var tryToString$1 = tryToString$2;
  var $TypeError$6 = TypeError;
  var aCallable$3 = function(argument) {
    if (isCallable$e(argument))
      return argument;
    throw new $TypeError$6(tryToString$1(argument) + " is not a function");
  };
  var aCallable$2 = aCallable$3;
  var isNullOrUndefined = isNullOrUndefined$2;
  var getMethod$1 = function(V, P) {
    var func = V[P];
    return isNullOrUndefined(func) ? void 0 : aCallable$2(func);
  };
  var call$7 = functionCall;
  var isCallable$d = isCallable$i;
  var isObject$a = isObject$b;
  var $TypeError$5 = TypeError;
  var ordinaryToPrimitive$1 = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable$d(fn = input.toString) && !isObject$a(val = call$7(fn, input)))
      return val;
    if (isCallable$d(fn = input.valueOf) && !isObject$a(val = call$7(fn, input)))
      return val;
    if (pref !== "string" && isCallable$d(fn = input.toString) && !isObject$a(val = call$7(fn, input)))
      return val;
    throw new $TypeError$5("Can't convert object to primitive value");
  };
  var sharedStore = { exports: {} };
  var globalThis$f = globalThis_1;
  var defineProperty$9 = Object.defineProperty;
  var defineGlobalProperty$3 = function(key, value) {
    try {
      defineProperty$9(globalThis$f, key, { value, configurable: true, writable: true });
    } catch (error) {
      globalThis$f[key] = value;
    }
    return value;
  };
  var globalThis$e = globalThis_1;
  var defineGlobalProperty$2 = defineGlobalProperty$3;
  var SHARED = "__core-js_shared__";
  var store$3 = sharedStore.exports = globalThis$e[SHARED] || defineGlobalProperty$2(SHARED, {});
  (store$3.versions || (store$3.versions = [])).push({
    version: "3.41.0",
    mode: "global",
    copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  var sharedStoreExports = sharedStore.exports;
  var store$2 = sharedStoreExports;
  var shared$6 = function(key, value) {
    return store$2[key] || (store$2[key] = value || {});
  };
  var requireObjectCoercible$1 = requireObjectCoercible$3;
  var $Object$2 = Object;
  var toObject$5 = function(argument) {
    return $Object$2(requireObjectCoercible$1(argument));
  };
  var uncurryThis$f = functionUncurryThis;
  var toObject$4 = toObject$5;
  var hasOwnProperty = uncurryThis$f({}.hasOwnProperty);
  var hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
    return hasOwnProperty(toObject$4(it), key);
  };
  var uncurryThis$e = functionUncurryThis;
  var id = 0;
  var postfix = Math.random();
  var toString$5 = uncurryThis$e(1 .toString);
  var uid$3 = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$5(++id + postfix, 36);
  };
  var globalThis$d = globalThis_1;
  var shared$5 = shared$6;
  var hasOwn$d = hasOwnProperty_1;
  var uid$2 = uid$3;
  var NATIVE_SYMBOL$5 = symbolConstructorDetection;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;
  var Symbol$3 = globalThis$d.Symbol;
  var WellKnownSymbolsStore$1 = shared$5("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$3["for"] || Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$2;
  var wellKnownSymbol$f = function(name) {
    if (!hasOwn$d(WellKnownSymbolsStore$1, name)) {
      WellKnownSymbolsStore$1[name] = NATIVE_SYMBOL$5 && hasOwn$d(Symbol$3, name) ? Symbol$3[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore$1[name];
  };
  var call$6 = functionCall;
  var isObject$9 = isObject$b;
  var isSymbol$3 = isSymbol$4;
  var getMethod = getMethod$1;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$e = wellKnownSymbol$f;
  var $TypeError$4 = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol$e("toPrimitive");
  var toPrimitive$1 = function(input, pref) {
    if (!isObject$9(input) || isSymbol$3(input))
      return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === void 0)
        pref = "default";
      result = call$6(exoticToPrim, input, pref);
      if (!isObject$9(result) || isSymbol$3(result))
        return result;
      throw new $TypeError$4("Can't convert object to primitive value");
    }
    if (pref === void 0)
      pref = "number";
    return ordinaryToPrimitive(input, pref);
  };
  var toPrimitive = toPrimitive$1;
  var isSymbol$2 = isSymbol$4;
  var toPropertyKey$3 = function(argument) {
    var key = toPrimitive(argument, "string");
    return isSymbol$2(key) ? key : key + "";
  };
  var globalThis$c = globalThis_1;
  var isObject$8 = isObject$b;
  var document$1 = globalThis$c.document;
  var EXISTS$1 = isObject$8(document$1) && isObject$8(document$1.createElement);
  var documentCreateElement$2 = function(it) {
    return EXISTS$1 ? document$1.createElement(it) : {};
  };
  var DESCRIPTORS$b = descriptors;
  var fails$b = fails$g;
  var createElement = documentCreateElement$2;
  var ie8DomDefine = !DESCRIPTORS$b && !fails$b(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
  var DESCRIPTORS$a = descriptors;
  var call$5 = functionCall;
  var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
  var createPropertyDescriptor$4 = createPropertyDescriptor$5;
  var toIndexedObject$6 = toIndexedObject$7;
  var toPropertyKey$2 = toPropertyKey$3;
  var hasOwn$c = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine;
  var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$a ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor2(O, P) {
    O = toIndexedObject$6(O);
    P = toPropertyKey$2(P);
    if (IE8_DOM_DEFINE$1)
      try {
        return $getOwnPropertyDescriptor$2(O, P);
      } catch (error) {
      }
    if (hasOwn$c(O, P))
      return createPropertyDescriptor$4(!call$5(propertyIsEnumerableModule$1.f, O, P), O[P]);
  };
  var objectDefineProperty = {};
  var DESCRIPTORS$9 = descriptors;
  var fails$a = fails$g;
  var v8PrototypeDefineBug = DESCRIPTORS$9 && fails$a(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
  var isObject$7 = isObject$b;
  var $String$4 = String;
  var $TypeError$3 = TypeError;
  var anObject$5 = function(argument) {
    if (isObject$7(argument))
      return argument;
    throw new $TypeError$3($String$4(argument) + " is not an object");
  };
  var DESCRIPTORS$8 = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
  var anObject$4 = anObject$5;
  var toPropertyKey$1 = toPropertyKey$3;
  var $TypeError$2 = TypeError;
  var $defineProperty$1 = Object.defineProperty;
  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE$1 = "configurable";
  var WRITABLE = "writable";
  objectDefineProperty.f = DESCRIPTORS$8 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty2(O, P, Attributes) {
    anObject$4(O);
    P = toPropertyKey$1(P);
    anObject$4(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor$1(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty$1(O, P, Attributes);
  } : $defineProperty$1 : function defineProperty2(O, P, Attributes) {
    anObject$4(O);
    P = toPropertyKey$1(P);
    anObject$4(Attributes);
    if (IE8_DOM_DEFINE)
      try {
        return $defineProperty$1(O, P, Attributes);
      } catch (error) {
      }
    if ("get" in Attributes || "set" in Attributes)
      throw new $TypeError$2("Accessors not supported");
    if ("value" in Attributes)
      O[P] = Attributes.value;
    return O;
  };
  var DESCRIPTORS$7 = descriptors;
  var definePropertyModule$5 = objectDefineProperty;
  var createPropertyDescriptor$3 = createPropertyDescriptor$5;
  var createNonEnumerableProperty$4 = DESCRIPTORS$7 ? function(object, key, value) {
    return definePropertyModule$5.f(object, key, createPropertyDescriptor$3(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var makeBuiltIn$3 = { exports: {} };
  var DESCRIPTORS$6 = descriptors;
  var hasOwn$b = hasOwnProperty_1;
  var FunctionPrototype$2 = Function.prototype;
  var getDescriptor = DESCRIPTORS$6 && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn$b(FunctionPrototype$2, "name");
  var PROPER = EXISTS && function something() {
  }.name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$6 || DESCRIPTORS$6 && getDescriptor(FunctionPrototype$2, "name").configurable);
  var functionName = {
    PROPER,
    CONFIGURABLE
  };
  var uncurryThis$d = functionUncurryThis;
  var isCallable$c = isCallable$i;
  var store$1 = sharedStoreExports;
  var functionToString = uncurryThis$d(Function.toString);
  if (!isCallable$c(store$1.inspectSource)) {
    store$1.inspectSource = function(it) {
      return functionToString(it);
    };
  }
  var inspectSource$2 = store$1.inspectSource;
  var globalThis$b = globalThis_1;
  var isCallable$b = isCallable$i;
  var WeakMap$2 = globalThis$b.WeakMap;
  var weakMapBasicDetection = isCallable$b(WeakMap$2) && /native code/.test(String(WeakMap$2));
  var shared$4 = shared$6;
  var uid$1 = uid$3;
  var keys = shared$4("keys");
  var sharedKey$4 = function(key) {
    return keys[key] || (keys[key] = uid$1(key));
  };
  var hiddenKeys$5 = {};
  var NATIVE_WEAK_MAP = weakMapBasicDetection;
  var globalThis$a = globalThis_1;
  var isObject$6 = isObject$b;
  var createNonEnumerableProperty$3 = createNonEnumerableProperty$4;
  var hasOwn$a = hasOwnProperty_1;
  var shared$3 = sharedStoreExports;
  var sharedKey$3 = sharedKey$4;
  var hiddenKeys$4 = hiddenKeys$5;
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError$2 = globalThis$a.TypeError;
  var WeakMap$1 = globalThis$a.WeakMap;
  var set, get, has;
  var enforce = function(it) {
    return has(it) ? get(it) : set(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject$6(it) || (state = get(it)).type !== TYPE) {
        throw new TypeError$2("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared$3.state) {
    var store = shared$3.state || (shared$3.state = new WeakMap$1());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it, metadata) {
      if (store.has(it))
        throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store.set(it, metadata);
      return metadata;
    };
    get = function(it) {
      return store.get(it) || {};
    };
    has = function(it) {
      return store.has(it);
    };
  } else {
    var STATE = sharedKey$3("state");
    hiddenKeys$4[STATE] = true;
    set = function(it, metadata) {
      if (hasOwn$a(it, STATE))
        throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$3(it, STATE, metadata);
      return metadata;
    };
    get = function(it) {
      return hasOwn$a(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
      return hasOwn$a(it, STATE);
    };
  }
  var internalState = {
    set,
    get,
    has,
    enforce,
    getterFor
  };
  var uncurryThis$c = functionUncurryThis;
  var fails$9 = fails$g;
  var isCallable$a = isCallable$i;
  var hasOwn$9 = hasOwnProperty_1;
  var DESCRIPTORS$5 = descriptors;
  var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
  var inspectSource$1 = inspectSource$2;
  var InternalStateModule$2 = internalState;
  var enforceInternalState = InternalStateModule$2.enforce;
  var getInternalState$2 = InternalStateModule$2.get;
  var $String$3 = String;
  var defineProperty$8 = Object.defineProperty;
  var stringSlice$1 = uncurryThis$c("".slice);
  var replace$2 = uncurryThis$c("".replace);
  var join = uncurryThis$c([].join);
  var CONFIGURABLE_LENGTH = DESCRIPTORS$5 && !fails$9(function() {
    return defineProperty$8(function() {
    }, "length", { value: 8 }).length !== 8;
  });
  var TEMPLATE = String(String).split("String");
  var makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name, options) {
    if (stringSlice$1($String$3(name), 0, 7) === "Symbol(") {
      name = "[" + replace$2($String$3(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
    }
    if (options && options.getter)
      name = "get " + name;
    if (options && options.setter)
      name = "set " + name;
    if (!hasOwn$9(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
      if (DESCRIPTORS$5)
        defineProperty$8(value, "name", { value: name, configurable: true });
      else
        value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwn$9(options, "arity") && value.length !== options.arity) {
      defineProperty$8(value, "length", { value: options.arity });
    }
    try {
      if (options && hasOwn$9(options, "constructor") && options.constructor) {
        if (DESCRIPTORS$5)
          defineProperty$8(value, "prototype", { writable: false });
      } else if (value.prototype)
        value.prototype = void 0;
    } catch (error) {
    }
    var state = enforceInternalState(value);
    if (!hasOwn$9(state, "source")) {
      state.source = join(TEMPLATE, typeof name == "string" ? name : "");
    }
    return value;
  };
  Function.prototype.toString = makeBuiltIn$2(function toString2() {
    return isCallable$a(this) && getInternalState$2(this).source || inspectSource$1(this);
  }, "toString");
  var makeBuiltInExports = makeBuiltIn$3.exports;
  var isCallable$9 = isCallable$i;
  var definePropertyModule$4 = objectDefineProperty;
  var makeBuiltIn$1 = makeBuiltInExports;
  var defineGlobalProperty$1 = defineGlobalProperty$3;
  var defineBuiltIn$6 = function(O, key, value, options) {
    if (!options)
      options = {};
    var simple = options.enumerable;
    var name = options.name !== void 0 ? options.name : key;
    if (isCallable$9(value))
      makeBuiltIn$1(value, name, options);
    if (options.global) {
      if (simple)
        O[key] = value;
      else
        defineGlobalProperty$1(key, value);
    } else {
      try {
        if (!options.unsafe)
          delete O[key];
        else if (O[key])
          simple = true;
      } catch (error) {
      }
      if (simple)
        O[key] = value;
      else
        definePropertyModule$4.f(O, key, {
          value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
    }
    return O;
  };
  var objectGetOwnPropertyNames = {};
  var ceil = Math.ceil;
  var floor = Math.floor;
  var mathTrunc = Math.trunc || function trunc2(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
  };
  var trunc = mathTrunc;
  var toIntegerOrInfinity$2 = function(argument) {
    var number = +argument;
    return number !== number || number === 0 ? 0 : trunc(number);
  };
  var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
  var max$1 = Math.max;
  var min$1 = Math.min;
  var toAbsoluteIndex$1 = function(index, length) {
    var integer = toIntegerOrInfinity$1(index);
    return integer < 0 ? max$1(integer + length, 0) : min$1(integer, length);
  };
  var toIntegerOrInfinity = toIntegerOrInfinity$2;
  var min = Math.min;
  var toLength$1 = function(argument) {
    var len = toIntegerOrInfinity(argument);
    return len > 0 ? min(len, 9007199254740991) : 0;
  };
  var toLength = toLength$1;
  var lengthOfArrayLike$3 = function(obj) {
    return toLength(obj.length);
  };
  var toIndexedObject$5 = toIndexedObject$7;
  var toAbsoluteIndex = toAbsoluteIndex$1;
  var lengthOfArrayLike$2 = lengthOfArrayLike$3;
  var createMethod$1 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$5($this);
      var length = lengthOfArrayLike$2(O);
      if (length === 0)
        return !IS_INCLUDES && -1;
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el !== el)
        while (length > index) {
          value = O[index++];
          if (value !== value)
            return true;
        }
      else
        for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el)
            return IS_INCLUDES || index || 0;
        }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes = {
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$1(false)
  };
  var uncurryThis$b = functionUncurryThis;
  var hasOwn$8 = hasOwnProperty_1;
  var toIndexedObject$4 = toIndexedObject$7;
  var indexOf = arrayIncludes.indexOf;
  var hiddenKeys$3 = hiddenKeys$5;
  var push$3 = uncurryThis$b([].push);
  var objectKeysInternal = function(object, names) {
    var O = toIndexedObject$4(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O)
      !hasOwn$8(hiddenKeys$3, key) && hasOwn$8(O, key) && push$3(result, key);
    while (names.length > i)
      if (hasOwn$8(O, key = names[i++])) {
        ~indexOf(result, key) || push$3(result, key);
      }
    return result;
  };
  var enumBugKeys$3 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3;
  var hiddenKeys$2 = enumBugKeys$2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys$1(O, hiddenKeys$2);
  };
  var objectGetOwnPropertySymbols = {};
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  var getBuiltIn$6 = getBuiltIn$8;
  var uncurryThis$a = functionUncurryThis;
  var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
  var anObject$3 = anObject$5;
  var concat = uncurryThis$a([].concat);
  var ownKeys$1 = getBuiltIn$6("Reflect", "ownKeys") || function ownKeys2(it) {
    var keys2 = getOwnPropertyNamesModule$1.f(anObject$3(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$2.f;
    return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
  };
  var hasOwn$7 = hasOwnProperty_1;
  var ownKeys = ownKeys$1;
  var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
  var definePropertyModule$3 = objectDefineProperty;
  var copyConstructorProperties$2 = function(target, source, exceptions) {
    var keys2 = ownKeys(source);
    var defineProperty2 = definePropertyModule$3.f;
    var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule$1.f;
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (!hasOwn$7(target, key) && !(exceptions && hasOwn$7(exceptions, key))) {
        defineProperty2(target, key, getOwnPropertyDescriptor2(source, key));
      }
    }
  };
  var fails$8 = fails$g;
  var isCallable$8 = isCallable$i;
  var replacement = /#|\.prototype\./;
  var isForced$1 = function(feature, detection) {
    var value = data[normalize(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable$8(detection) ? fails$8(detection) : !!detection;
  };
  var normalize = isForced$1.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
  };
  var data = isForced$1.data = {};
  var NATIVE = isForced$1.NATIVE = "N";
  var POLYFILL = isForced$1.POLYFILL = "P";
  var isForced_1 = isForced$1;
  var globalThis$9 = globalThis_1;
  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$4;
  var defineBuiltIn$5 = defineBuiltIn$6;
  var defineGlobalProperty = defineGlobalProperty$3;
  var copyConstructorProperties$1 = copyConstructorProperties$2;
  var isForced = isForced_1;
  var _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED2, target, key, targetProperty, sourceProperty, descriptor2;
    if (GLOBAL) {
      target = globalThis$9;
    } else if (STATIC) {
      target = globalThis$9[TARGET] || defineGlobalProperty(TARGET, {});
    } else {
      target = globalThis$9[TARGET] && globalThis$9[TARGET].prototype;
    }
    if (target)
      for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor2 = getOwnPropertyDescriptor$2(target, key);
          targetProperty = descriptor2 && descriptor2.value;
        } else
          targetProperty = target[key];
        FORCED2 = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        if (!FORCED2 && targetProperty !== void 0) {
          if (typeof sourceProperty == typeof targetProperty)
            continue;
          copyConstructorProperties$1(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty$2(sourceProperty, "sham", true);
        }
        defineBuiltIn$5(target, key, sourceProperty, options);
      }
  };
  var classof$6 = classofRaw$2;
  var isArray$3 = Array.isArray || function isArray2(argument) {
    return classof$6(argument) === "Array";
  };
  var $TypeError$1 = TypeError;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var doesNotExceedSafeInteger$1 = function(it) {
    if (it > MAX_SAFE_INTEGER)
      throw $TypeError$1("Maximum allowed index exceeded");
    return it;
  };
  var DESCRIPTORS$4 = descriptors;
  var definePropertyModule$2 = objectDefineProperty;
  var createPropertyDescriptor$2 = createPropertyDescriptor$5;
  var createProperty$1 = function(object, key, value) {
    if (DESCRIPTORS$4)
      definePropertyModule$2.f(object, key, createPropertyDescriptor$2(0, value));
    else
      object[key] = value;
  };
  var wellKnownSymbol$d = wellKnownSymbol$f;
  var TO_STRING_TAG$2 = wellKnownSymbol$d("toStringTag");
  var test = {};
  test[TO_STRING_TAG$2] = "z";
  var toStringTagSupport = String(test) === "[object z]";
  var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
  var isCallable$7 = isCallable$i;
  var classofRaw$1 = classofRaw$2;
  var wellKnownSymbol$c = wellKnownSymbol$f;
  var TO_STRING_TAG$1 = wellKnownSymbol$c("toStringTag");
  var $Object$1 = Object;
  var CORRECT_ARGUMENTS = classofRaw$1(/* @__PURE__ */ function() {
    return arguments;
  }()) === "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (error) {
    }
  };
  var classof$5 = TO_STRING_TAG_SUPPORT$2 ? classofRaw$1 : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw$1(O) : (result = classofRaw$1(O)) === "Object" && isCallable$7(O.callee) ? "Arguments" : result;
  };
  var uncurryThis$9 = functionUncurryThis;
  var fails$7 = fails$g;
  var isCallable$6 = isCallable$i;
  var classof$4 = classof$5;
  var getBuiltIn$5 = getBuiltIn$8;
  var inspectSource = inspectSource$2;
  var noop = function() {
  };
  var construct = getBuiltIn$5("Reflect", "construct");
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec$1 = uncurryThis$9(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
  var isConstructorModern = function isConstructor2(argument) {
    if (!isCallable$6(argument))
      return false;
    try {
      construct(noop, [], argument);
      return true;
    } catch (error) {
      return false;
    }
  };
  var isConstructorLegacy = function isConstructor2(argument) {
    if (!isCallable$6(argument))
      return false;
    switch (classof$4(argument)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return INCORRECT_TO_STRING || !!exec$1(constructorRegExp, inspectSource(argument));
    } catch (error) {
      return true;
    }
  };
  isConstructorLegacy.sham = true;
  var isConstructor$1 = !construct || fails$7(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;
  var isArray$2 = isArray$3;
  var isConstructor = isConstructor$1;
  var isObject$5 = isObject$b;
  var wellKnownSymbol$b = wellKnownSymbol$f;
  var SPECIES$1 = wellKnownSymbol$b("species");
  var $Array = Array;
  var arraySpeciesConstructor$1 = function(originalArray) {
    var C;
    if (isArray$2(originalArray)) {
      C = originalArray.constructor;
      if (isConstructor(C) && (C === $Array || isArray$2(C.prototype)))
        C = void 0;
      else if (isObject$5(C)) {
        C = C[SPECIES$1];
        if (C === null)
          C = void 0;
      }
    }
    return C === void 0 ? $Array : C;
  };
  var arraySpeciesConstructor = arraySpeciesConstructor$1;
  var arraySpeciesCreate$2 = function(originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
  };
  var fails$6 = fails$g;
  var wellKnownSymbol$a = wellKnownSymbol$f;
  var V8_VERSION$1 = environmentV8Version;
  var SPECIES = wellKnownSymbol$a("species");
  var arrayMethodHasSpeciesSupport$1 = function(METHOD_NAME) {
    return V8_VERSION$1 >= 51 || !fails$6(function() {
      var array = [];
      var constructor = array.constructor = {};
      constructor[SPECIES] = function() {
        return { foo: 1 };
      };
      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };
  var $$8 = _export;
  var fails$5 = fails$g;
  var isArray$1 = isArray$3;
  var isObject$4 = isObject$b;
  var toObject$3 = toObject$5;
  var lengthOfArrayLike$1 = lengthOfArrayLike$3;
  var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;
  var createProperty = createProperty$1;
  var arraySpeciesCreate$1 = arraySpeciesCreate$2;
  var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$1;
  var wellKnownSymbol$9 = wellKnownSymbol$f;
  var V8_VERSION = environmentV8Version;
  var IS_CONCAT_SPREADABLE = wellKnownSymbol$9("isConcatSpreadable");
  var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$5(function() {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });
  var isConcatSpreadable = function(O) {
    if (!isObject$4(O))
      return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== void 0 ? !!spreadable : isArray$1(O);
  };
  var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
  $$8({ target: "Array", proto: true, arity: 1, forced: FORCED$1 }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat2(arg) {
      var O = toObject$3(this);
      var A = arraySpeciesCreate$1(O, 0);
      var n = 0;
      var i, k2, length, len, E;
      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = lengthOfArrayLike$1(E);
          doesNotExceedSafeInteger(n + len);
          for (k2 = 0; k2 < len; k2++, n++)
            if (k2 in E)
              createProperty(A, n, E[k2]);
        } else {
          doesNotExceedSafeInteger(n + 1);
          createProperty(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });
  var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
  var classof$3 = classof$5;
  var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString2() {
    return "[object " + classof$3(this) + "]";
  };
  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var defineBuiltIn$4 = defineBuiltIn$6;
  var toString$4 = objectToString;
  if (!TO_STRING_TAG_SUPPORT) {
    defineBuiltIn$4(Object.prototype, "toString", toString$4, { unsafe: true });
  }
  var classof$2 = classof$5;
  var $String$2 = String;
  var toString$3 = function(argument) {
    if (classof$2(argument) === "Symbol")
      throw new TypeError("Cannot convert a Symbol value to a string");
    return $String$2(argument);
  };
  var objectDefineProperties = {};
  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys$1 = enumBugKeys$3;
  var objectKeys$2 = Object.keys || function keys2(O) {
    return internalObjectKeys(O, enumBugKeys$1);
  };
  var DESCRIPTORS$3 = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var definePropertyModule$1 = objectDefineProperty;
  var anObject$2 = anObject$5;
  var toIndexedObject$3 = toIndexedObject$7;
  var objectKeys$1 = objectKeys$2;
  objectDefineProperties.f = DESCRIPTORS$3 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$2(O);
    var props = toIndexedObject$3(Properties);
    var keys2 = objectKeys$1(Properties);
    var length = keys2.length;
    var index = 0;
    var key;
    while (length > index)
      definePropertyModule$1.f(O, key = keys2[index++], props[key]);
    return O;
  };
  var getBuiltIn$4 = getBuiltIn$8;
  var html$1 = getBuiltIn$4("document", "documentElement");
  var anObject$1 = anObject$5;
  var definePropertiesModule$1 = objectDefineProperties;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys$1 = hiddenKeys$5;
  var html = html$1;
  var documentCreateElement$1 = documentCreateElement$2;
  var sharedKey$2 = sharedKey$4;
  var GT = ">";
  var LT = "<";
  var PROTOTYPE$1 = "prototype";
  var SCRIPT = "script";
  var IE_PROTO$1 = sharedKey$2("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement$1("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {
    }
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length = enumBugKeys.length;
    while (length--)
      delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];
    return NullProtoObject();
  };
  hiddenKeys$1[IE_PROTO$1] = true;
  var objectCreate = Object.create || function create2(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE$1] = anObject$1(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE$1] = null;
      result[IE_PROTO$1] = O;
    } else
      result = NullProtoObject();
    return Properties === void 0 ? result : definePropertiesModule$1.f(result, Properties);
  };
  var objectGetOwnPropertyNamesExternal = {};
  var uncurryThis$8 = functionUncurryThis;
  var arraySlice$2 = uncurryThis$8([].slice);
  var classof$1 = classofRaw$2;
  var toIndexedObject$2 = toIndexedObject$7;
  var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
  var arraySlice$1 = arraySlice$2;
  var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return $getOwnPropertyNames$1(it);
    } catch (error) {
      return arraySlice$1(windowNames);
    }
  };
  objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
    return windowNames && classof$1(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$2(it));
  };
  var makeBuiltIn = makeBuiltInExports;
  var defineProperty$7 = objectDefineProperty;
  var defineBuiltInAccessor$2 = function(target, name, descriptor2) {
    if (descriptor2.get)
      makeBuiltIn(descriptor2.get, name, { getter: true });
    if (descriptor2.set)
      makeBuiltIn(descriptor2.set, name, { setter: true });
    return defineProperty$7.f(target, name, descriptor2);
  };
  var wellKnownSymbolWrapped = {};
  var wellKnownSymbol$8 = wellKnownSymbol$f;
  wellKnownSymbolWrapped.f = wellKnownSymbol$8;
  var globalThis$8 = globalThis_1;
  var path$2 = globalThis$8;
  var path$1 = path$2;
  var hasOwn$6 = hasOwnProperty_1;
  var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
  var defineProperty$6 = objectDefineProperty.f;
  var wellKnownSymbolDefine = function(NAME) {
    var Symbol2 = path$1.Symbol || (path$1.Symbol = {});
    if (!hasOwn$6(Symbol2, NAME))
      defineProperty$6(Symbol2, NAME, {
        value: wrappedWellKnownSymbolModule$1.f(NAME)
      });
  };
  var call$4 = functionCall;
  var getBuiltIn$3 = getBuiltIn$8;
  var wellKnownSymbol$7 = wellKnownSymbol$f;
  var defineBuiltIn$3 = defineBuiltIn$6;
  var symbolDefineToPrimitive = function() {
    var Symbol2 = getBuiltIn$3("Symbol");
    var SymbolPrototype2 = Symbol2 && Symbol2.prototype;
    var valueOf = SymbolPrototype2 && SymbolPrototype2.valueOf;
    var TO_PRIMITIVE2 = wellKnownSymbol$7("toPrimitive");
    if (SymbolPrototype2 && !SymbolPrototype2[TO_PRIMITIVE2]) {
      defineBuiltIn$3(SymbolPrototype2, TO_PRIMITIVE2, function(hint) {
        return call$4(valueOf, this);
      }, { arity: 1 });
    }
  };
  var defineProperty$5 = objectDefineProperty.f;
  var hasOwn$5 = hasOwnProperty_1;
  var wellKnownSymbol$6 = wellKnownSymbol$f;
  var TO_STRING_TAG = wellKnownSymbol$6("toStringTag");
  var setToStringTag$8 = function(target, TAG2, STATIC) {
    if (target && !STATIC)
      target = target.prototype;
    if (target && !hasOwn$5(target, TO_STRING_TAG)) {
      defineProperty$5(target, TO_STRING_TAG, { configurable: true, value: TAG2 });
    }
  };
  var classofRaw = classofRaw$2;
  var uncurryThis$7 = functionUncurryThis;
  var functionUncurryThisClause = function(fn) {
    if (classofRaw(fn) === "Function")
      return uncurryThis$7(fn);
  };
  var uncurryThis$6 = functionUncurryThisClause;
  var aCallable$1 = aCallable$3;
  var NATIVE_BIND$1 = functionBindNative;
  var bind$1 = uncurryThis$6(uncurryThis$6.bind);
  var functionBindContext = function(fn, that) {
    aCallable$1(fn);
    return that === void 0 ? fn : NATIVE_BIND$1 ? bind$1(fn, that) : function() {
      return fn.apply(that, arguments);
    };
  };
  var bind = functionBindContext;
  var uncurryThis$5 = functionUncurryThis;
  var IndexedObject = indexedObject;
  var toObject$2 = toObject$5;
  var lengthOfArrayLike = lengthOfArrayLike$3;
  var arraySpeciesCreate = arraySpeciesCreate$2;
  var push$2 = uncurryThis$5([].push);
  var createMethod = function(TYPE) {
    var IS_MAP = TYPE === 1;
    var IS_FILTER = TYPE === 2;
    var IS_SOME = TYPE === 3;
    var IS_EVERY = TYPE === 4;
    var IS_FIND_INDEX = TYPE === 6;
    var IS_FILTER_REJECT = TYPE === 7;
    var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that, specificCreate) {
      var O = toObject$2($this);
      var self2 = IndexedObject(O);
      var length = lengthOfArrayLike(self2);
      var boundFunction = bind(callbackfn, that);
      var index = 0;
      var create2 = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
      var value, result;
      for (; length > index; index++)
        if (NO_HOLES || index in self2) {
          value = self2[index];
          result = boundFunction(value, index, O);
          if (TYPE) {
            if (IS_MAP)
              target[index] = result;
            else if (result)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return value;
                case 6:
                  return index;
                case 2:
                  push$2(target, value);
              }
            else
              switch (TYPE) {
                case 4:
                  return false;
                case 7:
                  push$2(target, value);
              }
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };
  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod(0)
  };
  var $$7 = _export;
  var globalThis$7 = globalThis_1;
  var call$3 = functionCall;
  var uncurryThis$4 = functionUncurryThis;
  var DESCRIPTORS$2 = descriptors;
  var NATIVE_SYMBOL$4 = symbolConstructorDetection;
  var fails$4 = fails$g;
  var hasOwn$4 = hasOwnProperty_1;
  var isPrototypeOf$1 = objectIsPrototypeOf;
  var anObject = anObject$5;
  var toIndexedObject$1 = toIndexedObject$7;
  var toPropertyKey = toPropertyKey$3;
  var $toString = toString$3;
  var createPropertyDescriptor$1 = createPropertyDescriptor$5;
  var nativeObjectCreate = objectCreate;
  var objectKeys = objectKeys$2;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
  var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var definePropertyModule = objectDefineProperty;
  var definePropertiesModule = objectDefineProperties;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var defineBuiltIn$2 = defineBuiltIn$6;
  var defineBuiltInAccessor$1 = defineBuiltInAccessor$2;
  var shared$2 = shared$6;
  var sharedKey$1 = sharedKey$4;
  var hiddenKeys = hiddenKeys$5;
  var uid = uid$3;
  var wellKnownSymbol$5 = wellKnownSymbol$f;
  var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
  var defineWellKnownSymbol$g = wellKnownSymbolDefine;
  var defineSymbolToPrimitive$1 = symbolDefineToPrimitive;
  var setToStringTag$7 = setToStringTag$8;
  var InternalStateModule$1 = internalState;
  var $forEach = arrayIteration.forEach;
  var HIDDEN = sharedKey$1("hidden");
  var SYMBOL = "Symbol";
  var PROTOTYPE = "prototype";
  var setInternalState$1 = InternalStateModule$1.set;
  var getInternalState$1 = InternalStateModule$1.getterFor(SYMBOL);
  var ObjectPrototype$1 = Object[PROTOTYPE];
  var $Symbol = globalThis$7.Symbol;
  var SymbolPrototype$1 = $Symbol && $Symbol[PROTOTYPE];
  var RangeError$1 = globalThis$7.RangeError;
  var TypeError$1 = globalThis$7.TypeError;
  var QObject = globalThis$7.QObject;
  var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  var nativeDefineProperty = definePropertyModule.f;
  var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
  var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
  var push$1 = uncurryThis$4([].push);
  var AllSymbols = shared$2("symbols");
  var ObjectPrototypeSymbols = shared$2("op-symbols");
  var WellKnownSymbolsStore = shared$2("wks");
  var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
  var fallbackDefineProperty = function(O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype$1, P);
    if (ObjectPrototypeDescriptor)
      delete ObjectPrototype$1[P];
    nativeDefineProperty(O, P, Attributes);
    if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
      nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
    }
  };
  var setSymbolDescriptor = DESCRIPTORS$2 && fails$4(function() {
    return nativeObjectCreate(nativeDefineProperty({}, "a", {
      get: function() {
        return nativeDefineProperty(this, "a", { value: 7 }).a;
      }
    })).a !== 7;
  }) ? fallbackDefineProperty : nativeDefineProperty;
  var wrap$1 = function(tag, description) {
    var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype$1);
    setInternalState$1(symbol, {
      type: SYMBOL,
      tag,
      description
    });
    if (!DESCRIPTORS$2)
      symbol.description = description;
    return symbol;
  };
  var $defineProperty = function defineProperty2(O, P, Attributes) {
    if (O === ObjectPrototype$1)
      $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject(O);
    var key = toPropertyKey(P);
    anObject(Attributes);
    if (hasOwn$4(AllSymbols, key)) {
      if (!Attributes.enumerable) {
        if (!hasOwn$4(O, HIDDEN))
          nativeDefineProperty(O, HIDDEN, createPropertyDescriptor$1(1, nativeObjectCreate(null)));
        O[HIDDEN][key] = true;
      } else {
        if (hasOwn$4(O, HIDDEN) && O[HIDDEN][key])
          O[HIDDEN][key] = false;
        Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor$1(0, false) });
      }
      return setSymbolDescriptor(O, key, Attributes);
    }
    return nativeDefineProperty(O, key, Attributes);
  };
  var $defineProperties = function defineProperties(O, Properties) {
    anObject(O);
    var properties = toIndexedObject$1(Properties);
    var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
    $forEach(keys2, function(key) {
      if (!DESCRIPTORS$2 || call$3($propertyIsEnumerable, properties, key))
        $defineProperty(O, key, properties[key]);
    });
    return O;
  };
  var $create = function create2(O, Properties) {
    return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(V) {
    var P = toPropertyKey(V);
    var enumerable = call$3(nativePropertyIsEnumerable, this, P);
    if (this === ObjectPrototype$1 && hasOwn$4(AllSymbols, P) && !hasOwn$4(ObjectPrototypeSymbols, P))
      return false;
    return enumerable || !hasOwn$4(this, P) || !hasOwn$4(AllSymbols, P) || hasOwn$4(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O, P) {
    var it = toIndexedObject$1(O);
    var key = toPropertyKey(P);
    if (it === ObjectPrototype$1 && hasOwn$4(AllSymbols, key) && !hasOwn$4(ObjectPrototypeSymbols, key))
      return;
    var descriptor2 = nativeGetOwnPropertyDescriptor(it, key);
    if (descriptor2 && hasOwn$4(AllSymbols, key) && !(hasOwn$4(it, HIDDEN) && it[HIDDEN][key])) {
      descriptor2.enumerable = true;
    }
    return descriptor2;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames(toIndexedObject$1(O));
    var result = [];
    $forEach(names, function(key) {
      if (!hasOwn$4(AllSymbols, key) && !hasOwn$4(hiddenKeys, key))
        push$1(result, key);
    });
    return result;
  };
  var $getOwnPropertySymbols = function(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$1(O));
    var result = [];
    $forEach(names, function(key) {
      if (hasOwn$4(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$4(ObjectPrototype$1, key))) {
        push$1(result, AllSymbols[key]);
      }
    });
    return result;
  };
  if (!NATIVE_SYMBOL$4) {
    $Symbol = function Symbol2() {
      if (isPrototypeOf$1(SymbolPrototype$1, this))
        throw new TypeError$1("Symbol is not a constructor");
      var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
      var tag = uid(description);
      var setter = function(value) {
        var $this = this === void 0 ? globalThis$7 : this;
        if ($this === ObjectPrototype$1)
          call$3(setter, ObjectPrototypeSymbols, value);
        if (hasOwn$4($this, HIDDEN) && hasOwn$4($this[HIDDEN], tag))
          $this[HIDDEN][tag] = false;
        var descriptor2 = createPropertyDescriptor$1(1, value);
        try {
          setSymbolDescriptor($this, tag, descriptor2);
        } catch (error) {
          if (!(error instanceof RangeError$1))
            throw error;
          fallbackDefineProperty($this, tag, descriptor2);
        }
      };
      if (DESCRIPTORS$2 && USE_SETTER)
        setSymbolDescriptor(ObjectPrototype$1, tag, { configurable: true, set: setter });
      return wrap$1(tag, description);
    };
    SymbolPrototype$1 = $Symbol[PROTOTYPE];
    defineBuiltIn$2(SymbolPrototype$1, "toString", function toString2() {
      return getInternalState$1(this).tag;
    });
    defineBuiltIn$2($Symbol, "withoutSetter", function(description) {
      return wrap$1(uid(description), description);
    });
    propertyIsEnumerableModule.f = $propertyIsEnumerable;
    definePropertyModule.f = $defineProperty;
    definePropertiesModule.f = $defineProperties;
    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    getOwnPropertySymbolsModule$1.f = $getOwnPropertySymbols;
    wrappedWellKnownSymbolModule.f = function(name) {
      return wrap$1(wellKnownSymbol$5(name), name);
    };
    if (DESCRIPTORS$2) {
      defineBuiltInAccessor$1(SymbolPrototype$1, "description", {
        configurable: true,
        get: function description() {
          return getInternalState$1(this).description;
        }
      });
      {
        defineBuiltIn$2(ObjectPrototype$1, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
      }
    }
  }
  $$7({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$4, sham: !NATIVE_SYMBOL$4 }, {
    Symbol: $Symbol
  });
  $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
    defineWellKnownSymbol$g(name);
  });
  $$7({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$4 }, {
    useSetter: function() {
      USE_SETTER = true;
    },
    useSimple: function() {
      USE_SETTER = false;
    }
  });
  $$7({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$4, sham: !DESCRIPTORS$2 }, {
    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
  });
  $$7({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$4 }, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames
  });
  defineSymbolToPrimitive$1();
  setToStringTag$7($Symbol, SYMBOL);
  hiddenKeys[HIDDEN] = true;
  var NATIVE_SYMBOL$3 = symbolConstructorDetection;
  var symbolRegistryDetection = NATIVE_SYMBOL$3 && !!Symbol["for"] && !!Symbol.keyFor;
  var $$6 = _export;
  var getBuiltIn$2 = getBuiltIn$8;
  var hasOwn$3 = hasOwnProperty_1;
  var toString$2 = toString$3;
  var shared$1 = shared$6;
  var NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;
  var StringToSymbolRegistry = shared$1("string-to-symbol-registry");
  var SymbolToStringRegistry$1 = shared$1("symbol-to-string-registry");
  $$6({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, {
    "for": function(key) {
      var string = toString$2(key);
      if (hasOwn$3(StringToSymbolRegistry, string))
        return StringToSymbolRegistry[string];
      var symbol = getBuiltIn$2("Symbol")(string);
      StringToSymbolRegistry[string] = symbol;
      SymbolToStringRegistry$1[symbol] = string;
      return symbol;
    }
  });
  var $$5 = _export;
  var hasOwn$2 = hasOwnProperty_1;
  var isSymbol$1 = isSymbol$4;
  var tryToString = tryToString$2;
  var shared = shared$6;
  var NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;
  var SymbolToStringRegistry = shared("symbol-to-string-registry");
  $$5({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
    keyFor: function keyFor(sym) {
      if (!isSymbol$1(sym))
        throw new TypeError(tryToString(sym) + " is not a symbol");
      if (hasOwn$2(SymbolToStringRegistry, sym))
        return SymbolToStringRegistry[sym];
    }
  });
  var NATIVE_BIND = functionBindNative;
  var FunctionPrototype$1 = Function.prototype;
  var apply$1 = FunctionPrototype$1.apply;
  var call$2 = FunctionPrototype$1.call;
  var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call$2.bind(apply$1) : function() {
    return call$2.apply(apply$1, arguments);
  });
  var uncurryThis$3 = functionUncurryThis;
  var isArray = isArray$3;
  var isCallable$5 = isCallable$i;
  var classof = classofRaw$2;
  var toString$1 = toString$3;
  var push = uncurryThis$3([].push);
  var getJsonReplacerFunction = function(replacer) {
    if (isCallable$5(replacer))
      return replacer;
    if (!isArray(replacer))
      return;
    var rawLength = replacer.length;
    var keys2 = [];
    for (var i = 0; i < rawLength; i++) {
      var element = replacer[i];
      if (typeof element == "string")
        push(keys2, element);
      else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String")
        push(keys2, toString$1(element));
    }
    var keysLength = keys2.length;
    var root = true;
    return function(key, value) {
      if (root) {
        root = false;
        return value;
      }
      if (isArray(this))
        return value;
      for (var j = 0; j < keysLength; j++)
        if (keys2[j] === key)
          return value;
    };
  };
  var $$4 = _export;
  var getBuiltIn$1 = getBuiltIn$8;
  var apply = functionApply;
  var call$1 = functionCall;
  var uncurryThis$2 = functionUncurryThis;
  var fails$3 = fails$g;
  var isCallable$4 = isCallable$i;
  var isSymbol = isSymbol$4;
  var arraySlice = arraySlice$2;
  var getReplacerFunction = getJsonReplacerFunction;
  var NATIVE_SYMBOL$2 = symbolConstructorDetection;
  var $String$1 = String;
  var $stringify = getBuiltIn$1("JSON", "stringify");
  var exec = uncurryThis$2(/./.exec);
  var charAt = uncurryThis$2("".charAt);
  var charCodeAt = uncurryThis$2("".charCodeAt);
  var replace$1 = uncurryThis$2("".replace);
  var numberToString = uncurryThis$2(1 .toString);
  var tester = /[\uD800-\uDFFF]/g;
  var low = /^[\uD800-\uDBFF]$/;
  var hi = /^[\uDC00-\uDFFF]$/;
  var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$2 || fails$3(function() {
    var symbol = getBuiltIn$1("Symbol")("stringify detection");
    return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
  });
  var ILL_FORMED_UNICODE = fails$3(function() {
    return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
  });
  var stringifyWithSymbolsFix = function(it, replacer) {
    var args = arraySlice(arguments);
    var $replacer = getReplacerFunction(replacer);
    if (!isCallable$4($replacer) && (it === void 0 || isSymbol(it)))
      return;
    args[1] = function(key, value) {
      if (isCallable$4($replacer))
        value = call$1($replacer, this, $String$1(key), value);
      if (!isSymbol(value))
        return value;
    };
    return apply($stringify, null, args);
  };
  var fixIllFormed = function(match2, offset, string) {
    var prev = charAt(string, offset - 1);
    var next = charAt(string, offset + 1);
    if (exec(low, match2) && !exec(hi, next) || exec(hi, match2) && !exec(low, prev)) {
      return "\\u" + numberToString(charCodeAt(match2, 0), 16);
    }
    return match2;
  };
  if ($stringify) {
    $$4({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      stringify: function stringify(it, replacer, space) {
        var args = arraySlice(arguments);
        var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
        return ILL_FORMED_UNICODE && typeof result == "string" ? replace$1(result, tester, fixIllFormed) : result;
      }
    });
  }
  var $$3 = _export;
  var NATIVE_SYMBOL$1 = symbolConstructorDetection;
  var fails$2 = fails$g;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var toObject$1 = toObject$5;
  var FORCED = !NATIVE_SYMBOL$1 || fails$2(function() {
    getOwnPropertySymbolsModule.f(1);
  });
  $$3({ target: "Object", stat: true, forced: FORCED }, {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      var $getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
      return $getOwnPropertySymbols2 ? $getOwnPropertySymbols2(toObject$1(it)) : [];
    }
  });
  var defineWellKnownSymbol$f = wellKnownSymbolDefine;
  defineWellKnownSymbol$f("asyncIterator");
  var $$2 = _export;
  var DESCRIPTORS$1 = descriptors;
  var globalThis$6 = globalThis_1;
  var uncurryThis$1 = functionUncurryThis;
  var hasOwn$1 = hasOwnProperty_1;
  var isCallable$3 = isCallable$i;
  var isPrototypeOf = objectIsPrototypeOf;
  var toString = toString$3;
  var defineBuiltInAccessor = defineBuiltInAccessor$2;
  var copyConstructorProperties = copyConstructorProperties$2;
  var NativeSymbol = globalThis$6.Symbol;
  var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
  if (DESCRIPTORS$1 && isCallable$3(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
  NativeSymbol().description !== void 0)) {
    var EmptyStringDescriptionStore = {};
    var SymbolWrapper = function Symbol2() {
      var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
      var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
      if (description === "")
        EmptyStringDescriptionStore[result] = true;
      return result;
    };
    copyConstructorProperties(SymbolWrapper, NativeSymbol);
    SymbolWrapper.prototype = SymbolPrototype;
    SymbolPrototype.constructor = SymbolWrapper;
    var NATIVE_SYMBOL = String(NativeSymbol("description detection")) === "Symbol(description detection)";
    var thisSymbolValue = uncurryThis$1(SymbolPrototype.valueOf);
    var symbolDescriptiveString = uncurryThis$1(SymbolPrototype.toString);
    var regexp = /^Symbol\((.*)\)[^)]+$/;
    var replace = uncurryThis$1("".replace);
    var stringSlice = uncurryThis$1("".slice);
    defineBuiltInAccessor(SymbolPrototype, "description", {
      configurable: true,
      get: function description() {
        var symbol = thisSymbolValue(this);
        if (hasOwn$1(EmptyStringDescriptionStore, symbol))
          return "";
        var string = symbolDescriptiveString(symbol);
        var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
        return desc === "" ? void 0 : desc;
      }
    });
    $$2({ global: true, constructor: true, forced: true }, {
      Symbol: SymbolWrapper
    });
  }
  var defineWellKnownSymbol$e = wellKnownSymbolDefine;
  defineWellKnownSymbol$e("hasInstance");
  var defineWellKnownSymbol$d = wellKnownSymbolDefine;
  defineWellKnownSymbol$d("isConcatSpreadable");
  var defineWellKnownSymbol$c = wellKnownSymbolDefine;
  defineWellKnownSymbol$c("iterator");
  var defineWellKnownSymbol$b = wellKnownSymbolDefine;
  defineWellKnownSymbol$b("match");
  var defineWellKnownSymbol$a = wellKnownSymbolDefine;
  defineWellKnownSymbol$a("matchAll");
  var defineWellKnownSymbol$9 = wellKnownSymbolDefine;
  defineWellKnownSymbol$9("replace");
  var defineWellKnownSymbol$8 = wellKnownSymbolDefine;
  defineWellKnownSymbol$8("search");
  var defineWellKnownSymbol$7 = wellKnownSymbolDefine;
  defineWellKnownSymbol$7("species");
  var defineWellKnownSymbol$6 = wellKnownSymbolDefine;
  defineWellKnownSymbol$6("split");
  var defineWellKnownSymbol$5 = wellKnownSymbolDefine;
  var defineSymbolToPrimitive = symbolDefineToPrimitive;
  defineWellKnownSymbol$5("toPrimitive");
  defineSymbolToPrimitive();
  var getBuiltIn = getBuiltIn$8;
  var defineWellKnownSymbol$4 = wellKnownSymbolDefine;
  var setToStringTag$6 = setToStringTag$8;
  defineWellKnownSymbol$4("toStringTag");
  setToStringTag$6(getBuiltIn("Symbol"), "Symbol");
  var defineWellKnownSymbol$3 = wellKnownSymbolDefine;
  defineWellKnownSymbol$3("unscopables");
  var globalThis$5 = globalThis_1;
  var setToStringTag$5 = setToStringTag$8;
  setToStringTag$5(globalThis$5.JSON, "JSON", true);
  var setToStringTag$4 = setToStringTag$8;
  setToStringTag$4(Math, "Math", true);
  var $$1 = _export;
  var globalThis$4 = globalThis_1;
  var setToStringTag$3 = setToStringTag$8;
  $$1({ global: true }, { Reflect: {} });
  setToStringTag$3(globalThis$4.Reflect, "Reflect", true);
  var path = path$2;
  path.Symbol;
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  var documentCreateElement = documentCreateElement$2;
  var classList = documentCreateElement("span").classList;
  var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
  var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
  var wellKnownSymbol$4 = wellKnownSymbol$f;
  var create$1 = objectCreate;
  var defineProperty$4 = objectDefineProperty.f;
  var UNSCOPABLES = wellKnownSymbol$4("unscopables");
  var ArrayPrototype = Array.prototype;
  if (ArrayPrototype[UNSCOPABLES] === void 0) {
    defineProperty$4(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create$1(null)
    });
  }
  var addToUnscopables$1 = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };
  var iterators = {};
  var fails$1 = fails$g;
  var correctPrototypeGetter = !fails$1(function() {
    function F() {
    }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });
  var hasOwn = hasOwnProperty_1;
  var isCallable$2 = isCallable$i;
  var toObject = toObject$5;
  var sharedKey = sharedKey$4;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
  var IE_PROTO = sharedKey("IE_PROTO");
  var $Object = Object;
  var ObjectPrototype = $Object.prototype;
  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
    var object = toObject(O);
    if (hasOwn(object, IE_PROTO))
      return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable$2(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }
    return object instanceof $Object ? ObjectPrototype : null;
  };
  var fails = fails$g;
  var isCallable$1 = isCallable$i;
  var isObject$3 = isObject$b;
  var getPrototypeOf$1 = objectGetPrototypeOf;
  var defineBuiltIn$1 = defineBuiltIn$6;
  var wellKnownSymbol$3 = wellKnownSymbol$f;
  var ITERATOR$2 = wellKnownSymbol$3("iterator");
  var BUGGY_SAFARI_ITERATORS$1 = false;
  var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
  if ([].keys) {
    arrayIterator = [].keys();
    if (!("next" in arrayIterator))
      BUGGY_SAFARI_ITERATORS$1 = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
        IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
    }
  }
  var NEW_ITERATOR_PROTOTYPE = !isObject$3(IteratorPrototype$2) || fails(function() {
    var test2 = {};
    return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
  });
  if (NEW_ITERATOR_PROTOTYPE)
    IteratorPrototype$2 = {};
  if (!isCallable$1(IteratorPrototype$2[ITERATOR$2])) {
    defineBuiltIn$1(IteratorPrototype$2, ITERATOR$2, function() {
      return this;
    });
  }
  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$2,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };
  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
  var create = objectCreate;
  var createPropertyDescriptor = createPropertyDescriptor$5;
  var setToStringTag$2 = setToStringTag$8;
  var Iterators$2 = iterators;
  var returnThis$1 = function() {
    return this;
  };
  var iteratorCreateConstructor = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG2 = NAME + " Iterator";
    IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
    setToStringTag$2(IteratorConstructor, TO_STRING_TAG2, false);
    Iterators$2[TO_STRING_TAG2] = returnThis$1;
    return IteratorConstructor;
  };
  var uncurryThis = functionUncurryThis;
  var aCallable = aCallable$3;
  var functionUncurryThisAccessor = function(object, key, method) {
    try {
      return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {
    }
  };
  var isObject$2 = isObject$b;
  var isPossiblePrototype$1 = function(argument) {
    return isObject$2(argument) || argument === null;
  };
  var isPossiblePrototype = isPossiblePrototype$1;
  var $String = String;
  var $TypeError = TypeError;
  var aPossiblePrototype$1 = function(argument) {
    if (isPossiblePrototype(argument))
      return argument;
    throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
  };
  var uncurryThisAccessor = functionUncurryThisAccessor;
  var isObject$1 = isObject$b;
  var requireObjectCoercible = requireObjectCoercible$3;
  var aPossiblePrototype = aPossiblePrototype$1;
  var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
    var CORRECT_SETTER = false;
    var test2 = {};
    var setter;
    try {
      setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
      setter(test2, []);
      CORRECT_SETTER = test2 instanceof Array;
    } catch (error) {
    }
    return function setPrototypeOf2(O, proto) {
      requireObjectCoercible(O);
      aPossiblePrototype(proto);
      if (!isObject$1(O))
        return O;
      if (CORRECT_SETTER)
        setter(O, proto);
      else
        O.__proto__ = proto;
      return O;
    };
  }() : void 0);
  var $ = _export;
  var call = functionCall;
  var FunctionName = functionName;
  var isCallable = isCallable$i;
  var createIteratorConstructor = iteratorCreateConstructor;
  var getPrototypeOf = objectGetPrototypeOf;
  var setPrototypeOf = objectSetPrototypeOf;
  var setToStringTag$1 = setToStringTag$8;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$4;
  var defineBuiltIn = defineBuiltIn$6;
  var wellKnownSymbol$2 = wellKnownSymbol$f;
  var Iterators$1 = iterators;
  var IteratorsCore = iteratorsCore;
  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$1 = wellKnownSymbol$2("iterator");
  var KEYS = "keys";
  var VALUES = "values";
  var ENTRIES = "entries";
  var returnThis = function() {
    return this;
  };
  var iteratorDefine = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED2) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator)
        return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
        return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS:
          return function keys2() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES:
          return function values2() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG2 = NAME + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf) {
            setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
          } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$1])) {
            defineBuiltIn(CurrentIteratorPrototype, ITERATOR$1, returnThis);
          }
        }
        setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG2, true);
      }
    }
    if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if (CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty$1(IterablePrototype, "name", VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values2() {
          return call(nativeIterator, this);
        };
      }
    }
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED2)
        for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        }
      else
        $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }
    if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
      defineBuiltIn(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
    }
    Iterators$1[NAME] = defaultIterator;
    return methods;
  };
  var createIterResultObject$1 = function(value, done) {
    return { value, done };
  };
  var toIndexedObject = toIndexedObject$7;
  var addToUnscopables = addToUnscopables$1;
  var Iterators = iterators;
  var InternalStateModule = internalState;
  var defineProperty$3 = objectDefineProperty.f;
  var defineIterator = iteratorDefine;
  var createIterResultObject = createIterResultObject$1;
  var DESCRIPTORS = descriptors;
  var ARRAY_ITERATOR = "Array Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
  var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState(this);
    var target = state.target;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = null;
      return createIterResultObject(void 0, true);
    }
    switch (state.kind) {
      case "keys":
        return createIterResultObject(index, false);
      case "values":
        return createIterResultObject(target[index], false);
    }
    return createIterResultObject([index, target[index]], false);
  }, "values");
  var values = Iterators.Arguments = Iterators.Array;
  addToUnscopables("keys");
  addToUnscopables("values");
  addToUnscopables("entries");
  if (DESCRIPTORS && values.name !== "values")
    try {
      defineProperty$3(values, "name", { value: "values" });
    } catch (error) {
    }
  var globalThis$3 = globalThis_1;
  var DOMIterables = domIterables;
  var DOMTokenListPrototype = domTokenListPrototype;
  var ArrayIteratorMethods = es_array_iterator;
  var createNonEnumerableProperty = createNonEnumerableProperty$4;
  var setToStringTag = setToStringTag$8;
  var wellKnownSymbol$1 = wellKnownSymbol$f;
  var ITERATOR = wellKnownSymbol$1("iterator");
  var ArrayValues = ArrayIteratorMethods.values;
  var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
    if (CollectionPrototype) {
      if (CollectionPrototype[ITERATOR] !== ArrayValues)
        try {
          createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR] = ArrayValues;
        }
      setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
      if (DOMIterables[COLLECTION_NAME2])
        for (var METHOD_NAME in ArrayIteratorMethods) {
          if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
            try {
              createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
            } catch (error) {
              CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
            }
        }
    }
  };
  for (var COLLECTION_NAME in DOMIterables) {
    handlePrototype(globalThis$3[COLLECTION_NAME] && globalThis$3[COLLECTION_NAME].prototype, COLLECTION_NAME);
  }
  handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  var wellKnownSymbol = wellKnownSymbol$f;
  var defineProperty$2 = objectDefineProperty.f;
  var METADATA = wellKnownSymbol("metadata");
  var FunctionPrototype = Function.prototype;
  if (FunctionPrototype[METADATA] === void 0) {
    defineProperty$2(FunctionPrototype, METADATA, {
      value: null
    });
  }
  var globalThis$2 = globalThis_1;
  var defineWellKnownSymbol$2 = wellKnownSymbolDefine;
  var defineProperty$1 = objectDefineProperty.f;
  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  var Symbol$2 = globalThis$2.Symbol;
  defineWellKnownSymbol$2("asyncDispose");
  if (Symbol$2) {
    var descriptor$1 = getOwnPropertyDescriptor$1(Symbol$2, "asyncDispose");
    if (descriptor$1.enumerable && descriptor$1.configurable && descriptor$1.writable) {
      defineProperty$1(Symbol$2, "asyncDispose", { value: descriptor$1.value, enumerable: false, configurable: false, writable: false });
    }
  }
  var globalThis$1 = globalThis_1;
  var defineWellKnownSymbol$1 = wellKnownSymbolDefine;
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var Symbol$1 = globalThis$1.Symbol;
  defineWellKnownSymbol$1("dispose");
  if (Symbol$1) {
    var descriptor = getOwnPropertyDescriptor(Symbol$1, "dispose");
    if (descriptor.enumerable && descriptor.configurable && descriptor.writable) {
      defineProperty(Symbol$1, "dispose", { value: descriptor.value, enumerable: false, configurable: false, writable: false });
    }
  }
  var defineWellKnownSymbol = wellKnownSymbolDefine;
  defineWellKnownSymbol("metadata");
  var eventemitter3 = { exports: {} };
  (function(module) {
    var has2 = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has2.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
  class AbortSignal {
    constructor() {
      this.eventEmitter = new EventEmitter();
      this.onabort = null;
      this.aborted = false;
      this.reason = void 0;
    }
    toString() {
      return "[object AbortSignal]";
    }
    get [Symbol.toStringTag]() {
      return "AbortSignal";
    }
    removeEventListener(name, handler) {
      this.eventEmitter.removeListener(name, handler);
    }
    addEventListener(name, handler) {
      this.eventEmitter.on(name, handler);
    }
    dispatchEvent(type) {
      const event = { type, target: this };
      const handlerName = `on${type}`;
      if (typeof this[handlerName] === "function")
        this[handlerName](event);
      this.eventEmitter.emit(type, event);
    }
    throwIfAborted() {
      if (this.aborted) {
        throw this.reason;
      }
    }
    static abort(reason) {
      const controller = new AbortController$1();
      controller.abort();
      return controller.signal;
    }
    static timeout(time) {
      const controller = new AbortController$1();
      setTimeout(() => {
        const err2 = new Error("TimeoutError");
        err2.name = "TimeoutError";
        controller.abort(err2);
      }, time);
      return controller.signal;
    }
  }
  let AbortController$1 = class AbortController {
    constructor() {
      this.signal = new AbortSignal();
    }
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.aborted = true;
      if (reason)
        this.signal.reason = reason;
      else {
        const err2 = new Error("AbortError");
        err2.name = "AbortError";
        this.signal.reason = err2;
      }
      this.signal.dispatchEvent("abort");
    }
    toString() {
      return "[object AbortController]";
    }
    get [Symbol.toStringTag]() {
      return "AbortController";
    }
  };
  {
    Object.assign(self, { AbortController: AbortController$1, AbortSignal });
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */
  const proxyMarker = Symbol("Comlink.proxy");
  const createEndpoint = Symbol("Comlink.endpoint");
  const releaseProxy = Symbol("Comlink.releaseProxy");
  const finalizer = Symbol("Comlink.finalizer");
  const throwMarker = Symbol("Comlink.thrown");
  const isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
  const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
      const { port1, port2 } = new MessageChannel();
      expose(obj, port1);
      return [port2, [port2]];
    },
    deserialize(port) {
      port.start();
      return wrap(port);
    }
  };
  const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
      let serialized;
      if (value instanceof Error) {
        serialized = {
          isError: true,
          value: {
            message: value.message,
            name: value.name,
            stack: value.stack
          }
        };
      } else {
        serialized = { isError: false, value };
      }
      return [serialized, []];
    },
    deserialize(serialized) {
      if (serialized.isError) {
        throw Object.assign(new Error(serialized.value.message), serialized.value);
      }
      throw serialized.value;
    }
  };
  const transferHandlers = /* @__PURE__ */ new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler]
  ]);
  function isAllowedOrigin(allowedOrigins, origin) {
    for(let   allowedOrigin of allowedOrigins) {
      if (origin === allowedOrigin || allowedOrigin === "*") {
        return true;
      }
      if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
        return true;
      }
    }
    return false;
  }
  function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
      if (!ev || !ev.data) {
        return;
      }
      if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
        console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
        return;
      }
      const { id: id2, type, path: path2 } = Object.assign({ path: [] }, ev.data);
      const argumentList = (ev.data.argumentList || []).map(fromWireValue);
      let returnValue;
      try {
        const parent = path2.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
        const rawValue = path2.reduce((obj2, prop) => obj2[prop], obj);
        switch (type) {
          case "GET":
            {
              returnValue = rawValue;
            }
            break;
          case "SET":
            {
              parent[path2.slice(-1)[0]] = fromWireValue(ev.data.value);
              returnValue = true;
            }
            break;
          case "APPLY":
            {
              returnValue = rawValue.apply(parent, argumentList);
            }
            break;
          case "CONSTRUCT":
            {
              const value = new rawValue(...argumentList);
              returnValue = proxy(value);
            }
            break;
          case "ENDPOINT":
            {
              const { port1, port2 } = new MessageChannel();
              expose(obj, port2);
              returnValue = transfer(port1, [port1]);
            }
            break;
          case "RELEASE":
            {
              returnValue = void 0;
            }
            break;
          default:
            return;
        }
      } catch (value) {
        returnValue = { value, [throwMarker]: 0 };
      }
      Promise.resolve(returnValue).catch((value) => {
        return { value, [throwMarker]: 0 };
      }).then((returnValue2) => {
        const [wireValue, transferables] = toWireValue(returnValue2);
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
        if (type === "RELEASE") {
          ep.removeEventListener("message", callback);
          closeEndPoint(ep);
          if (finalizer in obj && typeof obj[finalizer] === "function") {
            obj[finalizer]();
          }
        }
      }).catch((error) => {
        const [wireValue, transferables] = toWireValue({
          value: new TypeError("Unserializable return value"),
          [throwMarker]: 0
        });
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      });
    });
    if (ep.start) {
      ep.start();
    }
  }
  function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
  }
  function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
      endpoint.close();
  }
  function wrap(ep, target) {
    const pendingListeners = /* @__PURE__ */ new Map();
    ep.addEventListener("message", function handleMessage(ev) {
      const { data: data2 } = ev;
      if (!data2 || !data2.id) {
        return;
      }
      const resolver = pendingListeners.get(data2.id);
      if (!resolver) {
        return;
      }
      try {
        resolver(data2);
      } finally {
        pendingListeners.delete(data2.id);
      }
    });
    return createProxy(ep, pendingListeners, [], target);
  }
  function throwIfProxyReleased(isReleased) {
    if (isReleased) {
      throw new Error("Proxy has been released and is not useable");
    }
  }
  function releaseEndpoint(ep) {
    return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
      type: "RELEASE"
    }).then(() => {
      closeEndPoint(ep);
    });
  }
  const proxyCounter = /* @__PURE__ */ new WeakMap();
  const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
    const newCount = (proxyCounter.get(ep) || 0) - 1;
    proxyCounter.set(ep, newCount);
    if (newCount === 0) {
      releaseEndpoint(ep);
    }
  });
  function registerProxy(proxy2, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
      proxyFinalizers.register(proxy2, ep, proxy2);
    }
  }
  function unregisterProxy(proxy2) {
    if (proxyFinalizers) {
      proxyFinalizers.unregister(proxy2);
    }
  }
  function createProxy(ep, pendingListeners, path2 = [], target = function() {
  }) {
    let isProxyReleased = false;
    const proxy2 = new Proxy(target, {
      get(_target, prop) {
        throwIfProxyReleased(isProxyReleased);
        if (prop === releaseProxy) {
          return () => {
            unregisterProxy(proxy2);
            releaseEndpoint(ep);
            pendingListeners.clear();
            isProxyReleased = true;
          };
        }
        if (prop === "then") {
          if (path2.length === 0) {
            return { then: () => proxy2 };
          }
          const r = requestResponseMessage(ep, pendingListeners, {
            type: "GET",
            path: path2.map((p) => p.toString())
          }).then(fromWireValue);
          return r.then.bind(r);
        }
        return createProxy(ep, pendingListeners, [...path2, prop]);
      },
      set(_target, prop, rawValue) {
        throwIfProxyReleased(isProxyReleased);
        const [value, transferables] = toWireValue(rawValue);
        return requestResponseMessage(ep, pendingListeners, {
          type: "SET",
          path: [...path2, prop].map((p) => p.toString()),
          value
        }, transferables).then(fromWireValue);
      },
      apply(_target, _thisArg, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const last = path2[path2.length - 1];
        if (last === createEndpoint) {
          return requestResponseMessage(ep, pendingListeners, {
            type: "ENDPOINT"
          }).then(fromWireValue);
        }
        if (last === "bind") {
          return createProxy(ep, pendingListeners, path2.slice(0, -1));
        }
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "APPLY",
          path: path2.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      },
      construct(_target, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "CONSTRUCT",
          path: path2.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      }
    });
    registerProxy(proxy2, ep);
    return proxy2;
  }
  function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
  }
  const transferCache = /* @__PURE__ */ new WeakMap();
  function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
  }
  function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
  }
  function toWireValue(value) {
    for(let   [name, handler] of transferHandlers) {
      if (handler.canHandle(value)) {
        const [serializedValue, transferables] = handler.serialize(value);
        return [
          {
            type: "HANDLER",
            name,
            value: serializedValue
          },
          transferables
        ];
      }
    }
    return [
      {
        type: "RAW",
        value
      },
      transferCache.get(value) || []
    ];
  }
  function fromWireValue(value) {
    switch (value.type) {
      case "HANDLER":
        return transferHandlers.get(value.name).deserialize(value.value);
      case "RAW":
        return value.value;
    }
  }
  function requestResponseMessage(ep, pendingListeners, msg, transfers) {
    return new Promise((resolve) => {
      const id2 = generateUUID();
      pendingListeners.set(id2, resolve);
      if (ep.start) {
        ep.start();
      }
      ep.postMessage(Object.assign({ id: id2 }, msg), transfers);
    });
  }
  function generateUUID() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
  }
  class MtcuteError extends Error {
  }
  class MtArgumentError extends MtcuteError {
  }
  class MtSecurityError extends MtcuteError {
  }
  class MtUnsupportedError extends MtcuteError {
  }
  class MtTypeAssertionError extends MtcuteError {
    constructor(context, expected, actual) {
      super(`Type assertion error at ${context}: expected ${expected}, but got ${actual}`);
      /**
       * Context at which the error occurred.
       * Usually a user-friendly string containing name
       * of the high-level API method, name of the TL
       * RPC method, and path of the entity,
       * like this: `signIn (@ auth.signIn -> user)`
       */
      __publicField(this, "context");
      /** Expected TL type */
      __publicField(this, "expected");
      /** Actual TL type */
      __publicField(this, "actual");
      this.context = context;
      this.expected = expected;
      this.actual = actual;
    }
  }
  class MtTimeoutError extends MtcuteError {
    constructor(timeout) {
      super(`Request timed out${timeout ? ` after ${timeout}ms` : ""}`);
      this.timeout = timeout;
    }
  }
  function assertNever$1(_) {
    throw new Error("Illegal state");
  }
  var tl = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tl = {};
    (function(ns) {
      var _types = void 0;
      function _isAny(type) {
        return function(obj) {
          return typeof obj === "object" && obj && _types[obj._] == type;
        };
      }
      ns.$extendTypes = function(types) {
        for (var i in types) {
          types.hasOwnProperty(i) && (_types[i] = types[i]);
        }
      };
      ns.LAYER = 189;
      const _descriptionsMap = JSON.parse(`{"FLOOD_WAIT_%d":"A wait of %d seconds is required","FILE_MIGRATE_%d":"The file to be accessed is currently stored in DC %d","NETWORK_MIGRATE_%d":"The source IP address is associated with DC %d","PHONE_MIGRATE_%d":"The phone number a user is trying to use for authorization is associated with DC %d","STATS_MIGRATE_%d":"The channel statistics must be fetched from DC %d","ABOUT_TOO_LONG":"About string too long.","ACCESS_TOKEN_EXPIRED":"Access token expired.","ACCESS_TOKEN_INVALID":"Access token invalid.","ADMIN_ID_INVALID":"The specified admin ID is invalid.","ADMIN_RANK_EMOJI_NOT_ALLOWED":"An admin rank cannot contain emojis.","ADMIN_RANK_INVALID":"The specified admin rank is invalid.","ADMINS_TOO_MUCH":"There are too many admins.","ALBUM_PHOTOS_TOO_MANY":"You have uploaded too many profile photos, delete some before retrying.","API_ID_INVALID":"API ID invalid.","API_ID_PUBLISHED_FLOOD":"This API id was published somewhere, you can't use it now.","ARTICLE_TITLE_EMPTY":"The title of the article is empty.","AUDIO_CONTENT_URL_EMPTY":"The remote URL specified in the content field is empty.","AUDIO_TITLE_EMPTY":"An empty audio title was provided.","AUTH_BYTES_INVALID":"The provided authorization is invalid.","AUTH_TOKEN_ALREADY_ACCEPTED":"The specified auth token was already accepted.","AUTH_TOKEN_EXCEPTION":"An error occurred while importing the auth token.","AUTH_TOKEN_EXPIRED":"The authorization token has expired.","AUTH_TOKEN_INVALID":"The specified auth token is invalid.","AUTH_TOKEN_INVALIDX":"The specified auth token is invalid.","AUTOARCHIVE_NOT_AVAILABLE":"The autoarchive setting is not available at this time: please check the value of the [autoarchive_setting_available field in client config &raquo;](https://core.telegram.org/api/config#client-configuration) before calling this method.","BANK_CARD_NUMBER_INVALID":"The specified card number is invalid.","BANNED_RIGHTS_INVALID":"You provided some invalid flags in the banned rights.","BOT_APP_INVALID":"The specified bot app is invalid.","BOT_CHANNELS_NA":"Bots can't edit admin privileges.","BOT_COMMAND_DESCRIPTION_INVALID":"The specified command description is invalid.","BOT_COMMAND_INVALID":"The specified command is invalid.","BOT_DOMAIN_INVALID":"Bot domain invalid.","BOT_GROUPS_BLOCKED":"This bot can't be added to groups.","BOT_INLINE_DISABLED":"This bot can't be used in inline mode.","BOT_INVALID":"This is not a valid bot.","BOT_MISSING":"Only bots can call this method, please use [@stickers](https://t.me/stickers) if you're a user.","BOT_ONESIDE_NOT_AVAIL":"Bots can't pin messages in PM just for themselves.","BOT_PAYMENTS_DISABLED":"Please enable bot payments in botfather before calling this method.","BOT_RESPONSE_TIMEOUT":"A timeout occurred while fetching data from the bot.","BOT_SCORE_NOT_MODIFIED":"The score wasn't modified.","BOTS_TOO_MUCH":"There are too many bots in this chat/channel.","BROADCAST_ID_INVALID":"Broadcast ID invalid.","BROADCAST_PUBLIC_VOTERS_FORBIDDEN":"You can't forward polls with public voters.","BROADCAST_REQUIRED":"This method can only be called on a channel, please use stats.getMegagroupStats for supergroups.","BUTTON_DATA_INVALID":"The data of one or more of the buttons you provided is invalid.","BUTTON_TEXT_INVALID":"The specified button text is invalid.","BUTTON_TYPE_INVALID":"The type of one or more of the buttons you provided is invalid.","BUTTON_URL_INVALID":"Button URL invalid.","BUTTON_USER_PRIVACY_RESTRICTED":"The privacy setting of the user specified in a [inputKeyboardButtonUserProfile](/constructor/inputKeyboardButtonUserProfile) button do not allow creating such a button.","CALL_ALREADY_ACCEPTED":"The call was already accepted.","CALL_ALREADY_DECLINED":"The call was already declined.","CALL_OCCUPY_FAILED":"The call failed because the user is already making another call.","CALL_PEER_INVALID":"The provided call peer object is invalid.","CALL_PROTOCOL_FLAGS_INVALID":"Call protocol flags invalid.","CDN_METHOD_INVALID":"You can't call this method in a CDN DC.","CHANNEL_FORUM_MISSING":"This supergroup is not a forum.","CHANNEL_ID_INVALID":"The specified supergroup ID is invalid.","CHANNEL_INVALID":"The provided channel is invalid.","CHANNEL_PARICIPANT_MISSING":"The current user is not in the channel.","CHANNEL_PRIVATE":"You haven't joined this channel/supergroup.","CHANNEL_TOO_BIG":"This channel has too many participants (>1000) to be deleted.","CHANNEL_TOO_LARGE":"Channel is too large to be deleted; this error is issued when trying to delete channels with more than 1000 members (subject to change).","CHANNELS_ADMIN_LOCATED_TOO_MUCH":"The user has reached the limit of public geogroups.","CHANNELS_ADMIN_PUBLIC_TOO_MUCH":"You're admin of too many public channels, make some channels private to change the username of this channel.","CHANNELS_TOO_MUCH":"You have joined too many channels/supergroups.","CHAT_ABOUT_NOT_MODIFIED":"About text has not changed.","CHAT_ABOUT_TOO_LONG":"Chat about too long.","CHAT_ADMIN_REQUIRED":"You must be an admin in this chat to do this.","CHAT_DISCUSSION_UNALLOWED":"You can't enable forum topics in a discussion group linked to a channel.","CHAT_FORWARDS_RESTRICTED":"You can't forward messages from a protected chat.","CHAT_ID_EMPTY":"The provided chat ID is empty.","CHAT_ID_INVALID":"The provided chat id is invalid.","CHAT_INVALID":"Invalid chat.","CHAT_INVITE_PERMANENT":"You can't set an expiration date on permanent invite links.","CHAT_LINK_EXISTS":"The chat is public, you can't hide the history to new users.","CHAT_NOT_MODIFIED":"The pinned message wasn't modified.","CHAT_PUBLIC_REQUIRED":"You can only enable join requests in public groups.","CHAT_RESTRICTED":"You can't send messages in this chat, you were restricted.","CHAT_REVOKE_DATE_UNSUPPORTED":"\`min_date\` and \`max_date\` are not available for using with non-user peers.","CHAT_SEND_INLINE_FORBIDDEN":"You can't send inline messages in this group.","CHAT_TITLE_EMPTY":"No chat title provided.","CHAT_TOO_BIG":"This method is not available for groups with more than \`chat_read_mark_size_threshold\` members, [see client configuration &raquo;](https://core.telegram.org/api/config#client-configuration).","CODE_EMPTY":"The provided code is empty.","CODE_HASH_INVALID":"Code hash invalid.","CODE_INVALID":"Code invalid.","CONNECTION_API_ID_INVALID":"The provided API id is invalid.","CONNECTION_APP_VERSION_EMPTY":"App version is empty.","CONNECTION_LAYER_INVALID":"Layer invalid.","CONTACT_ADD_MISSING":"Contact to add is missing.","CONTACT_ID_INVALID":"The provided contact ID is invalid.","CONTACT_NAME_EMPTY":"Contact name empty.","CONTACT_REQ_MISSING":"Missing contact request.","CREATE_CALL_FAILED":"An error occurred while creating the call.","CURRENCY_TOTAL_AMOUNT_INVALID":"The total amount of all prices is invalid.","DATA_INVALID":"Encrypted data invalid.","DATA_JSON_INVALID":"The provided JSON data is invalid.","DATA_TOO_LONG":"Data too long.","DATE_EMPTY":"Date empty.","DC_ID_INVALID":"The provided DC ID is invalid.","DH_G_A_INVALID":"g_a invalid.","DOCUMENT_INVALID":"The specified document is invalid.","EMAIL_HASH_EXPIRED":"Email hash expired.","EMAIL_INVALID":"The specified email is invalid.","EMAIL_NOT_SETUP":"In order to change the login email with emailVerifyPurposeLoginChange, an existing login email must already be set using emailVerifyPurposeLoginSetup.","EMAIL_UNCONFIRMED":"Email unconfirmed.","EMAIL_UNCONFIRMED_%d":"Email unconfirmed, the length of the code must be %d","EMAIL_VERIFY_EXPIRED":"The verification email has expired.","EMOJI_INVALID":"The specified theme emoji is valid.","EMOJI_MARKUP_INVALID":"The specified \`video_emoji_markup\` was invalid.","EMOJI_NOT_MODIFIED":"The theme wasn't changed.","EMOTICON_EMPTY":"The emoji is empty.","EMOTICON_INVALID":"The specified emoji is invalid.","EMOTICON_STICKERPACK_MISSING":"inputStickerSetDice.emoji cannot be empty.","ENCRYPTED_MESSAGE_INVALID":"Encrypted message invalid.","ENCRYPTION_ALREADY_ACCEPTED":"Secret chat already accepted.","ENCRYPTION_ALREADY_DECLINED":"The secret chat was already declined.","ENCRYPTION_DECLINED":"The secret chat was declined.","ENCRYPTION_ID_INVALID":"The provided secret chat ID is invalid.","ENTITIES_TOO_LONG":"You provided too many styled message entities.","ENTITY_BOUNDS_INVALID":"A specified [entity offset or length](/api/entities#entity-length) is invalid, see [here &raquo;](/api/entities#entity-length) for info on how to properly compute the entity offset/length.","ENTITY_MENTION_USER_INVALID":"You mentioned an invalid user.","ERROR_TEXT_EMPTY":"The provided error message is empty.","EXPIRE_DATE_INVALID":"The specified expiration date is invalid.","EXPORT_CARD_INVALID":"Provided card is invalid.","EXTERNAL_URL_INVALID":"External URL invalid.","FILE_CONTENT_TYPE_INVALID":"File content-type is invalid.","FILE_EMTPY":"An empty file was provided.","FILE_ID_INVALID":"The provided file id is invalid.","FILE_PART_EMPTY":"The provided file part is empty.","FILE_PART_INVALID":"The file part number is invalid.","FILE_PART_LENGTH_INVALID":"The length of a file part is invalid.","FILE_PART_SIZE_CHANGED":"Provided file part size has changed.","FILE_PART_SIZE_INVALID":"The provided file part size is invalid.","FILE_PART_TOO_BIG":"The uploaded file part is too big.","FILE_PARTS_INVALID":"The number of file parts is invalid.","FILE_REFERENCE_EMPTY":"An empty [file reference](https://core.telegram.org/api/file_reference) was specified.","FILE_REFERENCE_EXPIRED":"File reference expired, it must be refetched as described in [the documentation](https://core.telegram.org/api/file_reference).","FILE_REFERENCE_INVALID":"The specified [file reference](https://core.telegram.org/api/file_reference) is invalid.","FILE_TITLE_EMPTY":"An empty file title was specified.","FILE_TOKEN_INVALID":"The specified file token is invalid.","FILTER_ID_INVALID":"The specified filter ID is invalid.","FILTER_INCLUDE_EMPTY":"The include_peers vector of the filter is empty.","FILTER_NOT_SUPPORTED":"The specified filter cannot be used in this context.","FILTER_TITLE_EMPTY":"The title field of the filter is empty.","FIRSTNAME_INVALID":"The first name is invalid.","FOLDER_ID_EMPTY":"An empty folder ID was specified.","FOLDER_ID_INVALID":"Invalid folder ID.","FRESH_CHANGE_ADMINS_FORBIDDEN":"You were just elected admin, you can't add or modify other admins yet.","FROM_MESSAGE_BOT_DISABLED":"Bots can't use fromMessage min constructors.","FROM_PEER_INVALID":"The specified from_id is invalid.","GAME_BOT_INVALID":"Bots can't send another bot's game.","GEO_POINT_INVALID":"Invalid geoposition provided.","GIF_CONTENT_TYPE_INVALID":"GIF content-type invalid.","GIF_ID_INVALID":"The provided GIF ID is invalid.","GRAPH_EXPIRED_RELOAD":"This graph has expired, please obtain a new graph token.","GRAPH_INVALID_RELOAD":"Invalid graph token provided, please reload the stats and provide the updated token.","GRAPH_OUTDATED_RELOAD":"The graph is outdated, please get a new async token using stats.getBroadcastStats.","GROUPCALL_ALREADY_DISCARDED":"The group call was already discarded.","GROUPCALL_FORBIDDEN":"The group call has already ended.","GROUPCALL_INVALID":"The specified group call is invalid.","GROUPCALL_JOIN_MISSING":"You haven't joined this group call.","GROUPCALL_NOT_MODIFIED":"Group call settings weren't modified.","GROUPCALL_SSRC_DUPLICATE_MUCH":"The app needs to retry joining the group call with a new SSRC value.","GROUPED_MEDIA_INVALID":"Invalid grouped media.","HASH_INVALID":"The provided hash is invalid.","HIDE_REQUESTER_MISSING":"The join request was missing or was already handled.","IMAGE_PROCESS_FAILED":"Failure while processing image.","IMPORT_FILE_INVALID":"The specified chat export file is invalid.","IMPORT_FORMAT_UNRECOGNIZED":"The specified chat export file was exported from an unsupported chat app.","IMPORT_ID_INVALID":"The specified import ID is invalid.","IMPORT_TOKEN_INVALID":"The specified token is invalid.","INLINE_RESULT_EXPIRED":"The inline query expired.","INPUT_FILTER_INVALID":"The specified filter is invalid.","INPUT_TEXT_EMPTY":"The specified text is empty.","INPUT_USER_DEACTIVATED":"The specified user was deleted.","INVITE_FORBIDDEN_WITH_JOINAS":"If the user has anonymously joined a group call as a channel, they can't invite other users to the group call because that would cause deanonymization, because the invite would be sent using the original user ID, not the anonymized channel ID.","INVITE_HASH_EMPTY":"The invite hash is empty.","INVITE_HASH_EXPIRED":"The invite link has expired.","INVITE_HASH_INVALID":"The invite hash is invalid.","INVITE_REQUEST_SENT":"You have successfully requested to join this chat or channel.","INVITE_REVOKED_MISSING":"The specified invite link was already revoked or is invalid.","INVITE_SLUG_EMPTY":"The specified invite slug is empty.","INVITES_TOO_MUCH":"The maximum number of per-folder invites specified by the \`chatlist_invites_limit_default\`/\`chatlist_invites_limit_premium\` [client configuration parameters &raquo;](/api/config#chatlist-invites-limit-default) was reached.","INVOICE_PAYLOAD_INVALID":"The specified invoice payload is invalid.","JOIN_AS_PEER_INVALID":"The specified peer cannot be used to join a group call.","LANG_CODE_INVALID":"The specified language code is invalid.","LANG_CODE_NOT_SUPPORTED":"The specified language code is not supported.","LANG_PACK_INVALID":"The provided language pack is invalid.","LASTNAME_INVALID":"The last name is invalid.","LIMIT_INVALID":"The provided limit is invalid.","LINK_NOT_MODIFIED":"Discussion link not modified.","LOCATION_INVALID":"The provided location is invalid.","MAX_DATE_INVALID":"The specified maximum date is invalid.","MAX_ID_INVALID":"The provided max ID is invalid.","MAX_QTS_INVALID":"The specified max_qts is invalid.","MD5_CHECKSUM_INVALID":"The MD5 checksums do not match.","MEDIA_CAPTION_TOO_LONG":"The caption is too long.","MEDIA_EMPTY":"The provided media object is invalid.","MEDIA_GROUPED_INVALID":"You tried to send media of different types in an album.","MEDIA_INVALID":"Media invalid.","MEDIA_NEW_INVALID":"The new media is invalid.","MEDIA_PREV_INVALID":"Previous media invalid.","MEGAGROUP_ID_INVALID":"Invalid supergroup ID.","MEGAGROUP_PREHISTORY_HIDDEN":"Group with hidden history for new members can't be set as discussion groups.","MEGAGROUP_REQUIRED":"You can only use this method on a supergroup.","MESSAGE_EDIT_TIME_EXPIRED":"You can't edit this message anymore, too much time has passed since its creation.","MESSAGE_EMPTY":"The provided message is empty.","MESSAGE_ID_INVALID":"The provided message id is invalid.","MESSAGE_IDS_EMPTY":"No message ids were provided.","MESSAGE_NOT_MODIFIED":"The provided message data is identical to the previous message data, the message wasn't modified.","MESSAGE_POLL_CLOSED":"Poll closed.","MESSAGE_TOO_LONG":"The provided message is too long.","METHOD_INVALID":"The specified method is invalid.","MIN_DATE_INVALID":"The specified minimum date is invalid.","MSG_ID_INVALID":"Invalid message ID provided.","MSG_TOO_OLD":"[\`chat_read_mark_expire_period\` seconds](https://core.telegram.org/api/config#chat-read-mark-expire-period) have passed since the message was sent, read receipts were deleted.","MSG_WAIT_FAILED":"A waiting call returned an error.","MULTI_MEDIA_TOO_LONG":"Too many media files for album.","NEW_SALT_INVALID":"The new salt is invalid.","NEW_SETTINGS_EMPTY":"No password is set on the current account, and no new password was specified in \`new_settings\`.","NEW_SETTINGS_INVALID":"The new password settings are invalid.","NEXT_OFFSET_INVALID":"The specified offset is longer than 64 bytes.","OFFSET_INVALID":"The provided offset is invalid.","OFFSET_PEER_ID_INVALID":"The provided offset peer is invalid.","OPTION_INVALID":"Invalid option selected.","OPTIONS_TOO_MUCH":"Too many options provided.","ORDER_INVALID":"The specified username order is invalid.","PACK_SHORT_NAME_INVALID":"Short pack name invalid.","PACK_SHORT_NAME_OCCUPIED":"A stickerpack with this name already exists.","PACK_TITLE_INVALID":"The stickerpack title is invalid.","PARTICIPANT_ID_INVALID":"The specified participant ID is invalid.","PARTICIPANT_JOIN_MISSING":"Trying to enable a presentation, when the user hasn't joined the Video Chat with [phone.joinGroupCall](https://core.telegram.org/method/phone.joinGroupCall).","PARTICIPANT_VERSION_OUTDATED":"The other participant does not use an up to date telegram client with support for calls.","PARTICIPANTS_TOO_FEW":"Not enough participants.","PASSWORD_EMPTY":"The provided password is empty.","PASSWORD_HASH_INVALID":"The provided password hash is invalid.","PASSWORD_MISSING":"You must enable 2FA in order to transfer ownership of a channel.","PASSWORD_RECOVERY_EXPIRED":"The recovery code has expired.","PASSWORD_RECOVERY_NA":"No email was set, can't recover password via email.","PASSWORD_REQUIRED":"A [2FA password](https://core.telegram.org/api/srp) must be configured to use Telegram Passport.","PASSWORD_TOO_FRESH_%d":"The password was added too recently and %d seconds must pass before using the method","PAYMENT_PROVIDER_INVALID":"The specified payment provider is invalid.","PEER_HISTORY_EMPTY":"You can't pin an empty chat with a user.","PEER_ID_INVALID":"The provided peer id is invalid.","PEER_ID_NOT_SUPPORTED":"The provided peer ID is not supported.","PEERS_LIST_EMPTY":"The specified list of peers is empty.","PERSISTENT_TIMESTAMP_EMPTY":"Persistent timestamp empty.","PERSISTENT_TIMESTAMP_INVALID":"Persistent timestamp invalid.","PHONE_CODE_EMPTY":"phone_code is missing.","PHONE_CODE_EXPIRED":"The phone code you provided has expired.","PHONE_CODE_HASH_EMPTY":"phone_code_hash is missing.","PHONE_CODE_INVALID":"The provided phone code is invalid.","PHONE_HASH_EXPIRED":"An invalid or expired \`phone_code_hash\` was provided.","PHONE_NOT_OCCUPIED":"No user is associated to the specified phone number.","PHONE_NUMBER_APP_SIGNUP_FORBIDDEN":"You can't sign up using this app.","PHONE_NUMBER_BANNED":"The provided phone number is banned from telegram.","PHONE_NUMBER_FLOOD":"You asked for the code too many times.","PHONE_NUMBER_INVALID":"The phone number is invalid.","PHONE_NUMBER_OCCUPIED":"The phone number is already in use.","PHONE_NUMBER_UNOCCUPIED":"The phone number is not yet being used.","PHONE_PASSWORD_PROTECTED":"This phone is password protected.","PHOTO_CONTENT_TYPE_INVALID":"Photo mime-type invalid.","PHOTO_CONTENT_URL_EMPTY":"Photo URL invalid.","PHOTO_CROP_FILE_MISSING":"Photo crop file missing.","PHOTO_CROP_SIZE_SMALL":"Photo is too small.","PHOTO_EXT_INVALID":"The extension of the photo is invalid.","PHOTO_FILE_MISSING":"Profile photo file missing.","PHOTO_ID_INVALID":"Photo ID invalid.","PHOTO_INVALID":"Photo invalid.","PHOTO_INVALID_DIMENSIONS":"The photo dimensions are invalid.","PHOTO_SAVE_FILE_INVALID":"Internal issues, try again later.","PHOTO_THUMB_URL_EMPTY":"Photo thumbnail URL is empty.","PIN_RESTRICTED":"You can't pin messages.","PINNED_DIALOGS_TOO_MUCH":"Too many pinned dialogs.","POLL_ANSWER_INVALID":"One of the poll answers is not acceptable.","POLL_ANSWERS_INVALID":"Invalid poll answers were provided.","POLL_OPTION_DUPLICATE":"Duplicate poll options provided.","POLL_OPTION_INVALID":"Invalid poll option provided.","POLL_QUESTION_INVALID":"One of the poll questions is not acceptable.","PRIVACY_KEY_INVALID":"The privacy key is invalid.","PRIVACY_TOO_LONG":"Too many privacy rules were specified, the current limit is 1000.","PRIVACY_VALUE_INVALID":"The specified privacy rule combination is invalid.","PUBLIC_KEY_REQUIRED":"A public key is required.","QUERY_ID_EMPTY":"The query ID is empty.","QUERY_ID_INVALID":"The query ID is invalid.","QUERY_TOO_SHORT":"The query string is too short.","QUIZ_ANSWER_MISSING":"You can forward a quiz while hiding the original author only after choosing an option in the quiz.","QUIZ_CORRECT_ANSWER_INVALID":"An invalid value was provided to the correct_answers field.","QUIZ_CORRECT_ANSWERS_EMPTY":"No correct quiz answer was specified.","QUIZ_CORRECT_ANSWERS_TOO_MUCH":"You specified too many correct answers in a quiz, quizzes can only have one right answer!","QUIZ_MULTIPLE_INVALID":"Quizzes can't have the multiple_choice flag set!","RANDOM_ID_EMPTY":"Random ID empty.","RANDOM_ID_INVALID":"A provided random ID is invalid.","RANDOM_LENGTH_INVALID":"Random length invalid.","RANGES_INVALID":"Invalid range provided.","REACTION_EMPTY":"Empty reaction provided.","REACTION_INVALID":"The specified reaction is invalid.","REACTIONS_TOO_MANY":"The message already has exactly \`reactions_uniq_max\` reaction emojis, you can't react with a new emoji, see [the docs for more info &raquo;](/api/config#client-configuration).","REPLY_MARKUP_BUY_EMPTY":"Reply markup for buy button empty.","REPLY_MARKUP_INVALID":"The provided reply markup is invalid.","REPLY_MARKUP_TOO_LONG":"The specified reply_markup is too long.","RESET_REQUEST_MISSING":"No password reset is in progress.","RESULT_ID_DUPLICATE":"You provided a duplicate result ID.","RESULT_ID_EMPTY":"Result ID empty.","RESULT_ID_INVALID":"One of the specified result IDs is invalid.","RESULT_TYPE_INVALID":"Result type invalid.","RESULTS_TOO_MUCH":"Too many results were provided.","REVOTE_NOT_ALLOWED":"You cannot change your vote.","RIGHTS_NOT_MODIFIED":"The new admin rights are equal to the old rights, no change was made.","RSA_DECRYPT_FAILED":"Internal RSA decryption failed.","SCHEDULE_BOT_NOT_ALLOWED":"Bots cannot schedule messages.","SCHEDULE_DATE_INVALID":"Invalid schedule date provided.","SCHEDULE_DATE_TOO_LATE":"You can't schedule a message this far in the future.","SCHEDULE_STATUS_PRIVATE":"Can't schedule until user is online, if the user's last seen timestamp is hidden by their privacy settings.","SCHEDULE_TOO_MUCH":"There are too many scheduled messages.","SCORE_INVALID":"The specified game score is invalid.","SEARCH_QUERY_EMPTY":"The search query is empty.","SEARCH_WITH_LINK_NOT_SUPPORTED":"You cannot provide a search query and an invite link at the same time.","SECONDS_INVALID":"Invalid duration provided.","SEND_AS_PEER_INVALID":"You can't send messages as the specified peer.","SEND_MESSAGE_MEDIA_INVALID":"Invalid media provided.","SEND_MESSAGE_TYPE_INVALID":"The message type is invalid.","SESSION_TOO_FRESH_%d":"The session logged in too recently and %d seconds must pass before calling the method","SETTINGS_INVALID":"Invalid settings were provided.","SHA256_HASH_INVALID":"The provided SHA256 hash is invalid.","SHORT_NAME_INVALID":"The specified short name is invalid.","SHORT_NAME_OCCUPIED":"The specified short name is already in use.","SLOWMODE_MULTI_MSGS_DISABLED":"Slowmode is enabled, you cannot forward multiple messages to this group.","SMS_CODE_CREATE_FAILED":"An error occurred while creating the SMS code.","SRP_ID_INVALID":"Invalid SRP ID provided.","SRP_PASSWORD_CHANGED":"Password has changed.","START_PARAM_EMPTY":"The start parameter is empty.","START_PARAM_INVALID":"Start parameter invalid.","START_PARAM_TOO_LONG":"Start parameter is too long.","STICKER_DOCUMENT_INVALID":"The specified sticker document is invalid.","STICKER_EMOJI_INVALID":"Sticker emoji invalid.","STICKER_FILE_INVALID":"Sticker file invalid.","STICKER_GIF_DIMENSIONS":"The specified video sticker has invalid dimensions.","STICKER_ID_INVALID":"The provided sticker ID is invalid.","STICKER_INVALID":"The provided sticker is invalid.","STICKER_MIME_INVALID":"The specified sticker MIME type is invalid.","STICKER_PNG_DIMENSIONS":"Sticker png dimensions invalid.","STICKER_PNG_NOPNG":"One of the specified stickers is not a valid PNG file.","STICKER_TGS_NODOC":"You must send the animated sticker as a document.","STICKER_TGS_NOTGS":"Invalid TGS sticker provided.","STICKER_THUMB_PNG_NOPNG":"Incorrect stickerset thumb file provided, PNG / WEBP expected.","STICKER_THUMB_TGS_NOTGS":"Incorrect stickerset TGS thumb file provided.","STICKER_VIDEO_BIG":"The specified video sticker is too big.","STICKER_VIDEO_NODOC":"You must send the video sticker as a document.","STICKER_VIDEO_NOWEBM":"The specified video sticker is not in webm format.","STICKERPACK_STICKERS_TOO_MUCH":"There are too many stickers in this stickerpack, you can't add any more.","STICKERS_EMPTY":"No sticker provided.","STICKERS_TOO_MUCH":"There are too many stickers in this stickerpack, you can't add any more.","STICKERSET_INVALID":"The provided sticker set is invalid.","SWITCH_PM_TEXT_EMPTY":"The switch_pm.text field was empty.","TAKEOUT_REQUIRED":"A takeout session has to be initialized, first.","TASK_ALREADY_EXISTS":"An email reset was already requested.","TEMP_AUTH_KEY_ALREADY_BOUND":"The passed temporary key is already bound to another **perm_auth_key_id**.","TEMP_AUTH_KEY_EMPTY":"No temporary auth key provided.","THEME_FILE_INVALID":"Invalid theme file provided.","THEME_FORMAT_INVALID":"Invalid theme format provided.","THEME_INVALID":"Invalid theme provided.","THEME_MIME_INVALID":"The theme's MIME type is invalid.","THEME_TITLE_INVALID":"The specified theme title is invalid.","TITLE_INVALID":"The specified stickerpack title is invalid.","TMP_PASSWORD_DISABLED":"The temporary password is disabled.","TO_LANG_INVALID":"The specified destination language is invalid.","TOKEN_EMPTY":"The specified token is empty.","TOKEN_INVALID":"The provided token is invalid.","TOKEN_TYPE_INVALID":"The specified token type is invalid.","TOPIC_CLOSED":"This topic was closed, you can't send messages to it anymore.","TOPIC_DELETED":"The specified topic was deleted.","TOPIC_ID_INVALID":"The specified topic ID is invalid.","TOPIC_NOT_MODIFIED":"The updated topic info is equal to the current topic info, nothing was changed.","TRANSCRIPTION_FAILED":"Audio transcription failed.","TTL_DAYS_INVALID":"The provided TTL is invalid.","TTL_MEDIA_INVALID":"Invalid media Time To Live was provided.","TTL_PERIOD_INVALID":"The specified TTL period is invalid.","TYPES_EMPTY":"No top peer type was provided.","UNTIL_DATE_INVALID":"Invalid until date provided.","URL_INVALID":"Invalid URL provided.","USAGE_LIMIT_INVALID":"The specified usage limit is invalid.","USER_ADMIN_INVALID":"You're not an admin.","USER_ALREADY_INVITED":"You have already invited this user.","USER_ALREADY_PARTICIPANT":"The user is already in the group.","USER_BANNED_IN_CHANNEL":"You're banned from sending messages in supergroups/channels.","USER_BLOCKED":"User blocked.","USER_BOT":"Bots can only be admins in channels.","USER_BOT_INVALID":"User accounts must provide the \`bot\` method parameter when calling this method. If there is no such method parameter, this method can only be invoked by bot accounts.","USER_BOT_REQUIRED":"This method can only be called by a bot.","USER_CHANNELS_TOO_MUCH":"One of the users you tried to add is already in too many channels/supergroups.","USER_CREATOR":"You can't leave this channel, because you're its creator.","USER_ID_INVALID":"The provided user ID is invalid.","USER_INVALID":"Invalid user provided.","USER_IS_BLOCKED":"You were blocked by this user.","USER_IS_BOT":"Bots can't send messages to other bots.","USER_KICKED":"This user was kicked from this supergroup/channel.","USER_NOT_MUTUAL_CONTACT":"The provided user is not a mutual contact.","USER_NOT_PARTICIPANT":"You're not a member of this supergroup/channel.","USER_VOLUME_INVALID":"The specified user volume is invalid.","USERNAME_INVALID":"The provided username is not valid.","USERNAME_NOT_MODIFIED":"The username was not modified.","USERNAME_NOT_OCCUPIED":"The provided username is not occupied.","USERNAME_OCCUPIED":"The provided username is already occupied.","USERNAME_PURCHASE_AVAILABLE":"The specified username can be purchased on https://fragment.com.","USERNAMES_ACTIVE_TOO_MUCH":"The maximum number of active usernames was reached.","USERPIC_UPLOAD_REQUIRED":"You must have a profile picture to publish your geolocation.","USERS_TOO_FEW":"Not enough users (to create a chat, for example).","USERS_TOO_MUCH":"The maximum number of users has been exceeded (to create a chat, for example).","VIDEO_CONTENT_TYPE_INVALID":"The video's content type is invalid.","VIDEO_FILE_INVALID":"The specified video file is invalid.","VIDEO_TITLE_EMPTY":"The specified video title is empty.","VOICE_MESSAGES_FORBIDDEN":"This user's privacy settings forbid you from sending voice messages.","WALLPAPER_FILE_INVALID":"The specified wallpaper file is invalid.","WALLPAPER_INVALID":"The specified wallpaper is invalid.","WALLPAPER_MIME_INVALID":"The specified wallpaper MIME type is invalid.","WC_CONVERT_URL_INVALID":"WC convert URL invalid.","WEBDOCUMENT_INVALID":"Invalid webdocument URL provided.","WEBDOCUMENT_MIME_INVALID":"Invalid webdocument mime type provided.","WEBDOCUMENT_SIZE_TOO_BIG":"Webdocument is too big!","WEBDOCUMENT_URL_INVALID":"The specified webdocument URL is invalid.","WEBPAGE_CURL_FAILED":"Failure while fetching the webpage with cURL.","WEBPAGE_MEDIA_EMPTY":"Webpage media empty.","WEBPUSH_AUTH_INVALID":"The specified web push authentication secret is invalid.","WEBPUSH_KEY_INVALID":"The specified web push elliptic curve Diffie-Hellman public key is invalid.","WEBPUSH_TOKEN_INVALID":"The specified web push token is invalid.","YOU_BLOCKED_USER":"You blocked this user.","BROADCAST_FORBIDDEN":"Participants of polls in channels should stay anonymous.","CHANNEL_PUBLIC_GROUP_NA":"channel/supergroup not available.","CHAT_ADMIN_INVITE_REQUIRED":"You do not have the rights to do this.","CHAT_GUEST_SEND_FORBIDDEN":"You join the discussion group before commenting, see [here &raquo;](/api/discussion#requiring-users-to-join-the-group) for more info.","CHAT_SEND_AUDIOS_FORBIDDEN":"You can't send audio messages in this chat.","CHAT_SEND_DOCS_FORBIDDEN":"You can't send documents in this chat.","CHAT_SEND_GAME_FORBIDDEN":"You can't send a game to this chat.","CHAT_SEND_GIFS_FORBIDDEN":"You can't send gifs in this chat.","CHAT_SEND_MEDIA_FORBIDDEN":"You can't send media in this chat.","CHAT_SEND_PHOTOS_FORBIDDEN":"You can't send photos in this chat.","CHAT_SEND_PLAIN_FORBIDDEN":"You can't send non-media (text) messages in this chat.","CHAT_SEND_POLL_FORBIDDEN":"You can't send polls in this chat.","CHAT_SEND_STICKERS_FORBIDDEN":"You can't send stickers in this chat.","CHAT_SEND_VIDEOS_FORBIDDEN":"You can't send videos in this chat.","CHAT_SEND_VOICES_FORBIDDEN":"You can't send voice recordings in this chat.","CHAT_WRITE_FORBIDDEN":"You can't write in this chat.","EDIT_BOT_INVITE_FORBIDDEN":"Normal users can't edit invites that were created by bots.","GROUPCALL_ALREADY_STARTED":"The groupcall has already started, you can join directly using [phone.joinGroupCall](https://core.telegram.org/method/phone.joinGroupCall).","INLINE_BOT_REQUIRED":"Only the inline bot can edit message.","MESSAGE_AUTHOR_REQUIRED":"Message author required.","MESSAGE_DELETE_FORBIDDEN":"You can't delete one of the messages you tried to delete, most likely because it is a service message.","POLL_VOTE_REQUIRED":"Cast a vote in the poll before calling this method.","PREMIUM_ACCOUNT_REQUIRED":"A premium account is required to execute this action.","PUBLIC_CHANNEL_MISSING":"You can only export group call invite links for public chats or channels.","RIGHT_FORBIDDEN":"Your admin rights do not allow you to do this.","SENSITIVE_CHANGE_FORBIDDEN":"You can't change your sensitive content settings.","USER_DELETED":"You can't send this secret message because the other participant deleted their account.","USER_PRIVACY_RESTRICTED":"The user's privacy settings do not allow you to do this.","USER_RESTRICTED":"You're spamreported, you can't create channels or chats.","FILEREF_UPGRADE_NEEDED":"The client has to be updated in order to support [file references](https://core.telegram.org/api/file_reference).","FRESH_CHANGE_PHONE_FORBIDDEN":"You can't change phone number right after logging in, please wait at least 24 hours.","FRESH_RESET_AUTHORISATION_FORBIDDEN":"You can't logout other sessions if less than 24 hours have passed since you logged on the current session.","PAYMENT_UNSUPPORTED":"A detailed description of the error will be received separately as described [here &raquo;](https://core.telegram.org/api/errors#406-not-acceptable).","PHONE_PASSWORD_FLOOD":"You have tried logging in too many times.","PREVIOUS_CHAT_IMPORT_ACTIVE_WAIT_%dMIN":"Similar to a flood wait, must wait %d minutes","SEND_CODE_UNAVAILABLE":"Returned when all available options for this type of number were already used (e.g. flash-call, then SMS, then this error might be returned to trigger a second resend).","STICKERSET_OWNER_ANONYMOUS":"Provided stickerset can't be installed as group stickerset to prevent admin deanonymization.","USERPIC_PRIVACY_REQUIRED":"You need to disable privacy settings for your profile picture in order to make your geolocation public.","2FA_CONFIRM_WAIT_%d":"The account is 2FA protected so it will be deleted in a week. Otherwise it can be reset in %d","SLOWMODE_WAIT_%d":"A wait of %d seconds is required before sending another message in this chat","TAKEOUT_INIT_DELAY_%d":"A wait of %d seconds is required before being able to initiate the takeout","AUTH_RESTART":"Restart the authorization process.","CDN_UPLOAD_TIMEOUT":"A server-side timeout occurred while reuploading the file to the CDN DC.","CHAT_ID_GENERATE_FAILED":"Failure while generating the chat ID.","PERSISTENT_TIMESTAMP_OUTDATED":"Channel internal replication issues, try again later (treat this like an RPC_CALL_FAIL).","RANDOM_ID_DUPLICATE":"You provided a random ID that was already used.","SIGN_IN_FAILED":"Failure while signing in.","Invalid msg_resend_req query":"Invalid msg_resend_req query.","Invalid msgs_ack query":"Invalid msgs_ack query.","Invalid msgs_state_req query":"Invalid msgs_state_req query.","Timeout":"Timeout while fetching data.","SESSION_PASSWORD_NEEDED":"2FA is enabled, use a password to login.","ACTIVE_USER_REQUIRED":"The method is only available to already activated users","AUTH_KEY_DUPLICATED":"The authorization key (session file) was used under two different IP addresses simultaneously, and can no longer be used. Use the same session exclusively, or use different sessions","AUTH_KEY_INVALID":"The key is invalid","AUTH_KEY_PERM_EMPTY":"The method is unavailable for temporary authorization key, not bound to permanent","AUTH_KEY_UNREGISTERED":"The key is not registered in the system","AUTH_TOKEN_INVALID2":"An invalid authorization token was provided","BASE_PORT_LOC_INVALID":"Base port location invalid","BOT_GAMES_DISABLED":"Bot games cannot be used in this type of chat","BOT_METHOD_INVALID":"The API access for bot users is restricted. The method you tried to invoke cannot be executed as a bot","BOT_POLLS_DISABLED":"You cannot create polls under a bot account","CHANNEL_BANNED":"The channel is banned","CHAT_FORBIDDEN":"You cannot write in this chat","CHP_CALL_FAIL":"The statistics cannot be retrieved at this time","CONNECTION_DEVICE_MODEL_EMPTY":"Device model empty","CONNECTION_LANG_PACK_INVALID":"The specified language pack is not valid. This is meant to be used by official applications only so far, leave it empty","CONNECTION_NOT_INITED":"Connection not initialized","CONNECTION_SYSTEM_EMPTY":"Connection system empty","CONNECTION_SYSTEM_LANG_CODE_EMPTY":"The system language string was empty during connection","ENCRYPTION_OCCUPY_FAILED":"TDLib developer claimed it is not an error while accepting secret chats and 500 is used instead of 420","FIELD_NAME_EMPTY":"The field with the name FIELD_NAME is missing","FIELD_NAME_INVALID":"The field with the name FIELD_NAME is invalid","FILE_PART_0_MISSING":"File part 0 missing","FILE_PART_%d_MISSING":"Part %d of the file is missing from storage","FLOOD_TEST_PHONE_WAIT_%d":"A wait of %d seconds is required in the test servers","GROUP_CALL_INVALID":"Group call invalid","HISTORY_GET_FAILED":"Fetching of history failed","INPUT_CONSTRUCTOR_INVALID":"The provided constructor is invalid","INPUT_FETCH_ERROR":"An error occurred while deserializing TL parameters","INPUT_FETCH_FAIL":"Failed deserializing TL payload","INPUT_LAYER_INVALID":"The provided layer is invalid","INPUT_METHOD_INVALID":"The invoked method does not exist anymore or has never existed","INPUT_REQUEST_TOO_LONG":"The input request was too long. This may be a bug in the library as it can occur when serializing more bytes than it should (like appending the vector constructor code at the end of a message)","INTERDC_%d_CALL_ERROR":"An error occurred while communicating with DC %d","INTERDC_%d_CALL_RICH_ERROR":"A rich error occurred while communicating with DC %d","MEMBER_NO_LOCATION":"An internal failure occurred while fetching user info (couldn't find location)","MEMBER_OCCUPY_PRIMARY_LOC_FAILED":"Occupation of primary member location failed","MSGID_DECREASE_RETRY":"The request should be retried with a lower message ID","NEED_CHAT_INVALID":"The provided chat is invalid","NEED_MEMBER_INVALID":"The provided member is invalid or does not exist (for example a thumb size)","PARTICIPANT_CALL_FAILED":"Failure while making call","PEER_FLOOD":"Too many requests","POLL_UNSUPPORTED":"This layer does not support polls in the issued method","POSTPONED_TIMEOUT":"The postponed call has timed out","PTS_CHANGE_EMPTY":"No PTS change","REFLECTOR_NOT_AVAILABLE":"Invalid call reflector server","REG_ID_GENERATE_FAILED":"Failure while generating registration ID","REPLY_MARKUP_GAME_EMPTY":"The provided reply markup for the game is empty","RPC_CALL_FAIL":"Telegram is having internal issues, please try again later.","RPC_MCGET_FAIL":"Telegram is having internal issues, please try again later.","SESSION_EXPIRED":"The authorization has expired","SESSION_REVOKED":"The authorization has been invalidated, because of the user terminating all sessions","SHORTNAME_OCCUPY_FAILED":"An error occurred when trying to register the short-name used for the sticker pack. Try a different name","STORAGE_CHECK_FAILED":"Server storage check failed","TAKEOUT_INVALID":"The takeout session has been invalidated by another data export session","TMP_PASSWORD_INVALID":"Password auth needs to be regenerated","TYPE_CONSTRUCTOR_INVALID":"The type constructor is invalid","Timedout":"Timeout while fetching data","UNKNOWN_METHOD":"The method you tried to call cannot be called on non-CDN DCs","USER_DEACTIVATED":"The user has been deleted/deactivated","USER_DEACTIVATED_BAN":"The user has been deleted/deactivated","USER_MIGRATE_%d":"The user whose identity is being used to execute queries is associated with DC %d","WORKER_BUSY_TOO_LONG_RETRY":"Telegram workers are too busy to respond immediately"}`);
      class RpcError extends Error {
        constructor(code2, text, description) {
          super(description || "Unknown RPC error: [" + code2 + ":" + text + "]");
          this.code = code2;
          this.text = text;
        }
        static is(err2, text) {
          return err2.constructor === RpcError && (!text || err2.text === text);
        }
        is(text) {
          return this.text === text;
        }
      }
      RpcError.fromTl = function(obj) {
        if (obj.errorMessage in _descriptionsMap) {
          return new RpcError(obj.errorCode, obj.errorMessage, _descriptionsMap[obj.errorMessage]);
        }
        var err2 = new RpcError(obj.errorCode, obj.errorMessage);
        var match2, param;
        if ((match2 = err2.text.match(/^FLOOD_WAIT_(\d+)$/)) != null) {
          err2.text = "FLOOD_WAIT_%d";
          param = err2.seconds = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^FILE_MIGRATE_(\d+)$/)) != null) {
          err2.text = "FILE_MIGRATE_%d";
          param = err2.newDc = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^NETWORK_MIGRATE_(\d+)$/)) != null) {
          err2.text = "NETWORK_MIGRATE_%d";
          param = err2.newDc = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^PHONE_MIGRATE_(\d+)$/)) != null) {
          err2.text = "PHONE_MIGRATE_%d";
          param = err2.newDc = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^STATS_MIGRATE_(\d+)$/)) != null) {
          err2.text = "STATS_MIGRATE_%d";
          param = err2.dc = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^EMAIL_UNCONFIRMED_(\d+)$/)) != null) {
          err2.text = "EMAIL_UNCONFIRMED_%d";
          param = err2.codeLength = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^PASSWORD_TOO_FRESH_(\d+)$/)) != null) {
          err2.text = "PASSWORD_TOO_FRESH_%d";
          param = err2.seconds = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^SESSION_TOO_FRESH_(\d+)$/)) != null) {
          err2.text = "SESSION_TOO_FRESH_%d";
          param = err2.seconds = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^PREVIOUS_CHAT_IMPORT_ACTIVE_WAIT_(\d+)MIN$/)) != null) {
          err2.text = "PREVIOUS_CHAT_IMPORT_ACTIVE_WAIT_%dMIN";
          param = err2.minutes = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^2FA_CONFIRM_WAIT_(\d+)$/)) != null) {
          err2.text = "2FA_CONFIRM_WAIT_%d";
          param = err2.seconds = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^SLOWMODE_WAIT_(\d+)$/)) != null) {
          err2.text = "SLOWMODE_WAIT_%d";
          param = err2.seconds = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^TAKEOUT_INIT_DELAY_(\d+)$/)) != null) {
          err2.text = "TAKEOUT_INIT_DELAY_%d";
          param = err2.seconds = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^FILE_PART_(\d+)_MISSING$/)) != null) {
          err2.text = "FILE_PART_%d_MISSING";
          param = err2.which = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^FLOOD_TEST_PHONE_WAIT_(\d+)$/)) != null) {
          err2.text = "FLOOD_TEST_PHONE_WAIT_%d";
          param = err2.seconds = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^INTERDC_(\d+)_CALL_ERROR$/)) != null) {
          err2.text = "INTERDC_%d_CALL_ERROR";
          param = err2.dc = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^INTERDC_(\d+)_CALL_RICH_ERROR$/)) != null) {
          err2.text = "INTERDC_%d_CALL_RICH_ERROR";
          param = err2.dc = parseInt(match2[1]);
        } else if ((match2 = err2.text.match(/^USER_MIGRATE_(\d+)$/)) != null) {
          err2.text = "USER_MIGRATE_%d";
          param = err2.newDc = parseInt(match2[1]);
        } else
          return err2;
        err2.message = _descriptionsMap[err2.text].replace("%d", param);
        return err2;
      };
      RpcError.create = function(code2, text) {
        var desc = _descriptionsMap[text];
        var err2 = new RpcError(code2, text, desc);
        if (!desc) {
          err2.unknown = true;
        }
        return err2;
      };
      RpcError.BAD_REQUEST = 400;
      RpcError.UNAUTHORIZED = 401;
      RpcError.FORBIDDEN = 403;
      RpcError.NOT_FOUND = 404;
      RpcError.FLOOD = 420;
      RpcError.SEE_OTHER = 303;
      RpcError.NOT_ACCEPTABLE = 406;
      RpcError.INTERNAL = 500;
      ns.RpcError = RpcError;
      ns.isAnyError = _isAny("Error");
      ns.isAnyIpPort = _isAny("IpPort");
      ns.isAnyAccessPointRule = _isAny("AccessPointRule");
      ns.isAnyInputFileLocation = _isAny("InputFileLocation");
      ns.isAnyInputPeer = _isAny("InputPeer");
      ns.isAnyInputUser = _isAny("InputUser");
      ns.isAnyInputContact = _isAny("InputContact");
      ns.isAnyInputFile = _isAny("InputFile");
      ns.isAnyInputMedia = _isAny("InputMedia");
      ns.isAnyInputChatPhoto = _isAny("InputChatPhoto");
      ns.isAnyInputGeoPoint = _isAny("InputGeoPoint");
      ns.isAnyInputPhoto = _isAny("InputPhoto");
      ns.isAnyPeer = _isAny("Peer");
      ns.isAnyUser = _isAny("User");
      ns.isAnyUserProfilePhoto = _isAny("UserProfilePhoto");
      ns.isAnyUserStatus = _isAny("UserStatus");
      ns.isAnyChat = _isAny("Chat");
      ns.isAnyChatFull = _isAny("ChatFull");
      ns.isAnyChatParticipant = _isAny("ChatParticipant");
      ns.isAnyChatParticipants = _isAny("ChatParticipants");
      ns.isAnyChatPhoto = _isAny("ChatPhoto");
      ns.isAnyMessage = _isAny("Message");
      ns.isAnyMessageMedia = _isAny("MessageMedia");
      ns.isAnyMessageAction = _isAny("MessageAction");
      ns.isAnyDialog = _isAny("Dialog");
      ns.isAnyPhoto = _isAny("Photo");
      ns.isAnyPhotoSize = _isAny("PhotoSize");
      ns.isAnyGeoPoint = _isAny("GeoPoint");
      ns.isAnyInputNotifyPeer = _isAny("InputNotifyPeer");
      ns.isAnyInputPeerNotifySettings = _isAny("InputPeerNotifySettings");
      ns.isAnyPeerNotifySettings = _isAny("PeerNotifySettings");
      ns.isAnyPeerSettings = _isAny("PeerSettings");
      ns.isAnyWallPaper = _isAny("WallPaper");
      ns.isAnyReportReason = _isAny("ReportReason");
      ns.isAnyUserFull = _isAny("UserFull");
      ns.isAnyContact = _isAny("Contact");
      ns.isAnyImportedContact = _isAny("ImportedContact");
      ns.isAnyContactStatus = _isAny("ContactStatus");
      ns.isAnyMessagesFilter = _isAny("MessagesFilter");
      ns.isAnyUpdate = _isAny("Update");
      ns.isAnyUpdates = _isAny("Updates");
      ns.isAnyDcOption = _isAny("DcOption");
      ns.isAnyConfig = _isAny("Config");
      ns.isAnyNearestDc = _isAny("NearestDc");
      ns.isAnyEncryptedChat = _isAny("EncryptedChat");
      ns.isAnyInputEncryptedChat = _isAny("InputEncryptedChat");
      ns.isAnyEncryptedFile = _isAny("EncryptedFile");
      ns.isAnyInputEncryptedFile = _isAny("InputEncryptedFile");
      ns.isAnyEncryptedMessage = _isAny("EncryptedMessage");
      ns.isAnyInputDocument = _isAny("InputDocument");
      ns.isAnyDocument = _isAny("Document");
      ns.isAnyNotifyPeer = _isAny("NotifyPeer");
      ns.isAnySendMessageAction = _isAny("SendMessageAction");
      ns.isAnyInputPrivacyKey = _isAny("InputPrivacyKey");
      ns.isAnyPrivacyKey = _isAny("PrivacyKey");
      ns.isAnyInputPrivacyRule = _isAny("InputPrivacyRule");
      ns.isAnyPrivacyRule = _isAny("PrivacyRule");
      ns.isAnyAccountDaysTTL = _isAny("AccountDaysTTL");
      ns.isAnyDocumentAttribute = _isAny("DocumentAttribute");
      ns.isAnyStickerPack = _isAny("StickerPack");
      ns.isAnyWebPage = _isAny("WebPage");
      ns.isAnyAuthorization = _isAny("Authorization");
      ns.isAnyReceivedNotifyMessage = _isAny("ReceivedNotifyMessage");
      ns.isAnyExportedChatInvite = _isAny("ExportedChatInvite");
      ns.isAnyChatInvite = _isAny("ChatInvite");
      ns.isAnyInputStickerSet = _isAny("InputStickerSet");
      ns.isAnyStickerSet = _isAny("StickerSet");
      ns.isAnyBotCommand = _isAny("BotCommand");
      ns.isAnyBotInfo = _isAny("BotInfo");
      ns.isAnyKeyboardButton = _isAny("KeyboardButton");
      ns.isAnyKeyboardButtonRow = _isAny("KeyboardButtonRow");
      ns.isAnyReplyMarkup = _isAny("ReplyMarkup");
      ns.isAnyMessageEntity = _isAny("MessageEntity");
      ns.isAnyInputChannel = _isAny("InputChannel");
      ns.isAnyMessageRange = _isAny("MessageRange");
      ns.isAnyChannelMessagesFilter = _isAny("ChannelMessagesFilter");
      ns.isAnyChannelParticipant = _isAny("ChannelParticipant");
      ns.isAnyChannelParticipantsFilter = _isAny("ChannelParticipantsFilter");
      ns.isAnyInputBotInlineMessage = _isAny("InputBotInlineMessage");
      ns.isAnyInputBotInlineResult = _isAny("InputBotInlineResult");
      ns.isAnyBotInlineMessage = _isAny("BotInlineMessage");
      ns.isAnyBotInlineResult = _isAny("BotInlineResult");
      ns.isAnyExportedMessageLink = _isAny("ExportedMessageLink");
      ns.isAnyMessageFwdHeader = _isAny("MessageFwdHeader");
      ns.isAnyInputBotInlineMessageID = _isAny("InputBotInlineMessageID");
      ns.isAnyInlineBotSwitchPM = _isAny("InlineBotSwitchPM");
      ns.isAnyTopPeer = _isAny("TopPeer");
      ns.isAnyTopPeerCategory = _isAny("TopPeerCategory");
      ns.isAnyTopPeerCategoryPeers = _isAny("TopPeerCategoryPeers");
      ns.isAnyDraftMessage = _isAny("DraftMessage");
      ns.isAnyStickerSetCovered = _isAny("StickerSetCovered");
      ns.isAnyMaskCoords = _isAny("MaskCoords");
      ns.isAnyInputStickeredMedia = _isAny("InputStickeredMedia");
      ns.isAnyGame = _isAny("Game");
      ns.isAnyInputGame = _isAny("InputGame");
      ns.isAnyHighScore = _isAny("HighScore");
      ns.isAnyRichText = _isAny("RichText");
      ns.isAnyPageBlock = _isAny("PageBlock");
      ns.isAnyPhoneCallDiscardReason = _isAny("PhoneCallDiscardReason");
      ns.isAnyDataJSON = _isAny("DataJSON");
      ns.isAnyLabeledPrice = _isAny("LabeledPrice");
      ns.isAnyInvoice = _isAny("Invoice");
      ns.isAnyPaymentCharge = _isAny("PaymentCharge");
      ns.isAnyPostAddress = _isAny("PostAddress");
      ns.isAnyPaymentRequestedInfo = _isAny("PaymentRequestedInfo");
      ns.isAnyPaymentSavedCredentials = _isAny("PaymentSavedCredentials");
      ns.isAnyWebDocument = _isAny("WebDocument");
      ns.isAnyInputWebDocument = _isAny("InputWebDocument");
      ns.isAnyInputWebFileLocation = _isAny("InputWebFileLocation");
      ns.isAnyInputPaymentCredentials = _isAny("InputPaymentCredentials");
      ns.isAnyShippingOption = _isAny("ShippingOption");
      ns.isAnyInputStickerSetItem = _isAny("InputStickerSetItem");
      ns.isAnyInputPhoneCall = _isAny("InputPhoneCall");
      ns.isAnyPhoneCall = _isAny("PhoneCall");
      ns.isAnyPhoneConnection = _isAny("PhoneConnection");
      ns.isAnyPhoneCallProtocol = _isAny("PhoneCallProtocol");
      ns.isAnyCdnPublicKey = _isAny("CdnPublicKey");
      ns.isAnyCdnConfig = _isAny("CdnConfig");
      ns.isAnyLangPackString = _isAny("LangPackString");
      ns.isAnyLangPackDifference = _isAny("LangPackDifference");
      ns.isAnyLangPackLanguage = _isAny("LangPackLanguage");
      ns.isAnyChannelAdminLogEventAction = _isAny("ChannelAdminLogEventAction");
      ns.isAnyChannelAdminLogEvent = _isAny("ChannelAdminLogEvent");
      ns.isAnyChannelAdminLogEventsFilter = _isAny("ChannelAdminLogEventsFilter");
      ns.isAnyPopularContact = _isAny("PopularContact");
      ns.isAnyRecentMeUrl = _isAny("RecentMeUrl");
      ns.isAnyInputSingleMedia = _isAny("InputSingleMedia");
      ns.isAnyWebAuthorization = _isAny("WebAuthorization");
      ns.isAnyInputMessage = _isAny("InputMessage");
      ns.isAnyInputDialogPeer = _isAny("InputDialogPeer");
      ns.isAnyDialogPeer = _isAny("DialogPeer");
      ns.isAnyFileHash = _isAny("FileHash");
      ns.isAnyInputClientProxy = _isAny("InputClientProxy");
      ns.isAnyInputSecureFile = _isAny("InputSecureFile");
      ns.isAnySecureFile = _isAny("SecureFile");
      ns.isAnySecureData = _isAny("SecureData");
      ns.isAnySecurePlainData = _isAny("SecurePlainData");
      ns.isAnySecureValueType = _isAny("SecureValueType");
      ns.isAnySecureValue = _isAny("SecureValue");
      ns.isAnyInputSecureValue = _isAny("InputSecureValue");
      ns.isAnySecureValueHash = _isAny("SecureValueHash");
      ns.isAnySecureValueError = _isAny("SecureValueError");
      ns.isAnySecureCredentialsEncrypted = _isAny("SecureCredentialsEncrypted");
      ns.isAnySavedContact = _isAny("SavedContact");
      ns.isAnyPasswordKdfAlgo = _isAny("PasswordKdfAlgo");
      ns.isAnySecurePasswordKdfAlgo = _isAny("SecurePasswordKdfAlgo");
      ns.isAnySecureSecretSettings = _isAny("SecureSecretSettings");
      ns.isAnyInputCheckPasswordSRP = _isAny("InputCheckPasswordSRP");
      ns.isAnySecureRequiredType = _isAny("SecureRequiredType");
      ns.isAnyInputAppEvent = _isAny("InputAppEvent");
      ns.isAnyJSONObjectValue = _isAny("JSONObjectValue");
      ns.isAnyJSONValue = _isAny("JSONValue");
      ns.isAnyPageTableCell = _isAny("PageTableCell");
      ns.isAnyPageTableRow = _isAny("PageTableRow");
      ns.isAnyPageCaption = _isAny("PageCaption");
      ns.isAnyPageListItem = _isAny("PageListItem");
      ns.isAnyPageListOrderedItem = _isAny("PageListOrderedItem");
      ns.isAnyPageRelatedArticle = _isAny("PageRelatedArticle");
      ns.isAnyPage = _isAny("Page");
      ns.isAnyPollAnswer = _isAny("PollAnswer");
      ns.isAnyPoll = _isAny("Poll");
      ns.isAnyPollAnswerVoters = _isAny("PollAnswerVoters");
      ns.isAnyPollResults = _isAny("PollResults");
      ns.isAnyChatOnlines = _isAny("ChatOnlines");
      ns.isAnyStatsURL = _isAny("StatsURL");
      ns.isAnyChatAdminRights = _isAny("ChatAdminRights");
      ns.isAnyChatBannedRights = _isAny("ChatBannedRights");
      ns.isAnyInputWallPaper = _isAny("InputWallPaper");
      ns.isAnyCodeSettings = _isAny("CodeSettings");
      ns.isAnyWallPaperSettings = _isAny("WallPaperSettings");
      ns.isAnyAutoDownloadSettings = _isAny("AutoDownloadSettings");
      ns.isAnyEmojiKeyword = _isAny("EmojiKeyword");
      ns.isAnyEmojiKeywordsDifference = _isAny("EmojiKeywordsDifference");
      ns.isAnyEmojiURL = _isAny("EmojiURL");
      ns.isAnyEmojiLanguage = _isAny("EmojiLanguage");
      ns.isAnyFolder = _isAny("Folder");
      ns.isAnyInputFolderPeer = _isAny("InputFolderPeer");
      ns.isAnyFolderPeer = _isAny("FolderPeer");
      ns.isAnyUrlAuthResult = _isAny("UrlAuthResult");
      ns.isAnyChannelLocation = _isAny("ChannelLocation");
      ns.isAnyPeerLocated = _isAny("PeerLocated");
      ns.isAnyRestrictionReason = _isAny("RestrictionReason");
      ns.isAnyInputTheme = _isAny("InputTheme");
      ns.isAnyTheme = _isAny("Theme");
      ns.isAnyBaseTheme = _isAny("BaseTheme");
      ns.isAnyInputThemeSettings = _isAny("InputThemeSettings");
      ns.isAnyThemeSettings = _isAny("ThemeSettings");
      ns.isAnyWebPageAttribute = _isAny("WebPageAttribute");
      ns.isAnyBankCardOpenUrl = _isAny("BankCardOpenUrl");
      ns.isAnyDialogFilter = _isAny("DialogFilter");
      ns.isAnyDialogFilterSuggested = _isAny("DialogFilterSuggested");
      ns.isAnyStatsDateRangeDays = _isAny("StatsDateRangeDays");
      ns.isAnyStatsAbsValueAndPrev = _isAny("StatsAbsValueAndPrev");
      ns.isAnyStatsPercentValue = _isAny("StatsPercentValue");
      ns.isAnyStatsGraph = _isAny("StatsGraph");
      ns.isAnyVideoSize = _isAny("VideoSize");
      ns.isAnyStatsGroupTopPoster = _isAny("StatsGroupTopPoster");
      ns.isAnyStatsGroupTopAdmin = _isAny("StatsGroupTopAdmin");
      ns.isAnyStatsGroupTopInviter = _isAny("StatsGroupTopInviter");
      ns.isAnyGlobalPrivacySettings = _isAny("GlobalPrivacySettings");
      ns.isAnyMessageViews = _isAny("MessageViews");
      ns.isAnyMessageReplyHeader = _isAny("MessageReplyHeader");
      ns.isAnyMessageReplies = _isAny("MessageReplies");
      ns.isAnyPeerBlocked = _isAny("PeerBlocked");
      ns.isAnyGroupCall = _isAny("GroupCall");
      ns.isAnyInputGroupCall = _isAny("InputGroupCall");
      ns.isAnyGroupCallParticipant = _isAny("GroupCallParticipant");
      ns.isAnyInlineQueryPeerType = _isAny("InlineQueryPeerType");
      ns.isAnyChatInviteImporter = _isAny("ChatInviteImporter");
      ns.isAnyChatAdminWithInvites = _isAny("ChatAdminWithInvites");
      ns.isAnyGroupCallParticipantVideoSourceGroup = _isAny("GroupCallParticipantVideoSourceGroup");
      ns.isAnyGroupCallParticipantVideo = _isAny("GroupCallParticipantVideo");
      ns.isAnyBotCommandScope = _isAny("BotCommandScope");
      ns.isAnySponsoredMessage = _isAny("SponsoredMessage");
      ns.isAnySearchResultsCalendarPeriod = _isAny("SearchResultsCalendarPeriod");
      ns.isAnySearchResultsPosition = _isAny("SearchResultsPosition");
      ns.isAnyReactionCount = _isAny("ReactionCount");
      ns.isAnyMessageReactions = _isAny("MessageReactions");
      ns.isAnyAvailableReaction = _isAny("AvailableReaction");
      ns.isAnyMessagePeerReaction = _isAny("MessagePeerReaction");
      ns.isAnyGroupCallStreamChannel = _isAny("GroupCallStreamChannel");
      ns.isAnyAttachMenuBotIconColor = _isAny("AttachMenuBotIconColor");
      ns.isAnyAttachMenuBotIcon = _isAny("AttachMenuBotIcon");
      ns.isAnyAttachMenuBot = _isAny("AttachMenuBot");
      ns.isAnyAttachMenuBots = _isAny("AttachMenuBots");
      ns.isAnyAttachMenuBotsBot = _isAny("AttachMenuBotsBot");
      ns.isAnyWebViewResult = _isAny("WebViewResult");
      ns.isAnyWebViewMessageSent = _isAny("WebViewMessageSent");
      ns.isAnyBotMenuButton = _isAny("BotMenuButton");
      ns.isAnyNotificationSound = _isAny("NotificationSound");
      ns.isAnyAttachMenuPeerType = _isAny("AttachMenuPeerType");
      ns.isAnyInputInvoice = _isAny("InputInvoice");
      ns.isAnyInputStorePaymentPurpose = _isAny("InputStorePaymentPurpose");
      ns.isAnyPremiumGiftOption = _isAny("PremiumGiftOption");
      ns.isAnyPaymentFormMethod = _isAny("PaymentFormMethod");
      ns.isAnyEmojiStatus = _isAny("EmojiStatus");
      ns.isAnyReaction = _isAny("Reaction");
      ns.isAnyChatReactions = _isAny("ChatReactions");
      ns.isAnyEmailVerifyPurpose = _isAny("EmailVerifyPurpose");
      ns.isAnyEmailVerification = _isAny("EmailVerification");
      ns.isAnyPremiumSubscriptionOption = _isAny("PremiumSubscriptionOption");
      ns.isAnySendAsPeer = _isAny("SendAsPeer");
      ns.isAnyMessageExtendedMedia = _isAny("MessageExtendedMedia");
      ns.isAnyStickerKeyword = _isAny("StickerKeyword");
      ns.isAnyUsername = _isAny("Username");
      ns.isAnyForumTopic = _isAny("ForumTopic");
      ns.isAnyDefaultHistoryTTL = _isAny("DefaultHistoryTTL");
      ns.isAnyExportedContactToken = _isAny("ExportedContactToken");
      ns.isAnyRequestPeerType = _isAny("RequestPeerType");
      ns.isAnyEmojiList = _isAny("EmojiList");
      ns.isAnyEmojiGroup = _isAny("EmojiGroup");
      ns.isAnyTextWithEntities = _isAny("TextWithEntities");
      ns.isAnyAutoSaveSettings = _isAny("AutoSaveSettings");
      ns.isAnyAutoSaveException = _isAny("AutoSaveException");
      ns.isAnyInputBotApp = _isAny("InputBotApp");
      ns.isAnyBotApp = _isAny("BotApp");
      ns.isAnyInlineBotWebView = _isAny("InlineBotWebView");
      ns.isAnyReadParticipantDate = _isAny("ReadParticipantDate");
      ns.isAnyInputChatlist = _isAny("InputChatlist");
      ns.isAnyExportedChatlistInvite = _isAny("ExportedChatlistInvite");
      ns.isAnyMessagePeerVote = _isAny("MessagePeerVote");
      ns.isAnyStoryViews = _isAny("StoryViews");
      ns.isAnyStoryItem = _isAny("StoryItem");
      ns.isAnyStoryView = _isAny("StoryView");
      ns.isAnyInputReplyTo = _isAny("InputReplyTo");
      ns.isAnyExportedStoryLink = _isAny("ExportedStoryLink");
      ns.isAnyStoriesStealthMode = _isAny("StoriesStealthMode");
      ns.isAnyMediaAreaCoordinates = _isAny("MediaAreaCoordinates");
      ns.isAnyMediaArea = _isAny("MediaArea");
      ns.isAnyPeerStories = _isAny("PeerStories");
      ns.isAnyPremiumGiftCodeOption = _isAny("PremiumGiftCodeOption");
      ns.isAnyPrepaidGiveaway = _isAny("PrepaidGiveaway");
      ns.isAnyBoost = _isAny("Boost");
      ns.isAnyMyBoost = _isAny("MyBoost");
      ns.isAnyStoryFwdHeader = _isAny("StoryFwdHeader");
      ns.isAnyPostInteractionCounters = _isAny("PostInteractionCounters");
      ns.isAnyPublicForward = _isAny("PublicForward");
      ns.isAnyPeerColor = _isAny("PeerColor");
      ns.isAnyStoryReaction = _isAny("StoryReaction");
      ns.isAnySavedDialog = _isAny("SavedDialog");
      ns.isAnySavedReactionTag = _isAny("SavedReactionTag");
      ns.isAnyOutboxReadDate = _isAny("OutboxReadDate");
      ns.isAnySmsJob = _isAny("SmsJob");
      ns.isAnyBusinessWeeklyOpen = _isAny("BusinessWeeklyOpen");
      ns.isAnyBusinessWorkHours = _isAny("BusinessWorkHours");
      ns.isAnyBusinessLocation = _isAny("BusinessLocation");
      ns.isAnyInputBusinessRecipients = _isAny("InputBusinessRecipients");
      ns.isAnyBusinessRecipients = _isAny("BusinessRecipients");
      ns.isAnyBusinessAwayMessageSchedule = _isAny("BusinessAwayMessageSchedule");
      ns.isAnyInputBusinessGreetingMessage = _isAny("InputBusinessGreetingMessage");
      ns.isAnyBusinessGreetingMessage = _isAny("BusinessGreetingMessage");
      ns.isAnyInputBusinessAwayMessage = _isAny("InputBusinessAwayMessage");
      ns.isAnyBusinessAwayMessage = _isAny("BusinessAwayMessage");
      ns.isAnyTimezone = _isAny("Timezone");
      ns.isAnyQuickReply = _isAny("QuickReply");
      ns.isAnyInputQuickReplyShortcut = _isAny("InputQuickReplyShortcut");
      ns.isAnyConnectedBot = _isAny("ConnectedBot");
      ns.isAnyBirthday = _isAny("Birthday");
      ns.isAnyBotBusinessConnection = _isAny("BotBusinessConnection");
      ns.isAnyInputBusinessIntro = _isAny("InputBusinessIntro");
      ns.isAnyBusinessIntro = _isAny("BusinessIntro");
      ns.isAnyInputCollectible = _isAny("InputCollectible");
      ns.isAnyInputBusinessBotRecipients = _isAny("InputBusinessBotRecipients");
      ns.isAnyBusinessBotRecipients = _isAny("BusinessBotRecipients");
      ns.isAnyContactBirthday = _isAny("ContactBirthday");
      ns.isAnyMissingInvitee = _isAny("MissingInvitee");
      ns.isAnyInputBusinessChatLink = _isAny("InputBusinessChatLink");
      ns.isAnyBusinessChatLink = _isAny("BusinessChatLink");
      ns.isAnyRequestedPeer = _isAny("RequestedPeer");
      ns.isAnySponsoredMessageReportOption = _isAny("SponsoredMessageReportOption");
      ns.isAnyBroadcastRevenueTransaction = _isAny("BroadcastRevenueTransaction");
      ns.isAnyReactionNotificationsFrom = _isAny("ReactionNotificationsFrom");
      ns.isAnyReactionsNotifySettings = _isAny("ReactionsNotifySettings");
      ns.isAnyBroadcastRevenueBalances = _isAny("BroadcastRevenueBalances");
      ns.isAnyAvailableEffect = _isAny("AvailableEffect");
      ns.isAnyFactCheck = _isAny("FactCheck");
      ns.isAnyStarsTransactionPeer = _isAny("StarsTransactionPeer");
      ns.isAnyStarsTopupOption = _isAny("StarsTopupOption");
      ns.isAnyStarsTransaction = _isAny("StarsTransaction");
      ns.isAnyFoundStory = _isAny("FoundStory");
      ns.isAnyGeoPointAddress = _isAny("GeoPointAddress");
      ns.isAnyStarsRevenueStatus = _isAny("StarsRevenueStatus");
      ns.isAnyInputStarsTransaction = _isAny("InputStarsTransaction");
      ns.isAnyStarsGiftOption = _isAny("StarsGiftOption");
      ns.isAnyBotPreviewMedia = _isAny("BotPreviewMedia");
      ns.isAnyStarsSubscriptionPricing = _isAny("StarsSubscriptionPricing");
      ns.isAnyStarsSubscription = _isAny("StarsSubscription");
      ns.isAnyMessageReactor = _isAny("MessageReactor");
      ns.isAnyStarsGiveawayOption = _isAny("StarsGiveawayOption");
      ns.isAnyStarsGiveawayWinnersOption = _isAny("StarsGiveawayWinnersOption");
      ns.isAnyStarGift = _isAny("StarGift");
      ns.isAnyUserStarGift = _isAny("UserStarGift");
      ns.isAnyMessageReportOption = _isAny("MessageReportOption");
      ns.isAnyReportResult = _isAny("ReportResult");
      ns.help = {};
      (function(ns2) {
        ns2.isAnyConfigSimple = _isAny("help.ConfigSimple");
        ns2.isAnyAppUpdate = _isAny("help.AppUpdate");
        ns2.isAnyInviteText = _isAny("help.InviteText");
        ns2.isAnySupport = _isAny("help.Support");
        ns2.isAnyTermsOfService = _isAny("help.TermsOfService");
        ns2.isAnyRecentMeUrls = _isAny("help.RecentMeUrls");
        ns2.isAnyTermsOfServiceUpdate = _isAny("help.TermsOfServiceUpdate");
        ns2.isAnyDeepLinkInfo = _isAny("help.DeepLinkInfo");
        ns2.isAnyPassportConfig = _isAny("help.PassportConfig");
        ns2.isAnySupportName = _isAny("help.SupportName");
        ns2.isAnyUserInfo = _isAny("help.UserInfo");
        ns2.isAnyPromoData = _isAny("help.PromoData");
        ns2.isAnyCountryCode = _isAny("help.CountryCode");
        ns2.isAnyCountry = _isAny("help.Country");
        ns2.isAnyCountriesList = _isAny("help.CountriesList");
        ns2.isAnyPremiumPromo = _isAny("help.PremiumPromo");
        ns2.isAnyAppConfig = _isAny("help.AppConfig");
        ns2.isAnyPeerColorSet = _isAny("help.PeerColorSet");
        ns2.isAnyPeerColorOption = _isAny("help.PeerColorOption");
        ns2.isAnyPeerColors = _isAny("help.PeerColors");
        ns2.isAnyTimezonesList = _isAny("help.TimezonesList");
      })(ns.help);
      ns.storage = {};
      (function(ns2) {
        ns2.isAnyFileType = _isAny("storage.FileType");
      })(ns.storage);
      ns.auth = {};
      (function(ns2) {
        ns2.isAnySentCode = _isAny("auth.SentCode");
        ns2.isAnyAuthorization = _isAny("auth.Authorization");
        ns2.isAnyExportedAuthorization = _isAny("auth.ExportedAuthorization");
        ns2.isAnyPasswordRecovery = _isAny("auth.PasswordRecovery");
        ns2.isAnyCodeType = _isAny("auth.CodeType");
        ns2.isAnySentCodeType = _isAny("auth.SentCodeType");
        ns2.isAnyLoginToken = _isAny("auth.LoginToken");
        ns2.isAnyLoggedOut = _isAny("auth.LoggedOut");
      })(ns.auth);
      ns.contacts = {};
      (function(ns2) {
        ns2.isAnyContacts = _isAny("contacts.Contacts");
        ns2.isAnyImportedContacts = _isAny("contacts.ImportedContacts");
        ns2.isAnyBlocked = _isAny("contacts.Blocked");
        ns2.isAnyFound = _isAny("contacts.Found");
        ns2.isAnyResolvedPeer = _isAny("contacts.ResolvedPeer");
        ns2.isAnyTopPeers = _isAny("contacts.TopPeers");
        ns2.isAnyContactBirthdays = _isAny("contacts.ContactBirthdays");
      })(ns.contacts);
      ns.messages = {};
      (function(ns2) {
        ns2.isAnyDialogs = _isAny("messages.Dialogs");
        ns2.isAnyMessages = _isAny("messages.Messages");
        ns2.isAnyChats = _isAny("messages.Chats");
        ns2.isAnyChatFull = _isAny("messages.ChatFull");
        ns2.isAnyAffectedHistory = _isAny("messages.AffectedHistory");
        ns2.isAnyDhConfig = _isAny("messages.DhConfig");
        ns2.isAnySentEncryptedMessage = _isAny("messages.SentEncryptedMessage");
        ns2.isAnyStickers = _isAny("messages.Stickers");
        ns2.isAnyAllStickers = _isAny("messages.AllStickers");
        ns2.isAnyAffectedMessages = _isAny("messages.AffectedMessages");
        ns2.isAnyStickerSet = _isAny("messages.StickerSet");
        ns2.isAnySavedGifs = _isAny("messages.SavedGifs");
        ns2.isAnyBotResults = _isAny("messages.BotResults");
        ns2.isAnyBotCallbackAnswer = _isAny("messages.BotCallbackAnswer");
        ns2.isAnyMessageEditData = _isAny("messages.MessageEditData");
        ns2.isAnyPeerDialogs = _isAny("messages.PeerDialogs");
        ns2.isAnyFeaturedStickers = _isAny("messages.FeaturedStickers");
        ns2.isAnyRecentStickers = _isAny("messages.RecentStickers");
        ns2.isAnyArchivedStickers = _isAny("messages.ArchivedStickers");
        ns2.isAnyStickerSetInstallResult = _isAny("messages.StickerSetInstallResult");
        ns2.isAnyHighScores = _isAny("messages.HighScores");
        ns2.isAnyFavedStickers = _isAny("messages.FavedStickers");
        ns2.isAnyFoundStickerSets = _isAny("messages.FoundStickerSets");
        ns2.isAnySearchCounter = _isAny("messages.SearchCounter");
        ns2.isAnyInactiveChats = _isAny("messages.InactiveChats");
        ns2.isAnyVotesList = _isAny("messages.VotesList");
        ns2.isAnyMessageViews = _isAny("messages.MessageViews");
        ns2.isAnyDiscussionMessage = _isAny("messages.DiscussionMessage");
        ns2.isAnyHistoryImport = _isAny("messages.HistoryImport");
        ns2.isAnyHistoryImportParsed = _isAny("messages.HistoryImportParsed");
        ns2.isAnyAffectedFoundMessages = _isAny("messages.AffectedFoundMessages");
        ns2.isAnyExportedChatInvites = _isAny("messages.ExportedChatInvites");
        ns2.isAnyExportedChatInvite = _isAny("messages.ExportedChatInvite");
        ns2.isAnyChatInviteImporters = _isAny("messages.ChatInviteImporters");
        ns2.isAnyChatAdminsWithInvites = _isAny("messages.ChatAdminsWithInvites");
        ns2.isAnyCheckedHistoryImportPeer = _isAny("messages.CheckedHistoryImportPeer");
        ns2.isAnySponsoredMessages = _isAny("messages.SponsoredMessages");
        ns2.isAnySearchResultsCalendar = _isAny("messages.SearchResultsCalendar");
        ns2.isAnySearchResultsPositions = _isAny("messages.SearchResultsPositions");
        ns2.isAnyPeerSettings = _isAny("messages.PeerSettings");
        ns2.isAnyMessageReactionsList = _isAny("messages.MessageReactionsList");
        ns2.isAnyAvailableReactions = _isAny("messages.AvailableReactions");
        ns2.isAnyTranscribedAudio = _isAny("messages.TranscribedAudio");
        ns2.isAnyReactions = _isAny("messages.Reactions");
        ns2.isAnyForumTopics = _isAny("messages.ForumTopics");
        ns2.isAnyEmojiGroups = _isAny("messages.EmojiGroups");
        ns2.isAnyTranslatedText = _isAny("messages.TranslatedText");
        ns2.isAnyBotApp = _isAny("messages.BotApp");
        ns2.isAnyWebPage = _isAny("messages.WebPage");
        ns2.isAnySavedDialogs = _isAny("messages.SavedDialogs");
        ns2.isAnySavedReactionTags = _isAny("messages.SavedReactionTags");
        ns2.isAnyQuickReplies = _isAny("messages.QuickReplies");
        ns2.isAnyDialogFilters = _isAny("messages.DialogFilters");
        ns2.isAnyMyStickers = _isAny("messages.MyStickers");
        ns2.isAnyInvitedUsers = _isAny("messages.InvitedUsers");
        ns2.isAnyAvailableEffects = _isAny("messages.AvailableEffects");
      })(ns.messages);
      ns.updates = {};
      (function(ns2) {
        ns2.isAnyState = _isAny("updates.State");
        ns2.isAnyDifference = _isAny("updates.Difference");
        ns2.isAnyChannelDifference = _isAny("updates.ChannelDifference");
      })(ns.updates);
      ns.photos = {};
      (function(ns2) {
        ns2.isAnyPhotos = _isAny("photos.Photos");
        ns2.isAnyPhoto = _isAny("photos.Photo");
      })(ns.photos);
      ns.upload = {};
      (function(ns2) {
        ns2.isAnyFile = _isAny("upload.File");
        ns2.isAnyWebFile = _isAny("upload.WebFile");
        ns2.isAnyCdnFile = _isAny("upload.CdnFile");
      })(ns.upload);
      ns.account = {};
      (function(ns2) {
        ns2.isAnyPrivacyRules = _isAny("account.PrivacyRules");
        ns2.isAnyAuthorizations = _isAny("account.Authorizations");
        ns2.isAnyPassword = _isAny("account.Password");
        ns2.isAnyPasswordSettings = _isAny("account.PasswordSettings");
        ns2.isAnyPasswordInputSettings = _isAny("account.PasswordInputSettings");
        ns2.isAnyTmpPassword = _isAny("account.TmpPassword");
        ns2.isAnyWebAuthorizations = _isAny("account.WebAuthorizations");
        ns2.isAnyAuthorizationForm = _isAny("account.AuthorizationForm");
        ns2.isAnySentEmailCode = _isAny("account.SentEmailCode");
        ns2.isAnyTakeout = _isAny("account.Takeout");
        ns2.isAnyWallPapers = _isAny("account.WallPapers");
        ns2.isAnyAutoDownloadSettings = _isAny("account.AutoDownloadSettings");
        ns2.isAnyThemes = _isAny("account.Themes");
        ns2.isAnyContentSettings = _isAny("account.ContentSettings");
        ns2.isAnyResetPasswordResult = _isAny("account.ResetPasswordResult");
        ns2.isAnySavedRingtones = _isAny("account.SavedRingtones");
        ns2.isAnySavedRingtone = _isAny("account.SavedRingtone");
        ns2.isAnyEmojiStatuses = _isAny("account.EmojiStatuses");
        ns2.isAnyEmailVerified = _isAny("account.EmailVerified");
        ns2.isAnyAutoSaveSettings = _isAny("account.AutoSaveSettings");
        ns2.isAnyConnectedBots = _isAny("account.ConnectedBots");
        ns2.isAnyBusinessChatLinks = _isAny("account.BusinessChatLinks");
        ns2.isAnyResolvedBusinessChatLinks = _isAny("account.ResolvedBusinessChatLinks");
      })(ns.account);
      ns.channels = {};
      (function(ns2) {
        ns2.isAnyChannelParticipants = _isAny("channels.ChannelParticipants");
        ns2.isAnyChannelParticipant = _isAny("channels.ChannelParticipant");
        ns2.isAnyAdminLogResults = _isAny("channels.AdminLogResults");
        ns2.isAnySendAsPeers = _isAny("channels.SendAsPeers");
        ns2.isAnySponsoredMessageReportResult = _isAny("channels.SponsoredMessageReportResult");
      })(ns.channels);
      ns.payments = {};
      (function(ns2) {
        ns2.isAnyPaymentForm = _isAny("payments.PaymentForm");
        ns2.isAnyValidatedRequestedInfo = _isAny("payments.ValidatedRequestedInfo");
        ns2.isAnyPaymentResult = _isAny("payments.PaymentResult");
        ns2.isAnyPaymentReceipt = _isAny("payments.PaymentReceipt");
        ns2.isAnySavedInfo = _isAny("payments.SavedInfo");
        ns2.isAnyBankCardData = _isAny("payments.BankCardData");
        ns2.isAnyExportedInvoice = _isAny("payments.ExportedInvoice");
        ns2.isAnyCheckedGiftCode = _isAny("payments.CheckedGiftCode");
        ns2.isAnyGiveawayInfo = _isAny("payments.GiveawayInfo");
        ns2.isAnyStarsStatus = _isAny("payments.StarsStatus");
        ns2.isAnyStarsRevenueStats = _isAny("payments.StarsRevenueStats");
        ns2.isAnyStarsRevenueWithdrawalUrl = _isAny("payments.StarsRevenueWithdrawalUrl");
        ns2.isAnyStarsRevenueAdsAccountUrl = _isAny("payments.StarsRevenueAdsAccountUrl");
        ns2.isAnyStarGifts = _isAny("payments.StarGifts");
        ns2.isAnyUserStarGifts = _isAny("payments.UserStarGifts");
      })(ns.payments);
      ns.phone = {};
      (function(ns2) {
        ns2.isAnyPhoneCall = _isAny("phone.PhoneCall");
        ns2.isAnyGroupCall = _isAny("phone.GroupCall");
        ns2.isAnyGroupParticipants = _isAny("phone.GroupParticipants");
        ns2.isAnyJoinAsPeers = _isAny("phone.JoinAsPeers");
        ns2.isAnyExportedGroupCallInvite = _isAny("phone.ExportedGroupCallInvite");
        ns2.isAnyGroupCallStreamChannels = _isAny("phone.GroupCallStreamChannels");
        ns2.isAnyGroupCallStreamRtmpUrl = _isAny("phone.GroupCallStreamRtmpUrl");
      })(ns.phone);
      ns.stats = {};
      (function(ns2) {
        ns2.isAnyBroadcastStats = _isAny("stats.BroadcastStats");
        ns2.isAnyMegagroupStats = _isAny("stats.MegagroupStats");
        ns2.isAnyMessageStats = _isAny("stats.MessageStats");
        ns2.isAnyStoryStats = _isAny("stats.StoryStats");
        ns2.isAnyPublicForwards = _isAny("stats.PublicForwards");
        ns2.isAnyBroadcastRevenueStats = _isAny("stats.BroadcastRevenueStats");
        ns2.isAnyBroadcastRevenueWithdrawalUrl = _isAny("stats.BroadcastRevenueWithdrawalUrl");
        ns2.isAnyBroadcastRevenueTransactions = _isAny("stats.BroadcastRevenueTransactions");
      })(ns.stats);
      ns.stickers = {};
      (function(ns2) {
        ns2.isAnySuggestedShortName = _isAny("stickers.SuggestedShortName");
      })(ns.stickers);
      ns.users = {};
      (function(ns2) {
        ns2.isAnyUserFull = _isAny("users.UserFull");
      })(ns.users);
      ns.chatlists = {};
      (function(ns2) {
        ns2.isAnyExportedChatlistInvite = _isAny("chatlists.ExportedChatlistInvite");
        ns2.isAnyExportedInvites = _isAny("chatlists.ExportedInvites");
        ns2.isAnyChatlistInvite = _isAny("chatlists.ChatlistInvite");
        ns2.isAnyChatlistUpdates = _isAny("chatlists.ChatlistUpdates");
      })(ns.chatlists);
      ns.bots = {};
      (function(ns2) {
        ns2.isAnyBotInfo = _isAny("bots.BotInfo");
        ns2.isAnyPopularAppBots = _isAny("bots.PopularAppBots");
        ns2.isAnyPreviewInfo = _isAny("bots.PreviewInfo");
      })(ns.bots);
      ns.stories = {};
      (function(ns2) {
        ns2.isAnyAllStories = _isAny("stories.AllStories");
        ns2.isAnyStories = _isAny("stories.Stories");
        ns2.isAnyStoryViewsList = _isAny("stories.StoryViewsList");
        ns2.isAnyStoryViews = _isAny("stories.StoryViews");
        ns2.isAnyPeerStories = _isAny("stories.PeerStories");
        ns2.isAnyStoryReactionsList = _isAny("stories.StoryReactionsList");
        ns2.isAnyFoundStories = _isAny("stories.FoundStories");
      })(ns.stories);
      ns.premium = {};
      (function(ns2) {
        ns2.isAnyBoostsList = _isAny("premium.BoostsList");
        ns2.isAnyMyBoosts = _isAny("premium.MyBoosts");
        ns2.isAnyBoostsStatus = _isAny("premium.BoostsStatus");
      })(ns.premium);
      ns.smsjobs = {};
      (function(ns2) {
        ns2.isAnyEligibilityToJoin = _isAny("smsjobs.EligibilityToJoin");
        ns2.isAnyStatus = _isAny("smsjobs.Status");
      })(ns.smsjobs);
      ns.fragment = {};
      (function(ns2) {
        ns2.isAnyCollectibleInfo = _isAny("fragment.CollectibleInfo");
      })(ns.fragment);
      ns.mtcute = {};
      (function(ns2) {
        ns2.isAnyUpdate = _isAny("Update");
        ns2.isAnyInputPeer = _isAny("InputPeer");
      })(ns.mtcute);
      ns.test = {};
      /* @__PURE__ */ (function(ns2) {
      })(ns.test);
      ns.langpack = {};
      /* @__PURE__ */ (function(ns2) {
      })(ns.langpack);
      ns.folders = {};
      /* @__PURE__ */ (function(ns2) {
      })(ns.folders);
      _types = JSON.parse('{"error":"Error","ipPort":"IpPort","ipPortSecret":"IpPort","accessPointRule":"AccessPointRule","help.configSimple":"help.ConfigSimple","inputPeerPhotoFileLocationLegacy":"InputFileLocation","inputStickerSetThumbLegacy":"InputFileLocation","inputPeerEmpty":"InputPeer","inputPeerSelf":"InputPeer","inputPeerChat":"InputPeer","inputPeerUser":"InputPeer","inputPeerChannel":"InputPeer","inputPeerUserFromMessage":"InputPeer","inputPeerChannelFromMessage":"InputPeer","inputUserEmpty":"InputUser","inputUserSelf":"InputUser","inputUser":"InputUser","inputUserFromMessage":"InputUser","inputPhoneContact":"InputContact","inputFile":"InputFile","inputFileBig":"InputFile","inputFileStoryDocument":"InputFile","inputMediaEmpty":"InputMedia","inputMediaUploadedPhoto":"InputMedia","inputMediaPhoto":"InputMedia","inputMediaGeoPoint":"InputMedia","inputMediaContact":"InputMedia","inputMediaUploadedDocument":"InputMedia","inputMediaDocument":"InputMedia","inputMediaVenue":"InputMedia","inputMediaPhotoExternal":"InputMedia","inputMediaDocumentExternal":"InputMedia","inputMediaGame":"InputMedia","inputMediaInvoice":"InputMedia","inputMediaGeoLive":"InputMedia","inputMediaPoll":"InputMedia","inputMediaDice":"InputMedia","inputMediaStory":"InputMedia","inputMediaWebPage":"InputMedia","inputMediaPaidMedia":"InputMedia","inputChatPhotoEmpty":"InputChatPhoto","inputChatUploadedPhoto":"InputChatPhoto","inputChatPhoto":"InputChatPhoto","inputGeoPointEmpty":"InputGeoPoint","inputGeoPoint":"InputGeoPoint","inputPhotoEmpty":"InputPhoto","inputPhoto":"InputPhoto","inputFileLocation":"InputFileLocation","inputEncryptedFileLocation":"InputFileLocation","inputDocumentFileLocation":"InputFileLocation","inputSecureFileLocation":"InputFileLocation","inputTakeoutFileLocation":"InputFileLocation","inputPhotoFileLocation":"InputFileLocation","inputPhotoLegacyFileLocation":"InputFileLocation","inputPeerPhotoFileLocation":"InputFileLocation","inputStickerSetThumb":"InputFileLocation","inputGroupCallStream":"InputFileLocation","peerUser":"Peer","peerChat":"Peer","peerChannel":"Peer","storage.fileUnknown":"storage.FileType","storage.filePartial":"storage.FileType","storage.fileJpeg":"storage.FileType","storage.fileGif":"storage.FileType","storage.filePng":"storage.FileType","storage.filePdf":"storage.FileType","storage.fileMp3":"storage.FileType","storage.fileMov":"storage.FileType","storage.fileMp4":"storage.FileType","storage.fileWebp":"storage.FileType","userEmpty":"User","user":"User","userProfilePhotoEmpty":"UserProfilePhoto","userProfilePhoto":"UserProfilePhoto","userStatusEmpty":"UserStatus","userStatusOnline":"UserStatus","userStatusOffline":"UserStatus","userStatusRecently":"UserStatus","userStatusLastWeek":"UserStatus","userStatusLastMonth":"UserStatus","chatEmpty":"Chat","chat":"Chat","chatForbidden":"Chat","channel":"Chat","channelForbidden":"Chat","chatFull":"ChatFull","channelFull":"ChatFull","chatParticipant":"ChatParticipant","chatParticipantCreator":"ChatParticipant","chatParticipantAdmin":"ChatParticipant","chatParticipantsForbidden":"ChatParticipants","chatParticipants":"ChatParticipants","chatPhotoEmpty":"ChatPhoto","chatPhoto":"ChatPhoto","messageEmpty":"Message","message":"Message","messageService":"Message","messageMediaEmpty":"MessageMedia","messageMediaPhoto":"MessageMedia","messageMediaGeo":"MessageMedia","messageMediaContact":"MessageMedia","messageMediaUnsupported":"MessageMedia","messageMediaDocument":"MessageMedia","messageMediaWebPage":"MessageMedia","messageMediaVenue":"MessageMedia","messageMediaGame":"MessageMedia","messageMediaInvoice":"MessageMedia","messageMediaGeoLive":"MessageMedia","messageMediaPoll":"MessageMedia","messageMediaDice":"MessageMedia","messageMediaStory":"MessageMedia","messageMediaGiveaway":"MessageMedia","messageMediaGiveawayResults":"MessageMedia","messageMediaPaidMedia":"MessageMedia","messageActionEmpty":"MessageAction","messageActionChatCreate":"MessageAction","messageActionChatEditTitle":"MessageAction","messageActionChatEditPhoto":"MessageAction","messageActionChatDeletePhoto":"MessageAction","messageActionChatAddUser":"MessageAction","messageActionChatDeleteUser":"MessageAction","messageActionChatJoinedByLink":"MessageAction","messageActionChannelCreate":"MessageAction","messageActionChatMigrateTo":"MessageAction","messageActionChannelMigrateFrom":"MessageAction","messageActionPinMessage":"MessageAction","messageActionHistoryClear":"MessageAction","messageActionGameScore":"MessageAction","messageActionPaymentSentMe":"MessageAction","messageActionPaymentSent":"MessageAction","messageActionPhoneCall":"MessageAction","messageActionScreenshotTaken":"MessageAction","messageActionCustomAction":"MessageAction","messageActionBotAllowed":"MessageAction","messageActionSecureValuesSentMe":"MessageAction","messageActionSecureValuesSent":"MessageAction","messageActionContactSignUp":"MessageAction","messageActionGeoProximityReached":"MessageAction","messageActionGroupCall":"MessageAction","messageActionInviteToGroupCall":"MessageAction","messageActionSetMessagesTTL":"MessageAction","messageActionGroupCallScheduled":"MessageAction","messageActionSetChatTheme":"MessageAction","messageActionChatJoinedByRequest":"MessageAction","messageActionWebViewDataSentMe":"MessageAction","messageActionWebViewDataSent":"MessageAction","messageActionGiftPremium":"MessageAction","messageActionTopicCreate":"MessageAction","messageActionTopicEdit":"MessageAction","messageActionSuggestProfilePhoto":"MessageAction","messageActionRequestedPeer":"MessageAction","messageActionSetChatWallPaper":"MessageAction","messageActionGiftCode":"MessageAction","messageActionGiveawayLaunch":"MessageAction","messageActionGiveawayResults":"MessageAction","messageActionBoostApply":"MessageAction","messageActionRequestedPeerSentMe":"MessageAction","messageActionPaymentRefunded":"MessageAction","messageActionGiftStars":"MessageAction","messageActionPrizeStars":"MessageAction","messageActionStarGift":"MessageAction","dialog":"Dialog","dialogFolder":"Dialog","photoEmpty":"Photo","photo":"Photo","photoSizeEmpty":"PhotoSize","photoSize":"PhotoSize","photoCachedSize":"PhotoSize","photoStrippedSize":"PhotoSize","photoSizeProgressive":"PhotoSize","photoPathSize":"PhotoSize","geoPointEmpty":"GeoPoint","geoPoint":"GeoPoint","auth.sentCode":"auth.SentCode","auth.sentCodeSuccess":"auth.SentCode","auth.authorization":"auth.Authorization","auth.authorizationSignUpRequired":"auth.Authorization","auth.exportedAuthorization":"auth.ExportedAuthorization","inputNotifyPeer":"InputNotifyPeer","inputNotifyUsers":"InputNotifyPeer","inputNotifyChats":"InputNotifyPeer","inputNotifyBroadcasts":"InputNotifyPeer","inputNotifyForumTopic":"InputNotifyPeer","inputPeerNotifySettings":"InputPeerNotifySettings","peerNotifySettings":"PeerNotifySettings","peerSettings":"PeerSettings","wallPaper":"WallPaper","wallPaperNoFile":"WallPaper","inputReportReasonSpam":"ReportReason","inputReportReasonViolence":"ReportReason","inputReportReasonPornography":"ReportReason","inputReportReasonChildAbuse":"ReportReason","inputReportReasonOther":"ReportReason","inputReportReasonCopyright":"ReportReason","inputReportReasonGeoIrrelevant":"ReportReason","inputReportReasonFake":"ReportReason","inputReportReasonIllegalDrugs":"ReportReason","inputReportReasonPersonalDetails":"ReportReason","userFull":"UserFull","contact":"Contact","importedContact":"ImportedContact","contactStatus":"ContactStatus","contacts.contactsNotModified":"contacts.Contacts","contacts.contacts":"contacts.Contacts","contacts.importedContacts":"contacts.ImportedContacts","contacts.blocked":"contacts.Blocked","contacts.blockedSlice":"contacts.Blocked","messages.dialogs":"messages.Dialogs","messages.dialogsSlice":"messages.Dialogs","messages.dialogsNotModified":"messages.Dialogs","messages.messages":"messages.Messages","messages.messagesSlice":"messages.Messages","messages.channelMessages":"messages.Messages","messages.messagesNotModified":"messages.Messages","messages.chats":"messages.Chats","messages.chatsSlice":"messages.Chats","messages.chatFull":"messages.ChatFull","messages.affectedHistory":"messages.AffectedHistory","inputMessagesFilterEmpty":"MessagesFilter","inputMessagesFilterPhotos":"MessagesFilter","inputMessagesFilterVideo":"MessagesFilter","inputMessagesFilterPhotoVideo":"MessagesFilter","inputMessagesFilterDocument":"MessagesFilter","inputMessagesFilterUrl":"MessagesFilter","inputMessagesFilterGif":"MessagesFilter","inputMessagesFilterVoice":"MessagesFilter","inputMessagesFilterMusic":"MessagesFilter","inputMessagesFilterChatPhotos":"MessagesFilter","inputMessagesFilterPhoneCalls":"MessagesFilter","inputMessagesFilterRoundVoice":"MessagesFilter","inputMessagesFilterRoundVideo":"MessagesFilter","inputMessagesFilterMyMentions":"MessagesFilter","inputMessagesFilterGeo":"MessagesFilter","inputMessagesFilterContacts":"MessagesFilter","inputMessagesFilterPinned":"MessagesFilter","updateNewMessage":"Update","updateMessageID":"Update","updateDeleteMessages":"Update","updateUserTyping":"Update","updateChatUserTyping":"Update","updateChatParticipants":"Update","updateUserStatus":"Update","updateUserName":"Update","updateNewAuthorization":"Update","updateNewEncryptedMessage":"Update","updateEncryptedChatTyping":"Update","updateEncryption":"Update","updateEncryptedMessagesRead":"Update","updateChatParticipantAdd":"Update","updateChatParticipantDelete":"Update","updateDcOptions":"Update","updateNotifySettings":"Update","updateServiceNotification":"Update","updatePrivacy":"Update","updateUserPhone":"Update","updateReadHistoryInbox":"Update","updateReadHistoryOutbox":"Update","updateWebPage":"Update","updateReadMessagesContents":"Update","updateChannelTooLong":"Update","updateChannel":"Update","updateNewChannelMessage":"Update","updateReadChannelInbox":"Update","updateDeleteChannelMessages":"Update","updateChannelMessageViews":"Update","updateChatParticipantAdmin":"Update","updateNewStickerSet":"Update","updateStickerSetsOrder":"Update","updateStickerSets":"Update","updateSavedGifs":"Update","updateBotInlineQuery":"Update","updateBotInlineSend":"Update","updateEditChannelMessage":"Update","updateBotCallbackQuery":"Update","updateEditMessage":"Update","updateInlineBotCallbackQuery":"Update","updateReadChannelOutbox":"Update","updateDraftMessage":"Update","updateReadFeaturedStickers":"Update","updateRecentStickers":"Update","updateConfig":"Update","updatePtsChanged":"Update","updateChannelWebPage":"Update","updateDialogPinned":"Update","updatePinnedDialogs":"Update","updateBotWebhookJSON":"Update","updateBotWebhookJSONQuery":"Update","updateBotShippingQuery":"Update","updateBotPrecheckoutQuery":"Update","updatePhoneCall":"Update","updateLangPackTooLong":"Update","updateLangPack":"Update","updateFavedStickers":"Update","updateChannelReadMessagesContents":"Update","updateContactsReset":"Update","updateChannelAvailableMessages":"Update","updateDialogUnreadMark":"Update","updateMessagePoll":"Update","updateChatDefaultBannedRights":"Update","updateFolderPeers":"Update","updatePeerSettings":"Update","updatePeerLocated":"Update","updateNewScheduledMessage":"Update","updateDeleteScheduledMessages":"Update","updateTheme":"Update","updateGeoLiveViewed":"Update","updateLoginToken":"Update","updateMessagePollVote":"Update","updateDialogFilter":"Update","updateDialogFilterOrder":"Update","updateDialogFilters":"Update","updatePhoneCallSignalingData":"Update","updateChannelMessageForwards":"Update","updateReadChannelDiscussionInbox":"Update","updateReadChannelDiscussionOutbox":"Update","updatePeerBlocked":"Update","updateChannelUserTyping":"Update","updatePinnedMessages":"Update","updatePinnedChannelMessages":"Update","updateChat":"Update","updateGroupCallParticipants":"Update","updateGroupCall":"Update","updatePeerHistoryTTL":"Update","updateChatParticipant":"Update","updateChannelParticipant":"Update","updateBotStopped":"Update","updateGroupCallConnection":"Update","updateBotCommands":"Update","updatePendingJoinRequests":"Update","updateBotChatInviteRequester":"Update","updateMessageReactions":"Update","updateAttachMenuBots":"Update","updateWebViewResultSent":"Update","updateBotMenuButton":"Update","updateSavedRingtones":"Update","updateTranscribedAudio":"Update","updateReadFeaturedEmojiStickers":"Update","updateUserEmojiStatus":"Update","updateRecentEmojiStatuses":"Update","updateRecentReactions":"Update","updateMoveStickerSetToTop":"Update","updateMessageExtendedMedia":"Update","updateChannelPinnedTopic":"Update","updateChannelPinnedTopics":"Update","updateUser":"Update","updateAutoSaveSettings":"Update","updateStory":"Update","updateReadStories":"Update","updateStoryID":"Update","updateStoriesStealthMode":"Update","updateSentStoryReaction":"Update","updateBotChatBoost":"Update","updateChannelViewForumAsMessages":"Update","updatePeerWallpaper":"Update","updateBotMessageReaction":"Update","updateBotMessageReactions":"Update","updateSavedDialogPinned":"Update","updatePinnedSavedDialogs":"Update","updateSavedReactionTags":"Update","updateSmsJob":"Update","updateQuickReplies":"Update","updateNewQuickReply":"Update","updateDeleteQuickReply":"Update","updateQuickReplyMessage":"Update","updateDeleteQuickReplyMessages":"Update","updateBotBusinessConnect":"Update","updateBotNewBusinessMessage":"Update","updateBotEditBusinessMessage":"Update","updateBotDeleteBusinessMessage":"Update","updateNewStoryReaction":"Update","updateBroadcastRevenueTransactions":"Update","updateStarsBalance":"Update","updateBusinessBotCallbackQuery":"Update","updateStarsRevenueStatus":"Update","updateBotPurchasedPaidMedia":"Update","updatePaidReactionPrivacy":"Update","updates.state":"updates.State","updates.differenceEmpty":"updates.Difference","updates.difference":"updates.Difference","updates.differenceSlice":"updates.Difference","updates.differenceTooLong":"updates.Difference","updatesTooLong":"Updates","updateShortMessage":"Updates","updateShortChatMessage":"Updates","updateShort":"Updates","updatesCombined":"Updates","updates":"Updates","updateShortSentMessage":"Updates","photos.photos":"photos.Photos","photos.photosSlice":"photos.Photos","photos.photo":"photos.Photo","upload.file":"upload.File","upload.fileCdnRedirect":"upload.File","dcOption":"DcOption","config":"Config","nearestDc":"NearestDc","help.appUpdate":"help.AppUpdate","help.noAppUpdate":"help.AppUpdate","help.inviteText":"help.InviteText","encryptedChatEmpty":"EncryptedChat","encryptedChatWaiting":"EncryptedChat","encryptedChatRequested":"EncryptedChat","encryptedChat":"EncryptedChat","encryptedChatDiscarded":"EncryptedChat","inputEncryptedChat":"InputEncryptedChat","encryptedFileEmpty":"EncryptedFile","encryptedFile":"EncryptedFile","inputEncryptedFileEmpty":"InputEncryptedFile","inputEncryptedFileUploaded":"InputEncryptedFile","inputEncryptedFile":"InputEncryptedFile","inputEncryptedFileBigUploaded":"InputEncryptedFile","encryptedMessage":"EncryptedMessage","encryptedMessageService":"EncryptedMessage","messages.dhConfigNotModified":"messages.DhConfig","messages.dhConfig":"messages.DhConfig","messages.sentEncryptedMessage":"messages.SentEncryptedMessage","messages.sentEncryptedFile":"messages.SentEncryptedMessage","inputDocumentEmpty":"InputDocument","inputDocument":"InputDocument","documentEmpty":"Document","document":"Document","help.support":"help.Support","notifyPeer":"NotifyPeer","notifyUsers":"NotifyPeer","notifyChats":"NotifyPeer","notifyBroadcasts":"NotifyPeer","notifyForumTopic":"NotifyPeer","sendMessageTypingAction":"SendMessageAction","sendMessageCancelAction":"SendMessageAction","sendMessageRecordVideoAction":"SendMessageAction","sendMessageUploadVideoAction":"SendMessageAction","sendMessageRecordAudioAction":"SendMessageAction","sendMessageUploadAudioAction":"SendMessageAction","sendMessageUploadPhotoAction":"SendMessageAction","sendMessageUploadDocumentAction":"SendMessageAction","sendMessageGeoLocationAction":"SendMessageAction","sendMessageChooseContactAction":"SendMessageAction","sendMessageGamePlayAction":"SendMessageAction","sendMessageRecordRoundAction":"SendMessageAction","sendMessageUploadRoundAction":"SendMessageAction","speakingInGroupCallAction":"SendMessageAction","sendMessageHistoryImportAction":"SendMessageAction","sendMessageChooseStickerAction":"SendMessageAction","sendMessageEmojiInteraction":"SendMessageAction","sendMessageEmojiInteractionSeen":"SendMessageAction","contacts.found":"contacts.Found","inputPrivacyKeyStatusTimestamp":"InputPrivacyKey","inputPrivacyKeyChatInvite":"InputPrivacyKey","inputPrivacyKeyPhoneCall":"InputPrivacyKey","inputPrivacyKeyPhoneP2P":"InputPrivacyKey","inputPrivacyKeyForwards":"InputPrivacyKey","inputPrivacyKeyProfilePhoto":"InputPrivacyKey","inputPrivacyKeyPhoneNumber":"InputPrivacyKey","inputPrivacyKeyAddedByPhone":"InputPrivacyKey","inputPrivacyKeyVoiceMessages":"InputPrivacyKey","inputPrivacyKeyAbout":"InputPrivacyKey","inputPrivacyKeyBirthday":"InputPrivacyKey","privacyKeyStatusTimestamp":"PrivacyKey","privacyKeyChatInvite":"PrivacyKey","privacyKeyPhoneCall":"PrivacyKey","privacyKeyPhoneP2P":"PrivacyKey","privacyKeyForwards":"PrivacyKey","privacyKeyProfilePhoto":"PrivacyKey","privacyKeyPhoneNumber":"PrivacyKey","privacyKeyAddedByPhone":"PrivacyKey","privacyKeyVoiceMessages":"PrivacyKey","privacyKeyAbout":"PrivacyKey","privacyKeyBirthday":"PrivacyKey","inputPrivacyValueAllowContacts":"InputPrivacyRule","inputPrivacyValueAllowAll":"InputPrivacyRule","inputPrivacyValueAllowUsers":"InputPrivacyRule","inputPrivacyValueDisallowContacts":"InputPrivacyRule","inputPrivacyValueDisallowAll":"InputPrivacyRule","inputPrivacyValueDisallowUsers":"InputPrivacyRule","inputPrivacyValueAllowChatParticipants":"InputPrivacyRule","inputPrivacyValueDisallowChatParticipants":"InputPrivacyRule","inputPrivacyValueAllowCloseFriends":"InputPrivacyRule","inputPrivacyValueAllowPremium":"InputPrivacyRule","privacyValueAllowContacts":"PrivacyRule","privacyValueAllowAll":"PrivacyRule","privacyValueAllowUsers":"PrivacyRule","privacyValueDisallowContacts":"PrivacyRule","privacyValueDisallowAll":"PrivacyRule","privacyValueDisallowUsers":"PrivacyRule","privacyValueAllowChatParticipants":"PrivacyRule","privacyValueDisallowChatParticipants":"PrivacyRule","privacyValueAllowCloseFriends":"PrivacyRule","privacyValueAllowPremium":"PrivacyRule","account.privacyRules":"account.PrivacyRules","accountDaysTTL":"AccountDaysTTL","documentAttributeImageSize":"DocumentAttribute","documentAttributeAnimated":"DocumentAttribute","documentAttributeSticker":"DocumentAttribute","documentAttributeVideo":"DocumentAttribute","documentAttributeAudio":"DocumentAttribute","documentAttributeFilename":"DocumentAttribute","documentAttributeHasStickers":"DocumentAttribute","documentAttributeCustomEmoji":"DocumentAttribute","messages.stickersNotModified":"messages.Stickers","messages.stickers":"messages.Stickers","stickerPack":"StickerPack","messages.allStickersNotModified":"messages.AllStickers","messages.allStickers":"messages.AllStickers","messages.affectedMessages":"messages.AffectedMessages","webPageEmpty":"WebPage","webPagePending":"WebPage","webPage":"WebPage","webPageNotModified":"WebPage","authorization":"Authorization","account.authorizations":"account.Authorizations","account.password":"account.Password","account.passwordSettings":"account.PasswordSettings","account.passwordInputSettings":"account.PasswordInputSettings","auth.passwordRecovery":"auth.PasswordRecovery","receivedNotifyMessage":"ReceivedNotifyMessage","chatInviteExported":"ExportedChatInvite","chatInvitePublicJoinRequests":"ExportedChatInvite","chatInviteAlready":"ChatInvite","chatInvite":"ChatInvite","chatInvitePeek":"ChatInvite","inputStickerSetEmpty":"InputStickerSet","inputStickerSetID":"InputStickerSet","inputStickerSetShortName":"InputStickerSet","inputStickerSetAnimatedEmoji":"InputStickerSet","inputStickerSetDice":"InputStickerSet","inputStickerSetAnimatedEmojiAnimations":"InputStickerSet","inputStickerSetPremiumGifts":"InputStickerSet","inputStickerSetEmojiGenericAnimations":"InputStickerSet","inputStickerSetEmojiDefaultStatuses":"InputStickerSet","inputStickerSetEmojiDefaultTopicIcons":"InputStickerSet","inputStickerSetEmojiChannelDefaultStatuses":"InputStickerSet","stickerSet":"StickerSet","messages.stickerSet":"messages.StickerSet","messages.stickerSetNotModified":"messages.StickerSet","botCommand":"BotCommand","botInfo":"BotInfo","keyboardButton":"KeyboardButton","keyboardButtonUrl":"KeyboardButton","keyboardButtonCallback":"KeyboardButton","keyboardButtonRequestPhone":"KeyboardButton","keyboardButtonRequestGeoLocation":"KeyboardButton","keyboardButtonSwitchInline":"KeyboardButton","keyboardButtonGame":"KeyboardButton","keyboardButtonBuy":"KeyboardButton","keyboardButtonUrlAuth":"KeyboardButton","inputKeyboardButtonUrlAuth":"KeyboardButton","keyboardButtonRequestPoll":"KeyboardButton","inputKeyboardButtonUserProfile":"KeyboardButton","keyboardButtonUserProfile":"KeyboardButton","keyboardButtonWebView":"KeyboardButton","keyboardButtonSimpleWebView":"KeyboardButton","keyboardButtonRequestPeer":"KeyboardButton","inputKeyboardButtonRequestPeer":"KeyboardButton","keyboardButtonCopy":"KeyboardButton","keyboardButtonRow":"KeyboardButtonRow","replyKeyboardHide":"ReplyMarkup","replyKeyboardForceReply":"ReplyMarkup","replyKeyboardMarkup":"ReplyMarkup","replyInlineMarkup":"ReplyMarkup","messageEntityUnknown":"MessageEntity","messageEntityMention":"MessageEntity","messageEntityHashtag":"MessageEntity","messageEntityBotCommand":"MessageEntity","messageEntityUrl":"MessageEntity","messageEntityEmail":"MessageEntity","messageEntityBold":"MessageEntity","messageEntityItalic":"MessageEntity","messageEntityCode":"MessageEntity","messageEntityPre":"MessageEntity","messageEntityTextUrl":"MessageEntity","messageEntityMentionName":"MessageEntity","inputMessageEntityMentionName":"MessageEntity","messageEntityPhone":"MessageEntity","messageEntityCashtag":"MessageEntity","messageEntityUnderline":"MessageEntity","messageEntityStrike":"MessageEntity","messageEntityBankCard":"MessageEntity","messageEntitySpoiler":"MessageEntity","messageEntityCustomEmoji":"MessageEntity","messageEntityBlockquote":"MessageEntity","inputChannelEmpty":"InputChannel","inputChannel":"InputChannel","inputChannelFromMessage":"InputChannel","contacts.resolvedPeer":"contacts.ResolvedPeer","messageRange":"MessageRange","updates.channelDifferenceEmpty":"updates.ChannelDifference","updates.channelDifferenceTooLong":"updates.ChannelDifference","updates.channelDifference":"updates.ChannelDifference","channelMessagesFilterEmpty":"ChannelMessagesFilter","channelMessagesFilter":"ChannelMessagesFilter","channelParticipant":"ChannelParticipant","channelParticipantSelf":"ChannelParticipant","channelParticipantCreator":"ChannelParticipant","channelParticipantAdmin":"ChannelParticipant","channelParticipantBanned":"ChannelParticipant","channelParticipantLeft":"ChannelParticipant","channelParticipantsRecent":"ChannelParticipantsFilter","channelParticipantsAdmins":"ChannelParticipantsFilter","channelParticipantsKicked":"ChannelParticipantsFilter","channelParticipantsBots":"ChannelParticipantsFilter","channelParticipantsBanned":"ChannelParticipantsFilter","channelParticipantsSearch":"ChannelParticipantsFilter","channelParticipantsContacts":"ChannelParticipantsFilter","channelParticipantsMentions":"ChannelParticipantsFilter","channels.channelParticipants":"channels.ChannelParticipants","channels.channelParticipantsNotModified":"channels.ChannelParticipants","channels.channelParticipant":"channels.ChannelParticipant","help.termsOfService":"help.TermsOfService","messages.savedGifsNotModified":"messages.SavedGifs","messages.savedGifs":"messages.SavedGifs","inputBotInlineMessageMediaAuto":"InputBotInlineMessage","inputBotInlineMessageText":"InputBotInlineMessage","inputBotInlineMessageMediaGeo":"InputBotInlineMessage","inputBotInlineMessageMediaVenue":"InputBotInlineMessage","inputBotInlineMessageMediaContact":"InputBotInlineMessage","inputBotInlineMessageGame":"InputBotInlineMessage","inputBotInlineMessageMediaInvoice":"InputBotInlineMessage","inputBotInlineMessageMediaWebPage":"InputBotInlineMessage","inputBotInlineResult":"InputBotInlineResult","inputBotInlineResultPhoto":"InputBotInlineResult","inputBotInlineResultDocument":"InputBotInlineResult","inputBotInlineResultGame":"InputBotInlineResult","botInlineMessageMediaAuto":"BotInlineMessage","botInlineMessageText":"BotInlineMessage","botInlineMessageMediaGeo":"BotInlineMessage","botInlineMessageMediaVenue":"BotInlineMessage","botInlineMessageMediaContact":"BotInlineMessage","botInlineMessageMediaInvoice":"BotInlineMessage","botInlineMessageMediaWebPage":"BotInlineMessage","botInlineResult":"BotInlineResult","botInlineMediaResult":"BotInlineResult","messages.botResults":"messages.BotResults","exportedMessageLink":"ExportedMessageLink","messageFwdHeader":"MessageFwdHeader","auth.codeTypeSms":"auth.CodeType","auth.codeTypeCall":"auth.CodeType","auth.codeTypeFlashCall":"auth.CodeType","auth.codeTypeMissedCall":"auth.CodeType","auth.codeTypeFragmentSms":"auth.CodeType","auth.sentCodeTypeApp":"auth.SentCodeType","auth.sentCodeTypeSms":"auth.SentCodeType","auth.sentCodeTypeCall":"auth.SentCodeType","auth.sentCodeTypeFlashCall":"auth.SentCodeType","auth.sentCodeTypeMissedCall":"auth.SentCodeType","auth.sentCodeTypeEmailCode":"auth.SentCodeType","auth.sentCodeTypeSetUpEmailRequired":"auth.SentCodeType","auth.sentCodeTypeFragmentSms":"auth.SentCodeType","auth.sentCodeTypeFirebaseSms":"auth.SentCodeType","auth.sentCodeTypeSmsWord":"auth.SentCodeType","auth.sentCodeTypeSmsPhrase":"auth.SentCodeType","messages.botCallbackAnswer":"messages.BotCallbackAnswer","messages.messageEditData":"messages.MessageEditData","inputBotInlineMessageID":"InputBotInlineMessageID","inputBotInlineMessageID64":"InputBotInlineMessageID","inlineBotSwitchPM":"InlineBotSwitchPM","messages.peerDialogs":"messages.PeerDialogs","topPeer":"TopPeer","topPeerCategoryBotsPM":"TopPeerCategory","topPeerCategoryBotsInline":"TopPeerCategory","topPeerCategoryCorrespondents":"TopPeerCategory","topPeerCategoryGroups":"TopPeerCategory","topPeerCategoryChannels":"TopPeerCategory","topPeerCategoryPhoneCalls":"TopPeerCategory","topPeerCategoryForwardUsers":"TopPeerCategory","topPeerCategoryForwardChats":"TopPeerCategory","topPeerCategoryBotsApp":"TopPeerCategory","topPeerCategoryPeers":"TopPeerCategoryPeers","contacts.topPeersNotModified":"contacts.TopPeers","contacts.topPeers":"contacts.TopPeers","contacts.topPeersDisabled":"contacts.TopPeers","draftMessageEmpty":"DraftMessage","draftMessage":"DraftMessage","messages.featuredStickersNotModified":"messages.FeaturedStickers","messages.featuredStickers":"messages.FeaturedStickers","messages.recentStickersNotModified":"messages.RecentStickers","messages.recentStickers":"messages.RecentStickers","messages.archivedStickers":"messages.ArchivedStickers","messages.stickerSetInstallResultSuccess":"messages.StickerSetInstallResult","messages.stickerSetInstallResultArchive":"messages.StickerSetInstallResult","stickerSetCovered":"StickerSetCovered","stickerSetMultiCovered":"StickerSetCovered","stickerSetFullCovered":"StickerSetCovered","stickerSetNoCovered":"StickerSetCovered","maskCoords":"MaskCoords","inputStickeredMediaPhoto":"InputStickeredMedia","inputStickeredMediaDocument":"InputStickeredMedia","game":"Game","inputGameID":"InputGame","inputGameShortName":"InputGame","highScore":"HighScore","messages.highScores":"messages.HighScores","textEmpty":"RichText","textPlain":"RichText","textBold":"RichText","textItalic":"RichText","textUnderline":"RichText","textStrike":"RichText","textFixed":"RichText","textUrl":"RichText","textEmail":"RichText","textConcat":"RichText","textSubscript":"RichText","textSuperscript":"RichText","textMarked":"RichText","textPhone":"RichText","textImage":"RichText","textAnchor":"RichText","pageBlockUnsupported":"PageBlock","pageBlockTitle":"PageBlock","pageBlockSubtitle":"PageBlock","pageBlockAuthorDate":"PageBlock","pageBlockHeader":"PageBlock","pageBlockSubheader":"PageBlock","pageBlockParagraph":"PageBlock","pageBlockPreformatted":"PageBlock","pageBlockFooter":"PageBlock","pageBlockDivider":"PageBlock","pageBlockAnchor":"PageBlock","pageBlockList":"PageBlock","pageBlockBlockquote":"PageBlock","pageBlockPullquote":"PageBlock","pageBlockPhoto":"PageBlock","pageBlockVideo":"PageBlock","pageBlockCover":"PageBlock","pageBlockEmbed":"PageBlock","pageBlockEmbedPost":"PageBlock","pageBlockCollage":"PageBlock","pageBlockSlideshow":"PageBlock","pageBlockChannel":"PageBlock","pageBlockAudio":"PageBlock","pageBlockKicker":"PageBlock","pageBlockTable":"PageBlock","pageBlockOrderedList":"PageBlock","pageBlockDetails":"PageBlock","pageBlockRelatedArticles":"PageBlock","pageBlockMap":"PageBlock","phoneCallDiscardReasonMissed":"PhoneCallDiscardReason","phoneCallDiscardReasonDisconnect":"PhoneCallDiscardReason","phoneCallDiscardReasonHangup":"PhoneCallDiscardReason","phoneCallDiscardReasonBusy":"PhoneCallDiscardReason","dataJSON":"DataJSON","labeledPrice":"LabeledPrice","invoice":"Invoice","paymentCharge":"PaymentCharge","postAddress":"PostAddress","paymentRequestedInfo":"PaymentRequestedInfo","paymentSavedCredentialsCard":"PaymentSavedCredentials","webDocument":"WebDocument","webDocumentNoProxy":"WebDocument","inputWebDocument":"InputWebDocument","inputWebFileLocation":"InputWebFileLocation","inputWebFileGeoPointLocation":"InputWebFileLocation","inputWebFileAudioAlbumThumbLocation":"InputWebFileLocation","upload.webFile":"upload.WebFile","payments.paymentForm":"payments.PaymentForm","payments.paymentFormStars":"payments.PaymentForm","payments.paymentFormStarGift":"payments.PaymentForm","payments.validatedRequestedInfo":"payments.ValidatedRequestedInfo","payments.paymentResult":"payments.PaymentResult","payments.paymentVerificationNeeded":"payments.PaymentResult","payments.paymentReceipt":"payments.PaymentReceipt","payments.paymentReceiptStars":"payments.PaymentReceipt","payments.savedInfo":"payments.SavedInfo","inputPaymentCredentialsSaved":"InputPaymentCredentials","inputPaymentCredentials":"InputPaymentCredentials","inputPaymentCredentialsApplePay":"InputPaymentCredentials","inputPaymentCredentialsGooglePay":"InputPaymentCredentials","account.tmpPassword":"account.TmpPassword","shippingOption":"ShippingOption","inputStickerSetItem":"InputStickerSetItem","inputPhoneCall":"InputPhoneCall","phoneCallEmpty":"PhoneCall","phoneCallWaiting":"PhoneCall","phoneCallRequested":"PhoneCall","phoneCallAccepted":"PhoneCall","phoneCall":"PhoneCall","phoneCallDiscarded":"PhoneCall","phoneConnection":"PhoneConnection","phoneConnectionWebrtc":"PhoneConnection","phoneCallProtocol":"PhoneCallProtocol","phone.phoneCall":"phone.PhoneCall","upload.cdnFileReuploadNeeded":"upload.CdnFile","upload.cdnFile":"upload.CdnFile","cdnPublicKey":"CdnPublicKey","cdnConfig":"CdnConfig","langPackString":"LangPackString","langPackStringPluralized":"LangPackString","langPackStringDeleted":"LangPackString","langPackDifference":"LangPackDifference","langPackLanguage":"LangPackLanguage","channelAdminLogEventActionChangeTitle":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeAbout":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeUsername":"ChannelAdminLogEventAction","channelAdminLogEventActionChangePhoto":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleInvites":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleSignatures":"ChannelAdminLogEventAction","channelAdminLogEventActionUpdatePinned":"ChannelAdminLogEventAction","channelAdminLogEventActionEditMessage":"ChannelAdminLogEventAction","channelAdminLogEventActionDeleteMessage":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantJoin":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantLeave":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantInvite":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantToggleBan":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantToggleAdmin":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeStickerSet":"ChannelAdminLogEventAction","channelAdminLogEventActionTogglePreHistoryHidden":"ChannelAdminLogEventAction","channelAdminLogEventActionDefaultBannedRights":"ChannelAdminLogEventAction","channelAdminLogEventActionStopPoll":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeLinkedChat":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeLocation":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleSlowMode":"ChannelAdminLogEventAction","channelAdminLogEventActionStartGroupCall":"ChannelAdminLogEventAction","channelAdminLogEventActionDiscardGroupCall":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantMute":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantUnmute":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleGroupCallSetting":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantJoinByInvite":"ChannelAdminLogEventAction","channelAdminLogEventActionExportedInviteDelete":"ChannelAdminLogEventAction","channelAdminLogEventActionExportedInviteRevoke":"ChannelAdminLogEventAction","channelAdminLogEventActionExportedInviteEdit":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantVolume":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeHistoryTTL":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantJoinByRequest":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleNoForwards":"ChannelAdminLogEventAction","channelAdminLogEventActionSendMessage":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeAvailableReactions":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeUsernames":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleForum":"ChannelAdminLogEventAction","channelAdminLogEventActionCreateTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionEditTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionDeleteTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionPinTopic":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleAntiSpam":"ChannelAdminLogEventAction","channelAdminLogEventActionChangePeerColor":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeProfilePeerColor":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeWallpaper":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeEmojiStatus":"ChannelAdminLogEventAction","channelAdminLogEventActionChangeEmojiStickerSet":"ChannelAdminLogEventAction","channelAdminLogEventActionToggleSignatureProfiles":"ChannelAdminLogEventAction","channelAdminLogEventActionParticipantSubExtend":"ChannelAdminLogEventAction","channelAdminLogEvent":"ChannelAdminLogEvent","channels.adminLogResults":"channels.AdminLogResults","channelAdminLogEventsFilter":"ChannelAdminLogEventsFilter","popularContact":"PopularContact","messages.favedStickersNotModified":"messages.FavedStickers","messages.favedStickers":"messages.FavedStickers","recentMeUrlUnknown":"RecentMeUrl","recentMeUrlUser":"RecentMeUrl","recentMeUrlChat":"RecentMeUrl","recentMeUrlChatInvite":"RecentMeUrl","recentMeUrlStickerSet":"RecentMeUrl","help.recentMeUrls":"help.RecentMeUrls","inputSingleMedia":"InputSingleMedia","webAuthorization":"WebAuthorization","account.webAuthorizations":"account.WebAuthorizations","inputMessageID":"InputMessage","inputMessageReplyTo":"InputMessage","inputMessagePinned":"InputMessage","inputMessageCallbackQuery":"InputMessage","inputDialogPeer":"InputDialogPeer","inputDialogPeerFolder":"InputDialogPeer","dialogPeer":"DialogPeer","dialogPeerFolder":"DialogPeer","messages.foundStickerSetsNotModified":"messages.FoundStickerSets","messages.foundStickerSets":"messages.FoundStickerSets","fileHash":"FileHash","inputClientProxy":"InputClientProxy","help.termsOfServiceUpdateEmpty":"help.TermsOfServiceUpdate","help.termsOfServiceUpdate":"help.TermsOfServiceUpdate","inputSecureFileUploaded":"InputSecureFile","inputSecureFile":"InputSecureFile","secureFileEmpty":"SecureFile","secureFile":"SecureFile","secureData":"SecureData","securePlainPhone":"SecurePlainData","securePlainEmail":"SecurePlainData","secureValueTypePersonalDetails":"SecureValueType","secureValueTypePassport":"SecureValueType","secureValueTypeDriverLicense":"SecureValueType","secureValueTypeIdentityCard":"SecureValueType","secureValueTypeInternalPassport":"SecureValueType","secureValueTypeAddress":"SecureValueType","secureValueTypeUtilityBill":"SecureValueType","secureValueTypeBankStatement":"SecureValueType","secureValueTypeRentalAgreement":"SecureValueType","secureValueTypePassportRegistration":"SecureValueType","secureValueTypeTemporaryRegistration":"SecureValueType","secureValueTypePhone":"SecureValueType","secureValueTypeEmail":"SecureValueType","secureValue":"SecureValue","inputSecureValue":"InputSecureValue","secureValueHash":"SecureValueHash","secureValueErrorData":"SecureValueError","secureValueErrorFrontSide":"SecureValueError","secureValueErrorReverseSide":"SecureValueError","secureValueErrorSelfie":"SecureValueError","secureValueErrorFile":"SecureValueError","secureValueErrorFiles":"SecureValueError","secureValueError":"SecureValueError","secureValueErrorTranslationFile":"SecureValueError","secureValueErrorTranslationFiles":"SecureValueError","secureCredentialsEncrypted":"SecureCredentialsEncrypted","account.authorizationForm":"account.AuthorizationForm","account.sentEmailCode":"account.SentEmailCode","help.deepLinkInfoEmpty":"help.DeepLinkInfo","help.deepLinkInfo":"help.DeepLinkInfo","savedPhoneContact":"SavedContact","account.takeout":"account.Takeout","passwordKdfAlgoUnknown":"PasswordKdfAlgo","passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow":"PasswordKdfAlgo","securePasswordKdfAlgoUnknown":"SecurePasswordKdfAlgo","securePasswordKdfAlgoPBKDF2HMACSHA512iter100000":"SecurePasswordKdfAlgo","securePasswordKdfAlgoSHA512":"SecurePasswordKdfAlgo","secureSecretSettings":"SecureSecretSettings","inputCheckPasswordEmpty":"InputCheckPasswordSRP","inputCheckPasswordSRP":"InputCheckPasswordSRP","secureRequiredType":"SecureRequiredType","secureRequiredTypeOneOf":"SecureRequiredType","help.passportConfigNotModified":"help.PassportConfig","help.passportConfig":"help.PassportConfig","inputAppEvent":"InputAppEvent","jsonObjectValue":"JSONObjectValue","jsonNull":"JSONValue","jsonBool":"JSONValue","jsonNumber":"JSONValue","jsonString":"JSONValue","jsonArray":"JSONValue","jsonObject":"JSONValue","pageTableCell":"PageTableCell","pageTableRow":"PageTableRow","pageCaption":"PageCaption","pageListItemText":"PageListItem","pageListItemBlocks":"PageListItem","pageListOrderedItemText":"PageListOrderedItem","pageListOrderedItemBlocks":"PageListOrderedItem","pageRelatedArticle":"PageRelatedArticle","page":"Page","help.supportName":"help.SupportName","help.userInfoEmpty":"help.UserInfo","help.userInfo":"help.UserInfo","pollAnswer":"PollAnswer","poll":"Poll","pollAnswerVoters":"PollAnswerVoters","pollResults":"PollResults","chatOnlines":"ChatOnlines","statsURL":"StatsURL","chatAdminRights":"ChatAdminRights","chatBannedRights":"ChatBannedRights","inputWallPaper":"InputWallPaper","inputWallPaperSlug":"InputWallPaper","inputWallPaperNoFile":"InputWallPaper","account.wallPapersNotModified":"account.WallPapers","account.wallPapers":"account.WallPapers","codeSettings":"CodeSettings","wallPaperSettings":"WallPaperSettings","autoDownloadSettings":"AutoDownloadSettings","account.autoDownloadSettings":"account.AutoDownloadSettings","emojiKeyword":"EmojiKeyword","emojiKeywordDeleted":"EmojiKeyword","emojiKeywordsDifference":"EmojiKeywordsDifference","emojiURL":"EmojiURL","emojiLanguage":"EmojiLanguage","folder":"Folder","inputFolderPeer":"InputFolderPeer","folderPeer":"FolderPeer","messages.searchCounter":"messages.SearchCounter","urlAuthResultRequest":"UrlAuthResult","urlAuthResultAccepted":"UrlAuthResult","urlAuthResultDefault":"UrlAuthResult","channelLocationEmpty":"ChannelLocation","channelLocation":"ChannelLocation","peerLocated":"PeerLocated","peerSelfLocated":"PeerLocated","restrictionReason":"RestrictionReason","inputTheme":"InputTheme","inputThemeSlug":"InputTheme","theme":"Theme","account.themesNotModified":"account.Themes","account.themes":"account.Themes","auth.loginToken":"auth.LoginToken","auth.loginTokenMigrateTo":"auth.LoginToken","auth.loginTokenSuccess":"auth.LoginToken","account.contentSettings":"account.ContentSettings","messages.inactiveChats":"messages.InactiveChats","baseThemeClassic":"BaseTheme","baseThemeDay":"BaseTheme","baseThemeNight":"BaseTheme","baseThemeTinted":"BaseTheme","baseThemeArctic":"BaseTheme","inputThemeSettings":"InputThemeSettings","themeSettings":"ThemeSettings","webPageAttributeTheme":"WebPageAttribute","webPageAttributeStory":"WebPageAttribute","webPageAttributeStickerSet":"WebPageAttribute","messages.votesList":"messages.VotesList","bankCardOpenUrl":"BankCardOpenUrl","payments.bankCardData":"payments.BankCardData","dialogFilter":"DialogFilter","dialogFilterDefault":"DialogFilter","dialogFilterChatlist":"DialogFilter","dialogFilterSuggested":"DialogFilterSuggested","statsDateRangeDays":"StatsDateRangeDays","statsAbsValueAndPrev":"StatsAbsValueAndPrev","statsPercentValue":"StatsPercentValue","statsGraphAsync":"StatsGraph","statsGraphError":"StatsGraph","statsGraph":"StatsGraph","stats.broadcastStats":"stats.BroadcastStats","help.promoDataEmpty":"help.PromoData","help.promoData":"help.PromoData","videoSize":"VideoSize","videoSizeEmojiMarkup":"VideoSize","videoSizeStickerMarkup":"VideoSize","statsGroupTopPoster":"StatsGroupTopPoster","statsGroupTopAdmin":"StatsGroupTopAdmin","statsGroupTopInviter":"StatsGroupTopInviter","stats.megagroupStats":"stats.MegagroupStats","globalPrivacySettings":"GlobalPrivacySettings","help.countryCode":"help.CountryCode","help.country":"help.Country","help.countriesListNotModified":"help.CountriesList","help.countriesList":"help.CountriesList","messageViews":"MessageViews","messages.messageViews":"messages.MessageViews","messages.discussionMessage":"messages.DiscussionMessage","messageReplyHeader":"MessageReplyHeader","messageReplyStoryHeader":"MessageReplyHeader","messageReplies":"MessageReplies","peerBlocked":"PeerBlocked","stats.messageStats":"stats.MessageStats","groupCallDiscarded":"GroupCall","groupCall":"GroupCall","inputGroupCall":"InputGroupCall","groupCallParticipant":"GroupCallParticipant","phone.groupCall":"phone.GroupCall","phone.groupParticipants":"phone.GroupParticipants","inlineQueryPeerTypeSameBotPM":"InlineQueryPeerType","inlineQueryPeerTypePM":"InlineQueryPeerType","inlineQueryPeerTypeChat":"InlineQueryPeerType","inlineQueryPeerTypeMegagroup":"InlineQueryPeerType","inlineQueryPeerTypeBroadcast":"InlineQueryPeerType","inlineQueryPeerTypeBotPM":"InlineQueryPeerType","messages.historyImport":"messages.HistoryImport","messages.historyImportParsed":"messages.HistoryImportParsed","messages.affectedFoundMessages":"messages.AffectedFoundMessages","chatInviteImporter":"ChatInviteImporter","messages.exportedChatInvites":"messages.ExportedChatInvites","messages.exportedChatInvite":"messages.ExportedChatInvite","messages.exportedChatInviteReplaced":"messages.ExportedChatInvite","messages.chatInviteImporters":"messages.ChatInviteImporters","chatAdminWithInvites":"ChatAdminWithInvites","messages.chatAdminsWithInvites":"messages.ChatAdminsWithInvites","messages.checkedHistoryImportPeer":"messages.CheckedHistoryImportPeer","phone.joinAsPeers":"phone.JoinAsPeers","phone.exportedGroupCallInvite":"phone.ExportedGroupCallInvite","groupCallParticipantVideoSourceGroup":"GroupCallParticipantVideoSourceGroup","groupCallParticipantVideo":"GroupCallParticipantVideo","stickers.suggestedShortName":"stickers.SuggestedShortName","botCommandScopeDefault":"BotCommandScope","botCommandScopeUsers":"BotCommandScope","botCommandScopeChats":"BotCommandScope","botCommandScopeChatAdmins":"BotCommandScope","botCommandScopePeer":"BotCommandScope","botCommandScopePeerAdmins":"BotCommandScope","botCommandScopePeerUser":"BotCommandScope","account.resetPasswordFailedWait":"account.ResetPasswordResult","account.resetPasswordRequestedWait":"account.ResetPasswordResult","account.resetPasswordOk":"account.ResetPasswordResult","sponsoredMessage":"SponsoredMessage","messages.sponsoredMessages":"messages.SponsoredMessages","messages.sponsoredMessagesEmpty":"messages.SponsoredMessages","searchResultsCalendarPeriod":"SearchResultsCalendarPeriod","messages.searchResultsCalendar":"messages.SearchResultsCalendar","searchResultPosition":"SearchResultsPosition","messages.searchResultsPositions":"messages.SearchResultsPositions","channels.sendAsPeers":"channels.SendAsPeers","users.userFull":"users.UserFull","messages.peerSettings":"messages.PeerSettings","auth.loggedOut":"auth.LoggedOut","reactionCount":"ReactionCount","messageReactions":"MessageReactions","messages.messageReactionsList":"messages.MessageReactionsList","availableReaction":"AvailableReaction","messages.availableReactionsNotModified":"messages.AvailableReactions","messages.availableReactions":"messages.AvailableReactions","messagePeerReaction":"MessagePeerReaction","groupCallStreamChannel":"GroupCallStreamChannel","phone.groupCallStreamChannels":"phone.GroupCallStreamChannels","phone.groupCallStreamRtmpUrl":"phone.GroupCallStreamRtmpUrl","attachMenuBotIconColor":"AttachMenuBotIconColor","attachMenuBotIcon":"AttachMenuBotIcon","attachMenuBot":"AttachMenuBot","attachMenuBotsNotModified":"AttachMenuBots","attachMenuBots":"AttachMenuBots","attachMenuBotsBot":"AttachMenuBotsBot","webViewResultUrl":"WebViewResult","webViewMessageSent":"WebViewMessageSent","botMenuButtonDefault":"BotMenuButton","botMenuButtonCommands":"BotMenuButton","botMenuButton":"BotMenuButton","account.savedRingtonesNotModified":"account.SavedRingtones","account.savedRingtones":"account.SavedRingtones","notificationSoundDefault":"NotificationSound","notificationSoundNone":"NotificationSound","notificationSoundLocal":"NotificationSound","notificationSoundRingtone":"NotificationSound","account.savedRingtone":"account.SavedRingtone","account.savedRingtoneConverted":"account.SavedRingtone","attachMenuPeerTypeSameBotPM":"AttachMenuPeerType","attachMenuPeerTypeBotPM":"AttachMenuPeerType","attachMenuPeerTypePM":"AttachMenuPeerType","attachMenuPeerTypeChat":"AttachMenuPeerType","attachMenuPeerTypeBroadcast":"AttachMenuPeerType","inputInvoiceMessage":"InputInvoice","inputInvoiceSlug":"InputInvoice","inputInvoicePremiumGiftCode":"InputInvoice","inputInvoiceStars":"InputInvoice","inputInvoiceChatInviteSubscription":"InputInvoice","inputInvoiceStarGift":"InputInvoice","payments.exportedInvoice":"payments.ExportedInvoice","messages.transcribedAudio":"messages.TranscribedAudio","help.premiumPromo":"help.PremiumPromo","inputStorePaymentPremiumSubscription":"InputStorePaymentPurpose","inputStorePaymentGiftPremium":"InputStorePaymentPurpose","inputStorePaymentPremiumGiftCode":"InputStorePaymentPurpose","inputStorePaymentPremiumGiveaway":"InputStorePaymentPurpose","inputStorePaymentStarsTopup":"InputStorePaymentPurpose","inputStorePaymentStarsGift":"InputStorePaymentPurpose","inputStorePaymentStarsGiveaway":"InputStorePaymentPurpose","premiumGiftOption":"PremiumGiftOption","paymentFormMethod":"PaymentFormMethod","emojiStatusEmpty":"EmojiStatus","emojiStatus":"EmojiStatus","emojiStatusUntil":"EmojiStatus","account.emojiStatusesNotModified":"account.EmojiStatuses","account.emojiStatuses":"account.EmojiStatuses","reactionEmpty":"Reaction","reactionEmoji":"Reaction","reactionCustomEmoji":"Reaction","reactionPaid":"Reaction","chatReactionsNone":"ChatReactions","chatReactionsAll":"ChatReactions","chatReactionsSome":"ChatReactions","messages.reactionsNotModified":"messages.Reactions","messages.reactions":"messages.Reactions","emailVerifyPurposeLoginSetup":"EmailVerifyPurpose","emailVerifyPurposeLoginChange":"EmailVerifyPurpose","emailVerifyPurposePassport":"EmailVerifyPurpose","emailVerificationCode":"EmailVerification","emailVerificationGoogle":"EmailVerification","emailVerificationApple":"EmailVerification","account.emailVerified":"account.EmailVerified","account.emailVerifiedLogin":"account.EmailVerified","premiumSubscriptionOption":"PremiumSubscriptionOption","sendAsPeer":"SendAsPeer","messageExtendedMediaPreview":"MessageExtendedMedia","messageExtendedMedia":"MessageExtendedMedia","stickerKeyword":"StickerKeyword","username":"Username","forumTopicDeleted":"ForumTopic","forumTopic":"ForumTopic","messages.forumTopics":"messages.ForumTopics","defaultHistoryTTL":"DefaultHistoryTTL","exportedContactToken":"ExportedContactToken","requestPeerTypeUser":"RequestPeerType","requestPeerTypeChat":"RequestPeerType","requestPeerTypeBroadcast":"RequestPeerType","emojiListNotModified":"EmojiList","emojiList":"EmojiList","emojiGroup":"EmojiGroup","emojiGroupGreeting":"EmojiGroup","emojiGroupPremium":"EmojiGroup","messages.emojiGroupsNotModified":"messages.EmojiGroups","messages.emojiGroups":"messages.EmojiGroups","textWithEntities":"TextWithEntities","messages.translateResult":"messages.TranslatedText","autoSaveSettings":"AutoSaveSettings","autoSaveException":"AutoSaveException","account.autoSaveSettings":"account.AutoSaveSettings","help.appConfigNotModified":"help.AppConfig","help.appConfig":"help.AppConfig","inputBotAppID":"InputBotApp","inputBotAppShortName":"InputBotApp","botAppNotModified":"BotApp","botApp":"BotApp","messages.botApp":"messages.BotApp","inlineBotWebView":"InlineBotWebView","readParticipantDate":"ReadParticipantDate","inputChatlistDialogFilter":"InputChatlist","exportedChatlistInvite":"ExportedChatlistInvite","chatlists.exportedChatlistInvite":"chatlists.ExportedChatlistInvite","chatlists.exportedInvites":"chatlists.ExportedInvites","chatlists.chatlistInviteAlready":"chatlists.ChatlistInvite","chatlists.chatlistInvite":"chatlists.ChatlistInvite","chatlists.chatlistUpdates":"chatlists.ChatlistUpdates","bots.botInfo":"bots.BotInfo","messagePeerVote":"MessagePeerVote","messagePeerVoteInputOption":"MessagePeerVote","messagePeerVoteMultiple":"MessagePeerVote","storyViews":"StoryViews","storyItemDeleted":"StoryItem","storyItemSkipped":"StoryItem","storyItem":"StoryItem","stories.allStoriesNotModified":"stories.AllStories","stories.allStories":"stories.AllStories","stories.stories":"stories.Stories","storyView":"StoryView","storyViewPublicForward":"StoryView","storyViewPublicRepost":"StoryView","stories.storyViewsList":"stories.StoryViewsList","stories.storyViews":"stories.StoryViews","inputReplyToMessage":"InputReplyTo","inputReplyToStory":"InputReplyTo","exportedStoryLink":"ExportedStoryLink","storiesStealthMode":"StoriesStealthMode","mediaAreaCoordinates":"MediaAreaCoordinates","mediaAreaVenue":"MediaArea","inputMediaAreaVenue":"MediaArea","mediaAreaGeoPoint":"MediaArea","mediaAreaSuggestedReaction":"MediaArea","mediaAreaChannelPost":"MediaArea","inputMediaAreaChannelPost":"MediaArea","mediaAreaUrl":"MediaArea","mediaAreaWeather":"MediaArea","peerStories":"PeerStories","stories.peerStories":"stories.PeerStories","messages.webPage":"messages.WebPage","premiumGiftCodeOption":"PremiumGiftCodeOption","payments.checkedGiftCode":"payments.CheckedGiftCode","payments.giveawayInfo":"payments.GiveawayInfo","payments.giveawayInfoResults":"payments.GiveawayInfo","prepaidGiveaway":"PrepaidGiveaway","prepaidStarsGiveaway":"PrepaidGiveaway","boost":"Boost","premium.boostsList":"premium.BoostsList","myBoost":"MyBoost","premium.myBoosts":"premium.MyBoosts","premium.boostsStatus":"premium.BoostsStatus","storyFwdHeader":"StoryFwdHeader","postInteractionCountersMessage":"PostInteractionCounters","postInteractionCountersStory":"PostInteractionCounters","stats.storyStats":"stats.StoryStats","publicForwardMessage":"PublicForward","publicForwardStory":"PublicForward","stats.publicForwards":"stats.PublicForwards","peerColor":"PeerColor","help.peerColorSet":"help.PeerColorSet","help.peerColorProfileSet":"help.PeerColorSet","help.peerColorOption":"help.PeerColorOption","help.peerColorsNotModified":"help.PeerColors","help.peerColors":"help.PeerColors","storyReaction":"StoryReaction","storyReactionPublicForward":"StoryReaction","storyReactionPublicRepost":"StoryReaction","stories.storyReactionsList":"stories.StoryReactionsList","savedDialog":"SavedDialog","messages.savedDialogs":"messages.SavedDialogs","messages.savedDialogsSlice":"messages.SavedDialogs","messages.savedDialogsNotModified":"messages.SavedDialogs","savedReactionTag":"SavedReactionTag","messages.savedReactionTagsNotModified":"messages.SavedReactionTags","messages.savedReactionTags":"messages.SavedReactionTags","outboxReadDate":"OutboxReadDate","smsjobs.eligibleToJoin":"smsjobs.EligibilityToJoin","smsjobs.status":"smsjobs.Status","smsJob":"SmsJob","businessWeeklyOpen":"BusinessWeeklyOpen","businessWorkHours":"BusinessWorkHours","businessLocation":"BusinessLocation","inputBusinessRecipients":"InputBusinessRecipients","businessRecipients":"BusinessRecipients","businessAwayMessageScheduleAlways":"BusinessAwayMessageSchedule","businessAwayMessageScheduleOutsideWorkHours":"BusinessAwayMessageSchedule","businessAwayMessageScheduleCustom":"BusinessAwayMessageSchedule","inputBusinessGreetingMessage":"InputBusinessGreetingMessage","businessGreetingMessage":"BusinessGreetingMessage","inputBusinessAwayMessage":"InputBusinessAwayMessage","businessAwayMessage":"BusinessAwayMessage","timezone":"Timezone","help.timezonesListNotModified":"help.TimezonesList","help.timezonesList":"help.TimezonesList","quickReply":"QuickReply","inputQuickReplyShortcut":"InputQuickReplyShortcut","inputQuickReplyShortcutId":"InputQuickReplyShortcut","messages.quickReplies":"messages.QuickReplies","messages.quickRepliesNotModified":"messages.QuickReplies","connectedBot":"ConnectedBot","account.connectedBots":"account.ConnectedBots","messages.dialogFilters":"messages.DialogFilters","birthday":"Birthday","botBusinessConnection":"BotBusinessConnection","inputBusinessIntro":"InputBusinessIntro","businessIntro":"BusinessIntro","messages.myStickers":"messages.MyStickers","inputCollectibleUsername":"InputCollectible","inputCollectiblePhone":"InputCollectible","fragment.collectibleInfo":"fragment.CollectibleInfo","inputBusinessBotRecipients":"InputBusinessBotRecipients","businessBotRecipients":"BusinessBotRecipients","contactBirthday":"ContactBirthday","contacts.contactBirthdays":"contacts.ContactBirthdays","missingInvitee":"MissingInvitee","messages.invitedUsers":"messages.InvitedUsers","inputBusinessChatLink":"InputBusinessChatLink","businessChatLink":"BusinessChatLink","account.businessChatLinks":"account.BusinessChatLinks","account.resolvedBusinessChatLinks":"account.ResolvedBusinessChatLinks","requestedPeerUser":"RequestedPeer","requestedPeerChat":"RequestedPeer","requestedPeerChannel":"RequestedPeer","sponsoredMessageReportOption":"SponsoredMessageReportOption","channels.sponsoredMessageReportResultChooseOption":"channels.SponsoredMessageReportResult","channels.sponsoredMessageReportResultAdsHidden":"channels.SponsoredMessageReportResult","channels.sponsoredMessageReportResultReported":"channels.SponsoredMessageReportResult","stats.broadcastRevenueStats":"stats.BroadcastRevenueStats","stats.broadcastRevenueWithdrawalUrl":"stats.BroadcastRevenueWithdrawalUrl","broadcastRevenueTransactionProceeds":"BroadcastRevenueTransaction","broadcastRevenueTransactionWithdrawal":"BroadcastRevenueTransaction","broadcastRevenueTransactionRefund":"BroadcastRevenueTransaction","stats.broadcastRevenueTransactions":"stats.BroadcastRevenueTransactions","reactionNotificationsFromContacts":"ReactionNotificationsFrom","reactionNotificationsFromAll":"ReactionNotificationsFrom","reactionsNotifySettings":"ReactionsNotifySettings","broadcastRevenueBalances":"BroadcastRevenueBalances","availableEffect":"AvailableEffect","messages.availableEffectsNotModified":"messages.AvailableEffects","messages.availableEffects":"messages.AvailableEffects","factCheck":"FactCheck","starsTransactionPeerUnsupported":"StarsTransactionPeer","starsTransactionPeerAppStore":"StarsTransactionPeer","starsTransactionPeerPlayMarket":"StarsTransactionPeer","starsTransactionPeerPremiumBot":"StarsTransactionPeer","starsTransactionPeerFragment":"StarsTransactionPeer","starsTransactionPeer":"StarsTransactionPeer","starsTransactionPeerAds":"StarsTransactionPeer","starsTopupOption":"StarsTopupOption","starsTransaction":"StarsTransaction","payments.starsStatus":"payments.StarsStatus","foundStory":"FoundStory","stories.foundStories":"stories.FoundStories","geoPointAddress":"GeoPointAddress","starsRevenueStatus":"StarsRevenueStatus","payments.starsRevenueStats":"payments.StarsRevenueStats","payments.starsRevenueWithdrawalUrl":"payments.StarsRevenueWithdrawalUrl","payments.starsRevenueAdsAccountUrl":"payments.StarsRevenueAdsAccountUrl","inputStarsTransaction":"InputStarsTransaction","starsGiftOption":"StarsGiftOption","bots.popularAppBots":"bots.PopularAppBots","botPreviewMedia":"BotPreviewMedia","bots.previewInfo":"bots.PreviewInfo","starsSubscriptionPricing":"StarsSubscriptionPricing","starsSubscription":"StarsSubscription","messageReactor":"MessageReactor","starsGiveawayOption":"StarsGiveawayOption","starsGiveawayWinnersOption":"StarsGiveawayWinnersOption","starGift":"StarGift","payments.starGiftsNotModified":"payments.StarGifts","payments.starGifts":"payments.StarGifts","userStarGift":"UserStarGift","payments.userStarGifts":"payments.UserStarGifts","messageReportOption":"MessageReportOption","reportResultChooseOption":"ReportResult","reportResultAddComment":"ReportResult","reportResultReported":"ReportResult","mtcute.dummyUpdate":"Update","mtcute.dummyInputPeerMinUser":"InputPeer","mtcute.dummyInputPeerMinChannel":"InputPeer"}');
    })(exports.tl);
    exports.mtp = {};
    (function(ns) {
      var _types = void 0;
      function _isAny(type) {
        return function(obj) {
          return typeof obj === "object" && obj && _types[obj._] == type;
        };
      }
      ns.$extendTypes = function(types) {
        for (var i in types) {
          types.hasOwnProperty(i) && (_types[i] = types[i]);
        }
      };
      ns.LAYER = 0;
      ns.isAnyResPQ = _isAny("ResPQ");
      ns.isAnyP_Q_inner_data = _isAny("P_Q_inner_data");
      ns.isAnyServer_DH_Params = _isAny("Server_DH_Params");
      ns.isAnyServer_DH_inner_data = _isAny("Server_DH_inner_data");
      ns.isAnyClient_DH_Inner_Data = _isAny("Client_DH_Inner_Data");
      ns.isAnySet_client_DH_params_answer = _isAny("Set_client_DH_params_answer");
      ns.isAnyBindAuthKeyInner = _isAny("BindAuthKeyInner");
      ns.isAnyRpcError = _isAny("RpcError");
      ns.isAnyRpcDropAnswer = _isAny("RpcDropAnswer");
      ns.isAnyFutureSalt = _isAny("FutureSalt");
      ns.isAnyFutureSalts = _isAny("FutureSalts");
      ns.isAnyPong = _isAny("Pong");
      ns.isAnyDestroySessionRes = _isAny("DestroySessionRes");
      ns.isAnyNewSession = _isAny("NewSession");
      ns.isAnyMsgsAck = _isAny("MsgsAck");
      ns.isAnyBadMsgNotification = _isAny("BadMsgNotification");
      ns.isAnyMsgResendReq = _isAny("MsgResendReq");
      ns.isAnyMsgsStateReq = _isAny("MsgsStateReq");
      ns.isAnyMsgsStateInfo = _isAny("MsgsStateInfo");
      ns.isAnyMsgsAllInfo = _isAny("MsgsAllInfo");
      ns.isAnyMsgDetailedInfo = _isAny("MsgDetailedInfo");
      ns.isAnyDestroyAuthKeyRes = _isAny("DestroyAuthKeyRes");
      ns.isAnyHttpWait = _isAny("HttpWait");
      _types = JSON.parse('{"mt_resPQ":"ResPQ","mt_p_q_inner_data_dc":"P_Q_inner_data","mt_p_q_inner_data_temp_dc":"P_Q_inner_data","mt_server_DH_params_ok":"Server_DH_Params","mt_server_DH_inner_data":"Server_DH_inner_data","mt_client_DH_inner_data":"Client_DH_Inner_Data","mt_dh_gen_ok":"Set_client_DH_params_answer","mt_dh_gen_retry":"Set_client_DH_params_answer","mt_dh_gen_fail":"Set_client_DH_params_answer","mt_bind_auth_key_inner":"BindAuthKeyInner","mt_rpc_error":"RpcError","mt_rpc_answer_unknown":"RpcDropAnswer","mt_rpc_answer_dropped_running":"RpcDropAnswer","mt_rpc_answer_dropped":"RpcDropAnswer","mt_future_salt":"FutureSalt","mt_future_salts":"FutureSalts","mt_pong":"Pong","mt_destroy_session_ok":"DestroySessionRes","mt_destroy_session_none":"DestroySessionRes","mt_new_session_created":"NewSession","mt_msgs_ack":"MsgsAck","mt_bad_msg_notification":"BadMsgNotification","mt_bad_server_salt":"BadMsgNotification","mt_msg_resend_req":"MsgResendReq","mt_msgs_state_req":"MsgsStateReq","mt_msgs_state_info":"MsgsStateInfo","mt_msgs_all_info":"MsgsAllInfo","mt_msg_detailed_info":"MsgDetailedInfo","mt_msg_new_detailed_info":"MsgDetailedInfo","mt_destroy_auth_key_ok":"DestroyAuthKeyRes","mt_destroy_auth_key_none":"DestroyAuthKeyRes","mt_destroy_auth_key_fail":"DestroyAuthKeyRes","mt_http_wait":"HttpWait","mt_req_pq_multi":"ResPQ","mt_req_DH_params":"Server_DH_Params","mt_set_client_DH_params":"Set_client_DH_params_answer","mt_rpc_drop_answer":"RpcDropAnswer","mt_get_future_salts":"FutureSalts","mt_ping":"Pong","mt_ping_delay_disconnect":"Pong","mt_destroy_session":"DestroySessionRes","mt_destroy_auth_key":"DestroyAuthKeyRes"}');
    })(exports.mtp);
  })(tl);
  var reader = {};
  Object.defineProperty(reader, "__esModule", { value: true });
  var m$1 = {
    3300522427: function(r) {
      return { _: "error", code: r.int(), text: r.string() };
    },
    3560156531: function(r) {
      return { _: "ipPort", ipv4: r.int(), port: r.int() };
    },
    932718150: function(r) {
      return { _: "ipPortSecret", ipv4: r.int(), port: r.int(), secret: r.bytes() };
    },
    1182381663: function(r) {
      return { _: "accessPointRule", phonePrefixRules: r.string(), dcId: r.int(), ips: r.vector(r.object, 1) };
    },
    1515793004: function(r) {
      return { _: "help.configSimple", date: r.int(), expires: r.int(), rules: r.vector(r.object, 1) };
    },
    668375447: function(r) {
      var flags = r.uint();
      return { _: "inputPeerPhotoFileLocationLegacy", big: !!(flags & 1), peer: r.object(), volumeId: r.long(), localId: r.int() };
    },
    230353641: function(r) {
      return { _: "inputStickerSetThumbLegacy", stickerset: r.object(), volumeId: r.long(), localId: r.int() };
    },
    2134579434: function(r) {
      return { _: "inputPeerEmpty" };
    },
    2107670217: function(r) {
      return { _: "inputPeerSelf" };
    },
    900291769: function(r) {
      return { _: "inputPeerChat", chatId: r.int53() };
    },
    3723011404: function(r) {
      return { _: "inputPeerUser", userId: r.int53(), accessHash: r.long() };
    },
    666680316: function(r) {
      return { _: "inputPeerChannel", channelId: r.int53(), accessHash: r.long() };
    },
    2826635804: function(r) {
      return { _: "inputPeerUserFromMessage", peer: r.object(), msgId: r.int(), userId: r.int53() };
    },
    3173648448: function(r) {
      return { _: "inputPeerChannelFromMessage", peer: r.object(), msgId: r.int(), channelId: r.int53() };
    },
    3112732367: function(r) {
      return { _: "inputUserEmpty" };
    },
    4156666175: function(r) {
      return { _: "inputUserSelf" };
    },
    4061223110: function(r) {
      return { _: "inputUser", userId: r.int53(), accessHash: r.long() };
    },
    497305826: function(r) {
      return { _: "inputUserFromMessage", peer: r.object(), msgId: r.int(), userId: r.int53() };
    },
    4086478836: function(r) {
      return { _: "inputPhoneContact", clientId: r.long(), phone: r.string(), firstName: r.string(), lastName: r.string() };
    },
    4113560191: function(r) {
      return { _: "inputFile", id: r.long(), parts: r.int(), name: r.string(), md5Checksum: r.string() };
    },
    4199484341: function(r) {
      return { _: "inputFileBig", id: r.long(), parts: r.int(), name: r.string() };
    },
    1658620744: function(r) {
      return { _: "inputFileStoryDocument", id: r.object() };
    },
    2523198847: function(r) {
      return { _: "inputMediaEmpty" };
    },
    505969924: function(r) {
      var flags = r.uint();
      return { _: "inputMediaUploadedPhoto", spoiler: !!(flags & 4), file: r.object(), stickers: flags & 1 ? r.vector(r.object) : void 0, ttlSeconds: flags & 2 ? r.int() : void 0 };
    },
    3015312949: function(r) {
      var flags = r.uint();
      return { _: "inputMediaPhoto", spoiler: !!(flags & 2), id: r.object(), ttlSeconds: flags & 1 ? r.int() : void 0 };
    },
    4190388548: function(r) {
      return { _: "inputMediaGeoPoint", geoPoint: r.object() };
    },
    4171988475: function(r) {
      return { _: "inputMediaContact", phoneNumber: r.string(), firstName: r.string(), lastName: r.string(), vcard: r.string() };
    },
    1530447553: function(r) {
      var flags = r.uint();
      return { _: "inputMediaUploadedDocument", nosoundVideo: !!(flags & 8), forceFile: !!(flags & 16), spoiler: !!(flags & 32), file: r.object(), thumb: flags & 4 ? r.object() : void 0, mimeType: r.string(), attributes: r.vector(r.object), stickers: flags & 1 ? r.vector(r.object) : void 0, ttlSeconds: flags & 2 ? r.int() : void 0 };
    },
    860303448: function(r) {
      var flags = r.uint();
      return { _: "inputMediaDocument", spoiler: !!(flags & 4), id: r.object(), ttlSeconds: flags & 1 ? r.int() : void 0, query: flags & 2 ? r.string() : void 0 };
    },
    3242007569: function(r) {
      return { _: "inputMediaVenue", geoPoint: r.object(), title: r.string(), address: r.string(), provider: r.string(), venueId: r.string(), venueType: r.string() };
    },
    3854302746: function(r) {
      var flags = r.uint();
      return { _: "inputMediaPhotoExternal", spoiler: !!(flags & 2), url: r.string(), ttlSeconds: flags & 1 ? r.int() : void 0 };
    },
    4216511641: function(r) {
      var flags = r.uint();
      return { _: "inputMediaDocumentExternal", spoiler: !!(flags & 2), url: r.string(), ttlSeconds: flags & 1 ? r.int() : void 0 };
    },
    3544138739: function(r) {
      return { _: "inputMediaGame", id: r.object() };
    },
    1080028941: function(r) {
      var flags = r.uint();
      return { _: "inputMediaInvoice", title: r.string(), description: r.string(), photo: flags & 1 ? r.object() : void 0, invoice: r.object(), payload: r.bytes(), provider: flags & 8 ? r.string() : void 0, providerData: r.object(), startParam: flags & 2 ? r.string() : void 0, extendedMedia: flags & 4 ? r.object() : void 0 };
    },
    2535434307: function(r) {
      var flags = r.uint();
      return { _: "inputMediaGeoLive", stopped: !!(flags & 1), geoPoint: r.object(), heading: flags & 4 ? r.int() : void 0, period: flags & 2 ? r.int() : void 0, proximityNotificationRadius: flags & 8 ? r.int() : void 0 };
    },
    261416433: function(r) {
      var flags = r.uint();
      return { _: "inputMediaPoll", poll: r.object(), correctAnswers: flags & 1 ? r.vector(r.bytes) : void 0, solution: flags & 2 ? r.string() : void 0, solutionEntities: flags & 2 ? r.vector(r.object) : void 0 };
    },
    3866083195: function(r) {
      return { _: "inputMediaDice", emoticon: r.string() };
    },
    2315114360: function(r) {
      return { _: "inputMediaStory", peer: r.object(), id: r.int() };
    },
    3256584265: function(r) {
      var flags = r.uint();
      return { _: "inputMediaWebPage", forceLargeMedia: !!(flags & 1), forceSmallMedia: !!(flags & 2), optional: !!(flags & 4), url: r.string() };
    },
    3289396102: function(r) {
      var flags = r.uint();
      return { _: "inputMediaPaidMedia", starsAmount: r.long(), extendedMedia: r.vector(r.object), payload: flags & 1 ? r.string() : void 0 };
    },
    480546647: function(r) {
      return { _: "inputChatPhotoEmpty" };
    },
    3184373440: function(r) {
      var flags = r.uint();
      return { _: "inputChatUploadedPhoto", file: flags & 1 ? r.object() : void 0, video: flags & 2 ? r.object() : void 0, videoStartTs: flags & 4 ? r.double() : void 0, videoEmojiMarkup: flags & 8 ? r.object() : void 0 };
    },
    2303962423: function(r) {
      return { _: "inputChatPhoto", id: r.object() };
    },
    3837862870: function(r) {
      return { _: "inputGeoPointEmpty" };
    },
    1210199983: function(r) {
      var flags = r.uint();
      return { _: "inputGeoPoint", lat: r.double(), long: r.double(), accuracyRadius: flags & 1 ? r.int() : void 0 };
    },
    483901197: function(r) {
      return { _: "inputPhotoEmpty" };
    },
    1001634122: function(r) {
      return { _: "inputPhoto", id: r.long(), accessHash: r.long(), fileReference: r.bytes() };
    },
    3755650017: function(r) {
      return { _: "inputFileLocation", volumeId: r.long(), localId: r.int(), secret: r.long(), fileReference: r.bytes() };
    },
    4112735573: function(r) {
      return { _: "inputEncryptedFileLocation", id: r.long(), accessHash: r.long() };
    },
    3134223748: function(r) {
      return { _: "inputDocumentFileLocation", id: r.long(), accessHash: r.long(), fileReference: r.bytes(), thumbSize: r.string() };
    },
    3418877480: function(r) {
      return { _: "inputSecureFileLocation", id: r.long(), accessHash: r.long() };
    },
    700340377: function(r) {
      return { _: "inputTakeoutFileLocation" };
    },
    1075322878: function(r) {
      return { _: "inputPhotoFileLocation", id: r.long(), accessHash: r.long(), fileReference: r.bytes(), thumbSize: r.string() };
    },
    3627312883: function(r) {
      return { _: "inputPhotoLegacyFileLocation", id: r.long(), accessHash: r.long(), fileReference: r.bytes(), volumeId: r.long(), localId: r.int(), secret: r.long() };
    },
    925204121: function(r) {
      var flags = r.uint();
      return { _: "inputPeerPhotoFileLocation", big: !!(flags & 1), peer: r.object(), photoId: r.long() };
    },
    2642736091: function(r) {
      return { _: "inputStickerSetThumb", stickerset: r.object(), thumbVersion: r.int() };
    },
    93890858: function(r) {
      var flags = r.uint();
      return { _: "inputGroupCallStream", call: r.object(), timeMs: r.long(), scale: r.int(), videoChannel: flags & 1 ? r.int() : void 0, videoQuality: flags & 1 ? r.int() : void 0 };
    },
    1498486562: function(r) {
      return { _: "peerUser", userId: r.int53() };
    },
    918946202: function(r) {
      return { _: "peerChat", chatId: r.int53() };
    },
    2728736542: function(r) {
      return { _: "peerChannel", channelId: r.int53() };
    },
    2861972229: function(r) {
      return { _: "storage.fileUnknown" };
    },
    1086091090: function(r) {
      return { _: "storage.filePartial" };
    },
    8322574: function(r) {
      return { _: "storage.fileJpeg" };
    },
    3403786975: function(r) {
      return { _: "storage.fileGif" };
    },
    172975040: function(r) {
      return { _: "storage.filePng" };
    },
    2921222285: function(r) {
      return { _: "storage.filePdf" };
    },
    1384777335: function(r) {
      return { _: "storage.fileMp3" };
    },
    1258941372: function(r) {
      return { _: "storage.fileMov" };
    },
    3016663268: function(r) {
      return { _: "storage.fileMp4" };
    },
    276907596: function(r) {
      return { _: "storage.fileWebp" };
    },
    3552332666: function(r) {
      return { _: "userEmpty", id: r.int53() };
    },
    2201046986: function(r) {
      var flags = r.uint(), flags2 = r.uint();
      return { _: "user", self: !!(flags & 1024), contact: !!(flags & 2048), mutualContact: !!(flags & 4096), deleted: !!(flags & 8192), bot: !!(flags & 16384), botChatHistory: !!(flags & 32768), botNochats: !!(flags & 65536), verified: !!(flags & 131072), restricted: !!(flags & 262144), min: !!(flags & 1048576), botInlineGeo: !!(flags & 2097152), support: !!(flags & 8388608), scam: !!(flags & 16777216), applyMinPhoto: !!(flags & 33554432), fake: !!(flags & 67108864), botAttachMenu: !!(flags & 134217728), premium: !!(flags & 268435456), attachMenuEnabled: !!(flags & 536870912), botCanEdit: !!(flags2 & 2), closeFriend: !!(flags2 & 4), storiesHidden: !!(flags2 & 8), storiesUnavailable: !!(flags2 & 16), contactRequirePremium: !!(flags2 & 1024), botBusiness: !!(flags2 & 2048), botHasMainApp: !!(flags2 & 8192), id: r.int53(), accessHash: flags & 1 ? r.long() : void 0, firstName: flags & 2 ? r.string() : void 0, lastName: flags & 4 ? r.string() : void 0, username: flags & 8 ? r.string() : void 0, phone: flags & 16 ? r.string() : void 0, photo: flags & 32 ? r.object() : void 0, status: flags & 64 ? r.object() : void 0, botInfoVersion: flags & 16384 ? r.int() : void 0, restrictionReason: flags & 262144 ? r.vector(r.object) : void 0, botInlinePlaceholder: flags & 524288 ? r.string() : void 0, langCode: flags & 4194304 ? r.string() : void 0, emojiStatus: flags & 1073741824 ? r.object() : void 0, usernames: flags2 & 1 ? r.vector(r.object) : void 0, storiesMaxId: flags2 & 32 ? r.int() : void 0, color: flags2 & 256 ? r.object() : void 0, profileColor: flags2 & 512 ? r.object() : void 0, botActiveUsers: flags2 & 4096 ? r.int() : void 0 };
    },
    1326562017: function(r) {
      return { _: "userProfilePhotoEmpty" };
    },
    2194798342: function(r) {
      var flags = r.uint();
      return { _: "userProfilePhoto", hasVideo: !!(flags & 1), personal: !!(flags & 4), photoId: r.long(), strippedThumb: flags & 2 ? r.bytes() : void 0, dcId: r.int() };
    },
    164646985: function(r) {
      return { _: "userStatusEmpty" };
    },
    3988339017: function(r) {
      return { _: "userStatusOnline", expires: r.int() };
    },
    9203775: function(r) {
      return { _: "userStatusOffline", wasOnline: r.int() };
    },
    2065268168: function(r) {
      var flags = r.uint();
      return { _: "userStatusRecently", byMe: !!(flags & 1) };
    },
    1410997530: function(r) {
      var flags = r.uint();
      return { _: "userStatusLastWeek", byMe: !!(flags & 1) };
    },
    1703516023: function(r) {
      var flags = r.uint();
      return { _: "userStatusLastMonth", byMe: !!(flags & 1) };
    },
    693512293: function(r) {
      return { _: "chatEmpty", id: r.int53() };
    },
    1103884886: function(r) {
      var flags = r.uint();
      return { _: "chat", creator: !!(flags & 1), left: !!(flags & 4), deactivated: !!(flags & 32), callActive: !!(flags & 8388608), callNotEmpty: !!(flags & 16777216), noforwards: !!(flags & 33554432), id: r.int53(), title: r.string(), photo: r.object(), participantsCount: r.int(), date: r.int(), version: r.int(), migratedTo: flags & 64 ? r.object() : void 0, adminRights: flags & 16384 ? r.object() : void 0, defaultBannedRights: flags & 262144 ? r.object() : void 0 };
    },
    1704108455: function(r) {
      return { _: "chatForbidden", id: r.int53(), title: r.string() };
    },
    4265900221: function(r) {
      var flags = r.uint(), flags2 = r.uint();
      return { _: "channel", creator: !!(flags & 1), left: !!(flags & 4), broadcast: !!(flags & 32), verified: !!(flags & 128), megagroup: !!(flags & 256), restricted: !!(flags & 512), signatures: !!(flags & 2048), min: !!(flags & 4096), scam: !!(flags & 524288), hasLink: !!(flags & 1048576), hasGeo: !!(flags & 2097152), slowmodeEnabled: !!(flags & 4194304), callActive: !!(flags & 8388608), callNotEmpty: !!(flags & 16777216), fake: !!(flags & 33554432), gigagroup: !!(flags & 67108864), noforwards: !!(flags & 134217728), joinToSend: !!(flags & 268435456), joinRequest: !!(flags & 536870912), forum: !!(flags & 1073741824), storiesHidden: !!(flags2 & 2), storiesHiddenMin: !!(flags2 & 4), storiesUnavailable: !!(flags2 & 8), signatureProfiles: !!(flags2 & 4096), id: r.int53(), accessHash: flags & 8192 ? r.long() : void 0, title: r.string(), username: flags & 64 ? r.string() : void 0, photo: r.object(), date: r.int(), restrictionReason: flags & 512 ? r.vector(r.object) : void 0, adminRights: flags & 16384 ? r.object() : void 0, bannedRights: flags & 32768 ? r.object() : void 0, defaultBannedRights: flags & 262144 ? r.object() : void 0, participantsCount: flags & 131072 ? r.int() : void 0, usernames: flags2 & 1 ? r.vector(r.object) : void 0, storiesMaxId: flags2 & 16 ? r.int() : void 0, color: flags2 & 128 ? r.object() : void 0, profileColor: flags2 & 256 ? r.object() : void 0, emojiStatus: flags2 & 512 ? r.object() : void 0, level: flags2 & 1024 ? r.int() : void 0, subscriptionUntilDate: flags2 & 2048 ? r.int() : void 0 };
    },
    399807445: function(r) {
      var flags = r.uint();
      return { _: "channelForbidden", broadcast: !!(flags & 32), megagroup: !!(flags & 256), id: r.int53(), accessHash: r.long(), title: r.string(), untilDate: flags & 65536 ? r.int() : void 0 };
    },
    640893467: function(r) {
      var flags = r.uint();
      return { _: "chatFull", canSetUsername: !!(flags & 128), hasScheduled: !!(flags & 256), translationsDisabled: !!(flags & 524288), id: r.int53(), about: r.string(), participants: r.object(), chatPhoto: flags & 4 ? r.object() : void 0, notifySettings: r.object(), exportedInvite: flags & 8192 ? r.object() : void 0, botInfo: flags & 8 ? r.vector(r.object) : void 0, pinnedMsgId: flags & 64 ? r.int() : void 0, folderId: flags & 2048 ? r.int() : void 0, call: flags & 4096 ? r.object() : void 0, ttlPeriod: flags & 16384 ? r.int() : void 0, groupcallDefaultJoinAs: flags & 32768 ? r.object() : void 0, themeEmoticon: flags & 65536 ? r.string() : void 0, requestsPending: flags & 131072 ? r.int() : void 0, recentRequesters: flags & 131072 ? r.vector(r.long) : void 0, availableReactions: flags & 262144 ? r.object() : void 0, reactionsLimit: flags & 1048576 ? r.int() : void 0 };
    },
    3148559501: function(r) {
      var flags = r.uint(), flags2 = r.uint();
      return { _: "channelFull", canViewParticipants: !!(flags & 8), canSetUsername: !!(flags & 64), canSetStickers: !!(flags & 128), hiddenPrehistory: !!(flags & 1024), canSetLocation: !!(flags & 65536), hasScheduled: !!(flags & 524288), canViewStats: !!(flags & 1048576), blocked: !!(flags & 4194304), canDeleteChannel: !!(flags2 & 1), antispam: !!(flags2 & 2), participantsHidden: !!(flags2 & 4), translationsDisabled: !!(flags2 & 8), storiesPinnedAvailable: !!(flags2 & 32), viewForumAsMessages: !!(flags2 & 64), restrictedSponsored: !!(flags2 & 2048), canViewRevenue: !!(flags2 & 4096), paidMediaAllowed: !!(flags2 & 16384), canViewStarsRevenue: !!(flags2 & 32768), paidReactionsAvailable: !!(flags2 & 65536), id: r.int53(), about: r.string(), participantsCount: flags & 1 ? r.int() : void 0, adminsCount: flags & 2 ? r.int() : void 0, kickedCount: flags & 4 ? r.int() : void 0, bannedCount: flags & 4 ? r.int() : void 0, onlineCount: flags & 8192 ? r.int() : void 0, readInboxMaxId: r.int(), readOutboxMaxId: r.int(), unreadCount: r.int(), chatPhoto: r.object(), notifySettings: r.object(), exportedInvite: flags & 8388608 ? r.object() : void 0, botInfo: r.vector(r.object), migratedFromChatId: flags & 16 ? r.long() : void 0, migratedFromMaxId: flags & 16 ? r.int() : void 0, pinnedMsgId: flags & 32 ? r.int() : void 0, stickerset: flags & 256 ? r.object() : void 0, availableMinId: flags & 512 ? r.int() : void 0, folderId: flags & 2048 ? r.int() : void 0, linkedChatId: flags & 16384 ? r.int53() : void 0, location: flags & 32768 ? r.object() : void 0, slowmodeSeconds: flags & 131072 ? r.int() : void 0, slowmodeNextSendDate: flags & 262144 ? r.int() : void 0, statsDc: flags & 4096 ? r.int() : void 0, pts: r.int(), call: flags & 2097152 ? r.object() : void 0, ttlPeriod: flags & 16777216 ? r.int() : void 0, pendingSuggestions: flags & 33554432 ? r.vector(r.string) : void 0, groupcallDefaultJoinAs: flags & 67108864 ? r.object() : void 0, themeEmoticon: flags & 134217728 ? r.string() : void 0, requestsPending: flags & 268435456 ? r.int() : void 0, recentRequesters: flags & 268435456 ? r.vector(r.long) : void 0, defaultSendAs: flags & 536870912 ? r.object() : void 0, availableReactions: flags & 1073741824 ? r.object() : void 0, reactionsLimit: flags2 & 8192 ? r.int() : void 0, stories: flags2 & 16 ? r.object() : void 0, wallpaper: flags2 & 128 ? r.object() : void 0, boostsApplied: flags2 & 256 ? r.int() : void 0, boostsUnrestrict: flags2 & 512 ? r.int() : void 0, emojiset: flags2 & 1024 ? r.object() : void 0 };
    },
    3224190983: function(r) {
      return { _: "chatParticipant", userId: r.int53(), inviterId: r.int53(), date: r.int() };
    },
    3832270564: function(r) {
      return { _: "chatParticipantCreator", userId: r.int53() };
    },
    2694004571: function(r) {
      return { _: "chatParticipantAdmin", userId: r.int53(), inviterId: r.int53(), date: r.int() };
    },
    2271466465: function(r) {
      var flags = r.uint();
      return { _: "chatParticipantsForbidden", chatId: r.int53(), selfParticipant: flags & 1 ? r.object() : void 0 };
    },
    1018991608: function(r) {
      return { _: "chatParticipants", chatId: r.int53(), participants: r.vector(r.object), version: r.int() };
    },
    935395612: function(r) {
      return { _: "chatPhotoEmpty" };
    },
    476978193: function(r) {
      var flags = r.uint();
      return { _: "chatPhoto", hasVideo: !!(flags & 1), photoId: r.long(), strippedThumb: flags & 2 ? r.bytes() : void 0, dcId: r.int() };
    },
    2426849924: function(r) {
      var flags = r.uint();
      return { _: "messageEmpty", id: r.int(), peerId: flags & 1 ? r.object() : void 0 };
    },
    2486456898: function(r) {
      var flags = r.uint(), flags2 = r.uint();
      return { _: "message", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), post: !!(flags & 16384), fromScheduled: !!(flags & 262144), legacy: !!(flags & 524288), editHide: !!(flags & 2097152), pinned: !!(flags & 16777216), noforwards: !!(flags & 67108864), invertMedia: !!(flags & 134217728), offline: !!(flags2 & 2), id: r.int(), fromId: flags & 256 ? r.object() : void 0, fromBoostsApplied: flags & 536870912 ? r.int() : void 0, peerId: r.object(), savedPeerId: flags & 268435456 ? r.object() : void 0, fwdFrom: flags & 4 ? r.object() : void 0, viaBotId: flags & 2048 ? r.int53() : void 0, viaBusinessBotId: flags2 & 1 ? r.int53() : void 0, replyTo: flags & 8 ? r.object() : void 0, date: r.int(), message: r.string(), media: flags & 512 ? r.object() : void 0, replyMarkup: flags & 64 ? r.object() : void 0, entities: flags & 128 ? r.vector(r.object) : void 0, views: flags & 1024 ? r.int() : void 0, forwards: flags & 1024 ? r.int() : void 0, replies: flags & 8388608 ? r.object() : void 0, editDate: flags & 32768 ? r.int() : void 0, postAuthor: flags & 65536 ? r.string() : void 0, groupedId: flags & 131072 ? r.long() : void 0, reactions: flags & 1048576 ? r.object() : void 0, restrictionReason: flags & 4194304 ? r.vector(r.object) : void 0, ttlPeriod: flags & 33554432 ? r.int() : void 0, quickReplyShortcutId: flags & 1073741824 ? r.int() : void 0, effect: flags2 & 4 ? r.long() : void 0, factcheck: flags2 & 8 ? r.object() : void 0 };
    },
    721967202: function(r) {
      var flags = r.uint();
      return { _: "messageService", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), post: !!(flags & 16384), legacy: !!(flags & 524288), id: r.int(), fromId: flags & 256 ? r.object() : void 0, peerId: r.object(), replyTo: flags & 8 ? r.object() : void 0, date: r.int(), action: r.object(), ttlPeriod: flags & 33554432 ? r.int() : void 0 };
    },
    1038967584: function(r) {
      return { _: "messageMediaEmpty" };
    },
    1766936791: function(r) {
      var flags = r.uint();
      return { _: "messageMediaPhoto", spoiler: !!(flags & 8), photo: flags & 1 ? r.object() : void 0, ttlSeconds: flags & 4 ? r.int() : void 0 };
    },
    1457575028: function(r) {
      return { _: "messageMediaGeo", geo: r.object() };
    },
    1882335561: function(r) {
      return { _: "messageMediaContact", phoneNumber: r.string(), firstName: r.string(), lastName: r.string(), vcard: r.string(), userId: r.int53() };
    },
    2676290718: function(r) {
      return { _: "messageMediaUnsupported" };
    },
    3713469397: function(r) {
      var flags = r.uint();
      return { _: "messageMediaDocument", nopremium: !!(flags & 8), spoiler: !!(flags & 16), video: !!(flags & 64), round: !!(flags & 128), voice: !!(flags & 256), document: flags & 1 ? r.object() : void 0, altDocuments: flags & 32 ? r.vector(r.object) : void 0, ttlSeconds: flags & 4 ? r.int() : void 0 };
    },
    3723562043: function(r) {
      var flags = r.uint();
      return { _: "messageMediaWebPage", forceLargeMedia: !!(flags & 1), forceSmallMedia: !!(flags & 2), manual: !!(flags & 8), safe: !!(flags & 16), webpage: r.object() };
    },
    784356159: function(r) {
      return { _: "messageMediaVenue", geo: r.object(), title: r.string(), address: r.string(), provider: r.string(), venueId: r.string(), venueType: r.string() };
    },
    4256272392: function(r) {
      return { _: "messageMediaGame", game: r.object() };
    },
    4138027219: function(r) {
      var flags = r.uint();
      return { _: "messageMediaInvoice", shippingAddressRequested: !!(flags & 2), test: !!(flags & 8), title: r.string(), description: r.string(), photo: flags & 1 ? r.object() : void 0, receiptMsgId: flags & 4 ? r.int() : void 0, currency: r.string(), totalAmount: r.long(), startParam: r.string(), extendedMedia: flags & 16 ? r.object() : void 0 };
    },
    3108030054: function(r) {
      var flags = r.uint();
      return { _: "messageMediaGeoLive", geo: r.object(), heading: flags & 1 ? r.int() : void 0, period: r.int(), proximityNotificationRadius: flags & 2 ? r.int() : void 0 };
    },
    1272375192: function(r) {
      return { _: "messageMediaPoll", poll: r.object(), results: r.object() };
    },
    1065280907: function(r) {
      return { _: "messageMediaDice", value: r.int(), emoticon: r.string() };
    },
    1758159491: function(r) {
      var flags = r.uint();
      return { _: "messageMediaStory", viaMention: !!(flags & 2), peer: r.object(), id: r.int(), story: flags & 1 ? r.object() : void 0 };
    },
    2852600811: function(r) {
      var flags = r.uint();
      return { _: "messageMediaGiveaway", onlyNewSubscribers: !!(flags & 1), winnersAreVisible: !!(flags & 4), channels: r.vector(r.int53), countriesIso2: flags & 2 ? r.vector(r.string) : void 0, prizeDescription: flags & 8 ? r.string() : void 0, quantity: r.int(), months: flags & 16 ? r.int() : void 0, stars: flags & 32 ? r.long() : void 0, untilDate: r.int() };
    },
    3467263649: function(r) {
      var flags = r.uint();
      return { _: "messageMediaGiveawayResults", onlyNewSubscribers: !!(flags & 1), refunded: !!(flags & 4), channelId: r.long(), additionalPeersCount: flags & 8 ? r.int() : void 0, launchMsgId: r.int(), winnersCount: r.int(), unclaimedCount: r.int(), winners: r.vector(r.long), months: flags & 16 ? r.int() : void 0, stars: flags & 32 ? r.long() : void 0, prizeDescription: flags & 2 ? r.string() : void 0, untilDate: r.int() };
    },
    2827297937: function(r) {
      return { _: "messageMediaPaidMedia", starsAmount: r.long(), extendedMedia: r.vector(r.object) };
    },
    3064919984: function(r) {
      return { _: "messageActionEmpty" };
    },
    3175599021: function(r) {
      return { _: "messageActionChatCreate", title: r.string(), users: r.vector(r.int53) };
    },
    3047280218: function(r) {
      return { _: "messageActionChatEditTitle", title: r.string() };
    },
    2144015272: function(r) {
      return { _: "messageActionChatEditPhoto", photo: r.object() };
    },
    2514746351: function(r) {
      return { _: "messageActionChatDeletePhoto" };
    },
    365886720: function(r) {
      return { _: "messageActionChatAddUser", users: r.vector(r.int53) };
    },
    2755604684: function(r) {
      return { _: "messageActionChatDeleteUser", userId: r.int53() };
    },
    51520707: function(r) {
      return { _: "messageActionChatJoinedByLink", inviterId: r.int53() };
    },
    2513611922: function(r) {
      return { _: "messageActionChannelCreate", title: r.string() };
    },
    3775102866: function(r) {
      return { _: "messageActionChatMigrateTo", channelId: r.int53() };
    },
    3929622761: function(r) {
      return { _: "messageActionChannelMigrateFrom", title: r.string(), chatId: r.int53() };
    },
    2495428845: function(r) {
      return { _: "messageActionPinMessage" };
    },
    2679813636: function(r) {
      return { _: "messageActionHistoryClear" };
    },
    2460428406: function(r) {
      return { _: "messageActionGameScore", gameId: r.long(), score: r.int() };
    },
    2402399015: function(r) {
      var flags = r.uint();
      return { _: "messageActionPaymentSentMe", recurringInit: !!(flags & 4), recurringUsed: !!(flags & 8), currency: r.string(), totalAmount: r.long(), payload: r.bytes(), info: flags & 1 ? r.object() : void 0, shippingOptionId: flags & 2 ? r.string() : void 0, charge: r.object() };
    },
    2518040406: function(r) {
      var flags = r.uint();
      return { _: "messageActionPaymentSent", recurringInit: !!(flags & 4), recurringUsed: !!(flags & 8), currency: r.string(), totalAmount: r.long(), invoiceSlug: flags & 1 ? r.string() : void 0 };
    },
    2162236031: function(r) {
      var flags = r.uint();
      return { _: "messageActionPhoneCall", video: !!(flags & 4), callId: r.long(), reason: flags & 1 ? r.object() : void 0, duration: flags & 2 ? r.int() : void 0 };
    },
    1200788123: function(r) {
      return { _: "messageActionScreenshotTaken" };
    },
    4209418070: function(r) {
      return { _: "messageActionCustomAction", message: r.string() };
    },
    3306608249: function(r) {
      var flags = r.uint();
      return { _: "messageActionBotAllowed", attachMenu: !!(flags & 2), fromRequest: !!(flags & 8), domain: flags & 1 ? r.string() : void 0, app: flags & 4 ? r.object() : void 0 };
    },
    455635795: function(r) {
      return { _: "messageActionSecureValuesSentMe", values: r.vector(r.object), credentials: r.object() };
    },
    3646710100: function(r) {
      return { _: "messageActionSecureValuesSent", types: r.vector(r.object) };
    },
    4092747638: function(r) {
      return { _: "messageActionContactSignUp" };
    },
    2564871831: function(r) {
      return { _: "messageActionGeoProximityReached", fromId: r.object(), toId: r.object(), distance: r.int() };
    },
    2047704898: function(r) {
      var flags = r.uint();
      return { _: "messageActionGroupCall", call: r.object(), duration: flags & 1 ? r.int() : void 0 };
    },
    1345295095: function(r) {
      return { _: "messageActionInviteToGroupCall", call: r.object(), users: r.vector(r.int53) };
    },
    1007897979: function(r) {
      var flags = r.uint();
      return { _: "messageActionSetMessagesTTL", period: r.int(), autoSettingFrom: flags & 1 ? r.long() : void 0 };
    },
    3013637729: function(r) {
      return { _: "messageActionGroupCallScheduled", call: r.object(), scheduleDate: r.int() };
    },
    2860016453: function(r) {
      return { _: "messageActionSetChatTheme", emoticon: r.string() };
    },
    3955008459: function(r) {
      return { _: "messageActionChatJoinedByRequest" };
    },
    1205698681: function(r) {
      return { _: "messageActionWebViewDataSentMe", text: r.string(), data: r.string() };
    },
    3032714421: function(r) {
      return { _: "messageActionWebViewDataSent", text: r.string() };
    },
    3359468268: function(r) {
      var flags = r.uint();
      return { _: "messageActionGiftPremium", currency: r.string(), amount: r.long(), months: r.int(), cryptoCurrency: flags & 1 ? r.string() : void 0, cryptoAmount: flags & 1 ? r.long() : void 0 };
    },
    228168278: function(r) {
      var flags = r.uint();
      return { _: "messageActionTopicCreate", title: r.string(), iconColor: r.int(), iconEmojiId: flags & 1 ? r.long() : void 0 };
    },
    3230943264: function(r) {
      var flags = r.uint();
      return { _: "messageActionTopicEdit", title: flags & 1 ? r.string() : void 0, iconEmojiId: flags & 2 ? r.long() : void 0, closed: flags & 4 ? r.boolean() : void 0, hidden: flags & 8 ? r.boolean() : void 0 };
    },
    1474192222: function(r) {
      return { _: "messageActionSuggestProfilePhoto", photo: r.object() };
    },
    827428507: function(r) {
      return { _: "messageActionRequestedPeer", buttonId: r.int(), peers: r.vector(r.object) };
    },
    1348510708: function(r) {
      var flags = r.uint();
      return { _: "messageActionSetChatWallPaper", same: !!(flags & 1), forBoth: !!(flags & 2), wallpaper: r.object() };
    },
    1737240073: function(r) {
      var flags = r.uint();
      return { _: "messageActionGiftCode", viaGiveaway: !!(flags & 1), unclaimed: !!(flags & 4), boostPeer: flags & 2 ? r.object() : void 0, months: r.int(), slug: r.string(), currency: flags & 4 ? r.string() : void 0, amount: flags & 4 ? r.long() : void 0, cryptoCurrency: flags & 8 ? r.string() : void 0, cryptoAmount: flags & 8 ? r.long() : void 0 };
    },
    2819576292: function(r) {
      var flags = r.uint();
      return { _: "messageActionGiveawayLaunch", stars: flags & 1 ? r.long() : void 0 };
    },
    2279797077: function(r) {
      var flags = r.uint();
      return { _: "messageActionGiveawayResults", stars: !!(flags & 1), winnersCount: r.int(), unclaimedCount: r.int() };
    },
    3422726765: function(r) {
      return { _: "messageActionBoostApply", boosts: r.int() };
    },
    2477987912: function(r) {
      return { _: "messageActionRequestedPeerSentMe", buttonId: r.int(), peers: r.vector(r.object) };
    },
    1102307842: function(r) {
      var flags = r.uint();
      return { _: "messageActionPaymentRefunded", peer: r.object(), currency: r.string(), totalAmount: r.long(), payload: flags & 1 ? r.bytes() : void 0, charge: r.object() };
    },
    1171632161: function(r) {
      var flags = r.uint();
      return { _: "messageActionGiftStars", currency: r.string(), amount: r.long(), stars: r.long(), cryptoCurrency: flags & 1 ? r.string() : void 0, cryptoAmount: flags & 1 ? r.long() : void 0, transactionId: flags & 2 ? r.string() : void 0 };
    },
    2953594786: function(r) {
      var flags = r.uint();
      return { _: "messageActionPrizeStars", unclaimed: !!(flags & 1), stars: r.long(), transactionId: r.string(), boostPeer: r.object(), giveawayMsgId: r.int() };
    },
    2612260676: function(r) {
      var flags = r.uint();
      return { _: "messageActionStarGift", nameHidden: !!(flags & 1), saved: !!(flags & 4), converted: !!(flags & 8), gift: r.object(), message: flags & 2 ? r.object() : void 0, convertStars: r.long() };
    },
    3582593222: function(r) {
      var flags = r.uint();
      return { _: "dialog", pinned: !!(flags & 4), unreadMark: !!(flags & 8), viewForumAsMessages: !!(flags & 64), peer: r.object(), topMessage: r.int(), readInboxMaxId: r.int(), readOutboxMaxId: r.int(), unreadCount: r.int(), unreadMentionsCount: r.int(), unreadReactionsCount: r.int(), notifySettings: r.object(), pts: flags & 1 ? r.int() : void 0, draft: flags & 2 ? r.object() : void 0, folderId: flags & 16 ? r.int() : void 0, ttlPeriod: flags & 32 ? r.int() : void 0 };
    },
    1908216652: function(r) {
      var flags = r.uint();
      return { _: "dialogFolder", pinned: !!(flags & 4), folder: r.object(), peer: r.object(), topMessage: r.int(), unreadMutedPeersCount: r.int(), unreadUnmutedPeersCount: r.int(), unreadMutedMessagesCount: r.int(), unreadUnmutedMessagesCount: r.int() };
    },
    590459437: function(r) {
      return { _: "photoEmpty", id: r.long() };
    },
    4212750949: function(r) {
      var flags = r.uint();
      return { _: "photo", hasStickers: !!(flags & 1), id: r.long(), accessHash: r.long(), fileReference: r.bytes(), date: r.int(), sizes: r.vector(r.object), videoSizes: flags & 2 ? r.vector(r.object) : void 0, dcId: r.int() };
    },
    236446268: function(r) {
      return { _: "photoSizeEmpty", type: r.string() };
    },
    1976012384: function(r) {
      return { _: "photoSize", type: r.string(), w: r.int(), h: r.int(), size: r.int() };
    },
    35527382: function(r) {
      return { _: "photoCachedSize", type: r.string(), w: r.int(), h: r.int(), bytes: r.bytes() };
    },
    3769678894: function(r) {
      return { _: "photoStrippedSize", type: r.string(), bytes: r.bytes() };
    },
    4198431637: function(r) {
      return { _: "photoSizeProgressive", type: r.string(), w: r.int(), h: r.int(), sizes: r.vector(r.int) };
    },
    3626061121: function(r) {
      return { _: "photoPathSize", type: r.string(), bytes: r.bytes() };
    },
    286776671: function(r) {
      return { _: "geoPointEmpty" };
    },
    2997024355: function(r) {
      var flags = r.uint();
      return { _: "geoPoint", long: r.double(), lat: r.double(), accessHash: r.long(), accuracyRadius: flags & 1 ? r.int() : void 0 };
    },
    1577067778: function(r) {
      var flags = r.uint();
      return { _: "auth.sentCode", type: r.object(), phoneCodeHash: r.string(), nextType: flags & 2 ? r.object() : void 0, timeout: flags & 4 ? r.int() : void 0 };
    },
    596704836: function(r) {
      return { _: "auth.sentCodeSuccess", authorization: r.object() };
    },
    782418132: function(r) {
      var flags = r.uint();
      return { _: "auth.authorization", setupPasswordRequired: !!(flags & 2), otherwiseReloginDays: flags & 2 ? r.int() : void 0, tmpSessions: flags & 1 ? r.int() : void 0, futureAuthToken: flags & 4 ? r.bytes() : void 0, user: r.object() };
    },
    1148485274: function(r) {
      var flags = r.uint();
      return { _: "auth.authorizationSignUpRequired", termsOfService: flags & 1 ? r.object() : void 0 };
    },
    3023364792: function(r) {
      return { _: "auth.exportedAuthorization", id: r.long(), bytes: r.bytes() };
    },
    3099351820: function(r) {
      return { _: "inputNotifyPeer", peer: r.object() };
    },
    423314455: function(r) {
      return { _: "inputNotifyUsers" };
    },
    1251338318: function(r) {
      return { _: "inputNotifyChats" };
    },
    2983951486: function(r) {
      return { _: "inputNotifyBroadcasts" };
    },
    1548122514: function(r) {
      return { _: "inputNotifyForumTopic", peer: r.object(), topMsgId: r.int() };
    },
    3402328802: function(r) {
      var flags = r.uint();
      return { _: "inputPeerNotifySettings", showPreviews: flags & 1 ? r.boolean() : void 0, silent: flags & 2 ? r.boolean() : void 0, muteUntil: flags & 4 ? r.int() : void 0, sound: flags & 8 ? r.object() : void 0, storiesMuted: flags & 64 ? r.boolean() : void 0, storiesHideSender: flags & 128 ? r.boolean() : void 0, storiesSound: flags & 256 ? r.object() : void 0 };
    },
    2573347852: function(r) {
      var flags = r.uint();
      return { _: "peerNotifySettings", showPreviews: flags & 1 ? r.boolean() : void 0, silent: flags & 2 ? r.boolean() : void 0, muteUntil: flags & 4 ? r.int() : void 0, iosSound: flags & 8 ? r.object() : void 0, androidSound: flags & 16 ? r.object() : void 0, otherSound: flags & 32 ? r.object() : void 0, storiesMuted: flags & 64 ? r.boolean() : void 0, storiesHideSender: flags & 128 ? r.boolean() : void 0, storiesIosSound: flags & 256 ? r.object() : void 0, storiesAndroidSound: flags & 512 ? r.object() : void 0, storiesOtherSound: flags & 1024 ? r.object() : void 0 };
    },
    2899733598: function(r) {
      var flags = r.uint();
      return { _: "peerSettings", reportSpam: !!(flags & 1), addContact: !!(flags & 2), blockContact: !!(flags & 4), shareContact: !!(flags & 8), needContactsException: !!(flags & 16), reportGeo: !!(flags & 32), autoarchived: !!(flags & 128), inviteMembers: !!(flags & 256), requestChatBroadcast: !!(flags & 1024), businessBotPaused: !!(flags & 2048), businessBotCanReply: !!(flags & 4096), geoDistance: flags & 64 ? r.int() : void 0, requestChatTitle: flags & 512 ? r.string() : void 0, requestChatDate: flags & 512 ? r.int() : void 0, businessBotId: flags & 8192 ? r.int53() : void 0, businessBotManageUrl: flags & 8192 ? r.string() : void 0 };
    },
    2755118061: function(r) {
      var id2 = r.long(), flags = r.uint();
      return { _: "wallPaper", id: id2, creator: !!(flags & 1), default: !!(flags & 2), pattern: !!(flags & 8), dark: !!(flags & 16), accessHash: r.long(), slug: r.string(), document: r.object(), settings: flags & 4 ? r.object() : void 0 };
    },
    3766501654: function(r) {
      var id2 = r.long(), flags = r.uint();
      return { _: "wallPaperNoFile", id: id2, default: !!(flags & 2), dark: !!(flags & 16), settings: flags & 4 ? r.object() : void 0 };
    },
    1490799288: function(r) {
      return { _: "inputReportReasonSpam" };
    },
    505595789: function(r) {
      return { _: "inputReportReasonViolence" };
    },
    777640226: function(r) {
      return { _: "inputReportReasonPornography" };
    },
    2918469347: function(r) {
      return { _: "inputReportReasonChildAbuse" };
    },
    3252986545: function(r) {
      return { _: "inputReportReasonOther" };
    },
    2609510714: function(r) {
      return { _: "inputReportReasonCopyright" };
    },
    3688169197: function(r) {
      return { _: "inputReportReasonGeoIrrelevant" };
    },
    4124956391: function(r) {
      return { _: "inputReportReasonFake" };
    },
    177124030: function(r) {
      return { _: "inputReportReasonIllegalDrugs" };
    },
    2663876157: function(r) {
      return { _: "inputReportReasonPersonalDetails" };
    },
    525919081: function(r) {
      var flags = r.uint(), flags2 = r.uint();
      return { _: "userFull", blocked: !!(flags & 1), phoneCallsAvailable: !!(flags & 16), phoneCallsPrivate: !!(flags & 32), canPinMessage: !!(flags & 128), hasScheduled: !!(flags & 4096), videoCallsAvailable: !!(flags & 8192), voiceMessagesForbidden: !!(flags & 1048576), translationsDisabled: !!(flags & 8388608), storiesPinnedAvailable: !!(flags & 67108864), blockedMyStoriesFrom: !!(flags & 134217728), wallpaperOverridden: !!(flags & 268435456), contactRequirePremium: !!(flags & 536870912), readDatesPrivate: !!(flags & 1073741824), sponsoredEnabled: !!(flags2 & 128), id: r.int53(), about: flags & 2 ? r.string() : void 0, settings: r.object(), personalPhoto: flags & 2097152 ? r.object() : void 0, profilePhoto: flags & 4 ? r.object() : void 0, fallbackPhoto: flags & 4194304 ? r.object() : void 0, notifySettings: r.object(), botInfo: flags & 8 ? r.object() : void 0, pinnedMsgId: flags & 64 ? r.int() : void 0, commonChatsCount: r.int(), folderId: flags & 2048 ? r.int() : void 0, ttlPeriod: flags & 16384 ? r.int() : void 0, themeEmoticon: flags & 32768 ? r.string() : void 0, privateForwardName: flags & 65536 ? r.string() : void 0, botGroupAdminRights: flags & 131072 ? r.object() : void 0, botBroadcastAdminRights: flags & 262144 ? r.object() : void 0, premiumGifts: flags & 524288 ? r.vector(r.object) : void 0, wallpaper: flags & 16777216 ? r.object() : void 0, stories: flags & 33554432 ? r.object() : void 0, businessWorkHours: flags2 & 1 ? r.object() : void 0, businessLocation: flags2 & 2 ? r.object() : void 0, businessGreetingMessage: flags2 & 4 ? r.object() : void 0, businessAwayMessage: flags2 & 8 ? r.object() : void 0, businessIntro: flags2 & 16 ? r.object() : void 0, birthday: flags2 & 32 ? r.object() : void 0, personalChannelId: flags2 & 64 ? r.int53() : void 0, personalChannelMessage: flags2 & 64 ? r.int() : void 0, stargiftsCount: flags2 & 256 ? r.int() : void 0 };
    },
    341499403: function(r) {
      return { _: "contact", userId: r.int53(), mutual: r.boolean() };
    },
    3242081360: function(r) {
      return { _: "importedContact", userId: r.int53(), clientId: r.long() };
    },
    383348795: function(r) {
      return { _: "contactStatus", userId: r.int53(), status: r.object() };
    },
    3075189202: function(r) {
      return { _: "contacts.contactsNotModified" };
    },
    3941105218: function(r) {
      return { _: "contacts.contacts", contacts: r.vector(r.object), savedCount: r.int(), users: r.vector(r.object) };
    },
    2010127419: function(r) {
      return { _: "contacts.importedContacts", imported: r.vector(r.object), popularInvites: r.vector(r.object), retryContacts: r.vector(r.long), users: r.vector(r.object) };
    },
    182326673: function(r) {
      return { _: "contacts.blocked", blocked: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3781575060: function(r) {
      return { _: "contacts.blockedSlice", count: r.int(), blocked: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    364538944: function(r) {
      return { _: "messages.dialogs", dialogs: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1910543603: function(r) {
      return { _: "messages.dialogsSlice", count: r.int(), dialogs: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    4041467286: function(r) {
      return { _: "messages.dialogsNotModified", count: r.int() };
    },
    2356252295: function(r) {
      return { _: "messages.messages", messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    978610270: function(r) {
      var flags = r.uint();
      return { _: "messages.messagesSlice", inexact: !!(flags & 2), count: r.int(), nextRate: flags & 1 ? r.int() : void 0, offsetIdOffset: flags & 4 ? r.int() : void 0, messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3346446926: function(r) {
      var flags = r.uint();
      return { _: "messages.channelMessages", inexact: !!(flags & 2), pts: r.int(), count: r.int(), offsetIdOffset: flags & 4 ? r.int() : void 0, messages: r.vector(r.object), topics: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1951620897: function(r) {
      return { _: "messages.messagesNotModified", count: r.int() };
    },
    1694474197: function(r) {
      return { _: "messages.chats", chats: r.vector(r.object) };
    },
    2631405892: function(r) {
      return { _: "messages.chatsSlice", count: r.int(), chats: r.vector(r.object) };
    },
    3856126364: function(r) {
      return { _: "messages.chatFull", fullChat: r.object(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3025955281: function(r) {
      return { _: "messages.affectedHistory", pts: r.int(), ptsCount: r.int(), offset: r.int() };
    },
    1474492012: function(r) {
      return { _: "inputMessagesFilterEmpty" };
    },
    2517214492: function(r) {
      return { _: "inputMessagesFilterPhotos" };
    },
    2680163941: function(r) {
      return { _: "inputMessagesFilterVideo" };
    },
    1458172132: function(r) {
      return { _: "inputMessagesFilterPhotoVideo" };
    },
    2665345416: function(r) {
      return { _: "inputMessagesFilterDocument" };
    },
    2129714567: function(r) {
      return { _: "inputMessagesFilterUrl" };
    },
    4291323271: function(r) {
      return { _: "inputMessagesFilterGif" };
    },
    1358283666: function(r) {
      return { _: "inputMessagesFilterVoice" };
    },
    928101534: function(r) {
      return { _: "inputMessagesFilterMusic" };
    },
    975236280: function(r) {
      return { _: "inputMessagesFilterChatPhotos" };
    },
    2160695144: function(r) {
      var flags = r.uint();
      return { _: "inputMessagesFilterPhoneCalls", missed: !!(flags & 1) };
    },
    2054952868: function(r) {
      return { _: "inputMessagesFilterRoundVoice" };
    },
    3041516115: function(r) {
      return { _: "inputMessagesFilterRoundVideo" };
    },
    3254314650: function(r) {
      return { _: "inputMessagesFilterMyMentions" };
    },
    3875695885: function(r) {
      return { _: "inputMessagesFilterGeo" };
    },
    3764575107: function(r) {
      return { _: "inputMessagesFilterContacts" };
    },
    464520273: function(r) {
      return { _: "inputMessagesFilterPinned" };
    },
    522914557: function(r) {
      return { _: "updateNewMessage", message: r.object(), pts: r.int(), ptsCount: r.int() };
    },
    1318109142: function(r) {
      return { _: "updateMessageID", id: r.int(), randomId: r.long() };
    },
    2718806245: function(r) {
      return { _: "updateDeleteMessages", messages: r.vector(r.int), pts: r.int(), ptsCount: r.int() };
    },
    3223225727: function(r) {
      return { _: "updateUserTyping", userId: r.int53(), action: r.object() };
    },
    2202565360: function(r) {
      return { _: "updateChatUserTyping", chatId: r.int53(), fromId: r.object(), action: r.object() };
    },
    125178264: function(r) {
      return { _: "updateChatParticipants", participants: r.object() };
    },
    3854432478: function(r) {
      return { _: "updateUserStatus", userId: r.int53(), status: r.object() };
    },
    2810480932: function(r) {
      return { _: "updateUserName", userId: r.int53(), firstName: r.string(), lastName: r.string(), usernames: r.vector(r.object) };
    },
    2303831023: function(r) {
      var flags = r.uint();
      return { _: "updateNewAuthorization", unconfirmed: !!(flags & 1), hash: r.long(), date: flags & 1 ? r.int() : void 0, device: flags & 1 ? r.string() : void 0, location: flags & 1 ? r.string() : void 0 };
    },
    314359194: function(r) {
      return { _: "updateNewEncryptedMessage", message: r.object(), qts: r.int() };
    },
    386986326: function(r) {
      return { _: "updateEncryptedChatTyping", chatId: r.int() };
    },
    3030575245: function(r) {
      return { _: "updateEncryption", chat: r.object(), date: r.int() };
    },
    956179895: function(r) {
      return { _: "updateEncryptedMessagesRead", chatId: r.int(), maxDate: r.int(), date: r.int() };
    },
    1037718609: function(r) {
      return { _: "updateChatParticipantAdd", chatId: r.int53(), userId: r.int53(), inviterId: r.int53(), date: r.int(), version: r.int() };
    },
    3811523959: function(r) {
      return { _: "updateChatParticipantDelete", chatId: r.int53(), userId: r.int53(), version: r.int() };
    },
    2388564083: function(r) {
      return { _: "updateDcOptions", dcOptions: r.vector(r.object) };
    },
    3200411887: function(r) {
      return { _: "updateNotifySettings", peer: r.object(), notifySettings: r.object() };
    },
    3957614617: function(r) {
      var flags = r.uint();
      return { _: "updateServiceNotification", popup: !!(flags & 1), invertMedia: !!(flags & 4), inboxDate: flags & 2 ? r.int() : void 0, type: r.string(), message: r.string(), media: r.object(), entities: r.vector(r.object) };
    },
    3996854058: function(r) {
      return { _: "updatePrivacy", key: r.object(), rules: r.vector(r.object) };
    },
    88680979: function(r) {
      return { _: "updateUserPhone", userId: r.int53(), phone: r.string() };
    },
    2627162079: function(r) {
      var flags = r.uint();
      return { _: "updateReadHistoryInbox", folderId: flags & 1 ? r.int() : void 0, peer: r.object(), maxId: r.int(), stillUnreadCount: r.int(), pts: r.int(), ptsCount: r.int() };
    },
    791617983: function(r) {
      return { _: "updateReadHistoryOutbox", peer: r.object(), maxId: r.int(), pts: r.int(), ptsCount: r.int() };
    },
    2139689491: function(r) {
      return { _: "updateWebPage", webpage: r.object(), pts: r.int(), ptsCount: r.int() };
    },
    4163006849: function(r) {
      var flags = r.uint();
      return { _: "updateReadMessagesContents", messages: r.vector(r.int), pts: r.int(), ptsCount: r.int(), date: flags & 1 ? r.int() : void 0 };
    },
    277713951: function(r) {
      var flags = r.uint();
      return { _: "updateChannelTooLong", channelId: r.int53(), pts: flags & 1 ? r.int() : void 0 };
    },
    1666927625: function(r) {
      return { _: "updateChannel", channelId: r.int53() };
    },
    1656358105: function(r) {
      return { _: "updateNewChannelMessage", message: r.object(), pts: r.int(), ptsCount: r.int() };
    },
    2452516368: function(r) {
      var flags = r.uint();
      return { _: "updateReadChannelInbox", folderId: flags & 1 ? r.int() : void 0, channelId: r.int53(), maxId: r.int(), stillUnreadCount: r.int(), pts: r.int() };
    },
    3274529554: function(r) {
      return { _: "updateDeleteChannelMessages", channelId: r.int53(), messages: r.vector(r.int), pts: r.int(), ptsCount: r.int() };
    },
    4062620680: function(r) {
      return { _: "updateChannelMessageViews", channelId: r.int53(), id: r.int(), views: r.int() };
    },
    3620364706: function(r) {
      return { _: "updateChatParticipantAdmin", chatId: r.int53(), userId: r.int53(), isAdmin: r.boolean(), version: r.int() };
    },
    1753886890: function(r) {
      return { _: "updateNewStickerSet", stickerset: r.object() };
    },
    196268545: function(r) {
      var flags = r.uint();
      return { _: "updateStickerSetsOrder", masks: !!(flags & 1), emojis: !!(flags & 2), order: r.vector(r.long) };
    },
    834816008: function(r) {
      var flags = r.uint();
      return { _: "updateStickerSets", masks: !!(flags & 1), emojis: !!(flags & 2) };
    },
    2473931806: function(r) {
      return { _: "updateSavedGifs" };
    },
    1232025500: function(r) {
      var flags = r.uint();
      return { _: "updateBotInlineQuery", queryId: r.long(), userId: r.int53(), query: r.string(), geo: flags & 1 ? r.object() : void 0, peerType: flags & 2 ? r.object() : void 0, offset: r.string() };
    },
    317794823: function(r) {
      var flags = r.uint();
      return { _: "updateBotInlineSend", userId: r.int53(), query: r.string(), geo: flags & 1 ? r.object() : void 0, id: r.string(), msgId: flags & 2 ? r.object() : void 0 };
    },
    457133559: function(r) {
      return { _: "updateEditChannelMessage", message: r.object(), pts: r.int(), ptsCount: r.int() };
    },
    3117401229: function(r) {
      var flags = r.uint();
      return { _: "updateBotCallbackQuery", queryId: r.long(), userId: r.int53(), peer: r.object(), msgId: r.int(), chatInstance: r.long(), data: flags & 1 ? r.bytes() : void 0, gameShortName: flags & 2 ? r.string() : void 0 };
    },
    3825430691: function(r) {
      return { _: "updateEditMessage", message: r.object(), pts: r.int(), ptsCount: r.int() };
    },
    1763610706: function(r) {
      var flags = r.uint();
      return { _: "updateInlineBotCallbackQuery", queryId: r.long(), userId: r.int53(), msgId: r.object(), chatInstance: r.long(), data: flags & 1 ? r.bytes() : void 0, gameShortName: flags & 2 ? r.string() : void 0 };
    },
    3076495785: function(r) {
      return { _: "updateReadChannelOutbox", channelId: r.int53(), maxId: r.int() };
    },
    457829485: function(r) {
      var flags = r.uint();
      return { _: "updateDraftMessage", peer: r.object(), topMsgId: flags & 1 ? r.int() : void 0, draft: r.object() };
    },
    1461528386: function(r) {
      return { _: "updateReadFeaturedStickers" };
    },
    2588027936: function(r) {
      return { _: "updateRecentStickers" };
    },
    2720652550: function(r) {
      return { _: "updateConfig" };
    },
    861169551: function(r) {
      return { _: "updatePtsChanged" };
    },
    791390623: function(r) {
      return { _: "updateChannelWebPage", channelId: r.int53(), webpage: r.object(), pts: r.int(), ptsCount: r.int() };
    },
    1852826908: function(r) {
      var flags = r.uint();
      return { _: "updateDialogPinned", pinned: !!(flags & 1), folderId: flags & 2 ? r.int() : void 0, peer: r.object() };
    },
    4195302562: function(r) {
      var flags = r.uint();
      return { _: "updatePinnedDialogs", folderId: flags & 2 ? r.int() : void 0, order: flags & 1 ? r.vector(r.object) : void 0 };
    },
    2199371971: function(r) {
      return { _: "updateBotWebhookJSON", data: r.object() };
    },
    2610053286: function(r) {
      return { _: "updateBotWebhookJSONQuery", queryId: r.long(), data: r.object(), timeout: r.int() };
    },
    3048144253: function(r) {
      return { _: "updateBotShippingQuery", queryId: r.long(), userId: r.int53(), payload: r.bytes(), shippingAddress: r.object() };
    },
    2359990934: function(r) {
      var flags = r.uint();
      return { _: "updateBotPrecheckoutQuery", queryId: r.long(), userId: r.int53(), payload: r.bytes(), info: flags & 1 ? r.object() : void 0, shippingOptionId: flags & 2 ? r.string() : void 0, currency: r.string(), totalAmount: r.long() };
    },
    2869914398: function(r) {
      return { _: "updatePhoneCall", phoneCall: r.object() };
    },
    1180041828: function(r) {
      return { _: "updateLangPackTooLong", langCode: r.string() };
    },
    1442983757: function(r) {
      return { _: "updateLangPack", difference: r.object() };
    },
    3843135853: function(r) {
      return { _: "updateFavedStickers" };
    },
    3928556893: function(r) {
      var flags = r.uint();
      return { _: "updateChannelReadMessagesContents", channelId: r.int53(), topMsgId: flags & 1 ? r.int() : void 0, messages: r.vector(r.int) };
    },
    1887741886: function(r) {
      return { _: "updateContactsReset" };
    },
    2990524056: function(r) {
      return { _: "updateChannelAvailableMessages", channelId: r.int53(), availableMinId: r.int() };
    },
    3781450179: function(r) {
      var flags = r.uint();
      return { _: "updateDialogUnreadMark", unread: !!(flags & 1), peer: r.object() };
    },
    2896258427: function(r) {
      var flags = r.uint();
      return { _: "updateMessagePoll", pollId: r.long(), poll: flags & 1 ? r.object() : void 0, results: r.object() };
    },
    1421875280: function(r) {
      return { _: "updateChatDefaultBannedRights", peer: r.object(), defaultBannedRights: r.object(), version: r.int() };
    },
    422972864: function(r) {
      return { _: "updateFolderPeers", folderPeers: r.vector(r.object), pts: r.int(), ptsCount: r.int() };
    },
    1786671974: function(r) {
      return { _: "updatePeerSettings", peer: r.object(), settings: r.object() };
    },
    3031420848: function(r) {
      return { _: "updatePeerLocated", peers: r.vector(r.object) };
    },
    967122427: function(r) {
      return { _: "updateNewScheduledMessage", message: r.object() };
    },
    2424728814: function(r) {
      return { _: "updateDeleteScheduledMessages", peer: r.object(), messages: r.vector(r.int) };
    },
    2182544291: function(r) {
      return { _: "updateTheme", theme: r.object() };
    },
    2267003193: function(r) {
      return { _: "updateGeoLiveViewed", peer: r.object(), msgId: r.int() };
    },
    1448076945: function(r) {
      return { _: "updateLoginToken" };
    },
    619974263: function(r) {
      return { _: "updateMessagePollVote", pollId: r.long(), peer: r.object(), options: r.vector(r.bytes), qts: r.int() };
    },
    654302845: function(r) {
      var flags = r.uint();
      return { _: "updateDialogFilter", id: r.int(), filter: flags & 1 ? r.object() : void 0 };
    },
    2782339333: function(r) {
      return { _: "updateDialogFilterOrder", order: r.vector(r.int) };
    },
    889491791: function(r) {
      return { _: "updateDialogFilters" };
    },
    643940105: function(r) {
      return { _: "updatePhoneCallSignalingData", phoneCallId: r.long(), data: r.bytes() };
    },
    3533318132: function(r) {
      return { _: "updateChannelMessageForwards", channelId: r.int53(), id: r.int(), forwards: r.int() };
    },
    3601962310: function(r) {
      var flags = r.uint();
      return { _: "updateReadChannelDiscussionInbox", channelId: r.int53(), topMsgId: r.int(), readMaxId: r.int(), broadcastId: flags & 1 ? r.int53() : void 0, broadcastPost: flags & 1 ? r.int() : void 0 };
    },
    1767677564: function(r) {
      return { _: "updateReadChannelDiscussionOutbox", channelId: r.int53(), topMsgId: r.int(), readMaxId: r.int() };
    },
    3957356370: function(r) {
      var flags = r.uint();
      return { _: "updatePeerBlocked", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), peerId: r.object() };
    },
    2357774627: function(r) {
      var flags = r.uint();
      return { _: "updateChannelUserTyping", channelId: r.int53(), topMsgId: flags & 1 ? r.int() : void 0, fromId: r.object(), action: r.object() };
    },
    3984976565: function(r) {
      var flags = r.uint();
      return { _: "updatePinnedMessages", pinned: !!(flags & 1), peer: r.object(), messages: r.vector(r.int), pts: r.int(), ptsCount: r.int() };
    },
    1538885128: function(r) {
      var flags = r.uint();
      return { _: "updatePinnedChannelMessages", pinned: !!(flags & 1), channelId: r.int53(), messages: r.vector(r.int), pts: r.int(), ptsCount: r.int() };
    },
    4170869326: function(r) {
      return { _: "updateChat", chatId: r.int53() };
    },
    4075543374: function(r) {
      return { _: "updateGroupCallParticipants", call: r.object(), participants: r.vector(r.object), version: r.int() };
    },
    347227392: function(r) {
      return { _: "updateGroupCall", chatId: r.int53(), call: r.object() };
    },
    3147544997: function(r) {
      var flags = r.uint();
      return { _: "updatePeerHistoryTTL", peer: r.object(), ttlPeriod: flags & 1 ? r.int() : void 0 };
    },
    3498534458: function(r) {
      var flags = r.uint();
      return { _: "updateChatParticipant", chatId: r.int53(), date: r.int(), actorId: r.int53(), userId: r.int53(), prevParticipant: flags & 1 ? r.object() : void 0, newParticipant: flags & 2 ? r.object() : void 0, invite: flags & 4 ? r.object() : void 0, qts: r.int() };
    },
    2556246715: function(r) {
      var flags = r.uint();
      return { _: "updateChannelParticipant", viaChatlist: !!(flags & 8), channelId: r.int53(), date: r.int(), actorId: r.int53(), userId: r.int53(), prevParticipant: flags & 1 ? r.object() : void 0, newParticipant: flags & 2 ? r.object() : void 0, invite: flags & 4 ? r.object() : void 0, qts: r.int() };
    },
    3297184329: function(r) {
      return { _: "updateBotStopped", userId: r.int53(), date: r.int(), stopped: r.boolean(), qts: r.int() };
    },
    192428418: function(r) {
      var flags = r.uint();
      return { _: "updateGroupCallConnection", presentation: !!(flags & 1), params: r.object() };
    },
    1299263278: function(r) {
      return { _: "updateBotCommands", peer: r.object(), botId: r.int53(), commands: r.vector(r.object) };
    },
    1885586395: function(r) {
      return { _: "updatePendingJoinRequests", peer: r.object(), requestsPending: r.int(), recentRequesters: r.vector(r.int53) };
    },
    299870598: function(r) {
      return { _: "updateBotChatInviteRequester", peer: r.object(), date: r.int(), userId: r.int53(), about: r.string(), invite: r.object(), qts: r.int() };
    },
    1578843320: function(r) {
      var flags = r.uint();
      return { _: "updateMessageReactions", peer: r.object(), msgId: r.int(), topMsgId: flags & 1 ? r.int() : void 0, reactions: r.object() };
    },
    397910539: function(r) {
      return { _: "updateAttachMenuBots" };
    },
    361936797: function(r) {
      return { _: "updateWebViewResultSent", queryId: r.long() };
    },
    347625491: function(r) {
      return { _: "updateBotMenuButton", botId: r.int53(), button: r.object() };
    },
    1960361625: function(r) {
      return { _: "updateSavedRingtones" };
    },
    8703322: function(r) {
      var flags = r.uint();
      return { _: "updateTranscribedAudio", pending: !!(flags & 1), peer: r.object(), msgId: r.int(), transcriptionId: r.long(), text: r.string() };
    },
    4216080748: function(r) {
      return { _: "updateReadFeaturedEmojiStickers" };
    },
    674706841: function(r) {
      return { _: "updateUserEmojiStatus", userId: r.int53(), emojiStatus: r.object() };
    },
    821314523: function(r) {
      return { _: "updateRecentEmojiStatuses" };
    },
    1870160884: function(r) {
      return { _: "updateRecentReactions" };
    },
    2264715141: function(r) {
      var flags = r.uint();
      return { _: "updateMoveStickerSetToTop", masks: !!(flags & 1), emojis: !!(flags & 2), stickerset: r.long() };
    },
    3584300836: function(r) {
      return { _: "updateMessageExtendedMedia", peer: r.object(), msgId: r.int(), extendedMedia: r.vector(r.object) };
    },
    422509539: function(r) {
      var flags = r.uint();
      return { _: "updateChannelPinnedTopic", pinned: !!(flags & 1), channelId: r.int53(), topicId: r.int() };
    },
    4263085570: function(r) {
      var flags = r.uint();
      return { _: "updateChannelPinnedTopics", channelId: r.int53(), order: flags & 1 ? r.vector(r.int) : void 0 };
    },
    542282808: function(r) {
      return { _: "updateUser", userId: r.int53() };
    },
    3959795863: function(r) {
      return { _: "updateAutoSaveSettings" };
    },
    1974712216: function(r) {
      return { _: "updateStory", peer: r.object(), story: r.object() };
    },
    4149121835: function(r) {
      return { _: "updateReadStories", peer: r.object(), maxId: r.int() };
    },
    468923833: function(r) {
      return { _: "updateStoryID", id: r.int(), randomId: r.long() };
    },
    738741697: function(r) {
      return { _: "updateStoriesStealthMode", stealthMode: r.object() };
    },
    2103604867: function(r) {
      return { _: "updateSentStoryReaction", peer: r.object(), storyId: r.int(), reaction: r.object() };
    },
    2421019804: function(r) {
      return { _: "updateBotChatBoost", peer: r.object(), boost: r.object(), qts: r.int() };
    },
    129403168: function(r) {
      return { _: "updateChannelViewForumAsMessages", channelId: r.int53(), enabled: r.boolean() };
    },
    2923368477: function(r) {
      var flags = r.uint();
      return { _: "updatePeerWallpaper", wallpaperOverridden: !!(flags & 2), peer: r.object(), wallpaper: flags & 1 ? r.object() : void 0 };
    },
    2887898062: function(r) {
      return { _: "updateBotMessageReaction", peer: r.object(), msgId: r.int(), date: r.int(), actor: r.object(), oldReactions: r.vector(r.object), newReactions: r.vector(r.object), qts: r.int() };
    },
    164329305: function(r) {
      return { _: "updateBotMessageReactions", peer: r.object(), msgId: r.int(), date: r.int(), reactions: r.vector(r.object), qts: r.int() };
    },
    2930744948: function(r) {
      var flags = r.uint();
      return { _: "updateSavedDialogPinned", pinned: !!(flags & 1), peer: r.object() };
    },
    1751942566: function(r) {
      var flags = r.uint();
      return { _: "updatePinnedSavedDialogs", order: flags & 1 ? r.vector(r.object) : void 0 };
    },
    969307186: function(r) {
      return { _: "updateSavedReactionTags" };
    },
    4049758676: function(r) {
      return { _: "updateSmsJob", jobId: r.string() };
    },
    4182182578: function(r) {
      return { _: "updateQuickReplies", quickReplies: r.vector(r.object) };
    },
    4114458391: function(r) {
      return { _: "updateNewQuickReply", quickReply: r.object() };
    },
    1407644140: function(r) {
      return { _: "updateDeleteQuickReply", shortcutId: r.int() };
    },
    1040518415: function(r) {
      return { _: "updateQuickReplyMessage", message: r.object() };
    },
    1450174413: function(r) {
      return { _: "updateDeleteQuickReplyMessages", shortcutId: r.int(), messages: r.vector(r.int) };
    },
    2330315130: function(r) {
      return { _: "updateBotBusinessConnect", connection: r.object(), qts: r.int() };
    },
    2648388732: function(r) {
      var flags = r.uint();
      return { _: "updateBotNewBusinessMessage", connectionId: r.string(), message: r.object(), replyToMessage: flags & 1 ? r.object() : void 0, qts: r.int() };
    },
    132077692: function(r) {
      var flags = r.uint();
      return { _: "updateBotEditBusinessMessage", connectionId: r.string(), message: r.object(), replyToMessage: flags & 1 ? r.object() : void 0, qts: r.int() };
    },
    2687146030: function(r) {
      return { _: "updateBotDeleteBusinessMessage", connectionId: r.string(), peer: r.object(), messages: r.vector(r.int), qts: r.int() };
    },
    405070859: function(r) {
      return { _: "updateNewStoryReaction", storyId: r.int(), peer: r.object(), reaction: r.object() };
    },
    3755565557: function(r) {
      return { _: "updateBroadcastRevenueTransactions", peer: r.object(), balances: r.object() };
    },
    263737752: function(r) {
      return { _: "updateStarsBalance", balance: r.long() };
    },
    513998247: function(r) {
      var flags = r.uint();
      return { _: "updateBusinessBotCallbackQuery", queryId: r.long(), userId: r.int53(), connectionId: r.string(), message: r.object(), replyToMessage: flags & 4 ? r.object() : void 0, chatInstance: r.long(), data: flags & 1 ? r.bytes() : void 0 };
    },
    2776936473: function(r) {
      return { _: "updateStarsRevenueStatus", peer: r.object(), status: r.object() };
    },
    675009298: function(r) {
      return { _: "updateBotPurchasedPaidMedia", userId: r.int53(), payload: r.string(), qts: r.int() };
    },
    1372224236: function(r) {
      return { _: "updatePaidReactionPrivacy", private: r.boolean() };
    },
    2775329342: function(r) {
      return { _: "updates.state", pts: r.int(), qts: r.int(), date: r.int(), seq: r.int(), unreadCount: r.int() };
    },
    1567990072: function(r) {
      return { _: "updates.differenceEmpty", date: r.int(), seq: r.int() };
    },
    16030880: function(r) {
      return { _: "updates.difference", newMessages: r.vector(r.object), newEncryptedMessages: r.vector(r.object), otherUpdates: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), state: r.object() };
    },
    2835028353: function(r) {
      return { _: "updates.differenceSlice", newMessages: r.vector(r.object), newEncryptedMessages: r.vector(r.object), otherUpdates: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), intermediateState: r.object() };
    },
    1258196845: function(r) {
      return { _: "updates.differenceTooLong", pts: r.int() };
    },
    3809980286: function(r) {
      return { _: "updatesTooLong" };
    },
    826001400: function(r) {
      var flags = r.uint();
      return { _: "updateShortMessage", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), id: r.int(), userId: r.int53(), message: r.string(), pts: r.int(), ptsCount: r.int(), date: r.int(), fwdFrom: flags & 4 ? r.object() : void 0, viaBotId: flags & 2048 ? r.int53() : void 0, replyTo: flags & 8 ? r.object() : void 0, entities: flags & 128 ? r.vector(r.object) : void 0, ttlPeriod: flags & 33554432 ? r.int() : void 0 };
    },
    1299050149: function(r) {
      var flags = r.uint();
      return { _: "updateShortChatMessage", out: !!(flags & 2), mentioned: !!(flags & 16), mediaUnread: !!(flags & 32), silent: !!(flags & 8192), id: r.int(), fromId: r.int53(), chatId: r.int53(), message: r.string(), pts: r.int(), ptsCount: r.int(), date: r.int(), fwdFrom: flags & 4 ? r.object() : void 0, viaBotId: flags & 2048 ? r.int53() : void 0, replyTo: flags & 8 ? r.object() : void 0, entities: flags & 128 ? r.vector(r.object) : void 0, ttlPeriod: flags & 33554432 ? r.int() : void 0 };
    },
    2027216577: function(r) {
      return { _: "updateShort", update: r.object(), date: r.int() };
    },
    1918567619: function(r) {
      return { _: "updatesCombined", updates: r.vector(r.object), users: r.vector(r.object), chats: r.vector(r.object), date: r.int(), seqStart: r.int(), seq: r.int() };
    },
    1957577280: function(r) {
      return { _: "updates", updates: r.vector(r.object), users: r.vector(r.object), chats: r.vector(r.object), date: r.int(), seq: r.int() };
    },
    2417352961: function(r) {
      var flags = r.uint();
      return { _: "updateShortSentMessage", out: !!(flags & 2), id: r.int(), pts: r.int(), ptsCount: r.int(), date: r.int(), media: flags & 512 ? r.object() : void 0, entities: flags & 128 ? r.vector(r.object) : void 0, ttlPeriod: flags & 33554432 ? r.int() : void 0 };
    },
    2378853029: function(r) {
      return { _: "photos.photos", photos: r.vector(r.object), users: r.vector(r.object) };
    },
    352657236: function(r) {
      return { _: "photos.photosSlice", count: r.int(), photos: r.vector(r.object), users: r.vector(r.object) };
    },
    539045032: function(r) {
      return { _: "photos.photo", photo: r.object(), users: r.vector(r.object) };
    },
    157948117: function(r) {
      return { _: "upload.file", type: r.object(), mtime: r.int(), bytes: r.bytes() };
    },
    4052539972: function(r) {
      return { _: "upload.fileCdnRedirect", dcId: r.int(), fileToken: r.bytes(), encryptionKey: r.bytes(), encryptionIv: r.bytes(), fileHashes: r.vector(r.object) };
    },
    414687501: function(r) {
      var flags = r.uint();
      return { _: "dcOption", ipv6: !!(flags & 1), mediaOnly: !!(flags & 2), tcpoOnly: !!(flags & 4), cdn: !!(flags & 8), static: !!(flags & 16), thisPortOnly: !!(flags & 32), id: r.int(), ipAddress: r.string(), port: r.int(), secret: flags & 1024 ? r.bytes() : void 0 };
    },
    3424265246: function(r) {
      var flags = r.uint();
      return { _: "config", defaultP2pContacts: !!(flags & 8), preloadFeaturedStickers: !!(flags & 16), revokePmInbox: !!(flags & 64), blockedMode: !!(flags & 256), forceTryIpv6: !!(flags & 16384), date: r.int(), expires: r.int(), testMode: r.boolean(), thisDc: r.int(), dcOptions: r.vector(r.object), dcTxtDomainName: r.string(), chatSizeMax: r.int(), megagroupSizeMax: r.int(), forwardedCountMax: r.int(), onlineUpdatePeriodMs: r.int(), offlineBlurTimeoutMs: r.int(), offlineIdleTimeoutMs: r.int(), onlineCloudTimeoutMs: r.int(), notifyCloudDelayMs: r.int(), notifyDefaultDelayMs: r.int(), pushChatPeriodMs: r.int(), pushChatLimit: r.int(), editTimeLimit: r.int(), revokeTimeLimit: r.int(), revokePmTimeLimit: r.int(), ratingEDecay: r.int(), stickersRecentLimit: r.int(), channelsReadMediaPeriod: r.int(), tmpSessions: flags & 1 ? r.int() : void 0, callReceiveTimeoutMs: r.int(), callRingTimeoutMs: r.int(), callConnectTimeoutMs: r.int(), callPacketTimeoutMs: r.int(), meUrlPrefix: r.string(), autoupdateUrlPrefix: flags & 128 ? r.string() : void 0, gifSearchUsername: flags & 512 ? r.string() : void 0, venueSearchUsername: flags & 1024 ? r.string() : void 0, imgSearchUsername: flags & 2048 ? r.string() : void 0, staticMapsProvider: flags & 4096 ? r.string() : void 0, captionLengthMax: r.int(), messageLengthMax: r.int(), webfileDcId: r.int(), suggestedLangCode: flags & 4 ? r.string() : void 0, langPackVersion: flags & 4 ? r.int() : void 0, baseLangPackVersion: flags & 4 ? r.int() : void 0, reactionsDefault: flags & 32768 ? r.object() : void 0, autologinToken: flags & 65536 ? r.string() : void 0 };
    },
    2384074613: function(r) {
      return { _: "nearestDc", country: r.string(), thisDc: r.int(), nearestDc: r.int() };
    },
    3434860080: function(r) {
      var flags = r.uint();
      return { _: "help.appUpdate", canNotSkip: !!(flags & 1), id: r.int(), version: r.string(), text: r.string(), entities: r.vector(r.object), document: flags & 2 ? r.object() : void 0, url: flags & 4 ? r.string() : void 0, sticker: flags & 8 ? r.object() : void 0 };
    },
    3294258486: function(r) {
      return { _: "help.noAppUpdate" };
    },
    415997816: function(r) {
      return { _: "help.inviteText", message: r.string() };
    },
    2877210784: function(r) {
      return { _: "encryptedChatEmpty", id: r.int() };
    },
    1722964307: function(r) {
      return { _: "encryptedChatWaiting", id: r.int(), accessHash: r.long(), date: r.int(), adminId: r.int53(), participantId: r.int53() };
    },
    1223809356: function(r) {
      var flags = r.uint();
      return { _: "encryptedChatRequested", folderId: flags & 1 ? r.int() : void 0, id: r.int(), accessHash: r.long(), date: r.int(), adminId: r.int53(), participantId: r.int53(), gA: r.bytes() };
    },
    1643173063: function(r) {
      return { _: "encryptedChat", id: r.int(), accessHash: r.long(), date: r.int(), adminId: r.int53(), participantId: r.int53(), gAOrB: r.bytes(), keyFingerprint: r.long() };
    },
    505183301: function(r) {
      var flags = r.uint();
      return { _: "encryptedChatDiscarded", historyDeleted: !!(flags & 1), id: r.int() };
    },
    4047615457: function(r) {
      return { _: "inputEncryptedChat", chatId: r.int(), accessHash: r.long() };
    },
    3256830334: function(r) {
      return { _: "encryptedFileEmpty" };
    },
    2818608344: function(r) {
      return { _: "encryptedFile", id: r.long(), accessHash: r.long(), size: r.int53(), dcId: r.int(), keyFingerprint: r.int() };
    },
    406307684: function(r) {
      return { _: "inputEncryptedFileEmpty" };
    },
    1690108678: function(r) {
      return { _: "inputEncryptedFileUploaded", id: r.long(), parts: r.int(), md5Checksum: r.string(), keyFingerprint: r.int() };
    },
    1511503333: function(r) {
      return { _: "inputEncryptedFile", id: r.long(), accessHash: r.long() };
    },
    767652808: function(r) {
      return { _: "inputEncryptedFileBigUploaded", id: r.long(), parts: r.int(), keyFingerprint: r.int() };
    },
    3977822488: function(r) {
      return { _: "encryptedMessage", randomId: r.long(), chatId: r.int(), date: r.int(), bytes: r.bytes(), file: r.object() };
    },
    594758406: function(r) {
      return { _: "encryptedMessageService", randomId: r.long(), chatId: r.int(), date: r.int(), bytes: r.bytes() };
    },
    3236054581: function(r) {
      return { _: "messages.dhConfigNotModified", random: r.bytes() };
    },
    740433629: function(r) {
      return { _: "messages.dhConfig", g: r.int(), p: r.bytes(), version: r.int(), random: r.bytes() };
    },
    1443858741: function(r) {
      return { _: "messages.sentEncryptedMessage", date: r.int() };
    },
    2492727090: function(r) {
      return { _: "messages.sentEncryptedFile", date: r.int(), file: r.object() };
    },
    1928391342: function(r) {
      return { _: "inputDocumentEmpty" };
    },
    448771445: function(r) {
      return { _: "inputDocument", id: r.long(), accessHash: r.long(), fileReference: r.bytes() };
    },
    922273905: function(r) {
      return { _: "documentEmpty", id: r.long() };
    },
    2413085912: function(r) {
      var flags = r.uint();
      return { _: "document", id: r.long(), accessHash: r.long(), fileReference: r.bytes(), date: r.int(), mimeType: r.string(), size: r.int53(), thumbs: flags & 1 ? r.vector(r.object) : void 0, videoThumbs: flags & 2 ? r.vector(r.object) : void 0, dcId: r.int(), attributes: r.vector(r.object) };
    },
    398898678: function(r) {
      return { _: "help.support", phoneNumber: r.string(), user: r.object() };
    },
    2681474008: function(r) {
      return { _: "notifyPeer", peer: r.object() };
    },
    3033021260: function(r) {
      return { _: "notifyUsers" };
    },
    3221737155: function(r) {
      return { _: "notifyChats" };
    },
    3591563503: function(r) {
      return { _: "notifyBroadcasts" };
    },
    577659656: function(r) {
      return { _: "notifyForumTopic", peer: r.object(), topMsgId: r.int() };
    },
    381645902: function(r) {
      return { _: "sendMessageTypingAction" };
    },
    4250847477: function(r) {
      return { _: "sendMessageCancelAction" };
    },
    2710034031: function(r) {
      return { _: "sendMessageRecordVideoAction" };
    },
    3916839660: function(r) {
      return { _: "sendMessageUploadVideoAction", progress: r.int() };
    },
    3576656887: function(r) {
      return { _: "sendMessageRecordAudioAction" };
    },
    4082227115: function(r) {
      return { _: "sendMessageUploadAudioAction", progress: r.int() };
    },
    3520285222: function(r) {
      return { _: "sendMessageUploadPhotoAction", progress: r.int() };
    },
    2852968932: function(r) {
      return { _: "sendMessageUploadDocumentAction", progress: r.int() };
    },
    393186209: function(r) {
      return { _: "sendMessageGeoLocationAction" };
    },
    1653390447: function(r) {
      return { _: "sendMessageChooseContactAction" };
    },
    3714748232: function(r) {
      return { _: "sendMessageGamePlayAction" };
    },
    2297593788: function(r) {
      return { _: "sendMessageRecordRoundAction" };
    },
    608050278: function(r) {
      return { _: "sendMessageUploadRoundAction", progress: r.int() };
    },
    3643548293: function(r) {
      return { _: "speakingInGroupCallAction" };
    },
    3688534598: function(r) {
      return { _: "sendMessageHistoryImportAction", progress: r.int() };
    },
    2958739121: function(r) {
      return { _: "sendMessageChooseStickerAction" };
    },
    630664139: function(r) {
      return { _: "sendMessageEmojiInteraction", emoticon: r.string(), msgId: r.int(), interaction: r.object() };
    },
    3060109358: function(r) {
      return { _: "sendMessageEmojiInteractionSeen", emoticon: r.string() };
    },
    3004386717: function(r) {
      return { _: "contacts.found", myResults: r.vector(r.object), results: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1335282456: function(r) {
      return { _: "inputPrivacyKeyStatusTimestamp" };
    },
    3187344422: function(r) {
      return { _: "inputPrivacyKeyChatInvite" };
    },
    4206550111: function(r) {
      return { _: "inputPrivacyKeyPhoneCall" };
    },
    3684593874: function(r) {
      return { _: "inputPrivacyKeyPhoneP2P" };
    },
    2765966344: function(r) {
      return { _: "inputPrivacyKeyForwards" };
    },
    1461304012: function(r) {
      return { _: "inputPrivacyKeyProfilePhoto" };
    },
    55761658: function(r) {
      return { _: "inputPrivacyKeyPhoneNumber" };
    },
    3508640733: function(r) {
      return { _: "inputPrivacyKeyAddedByPhone" };
    },
    2934349160: function(r) {
      return { _: "inputPrivacyKeyVoiceMessages" };
    },
    941870144: function(r) {
      return { _: "inputPrivacyKeyAbout" };
    },
    3596227020: function(r) {
      return { _: "inputPrivacyKeyBirthday" };
    },
    3157175088: function(r) {
      return { _: "privacyKeyStatusTimestamp" };
    },
    1343122938: function(r) {
      return { _: "privacyKeyChatInvite" };
    },
    1030105979: function(r) {
      return { _: "privacyKeyPhoneCall" };
    },
    961092808: function(r) {
      return { _: "privacyKeyPhoneP2P" };
    },
    1777096355: function(r) {
      return { _: "privacyKeyForwards" };
    },
    2517966829: function(r) {
      return { _: "privacyKeyProfilePhoto" };
    },
    3516589165: function(r) {
      return { _: "privacyKeyPhoneNumber" };
    },
    1124062251: function(r) {
      return { _: "privacyKeyAddedByPhone" };
    },
    110621716: function(r) {
      return { _: "privacyKeyVoiceMessages" };
    },
    2760292193: function(r) {
      return { _: "privacyKeyAbout" };
    },
    536913176: function(r) {
      return { _: "privacyKeyBirthday" };
    },
    218751099: function(r) {
      return { _: "inputPrivacyValueAllowContacts" };
    },
    407582158: function(r) {
      return { _: "inputPrivacyValueAllowAll" };
    },
    320652927: function(r) {
      return { _: "inputPrivacyValueAllowUsers", users: r.vector(r.object) };
    },
    195371015: function(r) {
      return { _: "inputPrivacyValueDisallowContacts" };
    },
    3597362889: function(r) {
      return { _: "inputPrivacyValueDisallowAll" };
    },
    2417034343: function(r) {
      return { _: "inputPrivacyValueDisallowUsers", users: r.vector(r.object) };
    },
    2215004623: function(r) {
      return { _: "inputPrivacyValueAllowChatParticipants", chats: r.vector(r.int53) };
    },
    3914272646: function(r) {
      return { _: "inputPrivacyValueDisallowChatParticipants", chats: r.vector(r.int53) };
    },
    793067081: function(r) {
      return { _: "inputPrivacyValueAllowCloseFriends" };
    },
    2009975281: function(r) {
      return { _: "inputPrivacyValueAllowPremium" };
    },
    4294843308: function(r) {
      return { _: "privacyValueAllowContacts" };
    },
    1698855810: function(r) {
      return { _: "privacyValueAllowAll" };
    },
    3096469426: function(r) {
      return { _: "privacyValueAllowUsers", users: r.vector(r.int53) };
    },
    4169726490: function(r) {
      return { _: "privacyValueDisallowContacts" };
    },
    2339628899: function(r) {
      return { _: "privacyValueDisallowAll" };
    },
    3831632193: function(r) {
      return { _: "privacyValueDisallowUsers", users: r.vector(r.int53) };
    },
    1796427406: function(r) {
      return { _: "privacyValueAllowChatParticipants", chats: r.vector(r.int53) };
    },
    1103656293: function(r) {
      return { _: "privacyValueDisallowChatParticipants", chats: r.vector(r.int53) };
    },
    4159232155: function(r) {
      return { _: "privacyValueAllowCloseFriends" };
    },
    3974725963: function(r) {
      return { _: "privacyValueAllowPremium" };
    },
    1352683077: function(r) {
      return { _: "account.privacyRules", rules: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3100684255: function(r) {
      return { _: "accountDaysTTL", days: r.int() };
    },
    1815593308: function(r) {
      return { _: "documentAttributeImageSize", w: r.int(), h: r.int() };
    },
    297109817: function(r) {
      return { _: "documentAttributeAnimated" };
    },
    1662637586: function(r) {
      var flags = r.uint();
      return { _: "documentAttributeSticker", mask: !!(flags & 2), alt: r.string(), stickerset: r.object(), maskCoords: flags & 1 ? r.object() : void 0 };
    },
    1137015880: function(r) {
      var flags = r.uint();
      return { _: "documentAttributeVideo", roundMessage: !!(flags & 1), supportsStreaming: !!(flags & 2), nosound: !!(flags & 8), duration: r.double(), w: r.int(), h: r.int(), preloadPrefixSize: flags & 4 ? r.int() : void 0, videoStartTs: flags & 16 ? r.double() : void 0, videoCodec: flags & 32 ? r.string() : void 0 };
    },
    2555574726: function(r) {
      var flags = r.uint();
      return { _: "documentAttributeAudio", voice: !!(flags & 1024), duration: r.int(), title: flags & 1 ? r.string() : void 0, performer: flags & 2 ? r.string() : void 0, waveform: flags & 4 ? r.bytes() : void 0 };
    },
    358154344: function(r) {
      return { _: "documentAttributeFilename", fileName: r.string() };
    },
    2550256375: function(r) {
      return { _: "documentAttributeHasStickers" };
    },
    4245985433: function(r) {
      var flags = r.uint();
      return { _: "documentAttributeCustomEmoji", free: !!(flags & 1), textColor: !!(flags & 2), alt: r.string(), stickerset: r.object() };
    },
    4050950690: function(r) {
      return { _: "messages.stickersNotModified" };
    },
    816245886: function(r) {
      return { _: "messages.stickers", hash: r.long(), stickers: r.vector(r.object) };
    },
    313694676: function(r) {
      return { _: "stickerPack", emoticon: r.string(), documents: r.vector(r.long) };
    },
    3898999491: function(r) {
      return { _: "messages.allStickersNotModified" };
    },
    3451637435: function(r) {
      return { _: "messages.allStickers", hash: r.long(), sets: r.vector(r.object) };
    },
    2228326789: function(r) {
      return { _: "messages.affectedMessages", pts: r.int(), ptsCount: r.int() };
    },
    555358088: function(r) {
      var flags = r.uint();
      return { _: "webPageEmpty", id: r.long(), url: flags & 1 ? r.string() : void 0 };
    },
    2966502983: function(r) {
      var flags = r.uint();
      return { _: "webPagePending", id: r.long(), url: flags & 1 ? r.string() : void 0, date: r.int() };
    },
    3902555570: function(r) {
      var flags = r.uint();
      return { _: "webPage", hasLargeMedia: !!(flags & 8192), id: r.long(), url: r.string(), displayUrl: r.string(), hash: r.int(), type: flags & 1 ? r.string() : void 0, siteName: flags & 2 ? r.string() : void 0, title: flags & 4 ? r.string() : void 0, description: flags & 8 ? r.string() : void 0, photo: flags & 16 ? r.object() : void 0, embedUrl: flags & 32 ? r.string() : void 0, embedType: flags & 32 ? r.string() : void 0, embedWidth: flags & 64 ? r.int() : void 0, embedHeight: flags & 64 ? r.int() : void 0, duration: flags & 128 ? r.int() : void 0, author: flags & 256 ? r.string() : void 0, document: flags & 512 ? r.object() : void 0, cachedPage: flags & 1024 ? r.object() : void 0, attributes: flags & 4096 ? r.vector(r.object) : void 0 };
    },
    1930545681: function(r) {
      var flags = r.uint();
      return { _: "webPageNotModified", cachedPageViews: flags & 1 ? r.int() : void 0 };
    },
    2902578717: function(r) {
      var flags = r.uint();
      return { _: "authorization", current: !!(flags & 1), officialApp: !!(flags & 2), passwordPending: !!(flags & 4), encryptedRequestsDisabled: !!(flags & 8), callRequestsDisabled: !!(flags & 16), unconfirmed: !!(flags & 32), hash: r.long(), deviceModel: r.string(), platform: r.string(), systemVersion: r.string(), apiId: r.int(), appName: r.string(), appVersion: r.string(), dateCreated: r.int(), dateActive: r.int(), ip: r.string(), country: r.string(), region: r.string() };
    },
    1275039392: function(r) {
      return { _: "account.authorizations", authorizationTtlDays: r.int(), authorizations: r.vector(r.object) };
    },
    2507886843: function(r) {
      var flags = r.uint();
      return { _: "account.password", hasRecovery: !!(flags & 1), hasSecureValues: !!(flags & 2), hasPassword: !!(flags & 4), currentAlgo: flags & 4 ? r.object() : void 0, srpB: flags & 4 ? r.bytes() : void 0, srpId: flags & 4 ? r.long() : void 0, hint: flags & 8 ? r.string() : void 0, emailUnconfirmedPattern: flags & 16 ? r.string() : void 0, newAlgo: r.object(), newSecureAlgo: r.object(), secureRandom: r.bytes(), pendingResetDate: flags & 32 ? r.int() : void 0, loginEmailPattern: flags & 64 ? r.string() : void 0 };
    },
    2589733861: function(r) {
      var flags = r.uint();
      return { _: "account.passwordSettings", email: flags & 1 ? r.string() : void 0, secureSettings: flags & 2 ? r.object() : void 0 };
    },
    3258394569: function(r) {
      var flags = r.uint();
      return { _: "account.passwordInputSettings", newAlgo: flags & 1 ? r.object() : void 0, newPasswordHash: flags & 1 ? r.bytes() : void 0, hint: flags & 1 ? r.string() : void 0, email: flags & 2 ? r.string() : void 0, newSecureSettings: flags & 4 ? r.object() : void 0 };
    },
    326715557: function(r) {
      return { _: "auth.passwordRecovery", emailPattern: r.string() };
    },
    2743383929: function(r) {
      return { _: "receivedNotifyMessage", id: r.int(), flags: r.int() };
    },
    2720841110: function(r) {
      var flags = r.uint();
      return { _: "chatInviteExported", revoked: !!(flags & 1), permanent: !!(flags & 32), requestNeeded: !!(flags & 64), link: r.string(), adminId: r.int53(), date: r.int(), startDate: flags & 16 ? r.int() : void 0, expireDate: flags & 2 ? r.int() : void 0, usageLimit: flags & 4 ? r.int() : void 0, usage: flags & 8 ? r.int() : void 0, requested: flags & 128 ? r.int() : void 0, subscriptionExpired: flags & 1024 ? r.int() : void 0, title: flags & 256 ? r.string() : void 0, subscriptionPricing: flags & 512 ? r.object() : void 0 };
    },
    3977280183: function(r) {
      return { _: "chatInvitePublicJoinRequests" };
    },
    1516793212: function(r) {
      return { _: "chatInviteAlready", chat: r.object() };
    },
    4268046493: function(r) {
      var flags = r.uint();
      return { _: "chatInvite", channel: !!(flags & 1), broadcast: !!(flags & 2), public: !!(flags & 4), megagroup: !!(flags & 8), requestNeeded: !!(flags & 64), verified: !!(flags & 128), scam: !!(flags & 256), fake: !!(flags & 512), canRefulfillSubscription: !!(flags & 2048), title: r.string(), about: flags & 32 ? r.string() : void 0, photo: r.object(), participantsCount: r.int(), participants: flags & 16 ? r.vector(r.object) : void 0, color: r.int(), subscriptionPricing: flags & 1024 ? r.object() : void 0, subscriptionFormId: flags & 4096 ? r.long() : void 0 };
    },
    1634294960: function(r) {
      return { _: "chatInvitePeek", chat: r.object(), expires: r.int() };
    },
    4290128789: function(r) {
      return { _: "inputStickerSetEmpty" };
    },
    2649203305: function(r) {
      return { _: "inputStickerSetID", id: r.long(), accessHash: r.long() };
    },
    2250033312: function(r) {
      return { _: "inputStickerSetShortName", shortName: r.string() };
    },
    42402760: function(r) {
      return { _: "inputStickerSetAnimatedEmoji" };
    },
    3867103758: function(r) {
      return { _: "inputStickerSetDice", emoticon: r.string() };
    },
    215889721: function(r) {
      return { _: "inputStickerSetAnimatedEmojiAnimations" };
    },
    3364567810: function(r) {
      return { _: "inputStickerSetPremiumGifts" };
    },
    80008398: function(r) {
      return { _: "inputStickerSetEmojiGenericAnimations" };
    },
    701560302: function(r) {
      return { _: "inputStickerSetEmojiDefaultStatuses" };
    },
    1153562857: function(r) {
      return { _: "inputStickerSetEmojiDefaultTopicIcons" };
    },
    1232373075: function(r) {
      return { _: "inputStickerSetEmojiChannelDefaultStatuses" };
    },
    768691932: function(r) {
      var flags = r.uint();
      return { _: "stickerSet", archived: !!(flags & 2), official: !!(flags & 4), masks: !!(flags & 8), emojis: !!(flags & 128), textColor: !!(flags & 512), channelEmojiStatus: !!(flags & 1024), creator: !!(flags & 2048), installedDate: flags & 1 ? r.int() : void 0, id: r.long(), accessHash: r.long(), title: r.string(), shortName: r.string(), thumbs: flags & 16 ? r.vector(r.object) : void 0, thumbDcId: flags & 16 ? r.int() : void 0, thumbVersion: flags & 16 ? r.int() : void 0, thumbDocumentId: flags & 256 ? r.long() : void 0, count: r.int(), hash: r.int() };
    },
    1846886166: function(r) {
      return { _: "messages.stickerSet", set: r.object(), packs: r.vector(r.object), keywords: r.vector(r.object), documents: r.vector(r.object) };
    },
    3556320491: function(r) {
      return { _: "messages.stickerSetNotModified" };
    },
    3262826695: function(r) {
      return { _: "botCommand", command: r.string(), description: r.string() };
    },
    2185461364: function(r) {
      var flags = r.uint();
      return { _: "botInfo", hasPreviewMedias: !!(flags & 64), userId: flags & 1 ? r.int53() : void 0, description: flags & 2 ? r.string() : void 0, descriptionPhoto: flags & 16 ? r.object() : void 0, descriptionDocument: flags & 32 ? r.object() : void 0, commands: flags & 4 ? r.vector(r.object) : void 0, menuButton: flags & 8 ? r.object() : void 0, privacyPolicyUrl: flags & 128 ? r.string() : void 0 };
    },
    2734311552: function(r) {
      return { _: "keyboardButton", text: r.string() };
    },
    629866245: function(r) {
      return { _: "keyboardButtonUrl", text: r.string(), url: r.string() };
    },
    901503851: function(r) {
      var flags = r.uint();
      return { _: "keyboardButtonCallback", requiresPassword: !!(flags & 1), text: r.string(), data: r.bytes() };
    },
    2976541737: function(r) {
      return { _: "keyboardButtonRequestPhone", text: r.string() };
    },
    4235815743: function(r) {
      return { _: "keyboardButtonRequestGeoLocation", text: r.string() };
    },
    2478439349: function(r) {
      var flags = r.uint();
      return { _: "keyboardButtonSwitchInline", samePeer: !!(flags & 1), text: r.string(), query: r.string(), peerTypes: flags & 2 ? r.vector(r.object) : void 0 };
    },
    1358175439: function(r) {
      return { _: "keyboardButtonGame", text: r.string() };
    },
    2950250427: function(r) {
      return { _: "keyboardButtonBuy", text: r.string() };
    },
    280464681: function(r) {
      var flags = r.uint();
      return { _: "keyboardButtonUrlAuth", text: r.string(), fwdText: flags & 1 ? r.string() : void 0, url: r.string(), buttonId: r.int() };
    },
    3492708308: function(r) {
      var flags = r.uint();
      return { _: "inputKeyboardButtonUrlAuth", requestWriteAccess: !!(flags & 1), text: r.string(), fwdText: flags & 2 ? r.string() : void 0, url: r.string(), bot: r.object() };
    },
    3150401885: function(r) {
      var flags = r.uint();
      return { _: "keyboardButtonRequestPoll", quiz: flags & 1 ? r.boolean() : void 0, text: r.string() };
    },
    3918005115: function(r) {
      return { _: "inputKeyboardButtonUserProfile", text: r.string(), userId: r.object() };
    },
    814112961: function(r) {
      return { _: "keyboardButtonUserProfile", text: r.string(), userId: r.int53() };
    },
    326529584: function(r) {
      return { _: "keyboardButtonWebView", text: r.string(), url: r.string() };
    },
    2696958044: function(r) {
      return { _: "keyboardButtonSimpleWebView", text: r.string(), url: r.string() };
    },
    1406648280: function(r) {
      return { _: "keyboardButtonRequestPeer", text: r.string(), buttonId: r.int(), peerType: r.object(), maxQuantity: r.int() };
    },
    3378916613: function(r) {
      var flags = r.uint();
      return { _: "inputKeyboardButtonRequestPeer", nameRequested: !!(flags & 1), usernameRequested: !!(flags & 2), photoRequested: !!(flags & 4), text: r.string(), buttonId: r.int(), peerType: r.object(), maxQuantity: r.int() };
    },
    1976723854: function(r) {
      return { _: "keyboardButtonCopy", text: r.string(), copyText: r.string() };
    },
    2002815875: function(r) {
      return { _: "keyboardButtonRow", buttons: r.vector(r.object) };
    },
    2688441221: function(r) {
      var flags = r.uint();
      return { _: "replyKeyboardHide", selective: !!(flags & 4) };
    },
    2259946248: function(r) {
      var flags = r.uint();
      return { _: "replyKeyboardForceReply", singleUse: !!(flags & 2), selective: !!(flags & 4), placeholder: flags & 8 ? r.string() : void 0 };
    },
    2245892561: function(r) {
      var flags = r.uint();
      return { _: "replyKeyboardMarkup", resize: !!(flags & 1), singleUse: !!(flags & 2), selective: !!(flags & 4), persistent: !!(flags & 16), rows: r.vector(r.object), placeholder: flags & 8 ? r.string() : void 0 };
    },
    1218642516: function(r) {
      return { _: "replyInlineMarkup", rows: r.vector(r.object) };
    },
    3146955413: function(r) {
      return { _: "messageEntityUnknown", offset: r.int(), length: r.int() };
    },
    4194588573: function(r) {
      return { _: "messageEntityMention", offset: r.int(), length: r.int() };
    },
    1868782349: function(r) {
      return { _: "messageEntityHashtag", offset: r.int(), length: r.int() };
    },
    1827637959: function(r) {
      return { _: "messageEntityBotCommand", offset: r.int(), length: r.int() };
    },
    1859134776: function(r) {
      return { _: "messageEntityUrl", offset: r.int(), length: r.int() };
    },
    1692693954: function(r) {
      return { _: "messageEntityEmail", offset: r.int(), length: r.int() };
    },
    3177253833: function(r) {
      return { _: "messageEntityBold", offset: r.int(), length: r.int() };
    },
    2188348256: function(r) {
      return { _: "messageEntityItalic", offset: r.int(), length: r.int() };
    },
    681706865: function(r) {
      return { _: "messageEntityCode", offset: r.int(), length: r.int() };
    },
    1938967520: function(r) {
      return { _: "messageEntityPre", offset: r.int(), length: r.int(), language: r.string() };
    },
    1990644519: function(r) {
      return { _: "messageEntityTextUrl", offset: r.int(), length: r.int(), url: r.string() };
    },
    3699052864: function(r) {
      return { _: "messageEntityMentionName", offset: r.int(), length: r.int(), userId: r.int53() };
    },
    546203849: function(r) {
      return { _: "inputMessageEntityMentionName", offset: r.int(), length: r.int(), userId: r.object() };
    },
    2607407947: function(r) {
      return { _: "messageEntityPhone", offset: r.int(), length: r.int() };
    },
    1280209983: function(r) {
      return { _: "messageEntityCashtag", offset: r.int(), length: r.int() };
    },
    2622389899: function(r) {
      return { _: "messageEntityUnderline", offset: r.int(), length: r.int() };
    },
    3204879316: function(r) {
      return { _: "messageEntityStrike", offset: r.int(), length: r.int() };
    },
    1981704948: function(r) {
      return { _: "messageEntityBankCard", offset: r.int(), length: r.int() };
    },
    852137487: function(r) {
      return { _: "messageEntitySpoiler", offset: r.int(), length: r.int() };
    },
    3369010680: function(r) {
      return { _: "messageEntityCustomEmoji", offset: r.int(), length: r.int(), documentId: r.long() };
    },
    4056722092: function(r) {
      var flags = r.uint();
      return { _: "messageEntityBlockquote", collapsed: !!(flags & 1), offset: r.int(), length: r.int() };
    },
    4002160262: function(r) {
      return { _: "inputChannelEmpty" };
    },
    4082822184: function(r) {
      return { _: "inputChannel", channelId: r.int53(), accessHash: r.long() };
    },
    1536380829: function(r) {
      return { _: "inputChannelFromMessage", peer: r.object(), msgId: r.int(), channelId: r.int53() };
    },
    2131196633: function(r) {
      return { _: "contacts.resolvedPeer", peer: r.object(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    182649427: function(r) {
      return { _: "messageRange", minId: r.int(), maxId: r.int() };
    },
    1041346555: function(r) {
      var flags = r.uint();
      return { _: "updates.channelDifferenceEmpty", final: !!(flags & 1), pts: r.int(), timeout: flags & 2 ? r.int() : void 0 };
    },
    2763835134: function(r) {
      var flags = r.uint();
      return { _: "updates.channelDifferenceTooLong", final: !!(flags & 1), timeout: flags & 2 ? r.int() : void 0, dialog: r.object(), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    543450958: function(r) {
      var flags = r.uint();
      return { _: "updates.channelDifference", final: !!(flags & 1), pts: r.int(), timeout: flags & 2 ? r.int() : void 0, newMessages: r.vector(r.object), otherUpdates: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2496933607: function(r) {
      return { _: "channelMessagesFilterEmpty" };
    },
    3447183703: function(r) {
      var flags = r.uint();
      return { _: "channelMessagesFilter", excludeNewMessages: !!(flags & 2), ranges: r.vector(r.object) };
    },
    3409540633: function(r) {
      var flags = r.uint();
      return { _: "channelParticipant", userId: r.int53(), date: r.int(), subscriptionUntilDate: flags & 1 ? r.int() : void 0 };
    },
    1331723247: function(r) {
      var flags = r.uint();
      return { _: "channelParticipantSelf", viaRequest: !!(flags & 1), userId: r.int53(), inviterId: r.int53(), date: r.int(), subscriptionUntilDate: flags & 2 ? r.int() : void 0 };
    },
    803602899: function(r) {
      var flags = r.uint();
      return { _: "channelParticipantCreator", userId: r.int53(), adminRights: r.object(), rank: flags & 1 ? r.string() : void 0 };
    },
    885242707: function(r) {
      var flags = r.uint();
      return { _: "channelParticipantAdmin", canEdit: !!(flags & 1), self: !!(flags & 2), userId: r.int53(), inviterId: flags & 2 ? r.int53() : void 0, promotedBy: r.int53(), date: r.int(), adminRights: r.object(), rank: flags & 4 ? r.string() : void 0 };
    },
    1844969806: function(r) {
      var flags = r.uint();
      return { _: "channelParticipantBanned", left: !!(flags & 1), peer: r.object(), kickedBy: r.int53(), date: r.int(), bannedRights: r.object() };
    },
    453242886: function(r) {
      return { _: "channelParticipantLeft", peer: r.object() };
    },
    3728686201: function(r) {
      return { _: "channelParticipantsRecent" };
    },
    3026225513: function(r) {
      return { _: "channelParticipantsAdmins" };
    },
    2746567045: function(r) {
      return { _: "channelParticipantsKicked", q: r.string() };
    },
    2966521435: function(r) {
      return { _: "channelParticipantsBots" };
    },
    338142689: function(r) {
      return { _: "channelParticipantsBanned", q: r.string() };
    },
    106343499: function(r) {
      return { _: "channelParticipantsSearch", q: r.string() };
    },
    3144345741: function(r) {
      return { _: "channelParticipantsContacts", q: r.string() };
    },
    3763035371: function(r) {
      var flags = r.uint();
      return { _: "channelParticipantsMentions", q: flags & 1 ? r.string() : void 0, topMsgId: flags & 2 ? r.int() : void 0 };
    },
    2595290799: function(r) {
      return { _: "channels.channelParticipants", count: r.int(), participants: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    4028055529: function(r) {
      return { _: "channels.channelParticipantsNotModified" };
    },
    3753378583: function(r) {
      return { _: "channels.channelParticipant", participant: r.object(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2013922064: function(r) {
      var flags = r.uint();
      return { _: "help.termsOfService", popup: !!(flags & 1), id: r.object(), text: r.string(), entities: r.vector(r.object), minAgeConfirm: flags & 2 ? r.int() : void 0 };
    },
    3892468898: function(r) {
      return { _: "messages.savedGifsNotModified" };
    },
    2225089037: function(r) {
      return { _: "messages.savedGifs", hash: r.long(), gifs: r.vector(r.object) };
    },
    864077702: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageMediaAuto", invertMedia: !!(flags & 8), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0, replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    1036876423: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageText", noWebpage: !!(flags & 1), invertMedia: !!(flags & 8), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0, replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    2526190213: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageMediaGeo", geoPoint: r.object(), heading: flags & 1 ? r.int() : void 0, period: flags & 2 ? r.int() : void 0, proximityNotificationRadius: flags & 8 ? r.int() : void 0, replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    1098628881: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageMediaVenue", geoPoint: r.object(), title: r.string(), address: r.string(), provider: r.string(), venueId: r.string(), venueType: r.string(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    2800599037: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageMediaContact", phoneNumber: r.string(), firstName: r.string(), lastName: r.string(), vcard: r.string(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    1262639204: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageGame", replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    3622273573: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageMediaInvoice", title: r.string(), description: r.string(), photo: flags & 1 ? r.object() : void 0, invoice: r.object(), payload: r.bytes(), provider: r.string(), providerData: r.object(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    3185362192: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineMessageMediaWebPage", invertMedia: !!(flags & 8), forceLargeMedia: !!(flags & 16), forceSmallMedia: !!(flags & 32), optional: !!(flags & 64), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0, url: r.string(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    2294256409: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineResult", id: r.string(), type: r.string(), title: flags & 2 ? r.string() : void 0, description: flags & 4 ? r.string() : void 0, url: flags & 8 ? r.string() : void 0, thumb: flags & 16 ? r.object() : void 0, content: flags & 32 ? r.object() : void 0, sendMessage: r.object() };
    },
    2832753831: function(r) {
      return { _: "inputBotInlineResultPhoto", id: r.string(), type: r.string(), photo: r.object(), sendMessage: r.object() };
    },
    4294507972: function(r) {
      var flags = r.uint();
      return { _: "inputBotInlineResultDocument", id: r.string(), type: r.string(), title: flags & 2 ? r.string() : void 0, description: flags & 4 ? r.string() : void 0, document: r.object(), sendMessage: r.object() };
    },
    1336154098: function(r) {
      return { _: "inputBotInlineResultGame", id: r.string(), shortName: r.string(), sendMessage: r.object() };
    },
    1984755728: function(r) {
      var flags = r.uint();
      return { _: "botInlineMessageMediaAuto", invertMedia: !!(flags & 8), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0, replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    2357159394: function(r) {
      var flags = r.uint();
      return { _: "botInlineMessageText", noWebpage: !!(flags & 1), invertMedia: !!(flags & 8), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0, replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    85477117: function(r) {
      var flags = r.uint();
      return { _: "botInlineMessageMediaGeo", geo: r.object(), heading: flags & 1 ? r.int() : void 0, period: flags & 2 ? r.int() : void 0, proximityNotificationRadius: flags & 8 ? r.int() : void 0, replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    2324063644: function(r) {
      var flags = r.uint();
      return { _: "botInlineMessageMediaVenue", geo: r.object(), title: r.string(), address: r.string(), provider: r.string(), venueId: r.string(), venueType: r.string(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    416402882: function(r) {
      var flags = r.uint();
      return { _: "botInlineMessageMediaContact", phoneNumber: r.string(), firstName: r.string(), lastName: r.string(), vcard: r.string(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    894081801: function(r) {
      var flags = r.uint();
      return { _: "botInlineMessageMediaInvoice", shippingAddressRequested: !!(flags & 2), test: !!(flags & 8), title: r.string(), description: r.string(), photo: flags & 1 ? r.object() : void 0, currency: r.string(), totalAmount: r.long(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    2157631910: function(r) {
      var flags = r.uint();
      return { _: "botInlineMessageMediaWebPage", invertMedia: !!(flags & 8), forceLargeMedia: !!(flags & 16), forceSmallMedia: !!(flags & 32), manual: !!(flags & 128), safe: !!(flags & 256), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0, url: r.string(), replyMarkup: flags & 4 ? r.object() : void 0 };
    },
    295067450: function(r) {
      var flags = r.uint();
      return { _: "botInlineResult", id: r.string(), type: r.string(), title: flags & 2 ? r.string() : void 0, description: flags & 4 ? r.string() : void 0, url: flags & 8 ? r.string() : void 0, thumb: flags & 16 ? r.object() : void 0, content: flags & 32 ? r.object() : void 0, sendMessage: r.object() };
    },
    400266251: function(r) {
      var flags = r.uint();
      return { _: "botInlineMediaResult", id: r.string(), type: r.string(), photo: flags & 1 ? r.object() : void 0, document: flags & 2 ? r.object() : void 0, title: flags & 4 ? r.string() : void 0, description: flags & 8 ? r.string() : void 0, sendMessage: r.object() };
    },
    3760321270: function(r) {
      var flags = r.uint();
      return { _: "messages.botResults", gallery: !!(flags & 1), queryId: r.long(), nextOffset: flags & 2 ? r.string() : void 0, switchPm: flags & 4 ? r.object() : void 0, switchWebview: flags & 8 ? r.object() : void 0, results: r.vector(r.object), cacheTime: r.int(), users: r.vector(r.object) };
    },
    1571494644: function(r) {
      return { _: "exportedMessageLink", link: r.string(), html: r.string() };
    },
    1313731771: function(r) {
      var flags = r.uint();
      return { _: "messageFwdHeader", imported: !!(flags & 128), savedOut: !!(flags & 2048), fromId: flags & 1 ? r.object() : void 0, fromName: flags & 32 ? r.string() : void 0, date: r.int(), channelPost: flags & 4 ? r.int() : void 0, postAuthor: flags & 8 ? r.string() : void 0, savedFromPeer: flags & 16 ? r.object() : void 0, savedFromMsgId: flags & 16 ? r.int() : void 0, savedFromId: flags & 256 ? r.object() : void 0, savedFromName: flags & 512 ? r.string() : void 0, savedDate: flags & 1024 ? r.int() : void 0, psaType: flags & 64 ? r.string() : void 0 };
    },
    1923290508: function(r) {
      return { _: "auth.codeTypeSms" };
    },
    1948046307: function(r) {
      return { _: "auth.codeTypeCall" };
    },
    577556219: function(r) {
      return { _: "auth.codeTypeFlashCall" };
    },
    3592083182: function(r) {
      return { _: "auth.codeTypeMissedCall" };
    },
    116234636: function(r) {
      return { _: "auth.codeTypeFragmentSms" };
    },
    1035688326: function(r) {
      return { _: "auth.sentCodeTypeApp", length: r.int() };
    },
    3221273506: function(r) {
      return { _: "auth.sentCodeTypeSms", length: r.int() };
    },
    1398007207: function(r) {
      return { _: "auth.sentCodeTypeCall", length: r.int() };
    },
    2869151449: function(r) {
      return { _: "auth.sentCodeTypeFlashCall", pattern: r.string() };
    },
    2181063812: function(r) {
      return { _: "auth.sentCodeTypeMissedCall", prefix: r.string(), length: r.int() };
    },
    4098946459: function(r) {
      var flags = r.uint();
      return { _: "auth.sentCodeTypeEmailCode", appleSigninAllowed: !!(flags & 1), googleSigninAllowed: !!(flags & 2), emailPattern: r.string(), length: r.int(), resetAvailablePeriod: flags & 8 ? r.int() : void 0, resetPendingDate: flags & 16 ? r.int() : void 0 };
    },
    2773032426: function(r) {
      var flags = r.uint();
      return { _: "auth.sentCodeTypeSetUpEmailRequired", appleSigninAllowed: !!(flags & 1), googleSigninAllowed: !!(flags & 2) };
    },
    3646315577: function(r) {
      return { _: "auth.sentCodeTypeFragmentSms", url: r.string(), length: r.int() };
    },
    10475318: function(r) {
      var flags = r.uint();
      return { _: "auth.sentCodeTypeFirebaseSms", nonce: flags & 1 ? r.bytes() : void 0, playIntegrityProjectId: flags & 4 ? r.long() : void 0, playIntegrityNonce: flags & 4 ? r.bytes() : void 0, receipt: flags & 2 ? r.string() : void 0, pushTimeout: flags & 2 ? r.int() : void 0, length: r.int() };
    },
    2752949377: function(r) {
      var flags = r.uint();
      return { _: "auth.sentCodeTypeSmsWord", beginning: flags & 1 ? r.string() : void 0 };
    },
    3010958511: function(r) {
      var flags = r.uint();
      return { _: "auth.sentCodeTypeSmsPhrase", beginning: flags & 1 ? r.string() : void 0 };
    },
    911761060: function(r) {
      var flags = r.uint();
      return { _: "messages.botCallbackAnswer", alert: !!(flags & 2), hasUrl: !!(flags & 8), nativeUi: !!(flags & 16), message: flags & 1 ? r.string() : void 0, url: flags & 4 ? r.string() : void 0, cacheTime: r.int() };
    },
    649453030: function(r) {
      var flags = r.uint();
      return { _: "messages.messageEditData", caption: !!(flags & 1) };
    },
    2299280777: function(r) {
      return { _: "inputBotInlineMessageID", dcId: r.int(), id: r.long(), accessHash: r.long() };
    },
    3067680215: function(r) {
      return { _: "inputBotInlineMessageID64", dcId: r.int(), ownerId: r.long(), id: r.int(), accessHash: r.long() };
    },
    1008755359: function(r) {
      return { _: "inlineBotSwitchPM", text: r.string(), startParam: r.string() };
    },
    863093588: function(r) {
      return { _: "messages.peerDialogs", dialogs: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), state: r.object() };
    },
    3989684315: function(r) {
      return { _: "topPeer", peer: r.object(), rating: r.double() };
    },
    2875595611: function(r) {
      return { _: "topPeerCategoryBotsPM" };
    },
    344356834: function(r) {
      return { _: "topPeerCategoryBotsInline" };
    },
    104314861: function(r) {
      return { _: "topPeerCategoryCorrespondents" };
    },
    3172442442: function(r) {
      return { _: "topPeerCategoryGroups" };
    },
    371037736: function(r) {
      return { _: "topPeerCategoryChannels" };
    },
    511092620: function(r) {
      return { _: "topPeerCategoryPhoneCalls" };
    },
    2822794409: function(r) {
      return { _: "topPeerCategoryForwardUsers" };
    },
    4226728176: function(r) {
      return { _: "topPeerCategoryForwardChats" };
    },
    4255022060: function(r) {
      return { _: "topPeerCategoryBotsApp" };
    },
    4219683473: function(r) {
      return { _: "topPeerCategoryPeers", category: r.object(), count: r.int(), peers: r.vector(r.object) };
    },
    3727060725: function(r) {
      return { _: "contacts.topPeersNotModified" };
    },
    1891070632: function(r) {
      return { _: "contacts.topPeers", categories: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3039597469: function(r) {
      return { _: "contacts.topPeersDisabled" };
    },
    453805082: function(r) {
      var flags = r.uint();
      return { _: "draftMessageEmpty", date: flags & 1 ? r.int() : void 0 };
    },
    761606687: function(r) {
      var flags = r.uint();
      return { _: "draftMessage", noWebpage: !!(flags & 2), invertMedia: !!(flags & 64), replyTo: flags & 16 ? r.object() : void 0, message: r.string(), entities: flags & 8 ? r.vector(r.object) : void 0, media: flags & 32 ? r.object() : void 0, date: r.int(), effect: flags & 128 ? r.long() : void 0 };
    },
    3336309862: function(r) {
      return { _: "messages.featuredStickersNotModified", count: r.int() };
    },
    3191351558: function(r) {
      var flags = r.uint();
      return { _: "messages.featuredStickers", premium: !!(flags & 1), hash: r.long(), count: r.int(), sets: r.vector(r.object), unread: r.vector(r.long) };
    },
    186120336: function(r) {
      return { _: "messages.recentStickersNotModified" };
    },
    2295561302: function(r) {
      return { _: "messages.recentStickers", hash: r.long(), packs: r.vector(r.object), stickers: r.vector(r.object), dates: r.vector(r.int) };
    },
    1338747336: function(r) {
      return { _: "messages.archivedStickers", count: r.int(), sets: r.vector(r.object) };
    },
    946083368: function(r) {
      return { _: "messages.stickerSetInstallResultSuccess" };
    },
    904138920: function(r) {
      return { _: "messages.stickerSetInstallResultArchive", sets: r.vector(r.object) };
    },
    1678812626: function(r) {
      return { _: "stickerSetCovered", set: r.object(), cover: r.object() };
    },
    872932635: function(r) {
      return { _: "stickerSetMultiCovered", set: r.object(), covers: r.vector(r.object) };
    },
    1087454222: function(r) {
      return { _: "stickerSetFullCovered", set: r.object(), packs: r.vector(r.object), keywords: r.vector(r.object), documents: r.vector(r.object) };
    },
    2008112412: function(r) {
      return { _: "stickerSetNoCovered", set: r.object() };
    },
    2933316530: function(r) {
      return { _: "maskCoords", n: r.int(), x: r.double(), y: r.double(), zoom: r.double() };
    },
    1251549527: function(r) {
      return { _: "inputStickeredMediaPhoto", id: r.object() };
    },
    70813275: function(r) {
      return { _: "inputStickeredMediaDocument", id: r.object() };
    },
    3187238203: function(r) {
      var flags = r.uint();
      return { _: "game", id: r.long(), accessHash: r.long(), shortName: r.string(), title: r.string(), description: r.string(), photo: r.object(), document: flags & 1 ? r.object() : void 0 };
    },
    53231223: function(r) {
      return { _: "inputGameID", id: r.long(), accessHash: r.long() };
    },
    3274827786: function(r) {
      return { _: "inputGameShortName", botId: r.object(), shortName: r.string() };
    },
    1940093419: function(r) {
      return { _: "highScore", pos: r.int(), userId: r.int53(), score: r.int() };
    },
    2587622809: function(r) {
      return { _: "messages.highScores", scores: r.vector(r.object), users: r.vector(r.object) };
    },
    3695018575: function(r) {
      return { _: "textEmpty" };
    },
    1950782688: function(r) {
      return { _: "textPlain", text: r.string() };
    },
    1730456516: function(r) {
      return { _: "textBold", text: r.object() };
    },
    3641877916: function(r) {
      return { _: "textItalic", text: r.object() };
    },
    3240501956: function(r) {
      return { _: "textUnderline", text: r.object() };
    },
    2616769429: function(r) {
      return { _: "textStrike", text: r.object() };
    },
    1816074681: function(r) {
      return { _: "textFixed", text: r.object() };
    },
    1009288385: function(r) {
      return { _: "textUrl", text: r.object(), url: r.string(), webpageId: r.long() };
    },
    3730443734: function(r) {
      return { _: "textEmail", text: r.object(), email: r.string() };
    },
    2120376535: function(r) {
      return { _: "textConcat", texts: r.vector(r.object) };
    },
    3983181060: function(r) {
      return { _: "textSubscript", text: r.object() };
    },
    3355139585: function(r) {
      return { _: "textSuperscript", text: r.object() };
    },
    55281185: function(r) {
      return { _: "textMarked", text: r.object() };
    },
    483104362: function(r) {
      return { _: "textPhone", text: r.object(), phone: r.string() };
    },
    136105807: function(r) {
      return { _: "textImage", documentId: r.long(), w: r.int(), h: r.int() };
    },
    894777186: function(r) {
      return { _: "textAnchor", text: r.object(), name: r.string() };
    },
    324435594: function(r) {
      return { _: "pageBlockUnsupported" };
    },
    1890305021: function(r) {
      return { _: "pageBlockTitle", text: r.object() };
    },
    2415565343: function(r) {
      return { _: "pageBlockSubtitle", text: r.object() };
    },
    3132089824: function(r) {
      return { _: "pageBlockAuthorDate", author: r.object(), publishedDate: r.int() };
    },
    3218105580: function(r) {
      return { _: "pageBlockHeader", text: r.object() };
    },
    4046173921: function(r) {
      return { _: "pageBlockSubheader", text: r.object() };
    },
    1182402406: function(r) {
      return { _: "pageBlockParagraph", text: r.object() };
    },
    3228621118: function(r) {
      return { _: "pageBlockPreformatted", text: r.object(), language: r.string() };
    },
    1216809369: function(r) {
      return { _: "pageBlockFooter", text: r.object() };
    },
    3676352904: function(r) {
      return { _: "pageBlockDivider" };
    },
    3456972720: function(r) {
      return { _: "pageBlockAnchor", name: r.string() };
    },
    3840442385: function(r) {
      return { _: "pageBlockList", items: r.vector(r.object) };
    },
    641563686: function(r) {
      return { _: "pageBlockBlockquote", text: r.object(), caption: r.object() };
    },
    1329878739: function(r) {
      return { _: "pageBlockPullquote", text: r.object(), caption: r.object() };
    },
    391759200: function(r) {
      var flags = r.uint();
      return { _: "pageBlockPhoto", photoId: r.long(), caption: r.object(), url: flags & 1 ? r.string() : void 0, webpageId: flags & 1 ? r.long() : void 0 };
    },
    2089805750: function(r) {
      var flags = r.uint();
      return { _: "pageBlockVideo", autoplay: !!(flags & 1), loop: !!(flags & 2), videoId: r.long(), caption: r.object() };
    },
    972174080: function(r) {
      return { _: "pageBlockCover", cover: r.object() };
    },
    2826014149: function(r) {
      var flags = r.uint();
      return { _: "pageBlockEmbed", fullWidth: !!(flags & 1), allowScrolling: !!(flags & 8), url: flags & 2 ? r.string() : void 0, html: flags & 4 ? r.string() : void 0, posterPhotoId: flags & 16 ? r.long() : void 0, w: flags & 32 ? r.int() : void 0, h: flags & 32 ? r.int() : void 0, caption: r.object() };
    },
    4065961995: function(r) {
      return { _: "pageBlockEmbedPost", url: r.string(), webpageId: r.long(), authorPhotoId: r.long(), author: r.string(), date: r.int(), blocks: r.vector(r.object), caption: r.object() };
    },
    1705048653: function(r) {
      return { _: "pageBlockCollage", items: r.vector(r.object), caption: r.object() };
    },
    52401552: function(r) {
      return { _: "pageBlockSlideshow", items: r.vector(r.object), caption: r.object() };
    },
    4011282869: function(r) {
      return { _: "pageBlockChannel", channel: r.object() };
    },
    2151899626: function(r) {
      return { _: "pageBlockAudio", audioId: r.long(), caption: r.object() };
    },
    504660880: function(r) {
      return { _: "pageBlockKicker", text: r.object() };
    },
    3209554562: function(r) {
      var flags = r.uint();
      return { _: "pageBlockTable", bordered: !!(flags & 1), striped: !!(flags & 2), title: r.object(), rows: r.vector(r.object) };
    },
    2592793057: function(r) {
      return { _: "pageBlockOrderedList", items: r.vector(r.object) };
    },
    1987480557: function(r) {
      var flags = r.uint();
      return { _: "pageBlockDetails", open: !!(flags & 1), blocks: r.vector(r.object), title: r.object() };
    },
    370236054: function(r) {
      return { _: "pageBlockRelatedArticles", title: r.object(), articles: r.vector(r.object) };
    },
    2756656886: function(r) {
      return { _: "pageBlockMap", geo: r.object(), zoom: r.int(), w: r.int(), h: r.int(), caption: r.object() };
    },
    2246320897: function(r) {
      return { _: "phoneCallDiscardReasonMissed" };
    },
    3767910816: function(r) {
      return { _: "phoneCallDiscardReasonDisconnect" };
    },
    1471006352: function(r) {
      return { _: "phoneCallDiscardReasonHangup" };
    },
    4210550985: function(r) {
      return { _: "phoneCallDiscardReasonBusy" };
    },
    2104790276: function(r) {
      return { _: "dataJSON", data: r.string() };
    },
    3408489464: function(r) {
      return { _: "labeledPrice", label: r.string(), amount: r.long() };
    },
    1572428309: function(r) {
      var flags = r.uint();
      return { _: "invoice", test: !!(flags & 1), nameRequested: !!(flags & 2), phoneRequested: !!(flags & 4), emailRequested: !!(flags & 8), shippingAddressRequested: !!(flags & 16), flexible: !!(flags & 32), phoneToProvider: !!(flags & 64), emailToProvider: !!(flags & 128), recurring: !!(flags & 512), currency: r.string(), prices: r.vector(r.object), maxTipAmount: flags & 256 ? r.long() : void 0, suggestedTipAmounts: flags & 256 ? r.vector(r.long) : void 0, termsUrl: flags & 1024 ? r.string() : void 0 };
    },
    3926049406: function(r) {
      return { _: "paymentCharge", id: r.string(), providerChargeId: r.string() };
    },
    512535275: function(r) {
      return { _: "postAddress", streetLine1: r.string(), streetLine2: r.string(), city: r.string(), state: r.string(), countryIso2: r.string(), postCode: r.string() };
    },
    2426158996: function(r) {
      var flags = r.uint();
      return { _: "paymentRequestedInfo", name: flags & 1 ? r.string() : void 0, phone: flags & 2 ? r.string() : void 0, email: flags & 4 ? r.string() : void 0, shippingAddress: flags & 8 ? r.object() : void 0 };
    },
    3452074527: function(r) {
      return { _: "paymentSavedCredentialsCard", id: r.string(), title: r.string() };
    },
    475467473: function(r) {
      return { _: "webDocument", url: r.string(), accessHash: r.long(), size: r.int(), mimeType: r.string(), attributes: r.vector(r.object) };
    },
    4190682310: function(r) {
      return { _: "webDocumentNoProxy", url: r.string(), size: r.int(), mimeType: r.string(), attributes: r.vector(r.object) };
    },
    2616017741: function(r) {
      return { _: "inputWebDocument", url: r.string(), size: r.int(), mimeType: r.string(), attributes: r.vector(r.object) };
    },
    3258570374: function(r) {
      return { _: "inputWebFileLocation", url: r.string(), accessHash: r.long() };
    },
    2669814217: function(r) {
      return { _: "inputWebFileGeoPointLocation", geoPoint: r.object(), accessHash: r.long(), w: r.int(), h: r.int(), zoom: r.int(), scale: r.int() };
    },
    4100974884: function(r) {
      var flags = r.uint();
      return { _: "inputWebFileAudioAlbumThumbLocation", small: !!(flags & 4), document: flags & 1 ? r.object() : void 0, title: flags & 2 ? r.string() : void 0, performer: flags & 2 ? r.string() : void 0 };
    },
    568808380: function(r) {
      return { _: "upload.webFile", size: r.int(), mimeType: r.string(), fileType: r.object(), mtime: r.int(), bytes: r.bytes() };
    },
    2684716881: function(r) {
      var flags = r.uint();
      return { _: "payments.paymentForm", canSaveCredentials: !!(flags & 4), passwordMissing: !!(flags & 8), formId: r.long(), botId: r.int53(), title: r.string(), description: r.string(), photo: flags & 32 ? r.object() : void 0, invoice: r.object(), providerId: r.long(), url: r.string(), nativeProvider: flags & 16 ? r.string() : void 0, nativeParams: flags & 16 ? r.object() : void 0, additionalMethods: flags & 64 ? r.vector(r.object) : void 0, savedInfo: flags & 1 ? r.object() : void 0, savedCredentials: flags & 2 ? r.vector(r.object) : void 0, users: r.vector(r.object) };
    },
    2079764828: function(r) {
      var flags = r.uint();
      return { _: "payments.paymentFormStars", formId: r.long(), botId: r.int53(), title: r.string(), description: r.string(), photo: flags & 32 ? r.object() : void 0, invoice: r.object(), users: r.vector(r.object) };
    },
    3022376929: function(r) {
      return { _: "payments.paymentFormStarGift", formId: r.long(), invoice: r.object() };
    },
    3510966403: function(r) {
      var flags = r.uint();
      return { _: "payments.validatedRequestedInfo", id: flags & 1 ? r.string() : void 0, shippingOptions: flags & 2 ? r.vector(r.object) : void 0 };
    },
    1314881805: function(r) {
      return { _: "payments.paymentResult", updates: r.object() };
    },
    3628142905: function(r) {
      return { _: "payments.paymentVerificationNeeded", url: r.string() };
    },
    1891958275: function(r) {
      var flags = r.uint();
      return { _: "payments.paymentReceipt", date: r.int(), botId: r.int53(), providerId: r.long(), title: r.string(), description: r.string(), photo: flags & 4 ? r.object() : void 0, invoice: r.object(), info: flags & 1 ? r.object() : void 0, shipping: flags & 2 ? r.object() : void 0, tipAmount: flags & 8 ? r.long() : void 0, currency: r.string(), totalAmount: r.long(), credentialsTitle: r.string(), users: r.vector(r.object) };
    },
    3669751866: function(r) {
      var flags = r.uint();
      return { _: "payments.paymentReceiptStars", date: r.int(), botId: r.int53(), title: r.string(), description: r.string(), photo: flags & 4 ? r.object() : void 0, invoice: r.object(), currency: r.string(), totalAmount: r.long(), transactionId: r.string(), users: r.vector(r.object) };
    },
    4220511292: function(r) {
      var flags = r.uint();
      return { _: "payments.savedInfo", hasSavedCredentials: !!(flags & 2), savedInfo: flags & 1 ? r.object() : void 0 };
    },
    3238965967: function(r) {
      return { _: "inputPaymentCredentialsSaved", id: r.string(), tmpPassword: r.bytes() };
    },
    873977640: function(r) {
      var flags = r.uint();
      return { _: "inputPaymentCredentials", save: !!(flags & 1), data: r.object() };
    },
    178373535: function(r) {
      return { _: "inputPaymentCredentialsApplePay", paymentData: r.object() };
    },
    2328045569: function(r) {
      return { _: "inputPaymentCredentialsGooglePay", paymentToken: r.object() };
    },
    3680828724: function(r) {
      return { _: "account.tmpPassword", tmpPassword: r.bytes(), validUntil: r.int() };
    },
    3055631583: function(r) {
      return { _: "shippingOption", id: r.string(), title: r.string(), prices: r.vector(r.object) };
    },
    853188252: function(r) {
      var flags = r.uint();
      return { _: "inputStickerSetItem", document: r.object(), emoji: r.string(), maskCoords: flags & 1 ? r.object() : void 0, keywords: flags & 2 ? r.string() : void 0 };
    },
    506920429: function(r) {
      return { _: "inputPhoneCall", id: r.long(), accessHash: r.long() };
    },
    1399245077: function(r) {
      return { _: "phoneCallEmpty", id: r.long() };
    },
    3307368215: function(r) {
      var flags = r.uint();
      return { _: "phoneCallWaiting", video: !!(flags & 64), id: r.long(), accessHash: r.long(), date: r.int(), adminId: r.int53(), participantId: r.int53(), protocol: r.object(), receiveDate: flags & 1 ? r.int() : void 0 };
    },
    347139340: function(r) {
      var flags = r.uint();
      return { _: "phoneCallRequested", video: !!(flags & 64), id: r.long(), accessHash: r.long(), date: r.int(), adminId: r.int53(), participantId: r.int53(), gAHash: r.bytes(), protocol: r.object() };
    },
    912311057: function(r) {
      var flags = r.uint();
      return { _: "phoneCallAccepted", video: !!(flags & 64), id: r.long(), accessHash: r.long(), date: r.int(), adminId: r.int53(), participantId: r.int53(), gB: r.bytes(), protocol: r.object() };
    },
    810769141: function(r) {
      var flags = r.uint();
      return { _: "phoneCall", p2pAllowed: !!(flags & 32), video: !!(flags & 64), id: r.long(), accessHash: r.long(), date: r.int(), adminId: r.int53(), participantId: r.int53(), gAOrB: r.bytes(), keyFingerprint: r.long(), protocol: r.object(), connections: r.vector(r.object), startDate: r.int(), customParameters: flags & 128 ? r.object() : void 0 };
    },
    1355435489: function(r) {
      var flags = r.uint();
      return { _: "phoneCallDiscarded", needRating: !!(flags & 4), needDebug: !!(flags & 8), video: !!(flags & 64), id: r.long(), reason: flags & 1 ? r.object() : void 0, duration: flags & 2 ? r.int() : void 0 };
    },
    2629903303: function(r) {
      var flags = r.uint();
      return { _: "phoneConnection", tcp: !!(flags & 1), id: r.long(), ip: r.string(), ipv6: r.string(), port: r.int(), peerTag: r.bytes() };
    },
    1667228533: function(r) {
      var flags = r.uint();
      return { _: "phoneConnectionWebrtc", turn: !!(flags & 1), stun: !!(flags & 2), id: r.long(), ip: r.string(), ipv6: r.string(), port: r.int(), username: r.string(), password: r.string() };
    },
    4236742600: function(r) {
      var flags = r.uint();
      return { _: "phoneCallProtocol", udpP2p: !!(flags & 1), udpReflector: !!(flags & 2), minLayer: r.int(), maxLayer: r.int(), libraryVersions: r.vector(r.string) };
    },
    3968000320: function(r) {
      return { _: "phone.phoneCall", phoneCall: r.object(), users: r.vector(r.object) };
    },
    4004045934: function(r) {
      return { _: "upload.cdnFileReuploadNeeded", requestToken: r.bytes() };
    },
    2845821519: function(r) {
      return { _: "upload.cdnFile", bytes: r.bytes() };
    },
    3380800186: function(r) {
      return { _: "cdnPublicKey", dcId: r.int(), publicKey: r.string() };
    },
    1462101002: function(r) {
      return { _: "cdnConfig", publicKeys: r.vector(r.object) };
    },
    3402727926: function(r) {
      return { _: "langPackString", key: r.string(), value: r.string() };
    },
    1816636575: function(r) {
      var flags = r.uint();
      return { _: "langPackStringPluralized", key: r.string(), zeroValue: flags & 1 ? r.string() : void 0, oneValue: flags & 2 ? r.string() : void 0, twoValue: flags & 4 ? r.string() : void 0, fewValue: flags & 8 ? r.string() : void 0, manyValue: flags & 16 ? r.string() : void 0, otherValue: r.string() };
    },
    695856818: function(r) {
      return { _: "langPackStringDeleted", key: r.string() };
    },
    4085629430: function(r) {
      return { _: "langPackDifference", langCode: r.string(), fromVersion: r.int(), version: r.int(), strings: r.vector(r.object) };
    },
    4006239459: function(r) {
      var flags = r.uint();
      return { _: "langPackLanguage", official: !!(flags & 1), rtl: !!(flags & 4), beta: !!(flags & 8), name: r.string(), nativeName: r.string(), langCode: r.string(), baseLangCode: flags & 2 ? r.string() : void 0, pluralCode: r.string(), stringsCount: r.int(), translatedCount: r.int(), translationsUrl: r.string() };
    },
    3873421349: function(r) {
      return { _: "channelAdminLogEventActionChangeTitle", prevValue: r.string(), newValue: r.string() };
    },
    1427671598: function(r) {
      return { _: "channelAdminLogEventActionChangeAbout", prevValue: r.string(), newValue: r.string() };
    },
    1783299128: function(r) {
      return { _: "channelAdminLogEventActionChangeUsername", prevValue: r.string(), newValue: r.string() };
    },
    1129042607: function(r) {
      return { _: "channelAdminLogEventActionChangePhoto", prevPhoto: r.object(), newPhoto: r.object() };
    },
    460916654: function(r) {
      return { _: "channelAdminLogEventActionToggleInvites", newValue: r.boolean() };
    },
    648939889: function(r) {
      return { _: "channelAdminLogEventActionToggleSignatures", newValue: r.boolean() };
    },
    3924306968: function(r) {
      return { _: "channelAdminLogEventActionUpdatePinned", message: r.object() };
    },
    1889215493: function(r) {
      return { _: "channelAdminLogEventActionEditMessage", prevMessage: r.object(), newMessage: r.object() };
    },
    1121994683: function(r) {
      return { _: "channelAdminLogEventActionDeleteMessage", message: r.object() };
    },
    405815507: function(r) {
      return { _: "channelAdminLogEventActionParticipantJoin" };
    },
    4170676210: function(r) {
      return { _: "channelAdminLogEventActionParticipantLeave" };
    },
    3810276568: function(r) {
      return { _: "channelAdminLogEventActionParticipantInvite", participant: r.object() };
    },
    3872931198: function(r) {
      return { _: "channelAdminLogEventActionParticipantToggleBan", prevParticipant: r.object(), newParticipant: r.object() };
    },
    3580323600: function(r) {
      return { _: "channelAdminLogEventActionParticipantToggleAdmin", prevParticipant: r.object(), newParticipant: r.object() };
    },
    2982398631: function(r) {
      return { _: "channelAdminLogEventActionChangeStickerSet", prevStickerset: r.object(), newStickerset: r.object() };
    },
    1599903217: function(r) {
      return { _: "channelAdminLogEventActionTogglePreHistoryHidden", newValue: r.boolean() };
    },
    771095562: function(r) {
      return { _: "channelAdminLogEventActionDefaultBannedRights", prevBannedRights: r.object(), newBannedRights: r.object() };
    },
    2399639107: function(r) {
      return { _: "channelAdminLogEventActionStopPoll", message: r.object() };
    },
    84703944: function(r) {
      return { _: "channelAdminLogEventActionChangeLinkedChat", prevValue: r.int53(), newValue: r.int53() };
    },
    241923758: function(r) {
      return { _: "channelAdminLogEventActionChangeLocation", prevValue: r.object(), newValue: r.object() };
    },
    1401984889: function(r) {
      return { _: "channelAdminLogEventActionToggleSlowMode", prevValue: r.int(), newValue: r.int() };
    },
    589338437: function(r) {
      return { _: "channelAdminLogEventActionStartGroupCall", call: r.object() };
    },
    3684667712: function(r) {
      return { _: "channelAdminLogEventActionDiscardGroupCall", call: r.object() };
    },
    4179895506: function(r) {
      return { _: "channelAdminLogEventActionParticipantMute", participant: r.object() };
    },
    3863226816: function(r) {
      return { _: "channelAdminLogEventActionParticipantUnmute", participant: r.object() };
    },
    1456906823: function(r) {
      return { _: "channelAdminLogEventActionToggleGroupCallSetting", joinMuted: r.boolean() };
    },
    4271882584: function(r) {
      var flags = r.uint();
      return { _: "channelAdminLogEventActionParticipantJoinByInvite", viaChatlist: !!(flags & 1), invite: r.object() };
    },
    1515256996: function(r) {
      return { _: "channelAdminLogEventActionExportedInviteDelete", invite: r.object() };
    },
    1091179342: function(r) {
      return { _: "channelAdminLogEventActionExportedInviteRevoke", invite: r.object() };
    },
    3910056793: function(r) {
      return { _: "channelAdminLogEventActionExportedInviteEdit", prevInvite: r.object(), newInvite: r.object() };
    },
    1048537159: function(r) {
      return { _: "channelAdminLogEventActionParticipantVolume", participant: r.object() };
    },
    1855199800: function(r) {
      return { _: "channelAdminLogEventActionChangeHistoryTTL", prevValue: r.int(), newValue: r.int() };
    },
    2947945546: function(r) {
      return { _: "channelAdminLogEventActionParticipantJoinByRequest", invite: r.object(), approvedBy: r.int53() };
    },
    3408578406: function(r) {
      return { _: "channelAdminLogEventActionToggleNoForwards", newValue: r.boolean() };
    },
    663693416: function(r) {
      return { _: "channelAdminLogEventActionSendMessage", message: r.object() };
    },
    3192786680: function(r) {
      return { _: "channelAdminLogEventActionChangeAvailableReactions", prevValue: r.object(), newValue: r.object() };
    },
    4031755177: function(r) {
      return { _: "channelAdminLogEventActionChangeUsernames", prevValue: r.vector(r.string), newValue: r.vector(r.string) };
    },
    46949251: function(r) {
      return { _: "channelAdminLogEventActionToggleForum", newValue: r.boolean() };
    },
    1483767080: function(r) {
      return { _: "channelAdminLogEventActionCreateTopic", topic: r.object() };
    },
    4033864200: function(r) {
      return { _: "channelAdminLogEventActionEditTopic", prevTopic: r.object(), newTopic: r.object() };
    },
    2920712457: function(r) {
      return { _: "channelAdminLogEventActionDeleteTopic", topic: r.object() };
    },
    1569535291: function(r) {
      var flags = r.uint();
      return { _: "channelAdminLogEventActionPinTopic", prevTopic: flags & 1 ? r.object() : void 0, newTopic: flags & 2 ? r.object() : void 0 };
    },
    1693675004: function(r) {
      return { _: "channelAdminLogEventActionToggleAntiSpam", newValue: r.boolean() };
    },
    1469507456: function(r) {
      return { _: "channelAdminLogEventActionChangePeerColor", prevValue: r.object(), newValue: r.object() };
    },
    1581742885: function(r) {
      return { _: "channelAdminLogEventActionChangeProfilePeerColor", prevValue: r.object(), newValue: r.object() };
    },
    834362706: function(r) {
      return { _: "channelAdminLogEventActionChangeWallpaper", prevValue: r.object(), newValue: r.object() };
    },
    1051328177: function(r) {
      return { _: "channelAdminLogEventActionChangeEmojiStatus", prevValue: r.object(), newValue: r.object() };
    },
    1188577451: function(r) {
      return { _: "channelAdminLogEventActionChangeEmojiStickerSet", prevStickerset: r.object(), newStickerset: r.object() };
    },
    1621597305: function(r) {
      return { _: "channelAdminLogEventActionToggleSignatureProfiles", newValue: r.boolean() };
    },
    1684286899: function(r) {
      return { _: "channelAdminLogEventActionParticipantSubExtend", prevParticipant: r.object(), newParticipant: r.object() };
    },
    531458253: function(r) {
      return { _: "channelAdminLogEvent", id: r.long(), date: r.int(), userId: r.int53(), action: r.object() };
    },
    3985307469: function(r) {
      return { _: "channels.adminLogResults", events: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3926948580: function(r) {
      var flags = r.uint();
      return { _: "channelAdminLogEventsFilter", join: !!(flags & 1), leave: !!(flags & 2), invite: !!(flags & 4), ban: !!(flags & 8), unban: !!(flags & 16), kick: !!(flags & 32), unkick: !!(flags & 64), promote: !!(flags & 128), demote: !!(flags & 256), info: !!(flags & 512), settings: !!(flags & 1024), pinned: !!(flags & 2048), edit: !!(flags & 4096), delete: !!(flags & 8192), groupCall: !!(flags & 16384), invites: !!(flags & 32768), send: !!(flags & 65536), forums: !!(flags & 131072), subExtend: !!(flags & 262144) };
    },
    1558266229: function(r) {
      return { _: "popularContact", clientId: r.long(), importers: r.int() };
    },
    2660214483: function(r) {
      return { _: "messages.favedStickersNotModified" };
    },
    750063767: function(r) {
      return { _: "messages.favedStickers", hash: r.long(), packs: r.vector(r.object), stickers: r.vector(r.object) };
    },
    1189204285: function(r) {
      return { _: "recentMeUrlUnknown", url: r.string() };
    },
    3106671074: function(r) {
      return { _: "recentMeUrlUser", url: r.string(), userId: r.int53() };
    },
    3000660434: function(r) {
      return { _: "recentMeUrlChat", url: r.string(), chatId: r.int53() };
    },
    3947431965: function(r) {
      return { _: "recentMeUrlChatInvite", url: r.string(), chatInvite: r.object() };
    },
    3154794460: function(r) {
      return { _: "recentMeUrlStickerSet", url: r.string(), set: r.object() };
    },
    235081943: function(r) {
      return { _: "help.recentMeUrls", urls: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    482797855: function(r) {
      var flags = r.uint();
      return { _: "inputSingleMedia", media: r.object(), randomId: r.long(), message: r.string(), entities: flags & 1 ? r.vector(r.object) : void 0 };
    },
    2801333330: function(r) {
      return { _: "webAuthorization", hash: r.long(), botId: r.int53(), domain: r.string(), browser: r.string(), platform: r.string(), dateCreated: r.int(), dateActive: r.int(), ip: r.string(), region: r.string() };
    },
    3981887996: function(r) {
      return { _: "account.webAuthorizations", authorizations: r.vector(r.object), users: r.vector(r.object) };
    },
    2792792866: function(r) {
      return { _: "inputMessageID", id: r.int() };
    },
    3134751637: function(r) {
      return { _: "inputMessageReplyTo", id: r.int() };
    },
    2257003832: function(r) {
      return { _: "inputMessagePinned" };
    },
    2902071934: function(r) {
      return { _: "inputMessageCallbackQuery", id: r.int(), queryId: r.long() };
    },
    4239064759: function(r) {
      return { _: "inputDialogPeer", peer: r.object() };
    },
    1684014375: function(r) {
      return { _: "inputDialogPeerFolder", folderId: r.int() };
    },
    3849174789: function(r) {
      return { _: "dialogPeer", peer: r.object() };
    },
    1363483106: function(r) {
      return { _: "dialogPeerFolder", folderId: r.int() };
    },
    223655517: function(r) {
      return { _: "messages.foundStickerSetsNotModified" };
    },
    2331024850: function(r) {
      return { _: "messages.foundStickerSets", hash: r.long(), sets: r.vector(r.object) };
    },
    4087022428: function(r) {
      return { _: "fileHash", offset: r.int53(), limit: r.int(), hash: r.bytes() };
    },
    1968737087: function(r) {
      return { _: "inputClientProxy", address: r.string(), port: r.int() };
    },
    3811614591: function(r) {
      return { _: "help.termsOfServiceUpdateEmpty", expires: r.int() };
    },
    686618977: function(r) {
      return { _: "help.termsOfServiceUpdate", expires: r.int(), termsOfService: r.object() };
    },
    859091184: function(r) {
      return { _: "inputSecureFileUploaded", id: r.long(), parts: r.int(), md5Checksum: r.string(), fileHash: r.bytes(), secret: r.bytes() };
    },
    1399317950: function(r) {
      return { _: "inputSecureFile", id: r.long(), accessHash: r.long() };
    },
    1679398724: function(r) {
      return { _: "secureFileEmpty" };
    },
    2097791614: function(r) {
      return { _: "secureFile", id: r.long(), accessHash: r.long(), size: r.int53(), dcId: r.int(), date: r.int(), fileHash: r.bytes(), secret: r.bytes() };
    },
    2330640067: function(r) {
      return { _: "secureData", data: r.bytes(), dataHash: r.bytes(), secret: r.bytes() };
    },
    2103482845: function(r) {
      return { _: "securePlainPhone", phone: r.string() };
    },
    569137759: function(r) {
      return { _: "securePlainEmail", email: r.string() };
    },
    2636808675: function(r) {
      return { _: "secureValueTypePersonalDetails" };
    },
    1034709504: function(r) {
      return { _: "secureValueTypePassport" };
    },
    115615172: function(r) {
      return { _: "secureValueTypeDriverLicense" };
    },
    2698015819: function(r) {
      return { _: "secureValueTypeIdentityCard" };
    },
    2577698595: function(r) {
      return { _: "secureValueTypeInternalPassport" };
    },
    3420659238: function(r) {
      return { _: "secureValueTypeAddress" };
    },
    4231435598: function(r) {
      return { _: "secureValueTypeUtilityBill" };
    },
    2299755533: function(r) {
      return { _: "secureValueTypeBankStatement" };
    },
    2340959368: function(r) {
      return { _: "secureValueTypeRentalAgreement" };
    },
    2581823594: function(r) {
      return { _: "secureValueTypePassportRegistration" };
    },
    3926060083: function(r) {
      return { _: "secureValueTypeTemporaryRegistration" };
    },
    3005262555: function(r) {
      return { _: "secureValueTypePhone" };
    },
    2386339822: function(r) {
      return { _: "secureValueTypeEmail" };
    },
    411017418: function(r) {
      var flags = r.uint();
      return { _: "secureValue", type: r.object(), data: flags & 1 ? r.object() : void 0, frontSide: flags & 2 ? r.object() : void 0, reverseSide: flags & 4 ? r.object() : void 0, selfie: flags & 8 ? r.object() : void 0, translation: flags & 64 ? r.vector(r.object) : void 0, files: flags & 16 ? r.vector(r.object) : void 0, plainData: flags & 32 ? r.object() : void 0, hash: r.bytes() };
    },
    3676426407: function(r) {
      var flags = r.uint();
      return { _: "inputSecureValue", type: r.object(), data: flags & 1 ? r.object() : void 0, frontSide: flags & 2 ? r.object() : void 0, reverseSide: flags & 4 ? r.object() : void 0, selfie: flags & 8 ? r.object() : void 0, translation: flags & 64 ? r.vector(r.object) : void 0, files: flags & 16 ? r.vector(r.object) : void 0, plainData: flags & 32 ? r.object() : void 0 };
    },
    3978218928: function(r) {
      return { _: "secureValueHash", type: r.object(), hash: r.bytes() };
    },
    3903065049: function(r) {
      return { _: "secureValueErrorData", type: r.object(), dataHash: r.bytes(), field: r.string(), text: r.string() };
    },
    12467706: function(r) {
      return { _: "secureValueErrorFrontSide", type: r.object(), fileHash: r.bytes(), text: r.string() };
    },
    2257201829: function(r) {
      return { _: "secureValueErrorReverseSide", type: r.object(), fileHash: r.bytes(), text: r.string() };
    },
    3845639894: function(r) {
      return { _: "secureValueErrorSelfie", type: r.object(), fileHash: r.bytes(), text: r.string() };
    },
    2054162547: function(r) {
      return { _: "secureValueErrorFile", type: r.object(), fileHash: r.bytes(), text: r.string() };
    },
    1717706985: function(r) {
      return { _: "secureValueErrorFiles", type: r.object(), fileHash: r.vector(r.bytes), text: r.string() };
    },
    2258466191: function(r) {
      return { _: "secureValueError", type: r.object(), hash: r.bytes(), text: r.string() };
    },
    2702460784: function(r) {
      return { _: "secureValueErrorTranslationFile", type: r.object(), fileHash: r.bytes(), text: r.string() };
    },
    878931416: function(r) {
      return { _: "secureValueErrorTranslationFiles", type: r.object(), fileHash: r.vector(r.bytes), text: r.string() };
    },
    871426631: function(r) {
      return { _: "secureCredentialsEncrypted", data: r.bytes(), hash: r.bytes(), secret: r.bytes() };
    },
    2905480408: function(r) {
      var flags = r.uint();
      return { _: "account.authorizationForm", requiredTypes: r.vector(r.object), values: r.vector(r.object), errors: r.vector(r.object), users: r.vector(r.object), privacyPolicyUrl: flags & 1 ? r.string() : void 0 };
    },
    2166326607: function(r) {
      return { _: "account.sentEmailCode", emailPattern: r.string(), length: r.int() };
    },
    1722786150: function(r) {
      return { _: "help.deepLinkInfoEmpty" };
    },
    1783556146: function(r) {
      var flags = r.uint();
      return { _: "help.deepLinkInfo", updateApp: !!(flags & 1), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0 };
    },
    289586518: function(r) {
      return { _: "savedPhoneContact", phone: r.string(), firstName: r.string(), lastName: r.string(), date: r.int() };
    },
    1304052993: function(r) {
      return { _: "account.takeout", id: r.long() };
    },
    3562713238: function(r) {
      return { _: "passwordKdfAlgoUnknown" };
    },
    982592842: function(r) {
      return { _: "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow", salt1: r.bytes(), salt2: r.bytes(), g: r.int(), p: r.bytes() };
    },
    4883767: function(r) {
      return { _: "securePasswordKdfAlgoUnknown" };
    },
    3153255840: function(r) {
      return { _: "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000", salt: r.bytes() };
    },
    2252807570: function(r) {
      return { _: "securePasswordKdfAlgoSHA512", salt: r.bytes() };
    },
    354925740: function(r) {
      return { _: "secureSecretSettings", secureAlgo: r.object(), secureSecret: r.bytes(), secureSecretId: r.long() };
    },
    2558588504: function(r) {
      return { _: "inputCheckPasswordEmpty" };
    },
    3531600002: function(r) {
      return { _: "inputCheckPasswordSRP", srpId: r.long(), A: r.bytes(), M1: r.bytes() };
    },
    2191366618: function(r) {
      var flags = r.uint();
      return { _: "secureRequiredType", nativeNames: !!(flags & 1), selfieRequired: !!(flags & 2), translationRequired: !!(flags & 4), type: r.object() };
    },
    41187252: function(r) {
      return { _: "secureRequiredTypeOneOf", types: r.vector(r.object) };
    },
    3216634967: function(r) {
      return { _: "help.passportConfigNotModified" };
    },
    2694370991: function(r) {
      return { _: "help.passportConfig", hash: r.int(), countriesLangs: r.object() };
    },
    488313413: function(r) {
      return { _: "inputAppEvent", time: r.double(), type: r.string(), peer: r.long(), data: r.object() };
    },
    3235781593: function(r) {
      return { _: "jsonObjectValue", key: r.string(), value: r.object() };
    },
    1064139624: function(r) {
      return { _: "jsonNull" };
    },
    3342098026: function(r) {
      return { _: "jsonBool", value: r.boolean() };
    },
    736157604: function(r) {
      return { _: "jsonNumber", value: r.double() };
    },
    3072226938: function(r) {
      return { _: "jsonString", value: r.string() };
    },
    4148447075: function(r) {
      return { _: "jsonArray", value: r.vector(r.object) };
    },
    2579616925: function(r) {
      return { _: "jsonObject", value: r.vector(r.object) };
    },
    878078826: function(r) {
      var flags = r.uint();
      return { _: "pageTableCell", header: !!(flags & 1), alignCenter: !!(flags & 8), alignRight: !!(flags & 16), valignMiddle: !!(flags & 32), valignBottom: !!(flags & 64), text: flags & 128 ? r.object() : void 0, colspan: flags & 2 ? r.int() : void 0, rowspan: flags & 4 ? r.int() : void 0 };
    },
    3770729957: function(r) {
      return { _: "pageTableRow", cells: r.vector(r.object) };
    },
    1869903447: function(r) {
      return { _: "pageCaption", text: r.object(), credit: r.object() };
    },
    3106911949: function(r) {
      return { _: "pageListItemText", text: r.object() };
    },
    635466748: function(r) {
      return { _: "pageListItemBlocks", blocks: r.vector(r.object) };
    },
    1577484359: function(r) {
      return { _: "pageListOrderedItemText", num: r.string(), text: r.object() };
    },
    2564655414: function(r) {
      return { _: "pageListOrderedItemBlocks", num: r.string(), blocks: r.vector(r.object) };
    },
    3012615176: function(r) {
      var flags = r.uint();
      return { _: "pageRelatedArticle", url: r.string(), webpageId: r.long(), title: flags & 1 ? r.string() : void 0, description: flags & 2 ? r.string() : void 0, photoId: flags & 4 ? r.long() : void 0, author: flags & 8 ? r.string() : void 0, publishedDate: flags & 16 ? r.int() : void 0 };
    },
    2556788493: function(r) {
      var flags = r.uint();
      return { _: "page", part: !!(flags & 1), rtl: !!(flags & 2), v2: !!(flags & 4), url: r.string(), blocks: r.vector(r.object), photos: r.vector(r.object), documents: r.vector(r.object), views: flags & 8 ? r.int() : void 0 };
    },
    2349199817: function(r) {
      return { _: "help.supportName", name: r.string() };
    },
    4088278765: function(r) {
      return { _: "help.userInfoEmpty" };
    },
    32192344: function(r) {
      return { _: "help.userInfo", message: r.string(), entities: r.vector(r.object), author: r.string(), date: r.int() };
    },
    4279689930: function(r) {
      return { _: "pollAnswer", text: r.object(), option: r.bytes() };
    },
    1484026161: function(r) {
      var id2 = r.long(), flags = r.uint();
      return { _: "poll", id: id2, closed: !!(flags & 1), publicVoters: !!(flags & 2), multipleChoice: !!(flags & 4), quiz: !!(flags & 8), question: r.object(), answers: r.vector(r.object), closePeriod: flags & 16 ? r.int() : void 0, closeDate: flags & 32 ? r.int() : void 0 };
    },
    997055186: function(r) {
      var flags = r.uint();
      return { _: "pollAnswerVoters", chosen: !!(flags & 1), correct: !!(flags & 2), option: r.bytes(), voters: r.int() };
    },
    2061444128: function(r) {
      var flags = r.uint();
      return { _: "pollResults", min: !!(flags & 1), results: flags & 2 ? r.vector(r.object) : void 0, totalVoters: flags & 4 ? r.int() : void 0, recentVoters: flags & 8 ? r.vector(r.object) : void 0, solution: flags & 16 ? r.string() : void 0, solutionEntities: flags & 16 ? r.vector(r.object) : void 0 };
    },
    4030849616: function(r) {
      return { _: "chatOnlines", onlines: r.int() };
    },
    1202287072: function(r) {
      return { _: "statsURL", url: r.string() };
    },
    1605510357: function(r) {
      var flags = r.uint();
      return { _: "chatAdminRights", changeInfo: !!(flags & 1), postMessages: !!(flags & 2), editMessages: !!(flags & 4), deleteMessages: !!(flags & 8), banUsers: !!(flags & 16), inviteUsers: !!(flags & 32), pinMessages: !!(flags & 128), addAdmins: !!(flags & 512), anonymous: !!(flags & 1024), manageCall: !!(flags & 2048), other: !!(flags & 4096), manageTopics: !!(flags & 8192), postStories: !!(flags & 16384), editStories: !!(flags & 32768), deleteStories: !!(flags & 65536) };
    },
    2668758040: function(r) {
      var flags = r.uint();
      return { _: "chatBannedRights", viewMessages: !!(flags & 1), sendMessages: !!(flags & 2), sendMedia: !!(flags & 4), sendStickers: !!(flags & 8), sendGifs: !!(flags & 16), sendGames: !!(flags & 32), sendInline: !!(flags & 64), embedLinks: !!(flags & 128), sendPolls: !!(flags & 256), changeInfo: !!(flags & 1024), inviteUsers: !!(flags & 32768), pinMessages: !!(flags & 131072), manageTopics: !!(flags & 262144), sendPhotos: !!(flags & 524288), sendVideos: !!(flags & 1048576), sendRoundvideos: !!(flags & 2097152), sendAudios: !!(flags & 4194304), sendVoices: !!(flags & 8388608), sendDocs: !!(flags & 16777216), sendPlain: !!(flags & 33554432), untilDate: r.int() };
    },
    3861952889: function(r) {
      return { _: "inputWallPaper", id: r.long(), accessHash: r.long() };
    },
    1913199744: function(r) {
      return { _: "inputWallPaperSlug", slug: r.string() };
    },
    2524595758: function(r) {
      return { _: "inputWallPaperNoFile", id: r.long() };
    },
    471437699: function(r) {
      return { _: "account.wallPapersNotModified" };
    },
    3452142988: function(r) {
      return { _: "account.wallPapers", hash: r.long(), wallpapers: r.vector(r.object) };
    },
    2904898936: function(r) {
      var flags = r.uint();
      return { _: "codeSettings", allowFlashcall: !!(flags & 1), currentNumber: !!(flags & 2), allowAppHash: !!(flags & 16), allowMissedCall: !!(flags & 32), allowFirebase: !!(flags & 128), unknownNumber: !!(flags & 512), logoutTokens: flags & 64 ? r.vector(r.bytes) : void 0, token: flags & 256 ? r.string() : void 0, appSandbox: flags & 256 ? r.boolean() : void 0 };
    },
    925826256: function(r) {
      var flags = r.uint();
      return { _: "wallPaperSettings", blur: !!(flags & 2), motion: !!(flags & 4), backgroundColor: flags & 1 ? r.int() : void 0, secondBackgroundColor: flags & 16 ? r.int() : void 0, thirdBackgroundColor: flags & 32 ? r.int() : void 0, fourthBackgroundColor: flags & 64 ? r.int() : void 0, intensity: flags & 8 ? r.int() : void 0, rotation: flags & 16 ? r.int() : void 0, emoticon: flags & 128 ? r.string() : void 0 };
    },
    3131405864: function(r) {
      var flags = r.uint();
      return { _: "autoDownloadSettings", disabled: !!(flags & 1), videoPreloadLarge: !!(flags & 2), audioPreloadNext: !!(flags & 4), phonecallsLessData: !!(flags & 8), storiesPreload: !!(flags & 16), photoSizeMax: r.int(), videoSizeMax: r.int53(), fileSizeMax: r.int53(), videoUploadMaxbitrate: r.int(), smallQueueActiveOperationsMax: r.int(), largeQueueActiveOperationsMax: r.int() };
    },
    1674235686: function(r) {
      return { _: "account.autoDownloadSettings", low: r.object(), medium: r.object(), high: r.object() };
    },
    3585325561: function(r) {
      return { _: "emojiKeyword", keyword: r.string(), emoticons: r.vector(r.string) };
    },
    594408994: function(r) {
      return { _: "emojiKeywordDeleted", keyword: r.string(), emoticons: r.vector(r.string) };
    },
    1556570557: function(r) {
      return { _: "emojiKeywordsDifference", langCode: r.string(), fromVersion: r.int(), version: r.int(), keywords: r.vector(r.object) };
    },
    2775937949: function(r) {
      return { _: "emojiURL", url: r.string() };
    },
    3019592545: function(r) {
      return { _: "emojiLanguage", langCode: r.string() };
    },
    4283715173: function(r) {
      var flags = r.uint();
      return { _: "folder", autofillNewBroadcasts: !!(flags & 1), autofillPublicGroups: !!(flags & 2), autofillNewCorrespondents: !!(flags & 4), id: r.int(), title: r.string(), photo: flags & 8 ? r.object() : void 0 };
    },
    4224893590: function(r) {
      return { _: "inputFolderPeer", peer: r.object(), folderId: r.int() };
    },
    3921323624: function(r) {
      return { _: "folderPeer", peer: r.object(), folderId: r.int() };
    },
    3896830975: function(r) {
      var flags = r.uint();
      return { _: "messages.searchCounter", inexact: !!(flags & 2), filter: r.object(), count: r.int() };
    },
    2463316494: function(r) {
      var flags = r.uint();
      return { _: "urlAuthResultRequest", requestWriteAccess: !!(flags & 1), bot: r.object(), domain: r.string() };
    },
    2408320590: function(r) {
      return { _: "urlAuthResultAccepted", url: r.string() };
    },
    2849430303: function(r) {
      return { _: "urlAuthResultDefault" };
    },
    3216354699: function(r) {
      return { _: "channelLocationEmpty" };
    },
    547062491: function(r) {
      return { _: "channelLocation", geoPoint: r.object(), address: r.string() };
    },
    3393592157: function(r) {
      return { _: "peerLocated", peer: r.object(), expires: r.int(), distance: r.int() };
    },
    4176226379: function(r) {
      return { _: "peerSelfLocated", expires: r.int() };
    },
    3497176244: function(r) {
      return { _: "restrictionReason", platform: r.string(), reason: r.string(), text: r.string() };
    },
    1012306921: function(r) {
      return { _: "inputTheme", id: r.long(), accessHash: r.long() };
    },
    4119399921: function(r) {
      return { _: "inputThemeSlug", slug: r.string() };
    },
    2685298646: function(r) {
      var flags = r.uint();
      return { _: "theme", creator: !!(flags & 1), default: !!(flags & 2), forChat: !!(flags & 32), id: r.long(), accessHash: r.long(), slug: r.string(), title: r.string(), document: flags & 4 ? r.object() : void 0, settings: flags & 8 ? r.vector(r.object) : void 0, emoticon: flags & 64 ? r.string() : void 0, installsCount: flags & 16 ? r.int() : void 0 };
    },
    4095653410: function(r) {
      return { _: "account.themesNotModified" };
    },
    2587724909: function(r) {
      return { _: "account.themes", hash: r.long(), themes: r.vector(r.object) };
    },
    1654593920: function(r) {
      return { _: "auth.loginToken", expires: r.int(), token: r.bytes() };
    },
    110008598: function(r) {
      return { _: "auth.loginTokenMigrateTo", dcId: r.int(), token: r.bytes() };
    },
    957176926: function(r) {
      return { _: "auth.loginTokenSuccess", authorization: r.object() };
    },
    1474462241: function(r) {
      var flags = r.uint();
      return { _: "account.contentSettings", sensitiveEnabled: !!(flags & 1), sensitiveCanChange: !!(flags & 2) };
    },
    2837970629: function(r) {
      return { _: "messages.inactiveChats", dates: r.vector(r.int), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3282117730: function(r) {
      return { _: "baseThemeClassic" };
    },
    4225242760: function(r) {
      return { _: "baseThemeDay" };
    },
    3081969320: function(r) {
      return { _: "baseThemeNight" };
    },
    1834973166: function(r) {
      return { _: "baseThemeTinted" };
    },
    1527845466: function(r) {
      return { _: "baseThemeArctic" };
    },
    2413711439: function(r) {
      var flags = r.uint();
      return { _: "inputThemeSettings", messageColorsAnimated: !!(flags & 4), baseTheme: r.object(), accentColor: r.int(), outboxAccentColor: flags & 8 ? r.int() : void 0, messageColors: flags & 1 ? r.vector(r.int) : void 0, wallpaper: flags & 2 ? r.object() : void 0, wallpaperSettings: flags & 2 ? r.object() : void 0 };
    },
    4200117972: function(r) {
      var flags = r.uint();
      return { _: "themeSettings", messageColorsAnimated: !!(flags & 4), baseTheme: r.object(), accentColor: r.int(), outboxAccentColor: flags & 8 ? r.int() : void 0, messageColors: flags & 1 ? r.vector(r.int) : void 0, wallpaper: flags & 2 ? r.object() : void 0 };
    },
    1421174295: function(r) {
      var flags = r.uint();
      return { _: "webPageAttributeTheme", documents: flags & 1 ? r.vector(r.object) : void 0, settings: flags & 2 ? r.object() : void 0 };
    },
    781501415: function(r) {
      var flags = r.uint();
      return { _: "webPageAttributeStory", peer: r.object(), id: r.int(), story: flags & 1 ? r.object() : void 0 };
    },
    1355547603: function(r) {
      var flags = r.uint();
      return { _: "webPageAttributeStickerSet", emojis: !!(flags & 1), textColor: !!(flags & 2), stickers: r.vector(r.object) };
    },
    1218005070: function(r) {
      var flags = r.uint();
      return { _: "messages.votesList", count: r.int(), votes: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0 };
    },
    4117234314: function(r) {
      return { _: "bankCardOpenUrl", url: r.string(), name: r.string() };
    },
    1042605427: function(r) {
      return { _: "payments.bankCardData", title: r.string(), openUrls: r.vector(r.object) };
    },
    1605718587: function(r) {
      var flags = r.uint();
      return { _: "dialogFilter", contacts: !!(flags & 1), nonContacts: !!(flags & 2), groups: !!(flags & 4), broadcasts: !!(flags & 8), bots: !!(flags & 16), excludeMuted: !!(flags & 2048), excludeRead: !!(flags & 4096), excludeArchived: !!(flags & 8192), id: r.int(), title: r.string(), emoticon: flags & 33554432 ? r.string() : void 0, color: flags & 134217728 ? r.int() : void 0, pinnedPeers: r.vector(r.object), includePeers: r.vector(r.object), excludePeers: r.vector(r.object) };
    },
    909284270: function(r) {
      return { _: "dialogFilterDefault" };
    },
    2682424996: function(r) {
      var flags = r.uint();
      return { _: "dialogFilterChatlist", hasMyInvites: !!(flags & 67108864), id: r.int(), title: r.string(), emoticon: flags & 33554432 ? r.string() : void 0, color: flags & 134217728 ? r.int() : void 0, pinnedPeers: r.vector(r.object), includePeers: r.vector(r.object) };
    },
    2004110666: function(r) {
      return { _: "dialogFilterSuggested", filter: r.object(), description: r.string() };
    },
    3057118639: function(r) {
      return { _: "statsDateRangeDays", minDate: r.int(), maxDate: r.int() };
    },
    3410210014: function(r) {
      return { _: "statsAbsValueAndPrev", current: r.double(), previous: r.double() };
    },
    3419287520: function(r) {
      return { _: "statsPercentValue", part: r.double(), total: r.double() };
    },
    1244130093: function(r) {
      return { _: "statsGraphAsync", token: r.string() };
    },
    3202127906: function(r) {
      return { _: "statsGraphError", error: r.string() };
    },
    2393138358: function(r) {
      var flags = r.uint();
      return { _: "statsGraph", json: r.object(), zoomToken: flags & 1 ? r.string() : void 0 };
    },
    963421692: function(r) {
      return { _: "stats.broadcastStats", period: r.object(), followers: r.object(), viewsPerPost: r.object(), sharesPerPost: r.object(), reactionsPerPost: r.object(), viewsPerStory: r.object(), sharesPerStory: r.object(), reactionsPerStory: r.object(), enabledNotifications: r.object(), growthGraph: r.object(), followersGraph: r.object(), muteGraph: r.object(), topHoursGraph: r.object(), interactionsGraph: r.object(), ivInteractionsGraph: r.object(), viewsBySourceGraph: r.object(), newFollowersBySourceGraph: r.object(), languagesGraph: r.object(), reactionsByEmotionGraph: r.object(), storyInteractionsGraph: r.object(), storyReactionsByEmotionGraph: r.object(), recentPostsInteractions: r.vector(r.object) };
    },
    2566302837: function(r) {
      return { _: "help.promoDataEmpty", expires: r.int() };
    },
    2352576831: function(r) {
      var flags = r.uint();
      return { _: "help.promoData", proxy: !!(flags & 1), expires: r.int(), peer: r.object(), chats: r.vector(r.object), users: r.vector(r.object), psaType: flags & 2 ? r.string() : void 0, psaMessage: flags & 4 ? r.string() : void 0 };
    },
    3727929492: function(r) {
      var flags = r.uint();
      return { _: "videoSize", type: r.string(), w: r.int(), h: r.int(), size: r.int(), videoStartTs: flags & 1 ? r.double() : void 0 };
    },
    4166795580: function(r) {
      return { _: "videoSizeEmojiMarkup", emojiId: r.long(), backgroundColors: r.vector(r.int) };
    },
    228623102: function(r) {
      return { _: "videoSizeStickerMarkup", stickerset: r.object(), stickerId: r.long(), backgroundColors: r.vector(r.int) };
    },
    2634330011: function(r) {
      return { _: "statsGroupTopPoster", userId: r.int53(), messages: r.int(), avgChars: r.int() };
    },
    3612888199: function(r) {
      return { _: "statsGroupTopAdmin", userId: r.int53(), deleted: r.int(), kicked: r.int(), banned: r.int() };
    },
    1398765469: function(r) {
      return { _: "statsGroupTopInviter", userId: r.int53(), invitations: r.int() };
    },
    4018141462: function(r) {
      return { _: "stats.megagroupStats", period: r.object(), members: r.object(), messages: r.object(), viewers: r.object(), posters: r.object(), growthGraph: r.object(), membersGraph: r.object(), newMembersBySourceGraph: r.object(), languagesGraph: r.object(), messagesGraph: r.object(), actionsGraph: r.object(), topHoursGraph: r.object(), weekdaysGraph: r.object(), topPosters: r.vector(r.object), topAdmins: r.vector(r.object), topInviters: r.vector(r.object), users: r.vector(r.object) };
    },
    1934380235: function(r) {
      var flags = r.uint();
      return { _: "globalPrivacySettings", archiveAndMuteNewNoncontactPeers: !!(flags & 1), keepArchivedUnmuted: !!(flags & 2), keepArchivedFolders: !!(flags & 4), hideReadMarks: !!(flags & 8), newNoncontactPeersRequirePremium: !!(flags & 16) };
    },
    1107543535: function(r) {
      var flags = r.uint();
      return { _: "help.countryCode", countryCode: r.string(), prefixes: flags & 1 ? r.vector(r.string) : void 0, patterns: flags & 2 ? r.vector(r.string) : void 0 };
    },
    3280440867: function(r) {
      var flags = r.uint();
      return { _: "help.country", hidden: !!(flags & 1), iso2: r.string(), defaultName: r.string(), name: flags & 2 ? r.string() : void 0, countryCodes: r.vector(r.object) };
    },
    2479628082: function(r) {
      return { _: "help.countriesListNotModified" };
    },
    2278585758: function(r) {
      return { _: "help.countriesList", countries: r.vector(r.object), hash: r.int() };
    },
    1163625789: function(r) {
      var flags = r.uint();
      return { _: "messageViews", views: flags & 1 ? r.int() : void 0, forwards: flags & 2 ? r.int() : void 0, replies: flags & 4 ? r.object() : void 0 };
    },
    3066361155: function(r) {
      return { _: "messages.messageViews", views: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2788431746: function(r) {
      var flags = r.uint();
      return { _: "messages.discussionMessage", messages: r.vector(r.object), maxId: flags & 1 ? r.int() : void 0, readInboxMaxId: flags & 2 ? r.int() : void 0, readOutboxMaxId: flags & 4 ? r.int() : void 0, unreadCount: r.int(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2948336091: function(r) {
      var flags = r.uint();
      return { _: "messageReplyHeader", replyToScheduled: !!(flags & 4), forumTopic: !!(flags & 8), quote: !!(flags & 512), replyToMsgId: flags & 16 ? r.int() : void 0, replyToPeerId: flags & 1 ? r.object() : void 0, replyFrom: flags & 32 ? r.object() : void 0, replyMedia: flags & 256 ? r.object() : void 0, replyToTopId: flags & 2 ? r.int() : void 0, quoteText: flags & 64 ? r.string() : void 0, quoteEntities: flags & 128 ? r.vector(r.object) : void 0, quoteOffset: flags & 1024 ? r.int() : void 0 };
    },
    240843065: function(r) {
      return { _: "messageReplyStoryHeader", peer: r.object(), storyId: r.int() };
    },
    2211844034: function(r) {
      var flags = r.uint();
      return { _: "messageReplies", comments: !!(flags & 1), replies: r.int(), repliesPts: r.int(), recentRepliers: flags & 2 ? r.vector(r.object) : void 0, channelId: flags & 1 ? r.int53() : void 0, maxId: flags & 4 ? r.int() : void 0, readMaxId: flags & 8 ? r.int() : void 0 };
    },
    3908927508: function(r) {
      return { _: "peerBlocked", peerId: r.object(), date: r.int() };
    },
    2145983508: function(r) {
      return { _: "stats.messageStats", viewsGraph: r.object(), reactionsByEmotionGraph: r.object() };
    },
    2004925620: function(r) {
      return { _: "groupCallDiscarded", id: r.long(), accessHash: r.long(), duration: r.int() };
    },
    3583468812: function(r) {
      var flags = r.uint();
      return { _: "groupCall", joinMuted: !!(flags & 2), canChangeJoinMuted: !!(flags & 4), joinDateAsc: !!(flags & 64), scheduleStartSubscribed: !!(flags & 256), canStartVideo: !!(flags & 512), recordVideoActive: !!(flags & 2048), rtmpStream: !!(flags & 4096), listenersHidden: !!(flags & 8192), id: r.long(), accessHash: r.long(), participantsCount: r.int(), title: flags & 8 ? r.string() : void 0, streamDcId: flags & 16 ? r.int() : void 0, recordStartDate: flags & 32 ? r.int() : void 0, scheduleDate: flags & 128 ? r.int() : void 0, unmutedVideoCount: flags & 1024 ? r.int() : void 0, unmutedVideoLimit: r.int(), version: r.int() };
    },
    3635053583: function(r) {
      return { _: "inputGroupCall", id: r.long(), accessHash: r.long() };
    },
    3953538814: function(r) {
      var flags = r.uint();
      return { _: "groupCallParticipant", muted: !!(flags & 1), left: !!(flags & 2), canSelfUnmute: !!(flags & 4), justJoined: !!(flags & 16), versioned: !!(flags & 32), min: !!(flags & 256), mutedByYou: !!(flags & 512), volumeByAdmin: !!(flags & 1024), self: !!(flags & 4096), videoJoined: !!(flags & 32768), peer: r.object(), date: r.int(), activeDate: flags & 8 ? r.int() : void 0, source: r.int(), volume: flags & 128 ? r.int() : void 0, about: flags & 2048 ? r.string() : void 0, raiseHandRating: flags & 8192 ? r.long() : void 0, video: flags & 64 ? r.object() : void 0, presentation: flags & 16384 ? r.object() : void 0 };
    },
    2658302637: function(r) {
      return { _: "phone.groupCall", call: r.object(), participants: r.vector(r.object), participantsNextOffset: r.string(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    4101460406: function(r) {
      return { _: "phone.groupParticipants", count: r.int(), participants: r.vector(r.object), nextOffset: r.string(), chats: r.vector(r.object), users: r.vector(r.object), version: r.int() };
    },
    813821341: function(r) {
      return { _: "inlineQueryPeerTypeSameBotPM" };
    },
    2201751468: function(r) {
      return { _: "inlineQueryPeerTypePM" };
    },
    3613836554: function(r) {
      return { _: "inlineQueryPeerTypeChat" };
    },
    1589952067: function(r) {
      return { _: "inlineQueryPeerTypeMegagroup" };
    },
    1664413338: function(r) {
      return { _: "inlineQueryPeerTypeBroadcast" };
    },
    238759180: function(r) {
      return { _: "inlineQueryPeerTypeBotPM" };
    },
    375566091: function(r) {
      return { _: "messages.historyImport", id: r.long() };
    },
    1578088377: function(r) {
      var flags = r.uint();
      return { _: "messages.historyImportParsed", pm: !!(flags & 1), group: !!(flags & 2), title: flags & 4 ? r.string() : void 0 };
    },
    4019011180: function(r) {
      return { _: "messages.affectedFoundMessages", pts: r.int(), ptsCount: r.int(), offset: r.int(), messages: r.vector(r.int) };
    },
    2354765785: function(r) {
      var flags = r.uint();
      return { _: "chatInviteImporter", requested: !!(flags & 1), viaChatlist: !!(flags & 8), userId: r.int53(), date: r.int(), about: flags & 4 ? r.string() : void 0, approvedBy: flags & 2 ? r.int53() : void 0 };
    },
    3183881676: function(r) {
      return { _: "messages.exportedChatInvites", count: r.int(), invites: r.vector(r.object), users: r.vector(r.object) };
    },
    410107472: function(r) {
      return { _: "messages.exportedChatInvite", invite: r.object(), users: r.vector(r.object) };
    },
    572915951: function(r) {
      return { _: "messages.exportedChatInviteReplaced", invite: r.object(), newInvite: r.object(), users: r.vector(r.object) };
    },
    2176233482: function(r) {
      return { _: "messages.chatInviteImporters", count: r.int(), importers: r.vector(r.object), users: r.vector(r.object) };
    },
    4075613987: function(r) {
      return { _: "chatAdminWithInvites", adminId: r.int53(), invitesCount: r.int(), revokedInvitesCount: r.int() };
    },
    3063640791: function(r) {
      return { _: "messages.chatAdminsWithInvites", admins: r.vector(r.object), users: r.vector(r.object) };
    },
    2723014423: function(r) {
      return { _: "messages.checkedHistoryImportPeer", confirmText: r.string() };
    },
    2951045695: function(r) {
      return { _: "phone.joinAsPeers", peers: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    541839704: function(r) {
      return { _: "phone.exportedGroupCallInvite", link: r.string() };
    },
    3702593719: function(r) {
      return { _: "groupCallParticipantVideoSourceGroup", semantics: r.string(), sources: r.vector(r.int) };
    },
    1735736008: function(r) {
      var flags = r.uint();
      return { _: "groupCallParticipantVideo", paused: !!(flags & 1), endpoint: r.string(), sourceGroups: r.vector(r.object), audioSource: flags & 2 ? r.int() : void 0 };
    },
    2248056895: function(r) {
      return { _: "stickers.suggestedShortName", shortName: r.string() };
    },
    795652779: function(r) {
      return { _: "botCommandScopeDefault" };
    },
    1011811544: function(r) {
      return { _: "botCommandScopeUsers" };
    },
    1877059713: function(r) {
      return { _: "botCommandScopeChats" };
    },
    3114950762: function(r) {
      return { _: "botCommandScopeChatAdmins" };
    },
    3684534653: function(r) {
      return { _: "botCommandScopePeer", peer: r.object() };
    },
    1071145937: function(r) {
      return { _: "botCommandScopePeerAdmins", peer: r.object() };
    },
    169026035: function(r) {
      return { _: "botCommandScopePeerUser", peer: r.object(), userId: r.object() };
    },
    3816265825: function(r) {
      return { _: "account.resetPasswordFailedWait", retryDate: r.int() };
    },
    3924819069: function(r) {
      return { _: "account.resetPasswordRequestedWait", untilDate: r.int() };
    },
    3911636542: function(r) {
      return { _: "account.resetPasswordOk" };
    },
    1301522832: function(r) {
      var flags = r.uint();
      return { _: "sponsoredMessage", recommended: !!(flags & 32), canReport: !!(flags & 4096), randomId: r.bytes(), url: r.string(), title: r.string(), message: r.string(), entities: flags & 2 ? r.vector(r.object) : void 0, photo: flags & 64 ? r.object() : void 0, media: flags & 16384 ? r.object() : void 0, color: flags & 8192 ? r.object() : void 0, buttonText: r.string(), sponsorInfo: flags & 128 ? r.string() : void 0, additionalInfo: flags & 256 ? r.string() : void 0 };
    },
    3387825543: function(r) {
      var flags = r.uint();
      return { _: "messages.sponsoredMessages", postsBetween: flags & 1 ? r.int() : void 0, messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    406407439: function(r) {
      return { _: "messages.sponsoredMessagesEmpty" };
    },
    3383776159: function(r) {
      return { _: "searchResultsCalendarPeriod", date: r.int(), minMsgId: r.int(), maxMsgId: r.int(), count: r.int() };
    },
    343859772: function(r) {
      var flags = r.uint();
      return { _: "messages.searchResultsCalendar", inexact: !!(flags & 1), count: r.int(), minDate: r.int(), minMsgId: r.int(), offsetIdOffset: flags & 2 ? r.int() : void 0, periods: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2137295719: function(r) {
      return { _: "searchResultPosition", msgId: r.int(), date: r.int(), offset: r.int() };
    },
    1404185519: function(r) {
      return { _: "messages.searchResultsPositions", count: r.int(), positions: r.vector(r.object) };
    },
    4103516358: function(r) {
      return { _: "channels.sendAsPeers", peers: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    997004590: function(r) {
      return { _: "users.userFull", fullUser: r.object(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1753266509: function(r) {
      return { _: "messages.peerSettings", settings: r.object(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3282207583: function(r) {
      var flags = r.uint();
      return { _: "auth.loggedOut", futureAuthToken: flags & 1 ? r.bytes() : void 0 };
    },
    2748435328: function(r) {
      var flags = r.uint();
      return { _: "reactionCount", chosenOrder: flags & 1 ? r.int() : void 0, reaction: r.object(), count: r.int() };
    },
    171155211: function(r) {
      var flags = r.uint();
      return { _: "messageReactions", min: !!(flags & 1), canSeeList: !!(flags & 4), reactionsAsTags: !!(flags & 8), results: r.vector(r.object), recentReactions: flags & 2 ? r.vector(r.object) : void 0, topReactors: flags & 16 ? r.vector(r.object) : void 0 };
    },
    834488621: function(r) {
      var flags = r.uint();
      return { _: "messages.messageReactionsList", count: r.int(), reactions: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0 };
    },
    3229084673: function(r) {
      var flags = r.uint();
      return { _: "availableReaction", inactive: !!(flags & 1), premium: !!(flags & 4), reaction: r.string(), title: r.string(), staticIcon: r.object(), appearAnimation: r.object(), selectAnimation: r.object(), activateAnimation: r.object(), effectAnimation: r.object(), aroundAnimation: flags & 2 ? r.object() : void 0, centerIcon: flags & 2 ? r.object() : void 0 };
    },
    2668042583: function(r) {
      return { _: "messages.availableReactionsNotModified" };
    },
    1989032621: function(r) {
      return { _: "messages.availableReactions", hash: r.int(), reactions: r.vector(r.object) };
    },
    2356786748: function(r) {
      var flags = r.uint();
      return { _: "messagePeerReaction", big: !!(flags & 1), unread: !!(flags & 2), my: !!(flags & 4), peerId: r.object(), date: r.int(), reaction: r.object() };
    },
    2162903215: function(r) {
      return { _: "groupCallStreamChannel", channel: r.int(), scale: r.int(), lastTimestampMs: r.long() };
    },
    3504636594: function(r) {
      return { _: "phone.groupCallStreamChannels", channels: r.vector(r.object) };
    },
    767505458: function(r) {
      return { _: "phone.groupCallStreamRtmpUrl", url: r.string(), key: r.string() };
    },
    1165423600: function(r) {
      return { _: "attachMenuBotIconColor", name: r.string(), color: r.int() };
    },
    2997303403: function(r) {
      var flags = r.uint();
      return { _: "attachMenuBotIcon", name: r.string(), icon: r.object(), colors: flags & 1 ? r.vector(r.object) : void 0 };
    },
    3641544190: function(r) {
      var flags = r.uint();
      return { _: "attachMenuBot", inactive: !!(flags & 1), hasSettings: !!(flags & 2), requestWriteAccess: !!(flags & 4), showInAttachMenu: !!(flags & 8), showInSideMenu: !!(flags & 16), sideMenuDisclaimerNeeded: !!(flags & 32), botId: r.int53(), shortName: r.string(), peerTypes: flags & 8 ? r.vector(r.object) : void 0, icons: r.vector(r.object) };
    },
    4057500252: function(r) {
      return { _: "attachMenuBotsNotModified" };
    },
    1011024320: function(r) {
      return { _: "attachMenuBots", hash: r.long(), bots: r.vector(r.object), users: r.vector(r.object) };
    },
    2478794367: function(r) {
      return { _: "attachMenuBotsBot", bot: r.object(), users: r.vector(r.object) };
    },
    1294139288: function(r) {
      var flags = r.uint();
      return { _: "webViewResultUrl", fullsize: !!(flags & 2), queryId: flags & 1 ? r.long() : void 0, url: r.string() };
    },
    211046684: function(r) {
      var flags = r.uint();
      return { _: "webViewMessageSent", msgId: flags & 1 ? r.object() : void 0 };
    },
    1966318984: function(r) {
      return { _: "botMenuButtonDefault" };
    },
    1113113093: function(r) {
      return { _: "botMenuButtonCommands" };
    },
    3350559974: function(r) {
      return { _: "botMenuButton", text: r.string(), url: r.string() };
    },
    4227262641: function(r) {
      return { _: "account.savedRingtonesNotModified" };
    },
    3253284037: function(r) {
      return { _: "account.savedRingtones", hash: r.long(), ringtones: r.vector(r.object) };
    },
    2548612798: function(r) {
      return { _: "notificationSoundDefault" };
    },
    1863070943: function(r) {
      return { _: "notificationSoundNone" };
    },
    2198575844: function(r) {
      return { _: "notificationSoundLocal", title: r.string(), data: r.string() };
    },
    4285300809: function(r) {
      return { _: "notificationSoundRingtone", id: r.long() };
    },
    3072737133: function(r) {
      return { _: "account.savedRingtone" };
    },
    523271863: function(r) {
      return { _: "account.savedRingtoneConverted", document: r.object() };
    },
    2104224014: function(r) {
      return { _: "attachMenuPeerTypeSameBotPM" };
    },
    3274439194: function(r) {
      return { _: "attachMenuPeerTypeBotPM" };
    },
    4047950623: function(r) {
      return { _: "attachMenuPeerTypePM" };
    },
    84480319: function(r) {
      return { _: "attachMenuPeerTypeChat" };
    },
    2080104188: function(r) {
      return { _: "attachMenuPeerTypeBroadcast" };
    },
    3317000281: function(r) {
      return { _: "inputInvoiceMessage", peer: r.object(), msgId: r.int() };
    },
    3274099439: function(r) {
      return { _: "inputInvoiceSlug", slug: r.string() };
    },
    2560125965: function(r) {
      return { _: "inputInvoicePremiumGiftCode", purpose: r.object(), option: r.object() };
    },
    1710230755: function(r) {
      return { _: "inputInvoiceStars", purpose: r.object() };
    },
    887591921: function(r) {
      return { _: "inputInvoiceChatInviteSubscription", hash: r.string() };
    },
    634962392: function(r) {
      var flags = r.uint();
      return { _: "inputInvoiceStarGift", hideName: !!(flags & 1), userId: r.object(), giftId: r.long(), message: flags & 2 ? r.object() : void 0 };
    },
    2932919257: function(r) {
      return { _: "payments.exportedInvoice", url: r.string() };
    },
    3485063511: function(r) {
      var flags = r.uint();
      return { _: "messages.transcribedAudio", pending: !!(flags & 1), transcriptionId: r.long(), text: r.string(), trialRemainsNum: flags & 2 ? r.int() : void 0, trialRemainsUntilDate: flags & 2 ? r.int() : void 0 };
    },
    1395946908: function(r) {
      return { _: "help.premiumPromo", statusText: r.string(), statusEntities: r.vector(r.object), videoSections: r.vector(r.string), videos: r.vector(r.object), periodOptions: r.vector(r.object), users: r.vector(r.object) };
    },
    2792693350: function(r) {
      var flags = r.uint();
      return { _: "inputStorePaymentPremiumSubscription", restore: !!(flags & 1), upgrade: !!(flags & 2) };
    },
    1634697192: function(r) {
      return { _: "inputStorePaymentGiftPremium", userId: r.object(), currency: r.string(), amount: r.long() };
    },
    2743099199: function(r) {
      var flags = r.uint();
      return { _: "inputStorePaymentPremiumGiftCode", users: r.vector(r.object), boostPeer: flags & 1 ? r.object() : void 0, currency: r.string(), amount: r.long() };
    },
    369444042: function(r) {
      var flags = r.uint();
      return { _: "inputStorePaymentPremiumGiveaway", onlyNewSubscribers: !!(flags & 1), winnersAreVisible: !!(flags & 8), boostPeer: r.object(), additionalPeers: flags & 2 ? r.vector(r.object) : void 0, countriesIso2: flags & 4 ? r.vector(r.string) : void 0, prizeDescription: flags & 16 ? r.string() : void 0, randomId: r.long(), untilDate: r.int(), currency: r.string(), amount: r.long() };
    },
    3722252118: function(r) {
      return { _: "inputStorePaymentStarsTopup", stars: r.long(), currency: r.string(), amount: r.long() };
    },
    494149367: function(r) {
      return { _: "inputStorePaymentStarsGift", userId: r.object(), stars: r.long(), currency: r.string(), amount: r.long() };
    },
    1964968186: function(r) {
      var flags = r.uint();
      return { _: "inputStorePaymentStarsGiveaway", onlyNewSubscribers: !!(flags & 1), winnersAreVisible: !!(flags & 8), stars: r.long(), boostPeer: r.object(), additionalPeers: flags & 2 ? r.vector(r.object) : void 0, countriesIso2: flags & 4 ? r.vector(r.string) : void 0, prizeDescription: flags & 16 ? r.string() : void 0, randomId: r.long(), untilDate: r.int(), currency: r.string(), amount: r.long(), users: r.int() };
    },
    1958953753: function(r) {
      var flags = r.uint();
      return { _: "premiumGiftOption", months: r.int(), currency: r.string(), amount: r.long(), botUrl: r.string(), storeProduct: flags & 1 ? r.string() : void 0 };
    },
    2298016283: function(r) {
      return { _: "paymentFormMethod", url: r.string(), title: r.string() };
    },
    769727150: function(r) {
      return { _: "emojiStatusEmpty" };
    },
    2459656605: function(r) {
      return { _: "emojiStatus", documentId: r.long() };
    },
    4197492935: function(r) {
      return { _: "emojiStatusUntil", documentId: r.long(), until: r.int() };
    },
    3498894917: function(r) {
      return { _: "account.emojiStatusesNotModified" };
    },
    2428790737: function(r) {
      return { _: "account.emojiStatuses", hash: r.long(), statuses: r.vector(r.object) };
    },
    2046153753: function(r) {
      return { _: "reactionEmpty" };
    },
    455247544: function(r) {
      return { _: "reactionEmoji", emoticon: r.string() };
    },
    2302016627: function(r) {
      return { _: "reactionCustomEmoji", documentId: r.long() };
    },
    1379771627: function(r) {
      return { _: "reactionPaid" };
    },
    3942396604: function(r) {
      return { _: "chatReactionsNone" };
    },
    1385335754: function(r) {
      var flags = r.uint();
      return { _: "chatReactionsAll", allowCustom: !!(flags & 1) };
    },
    1713193015: function(r) {
      return { _: "chatReactionsSome", reactions: r.vector(r.object) };
    },
    2960120799: function(r) {
      return { _: "messages.reactionsNotModified" };
    },
    3942512406: function(r) {
      return { _: "messages.reactions", hash: r.long(), reactions: r.vector(r.object) };
    },
    1128644211: function(r) {
      return { _: "emailVerifyPurposeLoginSetup", phoneNumber: r.string(), phoneCodeHash: r.string() };
    },
    1383932651: function(r) {
      return { _: "emailVerifyPurposeLoginChange" };
    },
    3153401477: function(r) {
      return { _: "emailVerifyPurposePassport" };
    },
    2452510121: function(r) {
      return { _: "emailVerificationCode", code: r.string() };
    },
    3683688130: function(r) {
      return { _: "emailVerificationGoogle", token: r.string() };
    },
    2530243837: function(r) {
      return { _: "emailVerificationApple", token: r.string() };
    },
    731303195: function(r) {
      return { _: "account.emailVerified", email: r.string() };
    },
    3787132257: function(r) {
      return { _: "account.emailVerifiedLogin", email: r.string(), sentCode: r.object() };
    },
    1596792306: function(r) {
      var flags = r.uint();
      return { _: "premiumSubscriptionOption", current: !!(flags & 2), canPurchaseUpgrade: !!(flags & 4), transaction: flags & 8 ? r.string() : void 0, months: r.int(), currency: r.string(), amount: r.long(), botUrl: r.string(), storeProduct: flags & 1 ? r.string() : void 0 };
    },
    3088871476: function(r) {
      var flags = r.uint();
      return { _: "sendAsPeer", premiumRequired: !!(flags & 1), peer: r.object() };
    },
    2908916936: function(r) {
      var flags = r.uint();
      return { _: "messageExtendedMediaPreview", w: flags & 1 ? r.int() : void 0, h: flags & 1 ? r.int() : void 0, thumb: flags & 2 ? r.object() : void 0, videoDuration: flags & 4 ? r.int() : void 0 };
    },
    3997670500: function(r) {
      return { _: "messageExtendedMedia", media: r.object() };
    },
    4244550300: function(r) {
      return { _: "stickerKeyword", documentId: r.long(), keyword: r.vector(r.string) };
    },
    3020371527: function(r) {
      var flags = r.uint();
      return { _: "username", editable: !!(flags & 1), active: !!(flags & 2), username: r.string() };
    },
    37687451: function(r) {
      return { _: "forumTopicDeleted", id: r.int() };
    },
    1903173033: function(r) {
      var flags = r.uint();
      return { _: "forumTopic", my: !!(flags & 2), closed: !!(flags & 4), pinned: !!(flags & 8), short: !!(flags & 32), hidden: !!(flags & 64), id: r.int(), date: r.int(), title: r.string(), iconColor: r.int(), iconEmojiId: flags & 1 ? r.long() : void 0, topMessage: r.int(), readInboxMaxId: r.int(), readOutboxMaxId: r.int(), unreadCount: r.int(), unreadMentionsCount: r.int(), unreadReactionsCount: r.int(), fromId: r.object(), notifySettings: r.object(), draft: flags & 16 ? r.object() : void 0 };
    },
    913709011: function(r) {
      var flags = r.uint();
      return { _: "messages.forumTopics", orderByCreateDate: !!(flags & 1), count: r.int(), topics: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), pts: r.int() };
    },
    1135897376: function(r) {
      return { _: "defaultHistoryTTL", period: r.int() };
    },
    1103040667: function(r) {
      return { _: "exportedContactToken", url: r.string(), expires: r.int() };
    },
    1597737472: function(r) {
      var flags = r.uint();
      return { _: "requestPeerTypeUser", bot: flags & 1 ? r.boolean() : void 0, premium: flags & 2 ? r.boolean() : void 0 };
    },
    3387977243: function(r) {
      var flags = r.uint();
      return { _: "requestPeerTypeChat", creator: !!(flags & 1), botParticipant: !!(flags & 32), hasUsername: flags & 8 ? r.boolean() : void 0, forum: flags & 16 ? r.boolean() : void 0, userAdminRights: flags & 2 ? r.object() : void 0, botAdminRights: flags & 4 ? r.object() : void 0 };
    },
    865857388: function(r) {
      var flags = r.uint();
      return { _: "requestPeerTypeBroadcast", creator: !!(flags & 1), hasUsername: flags & 8 ? r.boolean() : void 0, userAdminRights: flags & 2 ? r.object() : void 0, botAdminRights: flags & 4 ? r.object() : void 0 };
    },
    1209970170: function(r) {
      return { _: "emojiListNotModified" };
    },
    2048790993: function(r) {
      return { _: "emojiList", hash: r.long(), documentId: r.vector(r.long) };
    },
    2056961449: function(r) {
      return { _: "emojiGroup", title: r.string(), iconEmojiId: r.long(), emoticons: r.vector(r.string) };
    },
    2161274055: function(r) {
      return { _: "emojiGroupGreeting", title: r.string(), iconEmojiId: r.long(), emoticons: r.vector(r.string) };
    },
    154914612: function(r) {
      return { _: "emojiGroupPremium", title: r.string(), iconEmojiId: r.long() };
    },
    1874111879: function(r) {
      return { _: "messages.emojiGroupsNotModified" };
    },
    2283780427: function(r) {
      return { _: "messages.emojiGroups", hash: r.int(), groups: r.vector(r.object) };
    },
    1964978502: function(r) {
      return { _: "textWithEntities", text: r.string(), entities: r.vector(r.object) };
    },
    870003448: function(r) {
      return { _: "messages.translateResult", result: r.vector(r.object) };
    },
    3360175310: function(r) {
      var flags = r.uint();
      return { _: "autoSaveSettings", photos: !!(flags & 1), videos: !!(flags & 2), videoMaxSize: flags & 4 ? r.long() : void 0 };
    },
    2170563911: function(r) {
      return { _: "autoSaveException", peer: r.object(), settings: r.object() };
    },
    1279133341: function(r) {
      return { _: "account.autoSaveSettings", usersSettings: r.object(), chatsSettings: r.object(), broadcastsSettings: r.object(), exceptions: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2094949405: function(r) {
      return { _: "help.appConfigNotModified" };
    },
    3709368366: function(r) {
      return { _: "help.appConfig", hash: r.int(), config: r.object() };
    },
    2837495162: function(r) {
      return { _: "inputBotAppID", id: r.long(), accessHash: r.long() };
    },
    2425095175: function(r) {
      return { _: "inputBotAppShortName", botId: r.object(), shortName: r.string() };
    },
    1571189943: function(r) {
      return { _: "botAppNotModified" };
    },
    2516373974: function(r) {
      var flags = r.uint();
      return { _: "botApp", id: r.long(), accessHash: r.long(), shortName: r.string(), title: r.string(), description: r.string(), photo: r.object(), document: flags & 1 ? r.object() : void 0, hash: r.long() };
    },
    3947933173: function(r) {
      var flags = r.uint();
      return { _: "messages.botApp", inactive: !!(flags & 1), requestWriteAccess: !!(flags & 2), hasSettings: !!(flags & 4), app: r.object() };
    },
    3044185557: function(r) {
      return { _: "inlineBotWebView", text: r.string(), url: r.string() };
    },
    1246753138: function(r) {
      return { _: "readParticipantDate", userId: r.int53(), date: r.int() };
    },
    4091599411: function(r) {
      return { _: "inputChatlistDialogFilter", filterId: r.int() };
    },
    206668204: function(r) {
      r.uint();
      return { _: "exportedChatlistInvite", title: r.string(), url: r.string(), peers: r.vector(r.object) };
    },
    283567014: function(r) {
      return { _: "chatlists.exportedChatlistInvite", filter: r.object(), invite: r.object() };
    },
    279670215: function(r) {
      return { _: "chatlists.exportedInvites", invites: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    4203214425: function(r) {
      return { _: "chatlists.chatlistInviteAlready", filterId: r.int(), missingPeers: r.vector(r.object), alreadyPeers: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    500007837: function(r) {
      var flags = r.uint();
      return { _: "chatlists.chatlistInvite", title: r.string(), emoticon: flags & 1 ? r.string() : void 0, peers: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2478671757: function(r) {
      return { _: "chatlists.chatlistUpdates", missingPeers: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3903288752: function(r) {
      return { _: "bots.botInfo", name: r.string(), about: r.string(), description: r.string() };
    },
    3066834268: function(r) {
      return { _: "messagePeerVote", peer: r.object(), option: r.bytes(), date: r.int() };
    },
    1959634180: function(r) {
      return { _: "messagePeerVoteInputOption", peer: r.object(), date: r.int() };
    },
    1177089766: function(r) {
      return { _: "messagePeerVoteMultiple", peer: r.object(), options: r.vector(r.bytes), date: r.int() };
    },
    2371443926: function(r) {
      var flags = r.uint();
      return { _: "storyViews", hasViewers: !!(flags & 2), viewsCount: r.int(), forwardsCount: flags & 4 ? r.int() : void 0, reactions: flags & 8 ? r.vector(r.object) : void 0, reactionsCount: flags & 16 ? r.int() : void 0, recentViewers: flags & 1 ? r.vector(r.int53) : void 0 };
    },
    1374088783: function(r) {
      return { _: "storyItemDeleted", id: r.int() };
    },
    4289579283: function(r) {
      var flags = r.uint();
      return { _: "storyItemSkipped", closeFriends: !!(flags & 256), id: r.int(), date: r.int(), expireDate: r.int() };
    },
    2041735716: function(r) {
      var flags = r.uint();
      return { _: "storyItem", pinned: !!(flags & 32), public: !!(flags & 128), closeFriends: !!(flags & 256), min: !!(flags & 512), noforwards: !!(flags & 1024), edited: !!(flags & 2048), contacts: !!(flags & 4096), selectedContacts: !!(flags & 8192), out: !!(flags & 65536), id: r.int(), date: r.int(), fromId: flags & 262144 ? r.object() : void 0, fwdFrom: flags & 131072 ? r.object() : void 0, expireDate: r.int(), caption: flags & 1 ? r.string() : void 0, entities: flags & 2 ? r.vector(r.object) : void 0, media: r.object(), mediaAreas: flags & 16384 ? r.vector(r.object) : void 0, privacy: flags & 4 ? r.vector(r.object) : void 0, views: flags & 8 ? r.object() : void 0, sentReaction: flags & 32768 ? r.object() : void 0 };
    },
    291044926: function(r) {
      r.uint();
      return { _: "stories.allStoriesNotModified", state: r.string(), stealthMode: r.object() };
    },
    1862033025: function(r) {
      var flags = r.uint();
      return { _: "stories.allStories", hasMore: !!(flags & 1), count: r.int(), state: r.string(), peerStories: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), stealthMode: r.object() };
    },
    1673780490: function(r) {
      var flags = r.uint();
      return { _: "stories.stories", count: r.int(), stories: r.vector(r.object), pinnedToTop: flags & 1 ? r.vector(r.int) : void 0, chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2965236421: function(r) {
      var flags = r.uint();
      return { _: "storyView", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), userId: r.int53(), date: r.int(), reaction: flags & 4 ? r.object() : void 0 };
    },
    2424530699: function(r) {
      var flags = r.uint();
      return { _: "storyViewPublicForward", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), message: r.object() };
    },
    3178549065: function(r) {
      var flags = r.uint();
      return { _: "storyViewPublicRepost", blocked: !!(flags & 1), blockedMyStoriesFrom: !!(flags & 2), peerId: r.object(), story: r.object() };
    },
    1507299269: function(r) {
      var flags = r.uint();
      return { _: "stories.storyViewsList", count: r.int(), viewsCount: r.int(), forwardsCount: r.int(), reactionsCount: r.int(), views: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0 };
    },
    3734957341: function(r) {
      return { _: "stories.storyViews", views: r.vector(r.object), users: r.vector(r.object) };
    },
    583071445: function(r) {
      var flags = r.uint();
      return { _: "inputReplyToMessage", replyToMsgId: r.int(), topMsgId: flags & 1 ? r.int() : void 0, replyToPeerId: flags & 2 ? r.object() : void 0, quoteText: flags & 4 ? r.string() : void 0, quoteEntities: flags & 8 ? r.vector(r.object) : void 0, quoteOffset: flags & 16 ? r.int() : void 0 };
    },
    1484862010: function(r) {
      return { _: "inputReplyToStory", peer: r.object(), storyId: r.int() };
    },
    1070138683: function(r) {
      return { _: "exportedStoryLink", link: r.string() };
    },
    1898850301: function(r) {
      var flags = r.uint();
      return { _: "storiesStealthMode", activeUntilDate: flags & 1 ? r.int() : void 0, cooldownUntilDate: flags & 2 ? r.int() : void 0 };
    },
    3486113794: function(r) {
      var flags = r.uint();
      return { _: "mediaAreaCoordinates", x: r.double(), y: r.double(), w: r.double(), h: r.double(), rotation: r.double(), radius: flags & 1 ? r.double() : void 0 };
    },
    3196246940: function(r) {
      return { _: "mediaAreaVenue", coordinates: r.object(), geo: r.object(), title: r.string(), address: r.string(), provider: r.string(), venueId: r.string(), venueType: r.string() };
    },
    2994872703: function(r) {
      return { _: "inputMediaAreaVenue", coordinates: r.object(), queryId: r.long(), resultId: r.string() };
    },
    3402974509: function(r) {
      var flags = r.uint();
      return { _: "mediaAreaGeoPoint", coordinates: r.object(), geo: r.object(), address: flags & 1 ? r.object() : void 0 };
    },
    340088945: function(r) {
      var flags = r.uint();
      return { _: "mediaAreaSuggestedReaction", dark: !!(flags & 1), flipped: !!(flags & 2), coordinates: r.object(), reaction: r.object() };
    },
    1996756655: function(r) {
      return { _: "mediaAreaChannelPost", coordinates: r.object(), channelId: r.int53(), msgId: r.int() };
    },
    577893055: function(r) {
      return { _: "inputMediaAreaChannelPost", coordinates: r.object(), channel: r.object(), msgId: r.int() };
    },
    926421125: function(r) {
      return { _: "mediaAreaUrl", coordinates: r.object(), url: r.string() };
    },
    1235637404: function(r) {
      return { _: "mediaAreaWeather", coordinates: r.object(), emoji: r.string(), temperatureC: r.double(), color: r.int() };
    },
    2587224473: function(r) {
      var flags = r.uint();
      return { _: "peerStories", peer: r.object(), maxReadId: flags & 1 ? r.int() : void 0, stories: r.vector(r.object) };
    },
    3404105576: function(r) {
      return { _: "stories.peerStories", stories: r.object(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    4250800829: function(r) {
      return { _: "messages.webPage", webpage: r.object(), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    629052971: function(r) {
      var flags = r.uint();
      return { _: "premiumGiftCodeOption", users: r.int(), months: r.int(), storeProduct: flags & 1 ? r.string() : void 0, storeQuantity: flags & 2 ? r.int() : void 0, currency: r.string(), amount: r.long() };
    },
    675942550: function(r) {
      var flags = r.uint();
      return { _: "payments.checkedGiftCode", viaGiveaway: !!(flags & 4), fromId: flags & 16 ? r.object() : void 0, giveawayMsgId: flags & 8 ? r.int() : void 0, toId: flags & 1 ? r.long() : void 0, date: r.int(), months: r.int(), usedDate: flags & 2 ? r.int() : void 0, chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1130879648: function(r) {
      var flags = r.uint();
      return { _: "payments.giveawayInfo", participating: !!(flags & 1), preparingResults: !!(flags & 8), startDate: r.int(), joinedTooEarlyDate: flags & 2 ? r.int() : void 0, adminDisallowedChatId: flags & 4 ? r.long() : void 0, disallowedCountry: flags & 16 ? r.string() : void 0 };
    },
    3782600303: function(r) {
      var flags = r.uint();
      return { _: "payments.giveawayInfoResults", winner: !!(flags & 1), refunded: !!(flags & 2), startDate: r.int(), giftCodeSlug: flags & 8 ? r.string() : void 0, starsPrize: flags & 16 ? r.long() : void 0, finishDate: r.int(), winnersCount: r.int(), activatedCount: flags & 4 ? r.int() : void 0 };
    },
    2991824212: function(r) {
      return { _: "prepaidGiveaway", id: r.long(), months: r.int(), quantity: r.int(), date: r.int() };
    },
    2594011104: function(r) {
      return { _: "prepaidStarsGiveaway", id: r.long(), stars: r.long(), quantity: r.int(), boosts: r.int(), date: r.int() };
    },
    1262359766: function(r) {
      var flags = r.uint();
      return { _: "boost", gift: !!(flags & 2), giveaway: !!(flags & 4), unclaimed: !!(flags & 8), id: r.string(), userId: flags & 1 ? r.int53() : void 0, giveawayMsgId: flags & 4 ? r.int() : void 0, date: r.int(), expires: r.int(), usedGiftSlug: flags & 16 ? r.string() : void 0, multiplier: flags & 32 ? r.int() : void 0, stars: flags & 64 ? r.long() : void 0 };
    },
    2264424764: function(r) {
      var flags = r.uint();
      return { _: "premium.boostsList", count: r.int(), boosts: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0, users: r.vector(r.object) };
    },
    3293069660: function(r) {
      var flags = r.uint();
      return { _: "myBoost", slot: r.int(), peer: flags & 1 ? r.object() : void 0, date: r.int(), expires: r.int(), cooldownUntilDate: flags & 2 ? r.int() : void 0 };
    },
    2598512866: function(r) {
      return { _: "premium.myBoosts", myBoosts: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1230586490: function(r) {
      var flags = r.uint();
      return { _: "premium.boostsStatus", myBoost: !!(flags & 4), level: r.int(), currentLevelBoosts: r.int(), boosts: r.int(), giftBoosts: flags & 16 ? r.int() : void 0, nextLevelBoosts: flags & 1 ? r.int() : void 0, premiumAudience: flags & 2 ? r.object() : void 0, boostUrl: r.string(), prepaidGiveaways: flags & 8 ? r.vector(r.object) : void 0, myBoostSlots: flags & 4 ? r.vector(r.int) : void 0 };
    },
    3089555792: function(r) {
      var flags = r.uint();
      return { _: "storyFwdHeader", modified: !!(flags & 8), from: flags & 1 ? r.object() : void 0, fromName: flags & 2 ? r.string() : void 0, storyId: flags & 4 ? r.int() : void 0 };
    },
    3875901055: function(r) {
      return { _: "postInteractionCountersMessage", msgId: r.int(), views: r.int(), forwards: r.int(), reactions: r.int() };
    },
    2319978023: function(r) {
      return { _: "postInteractionCountersStory", storyId: r.int(), views: r.int(), forwards: r.int(), reactions: r.int() };
    },
    1355613820: function(r) {
      return { _: "stats.storyStats", viewsGraph: r.object(), reactionsByEmotionGraph: r.object() };
    },
    32685898: function(r) {
      return { _: "publicForwardMessage", message: r.object() };
    },
    3992169936: function(r) {
      return { _: "publicForwardStory", peer: r.object(), story: r.object() };
    },
    2466479648: function(r) {
      var flags = r.uint();
      return { _: "stats.publicForwards", count: r.int(), forwards: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0, chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3041614543: function(r) {
      var flags = r.uint();
      return { _: "peerColor", color: flags & 1 ? r.int() : void 0, backgroundEmojiId: flags & 2 ? r.long() : void 0 };
    },
    639736408: function(r) {
      return { _: "help.peerColorSet", colors: r.vector(r.int) };
    },
    1987928555: function(r) {
      return { _: "help.peerColorProfileSet", paletteColors: r.vector(r.int), bgColors: r.vector(r.int), storyColors: r.vector(r.int) };
    },
    2917953214: function(r) {
      var flags = r.uint();
      return { _: "help.peerColorOption", hidden: !!(flags & 1), colorId: r.int(), colors: flags & 2 ? r.object() : void 0, darkColors: flags & 4 ? r.object() : void 0, channelMinLevel: flags & 8 ? r.int() : void 0, groupMinLevel: flags & 16 ? r.int() : void 0 };
    },
    732034510: function(r) {
      return { _: "help.peerColorsNotModified" };
    },
    16313608: function(r) {
      return { _: "help.peerColors", hash: r.int(), colors: r.vector(r.object) };
    },
    1620104917: function(r) {
      return { _: "storyReaction", peerId: r.object(), date: r.int(), reaction: r.object() };
    },
    3148555843: function(r) {
      return { _: "storyReactionPublicForward", message: r.object() };
    },
    3486322451: function(r) {
      return { _: "storyReactionPublicRepost", peerId: r.object(), story: r.object() };
    },
    2858383516: function(r) {
      var flags = r.uint();
      return { _: "stories.storyReactionsList", count: r.int(), reactions: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0 };
    },
    3179793260: function(r) {
      var flags = r.uint();
      return { _: "savedDialog", pinned: !!(flags & 4), peer: r.object(), topMessage: r.int() };
    },
    4164608545: function(r) {
      return { _: "messages.savedDialogs", dialogs: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1153080793: function(r) {
      return { _: "messages.savedDialogsSlice", count: r.int(), dialogs: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3223285736: function(r) {
      return { _: "messages.savedDialogsNotModified", count: r.int() };
    },
    3413112872: function(r) {
      var flags = r.uint();
      return { _: "savedReactionTag", reaction: r.object(), title: flags & 1 ? r.string() : void 0, count: r.int() };
    },
    2291882479: function(r) {
      return { _: "messages.savedReactionTagsNotModified" };
    },
    844731658: function(r) {
      return { _: "messages.savedReactionTags", tags: r.vector(r.object), hash: r.long() };
    },
    1001931436: function(r) {
      return { _: "outboxReadDate", date: r.int() };
    },
    3700114639: function(r) {
      return { _: "smsjobs.eligibleToJoin", termsUrl: r.string(), monthlySentSms: r.int() };
    },
    720277905: function(r) {
      var flags = r.uint();
      return { _: "smsjobs.status", allowInternational: !!(flags & 1), recentSent: r.int(), recentSince: r.int(), recentRemains: r.int(), totalSent: r.int(), totalSince: r.int(), lastGiftSlug: flags & 2 ? r.string() : void 0, termsUrl: r.string() };
    },
    3869372088: function(r) {
      return { _: "smsJob", jobId: r.string(), phoneNumber: r.string(), text: r.string() };
    },
    302717625: function(r) {
      return { _: "businessWeeklyOpen", startMinute: r.int(), endMinute: r.int() };
    },
    2358423704: function(r) {
      var flags = r.uint();
      return { _: "businessWorkHours", openNow: !!(flags & 1), timezoneId: r.string(), weeklyOpen: r.vector(r.object) };
    },
    2891717367: function(r) {
      var flags = r.uint();
      return { _: "businessLocation", geoPoint: flags & 1 ? r.object() : void 0, address: r.string() };
    },
    1871393450: function(r) {
      var flags = r.uint();
      return { _: "inputBusinessRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r.vector(r.object) : void 0 };
    },
    554733559: function(r) {
      var flags = r.uint();
      return { _: "businessRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r.vector(r.int53) : void 0 };
    },
    3384402617: function(r) {
      return { _: "businessAwayMessageScheduleAlways" };
    },
    3287479553: function(r) {
      return { _: "businessAwayMessageScheduleOutsideWorkHours" };
    },
    3427638988: function(r) {
      return { _: "businessAwayMessageScheduleCustom", startDate: r.int(), endDate: r.int() };
    },
    26528571: function(r) {
      return { _: "inputBusinessGreetingMessage", shortcutId: r.int(), recipients: r.object(), noActivityDays: r.int() };
    },
    3843664811: function(r) {
      return { _: "businessGreetingMessage", shortcutId: r.int(), recipients: r.object(), noActivityDays: r.int() };
    },
    2200008160: function(r) {
      var flags = r.uint();
      return { _: "inputBusinessAwayMessage", offlineOnly: !!(flags & 1), shortcutId: r.int(), schedule: r.object(), recipients: r.object() };
    },
    4011158108: function(r) {
      var flags = r.uint();
      return { _: "businessAwayMessage", offlineOnly: !!(flags & 1), shortcutId: r.int(), schedule: r.object(), recipients: r.object() };
    },
    4287793653: function(r) {
      return { _: "timezone", id: r.string(), name: r.string(), utcOffset: r.int() };
    },
    2533820620: function(r) {
      return { _: "help.timezonesListNotModified" };
    },
    2071260529: function(r) {
      return { _: "help.timezonesList", timezones: r.vector(r.object), hash: r.int() };
    },
    110563371: function(r) {
      return { _: "quickReply", shortcutId: r.int(), shortcut: r.string(), topMessage: r.int(), count: r.int() };
    },
    609840449: function(r) {
      return { _: "inputQuickReplyShortcut", shortcut: r.string() };
    },
    18418929: function(r) {
      return { _: "inputQuickReplyShortcutId", shortcutId: r.int() };
    },
    3331155605: function(r) {
      return { _: "messages.quickReplies", quickReplies: r.vector(r.object), messages: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    1603398491: function(r) {
      return { _: "messages.quickRepliesNotModified" };
    },
    3171321345: function(r) {
      var flags = r.uint();
      return { _: "connectedBot", canReply: !!(flags & 1), botId: r.int53(), recipients: r.object() };
    },
    400029819: function(r) {
      return { _: "account.connectedBots", connectedBots: r.vector(r.object), users: r.vector(r.object) };
    },
    718878489: function(r) {
      var flags = r.uint();
      return { _: "messages.dialogFilters", tagsEnabled: !!(flags & 1), filters: r.vector(r.object) };
    },
    1821253126: function(r) {
      var flags = r.uint();
      return { _: "birthday", day: r.int(), month: r.int(), year: flags & 1 ? r.int() : void 0 };
    },
    2305045428: function(r) {
      var flags = r.uint();
      return { _: "botBusinessConnection", canReply: !!(flags & 1), disabled: !!(flags & 2), connectionId: r.string(), userId: r.int53(), dcId: r.int(), date: r.int() };
    },
    163867085: function(r) {
      var flags = r.uint();
      return { _: "inputBusinessIntro", title: r.string(), description: r.string(), sticker: flags & 1 ? r.object() : void 0 };
    },
    1510606445: function(r) {
      var flags = r.uint();
      return { _: "businessIntro", title: r.string(), description: r.string(), sticker: flags & 1 ? r.object() : void 0 };
    },
    4211040925: function(r) {
      return { _: "messages.myStickers", count: r.int(), sets: r.vector(r.object) };
    },
    3818152105: function(r) {
      return { _: "inputCollectibleUsername", username: r.string() };
    },
    2732725412: function(r) {
      return { _: "inputCollectiblePhone", phone: r.string() };
    },
    1857945489: function(r) {
      return { _: "fragment.collectibleInfo", purchaseDate: r.int(), currency: r.string(), amount: r.long(), cryptoCurrency: r.string(), cryptoAmount: r.long(), url: r.string() };
    },
    3303379486: function(r) {
      var flags = r.uint();
      return { _: "inputBusinessBotRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r.vector(r.object) : void 0, excludeUsers: flags & 64 ? r.vector(r.object) : void 0 };
    },
    3096245107: function(r) {
      var flags = r.uint();
      return { _: "businessBotRecipients", existingChats: !!(flags & 1), newChats: !!(flags & 2), contacts: !!(flags & 4), nonContacts: !!(flags & 8), excludeSelected: !!(flags & 32), users: flags & 16 ? r.vector(r.int53) : void 0, excludeUsers: flags & 64 ? r.vector(r.int53) : void 0 };
    },
    496600883: function(r) {
      return { _: "contactBirthday", contactId: r.int53(), birthday: r.object() };
    },
    290452237: function(r) {
      return { _: "contacts.contactBirthdays", contacts: r.vector(r.object), users: r.vector(r.object) };
    },
    1653379620: function(r) {
      var flags = r.uint();
      return { _: "missingInvitee", premiumWouldAllowInvite: !!(flags & 1), premiumRequiredForPm: !!(flags & 2), userId: r.int53() };
    },
    2136862630: function(r) {
      return { _: "messages.invitedUsers", updates: r.object(), missingInvitees: r.vector(r.object) };
    },
    292003751: function(r) {
      var flags = r.uint();
      return { _: "inputBusinessChatLink", message: r.string(), entities: flags & 1 ? r.vector(r.object) : void 0, title: flags & 2 ? r.string() : void 0 };
    },
    3031328367: function(r) {
      var flags = r.uint();
      return { _: "businessChatLink", link: r.string(), message: r.string(), entities: flags & 1 ? r.vector(r.object) : void 0, title: flags & 2 ? r.string() : void 0, views: r.int() };
    },
    3963855569: function(r) {
      return { _: "account.businessChatLinks", links: r.vector(r.object), chats: r.vector(r.object), users: r.vector(r.object) };
    },
    2586029857: function(r) {
      var flags = r.uint();
      return { _: "account.resolvedBusinessChatLinks", peer: r.object(), message: r.string(), entities: flags & 1 ? r.vector(r.object) : void 0, chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3593466986: function(r) {
      var flags = r.uint();
      return { _: "requestedPeerUser", userId: r.int53(), firstName: flags & 1 ? r.string() : void 0, lastName: flags & 1 ? r.string() : void 0, username: flags & 2 ? r.string() : void 0, photo: flags & 4 ? r.object() : void 0 };
    },
    1929860175: function(r) {
      var flags = r.uint();
      return { _: "requestedPeerChat", chatId: r.int53(), title: flags & 1 ? r.string() : void 0, photo: flags & 4 ? r.object() : void 0 };
    },
    2342781924: function(r) {
      var flags = r.uint();
      return { _: "requestedPeerChannel", channelId: r.int53(), title: flags & 1 ? r.string() : void 0, username: flags & 2 ? r.string() : void 0, photo: flags & 4 ? r.object() : void 0 };
    },
    1124938064: function(r) {
      return { _: "sponsoredMessageReportOption", text: r.string(), option: r.bytes() };
    },
    2221907522: function(r) {
      return { _: "channels.sponsoredMessageReportResultChooseOption", title: r.string(), options: r.vector(r.object) };
    },
    1044107055: function(r) {
      return { _: "channels.sponsoredMessageReportResultAdsHidden" };
    },
    2910423113: function(r) {
      return { _: "channels.sponsoredMessageReportResultReported" };
    },
    1409802903: function(r) {
      return { _: "stats.broadcastRevenueStats", topHoursGraph: r.object(), revenueGraph: r.object(), balances: r.object(), usdRate: r.double() };
    },
    3966080823: function(r) {
      return { _: "stats.broadcastRevenueWithdrawalUrl", url: r.string() };
    },
    1434332356: function(r) {
      return { _: "broadcastRevenueTransactionProceeds", amount: r.long(), fromDate: r.int(), toDate: r.int() };
    },
    1515784568: function(r) {
      var flags = r.uint();
      return { _: "broadcastRevenueTransactionWithdrawal", pending: !!(flags & 1), failed: !!(flags & 4), amount: r.long(), date: r.int(), provider: r.string(), transactionDate: flags & 2 ? r.int() : void 0, transactionUrl: flags & 2 ? r.string() : void 0 };
    },
    1121127726: function(r) {
      return { _: "broadcastRevenueTransactionRefund", amount: r.long(), date: r.int(), provider: r.string() };
    },
    2266334310: function(r) {
      return { _: "stats.broadcastRevenueTransactions", count: r.int(), transactions: r.vector(r.object) };
    },
    3133384218: function(r) {
      return { _: "reactionNotificationsFromContacts" };
    },
    1268654752: function(r) {
      return { _: "reactionNotificationsFromAll" };
    },
    1457736048: function(r) {
      var flags = r.uint();
      return { _: "reactionsNotifySettings", messagesNotifyFrom: flags & 1 ? r.object() : void 0, storiesNotifyFrom: flags & 2 ? r.object() : void 0, sound: r.object(), showPreviews: r.boolean() };
    },
    3288297959: function(r) {
      var flags = r.uint();
      return { _: "broadcastRevenueBalances", withdrawalEnabled: !!(flags & 1), currentBalance: r.long(), availableBalance: r.long(), overallRevenue: r.long() };
    },
    2479088254: function(r) {
      var flags = r.uint();
      return { _: "availableEffect", premiumRequired: !!(flags & 4), id: r.long(), emoticon: r.string(), staticIconId: flags & 1 ? r.long() : void 0, effectStickerId: r.long(), effectAnimationId: flags & 2 ? r.long() : void 0 };
    },
    3522009691: function(r) {
      return { _: "messages.availableEffectsNotModified" };
    },
    3185271150: function(r) {
      return { _: "messages.availableEffects", hash: r.int(), effects: r.vector(r.object), documents: r.vector(r.object) };
    },
    3097230543: function(r) {
      var flags = r.uint();
      return { _: "factCheck", needCheck: !!(flags & 1), country: flags & 2 ? r.string() : void 0, text: flags & 2 ? r.object() : void 0, hash: r.long() };
    },
    2515714020: function(r) {
      return { _: "starsTransactionPeerUnsupported" };
    },
    3025646453: function(r) {
      return { _: "starsTransactionPeerAppStore" };
    },
    2069236235: function(r) {
      return { _: "starsTransactionPeerPlayMarket" };
    },
    621656824: function(r) {
      return { _: "starsTransactionPeerPremiumBot" };
    },
    3912227074: function(r) {
      return { _: "starsTransactionPeerFragment" };
    },
    3624771933: function(r) {
      return { _: "starsTransactionPeer", peer: r.object() };
    },
    1617438738: function(r) {
      return { _: "starsTransactionPeerAds" };
    },
    198776256: function(r) {
      var flags = r.uint();
      return { _: "starsTopupOption", extended: !!(flags & 2), stars: r.long(), storeProduct: flags & 1 ? r.string() : void 0, currency: r.string(), amount: r.long() };
    },
    178185410: function(r) {
      var flags = r.uint();
      return { _: "starsTransaction", refund: !!(flags & 8), pending: !!(flags & 16), failed: !!(flags & 64), gift: !!(flags & 1024), reaction: !!(flags & 2048), id: r.string(), stars: r.long(), date: r.int(), peer: r.object(), title: flags & 1 ? r.string() : void 0, description: flags & 2 ? r.string() : void 0, photo: flags & 4 ? r.object() : void 0, transactionDate: flags & 32 ? r.int() : void 0, transactionUrl: flags & 32 ? r.string() : void 0, botPayload: flags & 128 ? r.bytes() : void 0, msgId: flags & 256 ? r.int() : void 0, extendedMedia: flags & 512 ? r.vector(r.object) : void 0, subscriptionPeriod: flags & 4096 ? r.int() : void 0, giveawayPostId: flags & 8192 ? r.int() : void 0, stargift: flags & 16384 ? r.object() : void 0 };
    },
    3153736044: function(r) {
      var flags = r.uint();
      return { _: "payments.starsStatus", balance: r.long(), subscriptions: flags & 2 ? r.vector(r.object) : void 0, subscriptionsNextOffset: flags & 4 ? r.string() : void 0, subscriptionsMissingBalance: flags & 16 ? r.long() : void 0, history: flags & 8 ? r.vector(r.object) : void 0, nextOffset: flags & 1 ? r.string() : void 0, chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3900361664: function(r) {
      return { _: "foundStory", peer: r.object(), story: r.object() };
    },
    3806230327: function(r) {
      var flags = r.uint();
      return { _: "stories.foundStories", count: r.int(), stories: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0, chats: r.vector(r.object), users: r.vector(r.object) };
    },
    3729546643: function(r) {
      var flags = r.uint();
      return { _: "geoPointAddress", countryIso2: r.string(), state: flags & 1 ? r.string() : void 0, city: flags & 2 ? r.string() : void 0, street: flags & 4 ? r.string() : void 0 };
    },
    2033461574: function(r) {
      var flags = r.uint();
      return { _: "starsRevenueStatus", withdrawalEnabled: !!(flags & 1), currentBalance: r.long(), availableBalance: r.long(), overallRevenue: r.long(), nextWithdrawalAt: flags & 2 ? r.int() : void 0 };
    },
    3375085371: function(r) {
      return { _: "payments.starsRevenueStats", revenueGraph: r.object(), status: r.object(), usdRate: r.double() };
    },
    497778871: function(r) {
      return { _: "payments.starsRevenueWithdrawalUrl", url: r.string() };
    },
    961445665: function(r) {
      return { _: "payments.starsRevenueAdsAccountUrl", url: r.string() };
    },
    543876817: function(r) {
      var flags = r.uint();
      return { _: "inputStarsTransaction", refund: !!(flags & 1), id: r.string() };
    },
    1577421297: function(r) {
      var flags = r.uint();
      return { _: "starsGiftOption", extended: !!(flags & 2), stars: r.long(), storeProduct: flags & 1 ? r.string() : void 0, currency: r.string(), amount: r.long() };
    },
    428978491: function(r) {
      var flags = r.uint();
      return { _: "bots.popularAppBots", nextOffset: flags & 1 ? r.string() : void 0, users: r.vector(r.object) };
    },
    602479523: function(r) {
      return { _: "botPreviewMedia", date: r.int(), media: r.object() };
    },
    212278628: function(r) {
      return { _: "bots.previewInfo", media: r.vector(r.object), langCodes: r.vector(r.string) };
    },
    88173912: function(r) {
      return { _: "starsSubscriptionPricing", period: r.int(), amount: r.long() };
    },
    1401868056: function(r) {
      var flags = r.uint();
      return { _: "starsSubscription", canceled: !!(flags & 1), canRefulfill: !!(flags & 2), missingBalance: !!(flags & 4), id: r.string(), peer: r.object(), untilDate: r.int(), pricing: r.object(), chatInviteHash: flags & 8 ? r.string() : void 0 };
    },
    1269016922: function(r) {
      var flags = r.uint();
      return { _: "messageReactor", top: !!(flags & 1), my: !!(flags & 2), anonymous: !!(flags & 4), peerId: flags & 8 ? r.object() : void 0, count: r.int() };
    },
    2496562474: function(r) {
      var flags = r.uint();
      return { _: "starsGiveawayOption", extended: !!(flags & 1), default: !!(flags & 2), stars: r.long(), yearlyBoosts: r.int(), storeProduct: flags & 4 ? r.string() : void 0, currency: r.string(), amount: r.long(), winners: r.vector(r.object) };
    },
    1411605001: function(r) {
      var flags = r.uint();
      return { _: "starsGiveawayWinnersOption", default: !!(flags & 1), users: r.int(), perUserStars: r.long() };
    },
    2929816814: function(r) {
      var flags = r.uint();
      return { _: "starGift", limited: !!(flags & 1), id: r.long(), sticker: r.object(), stars: r.long(), availabilityRemains: flags & 1 ? r.int() : void 0, availabilityTotal: flags & 1 ? r.int() : void 0, convertStars: r.long() };
    },
    2743640936: function(r) {
      return { _: "payments.starGiftsNotModified" };
    },
    2417396202: function(r) {
      return { _: "payments.starGifts", hash: r.int(), gifts: r.vector(r.object) };
    },
    4003764846: function(r) {
      var flags = r.uint();
      return { _: "userStarGift", nameHidden: !!(flags & 1), unsaved: !!(flags & 32), fromId: flags & 2 ? r.int53() : void 0, date: r.int(), gift: r.object(), message: flags & 4 ? r.object() : void 0, msgId: flags & 8 ? r.int() : void 0, convertStars: flags & 16 ? r.long() : void 0 };
    },
    1801827607: function(r) {
      var flags = r.uint();
      return { _: "payments.userStarGifts", count: r.int(), gifts: r.vector(r.object), nextOffset: flags & 1 ? r.string() : void 0, users: r.vector(r.object) };
    },
    2030298073: function(r) {
      return { _: "messageReportOption", text: r.string(), option: r.bytes() };
    },
    4041531574: function(r) {
      return { _: "reportResultChooseOption", title: r.string(), options: r.vector(r.object) };
    },
    1862904881: function(r) {
      var flags = r.uint();
      return { _: "reportResultAddComment", optional: !!(flags & 1), option: r.bytes() };
    },
    2377333835: function(r) {
      return { _: "reportResultReported" };
    },
    _results: {
      "contacts.getContactIDs": function(r) {
        return r.vector(r.int);
      },
      "messages.receivedQueue": function(r) {
        return r.vector(r.long);
      },
      "photos.deletePhotos": function(r) {
        return r.vector(r.long);
      },
      "phone.checkGroupCall": function(r) {
        return r.vector(r.int);
      },
      "stories.deleteStories": function(r) {
        return r.vector(r.int);
      },
      "stories.togglePinned": function(r) {
        return r.vector(r.int);
      },
      "stories.readStories": function(r) {
        return r.vector(r.int);
      },
      "stories.getPeerMaxIDs": function(r) {
        return r.vector(r.int);
      },
      "mtcute.customMethod": function(r) {
        return r.raw();
      }
    },
    85337187: function(r) {
      return { _: "mt_resPQ", nonce: r.int128(), serverNonce: r.int128(), pq: r.bytes(), serverPublicKeyFingerprints: r.vector(r.long) };
    },
    2851430293: function(r) {
      return { _: "mt_p_q_inner_data_dc", pq: r.bytes(), p: r.bytes(), q: r.bytes(), nonce: r.int128(), serverNonce: r.int128(), newNonce: r.int256(), dc: r.int() };
    },
    1459478408: function(r) {
      return { _: "mt_p_q_inner_data_temp_dc", pq: r.bytes(), p: r.bytes(), q: r.bytes(), nonce: r.int128(), serverNonce: r.int128(), newNonce: r.int256(), dc: r.int(), expiresIn: r.int() };
    },
    3504867164: function(r) {
      return { _: "mt_server_DH_params_ok", nonce: r.int128(), serverNonce: r.int128(), encryptedAnswer: r.bytes() };
    },
    3045658042: function(r) {
      return { _: "mt_server_DH_inner_data", nonce: r.int128(), serverNonce: r.int128(), g: r.int(), dhPrime: r.bytes(), gA: r.bytes(), serverTime: r.int() };
    },
    1715713620: function(r) {
      return { _: "mt_client_DH_inner_data", nonce: r.int128(), serverNonce: r.int128(), retryId: r.long(), gB: r.bytes() };
    },
    1003222836: function(r) {
      return { _: "mt_dh_gen_ok", nonce: r.int128(), serverNonce: r.int128(), newNonceHash1: r.int128() };
    },
    1188831161: function(r) {
      return { _: "mt_dh_gen_retry", nonce: r.int128(), serverNonce: r.int128(), newNonceHash2: r.int128() };
    },
    2795351554: function(r) {
      return { _: "mt_dh_gen_fail", nonce: r.int128(), serverNonce: r.int128(), newNonceHash3: r.int128() };
    },
    1973679973: function(r) {
      return { _: "mt_bind_auth_key_inner", nonce: r.long(), tempAuthKeyId: r.long(), permAuthKeyId: r.long(), tempSessionId: r.long(), expiresAt: r.int() };
    },
    558156313: function(r) {
      return { _: "mt_rpc_error", errorCode: r.int(), errorMessage: r.string() };
    },
    1579864942: function(r) {
      return { _: "mt_rpc_answer_unknown" };
    },
    3447252358: function(r) {
      return { _: "mt_rpc_answer_dropped_running" };
    },
    2755319991: function(r) {
      return { _: "mt_rpc_answer_dropped", msgId: r.long(), seqNo: r.int(), bytes: r.int() };
    },
    155834844: function(r = this) {
      return { _: "mt_future_salt", validSince: r.int(), validUntil: r.int(), salt: r.long() };
    },
    2924480661: function(r) {
      return { _: "mt_future_salts", reqMsgId: r.long(), now: r.int(), salts: r.vector(m$1[155834844], 1) };
    },
    880243653: function(r) {
      return { _: "mt_pong", msgId: r.long(), pingId: r.long() };
    },
    3793765884: function(r) {
      return { _: "mt_destroy_session_ok", sessionId: r.long() };
    },
    1658015945: function(r) {
      return { _: "mt_destroy_session_none", sessionId: r.long() };
    },
    2663516424: function(r) {
      return { _: "mt_new_session_created", firstMsgId: r.long(), uniqueId: r.long(), serverSalt: r.long() };
    },
    1658238041: function(r) {
      return { _: "mt_msgs_ack", msgIds: r.vector(r.long) };
    },
    2817521681: function(r) {
      return { _: "mt_bad_msg_notification", badMsgId: r.long(), badMsgSeqno: r.int(), errorCode: r.int() };
    },
    3987424379: function(r) {
      return { _: "mt_bad_server_salt", badMsgId: r.long(), badMsgSeqno: r.int(), errorCode: r.int(), newServerSalt: r.long() };
    },
    2105940488: function(r) {
      return { _: "mt_msg_resend_req", msgIds: r.vector(r.long) };
    },
    3664378706: function(r) {
      return { _: "mt_msgs_state_req", msgIds: r.vector(r.long) };
    },
    81704317: function(r) {
      return { _: "mt_msgs_state_info", reqMsgId: r.long(), info: r.bytes() };
    },
    2361446705: function(r) {
      return { _: "mt_msgs_all_info", msgIds: r.vector(r.long), info: r.bytes() };
    },
    661470918: function(r) {
      return { _: "mt_msg_detailed_info", msgId: r.long(), answerMsgId: r.long(), bytes: r.int(), status: r.int() };
    },
    2157819615: function(r) {
      return { _: "mt_msg_new_detailed_info", answerMsgId: r.long(), bytes: r.int(), status: r.int() };
    },
    4133544404: function(r) {
      return { _: "mt_destroy_auth_key_ok" };
    },
    178201177: function(r) {
      return { _: "mt_destroy_auth_key_none" };
    },
    3926956819: function(r) {
      return { _: "mt_destroy_auth_key_fail" };
    },
    2459514271: function(r) {
      return { _: "mt_http_wait", maxDelay: r.int(), waitAfter: r.int(), maxWait: r.int() };
    },
    3195965169: function(r) {
      return { _: "mt_req_pq_multi", nonce: r.int128() };
    },
    3608339646: function(r) {
      return { _: "mt_req_DH_params", nonce: r.int128(), serverNonce: r.int128(), p: r.bytes(), q: r.bytes(), publicKeyFingerprint: r.long(), encryptedData: r.bytes() };
    },
    4110704415: function(r) {
      return { _: "mt_set_client_DH_params", nonce: r.int128(), serverNonce: r.int128(), encryptedData: r.bytes() };
    },
    1491380032: function(r) {
      return { _: "mt_rpc_drop_answer", reqMsgId: r.long() };
    },
    3105996036: function(r) {
      return { _: "mt_get_future_salts", num: r.int() };
    },
    2059302892: function(r) {
      return { _: "mt_ping", pingId: r.long() };
    },
    4081220492: function(r) {
      return { _: "mt_ping_delay_disconnect", pingId: r.long(), disconnectDelay: r.int() };
    },
    3880853798: function(r) {
      return { _: "mt_destroy_session", sessionId: r.long() };
    },
    3510849888: function(r) {
      return { _: "mt_destroy_auth_key" };
    }
  };
  var __tlReaderMap = reader.__tlReaderMap = m$1;
  var writer = {};
  Object.defineProperty(writer, "__esModule", { value: true });
  function h(o, p) {
    var q = o[p];
    if (q === void 0)
      throw Error("Object " + o._ + " is missing required property " + p);
    return q;
  }
  var m = {
    "error": function(w, v) {
      w.uint(3300522427);
      w.int(h(v, "code"));
      w.string(h(v, "text"));
    },
    "ipPort": function(w, v) {
      w.uint(3560156531);
      w.int(h(v, "ipv4"));
      w.int(h(v, "port"));
    },
    "ipPortSecret": function(w, v) {
      w.uint(932718150);
      w.int(h(v, "ipv4"));
      w.int(h(v, "port"));
      w.bytes(h(v, "secret"));
    },
    "accessPointRule": function(w, v) {
      w.uint(1182381663);
      w.string(h(v, "phonePrefixRules"));
      w.int(h(v, "dcId"));
      w.vector(w.object, h(v, "ips"), 1);
    },
    "help.configSimple": function(w, v) {
      w.uint(1515793004);
      w.int(h(v, "date"));
      w.int(h(v, "expires"));
      w.vector(w.object, h(v, "rules"), 1);
    },
    "inputPeerPhotoFileLocationLegacy": function(w, v) {
      w.uint(668375447);
      var flags = 0;
      if (v.big === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.long(h(v, "volumeId"));
      w.int(h(v, "localId"));
    },
    "inputStickerSetThumbLegacy": function(w, v) {
      w.uint(230353641);
      w.object(h(v, "stickerset"));
      w.long(h(v, "volumeId"));
      w.int(h(v, "localId"));
    },
    "inputPeerEmpty": function(w) {
      w.uint(2134579434);
    },
    "inputPeerSelf": function(w) {
      w.uint(2107670217);
    },
    "inputPeerChat": function(w, v) {
      w.uint(900291769);
      w.int53(h(v, "chatId"));
    },
    "inputPeerUser": function(w, v) {
      w.uint(3723011404);
      w.int53(h(v, "userId"));
      w.long(h(v, "accessHash"));
    },
    "inputPeerChannel": function(w, v) {
      w.uint(666680316);
      w.int53(h(v, "channelId"));
      w.long(h(v, "accessHash"));
    },
    "inputPeerUserFromMessage": function(w, v) {
      w.uint(2826635804);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int53(h(v, "userId"));
    },
    "inputPeerChannelFromMessage": function(w, v) {
      w.uint(3173648448);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int53(h(v, "channelId"));
    },
    "inputUserEmpty": function(w) {
      w.uint(3112732367);
    },
    "inputUserSelf": function(w) {
      w.uint(4156666175);
    },
    "inputUser": function(w, v) {
      w.uint(4061223110);
      w.int53(h(v, "userId"));
      w.long(h(v, "accessHash"));
    },
    "inputUserFromMessage": function(w, v) {
      w.uint(497305826);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int53(h(v, "userId"));
    },
    "inputPhoneContact": function(w, v) {
      w.uint(4086478836);
      w.long(h(v, "clientId"));
      w.string(h(v, "phone"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
    },
    "inputFile": function(w, v) {
      w.uint(4113560191);
      w.long(h(v, "id"));
      w.int(h(v, "parts"));
      w.string(h(v, "name"));
      w.string(h(v, "md5Checksum"));
    },
    "inputFileBig": function(w, v) {
      w.uint(4199484341);
      w.long(h(v, "id"));
      w.int(h(v, "parts"));
      w.string(h(v, "name"));
    },
    "inputFileStoryDocument": function(w, v) {
      w.uint(1658620744);
      w.object(h(v, "id"));
    },
    "inputMediaEmpty": function(w) {
      w.uint(2523198847);
    },
    "inputMediaUploadedPhoto": function(w, v) {
      w.uint(505969924);
      var flags = 0;
      var _stickers = v.stickers && v.stickers.length;
      if (_stickers)
        flags |= 1;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 2;
      if (v.spoiler === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "file"));
      if (_stickers)
        w.vector(w.object, v.stickers);
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
    },
    "inputMediaPhoto": function(w, v) {
      w.uint(3015312949);
      var flags = 0;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 1;
      if (v.spoiler === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "id"));
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
    },
    "inputMediaGeoPoint": function(w, v) {
      w.uint(4190388548);
      w.object(h(v, "geoPoint"));
    },
    "inputMediaContact": function(w, v) {
      w.uint(4171988475);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
      w.string(h(v, "vcard"));
    },
    "inputMediaUploadedDocument": function(w, v) {
      w.uint(1530447553);
      var flags = 0;
      var _stickers = v.stickers && v.stickers.length;
      if (_stickers)
        flags |= 1;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 2;
      var _thumb = v.thumb !== void 0;
      if (_thumb)
        flags |= 4;
      if (v.nosoundVideo === true)
        flags |= 8;
      if (v.forceFile === true)
        flags |= 16;
      if (v.spoiler === true)
        flags |= 32;
      w.uint(flags);
      w.object(h(v, "file"));
      if (_thumb)
        w.object(v.thumb);
      w.string(h(v, "mimeType"));
      w.vector(w.object, h(v, "attributes"));
      if (_stickers)
        w.vector(w.object, v.stickers);
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
    },
    "inputMediaDocument": function(w, v) {
      w.uint(860303448);
      var flags = 0;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 1;
      var _query = v.query !== void 0;
      if (_query)
        flags |= 2;
      if (v.spoiler === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "id"));
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
      if (_query)
        w.string(v.query);
    },
    "inputMediaVenue": function(w, v) {
      w.uint(3242007569);
      w.object(h(v, "geoPoint"));
      w.string(h(v, "title"));
      w.string(h(v, "address"));
      w.string(h(v, "provider"));
      w.string(h(v, "venueId"));
      w.string(h(v, "venueType"));
    },
    "inputMediaPhotoExternal": function(w, v) {
      w.uint(3854302746);
      var flags = 0;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 1;
      if (v.spoiler === true)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "url"));
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
    },
    "inputMediaDocumentExternal": function(w, v) {
      w.uint(4216511641);
      var flags = 0;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 1;
      if (v.spoiler === true)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "url"));
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
    },
    "inputMediaGame": function(w, v) {
      w.uint(3544138739);
      w.object(h(v, "id"));
    },
    "inputMediaInvoice": function(w, v) {
      w.uint(1080028941);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 1;
      var _startParam = v.startParam !== void 0;
      if (_startParam)
        flags |= 2;
      var _extendedMedia = v.extendedMedia !== void 0;
      if (_extendedMedia)
        flags |= 4;
      var _provider = v.provider !== void 0;
      if (_provider)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      w.object(h(v, "invoice"));
      w.bytes(h(v, "payload"));
      if (_provider)
        w.string(v.provider);
      w.object(h(v, "providerData"));
      if (_startParam)
        w.string(v.startParam);
      if (_extendedMedia)
        w.object(v.extendedMedia);
    },
    "inputMediaGeoLive": function(w, v) {
      w.uint(2535434307);
      var flags = 0;
      if (v.stopped === true)
        flags |= 1;
      var _period = v.period !== void 0;
      if (_period)
        flags |= 2;
      var _heading = v.heading !== void 0;
      if (_heading)
        flags |= 4;
      var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
      if (_proximityNotificationRadius)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "geoPoint"));
      if (_heading)
        w.int(v.heading);
      if (_period)
        w.int(v.period);
      if (_proximityNotificationRadius)
        w.int(v.proximityNotificationRadius);
    },
    "inputMediaPoll": function(w, v) {
      w.uint(261416433);
      var flags = 0;
      var _correctAnswers = v.correctAnswers && v.correctAnswers.length;
      if (_correctAnswers)
        flags |= 1;
      var _solution = v.solution !== void 0;
      var _solutionEntities = v.solutionEntities && v.solutionEntities.length;
      var _flags_1 = _solution || _solutionEntities;
      if (_flags_1)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "poll"));
      if (_correctAnswers)
        w.vector(w.bytes, v.correctAnswers);
      if (_flags_1)
        w.string(v.solution);
      if (_flags_1)
        w.vector(w.object, v.solutionEntities);
    },
    "inputMediaDice": function(w, v) {
      w.uint(3866083195);
      w.string(h(v, "emoticon"));
    },
    "inputMediaStory": function(w, v) {
      w.uint(2315114360);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
    },
    "inputMediaWebPage": function(w, v) {
      w.uint(3256584265);
      var flags = 0;
      if (v.forceLargeMedia === true)
        flags |= 1;
      if (v.forceSmallMedia === true)
        flags |= 2;
      if (v.optional === true)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "url"));
    },
    "inputMediaPaidMedia": function(w, v) {
      w.uint(3289396102);
      var flags = 0;
      var _payload = v.payload !== void 0;
      if (_payload)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "starsAmount"));
      w.vector(w.object, h(v, "extendedMedia"));
      if (_payload)
        w.string(v.payload);
    },
    "inputChatPhotoEmpty": function(w) {
      w.uint(480546647);
    },
    "inputChatUploadedPhoto": function(w, v) {
      w.uint(3184373440);
      var flags = 0;
      var _file = v.file !== void 0;
      if (_file)
        flags |= 1;
      var _video = v.video !== void 0;
      if (_video)
        flags |= 2;
      var _videoStartTs = v.videoStartTs !== void 0;
      if (_videoStartTs)
        flags |= 4;
      var _videoEmojiMarkup = v.videoEmojiMarkup !== void 0;
      if (_videoEmojiMarkup)
        flags |= 8;
      w.uint(flags);
      if (_file)
        w.object(v.file);
      if (_video)
        w.object(v.video);
      if (_videoStartTs)
        w.double(v.videoStartTs);
      if (_videoEmojiMarkup)
        w.object(v.videoEmojiMarkup);
    },
    "inputChatPhoto": function(w, v) {
      w.uint(2303962423);
      w.object(h(v, "id"));
    },
    "inputGeoPointEmpty": function(w) {
      w.uint(3837862870);
    },
    "inputGeoPoint": function(w, v) {
      w.uint(1210199983);
      var flags = 0;
      var _accuracyRadius = v.accuracyRadius !== void 0;
      if (_accuracyRadius)
        flags |= 1;
      w.uint(flags);
      w.double(h(v, "lat"));
      w.double(h(v, "long"));
      if (_accuracyRadius)
        w.int(v.accuracyRadius);
    },
    "inputPhotoEmpty": function(w) {
      w.uint(483901197);
    },
    "inputPhoto": function(w, v) {
      w.uint(1001634122);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.bytes(h(v, "fileReference"));
    },
    "inputFileLocation": function(w, v) {
      w.uint(3755650017);
      w.long(h(v, "volumeId"));
      w.int(h(v, "localId"));
      w.long(h(v, "secret"));
      w.bytes(h(v, "fileReference"));
    },
    "inputEncryptedFileLocation": function(w, v) {
      w.uint(4112735573);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputDocumentFileLocation": function(w, v) {
      w.uint(3134223748);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.bytes(h(v, "fileReference"));
      w.string(h(v, "thumbSize"));
    },
    "inputSecureFileLocation": function(w, v) {
      w.uint(3418877480);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputTakeoutFileLocation": function(w) {
      w.uint(700340377);
    },
    "inputPhotoFileLocation": function(w, v) {
      w.uint(1075322878);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.bytes(h(v, "fileReference"));
      w.string(h(v, "thumbSize"));
    },
    "inputPhotoLegacyFileLocation": function(w, v) {
      w.uint(3627312883);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.bytes(h(v, "fileReference"));
      w.long(h(v, "volumeId"));
      w.int(h(v, "localId"));
      w.long(h(v, "secret"));
    },
    "inputPeerPhotoFileLocation": function(w, v) {
      w.uint(925204121);
      var flags = 0;
      if (v.big === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.long(h(v, "photoId"));
    },
    "inputStickerSetThumb": function(w, v) {
      w.uint(2642736091);
      w.object(h(v, "stickerset"));
      w.int(h(v, "thumbVersion"));
    },
    "inputGroupCallStream": function(w, v) {
      w.uint(93890858);
      var flags = 0;
      var _videoChannel = v.videoChannel !== void 0;
      var _videoQuality = v.videoQuality !== void 0;
      var _flags_0 = _videoChannel || _videoQuality;
      if (_flags_0)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "call"));
      w.long(h(v, "timeMs"));
      w.int(h(v, "scale"));
      if (_flags_0)
        w.int(v.videoChannel);
      if (_flags_0)
        w.int(v.videoQuality);
    },
    "peerUser": function(w, v) {
      w.uint(1498486562);
      w.int53(h(v, "userId"));
    },
    "peerChat": function(w, v) {
      w.uint(918946202);
      w.int53(h(v, "chatId"));
    },
    "peerChannel": function(w, v) {
      w.uint(2728736542);
      w.int53(h(v, "channelId"));
    },
    "storage.fileUnknown": function(w) {
      w.uint(2861972229);
    },
    "storage.filePartial": function(w) {
      w.uint(1086091090);
    },
    "storage.fileJpeg": function(w) {
      w.uint(8322574);
    },
    "storage.fileGif": function(w) {
      w.uint(3403786975);
    },
    "storage.filePng": function(w) {
      w.uint(172975040);
    },
    "storage.filePdf": function(w) {
      w.uint(2921222285);
    },
    "storage.fileMp3": function(w) {
      w.uint(1384777335);
    },
    "storage.fileMov": function(w) {
      w.uint(1258941372);
    },
    "storage.fileMp4": function(w) {
      w.uint(3016663268);
    },
    "storage.fileWebp": function(w) {
      w.uint(276907596);
    },
    "userEmpty": function(w, v) {
      w.uint(3552332666);
      w.int53(h(v, "id"));
    },
    "user": function(w, v) {
      w.uint(2201046986);
      var flags = 0;
      var _accessHash = v.accessHash !== void 0;
      if (_accessHash)
        flags |= 1;
      var _firstName = v.firstName !== void 0;
      if (_firstName)
        flags |= 2;
      var _lastName = v.lastName !== void 0;
      if (_lastName)
        flags |= 4;
      var _username = v.username !== void 0;
      if (_username)
        flags |= 8;
      var _phone = v.phone !== void 0;
      if (_phone)
        flags |= 16;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 32;
      var _status = v.status !== void 0;
      if (_status)
        flags |= 64;
      if (v.self === true)
        flags |= 1024;
      if (v.contact === true)
        flags |= 2048;
      if (v.mutualContact === true)
        flags |= 4096;
      if (v.deleted === true)
        flags |= 8192;
      var _botInfoVersion = v.botInfoVersion !== void 0;
      var _flags_14 = v.bot === true || _botInfoVersion;
      if (_flags_14)
        flags |= 16384;
      if (v.botChatHistory === true)
        flags |= 32768;
      if (v.botNochats === true)
        flags |= 65536;
      if (v.verified === true)
        flags |= 131072;
      var _restrictionReason = v.restrictionReason && v.restrictionReason.length;
      var _flags_18 = v.restricted === true || _restrictionReason;
      if (_flags_18)
        flags |= 262144;
      var _botInlinePlaceholder = v.botInlinePlaceholder !== void 0;
      if (_botInlinePlaceholder)
        flags |= 524288;
      if (v.min === true)
        flags |= 1048576;
      if (v.botInlineGeo === true)
        flags |= 2097152;
      var _langCode = v.langCode !== void 0;
      if (_langCode)
        flags |= 4194304;
      if (v.support === true)
        flags |= 8388608;
      if (v.scam === true)
        flags |= 16777216;
      if (v.applyMinPhoto === true)
        flags |= 33554432;
      if (v.fake === true)
        flags |= 67108864;
      if (v.botAttachMenu === true)
        flags |= 134217728;
      if (v.premium === true)
        flags |= 268435456;
      if (v.attachMenuEnabled === true)
        flags |= 536870912;
      var _emojiStatus = v.emojiStatus !== void 0;
      if (_emojiStatus)
        flags |= 1073741824;
      w.uint(flags);
      var flags2 = 0;
      var _usernames = v.usernames && v.usernames.length;
      if (_usernames)
        flags2 |= 1;
      if (v.botCanEdit === true)
        flags2 |= 2;
      if (v.closeFriend === true)
        flags2 |= 4;
      if (v.storiesHidden === true)
        flags2 |= 8;
      if (v.storiesUnavailable === true)
        flags2 |= 16;
      var _storiesMaxId = v.storiesMaxId !== void 0;
      if (_storiesMaxId)
        flags2 |= 32;
      var _color = v.color !== void 0;
      if (_color)
        flags2 |= 256;
      var _profileColor = v.profileColor !== void 0;
      if (_profileColor)
        flags2 |= 512;
      if (v.contactRequirePremium === true)
        flags2 |= 1024;
      if (v.botBusiness === true)
        flags2 |= 2048;
      var _botActiveUsers = v.botActiveUsers !== void 0;
      if (_botActiveUsers)
        flags2 |= 4096;
      if (v.botHasMainApp === true)
        flags2 |= 8192;
      w.uint(flags2);
      w.int53(h(v, "id"));
      if (_accessHash)
        w.long(v.accessHash);
      if (_firstName)
        w.string(v.firstName);
      if (_lastName)
        w.string(v.lastName);
      if (_username)
        w.string(v.username);
      if (_phone)
        w.string(v.phone);
      if (_photo)
        w.object(v.photo);
      if (_status)
        w.object(v.status);
      if (_flags_14)
        w.int(v.botInfoVersion);
      if (_flags_18)
        w.vector(w.object, v.restrictionReason);
      if (_botInlinePlaceholder)
        w.string(v.botInlinePlaceholder);
      if (_langCode)
        w.string(v.langCode);
      if (_emojiStatus)
        w.object(v.emojiStatus);
      if (_usernames)
        w.vector(w.object, v.usernames);
      if (_storiesMaxId)
        w.int(v.storiesMaxId);
      if (_color)
        w.object(v.color);
      if (_profileColor)
        w.object(v.profileColor);
      if (_botActiveUsers)
        w.int(v.botActiveUsers);
    },
    "userProfilePhotoEmpty": function(w) {
      w.uint(1326562017);
    },
    "userProfilePhoto": function(w, v) {
      w.uint(2194798342);
      var flags = 0;
      if (v.hasVideo === true)
        flags |= 1;
      var _strippedThumb = v.strippedThumb !== void 0;
      if (_strippedThumb)
        flags |= 2;
      if (v.personal === true)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "photoId"));
      if (_strippedThumb)
        w.bytes(v.strippedThumb);
      w.int(h(v, "dcId"));
    },
    "userStatusEmpty": function(w) {
      w.uint(164646985);
    },
    "userStatusOnline": function(w, v) {
      w.uint(3988339017);
      w.int(h(v, "expires"));
    },
    "userStatusOffline": function(w, v) {
      w.uint(9203775);
      w.int(h(v, "wasOnline"));
    },
    "userStatusRecently": function(w, v) {
      w.uint(2065268168);
      var flags = 0;
      if (v.byMe === true)
        flags |= 1;
      w.uint(flags);
    },
    "userStatusLastWeek": function(w, v) {
      w.uint(1410997530);
      var flags = 0;
      if (v.byMe === true)
        flags |= 1;
      w.uint(flags);
    },
    "userStatusLastMonth": function(w, v) {
      w.uint(1703516023);
      var flags = 0;
      if (v.byMe === true)
        flags |= 1;
      w.uint(flags);
    },
    "chatEmpty": function(w, v) {
      w.uint(693512293);
      w.int53(h(v, "id"));
    },
    "chat": function(w, v) {
      w.uint(1103884886);
      var flags = 0;
      if (v.creator === true)
        flags |= 1;
      if (v.left === true)
        flags |= 4;
      if (v.deactivated === true)
        flags |= 32;
      var _migratedTo = v.migratedTo !== void 0;
      if (_migratedTo)
        flags |= 64;
      var _adminRights = v.adminRights !== void 0;
      if (_adminRights)
        flags |= 16384;
      var _defaultBannedRights = v.defaultBannedRights !== void 0;
      if (_defaultBannedRights)
        flags |= 262144;
      if (v.callActive === true)
        flags |= 8388608;
      if (v.callNotEmpty === true)
        flags |= 16777216;
      if (v.noforwards === true)
        flags |= 33554432;
      w.uint(flags);
      w.int53(h(v, "id"));
      w.string(h(v, "title"));
      w.object(h(v, "photo"));
      w.int(h(v, "participantsCount"));
      w.int(h(v, "date"));
      w.int(h(v, "version"));
      if (_migratedTo)
        w.object(v.migratedTo);
      if (_adminRights)
        w.object(v.adminRights);
      if (_defaultBannedRights)
        w.object(v.defaultBannedRights);
    },
    "chatForbidden": function(w, v) {
      w.uint(1704108455);
      w.int53(h(v, "id"));
      w.string(h(v, "title"));
    },
    "channel": function(w, v) {
      w.uint(4265900221);
      var flags = 0;
      if (v.creator === true)
        flags |= 1;
      if (v.left === true)
        flags |= 4;
      if (v.broadcast === true)
        flags |= 32;
      var _username = v.username !== void 0;
      if (_username)
        flags |= 64;
      if (v.verified === true)
        flags |= 128;
      if (v.megagroup === true)
        flags |= 256;
      var _restrictionReason = v.restrictionReason && v.restrictionReason.length;
      var _flags_9 = v.restricted === true || _restrictionReason;
      if (_flags_9)
        flags |= 512;
      if (v.signatures === true)
        flags |= 2048;
      if (v.min === true)
        flags |= 4096;
      var _accessHash = v.accessHash !== void 0;
      if (_accessHash)
        flags |= 8192;
      var _adminRights = v.adminRights !== void 0;
      if (_adminRights)
        flags |= 16384;
      var _bannedRights = v.bannedRights !== void 0;
      if (_bannedRights)
        flags |= 32768;
      var _participantsCount = v.participantsCount !== void 0;
      if (_participantsCount)
        flags |= 131072;
      var _defaultBannedRights = v.defaultBannedRights !== void 0;
      if (_defaultBannedRights)
        flags |= 262144;
      if (v.scam === true)
        flags |= 524288;
      if (v.hasLink === true)
        flags |= 1048576;
      if (v.hasGeo === true)
        flags |= 2097152;
      if (v.slowmodeEnabled === true)
        flags |= 4194304;
      if (v.callActive === true)
        flags |= 8388608;
      if (v.callNotEmpty === true)
        flags |= 16777216;
      if (v.fake === true)
        flags |= 33554432;
      if (v.gigagroup === true)
        flags |= 67108864;
      if (v.noforwards === true)
        flags |= 134217728;
      if (v.joinToSend === true)
        flags |= 268435456;
      if (v.joinRequest === true)
        flags |= 536870912;
      if (v.forum === true)
        flags |= 1073741824;
      w.uint(flags);
      var flags2 = 0;
      var _usernames = v.usernames && v.usernames.length;
      if (_usernames)
        flags2 |= 1;
      if (v.storiesHidden === true)
        flags2 |= 2;
      if (v.storiesHiddenMin === true)
        flags2 |= 4;
      if (v.storiesUnavailable === true)
        flags2 |= 8;
      var _storiesMaxId = v.storiesMaxId !== void 0;
      if (_storiesMaxId)
        flags2 |= 16;
      var _color = v.color !== void 0;
      if (_color)
        flags2 |= 128;
      var _profileColor = v.profileColor !== void 0;
      if (_profileColor)
        flags2 |= 256;
      var _emojiStatus = v.emojiStatus !== void 0;
      if (_emojiStatus)
        flags2 |= 512;
      var _level = v.level !== void 0;
      if (_level)
        flags2 |= 1024;
      var _subscriptionUntilDate = v.subscriptionUntilDate !== void 0;
      if (_subscriptionUntilDate)
        flags2 |= 2048;
      if (v.signatureProfiles === true)
        flags2 |= 4096;
      w.uint(flags2);
      w.int53(h(v, "id"));
      if (_accessHash)
        w.long(v.accessHash);
      w.string(h(v, "title"));
      if (_username)
        w.string(v.username);
      w.object(h(v, "photo"));
      w.int(h(v, "date"));
      if (_flags_9)
        w.vector(w.object, v.restrictionReason);
      if (_adminRights)
        w.object(v.adminRights);
      if (_bannedRights)
        w.object(v.bannedRights);
      if (_defaultBannedRights)
        w.object(v.defaultBannedRights);
      if (_participantsCount)
        w.int(v.participantsCount);
      if (_usernames)
        w.vector(w.object, v.usernames);
      if (_storiesMaxId)
        w.int(v.storiesMaxId);
      if (_color)
        w.object(v.color);
      if (_profileColor)
        w.object(v.profileColor);
      if (_emojiStatus)
        w.object(v.emojiStatus);
      if (_level)
        w.int(v.level);
      if (_subscriptionUntilDate)
        w.int(v.subscriptionUntilDate);
    },
    "channelForbidden": function(w, v) {
      w.uint(399807445);
      var flags = 0;
      if (v.broadcast === true)
        flags |= 32;
      if (v.megagroup === true)
        flags |= 256;
      var _untilDate = v.untilDate !== void 0;
      if (_untilDate)
        flags |= 65536;
      w.uint(flags);
      w.int53(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.string(h(v, "title"));
      if (_untilDate)
        w.int(v.untilDate);
    },
    "chatFull": function(w, v) {
      w.uint(640893467);
      var flags = 0;
      var _chatPhoto = v.chatPhoto !== void 0;
      if (_chatPhoto)
        flags |= 4;
      var _botInfo = v.botInfo && v.botInfo.length;
      if (_botInfo)
        flags |= 8;
      var _pinnedMsgId = v.pinnedMsgId !== void 0;
      if (_pinnedMsgId)
        flags |= 64;
      if (v.canSetUsername === true)
        flags |= 128;
      if (v.hasScheduled === true)
        flags |= 256;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 2048;
      var _call = v.call !== void 0;
      if (_call)
        flags |= 4096;
      var _exportedInvite = v.exportedInvite !== void 0;
      if (_exportedInvite)
        flags |= 8192;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 16384;
      var _groupcallDefaultJoinAs = v.groupcallDefaultJoinAs !== void 0;
      if (_groupcallDefaultJoinAs)
        flags |= 32768;
      var _themeEmoticon = v.themeEmoticon !== void 0;
      if (_themeEmoticon)
        flags |= 65536;
      var _requestsPending = v.requestsPending !== void 0;
      var _recentRequesters = v.recentRequesters && v.recentRequesters.length;
      var _flags_17 = _requestsPending || _recentRequesters;
      if (_flags_17)
        flags |= 131072;
      var _availableReactions = v.availableReactions !== void 0;
      if (_availableReactions)
        flags |= 262144;
      if (v.translationsDisabled === true)
        flags |= 524288;
      var _reactionsLimit = v.reactionsLimit !== void 0;
      if (_reactionsLimit)
        flags |= 1048576;
      w.uint(flags);
      w.int53(h(v, "id"));
      w.string(h(v, "about"));
      w.object(h(v, "participants"));
      if (_chatPhoto)
        w.object(v.chatPhoto);
      w.object(h(v, "notifySettings"));
      if (_exportedInvite)
        w.object(v.exportedInvite);
      if (_botInfo)
        w.vector(w.object, v.botInfo);
      if (_pinnedMsgId)
        w.int(v.pinnedMsgId);
      if (_folderId)
        w.int(v.folderId);
      if (_call)
        w.object(v.call);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
      if (_groupcallDefaultJoinAs)
        w.object(v.groupcallDefaultJoinAs);
      if (_themeEmoticon)
        w.string(v.themeEmoticon);
      if (_flags_17)
        w.int(v.requestsPending);
      if (_flags_17)
        w.vector(w.long, v.recentRequesters);
      if (_availableReactions)
        w.object(v.availableReactions);
      if (_reactionsLimit)
        w.int(v.reactionsLimit);
    },
    "channelFull": function(w, v) {
      w.uint(3148559501);
      var flags = 0;
      var _participantsCount = v.participantsCount !== void 0;
      if (_participantsCount)
        flags |= 1;
      var _adminsCount = v.adminsCount !== void 0;
      if (_adminsCount)
        flags |= 2;
      var _kickedCount = v.kickedCount !== void 0;
      var _bannedCount = v.bannedCount !== void 0;
      var _flags_2 = _kickedCount || _bannedCount;
      if (_flags_2)
        flags |= 4;
      if (v.canViewParticipants === true)
        flags |= 8;
      var _migratedFromChatId = v.migratedFromChatId !== void 0;
      var _migratedFromMaxId = v.migratedFromMaxId !== void 0;
      var _flags_4 = _migratedFromChatId || _migratedFromMaxId;
      if (_flags_4)
        flags |= 16;
      var _pinnedMsgId = v.pinnedMsgId !== void 0;
      if (_pinnedMsgId)
        flags |= 32;
      if (v.canSetUsername === true)
        flags |= 64;
      if (v.canSetStickers === true)
        flags |= 128;
      var _stickerset = v.stickerset !== void 0;
      if (_stickerset)
        flags |= 256;
      var _availableMinId = v.availableMinId !== void 0;
      if (_availableMinId)
        flags |= 512;
      if (v.hiddenPrehistory === true)
        flags |= 1024;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 2048;
      var _statsDc = v.statsDc !== void 0;
      if (_statsDc)
        flags |= 4096;
      var _onlineCount = v.onlineCount !== void 0;
      if (_onlineCount)
        flags |= 8192;
      var _linkedChatId = v.linkedChatId !== void 0;
      if (_linkedChatId)
        flags |= 16384;
      var _location = v.location !== void 0;
      if (_location)
        flags |= 32768;
      if (v.canSetLocation === true)
        flags |= 65536;
      var _slowmodeSeconds = v.slowmodeSeconds !== void 0;
      if (_slowmodeSeconds)
        flags |= 131072;
      var _slowmodeNextSendDate = v.slowmodeNextSendDate !== void 0;
      if (_slowmodeNextSendDate)
        flags |= 262144;
      if (v.hasScheduled === true)
        flags |= 524288;
      if (v.canViewStats === true)
        flags |= 1048576;
      var _call = v.call !== void 0;
      if (_call)
        flags |= 2097152;
      if (v.blocked === true)
        flags |= 4194304;
      var _exportedInvite = v.exportedInvite !== void 0;
      if (_exportedInvite)
        flags |= 8388608;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 16777216;
      var _pendingSuggestions = v.pendingSuggestions && v.pendingSuggestions.length;
      if (_pendingSuggestions)
        flags |= 33554432;
      var _groupcallDefaultJoinAs = v.groupcallDefaultJoinAs !== void 0;
      if (_groupcallDefaultJoinAs)
        flags |= 67108864;
      var _themeEmoticon = v.themeEmoticon !== void 0;
      if (_themeEmoticon)
        flags |= 134217728;
      var _requestsPending = v.requestsPending !== void 0;
      var _recentRequesters = v.recentRequesters && v.recentRequesters.length;
      var _flags_28 = _requestsPending || _recentRequesters;
      if (_flags_28)
        flags |= 268435456;
      var _defaultSendAs = v.defaultSendAs !== void 0;
      if (_defaultSendAs)
        flags |= 536870912;
      var _availableReactions = v.availableReactions !== void 0;
      if (_availableReactions)
        flags |= 1073741824;
      w.uint(flags);
      var flags2 = 0;
      if (v.canDeleteChannel === true)
        flags2 |= 1;
      if (v.antispam === true)
        flags2 |= 2;
      if (v.participantsHidden === true)
        flags2 |= 4;
      if (v.translationsDisabled === true)
        flags2 |= 8;
      var _stories = v.stories !== void 0;
      if (_stories)
        flags2 |= 16;
      if (v.storiesPinnedAvailable === true)
        flags2 |= 32;
      if (v.viewForumAsMessages === true)
        flags2 |= 64;
      var _wallpaper = v.wallpaper !== void 0;
      if (_wallpaper)
        flags2 |= 128;
      var _boostsApplied = v.boostsApplied !== void 0;
      if (_boostsApplied)
        flags2 |= 256;
      var _boostsUnrestrict = v.boostsUnrestrict !== void 0;
      if (_boostsUnrestrict)
        flags2 |= 512;
      var _emojiset = v.emojiset !== void 0;
      if (_emojiset)
        flags2 |= 1024;
      if (v.restrictedSponsored === true)
        flags2 |= 2048;
      if (v.canViewRevenue === true)
        flags2 |= 4096;
      var _reactionsLimit = v.reactionsLimit !== void 0;
      if (_reactionsLimit)
        flags2 |= 8192;
      if (v.paidMediaAllowed === true)
        flags2 |= 16384;
      if (v.canViewStarsRevenue === true)
        flags2 |= 32768;
      if (v.paidReactionsAvailable === true)
        flags2 |= 65536;
      w.uint(flags2);
      w.int53(h(v, "id"));
      w.string(h(v, "about"));
      if (_participantsCount)
        w.int(v.participantsCount);
      if (_adminsCount)
        w.int(v.adminsCount);
      if (_flags_2)
        w.int(v.kickedCount);
      if (_flags_2)
        w.int(v.bannedCount);
      if (_onlineCount)
        w.int(v.onlineCount);
      w.int(h(v, "readInboxMaxId"));
      w.int(h(v, "readOutboxMaxId"));
      w.int(h(v, "unreadCount"));
      w.object(h(v, "chatPhoto"));
      w.object(h(v, "notifySettings"));
      if (_exportedInvite)
        w.object(v.exportedInvite);
      w.vector(w.object, h(v, "botInfo"));
      if (_flags_4)
        w.long(v.migratedFromChatId);
      if (_flags_4)
        w.int(v.migratedFromMaxId);
      if (_pinnedMsgId)
        w.int(v.pinnedMsgId);
      if (_stickerset)
        w.object(v.stickerset);
      if (_availableMinId)
        w.int(v.availableMinId);
      if (_folderId)
        w.int(v.folderId);
      if (_linkedChatId)
        w.int53(v.linkedChatId);
      if (_location)
        w.object(v.location);
      if (_slowmodeSeconds)
        w.int(v.slowmodeSeconds);
      if (_slowmodeNextSendDate)
        w.int(v.slowmodeNextSendDate);
      if (_statsDc)
        w.int(v.statsDc);
      w.int(h(v, "pts"));
      if (_call)
        w.object(v.call);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
      if (_pendingSuggestions)
        w.vector(w.string, v.pendingSuggestions);
      if (_groupcallDefaultJoinAs)
        w.object(v.groupcallDefaultJoinAs);
      if (_themeEmoticon)
        w.string(v.themeEmoticon);
      if (_flags_28)
        w.int(v.requestsPending);
      if (_flags_28)
        w.vector(w.long, v.recentRequesters);
      if (_defaultSendAs)
        w.object(v.defaultSendAs);
      if (_availableReactions)
        w.object(v.availableReactions);
      if (_reactionsLimit)
        w.int(v.reactionsLimit);
      if (_stories)
        w.object(v.stories);
      if (_wallpaper)
        w.object(v.wallpaper);
      if (_boostsApplied)
        w.int(v.boostsApplied);
      if (_boostsUnrestrict)
        w.int(v.boostsUnrestrict);
      if (_emojiset)
        w.object(v.emojiset);
    },
    "chatParticipant": function(w, v) {
      w.uint(3224190983);
      w.int53(h(v, "userId"));
      w.int53(h(v, "inviterId"));
      w.int(h(v, "date"));
    },
    "chatParticipantCreator": function(w, v) {
      w.uint(3832270564);
      w.int53(h(v, "userId"));
    },
    "chatParticipantAdmin": function(w, v) {
      w.uint(2694004571);
      w.int53(h(v, "userId"));
      w.int53(h(v, "inviterId"));
      w.int(h(v, "date"));
    },
    "chatParticipantsForbidden": function(w, v) {
      w.uint(2271466465);
      var flags = 0;
      var _selfParticipant = v.selfParticipant !== void 0;
      if (_selfParticipant)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "chatId"));
      if (_selfParticipant)
        w.object(v.selfParticipant);
    },
    "chatParticipants": function(w, v) {
      w.uint(1018991608);
      w.int53(h(v, "chatId"));
      w.vector(w.object, h(v, "participants"));
      w.int(h(v, "version"));
    },
    "chatPhotoEmpty": function(w) {
      w.uint(935395612);
    },
    "chatPhoto": function(w, v) {
      w.uint(476978193);
      var flags = 0;
      if (v.hasVideo === true)
        flags |= 1;
      var _strippedThumb = v.strippedThumb !== void 0;
      if (_strippedThumb)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "photoId"));
      if (_strippedThumb)
        w.bytes(v.strippedThumb);
      w.int(h(v, "dcId"));
    },
    "messageEmpty": function(w, v) {
      w.uint(2426849924);
      var flags = 0;
      var _peerId = v.peerId !== void 0;
      if (_peerId)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "id"));
      if (_peerId)
        w.object(v.peerId);
    },
    "message": function(w, v) {
      w.uint(2486456898);
      var flags = 0;
      if (v.out === true)
        flags |= 2;
      var _fwdFrom = v.fwdFrom !== void 0;
      if (_fwdFrom)
        flags |= 4;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 8;
      if (v.mentioned === true)
        flags |= 16;
      if (v.mediaUnread === true)
        flags |= 32;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 64;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 128;
      var _fromId = v.fromId !== void 0;
      if (_fromId)
        flags |= 256;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 512;
      var _views = v.views !== void 0;
      var _forwards = v.forwards !== void 0;
      var _flags_10 = _views || _forwards;
      if (_flags_10)
        flags |= 1024;
      var _viaBotId = v.viaBotId !== void 0;
      if (_viaBotId)
        flags |= 2048;
      if (v.silent === true)
        flags |= 8192;
      if (v.post === true)
        flags |= 16384;
      var _editDate = v.editDate !== void 0;
      if (_editDate)
        flags |= 32768;
      var _postAuthor = v.postAuthor !== void 0;
      if (_postAuthor)
        flags |= 65536;
      var _groupedId = v.groupedId !== void 0;
      if (_groupedId)
        flags |= 131072;
      if (v.fromScheduled === true)
        flags |= 262144;
      if (v.legacy === true)
        flags |= 524288;
      var _reactions = v.reactions !== void 0;
      if (_reactions)
        flags |= 1048576;
      if (v.editHide === true)
        flags |= 2097152;
      var _restrictionReason = v.restrictionReason && v.restrictionReason.length;
      if (_restrictionReason)
        flags |= 4194304;
      var _replies = v.replies !== void 0;
      if (_replies)
        flags |= 8388608;
      if (v.pinned === true)
        flags |= 16777216;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 33554432;
      if (v.noforwards === true)
        flags |= 67108864;
      if (v.invertMedia === true)
        flags |= 134217728;
      var _savedPeerId = v.savedPeerId !== void 0;
      if (_savedPeerId)
        flags |= 268435456;
      var _fromBoostsApplied = v.fromBoostsApplied !== void 0;
      if (_fromBoostsApplied)
        flags |= 536870912;
      var _quickReplyShortcutId = v.quickReplyShortcutId !== void 0;
      if (_quickReplyShortcutId)
        flags |= 1073741824;
      w.uint(flags);
      var flags2 = 0;
      var _viaBusinessBotId = v.viaBusinessBotId !== void 0;
      if (_viaBusinessBotId)
        flags2 |= 1;
      if (v.offline === true)
        flags2 |= 2;
      var _effect = v.effect !== void 0;
      if (_effect)
        flags2 |= 4;
      var _factcheck = v.factcheck !== void 0;
      if (_factcheck)
        flags2 |= 8;
      w.uint(flags2);
      w.int(h(v, "id"));
      if (_fromId)
        w.object(v.fromId);
      if (_fromBoostsApplied)
        w.int(v.fromBoostsApplied);
      w.object(h(v, "peerId"));
      if (_savedPeerId)
        w.object(v.savedPeerId);
      if (_fwdFrom)
        w.object(v.fwdFrom);
      if (_viaBotId)
        w.int53(v.viaBotId);
      if (_viaBusinessBotId)
        w.int53(v.viaBusinessBotId);
      if (_replyTo)
        w.object(v.replyTo);
      w.int(h(v, "date"));
      w.string(h(v, "message"));
      if (_media)
        w.object(v.media);
      if (_replyMarkup)
        w.object(v.replyMarkup);
      if (_entities)
        w.vector(w.object, v.entities);
      if (_flags_10)
        w.int(v.views);
      if (_flags_10)
        w.int(v.forwards);
      if (_replies)
        w.object(v.replies);
      if (_editDate)
        w.int(v.editDate);
      if (_postAuthor)
        w.string(v.postAuthor);
      if (_groupedId)
        w.long(v.groupedId);
      if (_reactions)
        w.object(v.reactions);
      if (_restrictionReason)
        w.vector(w.object, v.restrictionReason);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
      if (_quickReplyShortcutId)
        w.int(v.quickReplyShortcutId);
      if (_effect)
        w.long(v.effect);
      if (_factcheck)
        w.object(v.factcheck);
    },
    "messageService": function(w, v) {
      w.uint(721967202);
      var flags = 0;
      if (v.out === true)
        flags |= 2;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 8;
      if (v.mentioned === true)
        flags |= 16;
      if (v.mediaUnread === true)
        flags |= 32;
      var _fromId = v.fromId !== void 0;
      if (_fromId)
        flags |= 256;
      if (v.silent === true)
        flags |= 8192;
      if (v.post === true)
        flags |= 16384;
      if (v.legacy === true)
        flags |= 524288;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 33554432;
      w.uint(flags);
      w.int(h(v, "id"));
      if (_fromId)
        w.object(v.fromId);
      w.object(h(v, "peerId"));
      if (_replyTo)
        w.object(v.replyTo);
      w.int(h(v, "date"));
      w.object(h(v, "action"));
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "messageMediaEmpty": function(w) {
      w.uint(1038967584);
    },
    "messageMediaPhoto": function(w, v) {
      w.uint(1766936791);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 1;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 4;
      if (v.spoiler === true)
        flags |= 8;
      w.uint(flags);
      if (_photo)
        w.object(v.photo);
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
    },
    "messageMediaGeo": function(w, v) {
      w.uint(1457575028);
      w.object(h(v, "geo"));
    },
    "messageMediaContact": function(w, v) {
      w.uint(1882335561);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
      w.string(h(v, "vcard"));
      w.int53(h(v, "userId"));
    },
    "messageMediaUnsupported": function(w) {
      w.uint(2676290718);
    },
    "messageMediaDocument": function(w, v) {
      w.uint(3713469397);
      var flags = 0;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 1;
      var _ttlSeconds = v.ttlSeconds !== void 0;
      if (_ttlSeconds)
        flags |= 4;
      if (v.nopremium === true)
        flags |= 8;
      if (v.spoiler === true)
        flags |= 16;
      var _altDocuments = v.altDocuments && v.altDocuments.length;
      if (_altDocuments)
        flags |= 32;
      if (v.video === true)
        flags |= 64;
      if (v.round === true)
        flags |= 128;
      if (v.voice === true)
        flags |= 256;
      w.uint(flags);
      if (_document)
        w.object(v.document);
      if (_altDocuments)
        w.vector(w.object, v.altDocuments);
      if (_ttlSeconds)
        w.int(v.ttlSeconds);
    },
    "messageMediaWebPage": function(w, v) {
      w.uint(3723562043);
      var flags = 0;
      if (v.forceLargeMedia === true)
        flags |= 1;
      if (v.forceSmallMedia === true)
        flags |= 2;
      if (v.manual === true)
        flags |= 8;
      if (v.safe === true)
        flags |= 16;
      w.uint(flags);
      w.object(h(v, "webpage"));
    },
    "messageMediaVenue": function(w, v) {
      w.uint(784356159);
      w.object(h(v, "geo"));
      w.string(h(v, "title"));
      w.string(h(v, "address"));
      w.string(h(v, "provider"));
      w.string(h(v, "venueId"));
      w.string(h(v, "venueType"));
    },
    "messageMediaGame": function(w, v) {
      w.uint(4256272392);
      w.object(h(v, "game"));
    },
    "messageMediaInvoice": function(w, v) {
      w.uint(4138027219);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 1;
      if (v.shippingAddressRequested === true)
        flags |= 2;
      var _receiptMsgId = v.receiptMsgId !== void 0;
      if (_receiptMsgId)
        flags |= 4;
      if (v.test === true)
        flags |= 8;
      var _extendedMedia = v.extendedMedia !== void 0;
      if (_extendedMedia)
        flags |= 16;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      if (_receiptMsgId)
        w.int(v.receiptMsgId);
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
      w.string(h(v, "startParam"));
      if (_extendedMedia)
        w.object(v.extendedMedia);
    },
    "messageMediaGeoLive": function(w, v) {
      w.uint(3108030054);
      var flags = 0;
      var _heading = v.heading !== void 0;
      if (_heading)
        flags |= 1;
      var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
      if (_proximityNotificationRadius)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "geo"));
      if (_heading)
        w.int(v.heading);
      w.int(h(v, "period"));
      if (_proximityNotificationRadius)
        w.int(v.proximityNotificationRadius);
    },
    "messageMediaPoll": function(w, v) {
      w.uint(1272375192);
      w.object(h(v, "poll"));
      w.object(h(v, "results"));
    },
    "messageMediaDice": function(w, v) {
      w.uint(1065280907);
      w.int(h(v, "value"));
      w.string(h(v, "emoticon"));
    },
    "messageMediaStory": function(w, v) {
      w.uint(1758159491);
      var flags = 0;
      var _story = v.story !== void 0;
      if (_story)
        flags |= 1;
      if (v.viaMention === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      if (_story)
        w.object(v.story);
    },
    "messageMediaGiveaway": function(w, v) {
      w.uint(2852600811);
      var flags = 0;
      if (v.onlyNewSubscribers === true)
        flags |= 1;
      var _countriesIso2 = v.countriesIso2 && v.countriesIso2.length;
      if (_countriesIso2)
        flags |= 2;
      if (v.winnersAreVisible === true)
        flags |= 4;
      var _prizeDescription = v.prizeDescription !== void 0;
      if (_prizeDescription)
        flags |= 8;
      var _months = v.months !== void 0;
      if (_months)
        flags |= 16;
      var _stars = v.stars !== void 0;
      if (_stars)
        flags |= 32;
      w.uint(flags);
      w.vector(w.int53, h(v, "channels"));
      if (_countriesIso2)
        w.vector(w.string, v.countriesIso2);
      if (_prizeDescription)
        w.string(v.prizeDescription);
      w.int(h(v, "quantity"));
      if (_months)
        w.int(v.months);
      if (_stars)
        w.long(v.stars);
      w.int(h(v, "untilDate"));
    },
    "messageMediaGiveawayResults": function(w, v) {
      w.uint(3467263649);
      var flags = 0;
      if (v.onlyNewSubscribers === true)
        flags |= 1;
      var _prizeDescription = v.prizeDescription !== void 0;
      if (_prizeDescription)
        flags |= 2;
      if (v.refunded === true)
        flags |= 4;
      var _additionalPeersCount = v.additionalPeersCount !== void 0;
      if (_additionalPeersCount)
        flags |= 8;
      var _months = v.months !== void 0;
      if (_months)
        flags |= 16;
      var _stars = v.stars !== void 0;
      if (_stars)
        flags |= 32;
      w.uint(flags);
      w.long(h(v, "channelId"));
      if (_additionalPeersCount)
        w.int(v.additionalPeersCount);
      w.int(h(v, "launchMsgId"));
      w.int(h(v, "winnersCount"));
      w.int(h(v, "unclaimedCount"));
      w.vector(w.long, h(v, "winners"));
      if (_months)
        w.int(v.months);
      if (_stars)
        w.long(v.stars);
      if (_prizeDescription)
        w.string(v.prizeDescription);
      w.int(h(v, "untilDate"));
    },
    "messageMediaPaidMedia": function(w, v) {
      w.uint(2827297937);
      w.long(h(v, "starsAmount"));
      w.vector(w.object, h(v, "extendedMedia"));
    },
    "messageActionEmpty": function(w) {
      w.uint(3064919984);
    },
    "messageActionChatCreate": function(w, v) {
      w.uint(3175599021);
      w.string(h(v, "title"));
      w.vector(w.int53, h(v, "users"));
    },
    "messageActionChatEditTitle": function(w, v) {
      w.uint(3047280218);
      w.string(h(v, "title"));
    },
    "messageActionChatEditPhoto": function(w, v) {
      w.uint(2144015272);
      w.object(h(v, "photo"));
    },
    "messageActionChatDeletePhoto": function(w) {
      w.uint(2514746351);
    },
    "messageActionChatAddUser": function(w, v) {
      w.uint(365886720);
      w.vector(w.int53, h(v, "users"));
    },
    "messageActionChatDeleteUser": function(w, v) {
      w.uint(2755604684);
      w.int53(h(v, "userId"));
    },
    "messageActionChatJoinedByLink": function(w, v) {
      w.uint(51520707);
      w.int53(h(v, "inviterId"));
    },
    "messageActionChannelCreate": function(w, v) {
      w.uint(2513611922);
      w.string(h(v, "title"));
    },
    "messageActionChatMigrateTo": function(w, v) {
      w.uint(3775102866);
      w.int53(h(v, "channelId"));
    },
    "messageActionChannelMigrateFrom": function(w, v) {
      w.uint(3929622761);
      w.string(h(v, "title"));
      w.int53(h(v, "chatId"));
    },
    "messageActionPinMessage": function(w) {
      w.uint(2495428845);
    },
    "messageActionHistoryClear": function(w) {
      w.uint(2679813636);
    },
    "messageActionGameScore": function(w, v) {
      w.uint(2460428406);
      w.long(h(v, "gameId"));
      w.int(h(v, "score"));
    },
    "messageActionPaymentSentMe": function(w, v) {
      w.uint(2402399015);
      var flags = 0;
      var _info = v.info !== void 0;
      if (_info)
        flags |= 1;
      var _shippingOptionId = v.shippingOptionId !== void 0;
      if (_shippingOptionId)
        flags |= 2;
      if (v.recurringInit === true)
        flags |= 4;
      if (v.recurringUsed === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
      w.bytes(h(v, "payload"));
      if (_info)
        w.object(v.info);
      if (_shippingOptionId)
        w.string(v.shippingOptionId);
      w.object(h(v, "charge"));
    },
    "messageActionPaymentSent": function(w, v) {
      w.uint(2518040406);
      var flags = 0;
      var _invoiceSlug = v.invoiceSlug !== void 0;
      if (_invoiceSlug)
        flags |= 1;
      if (v.recurringInit === true)
        flags |= 4;
      if (v.recurringUsed === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
      if (_invoiceSlug)
        w.string(v.invoiceSlug);
    },
    "messageActionPhoneCall": function(w, v) {
      w.uint(2162236031);
      var flags = 0;
      var _reason = v.reason !== void 0;
      if (_reason)
        flags |= 1;
      var _duration = v.duration !== void 0;
      if (_duration)
        flags |= 2;
      if (v.video === true)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "callId"));
      if (_reason)
        w.object(v.reason);
      if (_duration)
        w.int(v.duration);
    },
    "messageActionScreenshotTaken": function(w) {
      w.uint(1200788123);
    },
    "messageActionCustomAction": function(w, v) {
      w.uint(4209418070);
      w.string(h(v, "message"));
    },
    "messageActionBotAllowed": function(w, v) {
      w.uint(3306608249);
      var flags = 0;
      var _domain = v.domain !== void 0;
      if (_domain)
        flags |= 1;
      if (v.attachMenu === true)
        flags |= 2;
      var _app = v.app !== void 0;
      if (_app)
        flags |= 4;
      if (v.fromRequest === true)
        flags |= 8;
      w.uint(flags);
      if (_domain)
        w.string(v.domain);
      if (_app)
        w.object(v.app);
    },
    "messageActionSecureValuesSentMe": function(w, v) {
      w.uint(455635795);
      w.vector(w.object, h(v, "values"));
      w.object(h(v, "credentials"));
    },
    "messageActionSecureValuesSent": function(w, v) {
      w.uint(3646710100);
      w.vector(w.object, h(v, "types"));
    },
    "messageActionContactSignUp": function(w) {
      w.uint(4092747638);
    },
    "messageActionGeoProximityReached": function(w, v) {
      w.uint(2564871831);
      w.object(h(v, "fromId"));
      w.object(h(v, "toId"));
      w.int(h(v, "distance"));
    },
    "messageActionGroupCall": function(w, v) {
      w.uint(2047704898);
      var flags = 0;
      var _duration = v.duration !== void 0;
      if (_duration)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "call"));
      if (_duration)
        w.int(v.duration);
    },
    "messageActionInviteToGroupCall": function(w, v) {
      w.uint(1345295095);
      w.object(h(v, "call"));
      w.vector(w.int53, h(v, "users"));
    },
    "messageActionSetMessagesTTL": function(w, v) {
      w.uint(1007897979);
      var flags = 0;
      var _autoSettingFrom = v.autoSettingFrom !== void 0;
      if (_autoSettingFrom)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "period"));
      if (_autoSettingFrom)
        w.long(v.autoSettingFrom);
    },
    "messageActionGroupCallScheduled": function(w, v) {
      w.uint(3013637729);
      w.object(h(v, "call"));
      w.int(h(v, "scheduleDate"));
    },
    "messageActionSetChatTheme": function(w, v) {
      w.uint(2860016453);
      w.string(h(v, "emoticon"));
    },
    "messageActionChatJoinedByRequest": function(w) {
      w.uint(3955008459);
    },
    "messageActionWebViewDataSentMe": function(w, v) {
      w.uint(1205698681);
      w.string(h(v, "text"));
      w.string(h(v, "data"));
    },
    "messageActionWebViewDataSent": function(w, v) {
      w.uint(3032714421);
      w.string(h(v, "text"));
    },
    "messageActionGiftPremium": function(w, v) {
      w.uint(3359468268);
      var flags = 0;
      var _cryptoCurrency = v.cryptoCurrency !== void 0;
      var _cryptoAmount = v.cryptoAmount !== void 0;
      var _flags_0 = _cryptoCurrency || _cryptoAmount;
      if (_flags_0)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
      w.int(h(v, "months"));
      if (_flags_0)
        w.string(v.cryptoCurrency);
      if (_flags_0)
        w.long(v.cryptoAmount);
    },
    "messageActionTopicCreate": function(w, v) {
      w.uint(228168278);
      var flags = 0;
      var _iconEmojiId = v.iconEmojiId !== void 0;
      if (_iconEmojiId)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "title"));
      w.int(h(v, "iconColor"));
      if (_iconEmojiId)
        w.long(v.iconEmojiId);
    },
    "messageActionTopicEdit": function(w, v) {
      w.uint(3230943264);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _iconEmojiId = v.iconEmojiId !== void 0;
      if (_iconEmojiId)
        flags |= 2;
      var _closed = v.closed !== void 0;
      if (_closed)
        flags |= 4;
      var _hidden = v.hidden !== void 0;
      if (_hidden)
        flags |= 8;
      w.uint(flags);
      if (_title)
        w.string(v.title);
      if (_iconEmojiId)
        w.long(v.iconEmojiId);
      if (_closed)
        w.boolean(v.closed);
      if (_hidden)
        w.boolean(v.hidden);
    },
    "messageActionSuggestProfilePhoto": function(w, v) {
      w.uint(1474192222);
      w.object(h(v, "photo"));
    },
    "messageActionRequestedPeer": function(w, v) {
      w.uint(827428507);
      w.int(h(v, "buttonId"));
      w.vector(w.object, h(v, "peers"));
    },
    "messageActionSetChatWallPaper": function(w, v) {
      w.uint(1348510708);
      var flags = 0;
      if (v.same === true)
        flags |= 1;
      if (v.forBoth === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "wallpaper"));
    },
    "messageActionGiftCode": function(w, v) {
      w.uint(1737240073);
      var flags = 0;
      if (v.viaGiveaway === true)
        flags |= 1;
      var _boostPeer = v.boostPeer !== void 0;
      if (_boostPeer)
        flags |= 2;
      var _currency = v.currency !== void 0;
      var _amount = v.amount !== void 0;
      var _flags_2 = v.unclaimed === true || _currency || _amount;
      if (_flags_2)
        flags |= 4;
      var _cryptoCurrency = v.cryptoCurrency !== void 0;
      var _cryptoAmount = v.cryptoAmount !== void 0;
      var _flags_3 = _cryptoCurrency || _cryptoAmount;
      if (_flags_3)
        flags |= 8;
      w.uint(flags);
      if (_boostPeer)
        w.object(v.boostPeer);
      w.int(h(v, "months"));
      w.string(h(v, "slug"));
      if (_flags_2)
        w.string(v.currency);
      if (_flags_2)
        w.long(v.amount);
      if (_flags_3)
        w.string(v.cryptoCurrency);
      if (_flags_3)
        w.long(v.cryptoAmount);
    },
    "messageActionGiveawayLaunch": function(w, v) {
      w.uint(2819576292);
      var flags = 0;
      var _stars = v.stars !== void 0;
      if (_stars)
        flags |= 1;
      w.uint(flags);
      if (_stars)
        w.long(v.stars);
    },
    "messageActionGiveawayResults": function(w, v) {
      w.uint(2279797077);
      var flags = 0;
      if (v.stars === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "winnersCount"));
      w.int(h(v, "unclaimedCount"));
    },
    "messageActionBoostApply": function(w, v) {
      w.uint(3422726765);
      w.int(h(v, "boosts"));
    },
    "messageActionRequestedPeerSentMe": function(w, v) {
      w.uint(2477987912);
      w.int(h(v, "buttonId"));
      w.vector(w.object, h(v, "peers"));
    },
    "messageActionPaymentRefunded": function(w, v) {
      w.uint(1102307842);
      var flags = 0;
      var _payload = v.payload !== void 0;
      if (_payload)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
      if (_payload)
        w.bytes(v.payload);
      w.object(h(v, "charge"));
    },
    "messageActionGiftStars": function(w, v) {
      w.uint(1171632161);
      var flags = 0;
      var _cryptoCurrency = v.cryptoCurrency !== void 0;
      var _cryptoAmount = v.cryptoAmount !== void 0;
      var _flags_0 = _cryptoCurrency || _cryptoAmount;
      if (_flags_0)
        flags |= 1;
      var _transactionId = v.transactionId !== void 0;
      if (_transactionId)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
      w.long(h(v, "stars"));
      if (_flags_0)
        w.string(v.cryptoCurrency);
      if (_flags_0)
        w.long(v.cryptoAmount);
      if (_transactionId)
        w.string(v.transactionId);
    },
    "messageActionPrizeStars": function(w, v) {
      w.uint(2953594786);
      var flags = 0;
      if (v.unclaimed === true)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "stars"));
      w.string(h(v, "transactionId"));
      w.object(h(v, "boostPeer"));
      w.int(h(v, "giveawayMsgId"));
    },
    "messageActionStarGift": function(w, v) {
      w.uint(2612260676);
      var flags = 0;
      if (v.nameHidden === true)
        flags |= 1;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 2;
      if (v.saved === true)
        flags |= 4;
      if (v.converted === true)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "gift"));
      if (_message)
        w.object(v.message);
      w.long(h(v, "convertStars"));
    },
    "dialog": function(w, v) {
      w.uint(3582593222);
      var flags = 0;
      var _pts = v.pts !== void 0;
      if (_pts)
        flags |= 1;
      var _draft = v.draft !== void 0;
      if (_draft)
        flags |= 2;
      if (v.pinned === true)
        flags |= 4;
      if (v.unreadMark === true)
        flags |= 8;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 16;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 32;
      if (v.viewForumAsMessages === true)
        flags |= 64;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "topMessage"));
      w.int(h(v, "readInboxMaxId"));
      w.int(h(v, "readOutboxMaxId"));
      w.int(h(v, "unreadCount"));
      w.int(h(v, "unreadMentionsCount"));
      w.int(h(v, "unreadReactionsCount"));
      w.object(h(v, "notifySettings"));
      if (_pts)
        w.int(v.pts);
      if (_draft)
        w.object(v.draft);
      if (_folderId)
        w.int(v.folderId);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "dialogFolder": function(w, v) {
      w.uint(1908216652);
      var flags = 0;
      if (v.pinned === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "folder"));
      w.object(h(v, "peer"));
      w.int(h(v, "topMessage"));
      w.int(h(v, "unreadMutedPeersCount"));
      w.int(h(v, "unreadUnmutedPeersCount"));
      w.int(h(v, "unreadMutedMessagesCount"));
      w.int(h(v, "unreadUnmutedMessagesCount"));
    },
    "photoEmpty": function(w, v) {
      w.uint(590459437);
      w.long(h(v, "id"));
    },
    "photo": function(w, v) {
      w.uint(4212750949);
      var flags = 0;
      if (v.hasStickers === true)
        flags |= 1;
      var _videoSizes = v.videoSizes && v.videoSizes.length;
      if (_videoSizes)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.bytes(h(v, "fileReference"));
      w.int(h(v, "date"));
      w.vector(w.object, h(v, "sizes"));
      if (_videoSizes)
        w.vector(w.object, v.videoSizes);
      w.int(h(v, "dcId"));
    },
    "photoSizeEmpty": function(w, v) {
      w.uint(236446268);
      w.string(h(v, "type"));
    },
    "photoSize": function(w, v) {
      w.uint(1976012384);
      w.string(h(v, "type"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
      w.int(h(v, "size"));
    },
    "photoCachedSize": function(w, v) {
      w.uint(35527382);
      w.string(h(v, "type"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
      w.bytes(h(v, "bytes"));
    },
    "photoStrippedSize": function(w, v) {
      w.uint(3769678894);
      w.string(h(v, "type"));
      w.bytes(h(v, "bytes"));
    },
    "photoSizeProgressive": function(w, v) {
      w.uint(4198431637);
      w.string(h(v, "type"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
      w.vector(w.int, h(v, "sizes"));
    },
    "photoPathSize": function(w, v) {
      w.uint(3626061121);
      w.string(h(v, "type"));
      w.bytes(h(v, "bytes"));
    },
    "geoPointEmpty": function(w) {
      w.uint(286776671);
    },
    "geoPoint": function(w, v) {
      w.uint(2997024355);
      var flags = 0;
      var _accuracyRadius = v.accuracyRadius !== void 0;
      if (_accuracyRadius)
        flags |= 1;
      w.uint(flags);
      w.double(h(v, "long"));
      w.double(h(v, "lat"));
      w.long(h(v, "accessHash"));
      if (_accuracyRadius)
        w.int(v.accuracyRadius);
    },
    "auth.sentCode": function(w, v) {
      w.uint(1577067778);
      var flags = 0;
      var _nextType = v.nextType !== void 0;
      if (_nextType)
        flags |= 2;
      var _timeout = v.timeout !== void 0;
      if (_timeout)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "type"));
      w.string(h(v, "phoneCodeHash"));
      if (_nextType)
        w.object(v.nextType);
      if (_timeout)
        w.int(v.timeout);
    },
    "auth.sentCodeSuccess": function(w, v) {
      w.uint(596704836);
      w.object(h(v, "authorization"));
    },
    "auth.authorization": function(w, v) {
      w.uint(782418132);
      var flags = 0;
      var _tmpSessions = v.tmpSessions !== void 0;
      if (_tmpSessions)
        flags |= 1;
      var _otherwiseReloginDays = v.otherwiseReloginDays !== void 0;
      var _flags_1 = v.setupPasswordRequired === true || _otherwiseReloginDays;
      if (_flags_1)
        flags |= 2;
      var _futureAuthToken = v.futureAuthToken !== void 0;
      if (_futureAuthToken)
        flags |= 4;
      w.uint(flags);
      if (_flags_1)
        w.int(v.otherwiseReloginDays);
      if (_tmpSessions)
        w.int(v.tmpSessions);
      if (_futureAuthToken)
        w.bytes(v.futureAuthToken);
      w.object(h(v, "user"));
    },
    "auth.authorizationSignUpRequired": function(w, v) {
      w.uint(1148485274);
      var flags = 0;
      var _termsOfService = v.termsOfService !== void 0;
      if (_termsOfService)
        flags |= 1;
      w.uint(flags);
      if (_termsOfService)
        w.object(v.termsOfService);
    },
    "auth.exportedAuthorization": function(w, v) {
      w.uint(3023364792);
      w.long(h(v, "id"));
      w.bytes(h(v, "bytes"));
    },
    "inputNotifyPeer": function(w, v) {
      w.uint(3099351820);
      w.object(h(v, "peer"));
    },
    "inputNotifyUsers": function(w) {
      w.uint(423314455);
    },
    "inputNotifyChats": function(w) {
      w.uint(1251338318);
    },
    "inputNotifyBroadcasts": function(w) {
      w.uint(2983951486);
    },
    "inputNotifyForumTopic": function(w, v) {
      w.uint(1548122514);
      w.object(h(v, "peer"));
      w.int(h(v, "topMsgId"));
    },
    "inputPeerNotifySettings": function(w, v) {
      w.uint(3402328802);
      var flags = 0;
      var _showPreviews = v.showPreviews !== void 0;
      if (_showPreviews)
        flags |= 1;
      var _silent = v.silent !== void 0;
      if (_silent)
        flags |= 2;
      var _muteUntil = v.muteUntil !== void 0;
      if (_muteUntil)
        flags |= 4;
      var _sound = v.sound !== void 0;
      if (_sound)
        flags |= 8;
      var _storiesMuted = v.storiesMuted !== void 0;
      if (_storiesMuted)
        flags |= 64;
      var _storiesHideSender = v.storiesHideSender !== void 0;
      if (_storiesHideSender)
        flags |= 128;
      var _storiesSound = v.storiesSound !== void 0;
      if (_storiesSound)
        flags |= 256;
      w.uint(flags);
      if (_showPreviews)
        w.boolean(v.showPreviews);
      if (_silent)
        w.boolean(v.silent);
      if (_muteUntil)
        w.int(v.muteUntil);
      if (_sound)
        w.object(v.sound);
      if (_storiesMuted)
        w.boolean(v.storiesMuted);
      if (_storiesHideSender)
        w.boolean(v.storiesHideSender);
      if (_storiesSound)
        w.object(v.storiesSound);
    },
    "peerNotifySettings": function(w, v) {
      w.uint(2573347852);
      var flags = 0;
      var _showPreviews = v.showPreviews !== void 0;
      if (_showPreviews)
        flags |= 1;
      var _silent = v.silent !== void 0;
      if (_silent)
        flags |= 2;
      var _muteUntil = v.muteUntil !== void 0;
      if (_muteUntil)
        flags |= 4;
      var _iosSound = v.iosSound !== void 0;
      if (_iosSound)
        flags |= 8;
      var _androidSound = v.androidSound !== void 0;
      if (_androidSound)
        flags |= 16;
      var _otherSound = v.otherSound !== void 0;
      if (_otherSound)
        flags |= 32;
      var _storiesMuted = v.storiesMuted !== void 0;
      if (_storiesMuted)
        flags |= 64;
      var _storiesHideSender = v.storiesHideSender !== void 0;
      if (_storiesHideSender)
        flags |= 128;
      var _storiesIosSound = v.storiesIosSound !== void 0;
      if (_storiesIosSound)
        flags |= 256;
      var _storiesAndroidSound = v.storiesAndroidSound !== void 0;
      if (_storiesAndroidSound)
        flags |= 512;
      var _storiesOtherSound = v.storiesOtherSound !== void 0;
      if (_storiesOtherSound)
        flags |= 1024;
      w.uint(flags);
      if (_showPreviews)
        w.boolean(v.showPreviews);
      if (_silent)
        w.boolean(v.silent);
      if (_muteUntil)
        w.int(v.muteUntil);
      if (_iosSound)
        w.object(v.iosSound);
      if (_androidSound)
        w.object(v.androidSound);
      if (_otherSound)
        w.object(v.otherSound);
      if (_storiesMuted)
        w.boolean(v.storiesMuted);
      if (_storiesHideSender)
        w.boolean(v.storiesHideSender);
      if (_storiesIosSound)
        w.object(v.storiesIosSound);
      if (_storiesAndroidSound)
        w.object(v.storiesAndroidSound);
      if (_storiesOtherSound)
        w.object(v.storiesOtherSound);
    },
    "peerSettings": function(w, v) {
      w.uint(2899733598);
      var flags = 0;
      if (v.reportSpam === true)
        flags |= 1;
      if (v.addContact === true)
        flags |= 2;
      if (v.blockContact === true)
        flags |= 4;
      if (v.shareContact === true)
        flags |= 8;
      if (v.needContactsException === true)
        flags |= 16;
      if (v.reportGeo === true)
        flags |= 32;
      var _geoDistance = v.geoDistance !== void 0;
      if (_geoDistance)
        flags |= 64;
      if (v.autoarchived === true)
        flags |= 128;
      if (v.inviteMembers === true)
        flags |= 256;
      var _requestChatTitle = v.requestChatTitle !== void 0;
      var _requestChatDate = v.requestChatDate !== void 0;
      var _flags_9 = _requestChatTitle || _requestChatDate;
      if (_flags_9)
        flags |= 512;
      if (v.requestChatBroadcast === true)
        flags |= 1024;
      if (v.businessBotPaused === true)
        flags |= 2048;
      if (v.businessBotCanReply === true)
        flags |= 4096;
      var _businessBotId = v.businessBotId !== void 0;
      var _businessBotManageUrl = v.businessBotManageUrl !== void 0;
      var _flags_13 = _businessBotId || _businessBotManageUrl;
      if (_flags_13)
        flags |= 8192;
      w.uint(flags);
      if (_geoDistance)
        w.int(v.geoDistance);
      if (_flags_9)
        w.string(v.requestChatTitle);
      if (_flags_9)
        w.int(v.requestChatDate);
      if (_flags_13)
        w.int53(v.businessBotId);
      if (_flags_13)
        w.string(v.businessBotManageUrl);
    },
    "wallPaper": function(w, v) {
      w.uint(2755118061);
      w.long(h(v, "id"));
      var flags = 0;
      if (v.creator === true)
        flags |= 1;
      if (v.default === true)
        flags |= 2;
      var _settings = v.settings !== void 0;
      if (_settings)
        flags |= 4;
      if (v.pattern === true)
        flags |= 8;
      if (v.dark === true)
        flags |= 16;
      w.uint(flags);
      w.long(h(v, "accessHash"));
      w.string(h(v, "slug"));
      w.object(h(v, "document"));
      if (_settings)
        w.object(v.settings);
    },
    "wallPaperNoFile": function(w, v) {
      w.uint(3766501654);
      w.long(h(v, "id"));
      var flags = 0;
      if (v.default === true)
        flags |= 2;
      var _settings = v.settings !== void 0;
      if (_settings)
        flags |= 4;
      if (v.dark === true)
        flags |= 16;
      w.uint(flags);
      if (_settings)
        w.object(v.settings);
    },
    "inputReportReasonSpam": function(w) {
      w.uint(1490799288);
    },
    "inputReportReasonViolence": function(w) {
      w.uint(505595789);
    },
    "inputReportReasonPornography": function(w) {
      w.uint(777640226);
    },
    "inputReportReasonChildAbuse": function(w) {
      w.uint(2918469347);
    },
    "inputReportReasonOther": function(w) {
      w.uint(3252986545);
    },
    "inputReportReasonCopyright": function(w) {
      w.uint(2609510714);
    },
    "inputReportReasonGeoIrrelevant": function(w) {
      w.uint(3688169197);
    },
    "inputReportReasonFake": function(w) {
      w.uint(4124956391);
    },
    "inputReportReasonIllegalDrugs": function(w) {
      w.uint(177124030);
    },
    "inputReportReasonPersonalDetails": function(w) {
      w.uint(2663876157);
    },
    "userFull": function(w, v) {
      w.uint(525919081);
      var flags = 0;
      if (v.blocked === true)
        flags |= 1;
      var _about = v.about !== void 0;
      if (_about)
        flags |= 2;
      var _profilePhoto = v.profilePhoto !== void 0;
      if (_profilePhoto)
        flags |= 4;
      var _botInfo = v.botInfo !== void 0;
      if (_botInfo)
        flags |= 8;
      if (v.phoneCallsAvailable === true)
        flags |= 16;
      if (v.phoneCallsPrivate === true)
        flags |= 32;
      var _pinnedMsgId = v.pinnedMsgId !== void 0;
      if (_pinnedMsgId)
        flags |= 64;
      if (v.canPinMessage === true)
        flags |= 128;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 2048;
      if (v.hasScheduled === true)
        flags |= 4096;
      if (v.videoCallsAvailable === true)
        flags |= 8192;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 16384;
      var _themeEmoticon = v.themeEmoticon !== void 0;
      if (_themeEmoticon)
        flags |= 32768;
      var _privateForwardName = v.privateForwardName !== void 0;
      if (_privateForwardName)
        flags |= 65536;
      var _botGroupAdminRights = v.botGroupAdminRights !== void 0;
      if (_botGroupAdminRights)
        flags |= 131072;
      var _botBroadcastAdminRights = v.botBroadcastAdminRights !== void 0;
      if (_botBroadcastAdminRights)
        flags |= 262144;
      var _premiumGifts = v.premiumGifts && v.premiumGifts.length;
      if (_premiumGifts)
        flags |= 524288;
      if (v.voiceMessagesForbidden === true)
        flags |= 1048576;
      var _personalPhoto = v.personalPhoto !== void 0;
      if (_personalPhoto)
        flags |= 2097152;
      var _fallbackPhoto = v.fallbackPhoto !== void 0;
      if (_fallbackPhoto)
        flags |= 4194304;
      if (v.translationsDisabled === true)
        flags |= 8388608;
      var _wallpaper = v.wallpaper !== void 0;
      if (_wallpaper)
        flags |= 16777216;
      var _stories = v.stories !== void 0;
      if (_stories)
        flags |= 33554432;
      if (v.storiesPinnedAvailable === true)
        flags |= 67108864;
      if (v.blockedMyStoriesFrom === true)
        flags |= 134217728;
      if (v.wallpaperOverridden === true)
        flags |= 268435456;
      if (v.contactRequirePremium === true)
        flags |= 536870912;
      if (v.readDatesPrivate === true)
        flags |= 1073741824;
      w.uint(flags);
      var flags2 = 0;
      var _businessWorkHours = v.businessWorkHours !== void 0;
      if (_businessWorkHours)
        flags2 |= 1;
      var _businessLocation = v.businessLocation !== void 0;
      if (_businessLocation)
        flags2 |= 2;
      var _businessGreetingMessage = v.businessGreetingMessage !== void 0;
      if (_businessGreetingMessage)
        flags2 |= 4;
      var _businessAwayMessage = v.businessAwayMessage !== void 0;
      if (_businessAwayMessage)
        flags2 |= 8;
      var _businessIntro = v.businessIntro !== void 0;
      if (_businessIntro)
        flags2 |= 16;
      var _birthday = v.birthday !== void 0;
      if (_birthday)
        flags2 |= 32;
      var _personalChannelId = v.personalChannelId !== void 0;
      var _personalChannelMessage = v.personalChannelMessage !== void 0;
      var _flags2_6 = _personalChannelId || _personalChannelMessage;
      if (_flags2_6)
        flags2 |= 64;
      if (v.sponsoredEnabled === true)
        flags2 |= 128;
      var _stargiftsCount = v.stargiftsCount !== void 0;
      if (_stargiftsCount)
        flags2 |= 256;
      w.uint(flags2);
      w.int53(h(v, "id"));
      if (_about)
        w.string(v.about);
      w.object(h(v, "settings"));
      if (_personalPhoto)
        w.object(v.personalPhoto);
      if (_profilePhoto)
        w.object(v.profilePhoto);
      if (_fallbackPhoto)
        w.object(v.fallbackPhoto);
      w.object(h(v, "notifySettings"));
      if (_botInfo)
        w.object(v.botInfo);
      if (_pinnedMsgId)
        w.int(v.pinnedMsgId);
      w.int(h(v, "commonChatsCount"));
      if (_folderId)
        w.int(v.folderId);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
      if (_themeEmoticon)
        w.string(v.themeEmoticon);
      if (_privateForwardName)
        w.string(v.privateForwardName);
      if (_botGroupAdminRights)
        w.object(v.botGroupAdminRights);
      if (_botBroadcastAdminRights)
        w.object(v.botBroadcastAdminRights);
      if (_premiumGifts)
        w.vector(w.object, v.premiumGifts);
      if (_wallpaper)
        w.object(v.wallpaper);
      if (_stories)
        w.object(v.stories);
      if (_businessWorkHours)
        w.object(v.businessWorkHours);
      if (_businessLocation)
        w.object(v.businessLocation);
      if (_businessGreetingMessage)
        w.object(v.businessGreetingMessage);
      if (_businessAwayMessage)
        w.object(v.businessAwayMessage);
      if (_businessIntro)
        w.object(v.businessIntro);
      if (_birthday)
        w.object(v.birthday);
      if (_flags2_6)
        w.int53(v.personalChannelId);
      if (_flags2_6)
        w.int(v.personalChannelMessage);
      if (_stargiftsCount)
        w.int(v.stargiftsCount);
    },
    "contact": function(w, v) {
      w.uint(341499403);
      w.int53(h(v, "userId"));
      w.boolean(h(v, "mutual"));
    },
    "importedContact": function(w, v) {
      w.uint(3242081360);
      w.int53(h(v, "userId"));
      w.long(h(v, "clientId"));
    },
    "contactStatus": function(w, v) {
      w.uint(383348795);
      w.int53(h(v, "userId"));
      w.object(h(v, "status"));
    },
    "contacts.contactsNotModified": function(w) {
      w.uint(3075189202);
    },
    "contacts.contacts": function(w, v) {
      w.uint(3941105218);
      w.vector(w.object, h(v, "contacts"));
      w.int(h(v, "savedCount"));
      w.vector(w.object, h(v, "users"));
    },
    "contacts.importedContacts": function(w, v) {
      w.uint(2010127419);
      w.vector(w.object, h(v, "imported"));
      w.vector(w.object, h(v, "popularInvites"));
      w.vector(w.long, h(v, "retryContacts"));
      w.vector(w.object, h(v, "users"));
    },
    "contacts.blocked": function(w, v) {
      w.uint(182326673);
      w.vector(w.object, h(v, "blocked"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "contacts.blockedSlice": function(w, v) {
      w.uint(3781575060);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "blocked"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.dialogs": function(w, v) {
      w.uint(364538944);
      w.vector(w.object, h(v, "dialogs"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.dialogsSlice": function(w, v) {
      w.uint(1910543603);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "dialogs"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.dialogsNotModified": function(w, v) {
      w.uint(4041467286);
      w.int(h(v, "count"));
    },
    "messages.messages": function(w, v) {
      w.uint(2356252295);
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.messagesSlice": function(w, v) {
      w.uint(978610270);
      var flags = 0;
      var _nextRate = v.nextRate !== void 0;
      if (_nextRate)
        flags |= 1;
      if (v.inexact === true)
        flags |= 2;
      var _offsetIdOffset = v.offsetIdOffset !== void 0;
      if (_offsetIdOffset)
        flags |= 4;
      w.uint(flags);
      w.int(h(v, "count"));
      if (_nextRate)
        w.int(v.nextRate);
      if (_offsetIdOffset)
        w.int(v.offsetIdOffset);
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.channelMessages": function(w, v) {
      w.uint(3346446926);
      var flags = 0;
      if (v.inexact === true)
        flags |= 2;
      var _offsetIdOffset = v.offsetIdOffset !== void 0;
      if (_offsetIdOffset)
        flags |= 4;
      w.uint(flags);
      w.int(h(v, "pts"));
      w.int(h(v, "count"));
      if (_offsetIdOffset)
        w.int(v.offsetIdOffset);
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "topics"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.messagesNotModified": function(w, v) {
      w.uint(1951620897);
      w.int(h(v, "count"));
    },
    "messages.chats": function(w, v) {
      w.uint(1694474197);
      w.vector(w.object, h(v, "chats"));
    },
    "messages.chatsSlice": function(w, v) {
      w.uint(2631405892);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "chats"));
    },
    "messages.chatFull": function(w, v) {
      w.uint(3856126364);
      w.object(h(v, "fullChat"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.affectedHistory": function(w, v) {
      w.uint(3025955281);
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
      w.int(h(v, "offset"));
    },
    "inputMessagesFilterEmpty": function(w) {
      w.uint(1474492012);
    },
    "inputMessagesFilterPhotos": function(w) {
      w.uint(2517214492);
    },
    "inputMessagesFilterVideo": function(w) {
      w.uint(2680163941);
    },
    "inputMessagesFilterPhotoVideo": function(w) {
      w.uint(1458172132);
    },
    "inputMessagesFilterDocument": function(w) {
      w.uint(2665345416);
    },
    "inputMessagesFilterUrl": function(w) {
      w.uint(2129714567);
    },
    "inputMessagesFilterGif": function(w) {
      w.uint(4291323271);
    },
    "inputMessagesFilterVoice": function(w) {
      w.uint(1358283666);
    },
    "inputMessagesFilterMusic": function(w) {
      w.uint(928101534);
    },
    "inputMessagesFilterChatPhotos": function(w) {
      w.uint(975236280);
    },
    "inputMessagesFilterPhoneCalls": function(w, v) {
      w.uint(2160695144);
      var flags = 0;
      if (v.missed === true)
        flags |= 1;
      w.uint(flags);
    },
    "inputMessagesFilterRoundVoice": function(w) {
      w.uint(2054952868);
    },
    "inputMessagesFilterRoundVideo": function(w) {
      w.uint(3041516115);
    },
    "inputMessagesFilterMyMentions": function(w) {
      w.uint(3254314650);
    },
    "inputMessagesFilterGeo": function(w) {
      w.uint(3875695885);
    },
    "inputMessagesFilterContacts": function(w) {
      w.uint(3764575107);
    },
    "inputMessagesFilterPinned": function(w) {
      w.uint(464520273);
    },
    "updateNewMessage": function(w, v) {
      w.uint(522914557);
      w.object(h(v, "message"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateMessageID": function(w, v) {
      w.uint(1318109142);
      w.int(h(v, "id"));
      w.long(h(v, "randomId"));
    },
    "updateDeleteMessages": function(w, v) {
      w.uint(2718806245);
      w.vector(w.int, h(v, "messages"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateUserTyping": function(w, v) {
      w.uint(3223225727);
      w.int53(h(v, "userId"));
      w.object(h(v, "action"));
    },
    "updateChatUserTyping": function(w, v) {
      w.uint(2202565360);
      w.int53(h(v, "chatId"));
      w.object(h(v, "fromId"));
      w.object(h(v, "action"));
    },
    "updateChatParticipants": function(w, v) {
      w.uint(125178264);
      w.object(h(v, "participants"));
    },
    "updateUserStatus": function(w, v) {
      w.uint(3854432478);
      w.int53(h(v, "userId"));
      w.object(h(v, "status"));
    },
    "updateUserName": function(w, v) {
      w.uint(2810480932);
      w.int53(h(v, "userId"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
      w.vector(w.object, h(v, "usernames"));
    },
    "updateNewAuthorization": function(w, v) {
      w.uint(2303831023);
      var flags = 0;
      var _date = v.date !== void 0;
      var _device = v.device !== void 0;
      var _location = v.location !== void 0;
      var _flags_0 = v.unconfirmed === true || _date || _device || _location;
      if (_flags_0)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "hash"));
      if (_flags_0)
        w.int(v.date);
      if (_flags_0)
        w.string(v.device);
      if (_flags_0)
        w.string(v.location);
    },
    "updateNewEncryptedMessage": function(w, v) {
      w.uint(314359194);
      w.object(h(v, "message"));
      w.int(h(v, "qts"));
    },
    "updateEncryptedChatTyping": function(w, v) {
      w.uint(386986326);
      w.int(h(v, "chatId"));
    },
    "updateEncryption": function(w, v) {
      w.uint(3030575245);
      w.object(h(v, "chat"));
      w.int(h(v, "date"));
    },
    "updateEncryptedMessagesRead": function(w, v) {
      w.uint(956179895);
      w.int(h(v, "chatId"));
      w.int(h(v, "maxDate"));
      w.int(h(v, "date"));
    },
    "updateChatParticipantAdd": function(w, v) {
      w.uint(1037718609);
      w.int53(h(v, "chatId"));
      w.int53(h(v, "userId"));
      w.int53(h(v, "inviterId"));
      w.int(h(v, "date"));
      w.int(h(v, "version"));
    },
    "updateChatParticipantDelete": function(w, v) {
      w.uint(3811523959);
      w.int53(h(v, "chatId"));
      w.int53(h(v, "userId"));
      w.int(h(v, "version"));
    },
    "updateDcOptions": function(w, v) {
      w.uint(2388564083);
      w.vector(w.object, h(v, "dcOptions"));
    },
    "updateNotifySettings": function(w, v) {
      w.uint(3200411887);
      w.object(h(v, "peer"));
      w.object(h(v, "notifySettings"));
    },
    "updateServiceNotification": function(w, v) {
      w.uint(3957614617);
      var flags = 0;
      if (v.popup === true)
        flags |= 1;
      var _inboxDate = v.inboxDate !== void 0;
      if (_inboxDate)
        flags |= 2;
      if (v.invertMedia === true)
        flags |= 4;
      w.uint(flags);
      if (_inboxDate)
        w.int(v.inboxDate);
      w.string(h(v, "type"));
      w.string(h(v, "message"));
      w.object(h(v, "media"));
      w.vector(w.object, h(v, "entities"));
    },
    "updatePrivacy": function(w, v) {
      w.uint(3996854058);
      w.object(h(v, "key"));
      w.vector(w.object, h(v, "rules"));
    },
    "updateUserPhone": function(w, v) {
      w.uint(88680979);
      w.int53(h(v, "userId"));
      w.string(h(v, "phone"));
    },
    "updateReadHistoryInbox": function(w, v) {
      w.uint(2627162079);
      var flags = 0;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 1;
      w.uint(flags);
      if (_folderId)
        w.int(v.folderId);
      w.object(h(v, "peer"));
      w.int(h(v, "maxId"));
      w.int(h(v, "stillUnreadCount"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateReadHistoryOutbox": function(w, v) {
      w.uint(791617983);
      w.object(h(v, "peer"));
      w.int(h(v, "maxId"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateWebPage": function(w, v) {
      w.uint(2139689491);
      w.object(h(v, "webpage"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateReadMessagesContents": function(w, v) {
      w.uint(4163006849);
      var flags = 0;
      var _date = v.date !== void 0;
      if (_date)
        flags |= 1;
      w.uint(flags);
      w.vector(w.int, h(v, "messages"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
      if (_date)
        w.int(v.date);
    },
    "updateChannelTooLong": function(w, v) {
      w.uint(277713951);
      var flags = 0;
      var _pts = v.pts !== void 0;
      if (_pts)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      if (_pts)
        w.int(v.pts);
    },
    "updateChannel": function(w, v) {
      w.uint(1666927625);
      w.int53(h(v, "channelId"));
    },
    "updateNewChannelMessage": function(w, v) {
      w.uint(1656358105);
      w.object(h(v, "message"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateReadChannelInbox": function(w, v) {
      w.uint(2452516368);
      var flags = 0;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 1;
      w.uint(flags);
      if (_folderId)
        w.int(v.folderId);
      w.int53(h(v, "channelId"));
      w.int(h(v, "maxId"));
      w.int(h(v, "stillUnreadCount"));
      w.int(h(v, "pts"));
    },
    "updateDeleteChannelMessages": function(w, v) {
      w.uint(3274529554);
      w.int53(h(v, "channelId"));
      w.vector(w.int, h(v, "messages"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateChannelMessageViews": function(w, v) {
      w.uint(4062620680);
      w.int53(h(v, "channelId"));
      w.int(h(v, "id"));
      w.int(h(v, "views"));
    },
    "updateChatParticipantAdmin": function(w, v) {
      w.uint(3620364706);
      w.int53(h(v, "chatId"));
      w.int53(h(v, "userId"));
      w.boolean(h(v, "isAdmin"));
      w.int(h(v, "version"));
    },
    "updateNewStickerSet": function(w, v) {
      w.uint(1753886890);
      w.object(h(v, "stickerset"));
    },
    "updateStickerSetsOrder": function(w, v) {
      w.uint(196268545);
      var flags = 0;
      if (v.masks === true)
        flags |= 1;
      if (v.emojis === true)
        flags |= 2;
      w.uint(flags);
      w.vector(w.long, h(v, "order"));
    },
    "updateStickerSets": function(w, v) {
      w.uint(834816008);
      var flags = 0;
      if (v.masks === true)
        flags |= 1;
      if (v.emojis === true)
        flags |= 2;
      w.uint(flags);
    },
    "updateSavedGifs": function(w) {
      w.uint(2473931806);
    },
    "updateBotInlineQuery": function(w, v) {
      w.uint(1232025500);
      var flags = 0;
      var _geo = v.geo !== void 0;
      if (_geo)
        flags |= 1;
      var _peerType = v.peerType !== void 0;
      if (_peerType)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "queryId"));
      w.int53(h(v, "userId"));
      w.string(h(v, "query"));
      if (_geo)
        w.object(v.geo);
      if (_peerType)
        w.object(v.peerType);
      w.string(h(v, "offset"));
    },
    "updateBotInlineSend": function(w, v) {
      w.uint(317794823);
      var flags = 0;
      var _geo = v.geo !== void 0;
      if (_geo)
        flags |= 1;
      var _msgId = v.msgId !== void 0;
      if (_msgId)
        flags |= 2;
      w.uint(flags);
      w.int53(h(v, "userId"));
      w.string(h(v, "query"));
      if (_geo)
        w.object(v.geo);
      w.string(h(v, "id"));
      if (_msgId)
        w.object(v.msgId);
    },
    "updateEditChannelMessage": function(w, v) {
      w.uint(457133559);
      w.object(h(v, "message"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateBotCallbackQuery": function(w, v) {
      w.uint(3117401229);
      var flags = 0;
      var _data = v.data !== void 0;
      if (_data)
        flags |= 1;
      var _gameShortName = v.gameShortName !== void 0;
      if (_gameShortName)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "queryId"));
      w.int53(h(v, "userId"));
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.long(h(v, "chatInstance"));
      if (_data)
        w.bytes(v.data);
      if (_gameShortName)
        w.string(v.gameShortName);
    },
    "updateEditMessage": function(w, v) {
      w.uint(3825430691);
      w.object(h(v, "message"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateInlineBotCallbackQuery": function(w, v) {
      w.uint(1763610706);
      var flags = 0;
      var _data = v.data !== void 0;
      if (_data)
        flags |= 1;
      var _gameShortName = v.gameShortName !== void 0;
      if (_gameShortName)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "queryId"));
      w.int53(h(v, "userId"));
      w.object(h(v, "msgId"));
      w.long(h(v, "chatInstance"));
      if (_data)
        w.bytes(v.data);
      if (_gameShortName)
        w.string(v.gameShortName);
    },
    "updateReadChannelOutbox": function(w, v) {
      w.uint(3076495785);
      w.int53(h(v, "channelId"));
      w.int(h(v, "maxId"));
    },
    "updateDraftMessage": function(w, v) {
      w.uint(457829485);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_topMsgId)
        w.int(v.topMsgId);
      w.object(h(v, "draft"));
    },
    "updateReadFeaturedStickers": function(w) {
      w.uint(1461528386);
    },
    "updateRecentStickers": function(w) {
      w.uint(2588027936);
    },
    "updateConfig": function(w) {
      w.uint(2720652550);
    },
    "updatePtsChanged": function(w) {
      w.uint(861169551);
    },
    "updateChannelWebPage": function(w, v) {
      w.uint(791390623);
      w.int53(h(v, "channelId"));
      w.object(h(v, "webpage"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateDialogPinned": function(w, v) {
      w.uint(1852826908);
      var flags = 0;
      if (v.pinned === true)
        flags |= 1;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 2;
      w.uint(flags);
      if (_folderId)
        w.int(v.folderId);
      w.object(h(v, "peer"));
    },
    "updatePinnedDialogs": function(w, v) {
      w.uint(4195302562);
      var flags = 0;
      var _order = v.order && v.order.length;
      if (_order)
        flags |= 1;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 2;
      w.uint(flags);
      if (_folderId)
        w.int(v.folderId);
      if (_order)
        w.vector(w.object, v.order);
    },
    "updateBotWebhookJSON": function(w, v) {
      w.uint(2199371971);
      w.object(h(v, "data"));
    },
    "updateBotWebhookJSONQuery": function(w, v) {
      w.uint(2610053286);
      w.long(h(v, "queryId"));
      w.object(h(v, "data"));
      w.int(h(v, "timeout"));
    },
    "updateBotShippingQuery": function(w, v) {
      w.uint(3048144253);
      w.long(h(v, "queryId"));
      w.int53(h(v, "userId"));
      w.bytes(h(v, "payload"));
      w.object(h(v, "shippingAddress"));
    },
    "updateBotPrecheckoutQuery": function(w, v) {
      w.uint(2359990934);
      var flags = 0;
      var _info = v.info !== void 0;
      if (_info)
        flags |= 1;
      var _shippingOptionId = v.shippingOptionId !== void 0;
      if (_shippingOptionId)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "queryId"));
      w.int53(h(v, "userId"));
      w.bytes(h(v, "payload"));
      if (_info)
        w.object(v.info);
      if (_shippingOptionId)
        w.string(v.shippingOptionId);
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
    },
    "updatePhoneCall": function(w, v) {
      w.uint(2869914398);
      w.object(h(v, "phoneCall"));
    },
    "updateLangPackTooLong": function(w, v) {
      w.uint(1180041828);
      w.string(h(v, "langCode"));
    },
    "updateLangPack": function(w, v) {
      w.uint(1442983757);
      w.object(h(v, "difference"));
    },
    "updateFavedStickers": function(w) {
      w.uint(3843135853);
    },
    "updateChannelReadMessagesContents": function(w, v) {
      w.uint(3928556893);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      if (_topMsgId)
        w.int(v.topMsgId);
      w.vector(w.int, h(v, "messages"));
    },
    "updateContactsReset": function(w) {
      w.uint(1887741886);
    },
    "updateChannelAvailableMessages": function(w, v) {
      w.uint(2990524056);
      w.int53(h(v, "channelId"));
      w.int(h(v, "availableMinId"));
    },
    "updateDialogUnreadMark": function(w, v) {
      w.uint(3781450179);
      var flags = 0;
      if (v.unread === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "updateMessagePoll": function(w, v) {
      w.uint(2896258427);
      var flags = 0;
      var _poll = v.poll !== void 0;
      if (_poll)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "pollId"));
      if (_poll)
        w.object(v.poll);
      w.object(h(v, "results"));
    },
    "updateChatDefaultBannedRights": function(w, v) {
      w.uint(1421875280);
      w.object(h(v, "peer"));
      w.object(h(v, "defaultBannedRights"));
      w.int(h(v, "version"));
    },
    "updateFolderPeers": function(w, v) {
      w.uint(422972864);
      w.vector(w.object, h(v, "folderPeers"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updatePeerSettings": function(w, v) {
      w.uint(1786671974);
      w.object(h(v, "peer"));
      w.object(h(v, "settings"));
    },
    "updatePeerLocated": function(w, v) {
      w.uint(3031420848);
      w.vector(w.object, h(v, "peers"));
    },
    "updateNewScheduledMessage": function(w, v) {
      w.uint(967122427);
      w.object(h(v, "message"));
    },
    "updateDeleteScheduledMessages": function(w, v) {
      w.uint(2424728814);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "messages"));
    },
    "updateTheme": function(w, v) {
      w.uint(2182544291);
      w.object(h(v, "theme"));
    },
    "updateGeoLiveViewed": function(w, v) {
      w.uint(2267003193);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "updateLoginToken": function(w) {
      w.uint(1448076945);
    },
    "updateMessagePollVote": function(w, v) {
      w.uint(619974263);
      w.long(h(v, "pollId"));
      w.object(h(v, "peer"));
      w.vector(w.bytes, h(v, "options"));
      w.int(h(v, "qts"));
    },
    "updateDialogFilter": function(w, v) {
      w.uint(654302845);
      var flags = 0;
      var _filter = v.filter !== void 0;
      if (_filter)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "id"));
      if (_filter)
        w.object(v.filter);
    },
    "updateDialogFilterOrder": function(w, v) {
      w.uint(2782339333);
      w.vector(w.int, h(v, "order"));
    },
    "updateDialogFilters": function(w) {
      w.uint(889491791);
    },
    "updatePhoneCallSignalingData": function(w, v) {
      w.uint(643940105);
      w.long(h(v, "phoneCallId"));
      w.bytes(h(v, "data"));
    },
    "updateChannelMessageForwards": function(w, v) {
      w.uint(3533318132);
      w.int53(h(v, "channelId"));
      w.int(h(v, "id"));
      w.int(h(v, "forwards"));
    },
    "updateReadChannelDiscussionInbox": function(w, v) {
      w.uint(3601962310);
      var flags = 0;
      var _broadcastId = v.broadcastId !== void 0;
      var _broadcastPost = v.broadcastPost !== void 0;
      var _flags_0 = _broadcastId || _broadcastPost;
      if (_flags_0)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      w.int(h(v, "topMsgId"));
      w.int(h(v, "readMaxId"));
      if (_flags_0)
        w.int53(v.broadcastId);
      if (_flags_0)
        w.int(v.broadcastPost);
    },
    "updateReadChannelDiscussionOutbox": function(w, v) {
      w.uint(1767677564);
      w.int53(h(v, "channelId"));
      w.int(h(v, "topMsgId"));
      w.int(h(v, "readMaxId"));
    },
    "updatePeerBlocked": function(w, v) {
      w.uint(3957356370);
      var flags = 0;
      if (v.blocked === true)
        flags |= 1;
      if (v.blockedMyStoriesFrom === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peerId"));
    },
    "updateChannelUserTyping": function(w, v) {
      w.uint(2357774627);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      if (_topMsgId)
        w.int(v.topMsgId);
      w.object(h(v, "fromId"));
      w.object(h(v, "action"));
    },
    "updatePinnedMessages": function(w, v) {
      w.uint(3984976565);
      var flags = 0;
      if (v.pinned === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "messages"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updatePinnedChannelMessages": function(w, v) {
      w.uint(1538885128);
      var flags = 0;
      if (v.pinned === true)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      w.vector(w.int, h(v, "messages"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "updateChat": function(w, v) {
      w.uint(4170869326);
      w.int53(h(v, "chatId"));
    },
    "updateGroupCallParticipants": function(w, v) {
      w.uint(4075543374);
      w.object(h(v, "call"));
      w.vector(w.object, h(v, "participants"));
      w.int(h(v, "version"));
    },
    "updateGroupCall": function(w, v) {
      w.uint(347227392);
      w.int53(h(v, "chatId"));
      w.object(h(v, "call"));
    },
    "updatePeerHistoryTTL": function(w, v) {
      w.uint(3147544997);
      var flags = 0;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "updateChatParticipant": function(w, v) {
      w.uint(3498534458);
      var flags = 0;
      var _prevParticipant = v.prevParticipant !== void 0;
      if (_prevParticipant)
        flags |= 1;
      var _newParticipant = v.newParticipant !== void 0;
      if (_newParticipant)
        flags |= 2;
      var _invite = v.invite !== void 0;
      if (_invite)
        flags |= 4;
      w.uint(flags);
      w.int53(h(v, "chatId"));
      w.int(h(v, "date"));
      w.int53(h(v, "actorId"));
      w.int53(h(v, "userId"));
      if (_prevParticipant)
        w.object(v.prevParticipant);
      if (_newParticipant)
        w.object(v.newParticipant);
      if (_invite)
        w.object(v.invite);
      w.int(h(v, "qts"));
    },
    "updateChannelParticipant": function(w, v) {
      w.uint(2556246715);
      var flags = 0;
      var _prevParticipant = v.prevParticipant !== void 0;
      if (_prevParticipant)
        flags |= 1;
      var _newParticipant = v.newParticipant !== void 0;
      if (_newParticipant)
        flags |= 2;
      var _invite = v.invite !== void 0;
      if (_invite)
        flags |= 4;
      if (v.viaChatlist === true)
        flags |= 8;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      w.int(h(v, "date"));
      w.int53(h(v, "actorId"));
      w.int53(h(v, "userId"));
      if (_prevParticipant)
        w.object(v.prevParticipant);
      if (_newParticipant)
        w.object(v.newParticipant);
      if (_invite)
        w.object(v.invite);
      w.int(h(v, "qts"));
    },
    "updateBotStopped": function(w, v) {
      w.uint(3297184329);
      w.int53(h(v, "userId"));
      w.int(h(v, "date"));
      w.boolean(h(v, "stopped"));
      w.int(h(v, "qts"));
    },
    "updateGroupCallConnection": function(w, v) {
      w.uint(192428418);
      var flags = 0;
      if (v.presentation === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "params"));
    },
    "updateBotCommands": function(w, v) {
      w.uint(1299263278);
      w.object(h(v, "peer"));
      w.int53(h(v, "botId"));
      w.vector(w.object, h(v, "commands"));
    },
    "updatePendingJoinRequests": function(w, v) {
      w.uint(1885586395);
      w.object(h(v, "peer"));
      w.int(h(v, "requestsPending"));
      w.vector(w.int53, h(v, "recentRequesters"));
    },
    "updateBotChatInviteRequester": function(w, v) {
      w.uint(299870598);
      w.object(h(v, "peer"));
      w.int(h(v, "date"));
      w.int53(h(v, "userId"));
      w.string(h(v, "about"));
      w.object(h(v, "invite"));
      w.int(h(v, "qts"));
    },
    "updateMessageReactions": function(w, v) {
      w.uint(1578843320);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      if (_topMsgId)
        w.int(v.topMsgId);
      w.object(h(v, "reactions"));
    },
    "updateAttachMenuBots": function(w) {
      w.uint(397910539);
    },
    "updateWebViewResultSent": function(w, v) {
      w.uint(361936797);
      w.long(h(v, "queryId"));
    },
    "updateBotMenuButton": function(w, v) {
      w.uint(347625491);
      w.int53(h(v, "botId"));
      w.object(h(v, "button"));
    },
    "updateSavedRingtones": function(w) {
      w.uint(1960361625);
    },
    "updateTranscribedAudio": function(w, v) {
      w.uint(8703322);
      var flags = 0;
      if (v.pending === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.long(h(v, "transcriptionId"));
      w.string(h(v, "text"));
    },
    "updateReadFeaturedEmojiStickers": function(w) {
      w.uint(4216080748);
    },
    "updateUserEmojiStatus": function(w, v) {
      w.uint(674706841);
      w.int53(h(v, "userId"));
      w.object(h(v, "emojiStatus"));
    },
    "updateRecentEmojiStatuses": function(w) {
      w.uint(821314523);
    },
    "updateRecentReactions": function(w) {
      w.uint(1870160884);
    },
    "updateMoveStickerSetToTop": function(w, v) {
      w.uint(2264715141);
      var flags = 0;
      if (v.masks === true)
        flags |= 1;
      if (v.emojis === true)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "stickerset"));
    },
    "updateMessageExtendedMedia": function(w, v) {
      w.uint(3584300836);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.vector(w.object, h(v, "extendedMedia"));
    },
    "updateChannelPinnedTopic": function(w, v) {
      w.uint(422509539);
      var flags = 0;
      if (v.pinned === true)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      w.int(h(v, "topicId"));
    },
    "updateChannelPinnedTopics": function(w, v) {
      w.uint(4263085570);
      var flags = 0;
      var _order = v.order && v.order.length;
      if (_order)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      if (_order)
        w.vector(w.int, v.order);
    },
    "updateUser": function(w, v) {
      w.uint(542282808);
      w.int53(h(v, "userId"));
    },
    "updateAutoSaveSettings": function(w) {
      w.uint(3959795863);
    },
    "updateStory": function(w, v) {
      w.uint(1974712216);
      w.object(h(v, "peer"));
      w.object(h(v, "story"));
    },
    "updateReadStories": function(w, v) {
      w.uint(4149121835);
      w.object(h(v, "peer"));
      w.int(h(v, "maxId"));
    },
    "updateStoryID": function(w, v) {
      w.uint(468923833);
      w.int(h(v, "id"));
      w.long(h(v, "randomId"));
    },
    "updateStoriesStealthMode": function(w, v) {
      w.uint(738741697);
      w.object(h(v, "stealthMode"));
    },
    "updateSentStoryReaction": function(w, v) {
      w.uint(2103604867);
      w.object(h(v, "peer"));
      w.int(h(v, "storyId"));
      w.object(h(v, "reaction"));
    },
    "updateBotChatBoost": function(w, v) {
      w.uint(2421019804);
      w.object(h(v, "peer"));
      w.object(h(v, "boost"));
      w.int(h(v, "qts"));
    },
    "updateChannelViewForumAsMessages": function(w, v) {
      w.uint(129403168);
      w.int53(h(v, "channelId"));
      w.boolean(h(v, "enabled"));
    },
    "updatePeerWallpaper": function(w, v) {
      w.uint(2923368477);
      var flags = 0;
      var _wallpaper = v.wallpaper !== void 0;
      if (_wallpaper)
        flags |= 1;
      if (v.wallpaperOverridden === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_wallpaper)
        w.object(v.wallpaper);
    },
    "updateBotMessageReaction": function(w, v) {
      w.uint(2887898062);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int(h(v, "date"));
      w.object(h(v, "actor"));
      w.vector(w.object, h(v, "oldReactions"));
      w.vector(w.object, h(v, "newReactions"));
      w.int(h(v, "qts"));
    },
    "updateBotMessageReactions": function(w, v) {
      w.uint(164329305);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int(h(v, "date"));
      w.vector(w.object, h(v, "reactions"));
      w.int(h(v, "qts"));
    },
    "updateSavedDialogPinned": function(w, v) {
      w.uint(2930744948);
      var flags = 0;
      if (v.pinned === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "updatePinnedSavedDialogs": function(w, v) {
      w.uint(1751942566);
      var flags = 0;
      var _order = v.order && v.order.length;
      if (_order)
        flags |= 1;
      w.uint(flags);
      if (_order)
        w.vector(w.object, v.order);
    },
    "updateSavedReactionTags": function(w) {
      w.uint(969307186);
    },
    "updateSmsJob": function(w, v) {
      w.uint(4049758676);
      w.string(h(v, "jobId"));
    },
    "updateQuickReplies": function(w, v) {
      w.uint(4182182578);
      w.vector(w.object, h(v, "quickReplies"));
    },
    "updateNewQuickReply": function(w, v) {
      w.uint(4114458391);
      w.object(h(v, "quickReply"));
    },
    "updateDeleteQuickReply": function(w, v) {
      w.uint(1407644140);
      w.int(h(v, "shortcutId"));
    },
    "updateQuickReplyMessage": function(w, v) {
      w.uint(1040518415);
      w.object(h(v, "message"));
    },
    "updateDeleteQuickReplyMessages": function(w, v) {
      w.uint(1450174413);
      w.int(h(v, "shortcutId"));
      w.vector(w.int, h(v, "messages"));
    },
    "updateBotBusinessConnect": function(w, v) {
      w.uint(2330315130);
      w.object(h(v, "connection"));
      w.int(h(v, "qts"));
    },
    "updateBotNewBusinessMessage": function(w, v) {
      w.uint(2648388732);
      var flags = 0;
      var _replyToMessage = v.replyToMessage !== void 0;
      if (_replyToMessage)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "connectionId"));
      w.object(h(v, "message"));
      if (_replyToMessage)
        w.object(v.replyToMessage);
      w.int(h(v, "qts"));
    },
    "updateBotEditBusinessMessage": function(w, v) {
      w.uint(132077692);
      var flags = 0;
      var _replyToMessage = v.replyToMessage !== void 0;
      if (_replyToMessage)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "connectionId"));
      w.object(h(v, "message"));
      if (_replyToMessage)
        w.object(v.replyToMessage);
      w.int(h(v, "qts"));
    },
    "updateBotDeleteBusinessMessage": function(w, v) {
      w.uint(2687146030);
      w.string(h(v, "connectionId"));
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "messages"));
      w.int(h(v, "qts"));
    },
    "updateNewStoryReaction": function(w, v) {
      w.uint(405070859);
      w.int(h(v, "storyId"));
      w.object(h(v, "peer"));
      w.object(h(v, "reaction"));
    },
    "updateBroadcastRevenueTransactions": function(w, v) {
      w.uint(3755565557);
      w.object(h(v, "peer"));
      w.object(h(v, "balances"));
    },
    "updateStarsBalance": function(w, v) {
      w.uint(263737752);
      w.long(h(v, "balance"));
    },
    "updateBusinessBotCallbackQuery": function(w, v) {
      w.uint(513998247);
      var flags = 0;
      var _data = v.data !== void 0;
      if (_data)
        flags |= 1;
      var _replyToMessage = v.replyToMessage !== void 0;
      if (_replyToMessage)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "queryId"));
      w.int53(h(v, "userId"));
      w.string(h(v, "connectionId"));
      w.object(h(v, "message"));
      if (_replyToMessage)
        w.object(v.replyToMessage);
      w.long(h(v, "chatInstance"));
      if (_data)
        w.bytes(v.data);
    },
    "updateStarsRevenueStatus": function(w, v) {
      w.uint(2776936473);
      w.object(h(v, "peer"));
      w.object(h(v, "status"));
    },
    "updateBotPurchasedPaidMedia": function(w, v) {
      w.uint(675009298);
      w.int53(h(v, "userId"));
      w.string(h(v, "payload"));
      w.int(h(v, "qts"));
    },
    "updatePaidReactionPrivacy": function(w, v) {
      w.uint(1372224236);
      w.boolean(h(v, "private"));
    },
    "updates.state": function(w, v) {
      w.uint(2775329342);
      w.int(h(v, "pts"));
      w.int(h(v, "qts"));
      w.int(h(v, "date"));
      w.int(h(v, "seq"));
      w.int(h(v, "unreadCount"));
    },
    "updates.differenceEmpty": function(w, v) {
      w.uint(1567990072);
      w.int(h(v, "date"));
      w.int(h(v, "seq"));
    },
    "updates.difference": function(w, v) {
      w.uint(16030880);
      w.vector(w.object, h(v, "newMessages"));
      w.vector(w.object, h(v, "newEncryptedMessages"));
      w.vector(w.object, h(v, "otherUpdates"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      w.object(h(v, "state"));
    },
    "updates.differenceSlice": function(w, v) {
      w.uint(2835028353);
      w.vector(w.object, h(v, "newMessages"));
      w.vector(w.object, h(v, "newEncryptedMessages"));
      w.vector(w.object, h(v, "otherUpdates"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      w.object(h(v, "intermediateState"));
    },
    "updates.differenceTooLong": function(w, v) {
      w.uint(1258196845);
      w.int(h(v, "pts"));
    },
    "updatesTooLong": function(w) {
      w.uint(3809980286);
    },
    "updateShortMessage": function(w, v) {
      w.uint(826001400);
      var flags = 0;
      if (v.out === true)
        flags |= 2;
      var _fwdFrom = v.fwdFrom !== void 0;
      if (_fwdFrom)
        flags |= 4;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 8;
      if (v.mentioned === true)
        flags |= 16;
      if (v.mediaUnread === true)
        flags |= 32;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 128;
      var _viaBotId = v.viaBotId !== void 0;
      if (_viaBotId)
        flags |= 2048;
      if (v.silent === true)
        flags |= 8192;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 33554432;
      w.uint(flags);
      w.int(h(v, "id"));
      w.int53(h(v, "userId"));
      w.string(h(v, "message"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
      w.int(h(v, "date"));
      if (_fwdFrom)
        w.object(v.fwdFrom);
      if (_viaBotId)
        w.int53(v.viaBotId);
      if (_replyTo)
        w.object(v.replyTo);
      if (_entities)
        w.vector(w.object, v.entities);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "updateShortChatMessage": function(w, v) {
      w.uint(1299050149);
      var flags = 0;
      if (v.out === true)
        flags |= 2;
      var _fwdFrom = v.fwdFrom !== void 0;
      if (_fwdFrom)
        flags |= 4;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 8;
      if (v.mentioned === true)
        flags |= 16;
      if (v.mediaUnread === true)
        flags |= 32;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 128;
      var _viaBotId = v.viaBotId !== void 0;
      if (_viaBotId)
        flags |= 2048;
      if (v.silent === true)
        flags |= 8192;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 33554432;
      w.uint(flags);
      w.int(h(v, "id"));
      w.int53(h(v, "fromId"));
      w.int53(h(v, "chatId"));
      w.string(h(v, "message"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
      w.int(h(v, "date"));
      if (_fwdFrom)
        w.object(v.fwdFrom);
      if (_viaBotId)
        w.int53(v.viaBotId);
      if (_replyTo)
        w.object(v.replyTo);
      if (_entities)
        w.vector(w.object, v.entities);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "updateShort": function(w, v) {
      w.uint(2027216577);
      w.object(h(v, "update"));
      w.int(h(v, "date"));
    },
    "updatesCombined": function(w, v) {
      w.uint(1918567619);
      w.vector(w.object, h(v, "updates"));
      w.vector(w.object, h(v, "users"));
      w.vector(w.object, h(v, "chats"));
      w.int(h(v, "date"));
      w.int(h(v, "seqStart"));
      w.int(h(v, "seq"));
    },
    "updates": function(w, v) {
      w.uint(1957577280);
      w.vector(w.object, h(v, "updates"));
      w.vector(w.object, h(v, "users"));
      w.vector(w.object, h(v, "chats"));
      w.int(h(v, "date"));
      w.int(h(v, "seq"));
    },
    "updateShortSentMessage": function(w, v) {
      w.uint(2417352961);
      var flags = 0;
      if (v.out === true)
        flags |= 2;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 128;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 512;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 33554432;
      w.uint(flags);
      w.int(h(v, "id"));
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
      w.int(h(v, "date"));
      if (_media)
        w.object(v.media);
      if (_entities)
        w.vector(w.object, v.entities);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "photos.photos": function(w, v) {
      w.uint(2378853029);
      w.vector(w.object, h(v, "photos"));
      w.vector(w.object, h(v, "users"));
    },
    "photos.photosSlice": function(w, v) {
      w.uint(352657236);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "photos"));
      w.vector(w.object, h(v, "users"));
    },
    "photos.photo": function(w, v) {
      w.uint(539045032);
      w.object(h(v, "photo"));
      w.vector(w.object, h(v, "users"));
    },
    "upload.file": function(w, v) {
      w.uint(157948117);
      w.object(h(v, "type"));
      w.int(h(v, "mtime"));
      w.bytes(h(v, "bytes"));
    },
    "upload.fileCdnRedirect": function(w, v) {
      w.uint(4052539972);
      w.int(h(v, "dcId"));
      w.bytes(h(v, "fileToken"));
      w.bytes(h(v, "encryptionKey"));
      w.bytes(h(v, "encryptionIv"));
      w.vector(w.object, h(v, "fileHashes"));
    },
    "dcOption": function(w, v) {
      w.uint(414687501);
      var flags = 0;
      if (v.ipv6 === true)
        flags |= 1;
      if (v.mediaOnly === true)
        flags |= 2;
      if (v.tcpoOnly === true)
        flags |= 4;
      if (v.cdn === true)
        flags |= 8;
      if (v.static === true)
        flags |= 16;
      if (v.thisPortOnly === true)
        flags |= 32;
      var _secret = v.secret !== void 0;
      if (_secret)
        flags |= 1024;
      w.uint(flags);
      w.int(h(v, "id"));
      w.string(h(v, "ipAddress"));
      w.int(h(v, "port"));
      if (_secret)
        w.bytes(v.secret);
    },
    "config": function(w, v) {
      w.uint(3424265246);
      var flags = 0;
      var _tmpSessions = v.tmpSessions !== void 0;
      if (_tmpSessions)
        flags |= 1;
      var _suggestedLangCode = v.suggestedLangCode !== void 0;
      var _langPackVersion = v.langPackVersion !== void 0;
      var _baseLangPackVersion = v.baseLangPackVersion !== void 0;
      var _flags_2 = _suggestedLangCode || _langPackVersion || _baseLangPackVersion;
      if (_flags_2)
        flags |= 4;
      if (v.defaultP2pContacts === true)
        flags |= 8;
      if (v.preloadFeaturedStickers === true)
        flags |= 16;
      if (v.revokePmInbox === true)
        flags |= 64;
      var _autoupdateUrlPrefix = v.autoupdateUrlPrefix !== void 0;
      if (_autoupdateUrlPrefix)
        flags |= 128;
      if (v.blockedMode === true)
        flags |= 256;
      var _gifSearchUsername = v.gifSearchUsername !== void 0;
      if (_gifSearchUsername)
        flags |= 512;
      var _venueSearchUsername = v.venueSearchUsername !== void 0;
      if (_venueSearchUsername)
        flags |= 1024;
      var _imgSearchUsername = v.imgSearchUsername !== void 0;
      if (_imgSearchUsername)
        flags |= 2048;
      var _staticMapsProvider = v.staticMapsProvider !== void 0;
      if (_staticMapsProvider)
        flags |= 4096;
      if (v.forceTryIpv6 === true)
        flags |= 16384;
      var _reactionsDefault = v.reactionsDefault !== void 0;
      if (_reactionsDefault)
        flags |= 32768;
      var _autologinToken = v.autologinToken !== void 0;
      if (_autologinToken)
        flags |= 65536;
      w.uint(flags);
      w.int(h(v, "date"));
      w.int(h(v, "expires"));
      w.boolean(h(v, "testMode"));
      w.int(h(v, "thisDc"));
      w.vector(w.object, h(v, "dcOptions"));
      w.string(h(v, "dcTxtDomainName"));
      w.int(h(v, "chatSizeMax"));
      w.int(h(v, "megagroupSizeMax"));
      w.int(h(v, "forwardedCountMax"));
      w.int(h(v, "onlineUpdatePeriodMs"));
      w.int(h(v, "offlineBlurTimeoutMs"));
      w.int(h(v, "offlineIdleTimeoutMs"));
      w.int(h(v, "onlineCloudTimeoutMs"));
      w.int(h(v, "notifyCloudDelayMs"));
      w.int(h(v, "notifyDefaultDelayMs"));
      w.int(h(v, "pushChatPeriodMs"));
      w.int(h(v, "pushChatLimit"));
      w.int(h(v, "editTimeLimit"));
      w.int(h(v, "revokeTimeLimit"));
      w.int(h(v, "revokePmTimeLimit"));
      w.int(h(v, "ratingEDecay"));
      w.int(h(v, "stickersRecentLimit"));
      w.int(h(v, "channelsReadMediaPeriod"));
      if (_tmpSessions)
        w.int(v.tmpSessions);
      w.int(h(v, "callReceiveTimeoutMs"));
      w.int(h(v, "callRingTimeoutMs"));
      w.int(h(v, "callConnectTimeoutMs"));
      w.int(h(v, "callPacketTimeoutMs"));
      w.string(h(v, "meUrlPrefix"));
      if (_autoupdateUrlPrefix)
        w.string(v.autoupdateUrlPrefix);
      if (_gifSearchUsername)
        w.string(v.gifSearchUsername);
      if (_venueSearchUsername)
        w.string(v.venueSearchUsername);
      if (_imgSearchUsername)
        w.string(v.imgSearchUsername);
      if (_staticMapsProvider)
        w.string(v.staticMapsProvider);
      w.int(h(v, "captionLengthMax"));
      w.int(h(v, "messageLengthMax"));
      w.int(h(v, "webfileDcId"));
      if (_flags_2)
        w.string(v.suggestedLangCode);
      if (_flags_2)
        w.int(v.langPackVersion);
      if (_flags_2)
        w.int(v.baseLangPackVersion);
      if (_reactionsDefault)
        w.object(v.reactionsDefault);
      if (_autologinToken)
        w.string(v.autologinToken);
    },
    "nearestDc": function(w, v) {
      w.uint(2384074613);
      w.string(h(v, "country"));
      w.int(h(v, "thisDc"));
      w.int(h(v, "nearestDc"));
    },
    "help.appUpdate": function(w, v) {
      w.uint(3434860080);
      var flags = 0;
      if (v.canNotSkip === true)
        flags |= 1;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 2;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 4;
      var _sticker = v.sticker !== void 0;
      if (_sticker)
        flags |= 8;
      w.uint(flags);
      w.int(h(v, "id"));
      w.string(h(v, "version"));
      w.string(h(v, "text"));
      w.vector(w.object, h(v, "entities"));
      if (_document)
        w.object(v.document);
      if (_url)
        w.string(v.url);
      if (_sticker)
        w.object(v.sticker);
    },
    "help.noAppUpdate": function(w) {
      w.uint(3294258486);
    },
    "help.inviteText": function(w, v) {
      w.uint(415997816);
      w.string(h(v, "message"));
    },
    "encryptedChatEmpty": function(w, v) {
      w.uint(2877210784);
      w.int(h(v, "id"));
    },
    "encryptedChatWaiting": function(w, v) {
      w.uint(1722964307);
      w.int(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "date"));
      w.int53(h(v, "adminId"));
      w.int53(h(v, "participantId"));
    },
    "encryptedChatRequested": function(w, v) {
      w.uint(1223809356);
      var flags = 0;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 1;
      w.uint(flags);
      if (_folderId)
        w.int(v.folderId);
      w.int(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "date"));
      w.int53(h(v, "adminId"));
      w.int53(h(v, "participantId"));
      w.bytes(h(v, "gA"));
    },
    "encryptedChat": function(w, v) {
      w.uint(1643173063);
      w.int(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "date"));
      w.int53(h(v, "adminId"));
      w.int53(h(v, "participantId"));
      w.bytes(h(v, "gAOrB"));
      w.long(h(v, "keyFingerprint"));
    },
    "encryptedChatDiscarded": function(w, v) {
      w.uint(505183301);
      var flags = 0;
      if (v.historyDeleted === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "id"));
    },
    "inputEncryptedChat": function(w, v) {
      w.uint(4047615457);
      w.int(h(v, "chatId"));
      w.long(h(v, "accessHash"));
    },
    "encryptedFileEmpty": function(w) {
      w.uint(3256830334);
    },
    "encryptedFile": function(w, v) {
      w.uint(2818608344);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int53(h(v, "size"));
      w.int(h(v, "dcId"));
      w.int(h(v, "keyFingerprint"));
    },
    "inputEncryptedFileEmpty": function(w) {
      w.uint(406307684);
    },
    "inputEncryptedFileUploaded": function(w, v) {
      w.uint(1690108678);
      w.long(h(v, "id"));
      w.int(h(v, "parts"));
      w.string(h(v, "md5Checksum"));
      w.int(h(v, "keyFingerprint"));
    },
    "inputEncryptedFile": function(w, v) {
      w.uint(1511503333);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputEncryptedFileBigUploaded": function(w, v) {
      w.uint(767652808);
      w.long(h(v, "id"));
      w.int(h(v, "parts"));
      w.int(h(v, "keyFingerprint"));
    },
    "encryptedMessage": function(w, v) {
      w.uint(3977822488);
      w.long(h(v, "randomId"));
      w.int(h(v, "chatId"));
      w.int(h(v, "date"));
      w.bytes(h(v, "bytes"));
      w.object(h(v, "file"));
    },
    "encryptedMessageService": function(w, v) {
      w.uint(594758406);
      w.long(h(v, "randomId"));
      w.int(h(v, "chatId"));
      w.int(h(v, "date"));
      w.bytes(h(v, "bytes"));
    },
    "messages.dhConfigNotModified": function(w, v) {
      w.uint(3236054581);
      w.bytes(h(v, "random"));
    },
    "messages.dhConfig": function(w, v) {
      w.uint(740433629);
      w.int(h(v, "g"));
      w.bytes(h(v, "p"));
      w.int(h(v, "version"));
      w.bytes(h(v, "random"));
    },
    "messages.sentEncryptedMessage": function(w, v) {
      w.uint(1443858741);
      w.int(h(v, "date"));
    },
    "messages.sentEncryptedFile": function(w, v) {
      w.uint(2492727090);
      w.int(h(v, "date"));
      w.object(h(v, "file"));
    },
    "inputDocumentEmpty": function(w) {
      w.uint(1928391342);
    },
    "inputDocument": function(w, v) {
      w.uint(448771445);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.bytes(h(v, "fileReference"));
    },
    "documentEmpty": function(w, v) {
      w.uint(922273905);
      w.long(h(v, "id"));
    },
    "document": function(w, v) {
      w.uint(2413085912);
      var flags = 0;
      var _thumbs = v.thumbs && v.thumbs.length;
      if (_thumbs)
        flags |= 1;
      var _videoThumbs = v.videoThumbs && v.videoThumbs.length;
      if (_videoThumbs)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.bytes(h(v, "fileReference"));
      w.int(h(v, "date"));
      w.string(h(v, "mimeType"));
      w.int53(h(v, "size"));
      if (_thumbs)
        w.vector(w.object, v.thumbs);
      if (_videoThumbs)
        w.vector(w.object, v.videoThumbs);
      w.int(h(v, "dcId"));
      w.vector(w.object, h(v, "attributes"));
    },
    "help.support": function(w, v) {
      w.uint(398898678);
      w.string(h(v, "phoneNumber"));
      w.object(h(v, "user"));
    },
    "notifyPeer": function(w, v) {
      w.uint(2681474008);
      w.object(h(v, "peer"));
    },
    "notifyUsers": function(w) {
      w.uint(3033021260);
    },
    "notifyChats": function(w) {
      w.uint(3221737155);
    },
    "notifyBroadcasts": function(w) {
      w.uint(3591563503);
    },
    "notifyForumTopic": function(w, v) {
      w.uint(577659656);
      w.object(h(v, "peer"));
      w.int(h(v, "topMsgId"));
    },
    "sendMessageTypingAction": function(w) {
      w.uint(381645902);
    },
    "sendMessageCancelAction": function(w) {
      w.uint(4250847477);
    },
    "sendMessageRecordVideoAction": function(w) {
      w.uint(2710034031);
    },
    "sendMessageUploadVideoAction": function(w, v) {
      w.uint(3916839660);
      w.int(h(v, "progress"));
    },
    "sendMessageRecordAudioAction": function(w) {
      w.uint(3576656887);
    },
    "sendMessageUploadAudioAction": function(w, v) {
      w.uint(4082227115);
      w.int(h(v, "progress"));
    },
    "sendMessageUploadPhotoAction": function(w, v) {
      w.uint(3520285222);
      w.int(h(v, "progress"));
    },
    "sendMessageUploadDocumentAction": function(w, v) {
      w.uint(2852968932);
      w.int(h(v, "progress"));
    },
    "sendMessageGeoLocationAction": function(w) {
      w.uint(393186209);
    },
    "sendMessageChooseContactAction": function(w) {
      w.uint(1653390447);
    },
    "sendMessageGamePlayAction": function(w) {
      w.uint(3714748232);
    },
    "sendMessageRecordRoundAction": function(w) {
      w.uint(2297593788);
    },
    "sendMessageUploadRoundAction": function(w, v) {
      w.uint(608050278);
      w.int(h(v, "progress"));
    },
    "speakingInGroupCallAction": function(w) {
      w.uint(3643548293);
    },
    "sendMessageHistoryImportAction": function(w, v) {
      w.uint(3688534598);
      w.int(h(v, "progress"));
    },
    "sendMessageChooseStickerAction": function(w) {
      w.uint(2958739121);
    },
    "sendMessageEmojiInteraction": function(w, v) {
      w.uint(630664139);
      w.string(h(v, "emoticon"));
      w.int(h(v, "msgId"));
      w.object(h(v, "interaction"));
    },
    "sendMessageEmojiInteractionSeen": function(w, v) {
      w.uint(3060109358);
      w.string(h(v, "emoticon"));
    },
    "contacts.found": function(w, v) {
      w.uint(3004386717);
      w.vector(w.object, h(v, "myResults"));
      w.vector(w.object, h(v, "results"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "inputPrivacyKeyStatusTimestamp": function(w) {
      w.uint(1335282456);
    },
    "inputPrivacyKeyChatInvite": function(w) {
      w.uint(3187344422);
    },
    "inputPrivacyKeyPhoneCall": function(w) {
      w.uint(4206550111);
    },
    "inputPrivacyKeyPhoneP2P": function(w) {
      w.uint(3684593874);
    },
    "inputPrivacyKeyForwards": function(w) {
      w.uint(2765966344);
    },
    "inputPrivacyKeyProfilePhoto": function(w) {
      w.uint(1461304012);
    },
    "inputPrivacyKeyPhoneNumber": function(w) {
      w.uint(55761658);
    },
    "inputPrivacyKeyAddedByPhone": function(w) {
      w.uint(3508640733);
    },
    "inputPrivacyKeyVoiceMessages": function(w) {
      w.uint(2934349160);
    },
    "inputPrivacyKeyAbout": function(w) {
      w.uint(941870144);
    },
    "inputPrivacyKeyBirthday": function(w) {
      w.uint(3596227020);
    },
    "privacyKeyStatusTimestamp": function(w) {
      w.uint(3157175088);
    },
    "privacyKeyChatInvite": function(w) {
      w.uint(1343122938);
    },
    "privacyKeyPhoneCall": function(w) {
      w.uint(1030105979);
    },
    "privacyKeyPhoneP2P": function(w) {
      w.uint(961092808);
    },
    "privacyKeyForwards": function(w) {
      w.uint(1777096355);
    },
    "privacyKeyProfilePhoto": function(w) {
      w.uint(2517966829);
    },
    "privacyKeyPhoneNumber": function(w) {
      w.uint(3516589165);
    },
    "privacyKeyAddedByPhone": function(w) {
      w.uint(1124062251);
    },
    "privacyKeyVoiceMessages": function(w) {
      w.uint(110621716);
    },
    "privacyKeyAbout": function(w) {
      w.uint(2760292193);
    },
    "privacyKeyBirthday": function(w) {
      w.uint(536913176);
    },
    "inputPrivacyValueAllowContacts": function(w) {
      w.uint(218751099);
    },
    "inputPrivacyValueAllowAll": function(w) {
      w.uint(407582158);
    },
    "inputPrivacyValueAllowUsers": function(w, v) {
      w.uint(320652927);
      w.vector(w.object, h(v, "users"));
    },
    "inputPrivacyValueDisallowContacts": function(w) {
      w.uint(195371015);
    },
    "inputPrivacyValueDisallowAll": function(w) {
      w.uint(3597362889);
    },
    "inputPrivacyValueDisallowUsers": function(w, v) {
      w.uint(2417034343);
      w.vector(w.object, h(v, "users"));
    },
    "inputPrivacyValueAllowChatParticipants": function(w, v) {
      w.uint(2215004623);
      w.vector(w.int53, h(v, "chats"));
    },
    "inputPrivacyValueDisallowChatParticipants": function(w, v) {
      w.uint(3914272646);
      w.vector(w.int53, h(v, "chats"));
    },
    "inputPrivacyValueAllowCloseFriends": function(w) {
      w.uint(793067081);
    },
    "inputPrivacyValueAllowPremium": function(w) {
      w.uint(2009975281);
    },
    "privacyValueAllowContacts": function(w) {
      w.uint(4294843308);
    },
    "privacyValueAllowAll": function(w) {
      w.uint(1698855810);
    },
    "privacyValueAllowUsers": function(w, v) {
      w.uint(3096469426);
      w.vector(w.int53, h(v, "users"));
    },
    "privacyValueDisallowContacts": function(w) {
      w.uint(4169726490);
    },
    "privacyValueDisallowAll": function(w) {
      w.uint(2339628899);
    },
    "privacyValueDisallowUsers": function(w, v) {
      w.uint(3831632193);
      w.vector(w.int53, h(v, "users"));
    },
    "privacyValueAllowChatParticipants": function(w, v) {
      w.uint(1796427406);
      w.vector(w.int53, h(v, "chats"));
    },
    "privacyValueDisallowChatParticipants": function(w, v) {
      w.uint(1103656293);
      w.vector(w.int53, h(v, "chats"));
    },
    "privacyValueAllowCloseFriends": function(w) {
      w.uint(4159232155);
    },
    "privacyValueAllowPremium": function(w) {
      w.uint(3974725963);
    },
    "account.privacyRules": function(w, v) {
      w.uint(1352683077);
      w.vector(w.object, h(v, "rules"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "accountDaysTTL": function(w, v) {
      w.uint(3100684255);
      w.int(h(v, "days"));
    },
    "documentAttributeImageSize": function(w, v) {
      w.uint(1815593308);
      w.int(h(v, "w"));
      w.int(h(v, "h"));
    },
    "documentAttributeAnimated": function(w) {
      w.uint(297109817);
    },
    "documentAttributeSticker": function(w, v) {
      w.uint(1662637586);
      var flags = 0;
      var _maskCoords = v.maskCoords !== void 0;
      if (_maskCoords)
        flags |= 1;
      if (v.mask === true)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "alt"));
      w.object(h(v, "stickerset"));
      if (_maskCoords)
        w.object(v.maskCoords);
    },
    "documentAttributeVideo": function(w, v) {
      w.uint(1137015880);
      var flags = 0;
      if (v.roundMessage === true)
        flags |= 1;
      if (v.supportsStreaming === true)
        flags |= 2;
      var _preloadPrefixSize = v.preloadPrefixSize !== void 0;
      if (_preloadPrefixSize)
        flags |= 4;
      if (v.nosound === true)
        flags |= 8;
      var _videoStartTs = v.videoStartTs !== void 0;
      if (_videoStartTs)
        flags |= 16;
      var _videoCodec = v.videoCodec !== void 0;
      if (_videoCodec)
        flags |= 32;
      w.uint(flags);
      w.double(h(v, "duration"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
      if (_preloadPrefixSize)
        w.int(v.preloadPrefixSize);
      if (_videoStartTs)
        w.double(v.videoStartTs);
      if (_videoCodec)
        w.string(v.videoCodec);
    },
    "documentAttributeAudio": function(w, v) {
      w.uint(2555574726);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _performer = v.performer !== void 0;
      if (_performer)
        flags |= 2;
      var _waveform = v.waveform !== void 0;
      if (_waveform)
        flags |= 4;
      if (v.voice === true)
        flags |= 1024;
      w.uint(flags);
      w.int(h(v, "duration"));
      if (_title)
        w.string(v.title);
      if (_performer)
        w.string(v.performer);
      if (_waveform)
        w.bytes(v.waveform);
    },
    "documentAttributeFilename": function(w, v) {
      w.uint(358154344);
      w.string(h(v, "fileName"));
    },
    "documentAttributeHasStickers": function(w) {
      w.uint(2550256375);
    },
    "documentAttributeCustomEmoji": function(w, v) {
      w.uint(4245985433);
      var flags = 0;
      if (v.free === true)
        flags |= 1;
      if (v.textColor === true)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "alt"));
      w.object(h(v, "stickerset"));
    },
    "messages.stickersNotModified": function(w) {
      w.uint(4050950690);
    },
    "messages.stickers": function(w, v) {
      w.uint(816245886);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "stickers"));
    },
    "stickerPack": function(w, v) {
      w.uint(313694676);
      w.string(h(v, "emoticon"));
      w.vector(w.long, h(v, "documents"));
    },
    "messages.allStickersNotModified": function(w) {
      w.uint(3898999491);
    },
    "messages.allStickers": function(w, v) {
      w.uint(3451637435);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "sets"));
    },
    "messages.affectedMessages": function(w, v) {
      w.uint(2228326789);
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
    },
    "webPageEmpty": function(w, v) {
      w.uint(555358088);
      var flags = 0;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "id"));
      if (_url)
        w.string(v.url);
    },
    "webPagePending": function(w, v) {
      w.uint(2966502983);
      var flags = 0;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "id"));
      if (_url)
        w.string(v.url);
      w.int(h(v, "date"));
    },
    "webPage": function(w, v) {
      w.uint(3902555570);
      var flags = 0;
      var _type = v.type !== void 0;
      if (_type)
        flags |= 1;
      var _siteName = v.siteName !== void 0;
      if (_siteName)
        flags |= 2;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 4;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 8;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 16;
      var _embedUrl = v.embedUrl !== void 0;
      var _embedType = v.embedType !== void 0;
      var _flags_5 = _embedUrl || _embedType;
      if (_flags_5)
        flags |= 32;
      var _embedWidth = v.embedWidth !== void 0;
      var _embedHeight = v.embedHeight !== void 0;
      var _flags_6 = _embedWidth || _embedHeight;
      if (_flags_6)
        flags |= 64;
      var _duration = v.duration !== void 0;
      if (_duration)
        flags |= 128;
      var _author = v.author !== void 0;
      if (_author)
        flags |= 256;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 512;
      var _cachedPage = v.cachedPage !== void 0;
      if (_cachedPage)
        flags |= 1024;
      var _attributes = v.attributes && v.attributes.length;
      if (_attributes)
        flags |= 4096;
      if (v.hasLargeMedia === true)
        flags |= 8192;
      w.uint(flags);
      w.long(h(v, "id"));
      w.string(h(v, "url"));
      w.string(h(v, "displayUrl"));
      w.int(h(v, "hash"));
      if (_type)
        w.string(v.type);
      if (_siteName)
        w.string(v.siteName);
      if (_title)
        w.string(v.title);
      if (_description)
        w.string(v.description);
      if (_photo)
        w.object(v.photo);
      if (_flags_5)
        w.string(v.embedUrl);
      if (_flags_5)
        w.string(v.embedType);
      if (_flags_6)
        w.int(v.embedWidth);
      if (_flags_6)
        w.int(v.embedHeight);
      if (_duration)
        w.int(v.duration);
      if (_author)
        w.string(v.author);
      if (_document)
        w.object(v.document);
      if (_cachedPage)
        w.object(v.cachedPage);
      if (_attributes)
        w.vector(w.object, v.attributes);
    },
    "webPageNotModified": function(w, v) {
      w.uint(1930545681);
      var flags = 0;
      var _cachedPageViews = v.cachedPageViews !== void 0;
      if (_cachedPageViews)
        flags |= 1;
      w.uint(flags);
      if (_cachedPageViews)
        w.int(v.cachedPageViews);
    },
    "authorization": function(w, v) {
      w.uint(2902578717);
      var flags = 0;
      if (v.current === true)
        flags |= 1;
      if (v.officialApp === true)
        flags |= 2;
      if (v.passwordPending === true)
        flags |= 4;
      if (v.encryptedRequestsDisabled === true)
        flags |= 8;
      if (v.callRequestsDisabled === true)
        flags |= 16;
      if (v.unconfirmed === true)
        flags |= 32;
      w.uint(flags);
      w.long(h(v, "hash"));
      w.string(h(v, "deviceModel"));
      w.string(h(v, "platform"));
      w.string(h(v, "systemVersion"));
      w.int(h(v, "apiId"));
      w.string(h(v, "appName"));
      w.string(h(v, "appVersion"));
      w.int(h(v, "dateCreated"));
      w.int(h(v, "dateActive"));
      w.string(h(v, "ip"));
      w.string(h(v, "country"));
      w.string(h(v, "region"));
    },
    "account.authorizations": function(w, v) {
      w.uint(1275039392);
      w.int(h(v, "authorizationTtlDays"));
      w.vector(w.object, h(v, "authorizations"));
    },
    "account.password": function(w, v) {
      w.uint(2507886843);
      var flags = 0;
      if (v.hasRecovery === true)
        flags |= 1;
      if (v.hasSecureValues === true)
        flags |= 2;
      var _currentAlgo = v.currentAlgo !== void 0;
      var _srpB = v.srpB !== void 0;
      var _srpId = v.srpId !== void 0;
      var _flags_2 = v.hasPassword === true || _currentAlgo || _srpB || _srpId;
      if (_flags_2)
        flags |= 4;
      var _hint = v.hint !== void 0;
      if (_hint)
        flags |= 8;
      var _emailUnconfirmedPattern = v.emailUnconfirmedPattern !== void 0;
      if (_emailUnconfirmedPattern)
        flags |= 16;
      var _pendingResetDate = v.pendingResetDate !== void 0;
      if (_pendingResetDate)
        flags |= 32;
      var _loginEmailPattern = v.loginEmailPattern !== void 0;
      if (_loginEmailPattern)
        flags |= 64;
      w.uint(flags);
      if (_flags_2)
        w.object(v.currentAlgo);
      if (_flags_2)
        w.bytes(v.srpB);
      if (_flags_2)
        w.long(v.srpId);
      if (_hint)
        w.string(v.hint);
      if (_emailUnconfirmedPattern)
        w.string(v.emailUnconfirmedPattern);
      w.object(h(v, "newAlgo"));
      w.object(h(v, "newSecureAlgo"));
      w.bytes(h(v, "secureRandom"));
      if (_pendingResetDate)
        w.int(v.pendingResetDate);
      if (_loginEmailPattern)
        w.string(v.loginEmailPattern);
    },
    "account.passwordSettings": function(w, v) {
      w.uint(2589733861);
      var flags = 0;
      var _email = v.email !== void 0;
      if (_email)
        flags |= 1;
      var _secureSettings = v.secureSettings !== void 0;
      if (_secureSettings)
        flags |= 2;
      w.uint(flags);
      if (_email)
        w.string(v.email);
      if (_secureSettings)
        w.object(v.secureSettings);
    },
    "account.passwordInputSettings": function(w, v) {
      w.uint(3258394569);
      var flags = 0;
      var _newAlgo = v.newAlgo !== void 0;
      var _newPasswordHash = v.newPasswordHash !== void 0;
      var _hint = v.hint !== void 0;
      var _flags_0 = _newAlgo || _newPasswordHash || _hint;
      if (_flags_0)
        flags |= 1;
      var _email = v.email !== void 0;
      if (_email)
        flags |= 2;
      var _newSecureSettings = v.newSecureSettings !== void 0;
      if (_newSecureSettings)
        flags |= 4;
      w.uint(flags);
      if (_flags_0)
        w.object(v.newAlgo);
      if (_flags_0)
        w.bytes(v.newPasswordHash);
      if (_flags_0)
        w.string(v.hint);
      if (_email)
        w.string(v.email);
      if (_newSecureSettings)
        w.object(v.newSecureSettings);
    },
    "auth.passwordRecovery": function(w, v) {
      w.uint(326715557);
      w.string(h(v, "emailPattern"));
    },
    "receivedNotifyMessage": function(w, v) {
      w.uint(2743383929);
      w.int(h(v, "id"));
      w.int(h(v, "flags"));
    },
    "chatInviteExported": function(w, v) {
      w.uint(2720841110);
      var flags = 0;
      if (v.revoked === true)
        flags |= 1;
      var _expireDate = v.expireDate !== void 0;
      if (_expireDate)
        flags |= 2;
      var _usageLimit = v.usageLimit !== void 0;
      if (_usageLimit)
        flags |= 4;
      var _usage = v.usage !== void 0;
      if (_usage)
        flags |= 8;
      var _startDate = v.startDate !== void 0;
      if (_startDate)
        flags |= 16;
      if (v.permanent === true)
        flags |= 32;
      if (v.requestNeeded === true)
        flags |= 64;
      var _requested = v.requested !== void 0;
      if (_requested)
        flags |= 128;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 256;
      var _subscriptionPricing = v.subscriptionPricing !== void 0;
      if (_subscriptionPricing)
        flags |= 512;
      var _subscriptionExpired = v.subscriptionExpired !== void 0;
      if (_subscriptionExpired)
        flags |= 1024;
      w.uint(flags);
      w.string(h(v, "link"));
      w.int53(h(v, "adminId"));
      w.int(h(v, "date"));
      if (_startDate)
        w.int(v.startDate);
      if (_expireDate)
        w.int(v.expireDate);
      if (_usageLimit)
        w.int(v.usageLimit);
      if (_usage)
        w.int(v.usage);
      if (_requested)
        w.int(v.requested);
      if (_subscriptionExpired)
        w.int(v.subscriptionExpired);
      if (_title)
        w.string(v.title);
      if (_subscriptionPricing)
        w.object(v.subscriptionPricing);
    },
    "chatInvitePublicJoinRequests": function(w) {
      w.uint(3977280183);
    },
    "chatInviteAlready": function(w, v) {
      w.uint(1516793212);
      w.object(h(v, "chat"));
    },
    "chatInvite": function(w, v) {
      w.uint(4268046493);
      var flags = 0;
      if (v.channel === true)
        flags |= 1;
      if (v.broadcast === true)
        flags |= 2;
      if (v.public === true)
        flags |= 4;
      if (v.megagroup === true)
        flags |= 8;
      var _participants = v.participants && v.participants.length;
      if (_participants)
        flags |= 16;
      var _about = v.about !== void 0;
      if (_about)
        flags |= 32;
      if (v.requestNeeded === true)
        flags |= 64;
      if (v.verified === true)
        flags |= 128;
      if (v.scam === true)
        flags |= 256;
      if (v.fake === true)
        flags |= 512;
      var _subscriptionPricing = v.subscriptionPricing !== void 0;
      if (_subscriptionPricing)
        flags |= 1024;
      if (v.canRefulfillSubscription === true)
        flags |= 2048;
      var _subscriptionFormId = v.subscriptionFormId !== void 0;
      if (_subscriptionFormId)
        flags |= 4096;
      w.uint(flags);
      w.string(h(v, "title"));
      if (_about)
        w.string(v.about);
      w.object(h(v, "photo"));
      w.int(h(v, "participantsCount"));
      if (_participants)
        w.vector(w.object, v.participants);
      w.int(h(v, "color"));
      if (_subscriptionPricing)
        w.object(v.subscriptionPricing);
      if (_subscriptionFormId)
        w.long(v.subscriptionFormId);
    },
    "chatInvitePeek": function(w, v) {
      w.uint(1634294960);
      w.object(h(v, "chat"));
      w.int(h(v, "expires"));
    },
    "inputStickerSetEmpty": function(w) {
      w.uint(4290128789);
    },
    "inputStickerSetID": function(w, v) {
      w.uint(2649203305);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputStickerSetShortName": function(w, v) {
      w.uint(2250033312);
      w.string(h(v, "shortName"));
    },
    "inputStickerSetAnimatedEmoji": function(w) {
      w.uint(42402760);
    },
    "inputStickerSetDice": function(w, v) {
      w.uint(3867103758);
      w.string(h(v, "emoticon"));
    },
    "inputStickerSetAnimatedEmojiAnimations": function(w) {
      w.uint(215889721);
    },
    "inputStickerSetPremiumGifts": function(w) {
      w.uint(3364567810);
    },
    "inputStickerSetEmojiGenericAnimations": function(w) {
      w.uint(80008398);
    },
    "inputStickerSetEmojiDefaultStatuses": function(w) {
      w.uint(701560302);
    },
    "inputStickerSetEmojiDefaultTopicIcons": function(w) {
      w.uint(1153562857);
    },
    "inputStickerSetEmojiChannelDefaultStatuses": function(w) {
      w.uint(1232373075);
    },
    "stickerSet": function(w, v) {
      w.uint(768691932);
      var flags = 0;
      var _installedDate = v.installedDate !== void 0;
      if (_installedDate)
        flags |= 1;
      if (v.archived === true)
        flags |= 2;
      if (v.official === true)
        flags |= 4;
      if (v.masks === true)
        flags |= 8;
      var _thumbs = v.thumbs && v.thumbs.length;
      var _thumbDcId = v.thumbDcId !== void 0;
      var _thumbVersion = v.thumbVersion !== void 0;
      var _flags_4 = _thumbs || _thumbDcId || _thumbVersion;
      if (_flags_4)
        flags |= 16;
      if (v.emojis === true)
        flags |= 128;
      var _thumbDocumentId = v.thumbDocumentId !== void 0;
      if (_thumbDocumentId)
        flags |= 256;
      if (v.textColor === true)
        flags |= 512;
      if (v.channelEmojiStatus === true)
        flags |= 1024;
      if (v.creator === true)
        flags |= 2048;
      w.uint(flags);
      if (_installedDate)
        w.int(v.installedDate);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.string(h(v, "title"));
      w.string(h(v, "shortName"));
      if (_flags_4)
        w.vector(w.object, v.thumbs);
      if (_flags_4)
        w.int(v.thumbDcId);
      if (_flags_4)
        w.int(v.thumbVersion);
      if (_thumbDocumentId)
        w.long(v.thumbDocumentId);
      w.int(h(v, "count"));
      w.int(h(v, "hash"));
    },
    "messages.stickerSet": function(w, v) {
      w.uint(1846886166);
      w.object(h(v, "set"));
      w.vector(w.object, h(v, "packs"));
      w.vector(w.object, h(v, "keywords"));
      w.vector(w.object, h(v, "documents"));
    },
    "messages.stickerSetNotModified": function(w) {
      w.uint(3556320491);
    },
    "botCommand": function(w, v) {
      w.uint(3262826695);
      w.string(h(v, "command"));
      w.string(h(v, "description"));
    },
    "botInfo": function(w, v) {
      w.uint(2185461364);
      var flags = 0;
      var _userId = v.userId !== void 0;
      if (_userId)
        flags |= 1;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 2;
      var _commands = v.commands && v.commands.length;
      if (_commands)
        flags |= 4;
      var _menuButton = v.menuButton !== void 0;
      if (_menuButton)
        flags |= 8;
      var _descriptionPhoto = v.descriptionPhoto !== void 0;
      if (_descriptionPhoto)
        flags |= 16;
      var _descriptionDocument = v.descriptionDocument !== void 0;
      if (_descriptionDocument)
        flags |= 32;
      if (v.hasPreviewMedias === true)
        flags |= 64;
      var _privacyPolicyUrl = v.privacyPolicyUrl !== void 0;
      if (_privacyPolicyUrl)
        flags |= 128;
      w.uint(flags);
      if (_userId)
        w.int53(v.userId);
      if (_description)
        w.string(v.description);
      if (_descriptionPhoto)
        w.object(v.descriptionPhoto);
      if (_descriptionDocument)
        w.object(v.descriptionDocument);
      if (_commands)
        w.vector(w.object, v.commands);
      if (_menuButton)
        w.object(v.menuButton);
      if (_privacyPolicyUrl)
        w.string(v.privacyPolicyUrl);
    },
    "keyboardButton": function(w, v) {
      w.uint(2734311552);
      w.string(h(v, "text"));
    },
    "keyboardButtonUrl": function(w, v) {
      w.uint(629866245);
      w.string(h(v, "text"));
      w.string(h(v, "url"));
    },
    "keyboardButtonCallback": function(w, v) {
      w.uint(901503851);
      var flags = 0;
      if (v.requiresPassword === true)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "text"));
      w.bytes(h(v, "data"));
    },
    "keyboardButtonRequestPhone": function(w, v) {
      w.uint(2976541737);
      w.string(h(v, "text"));
    },
    "keyboardButtonRequestGeoLocation": function(w, v) {
      w.uint(4235815743);
      w.string(h(v, "text"));
    },
    "keyboardButtonSwitchInline": function(w, v) {
      w.uint(2478439349);
      var flags = 0;
      if (v.samePeer === true)
        flags |= 1;
      var _peerTypes = v.peerTypes && v.peerTypes.length;
      if (_peerTypes)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "text"));
      w.string(h(v, "query"));
      if (_peerTypes)
        w.vector(w.object, v.peerTypes);
    },
    "keyboardButtonGame": function(w, v) {
      w.uint(1358175439);
      w.string(h(v, "text"));
    },
    "keyboardButtonBuy": function(w, v) {
      w.uint(2950250427);
      w.string(h(v, "text"));
    },
    "keyboardButtonUrlAuth": function(w, v) {
      w.uint(280464681);
      var flags = 0;
      var _fwdText = v.fwdText !== void 0;
      if (_fwdText)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "text"));
      if (_fwdText)
        w.string(v.fwdText);
      w.string(h(v, "url"));
      w.int(h(v, "buttonId"));
    },
    "inputKeyboardButtonUrlAuth": function(w, v) {
      w.uint(3492708308);
      var flags = 0;
      if (v.requestWriteAccess === true)
        flags |= 1;
      var _fwdText = v.fwdText !== void 0;
      if (_fwdText)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "text"));
      if (_fwdText)
        w.string(v.fwdText);
      w.string(h(v, "url"));
      w.object(h(v, "bot"));
    },
    "keyboardButtonRequestPoll": function(w, v) {
      w.uint(3150401885);
      var flags = 0;
      var _quiz = v.quiz !== void 0;
      if (_quiz)
        flags |= 1;
      w.uint(flags);
      if (_quiz)
        w.boolean(v.quiz);
      w.string(h(v, "text"));
    },
    "inputKeyboardButtonUserProfile": function(w, v) {
      w.uint(3918005115);
      w.string(h(v, "text"));
      w.object(h(v, "userId"));
    },
    "keyboardButtonUserProfile": function(w, v) {
      w.uint(814112961);
      w.string(h(v, "text"));
      w.int53(h(v, "userId"));
    },
    "keyboardButtonWebView": function(w, v) {
      w.uint(326529584);
      w.string(h(v, "text"));
      w.string(h(v, "url"));
    },
    "keyboardButtonSimpleWebView": function(w, v) {
      w.uint(2696958044);
      w.string(h(v, "text"));
      w.string(h(v, "url"));
    },
    "keyboardButtonRequestPeer": function(w, v) {
      w.uint(1406648280);
      w.string(h(v, "text"));
      w.int(h(v, "buttonId"));
      w.object(h(v, "peerType"));
      w.int(h(v, "maxQuantity"));
    },
    "inputKeyboardButtonRequestPeer": function(w, v) {
      w.uint(3378916613);
      var flags = 0;
      if (v.nameRequested === true)
        flags |= 1;
      if (v.usernameRequested === true)
        flags |= 2;
      if (v.photoRequested === true)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "text"));
      w.int(h(v, "buttonId"));
      w.object(h(v, "peerType"));
      w.int(h(v, "maxQuantity"));
    },
    "keyboardButtonCopy": function(w, v) {
      w.uint(1976723854);
      w.string(h(v, "text"));
      w.string(h(v, "copyText"));
    },
    "keyboardButtonRow": function(w, v) {
      w.uint(2002815875);
      w.vector(w.object, h(v, "buttons"));
    },
    "replyKeyboardHide": function(w, v) {
      w.uint(2688441221);
      var flags = 0;
      if (v.selective === true)
        flags |= 4;
      w.uint(flags);
    },
    "replyKeyboardForceReply": function(w, v) {
      w.uint(2259946248);
      var flags = 0;
      if (v.singleUse === true)
        flags |= 2;
      if (v.selective === true)
        flags |= 4;
      var _placeholder = v.placeholder !== void 0;
      if (_placeholder)
        flags |= 8;
      w.uint(flags);
      if (_placeholder)
        w.string(v.placeholder);
    },
    "replyKeyboardMarkup": function(w, v) {
      w.uint(2245892561);
      var flags = 0;
      if (v.resize === true)
        flags |= 1;
      if (v.singleUse === true)
        flags |= 2;
      if (v.selective === true)
        flags |= 4;
      var _placeholder = v.placeholder !== void 0;
      if (_placeholder)
        flags |= 8;
      if (v.persistent === true)
        flags |= 16;
      w.uint(flags);
      w.vector(w.object, h(v, "rows"));
      if (_placeholder)
        w.string(v.placeholder);
    },
    "replyInlineMarkup": function(w, v) {
      w.uint(1218642516);
      w.vector(w.object, h(v, "rows"));
    },
    "messageEntityUnknown": function(w, v) {
      w.uint(3146955413);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityMention": function(w, v) {
      w.uint(4194588573);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityHashtag": function(w, v) {
      w.uint(1868782349);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityBotCommand": function(w, v) {
      w.uint(1827637959);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityUrl": function(w, v) {
      w.uint(1859134776);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityEmail": function(w, v) {
      w.uint(1692693954);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityBold": function(w, v) {
      w.uint(3177253833);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityItalic": function(w, v) {
      w.uint(2188348256);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityCode": function(w, v) {
      w.uint(681706865);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityPre": function(w, v) {
      w.uint(1938967520);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
      w.string(h(v, "language"));
    },
    "messageEntityTextUrl": function(w, v) {
      w.uint(1990644519);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
      w.string(h(v, "url"));
    },
    "messageEntityMentionName": function(w, v) {
      w.uint(3699052864);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
      w.int53(h(v, "userId"));
    },
    "inputMessageEntityMentionName": function(w, v) {
      w.uint(546203849);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
      w.object(h(v, "userId"));
    },
    "messageEntityPhone": function(w, v) {
      w.uint(2607407947);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityCashtag": function(w, v) {
      w.uint(1280209983);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityUnderline": function(w, v) {
      w.uint(2622389899);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityStrike": function(w, v) {
      w.uint(3204879316);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityBankCard": function(w, v) {
      w.uint(1981704948);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntitySpoiler": function(w, v) {
      w.uint(852137487);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "messageEntityCustomEmoji": function(w, v) {
      w.uint(3369010680);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
      w.long(h(v, "documentId"));
    },
    "messageEntityBlockquote": function(w, v) {
      w.uint(4056722092);
      var flags = 0;
      if (v.collapsed === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "offset"));
      w.int(h(v, "length"));
    },
    "inputChannelEmpty": function(w) {
      w.uint(4002160262);
    },
    "inputChannel": function(w, v) {
      w.uint(4082822184);
      w.int53(h(v, "channelId"));
      w.long(h(v, "accessHash"));
    },
    "inputChannelFromMessage": function(w, v) {
      w.uint(1536380829);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int53(h(v, "channelId"));
    },
    "contacts.resolvedPeer": function(w, v) {
      w.uint(2131196633);
      w.object(h(v, "peer"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messageRange": function(w, v) {
      w.uint(182649427);
      w.int(h(v, "minId"));
      w.int(h(v, "maxId"));
    },
    "updates.channelDifferenceEmpty": function(w, v) {
      w.uint(1041346555);
      var flags = 0;
      if (v.final === true)
        flags |= 1;
      var _timeout = v.timeout !== void 0;
      if (_timeout)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "pts"));
      if (_timeout)
        w.int(v.timeout);
    },
    "updates.channelDifferenceTooLong": function(w, v) {
      w.uint(2763835134);
      var flags = 0;
      if (v.final === true)
        flags |= 1;
      var _timeout = v.timeout !== void 0;
      if (_timeout)
        flags |= 2;
      w.uint(flags);
      if (_timeout)
        w.int(v.timeout);
      w.object(h(v, "dialog"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "updates.channelDifference": function(w, v) {
      w.uint(543450958);
      var flags = 0;
      if (v.final === true)
        flags |= 1;
      var _timeout = v.timeout !== void 0;
      if (_timeout)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "pts"));
      if (_timeout)
        w.int(v.timeout);
      w.vector(w.object, h(v, "newMessages"));
      w.vector(w.object, h(v, "otherUpdates"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "channelMessagesFilterEmpty": function(w) {
      w.uint(2496933607);
    },
    "channelMessagesFilter": function(w, v) {
      w.uint(3447183703);
      var flags = 0;
      if (v.excludeNewMessages === true)
        flags |= 2;
      w.uint(flags);
      w.vector(w.object, h(v, "ranges"));
    },
    "channelParticipant": function(w, v) {
      w.uint(3409540633);
      var flags = 0;
      var _subscriptionUntilDate = v.subscriptionUntilDate !== void 0;
      if (_subscriptionUntilDate)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "userId"));
      w.int(h(v, "date"));
      if (_subscriptionUntilDate)
        w.int(v.subscriptionUntilDate);
    },
    "channelParticipantSelf": function(w, v) {
      w.uint(1331723247);
      var flags = 0;
      if (v.viaRequest === true)
        flags |= 1;
      var _subscriptionUntilDate = v.subscriptionUntilDate !== void 0;
      if (_subscriptionUntilDate)
        flags |= 2;
      w.uint(flags);
      w.int53(h(v, "userId"));
      w.int53(h(v, "inviterId"));
      w.int(h(v, "date"));
      if (_subscriptionUntilDate)
        w.int(v.subscriptionUntilDate);
    },
    "channelParticipantCreator": function(w, v) {
      w.uint(803602899);
      var flags = 0;
      var _rank = v.rank !== void 0;
      if (_rank)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "userId"));
      w.object(h(v, "adminRights"));
      if (_rank)
        w.string(v.rank);
    },
    "channelParticipantAdmin": function(w, v) {
      w.uint(885242707);
      var flags = 0;
      if (v.canEdit === true)
        flags |= 1;
      var _inviterId = v.inviterId !== void 0;
      var _flags_1 = v.self === true || _inviterId;
      if (_flags_1)
        flags |= 2;
      var _rank = v.rank !== void 0;
      if (_rank)
        flags |= 4;
      w.uint(flags);
      w.int53(h(v, "userId"));
      if (_flags_1)
        w.int53(v.inviterId);
      w.int53(h(v, "promotedBy"));
      w.int(h(v, "date"));
      w.object(h(v, "adminRights"));
      if (_rank)
        w.string(v.rank);
    },
    "channelParticipantBanned": function(w, v) {
      w.uint(1844969806);
      var flags = 0;
      if (v.left === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int53(h(v, "kickedBy"));
      w.int(h(v, "date"));
      w.object(h(v, "bannedRights"));
    },
    "channelParticipantLeft": function(w, v) {
      w.uint(453242886);
      w.object(h(v, "peer"));
    },
    "channelParticipantsRecent": function(w) {
      w.uint(3728686201);
    },
    "channelParticipantsAdmins": function(w) {
      w.uint(3026225513);
    },
    "channelParticipantsKicked": function(w, v) {
      w.uint(2746567045);
      w.string(h(v, "q"));
    },
    "channelParticipantsBots": function(w) {
      w.uint(2966521435);
    },
    "channelParticipantsBanned": function(w, v) {
      w.uint(338142689);
      w.string(h(v, "q"));
    },
    "channelParticipantsSearch": function(w, v) {
      w.uint(106343499);
      w.string(h(v, "q"));
    },
    "channelParticipantsContacts": function(w, v) {
      w.uint(3144345741);
      w.string(h(v, "q"));
    },
    "channelParticipantsMentions": function(w, v) {
      w.uint(3763035371);
      var flags = 0;
      var _q = v.q !== void 0;
      if (_q)
        flags |= 1;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 2;
      w.uint(flags);
      if (_q)
        w.string(v.q);
      if (_topMsgId)
        w.int(v.topMsgId);
    },
    "channels.channelParticipants": function(w, v) {
      w.uint(2595290799);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "participants"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "channels.channelParticipantsNotModified": function(w) {
      w.uint(4028055529);
    },
    "channels.channelParticipant": function(w, v) {
      w.uint(3753378583);
      w.object(h(v, "participant"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "help.termsOfService": function(w, v) {
      w.uint(2013922064);
      var flags = 0;
      if (v.popup === true)
        flags |= 1;
      var _minAgeConfirm = v.minAgeConfirm !== void 0;
      if (_minAgeConfirm)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "id"));
      w.string(h(v, "text"));
      w.vector(w.object, h(v, "entities"));
      if (_minAgeConfirm)
        w.int(v.minAgeConfirm);
    },
    "messages.savedGifsNotModified": function(w) {
      w.uint(3892468898);
    },
    "messages.savedGifs": function(w, v) {
      w.uint(2225089037);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "gifs"));
    },
    "inputBotInlineMessageMediaAuto": function(w, v) {
      w.uint(864077702);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      if (v.invertMedia === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineMessageText": function(w, v) {
      w.uint(1036876423);
      var flags = 0;
      if (v.noWebpage === true)
        flags |= 1;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      if (v.invertMedia === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineMessageMediaGeo": function(w, v) {
      w.uint(2526190213);
      var flags = 0;
      var _heading = v.heading !== void 0;
      if (_heading)
        flags |= 1;
      var _period = v.period !== void 0;
      if (_period)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
      if (_proximityNotificationRadius)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "geoPoint"));
      if (_heading)
        w.int(v.heading);
      if (_period)
        w.int(v.period);
      if (_proximityNotificationRadius)
        w.int(v.proximityNotificationRadius);
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineMessageMediaVenue": function(w, v) {
      w.uint(1098628881);
      var flags = 0;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "geoPoint"));
      w.string(h(v, "title"));
      w.string(h(v, "address"));
      w.string(h(v, "provider"));
      w.string(h(v, "venueId"));
      w.string(h(v, "venueType"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineMessageMediaContact": function(w, v) {
      w.uint(2800599037);
      var flags = 0;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
      w.string(h(v, "vcard"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineMessageGame": function(w, v) {
      w.uint(1262639204);
      var flags = 0;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      w.uint(flags);
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineMessageMediaInvoice": function(w, v) {
      w.uint(3622273573);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 1;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      w.object(h(v, "invoice"));
      w.bytes(h(v, "payload"));
      w.string(h(v, "provider"));
      w.object(h(v, "providerData"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineMessageMediaWebPage": function(w, v) {
      w.uint(3185362192);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      if (v.invertMedia === true)
        flags |= 8;
      if (v.forceLargeMedia === true)
        flags |= 16;
      if (v.forceSmallMedia === true)
        flags |= 32;
      if (v.optional === true)
        flags |= 64;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      w.string(h(v, "url"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "inputBotInlineResult": function(w, v) {
      w.uint(2294256409);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 4;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 8;
      var _thumb = v.thumb !== void 0;
      if (_thumb)
        flags |= 16;
      var _content = v.content !== void 0;
      if (_content)
        flags |= 32;
      w.uint(flags);
      w.string(h(v, "id"));
      w.string(h(v, "type"));
      if (_title)
        w.string(v.title);
      if (_description)
        w.string(v.description);
      if (_url)
        w.string(v.url);
      if (_thumb)
        w.object(v.thumb);
      if (_content)
        w.object(v.content);
      w.object(h(v, "sendMessage"));
    },
    "inputBotInlineResultPhoto": function(w, v) {
      w.uint(2832753831);
      w.string(h(v, "id"));
      w.string(h(v, "type"));
      w.object(h(v, "photo"));
      w.object(h(v, "sendMessage"));
    },
    "inputBotInlineResultDocument": function(w, v) {
      w.uint(4294507972);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "id"));
      w.string(h(v, "type"));
      if (_title)
        w.string(v.title);
      if (_description)
        w.string(v.description);
      w.object(h(v, "document"));
      w.object(h(v, "sendMessage"));
    },
    "inputBotInlineResultGame": function(w, v) {
      w.uint(1336154098);
      w.string(h(v, "id"));
      w.string(h(v, "shortName"));
      w.object(h(v, "sendMessage"));
    },
    "botInlineMessageMediaAuto": function(w, v) {
      w.uint(1984755728);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      if (v.invertMedia === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "botInlineMessageText": function(w, v) {
      w.uint(2357159394);
      var flags = 0;
      if (v.noWebpage === true)
        flags |= 1;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      if (v.invertMedia === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "botInlineMessageMediaGeo": function(w, v) {
      w.uint(85477117);
      var flags = 0;
      var _heading = v.heading !== void 0;
      if (_heading)
        flags |= 1;
      var _period = v.period !== void 0;
      if (_period)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      var _proximityNotificationRadius = v.proximityNotificationRadius !== void 0;
      if (_proximityNotificationRadius)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "geo"));
      if (_heading)
        w.int(v.heading);
      if (_period)
        w.int(v.period);
      if (_proximityNotificationRadius)
        w.int(v.proximityNotificationRadius);
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "botInlineMessageMediaVenue": function(w, v) {
      w.uint(2324063644);
      var flags = 0;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "geo"));
      w.string(h(v, "title"));
      w.string(h(v, "address"));
      w.string(h(v, "provider"));
      w.string(h(v, "venueId"));
      w.string(h(v, "venueType"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "botInlineMessageMediaContact": function(w, v) {
      w.uint(416402882);
      var flags = 0;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
      w.string(h(v, "vcard"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "botInlineMessageMediaInvoice": function(w, v) {
      w.uint(894081801);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 1;
      if (v.shippingAddressRequested === true)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      if (v.test === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "botInlineMessageMediaWebPage": function(w, v) {
      w.uint(2157631910);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      if (v.invertMedia === true)
        flags |= 8;
      if (v.forceLargeMedia === true)
        flags |= 16;
      if (v.forceSmallMedia === true)
        flags |= 32;
      if (v.manual === true)
        flags |= 128;
      if (v.safe === true)
        flags |= 256;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      w.string(h(v, "url"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
    },
    "botInlineResult": function(w, v) {
      w.uint(295067450);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 4;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 8;
      var _thumb = v.thumb !== void 0;
      if (_thumb)
        flags |= 16;
      var _content = v.content !== void 0;
      if (_content)
        flags |= 32;
      w.uint(flags);
      w.string(h(v, "id"));
      w.string(h(v, "type"));
      if (_title)
        w.string(v.title);
      if (_description)
        w.string(v.description);
      if (_url)
        w.string(v.url);
      if (_thumb)
        w.object(v.thumb);
      if (_content)
        w.object(v.content);
      w.object(h(v, "sendMessage"));
    },
    "botInlineMediaResult": function(w, v) {
      w.uint(400266251);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 1;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 2;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 4;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "id"));
      w.string(h(v, "type"));
      if (_photo)
        w.object(v.photo);
      if (_document)
        w.object(v.document);
      if (_title)
        w.string(v.title);
      if (_description)
        w.string(v.description);
      w.object(h(v, "sendMessage"));
    },
    "messages.botResults": function(w, v) {
      w.uint(3760321270);
      var flags = 0;
      if (v.gallery === true)
        flags |= 1;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 2;
      var _switchPm = v.switchPm !== void 0;
      if (_switchPm)
        flags |= 4;
      var _switchWebview = v.switchWebview !== void 0;
      if (_switchWebview)
        flags |= 8;
      w.uint(flags);
      w.long(h(v, "queryId"));
      if (_nextOffset)
        w.string(v.nextOffset);
      if (_switchPm)
        w.object(v.switchPm);
      if (_switchWebview)
        w.object(v.switchWebview);
      w.vector(w.object, h(v, "results"));
      w.int(h(v, "cacheTime"));
      w.vector(w.object, h(v, "users"));
    },
    "exportedMessageLink": function(w, v) {
      w.uint(1571494644);
      w.string(h(v, "link"));
      w.string(h(v, "html"));
    },
    "messageFwdHeader": function(w, v) {
      w.uint(1313731771);
      var flags = 0;
      var _fromId = v.fromId !== void 0;
      if (_fromId)
        flags |= 1;
      var _channelPost = v.channelPost !== void 0;
      if (_channelPost)
        flags |= 4;
      var _postAuthor = v.postAuthor !== void 0;
      if (_postAuthor)
        flags |= 8;
      var _savedFromPeer = v.savedFromPeer !== void 0;
      var _savedFromMsgId = v.savedFromMsgId !== void 0;
      var _flags_4 = _savedFromPeer || _savedFromMsgId;
      if (_flags_4)
        flags |= 16;
      var _fromName = v.fromName !== void 0;
      if (_fromName)
        flags |= 32;
      var _psaType = v.psaType !== void 0;
      if (_psaType)
        flags |= 64;
      if (v.imported === true)
        flags |= 128;
      var _savedFromId = v.savedFromId !== void 0;
      if (_savedFromId)
        flags |= 256;
      var _savedFromName = v.savedFromName !== void 0;
      if (_savedFromName)
        flags |= 512;
      var _savedDate = v.savedDate !== void 0;
      if (_savedDate)
        flags |= 1024;
      if (v.savedOut === true)
        flags |= 2048;
      w.uint(flags);
      if (_fromId)
        w.object(v.fromId);
      if (_fromName)
        w.string(v.fromName);
      w.int(h(v, "date"));
      if (_channelPost)
        w.int(v.channelPost);
      if (_postAuthor)
        w.string(v.postAuthor);
      if (_flags_4)
        w.object(v.savedFromPeer);
      if (_flags_4)
        w.int(v.savedFromMsgId);
      if (_savedFromId)
        w.object(v.savedFromId);
      if (_savedFromName)
        w.string(v.savedFromName);
      if (_savedDate)
        w.int(v.savedDate);
      if (_psaType)
        w.string(v.psaType);
    },
    "auth.codeTypeSms": function(w) {
      w.uint(1923290508);
    },
    "auth.codeTypeCall": function(w) {
      w.uint(1948046307);
    },
    "auth.codeTypeFlashCall": function(w) {
      w.uint(577556219);
    },
    "auth.codeTypeMissedCall": function(w) {
      w.uint(3592083182);
    },
    "auth.codeTypeFragmentSms": function(w) {
      w.uint(116234636);
    },
    "auth.sentCodeTypeApp": function(w, v) {
      w.uint(1035688326);
      w.int(h(v, "length"));
    },
    "auth.sentCodeTypeSms": function(w, v) {
      w.uint(3221273506);
      w.int(h(v, "length"));
    },
    "auth.sentCodeTypeCall": function(w, v) {
      w.uint(1398007207);
      w.int(h(v, "length"));
    },
    "auth.sentCodeTypeFlashCall": function(w, v) {
      w.uint(2869151449);
      w.string(h(v, "pattern"));
    },
    "auth.sentCodeTypeMissedCall": function(w, v) {
      w.uint(2181063812);
      w.string(h(v, "prefix"));
      w.int(h(v, "length"));
    },
    "auth.sentCodeTypeEmailCode": function(w, v) {
      w.uint(4098946459);
      var flags = 0;
      if (v.appleSigninAllowed === true)
        flags |= 1;
      if (v.googleSigninAllowed === true)
        flags |= 2;
      var _resetAvailablePeriod = v.resetAvailablePeriod !== void 0;
      if (_resetAvailablePeriod)
        flags |= 8;
      var _resetPendingDate = v.resetPendingDate !== void 0;
      if (_resetPendingDate)
        flags |= 16;
      w.uint(flags);
      w.string(h(v, "emailPattern"));
      w.int(h(v, "length"));
      if (_resetAvailablePeriod)
        w.int(v.resetAvailablePeriod);
      if (_resetPendingDate)
        w.int(v.resetPendingDate);
    },
    "auth.sentCodeTypeSetUpEmailRequired": function(w, v) {
      w.uint(2773032426);
      var flags = 0;
      if (v.appleSigninAllowed === true)
        flags |= 1;
      if (v.googleSigninAllowed === true)
        flags |= 2;
      w.uint(flags);
    },
    "auth.sentCodeTypeFragmentSms": function(w, v) {
      w.uint(3646315577);
      w.string(h(v, "url"));
      w.int(h(v, "length"));
    },
    "auth.sentCodeTypeFirebaseSms": function(w, v) {
      w.uint(10475318);
      var flags = 0;
      var _nonce = v.nonce !== void 0;
      if (_nonce)
        flags |= 1;
      var _receipt = v.receipt !== void 0;
      var _pushTimeout = v.pushTimeout !== void 0;
      var _flags_1 = _receipt || _pushTimeout;
      if (_flags_1)
        flags |= 2;
      var _playIntegrityProjectId = v.playIntegrityProjectId !== void 0;
      var _playIntegrityNonce = v.playIntegrityNonce !== void 0;
      var _flags_2 = _playIntegrityProjectId || _playIntegrityNonce;
      if (_flags_2)
        flags |= 4;
      w.uint(flags);
      if (_nonce)
        w.bytes(v.nonce);
      if (_flags_2)
        w.long(v.playIntegrityProjectId);
      if (_flags_2)
        w.bytes(v.playIntegrityNonce);
      if (_flags_1)
        w.string(v.receipt);
      if (_flags_1)
        w.int(v.pushTimeout);
      w.int(h(v, "length"));
    },
    "auth.sentCodeTypeSmsWord": function(w, v) {
      w.uint(2752949377);
      var flags = 0;
      var _beginning = v.beginning !== void 0;
      if (_beginning)
        flags |= 1;
      w.uint(flags);
      if (_beginning)
        w.string(v.beginning);
    },
    "auth.sentCodeTypeSmsPhrase": function(w, v) {
      w.uint(3010958511);
      var flags = 0;
      var _beginning = v.beginning !== void 0;
      if (_beginning)
        flags |= 1;
      w.uint(flags);
      if (_beginning)
        w.string(v.beginning);
    },
    "messages.botCallbackAnswer": function(w, v) {
      w.uint(911761060);
      var flags = 0;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 1;
      if (v.alert === true)
        flags |= 2;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 4;
      if (v.hasUrl === true)
        flags |= 8;
      if (v.nativeUi === true)
        flags |= 16;
      w.uint(flags);
      if (_message)
        w.string(v.message);
      if (_url)
        w.string(v.url);
      w.int(h(v, "cacheTime"));
    },
    "messages.messageEditData": function(w, v) {
      w.uint(649453030);
      var flags = 0;
      if (v.caption === true)
        flags |= 1;
      w.uint(flags);
    },
    "inputBotInlineMessageID": function(w, v) {
      w.uint(2299280777);
      w.int(h(v, "dcId"));
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputBotInlineMessageID64": function(w, v) {
      w.uint(3067680215);
      w.int(h(v, "dcId"));
      w.long(h(v, "ownerId"));
      w.int(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inlineBotSwitchPM": function(w, v) {
      w.uint(1008755359);
      w.string(h(v, "text"));
      w.string(h(v, "startParam"));
    },
    "messages.peerDialogs": function(w, v) {
      w.uint(863093588);
      w.vector(w.object, h(v, "dialogs"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      w.object(h(v, "state"));
    },
    "topPeer": function(w, v) {
      w.uint(3989684315);
      w.object(h(v, "peer"));
      w.double(h(v, "rating"));
    },
    "topPeerCategoryBotsPM": function(w) {
      w.uint(2875595611);
    },
    "topPeerCategoryBotsInline": function(w) {
      w.uint(344356834);
    },
    "topPeerCategoryCorrespondents": function(w) {
      w.uint(104314861);
    },
    "topPeerCategoryGroups": function(w) {
      w.uint(3172442442);
    },
    "topPeerCategoryChannels": function(w) {
      w.uint(371037736);
    },
    "topPeerCategoryPhoneCalls": function(w) {
      w.uint(511092620);
    },
    "topPeerCategoryForwardUsers": function(w) {
      w.uint(2822794409);
    },
    "topPeerCategoryForwardChats": function(w) {
      w.uint(4226728176);
    },
    "topPeerCategoryBotsApp": function(w) {
      w.uint(4255022060);
    },
    "topPeerCategoryPeers": function(w, v) {
      w.uint(4219683473);
      w.object(h(v, "category"));
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "peers"));
    },
    "contacts.topPeersNotModified": function(w) {
      w.uint(3727060725);
    },
    "contacts.topPeers": function(w, v) {
      w.uint(1891070632);
      w.vector(w.object, h(v, "categories"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "contacts.topPeersDisabled": function(w) {
      w.uint(3039597469);
    },
    "draftMessageEmpty": function(w, v) {
      w.uint(453805082);
      var flags = 0;
      var _date = v.date !== void 0;
      if (_date)
        flags |= 1;
      w.uint(flags);
      if (_date)
        w.int(v.date);
    },
    "draftMessage": function(w, v) {
      w.uint(761606687);
      var flags = 0;
      if (v.noWebpage === true)
        flags |= 2;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 8;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 16;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 32;
      if (v.invertMedia === true)
        flags |= 64;
      var _effect = v.effect !== void 0;
      if (_effect)
        flags |= 128;
      w.uint(flags);
      if (_replyTo)
        w.object(v.replyTo);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_media)
        w.object(v.media);
      w.int(h(v, "date"));
      if (_effect)
        w.long(v.effect);
    },
    "messages.featuredStickersNotModified": function(w, v) {
      w.uint(3336309862);
      w.int(h(v, "count"));
    },
    "messages.featuredStickers": function(w, v) {
      w.uint(3191351558);
      var flags = 0;
      if (v.premium === true)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "hash"));
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "sets"));
      w.vector(w.long, h(v, "unread"));
    },
    "messages.recentStickersNotModified": function(w) {
      w.uint(186120336);
    },
    "messages.recentStickers": function(w, v) {
      w.uint(2295561302);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "packs"));
      w.vector(w.object, h(v, "stickers"));
      w.vector(w.int, h(v, "dates"));
    },
    "messages.archivedStickers": function(w, v) {
      w.uint(1338747336);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "sets"));
    },
    "messages.stickerSetInstallResultSuccess": function(w) {
      w.uint(946083368);
    },
    "messages.stickerSetInstallResultArchive": function(w, v) {
      w.uint(904138920);
      w.vector(w.object, h(v, "sets"));
    },
    "stickerSetCovered": function(w, v) {
      w.uint(1678812626);
      w.object(h(v, "set"));
      w.object(h(v, "cover"));
    },
    "stickerSetMultiCovered": function(w, v) {
      w.uint(872932635);
      w.object(h(v, "set"));
      w.vector(w.object, h(v, "covers"));
    },
    "stickerSetFullCovered": function(w, v) {
      w.uint(1087454222);
      w.object(h(v, "set"));
      w.vector(w.object, h(v, "packs"));
      w.vector(w.object, h(v, "keywords"));
      w.vector(w.object, h(v, "documents"));
    },
    "stickerSetNoCovered": function(w, v) {
      w.uint(2008112412);
      w.object(h(v, "set"));
    },
    "maskCoords": function(w, v) {
      w.uint(2933316530);
      w.int(h(v, "n"));
      w.double(h(v, "x"));
      w.double(h(v, "y"));
      w.double(h(v, "zoom"));
    },
    "inputStickeredMediaPhoto": function(w, v) {
      w.uint(1251549527);
      w.object(h(v, "id"));
    },
    "inputStickeredMediaDocument": function(w, v) {
      w.uint(70813275);
      w.object(h(v, "id"));
    },
    "game": function(w, v) {
      w.uint(3187238203);
      var flags = 0;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.string(h(v, "shortName"));
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      w.object(h(v, "photo"));
      if (_document)
        w.object(v.document);
    },
    "inputGameID": function(w, v) {
      w.uint(53231223);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputGameShortName": function(w, v) {
      w.uint(3274827786);
      w.object(h(v, "botId"));
      w.string(h(v, "shortName"));
    },
    "highScore": function(w, v) {
      w.uint(1940093419);
      w.int(h(v, "pos"));
      w.int53(h(v, "userId"));
      w.int(h(v, "score"));
    },
    "messages.highScores": function(w, v) {
      w.uint(2587622809);
      w.vector(w.object, h(v, "scores"));
      w.vector(w.object, h(v, "users"));
    },
    "textEmpty": function(w) {
      w.uint(3695018575);
    },
    "textPlain": function(w, v) {
      w.uint(1950782688);
      w.string(h(v, "text"));
    },
    "textBold": function(w, v) {
      w.uint(1730456516);
      w.object(h(v, "text"));
    },
    "textItalic": function(w, v) {
      w.uint(3641877916);
      w.object(h(v, "text"));
    },
    "textUnderline": function(w, v) {
      w.uint(3240501956);
      w.object(h(v, "text"));
    },
    "textStrike": function(w, v) {
      w.uint(2616769429);
      w.object(h(v, "text"));
    },
    "textFixed": function(w, v) {
      w.uint(1816074681);
      w.object(h(v, "text"));
    },
    "textUrl": function(w, v) {
      w.uint(1009288385);
      w.object(h(v, "text"));
      w.string(h(v, "url"));
      w.long(h(v, "webpageId"));
    },
    "textEmail": function(w, v) {
      w.uint(3730443734);
      w.object(h(v, "text"));
      w.string(h(v, "email"));
    },
    "textConcat": function(w, v) {
      w.uint(2120376535);
      w.vector(w.object, h(v, "texts"));
    },
    "textSubscript": function(w, v) {
      w.uint(3983181060);
      w.object(h(v, "text"));
    },
    "textSuperscript": function(w, v) {
      w.uint(3355139585);
      w.object(h(v, "text"));
    },
    "textMarked": function(w, v) {
      w.uint(55281185);
      w.object(h(v, "text"));
    },
    "textPhone": function(w, v) {
      w.uint(483104362);
      w.object(h(v, "text"));
      w.string(h(v, "phone"));
    },
    "textImage": function(w, v) {
      w.uint(136105807);
      w.long(h(v, "documentId"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
    },
    "textAnchor": function(w, v) {
      w.uint(894777186);
      w.object(h(v, "text"));
      w.string(h(v, "name"));
    },
    "pageBlockUnsupported": function(w) {
      w.uint(324435594);
    },
    "pageBlockTitle": function(w, v) {
      w.uint(1890305021);
      w.object(h(v, "text"));
    },
    "pageBlockSubtitle": function(w, v) {
      w.uint(2415565343);
      w.object(h(v, "text"));
    },
    "pageBlockAuthorDate": function(w, v) {
      w.uint(3132089824);
      w.object(h(v, "author"));
      w.int(h(v, "publishedDate"));
    },
    "pageBlockHeader": function(w, v) {
      w.uint(3218105580);
      w.object(h(v, "text"));
    },
    "pageBlockSubheader": function(w, v) {
      w.uint(4046173921);
      w.object(h(v, "text"));
    },
    "pageBlockParagraph": function(w, v) {
      w.uint(1182402406);
      w.object(h(v, "text"));
    },
    "pageBlockPreformatted": function(w, v) {
      w.uint(3228621118);
      w.object(h(v, "text"));
      w.string(h(v, "language"));
    },
    "pageBlockFooter": function(w, v) {
      w.uint(1216809369);
      w.object(h(v, "text"));
    },
    "pageBlockDivider": function(w) {
      w.uint(3676352904);
    },
    "pageBlockAnchor": function(w, v) {
      w.uint(3456972720);
      w.string(h(v, "name"));
    },
    "pageBlockList": function(w, v) {
      w.uint(3840442385);
      w.vector(w.object, h(v, "items"));
    },
    "pageBlockBlockquote": function(w, v) {
      w.uint(641563686);
      w.object(h(v, "text"));
      w.object(h(v, "caption"));
    },
    "pageBlockPullquote": function(w, v) {
      w.uint(1329878739);
      w.object(h(v, "text"));
      w.object(h(v, "caption"));
    },
    "pageBlockPhoto": function(w, v) {
      w.uint(391759200);
      var flags = 0;
      var _url = v.url !== void 0;
      var _webpageId = v.webpageId !== void 0;
      var _flags_0 = _url || _webpageId;
      if (_flags_0)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "photoId"));
      w.object(h(v, "caption"));
      if (_flags_0)
        w.string(v.url);
      if (_flags_0)
        w.long(v.webpageId);
    },
    "pageBlockVideo": function(w, v) {
      w.uint(2089805750);
      var flags = 0;
      if (v.autoplay === true)
        flags |= 1;
      if (v.loop === true)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "videoId"));
      w.object(h(v, "caption"));
    },
    "pageBlockCover": function(w, v) {
      w.uint(972174080);
      w.object(h(v, "cover"));
    },
    "pageBlockEmbed": function(w, v) {
      w.uint(2826014149);
      var flags = 0;
      if (v.fullWidth === true)
        flags |= 1;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 2;
      var _html = v.html !== void 0;
      if (_html)
        flags |= 4;
      if (v.allowScrolling === true)
        flags |= 8;
      var _posterPhotoId = v.posterPhotoId !== void 0;
      if (_posterPhotoId)
        flags |= 16;
      var _w = v.w !== void 0;
      var _h = v.h !== void 0;
      var _flags_5 = _w || _h;
      if (_flags_5)
        flags |= 32;
      w.uint(flags);
      if (_url)
        w.string(v.url);
      if (_html)
        w.string(v.html);
      if (_posterPhotoId)
        w.long(v.posterPhotoId);
      if (_flags_5)
        w.int(v.w);
      if (_flags_5)
        w.int(v.h);
      w.object(h(v, "caption"));
    },
    "pageBlockEmbedPost": function(w, v) {
      w.uint(4065961995);
      w.string(h(v, "url"));
      w.long(h(v, "webpageId"));
      w.long(h(v, "authorPhotoId"));
      w.string(h(v, "author"));
      w.int(h(v, "date"));
      w.vector(w.object, h(v, "blocks"));
      w.object(h(v, "caption"));
    },
    "pageBlockCollage": function(w, v) {
      w.uint(1705048653);
      w.vector(w.object, h(v, "items"));
      w.object(h(v, "caption"));
    },
    "pageBlockSlideshow": function(w, v) {
      w.uint(52401552);
      w.vector(w.object, h(v, "items"));
      w.object(h(v, "caption"));
    },
    "pageBlockChannel": function(w, v) {
      w.uint(4011282869);
      w.object(h(v, "channel"));
    },
    "pageBlockAudio": function(w, v) {
      w.uint(2151899626);
      w.long(h(v, "audioId"));
      w.object(h(v, "caption"));
    },
    "pageBlockKicker": function(w, v) {
      w.uint(504660880);
      w.object(h(v, "text"));
    },
    "pageBlockTable": function(w, v) {
      w.uint(3209554562);
      var flags = 0;
      if (v.bordered === true)
        flags |= 1;
      if (v.striped === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "title"));
      w.vector(w.object, h(v, "rows"));
    },
    "pageBlockOrderedList": function(w, v) {
      w.uint(2592793057);
      w.vector(w.object, h(v, "items"));
    },
    "pageBlockDetails": function(w, v) {
      w.uint(1987480557);
      var flags = 0;
      if (v.open === true)
        flags |= 1;
      w.uint(flags);
      w.vector(w.object, h(v, "blocks"));
      w.object(h(v, "title"));
    },
    "pageBlockRelatedArticles": function(w, v) {
      w.uint(370236054);
      w.object(h(v, "title"));
      w.vector(w.object, h(v, "articles"));
    },
    "pageBlockMap": function(w, v) {
      w.uint(2756656886);
      w.object(h(v, "geo"));
      w.int(h(v, "zoom"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
      w.object(h(v, "caption"));
    },
    "phoneCallDiscardReasonMissed": function(w) {
      w.uint(2246320897);
    },
    "phoneCallDiscardReasonDisconnect": function(w) {
      w.uint(3767910816);
    },
    "phoneCallDiscardReasonHangup": function(w) {
      w.uint(1471006352);
    },
    "phoneCallDiscardReasonBusy": function(w) {
      w.uint(4210550985);
    },
    "dataJSON": function(w, v) {
      w.uint(2104790276);
      w.string(h(v, "data"));
    },
    "labeledPrice": function(w, v) {
      w.uint(3408489464);
      w.string(h(v, "label"));
      w.long(h(v, "amount"));
    },
    "invoice": function(w, v) {
      w.uint(1572428309);
      var flags = 0;
      if (v.test === true)
        flags |= 1;
      if (v.nameRequested === true)
        flags |= 2;
      if (v.phoneRequested === true)
        flags |= 4;
      if (v.emailRequested === true)
        flags |= 8;
      if (v.shippingAddressRequested === true)
        flags |= 16;
      if (v.flexible === true)
        flags |= 32;
      if (v.phoneToProvider === true)
        flags |= 64;
      if (v.emailToProvider === true)
        flags |= 128;
      var _maxTipAmount = v.maxTipAmount !== void 0;
      var _suggestedTipAmounts = v.suggestedTipAmounts && v.suggestedTipAmounts.length;
      var _flags_8 = _maxTipAmount || _suggestedTipAmounts;
      if (_flags_8)
        flags |= 256;
      if (v.recurring === true)
        flags |= 512;
      var _termsUrl = v.termsUrl !== void 0;
      if (_termsUrl)
        flags |= 1024;
      w.uint(flags);
      w.string(h(v, "currency"));
      w.vector(w.object, h(v, "prices"));
      if (_flags_8)
        w.long(v.maxTipAmount);
      if (_flags_8)
        w.vector(w.long, v.suggestedTipAmounts);
      if (_termsUrl)
        w.string(v.termsUrl);
    },
    "paymentCharge": function(w, v) {
      w.uint(3926049406);
      w.string(h(v, "id"));
      w.string(h(v, "providerChargeId"));
    },
    "postAddress": function(w, v) {
      w.uint(512535275);
      w.string(h(v, "streetLine1"));
      w.string(h(v, "streetLine2"));
      w.string(h(v, "city"));
      w.string(h(v, "state"));
      w.string(h(v, "countryIso2"));
      w.string(h(v, "postCode"));
    },
    "paymentRequestedInfo": function(w, v) {
      w.uint(2426158996);
      var flags = 0;
      var _name = v.name !== void 0;
      if (_name)
        flags |= 1;
      var _phone = v.phone !== void 0;
      if (_phone)
        flags |= 2;
      var _email = v.email !== void 0;
      if (_email)
        flags |= 4;
      var _shippingAddress = v.shippingAddress !== void 0;
      if (_shippingAddress)
        flags |= 8;
      w.uint(flags);
      if (_name)
        w.string(v.name);
      if (_phone)
        w.string(v.phone);
      if (_email)
        w.string(v.email);
      if (_shippingAddress)
        w.object(v.shippingAddress);
    },
    "paymentSavedCredentialsCard": function(w, v) {
      w.uint(3452074527);
      w.string(h(v, "id"));
      w.string(h(v, "title"));
    },
    "webDocument": function(w, v) {
      w.uint(475467473);
      w.string(h(v, "url"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "size"));
      w.string(h(v, "mimeType"));
      w.vector(w.object, h(v, "attributes"));
    },
    "webDocumentNoProxy": function(w, v) {
      w.uint(4190682310);
      w.string(h(v, "url"));
      w.int(h(v, "size"));
      w.string(h(v, "mimeType"));
      w.vector(w.object, h(v, "attributes"));
    },
    "inputWebDocument": function(w, v) {
      w.uint(2616017741);
      w.string(h(v, "url"));
      w.int(h(v, "size"));
      w.string(h(v, "mimeType"));
      w.vector(w.object, h(v, "attributes"));
    },
    "inputWebFileLocation": function(w, v) {
      w.uint(3258570374);
      w.string(h(v, "url"));
      w.long(h(v, "accessHash"));
    },
    "inputWebFileGeoPointLocation": function(w, v) {
      w.uint(2669814217);
      w.object(h(v, "geoPoint"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
      w.int(h(v, "zoom"));
      w.int(h(v, "scale"));
    },
    "inputWebFileAudioAlbumThumbLocation": function(w, v) {
      w.uint(4100974884);
      var flags = 0;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 1;
      var _title = v.title !== void 0;
      var _performer = v.performer !== void 0;
      var _flags_1 = _title || _performer;
      if (_flags_1)
        flags |= 2;
      if (v.small === true)
        flags |= 4;
      w.uint(flags);
      if (_document)
        w.object(v.document);
      if (_flags_1)
        w.string(v.title);
      if (_flags_1)
        w.string(v.performer);
    },
    "upload.webFile": function(w, v) {
      w.uint(568808380);
      w.int(h(v, "size"));
      w.string(h(v, "mimeType"));
      w.object(h(v, "fileType"));
      w.int(h(v, "mtime"));
      w.bytes(h(v, "bytes"));
    },
    "payments.paymentForm": function(w, v) {
      w.uint(2684716881);
      var flags = 0;
      var _savedInfo = v.savedInfo !== void 0;
      if (_savedInfo)
        flags |= 1;
      var _savedCredentials = v.savedCredentials && v.savedCredentials.length;
      if (_savedCredentials)
        flags |= 2;
      if (v.canSaveCredentials === true)
        flags |= 4;
      if (v.passwordMissing === true)
        flags |= 8;
      var _nativeProvider = v.nativeProvider !== void 0;
      var _nativeParams = v.nativeParams !== void 0;
      var _flags_4 = _nativeProvider || _nativeParams;
      if (_flags_4)
        flags |= 16;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 32;
      var _additionalMethods = v.additionalMethods && v.additionalMethods.length;
      if (_additionalMethods)
        flags |= 64;
      w.uint(flags);
      w.long(h(v, "formId"));
      w.int53(h(v, "botId"));
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      w.object(h(v, "invoice"));
      w.long(h(v, "providerId"));
      w.string(h(v, "url"));
      if (_flags_4)
        w.string(v.nativeProvider);
      if (_flags_4)
        w.object(v.nativeParams);
      if (_additionalMethods)
        w.vector(w.object, v.additionalMethods);
      if (_savedInfo)
        w.object(v.savedInfo);
      if (_savedCredentials)
        w.vector(w.object, v.savedCredentials);
      w.vector(w.object, h(v, "users"));
    },
    "payments.paymentFormStars": function(w, v) {
      w.uint(2079764828);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 32;
      w.uint(flags);
      w.long(h(v, "formId"));
      w.int53(h(v, "botId"));
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      w.object(h(v, "invoice"));
      w.vector(w.object, h(v, "users"));
    },
    "payments.paymentFormStarGift": function(w, v) {
      w.uint(3022376929);
      w.long(h(v, "formId"));
      w.object(h(v, "invoice"));
    },
    "payments.validatedRequestedInfo": function(w, v) {
      w.uint(3510966403);
      var flags = 0;
      var _id = v.id !== void 0;
      if (_id)
        flags |= 1;
      var _shippingOptions = v.shippingOptions && v.shippingOptions.length;
      if (_shippingOptions)
        flags |= 2;
      w.uint(flags);
      if (_id)
        w.string(v.id);
      if (_shippingOptions)
        w.vector(w.object, v.shippingOptions);
    },
    "payments.paymentResult": function(w, v) {
      w.uint(1314881805);
      w.object(h(v, "updates"));
    },
    "payments.paymentVerificationNeeded": function(w, v) {
      w.uint(3628142905);
      w.string(h(v, "url"));
    },
    "payments.paymentReceipt": function(w, v) {
      w.uint(1891958275);
      var flags = 0;
      var _info = v.info !== void 0;
      if (_info)
        flags |= 1;
      var _shipping = v.shipping !== void 0;
      if (_shipping)
        flags |= 2;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 4;
      var _tipAmount = v.tipAmount !== void 0;
      if (_tipAmount)
        flags |= 8;
      w.uint(flags);
      w.int(h(v, "date"));
      w.int53(h(v, "botId"));
      w.long(h(v, "providerId"));
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      w.object(h(v, "invoice"));
      if (_info)
        w.object(v.info);
      if (_shipping)
        w.object(v.shipping);
      if (_tipAmount)
        w.long(v.tipAmount);
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
      w.string(h(v, "credentialsTitle"));
      w.vector(w.object, h(v, "users"));
    },
    "payments.paymentReceiptStars": function(w, v) {
      w.uint(3669751866);
      var flags = 0;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 4;
      w.uint(flags);
      w.int(h(v, "date"));
      w.int53(h(v, "botId"));
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_photo)
        w.object(v.photo);
      w.object(h(v, "invoice"));
      w.string(h(v, "currency"));
      w.long(h(v, "totalAmount"));
      w.string(h(v, "transactionId"));
      w.vector(w.object, h(v, "users"));
    },
    "payments.savedInfo": function(w, v) {
      w.uint(4220511292);
      var flags = 0;
      var _savedInfo = v.savedInfo !== void 0;
      if (_savedInfo)
        flags |= 1;
      if (v.hasSavedCredentials === true)
        flags |= 2;
      w.uint(flags);
      if (_savedInfo)
        w.object(v.savedInfo);
    },
    "inputPaymentCredentialsSaved": function(w, v) {
      w.uint(3238965967);
      w.string(h(v, "id"));
      w.bytes(h(v, "tmpPassword"));
    },
    "inputPaymentCredentials": function(w, v) {
      w.uint(873977640);
      var flags = 0;
      if (v.save === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "data"));
    },
    "inputPaymentCredentialsApplePay": function(w, v) {
      w.uint(178373535);
      w.object(h(v, "paymentData"));
    },
    "inputPaymentCredentialsGooglePay": function(w, v) {
      w.uint(2328045569);
      w.object(h(v, "paymentToken"));
    },
    "account.tmpPassword": function(w, v) {
      w.uint(3680828724);
      w.bytes(h(v, "tmpPassword"));
      w.int(h(v, "validUntil"));
    },
    "shippingOption": function(w, v) {
      w.uint(3055631583);
      w.string(h(v, "id"));
      w.string(h(v, "title"));
      w.vector(w.object, h(v, "prices"));
    },
    "inputStickerSetItem": function(w, v) {
      w.uint(853188252);
      var flags = 0;
      var _maskCoords = v.maskCoords !== void 0;
      if (_maskCoords)
        flags |= 1;
      var _keywords = v.keywords !== void 0;
      if (_keywords)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "document"));
      w.string(h(v, "emoji"));
      if (_maskCoords)
        w.object(v.maskCoords);
      if (_keywords)
        w.string(v.keywords);
    },
    "inputPhoneCall": function(w, v) {
      w.uint(506920429);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "phoneCallEmpty": function(w, v) {
      w.uint(1399245077);
      w.long(h(v, "id"));
    },
    "phoneCallWaiting": function(w, v) {
      w.uint(3307368215);
      var flags = 0;
      var _receiveDate = v.receiveDate !== void 0;
      if (_receiveDate)
        flags |= 1;
      if (v.video === true)
        flags |= 64;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "date"));
      w.int53(h(v, "adminId"));
      w.int53(h(v, "participantId"));
      w.object(h(v, "protocol"));
      if (_receiveDate)
        w.int(v.receiveDate);
    },
    "phoneCallRequested": function(w, v) {
      w.uint(347139340);
      var flags = 0;
      if (v.video === true)
        flags |= 64;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "date"));
      w.int53(h(v, "adminId"));
      w.int53(h(v, "participantId"));
      w.bytes(h(v, "gAHash"));
      w.object(h(v, "protocol"));
    },
    "phoneCallAccepted": function(w, v) {
      w.uint(912311057);
      var flags = 0;
      if (v.video === true)
        flags |= 64;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "date"));
      w.int53(h(v, "adminId"));
      w.int53(h(v, "participantId"));
      w.bytes(h(v, "gB"));
      w.object(h(v, "protocol"));
    },
    "phoneCall": function(w, v) {
      w.uint(810769141);
      var flags = 0;
      if (v.p2pAllowed === true)
        flags |= 32;
      if (v.video === true)
        flags |= 64;
      var _customParameters = v.customParameters !== void 0;
      if (_customParameters)
        flags |= 128;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "date"));
      w.int53(h(v, "adminId"));
      w.int53(h(v, "participantId"));
      w.bytes(h(v, "gAOrB"));
      w.long(h(v, "keyFingerprint"));
      w.object(h(v, "protocol"));
      w.vector(w.object, h(v, "connections"));
      w.int(h(v, "startDate"));
      if (_customParameters)
        w.object(v.customParameters);
    },
    "phoneCallDiscarded": function(w, v) {
      w.uint(1355435489);
      var flags = 0;
      var _reason = v.reason !== void 0;
      if (_reason)
        flags |= 1;
      var _duration = v.duration !== void 0;
      if (_duration)
        flags |= 2;
      if (v.needRating === true)
        flags |= 4;
      if (v.needDebug === true)
        flags |= 8;
      if (v.video === true)
        flags |= 64;
      w.uint(flags);
      w.long(h(v, "id"));
      if (_reason)
        w.object(v.reason);
      if (_duration)
        w.int(v.duration);
    },
    "phoneConnection": function(w, v) {
      w.uint(2629903303);
      var flags = 0;
      if (v.tcp === true)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "id"));
      w.string(h(v, "ip"));
      w.string(h(v, "ipv6"));
      w.int(h(v, "port"));
      w.bytes(h(v, "peerTag"));
    },
    "phoneConnectionWebrtc": function(w, v) {
      w.uint(1667228533);
      var flags = 0;
      if (v.turn === true)
        flags |= 1;
      if (v.stun === true)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "id"));
      w.string(h(v, "ip"));
      w.string(h(v, "ipv6"));
      w.int(h(v, "port"));
      w.string(h(v, "username"));
      w.string(h(v, "password"));
    },
    "phoneCallProtocol": function(w, v) {
      w.uint(4236742600);
      var flags = 0;
      if (v.udpP2p === true)
        flags |= 1;
      if (v.udpReflector === true)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "minLayer"));
      w.int(h(v, "maxLayer"));
      w.vector(w.string, h(v, "libraryVersions"));
    },
    "phone.phoneCall": function(w, v) {
      w.uint(3968000320);
      w.object(h(v, "phoneCall"));
      w.vector(w.object, h(v, "users"));
    },
    "upload.cdnFileReuploadNeeded": function(w, v) {
      w.uint(4004045934);
      w.bytes(h(v, "requestToken"));
    },
    "upload.cdnFile": function(w, v) {
      w.uint(2845821519);
      w.bytes(h(v, "bytes"));
    },
    "cdnPublicKey": function(w, v) {
      w.uint(3380800186);
      w.int(h(v, "dcId"));
      w.string(h(v, "publicKey"));
    },
    "cdnConfig": function(w, v) {
      w.uint(1462101002);
      w.vector(w.object, h(v, "publicKeys"));
    },
    "langPackString": function(w, v) {
      w.uint(3402727926);
      w.string(h(v, "key"));
      w.string(h(v, "value"));
    },
    "langPackStringPluralized": function(w, v) {
      w.uint(1816636575);
      var flags = 0;
      var _zeroValue = v.zeroValue !== void 0;
      if (_zeroValue)
        flags |= 1;
      var _oneValue = v.oneValue !== void 0;
      if (_oneValue)
        flags |= 2;
      var _twoValue = v.twoValue !== void 0;
      if (_twoValue)
        flags |= 4;
      var _fewValue = v.fewValue !== void 0;
      if (_fewValue)
        flags |= 8;
      var _manyValue = v.manyValue !== void 0;
      if (_manyValue)
        flags |= 16;
      w.uint(flags);
      w.string(h(v, "key"));
      if (_zeroValue)
        w.string(v.zeroValue);
      if (_oneValue)
        w.string(v.oneValue);
      if (_twoValue)
        w.string(v.twoValue);
      if (_fewValue)
        w.string(v.fewValue);
      if (_manyValue)
        w.string(v.manyValue);
      w.string(h(v, "otherValue"));
    },
    "langPackStringDeleted": function(w, v) {
      w.uint(695856818);
      w.string(h(v, "key"));
    },
    "langPackDifference": function(w, v) {
      w.uint(4085629430);
      w.string(h(v, "langCode"));
      w.int(h(v, "fromVersion"));
      w.int(h(v, "version"));
      w.vector(w.object, h(v, "strings"));
    },
    "langPackLanguage": function(w, v) {
      w.uint(4006239459);
      var flags = 0;
      if (v.official === true)
        flags |= 1;
      var _baseLangCode = v.baseLangCode !== void 0;
      if (_baseLangCode)
        flags |= 2;
      if (v.rtl === true)
        flags |= 4;
      if (v.beta === true)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "name"));
      w.string(h(v, "nativeName"));
      w.string(h(v, "langCode"));
      if (_baseLangCode)
        w.string(v.baseLangCode);
      w.string(h(v, "pluralCode"));
      w.int(h(v, "stringsCount"));
      w.int(h(v, "translatedCount"));
      w.string(h(v, "translationsUrl"));
    },
    "channelAdminLogEventActionChangeTitle": function(w, v) {
      w.uint(3873421349);
      w.string(h(v, "prevValue"));
      w.string(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeAbout": function(w, v) {
      w.uint(1427671598);
      w.string(h(v, "prevValue"));
      w.string(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeUsername": function(w, v) {
      w.uint(1783299128);
      w.string(h(v, "prevValue"));
      w.string(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangePhoto": function(w, v) {
      w.uint(1129042607);
      w.object(h(v, "prevPhoto"));
      w.object(h(v, "newPhoto"));
    },
    "channelAdminLogEventActionToggleInvites": function(w, v) {
      w.uint(460916654);
      w.boolean(h(v, "newValue"));
    },
    "channelAdminLogEventActionToggleSignatures": function(w, v) {
      w.uint(648939889);
      w.boolean(h(v, "newValue"));
    },
    "channelAdminLogEventActionUpdatePinned": function(w, v) {
      w.uint(3924306968);
      w.object(h(v, "message"));
    },
    "channelAdminLogEventActionEditMessage": function(w, v) {
      w.uint(1889215493);
      w.object(h(v, "prevMessage"));
      w.object(h(v, "newMessage"));
    },
    "channelAdminLogEventActionDeleteMessage": function(w, v) {
      w.uint(1121994683);
      w.object(h(v, "message"));
    },
    "channelAdminLogEventActionParticipantJoin": function(w) {
      w.uint(405815507);
    },
    "channelAdminLogEventActionParticipantLeave": function(w) {
      w.uint(4170676210);
    },
    "channelAdminLogEventActionParticipantInvite": function(w, v) {
      w.uint(3810276568);
      w.object(h(v, "participant"));
    },
    "channelAdminLogEventActionParticipantToggleBan": function(w, v) {
      w.uint(3872931198);
      w.object(h(v, "prevParticipant"));
      w.object(h(v, "newParticipant"));
    },
    "channelAdminLogEventActionParticipantToggleAdmin": function(w, v) {
      w.uint(3580323600);
      w.object(h(v, "prevParticipant"));
      w.object(h(v, "newParticipant"));
    },
    "channelAdminLogEventActionChangeStickerSet": function(w, v) {
      w.uint(2982398631);
      w.object(h(v, "prevStickerset"));
      w.object(h(v, "newStickerset"));
    },
    "channelAdminLogEventActionTogglePreHistoryHidden": function(w, v) {
      w.uint(1599903217);
      w.boolean(h(v, "newValue"));
    },
    "channelAdminLogEventActionDefaultBannedRights": function(w, v) {
      w.uint(771095562);
      w.object(h(v, "prevBannedRights"));
      w.object(h(v, "newBannedRights"));
    },
    "channelAdminLogEventActionStopPoll": function(w, v) {
      w.uint(2399639107);
      w.object(h(v, "message"));
    },
    "channelAdminLogEventActionChangeLinkedChat": function(w, v) {
      w.uint(84703944);
      w.int53(h(v, "prevValue"));
      w.int53(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeLocation": function(w, v) {
      w.uint(241923758);
      w.object(h(v, "prevValue"));
      w.object(h(v, "newValue"));
    },
    "channelAdminLogEventActionToggleSlowMode": function(w, v) {
      w.uint(1401984889);
      w.int(h(v, "prevValue"));
      w.int(h(v, "newValue"));
    },
    "channelAdminLogEventActionStartGroupCall": function(w, v) {
      w.uint(589338437);
      w.object(h(v, "call"));
    },
    "channelAdminLogEventActionDiscardGroupCall": function(w, v) {
      w.uint(3684667712);
      w.object(h(v, "call"));
    },
    "channelAdminLogEventActionParticipantMute": function(w, v) {
      w.uint(4179895506);
      w.object(h(v, "participant"));
    },
    "channelAdminLogEventActionParticipantUnmute": function(w, v) {
      w.uint(3863226816);
      w.object(h(v, "participant"));
    },
    "channelAdminLogEventActionToggleGroupCallSetting": function(w, v) {
      w.uint(1456906823);
      w.boolean(h(v, "joinMuted"));
    },
    "channelAdminLogEventActionParticipantJoinByInvite": function(w, v) {
      w.uint(4271882584);
      var flags = 0;
      if (v.viaChatlist === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "invite"));
    },
    "channelAdminLogEventActionExportedInviteDelete": function(w, v) {
      w.uint(1515256996);
      w.object(h(v, "invite"));
    },
    "channelAdminLogEventActionExportedInviteRevoke": function(w, v) {
      w.uint(1091179342);
      w.object(h(v, "invite"));
    },
    "channelAdminLogEventActionExportedInviteEdit": function(w, v) {
      w.uint(3910056793);
      w.object(h(v, "prevInvite"));
      w.object(h(v, "newInvite"));
    },
    "channelAdminLogEventActionParticipantVolume": function(w, v) {
      w.uint(1048537159);
      w.object(h(v, "participant"));
    },
    "channelAdminLogEventActionChangeHistoryTTL": function(w, v) {
      w.uint(1855199800);
      w.int(h(v, "prevValue"));
      w.int(h(v, "newValue"));
    },
    "channelAdminLogEventActionParticipantJoinByRequest": function(w, v) {
      w.uint(2947945546);
      w.object(h(v, "invite"));
      w.int53(h(v, "approvedBy"));
    },
    "channelAdminLogEventActionToggleNoForwards": function(w, v) {
      w.uint(3408578406);
      w.boolean(h(v, "newValue"));
    },
    "channelAdminLogEventActionSendMessage": function(w, v) {
      w.uint(663693416);
      w.object(h(v, "message"));
    },
    "channelAdminLogEventActionChangeAvailableReactions": function(w, v) {
      w.uint(3192786680);
      w.object(h(v, "prevValue"));
      w.object(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeUsernames": function(w, v) {
      w.uint(4031755177);
      w.vector(w.string, h(v, "prevValue"));
      w.vector(w.string, h(v, "newValue"));
    },
    "channelAdminLogEventActionToggleForum": function(w, v) {
      w.uint(46949251);
      w.boolean(h(v, "newValue"));
    },
    "channelAdminLogEventActionCreateTopic": function(w, v) {
      w.uint(1483767080);
      w.object(h(v, "topic"));
    },
    "channelAdminLogEventActionEditTopic": function(w, v) {
      w.uint(4033864200);
      w.object(h(v, "prevTopic"));
      w.object(h(v, "newTopic"));
    },
    "channelAdminLogEventActionDeleteTopic": function(w, v) {
      w.uint(2920712457);
      w.object(h(v, "topic"));
    },
    "channelAdminLogEventActionPinTopic": function(w, v) {
      w.uint(1569535291);
      var flags = 0;
      var _prevTopic = v.prevTopic !== void 0;
      if (_prevTopic)
        flags |= 1;
      var _newTopic = v.newTopic !== void 0;
      if (_newTopic)
        flags |= 2;
      w.uint(flags);
      if (_prevTopic)
        w.object(v.prevTopic);
      if (_newTopic)
        w.object(v.newTopic);
    },
    "channelAdminLogEventActionToggleAntiSpam": function(w, v) {
      w.uint(1693675004);
      w.boolean(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangePeerColor": function(w, v) {
      w.uint(1469507456);
      w.object(h(v, "prevValue"));
      w.object(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeProfilePeerColor": function(w, v) {
      w.uint(1581742885);
      w.object(h(v, "prevValue"));
      w.object(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeWallpaper": function(w, v) {
      w.uint(834362706);
      w.object(h(v, "prevValue"));
      w.object(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeEmojiStatus": function(w, v) {
      w.uint(1051328177);
      w.object(h(v, "prevValue"));
      w.object(h(v, "newValue"));
    },
    "channelAdminLogEventActionChangeEmojiStickerSet": function(w, v) {
      w.uint(1188577451);
      w.object(h(v, "prevStickerset"));
      w.object(h(v, "newStickerset"));
    },
    "channelAdminLogEventActionToggleSignatureProfiles": function(w, v) {
      w.uint(1621597305);
      w.boolean(h(v, "newValue"));
    },
    "channelAdminLogEventActionParticipantSubExtend": function(w, v) {
      w.uint(1684286899);
      w.object(h(v, "prevParticipant"));
      w.object(h(v, "newParticipant"));
    },
    "channelAdminLogEvent": function(w, v) {
      w.uint(531458253);
      w.long(h(v, "id"));
      w.int(h(v, "date"));
      w.int53(h(v, "userId"));
      w.object(h(v, "action"));
    },
    "channels.adminLogResults": function(w, v) {
      w.uint(3985307469);
      w.vector(w.object, h(v, "events"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "channelAdminLogEventsFilter": function(w, v) {
      w.uint(3926948580);
      var flags = 0;
      if (v.join === true)
        flags |= 1;
      if (v.leave === true)
        flags |= 2;
      if (v.invite === true)
        flags |= 4;
      if (v.ban === true)
        flags |= 8;
      if (v.unban === true)
        flags |= 16;
      if (v.kick === true)
        flags |= 32;
      if (v.unkick === true)
        flags |= 64;
      if (v.promote === true)
        flags |= 128;
      if (v.demote === true)
        flags |= 256;
      if (v.info === true)
        flags |= 512;
      if (v.settings === true)
        flags |= 1024;
      if (v.pinned === true)
        flags |= 2048;
      if (v.edit === true)
        flags |= 4096;
      if (v.delete === true)
        flags |= 8192;
      if (v.groupCall === true)
        flags |= 16384;
      if (v.invites === true)
        flags |= 32768;
      if (v.send === true)
        flags |= 65536;
      if (v.forums === true)
        flags |= 131072;
      if (v.subExtend === true)
        flags |= 262144;
      w.uint(flags);
    },
    "popularContact": function(w, v) {
      w.uint(1558266229);
      w.long(h(v, "clientId"));
      w.int(h(v, "importers"));
    },
    "messages.favedStickersNotModified": function(w) {
      w.uint(2660214483);
    },
    "messages.favedStickers": function(w, v) {
      w.uint(750063767);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "packs"));
      w.vector(w.object, h(v, "stickers"));
    },
    "recentMeUrlUnknown": function(w, v) {
      w.uint(1189204285);
      w.string(h(v, "url"));
    },
    "recentMeUrlUser": function(w, v) {
      w.uint(3106671074);
      w.string(h(v, "url"));
      w.int53(h(v, "userId"));
    },
    "recentMeUrlChat": function(w, v) {
      w.uint(3000660434);
      w.string(h(v, "url"));
      w.int53(h(v, "chatId"));
    },
    "recentMeUrlChatInvite": function(w, v) {
      w.uint(3947431965);
      w.string(h(v, "url"));
      w.object(h(v, "chatInvite"));
    },
    "recentMeUrlStickerSet": function(w, v) {
      w.uint(3154794460);
      w.string(h(v, "url"));
      w.object(h(v, "set"));
    },
    "help.recentMeUrls": function(w, v) {
      w.uint(235081943);
      w.vector(w.object, h(v, "urls"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "inputSingleMedia": function(w, v) {
      w.uint(482797855);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "media"));
      w.long(h(v, "randomId"));
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
    },
    "webAuthorization": function(w, v) {
      w.uint(2801333330);
      w.long(h(v, "hash"));
      w.int53(h(v, "botId"));
      w.string(h(v, "domain"));
      w.string(h(v, "browser"));
      w.string(h(v, "platform"));
      w.int(h(v, "dateCreated"));
      w.int(h(v, "dateActive"));
      w.string(h(v, "ip"));
      w.string(h(v, "region"));
    },
    "account.webAuthorizations": function(w, v) {
      w.uint(3981887996);
      w.vector(w.object, h(v, "authorizations"));
      w.vector(w.object, h(v, "users"));
    },
    "inputMessageID": function(w, v) {
      w.uint(2792792866);
      w.int(h(v, "id"));
    },
    "inputMessageReplyTo": function(w, v) {
      w.uint(3134751637);
      w.int(h(v, "id"));
    },
    "inputMessagePinned": function(w) {
      w.uint(2257003832);
    },
    "inputMessageCallbackQuery": function(w, v) {
      w.uint(2902071934);
      w.int(h(v, "id"));
      w.long(h(v, "queryId"));
    },
    "inputDialogPeer": function(w, v) {
      w.uint(4239064759);
      w.object(h(v, "peer"));
    },
    "inputDialogPeerFolder": function(w, v) {
      w.uint(1684014375);
      w.int(h(v, "folderId"));
    },
    "dialogPeer": function(w, v) {
      w.uint(3849174789);
      w.object(h(v, "peer"));
    },
    "dialogPeerFolder": function(w, v) {
      w.uint(1363483106);
      w.int(h(v, "folderId"));
    },
    "messages.foundStickerSetsNotModified": function(w) {
      w.uint(223655517);
    },
    "messages.foundStickerSets": function(w, v) {
      w.uint(2331024850);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "sets"));
    },
    "fileHash": function(w, v) {
      w.uint(4087022428);
      w.int53(h(v, "offset"));
      w.int(h(v, "limit"));
      w.bytes(h(v, "hash"));
    },
    "inputClientProxy": function(w, v) {
      w.uint(1968737087);
      w.string(h(v, "address"));
      w.int(h(v, "port"));
    },
    "help.termsOfServiceUpdateEmpty": function(w, v) {
      w.uint(3811614591);
      w.int(h(v, "expires"));
    },
    "help.termsOfServiceUpdate": function(w, v) {
      w.uint(686618977);
      w.int(h(v, "expires"));
      w.object(h(v, "termsOfService"));
    },
    "inputSecureFileUploaded": function(w, v) {
      w.uint(859091184);
      w.long(h(v, "id"));
      w.int(h(v, "parts"));
      w.string(h(v, "md5Checksum"));
      w.bytes(h(v, "fileHash"));
      w.bytes(h(v, "secret"));
    },
    "inputSecureFile": function(w, v) {
      w.uint(1399317950);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "secureFileEmpty": function(w) {
      w.uint(1679398724);
    },
    "secureFile": function(w, v) {
      w.uint(2097791614);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int53(h(v, "size"));
      w.int(h(v, "dcId"));
      w.int(h(v, "date"));
      w.bytes(h(v, "fileHash"));
      w.bytes(h(v, "secret"));
    },
    "secureData": function(w, v) {
      w.uint(2330640067);
      w.bytes(h(v, "data"));
      w.bytes(h(v, "dataHash"));
      w.bytes(h(v, "secret"));
    },
    "securePlainPhone": function(w, v) {
      w.uint(2103482845);
      w.string(h(v, "phone"));
    },
    "securePlainEmail": function(w, v) {
      w.uint(569137759);
      w.string(h(v, "email"));
    },
    "secureValueTypePersonalDetails": function(w) {
      w.uint(2636808675);
    },
    "secureValueTypePassport": function(w) {
      w.uint(1034709504);
    },
    "secureValueTypeDriverLicense": function(w) {
      w.uint(115615172);
    },
    "secureValueTypeIdentityCard": function(w) {
      w.uint(2698015819);
    },
    "secureValueTypeInternalPassport": function(w) {
      w.uint(2577698595);
    },
    "secureValueTypeAddress": function(w) {
      w.uint(3420659238);
    },
    "secureValueTypeUtilityBill": function(w) {
      w.uint(4231435598);
    },
    "secureValueTypeBankStatement": function(w) {
      w.uint(2299755533);
    },
    "secureValueTypeRentalAgreement": function(w) {
      w.uint(2340959368);
    },
    "secureValueTypePassportRegistration": function(w) {
      w.uint(2581823594);
    },
    "secureValueTypeTemporaryRegistration": function(w) {
      w.uint(3926060083);
    },
    "secureValueTypePhone": function(w) {
      w.uint(3005262555);
    },
    "secureValueTypeEmail": function(w) {
      w.uint(2386339822);
    },
    "secureValue": function(w, v) {
      w.uint(411017418);
      var flags = 0;
      var _data = v.data !== void 0;
      if (_data)
        flags |= 1;
      var _frontSide = v.frontSide !== void 0;
      if (_frontSide)
        flags |= 2;
      var _reverseSide = v.reverseSide !== void 0;
      if (_reverseSide)
        flags |= 4;
      var _selfie = v.selfie !== void 0;
      if (_selfie)
        flags |= 8;
      var _files = v.files && v.files.length;
      if (_files)
        flags |= 16;
      var _plainData = v.plainData !== void 0;
      if (_plainData)
        flags |= 32;
      var _translation = v.translation && v.translation.length;
      if (_translation)
        flags |= 64;
      w.uint(flags);
      w.object(h(v, "type"));
      if (_data)
        w.object(v.data);
      if (_frontSide)
        w.object(v.frontSide);
      if (_reverseSide)
        w.object(v.reverseSide);
      if (_selfie)
        w.object(v.selfie);
      if (_translation)
        w.vector(w.object, v.translation);
      if (_files)
        w.vector(w.object, v.files);
      if (_plainData)
        w.object(v.plainData);
      w.bytes(h(v, "hash"));
    },
    "inputSecureValue": function(w, v) {
      w.uint(3676426407);
      var flags = 0;
      var _data = v.data !== void 0;
      if (_data)
        flags |= 1;
      var _frontSide = v.frontSide !== void 0;
      if (_frontSide)
        flags |= 2;
      var _reverseSide = v.reverseSide !== void 0;
      if (_reverseSide)
        flags |= 4;
      var _selfie = v.selfie !== void 0;
      if (_selfie)
        flags |= 8;
      var _files = v.files && v.files.length;
      if (_files)
        flags |= 16;
      var _plainData = v.plainData !== void 0;
      if (_plainData)
        flags |= 32;
      var _translation = v.translation && v.translation.length;
      if (_translation)
        flags |= 64;
      w.uint(flags);
      w.object(h(v, "type"));
      if (_data)
        w.object(v.data);
      if (_frontSide)
        w.object(v.frontSide);
      if (_reverseSide)
        w.object(v.reverseSide);
      if (_selfie)
        w.object(v.selfie);
      if (_translation)
        w.vector(w.object, v.translation);
      if (_files)
        w.vector(w.object, v.files);
      if (_plainData)
        w.object(v.plainData);
    },
    "secureValueHash": function(w, v) {
      w.uint(3978218928);
      w.object(h(v, "type"));
      w.bytes(h(v, "hash"));
    },
    "secureValueErrorData": function(w, v) {
      w.uint(3903065049);
      w.object(h(v, "type"));
      w.bytes(h(v, "dataHash"));
      w.string(h(v, "field"));
      w.string(h(v, "text"));
    },
    "secureValueErrorFrontSide": function(w, v) {
      w.uint(12467706);
      w.object(h(v, "type"));
      w.bytes(h(v, "fileHash"));
      w.string(h(v, "text"));
    },
    "secureValueErrorReverseSide": function(w, v) {
      w.uint(2257201829);
      w.object(h(v, "type"));
      w.bytes(h(v, "fileHash"));
      w.string(h(v, "text"));
    },
    "secureValueErrorSelfie": function(w, v) {
      w.uint(3845639894);
      w.object(h(v, "type"));
      w.bytes(h(v, "fileHash"));
      w.string(h(v, "text"));
    },
    "secureValueErrorFile": function(w, v) {
      w.uint(2054162547);
      w.object(h(v, "type"));
      w.bytes(h(v, "fileHash"));
      w.string(h(v, "text"));
    },
    "secureValueErrorFiles": function(w, v) {
      w.uint(1717706985);
      w.object(h(v, "type"));
      w.vector(w.bytes, h(v, "fileHash"));
      w.string(h(v, "text"));
    },
    "secureValueError": function(w, v) {
      w.uint(2258466191);
      w.object(h(v, "type"));
      w.bytes(h(v, "hash"));
      w.string(h(v, "text"));
    },
    "secureValueErrorTranslationFile": function(w, v) {
      w.uint(2702460784);
      w.object(h(v, "type"));
      w.bytes(h(v, "fileHash"));
      w.string(h(v, "text"));
    },
    "secureValueErrorTranslationFiles": function(w, v) {
      w.uint(878931416);
      w.object(h(v, "type"));
      w.vector(w.bytes, h(v, "fileHash"));
      w.string(h(v, "text"));
    },
    "secureCredentialsEncrypted": function(w, v) {
      w.uint(871426631);
      w.bytes(h(v, "data"));
      w.bytes(h(v, "hash"));
      w.bytes(h(v, "secret"));
    },
    "account.authorizationForm": function(w, v) {
      w.uint(2905480408);
      var flags = 0;
      var _privacyPolicyUrl = v.privacyPolicyUrl !== void 0;
      if (_privacyPolicyUrl)
        flags |= 1;
      w.uint(flags);
      w.vector(w.object, h(v, "requiredTypes"));
      w.vector(w.object, h(v, "values"));
      w.vector(w.object, h(v, "errors"));
      w.vector(w.object, h(v, "users"));
      if (_privacyPolicyUrl)
        w.string(v.privacyPolicyUrl);
    },
    "account.sentEmailCode": function(w, v) {
      w.uint(2166326607);
      w.string(h(v, "emailPattern"));
      w.int(h(v, "length"));
    },
    "help.deepLinkInfoEmpty": function(w) {
      w.uint(1722786150);
    },
    "help.deepLinkInfo": function(w, v) {
      w.uint(1783556146);
      var flags = 0;
      if (v.updateApp === true)
        flags |= 1;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
    },
    "savedPhoneContact": function(w, v) {
      w.uint(289586518);
      w.string(h(v, "phone"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
      w.int(h(v, "date"));
    },
    "account.takeout": function(w, v) {
      w.uint(1304052993);
      w.long(h(v, "id"));
    },
    "passwordKdfAlgoUnknown": function(w) {
      w.uint(3562713238);
    },
    "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow": function(w, v) {
      w.uint(982592842);
      w.bytes(h(v, "salt1"));
      w.bytes(h(v, "salt2"));
      w.int(h(v, "g"));
      w.bytes(h(v, "p"));
    },
    "securePasswordKdfAlgoUnknown": function(w) {
      w.uint(4883767);
    },
    "securePasswordKdfAlgoPBKDF2HMACSHA512iter100000": function(w, v) {
      w.uint(3153255840);
      w.bytes(h(v, "salt"));
    },
    "securePasswordKdfAlgoSHA512": function(w, v) {
      w.uint(2252807570);
      w.bytes(h(v, "salt"));
    },
    "secureSecretSettings": function(w, v) {
      w.uint(354925740);
      w.object(h(v, "secureAlgo"));
      w.bytes(h(v, "secureSecret"));
      w.long(h(v, "secureSecretId"));
    },
    "inputCheckPasswordEmpty": function(w) {
      w.uint(2558588504);
    },
    "inputCheckPasswordSRP": function(w, v) {
      w.uint(3531600002);
      w.long(h(v, "srpId"));
      w.bytes(h(v, "A"));
      w.bytes(h(v, "M1"));
    },
    "secureRequiredType": function(w, v) {
      w.uint(2191366618);
      var flags = 0;
      if (v.nativeNames === true)
        flags |= 1;
      if (v.selfieRequired === true)
        flags |= 2;
      if (v.translationRequired === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "type"));
    },
    "secureRequiredTypeOneOf": function(w, v) {
      w.uint(41187252);
      w.vector(w.object, h(v, "types"));
    },
    "help.passportConfigNotModified": function(w) {
      w.uint(3216634967);
    },
    "help.passportConfig": function(w, v) {
      w.uint(2694370991);
      w.int(h(v, "hash"));
      w.object(h(v, "countriesLangs"));
    },
    "inputAppEvent": function(w, v) {
      w.uint(488313413);
      w.double(h(v, "time"));
      w.string(h(v, "type"));
      w.long(h(v, "peer"));
      w.object(h(v, "data"));
    },
    "jsonObjectValue": function(w, v) {
      w.uint(3235781593);
      w.string(h(v, "key"));
      w.object(h(v, "value"));
    },
    "jsonNull": function(w) {
      w.uint(1064139624);
    },
    "jsonBool": function(w, v) {
      w.uint(3342098026);
      w.boolean(h(v, "value"));
    },
    "jsonNumber": function(w, v) {
      w.uint(736157604);
      w.double(h(v, "value"));
    },
    "jsonString": function(w, v) {
      w.uint(3072226938);
      w.string(h(v, "value"));
    },
    "jsonArray": function(w, v) {
      w.uint(4148447075);
      w.vector(w.object, h(v, "value"));
    },
    "jsonObject": function(w, v) {
      w.uint(2579616925);
      w.vector(w.object, h(v, "value"));
    },
    "pageTableCell": function(w, v) {
      w.uint(878078826);
      var flags = 0;
      if (v.header === true)
        flags |= 1;
      var _colspan = v.colspan !== void 0;
      if (_colspan)
        flags |= 2;
      var _rowspan = v.rowspan !== void 0;
      if (_rowspan)
        flags |= 4;
      if (v.alignCenter === true)
        flags |= 8;
      if (v.alignRight === true)
        flags |= 16;
      if (v.valignMiddle === true)
        flags |= 32;
      if (v.valignBottom === true)
        flags |= 64;
      var _text = v.text !== void 0;
      if (_text)
        flags |= 128;
      w.uint(flags);
      if (_text)
        w.object(v.text);
      if (_colspan)
        w.int(v.colspan);
      if (_rowspan)
        w.int(v.rowspan);
    },
    "pageTableRow": function(w, v) {
      w.uint(3770729957);
      w.vector(w.object, h(v, "cells"));
    },
    "pageCaption": function(w, v) {
      w.uint(1869903447);
      w.object(h(v, "text"));
      w.object(h(v, "credit"));
    },
    "pageListItemText": function(w, v) {
      w.uint(3106911949);
      w.object(h(v, "text"));
    },
    "pageListItemBlocks": function(w, v) {
      w.uint(635466748);
      w.vector(w.object, h(v, "blocks"));
    },
    "pageListOrderedItemText": function(w, v) {
      w.uint(1577484359);
      w.string(h(v, "num"));
      w.object(h(v, "text"));
    },
    "pageListOrderedItemBlocks": function(w, v) {
      w.uint(2564655414);
      w.string(h(v, "num"));
      w.vector(w.object, h(v, "blocks"));
    },
    "pageRelatedArticle": function(w, v) {
      w.uint(3012615176);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 2;
      var _photoId = v.photoId !== void 0;
      if (_photoId)
        flags |= 4;
      var _author = v.author !== void 0;
      if (_author)
        flags |= 8;
      var _publishedDate = v.publishedDate !== void 0;
      if (_publishedDate)
        flags |= 16;
      w.uint(flags);
      w.string(h(v, "url"));
      w.long(h(v, "webpageId"));
      if (_title)
        w.string(v.title);
      if (_description)
        w.string(v.description);
      if (_photoId)
        w.long(v.photoId);
      if (_author)
        w.string(v.author);
      if (_publishedDate)
        w.int(v.publishedDate);
    },
    "page": function(w, v) {
      w.uint(2556788493);
      var flags = 0;
      if (v.part === true)
        flags |= 1;
      if (v.rtl === true)
        flags |= 2;
      if (v.v2 === true)
        flags |= 4;
      var _views = v.views !== void 0;
      if (_views)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "url"));
      w.vector(w.object, h(v, "blocks"));
      w.vector(w.object, h(v, "photos"));
      w.vector(w.object, h(v, "documents"));
      if (_views)
        w.int(v.views);
    },
    "help.supportName": function(w, v) {
      w.uint(2349199817);
      w.string(h(v, "name"));
    },
    "help.userInfoEmpty": function(w) {
      w.uint(4088278765);
    },
    "help.userInfo": function(w, v) {
      w.uint(32192344);
      w.string(h(v, "message"));
      w.vector(w.object, h(v, "entities"));
      w.string(h(v, "author"));
      w.int(h(v, "date"));
    },
    "pollAnswer": function(w, v) {
      w.uint(4279689930);
      w.object(h(v, "text"));
      w.bytes(h(v, "option"));
    },
    "poll": function(w, v) {
      w.uint(1484026161);
      w.long(h(v, "id"));
      var flags = 0;
      if (v.closed === true)
        flags |= 1;
      if (v.publicVoters === true)
        flags |= 2;
      if (v.multipleChoice === true)
        flags |= 4;
      if (v.quiz === true)
        flags |= 8;
      var _closePeriod = v.closePeriod !== void 0;
      if (_closePeriod)
        flags |= 16;
      var _closeDate = v.closeDate !== void 0;
      if (_closeDate)
        flags |= 32;
      w.uint(flags);
      w.object(h(v, "question"));
      w.vector(w.object, h(v, "answers"));
      if (_closePeriod)
        w.int(v.closePeriod);
      if (_closeDate)
        w.int(v.closeDate);
    },
    "pollAnswerVoters": function(w, v) {
      w.uint(997055186);
      var flags = 0;
      if (v.chosen === true)
        flags |= 1;
      if (v.correct === true)
        flags |= 2;
      w.uint(flags);
      w.bytes(h(v, "option"));
      w.int(h(v, "voters"));
    },
    "pollResults": function(w, v) {
      w.uint(2061444128);
      var flags = 0;
      if (v.min === true)
        flags |= 1;
      var _results = v.results && v.results.length;
      if (_results)
        flags |= 2;
      var _totalVoters = v.totalVoters !== void 0;
      if (_totalVoters)
        flags |= 4;
      var _recentVoters = v.recentVoters && v.recentVoters.length;
      if (_recentVoters)
        flags |= 8;
      var _solution = v.solution !== void 0;
      var _solutionEntities = v.solutionEntities && v.solutionEntities.length;
      var _flags_4 = _solution || _solutionEntities;
      if (_flags_4)
        flags |= 16;
      w.uint(flags);
      if (_results)
        w.vector(w.object, v.results);
      if (_totalVoters)
        w.int(v.totalVoters);
      if (_recentVoters)
        w.vector(w.object, v.recentVoters);
      if (_flags_4)
        w.string(v.solution);
      if (_flags_4)
        w.vector(w.object, v.solutionEntities);
    },
    "chatOnlines": function(w, v) {
      w.uint(4030849616);
      w.int(h(v, "onlines"));
    },
    "statsURL": function(w, v) {
      w.uint(1202287072);
      w.string(h(v, "url"));
    },
    "chatAdminRights": function(w, v) {
      w.uint(1605510357);
      var flags = 0;
      if (v.changeInfo === true)
        flags |= 1;
      if (v.postMessages === true)
        flags |= 2;
      if (v.editMessages === true)
        flags |= 4;
      if (v.deleteMessages === true)
        flags |= 8;
      if (v.banUsers === true)
        flags |= 16;
      if (v.inviteUsers === true)
        flags |= 32;
      if (v.pinMessages === true)
        flags |= 128;
      if (v.addAdmins === true)
        flags |= 512;
      if (v.anonymous === true)
        flags |= 1024;
      if (v.manageCall === true)
        flags |= 2048;
      if (v.other === true)
        flags |= 4096;
      if (v.manageTopics === true)
        flags |= 8192;
      if (v.postStories === true)
        flags |= 16384;
      if (v.editStories === true)
        flags |= 32768;
      if (v.deleteStories === true)
        flags |= 65536;
      w.uint(flags);
    },
    "chatBannedRights": function(w, v) {
      w.uint(2668758040);
      var flags = 0;
      if (v.viewMessages === true)
        flags |= 1;
      if (v.sendMessages === true)
        flags |= 2;
      if (v.sendMedia === true)
        flags |= 4;
      if (v.sendStickers === true)
        flags |= 8;
      if (v.sendGifs === true)
        flags |= 16;
      if (v.sendGames === true)
        flags |= 32;
      if (v.sendInline === true)
        flags |= 64;
      if (v.embedLinks === true)
        flags |= 128;
      if (v.sendPolls === true)
        flags |= 256;
      if (v.changeInfo === true)
        flags |= 1024;
      if (v.inviteUsers === true)
        flags |= 32768;
      if (v.pinMessages === true)
        flags |= 131072;
      if (v.manageTopics === true)
        flags |= 262144;
      if (v.sendPhotos === true)
        flags |= 524288;
      if (v.sendVideos === true)
        flags |= 1048576;
      if (v.sendRoundvideos === true)
        flags |= 2097152;
      if (v.sendAudios === true)
        flags |= 4194304;
      if (v.sendVoices === true)
        flags |= 8388608;
      if (v.sendDocs === true)
        flags |= 16777216;
      if (v.sendPlain === true)
        flags |= 33554432;
      w.uint(flags);
      w.int(h(v, "untilDate"));
    },
    "inputWallPaper": function(w, v) {
      w.uint(3861952889);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputWallPaperSlug": function(w, v) {
      w.uint(1913199744);
      w.string(h(v, "slug"));
    },
    "inputWallPaperNoFile": function(w, v) {
      w.uint(2524595758);
      w.long(h(v, "id"));
    },
    "account.wallPapersNotModified": function(w) {
      w.uint(471437699);
    },
    "account.wallPapers": function(w, v) {
      w.uint(3452142988);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "wallpapers"));
    },
    "codeSettings": function(w, v) {
      w.uint(2904898936);
      var flags = 0;
      if (v.allowFlashcall === true)
        flags |= 1;
      if (v.currentNumber === true)
        flags |= 2;
      if (v.allowAppHash === true)
        flags |= 16;
      if (v.allowMissedCall === true)
        flags |= 32;
      var _logoutTokens = v.logoutTokens && v.logoutTokens.length;
      if (_logoutTokens)
        flags |= 64;
      if (v.allowFirebase === true)
        flags |= 128;
      var _token = v.token !== void 0;
      var _appSandbox = v.appSandbox !== void 0;
      var _flags_8 = _token || _appSandbox;
      if (_flags_8)
        flags |= 256;
      if (v.unknownNumber === true)
        flags |= 512;
      w.uint(flags);
      if (_logoutTokens)
        w.vector(w.bytes, v.logoutTokens);
      if (_flags_8)
        w.string(v.token);
      if (_flags_8)
        w.boolean(v.appSandbox);
    },
    "wallPaperSettings": function(w, v) {
      w.uint(925826256);
      var flags = 0;
      var _backgroundColor = v.backgroundColor !== void 0;
      if (_backgroundColor)
        flags |= 1;
      if (v.blur === true)
        flags |= 2;
      if (v.motion === true)
        flags |= 4;
      var _intensity = v.intensity !== void 0;
      if (_intensity)
        flags |= 8;
      var _secondBackgroundColor = v.secondBackgroundColor !== void 0;
      var _rotation = v.rotation !== void 0;
      var _flags_4 = _secondBackgroundColor || _rotation;
      if (_flags_4)
        flags |= 16;
      var _thirdBackgroundColor = v.thirdBackgroundColor !== void 0;
      if (_thirdBackgroundColor)
        flags |= 32;
      var _fourthBackgroundColor = v.fourthBackgroundColor !== void 0;
      if (_fourthBackgroundColor)
        flags |= 64;
      var _emoticon = v.emoticon !== void 0;
      if (_emoticon)
        flags |= 128;
      w.uint(flags);
      if (_backgroundColor)
        w.int(v.backgroundColor);
      if (_flags_4)
        w.int(v.secondBackgroundColor);
      if (_thirdBackgroundColor)
        w.int(v.thirdBackgroundColor);
      if (_fourthBackgroundColor)
        w.int(v.fourthBackgroundColor);
      if (_intensity)
        w.int(v.intensity);
      if (_flags_4)
        w.int(v.rotation);
      if (_emoticon)
        w.string(v.emoticon);
    },
    "autoDownloadSettings": function(w, v) {
      w.uint(3131405864);
      var flags = 0;
      if (v.disabled === true)
        flags |= 1;
      if (v.videoPreloadLarge === true)
        flags |= 2;
      if (v.audioPreloadNext === true)
        flags |= 4;
      if (v.phonecallsLessData === true)
        flags |= 8;
      if (v.storiesPreload === true)
        flags |= 16;
      w.uint(flags);
      w.int(h(v, "photoSizeMax"));
      w.int53(h(v, "videoSizeMax"));
      w.int53(h(v, "fileSizeMax"));
      w.int(h(v, "videoUploadMaxbitrate"));
      w.int(h(v, "smallQueueActiveOperationsMax"));
      w.int(h(v, "largeQueueActiveOperationsMax"));
    },
    "account.autoDownloadSettings": function(w, v) {
      w.uint(1674235686);
      w.object(h(v, "low"));
      w.object(h(v, "medium"));
      w.object(h(v, "high"));
    },
    "emojiKeyword": function(w, v) {
      w.uint(3585325561);
      w.string(h(v, "keyword"));
      w.vector(w.string, h(v, "emoticons"));
    },
    "emojiKeywordDeleted": function(w, v) {
      w.uint(594408994);
      w.string(h(v, "keyword"));
      w.vector(w.string, h(v, "emoticons"));
    },
    "emojiKeywordsDifference": function(w, v) {
      w.uint(1556570557);
      w.string(h(v, "langCode"));
      w.int(h(v, "fromVersion"));
      w.int(h(v, "version"));
      w.vector(w.object, h(v, "keywords"));
    },
    "emojiURL": function(w, v) {
      w.uint(2775937949);
      w.string(h(v, "url"));
    },
    "emojiLanguage": function(w, v) {
      w.uint(3019592545);
      w.string(h(v, "langCode"));
    },
    "folder": function(w, v) {
      w.uint(4283715173);
      var flags = 0;
      if (v.autofillNewBroadcasts === true)
        flags |= 1;
      if (v.autofillPublicGroups === true)
        flags |= 2;
      if (v.autofillNewCorrespondents === true)
        flags |= 4;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 8;
      w.uint(flags);
      w.int(h(v, "id"));
      w.string(h(v, "title"));
      if (_photo)
        w.object(v.photo);
    },
    "inputFolderPeer": function(w, v) {
      w.uint(4224893590);
      w.object(h(v, "peer"));
      w.int(h(v, "folderId"));
    },
    "folderPeer": function(w, v) {
      w.uint(3921323624);
      w.object(h(v, "peer"));
      w.int(h(v, "folderId"));
    },
    "messages.searchCounter": function(w, v) {
      w.uint(3896830975);
      var flags = 0;
      if (v.inexact === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "filter"));
      w.int(h(v, "count"));
    },
    "urlAuthResultRequest": function(w, v) {
      w.uint(2463316494);
      var flags = 0;
      if (v.requestWriteAccess === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "bot"));
      w.string(h(v, "domain"));
    },
    "urlAuthResultAccepted": function(w, v) {
      w.uint(2408320590);
      w.string(h(v, "url"));
    },
    "urlAuthResultDefault": function(w) {
      w.uint(2849430303);
    },
    "channelLocationEmpty": function(w) {
      w.uint(3216354699);
    },
    "channelLocation": function(w, v) {
      w.uint(547062491);
      w.object(h(v, "geoPoint"));
      w.string(h(v, "address"));
    },
    "peerLocated": function(w, v) {
      w.uint(3393592157);
      w.object(h(v, "peer"));
      w.int(h(v, "expires"));
      w.int(h(v, "distance"));
    },
    "peerSelfLocated": function(w, v) {
      w.uint(4176226379);
      w.int(h(v, "expires"));
    },
    "restrictionReason": function(w, v) {
      w.uint(3497176244);
      w.string(h(v, "platform"));
      w.string(h(v, "reason"));
      w.string(h(v, "text"));
    },
    "inputTheme": function(w, v) {
      w.uint(1012306921);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputThemeSlug": function(w, v) {
      w.uint(4119399921);
      w.string(h(v, "slug"));
    },
    "theme": function(w, v) {
      w.uint(2685298646);
      var flags = 0;
      if (v.creator === true)
        flags |= 1;
      if (v.default === true)
        flags |= 2;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 4;
      var _settings = v.settings && v.settings.length;
      if (_settings)
        flags |= 8;
      var _installsCount = v.installsCount !== void 0;
      if (_installsCount)
        flags |= 16;
      if (v.forChat === true)
        flags |= 32;
      var _emoticon = v.emoticon !== void 0;
      if (_emoticon)
        flags |= 64;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.string(h(v, "slug"));
      w.string(h(v, "title"));
      if (_document)
        w.object(v.document);
      if (_settings)
        w.vector(w.object, v.settings);
      if (_emoticon)
        w.string(v.emoticon);
      if (_installsCount)
        w.int(v.installsCount);
    },
    "account.themesNotModified": function(w) {
      w.uint(4095653410);
    },
    "account.themes": function(w, v) {
      w.uint(2587724909);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "themes"));
    },
    "auth.loginToken": function(w, v) {
      w.uint(1654593920);
      w.int(h(v, "expires"));
      w.bytes(h(v, "token"));
    },
    "auth.loginTokenMigrateTo": function(w, v) {
      w.uint(110008598);
      w.int(h(v, "dcId"));
      w.bytes(h(v, "token"));
    },
    "auth.loginTokenSuccess": function(w, v) {
      w.uint(957176926);
      w.object(h(v, "authorization"));
    },
    "account.contentSettings": function(w, v) {
      w.uint(1474462241);
      var flags = 0;
      if (v.sensitiveEnabled === true)
        flags |= 1;
      if (v.sensitiveCanChange === true)
        flags |= 2;
      w.uint(flags);
    },
    "messages.inactiveChats": function(w, v) {
      w.uint(2837970629);
      w.vector(w.int, h(v, "dates"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "baseThemeClassic": function(w) {
      w.uint(3282117730);
    },
    "baseThemeDay": function(w) {
      w.uint(4225242760);
    },
    "baseThemeNight": function(w) {
      w.uint(3081969320);
    },
    "baseThemeTinted": function(w) {
      w.uint(1834973166);
    },
    "baseThemeArctic": function(w) {
      w.uint(1527845466);
    },
    "inputThemeSettings": function(w, v) {
      w.uint(2413711439);
      var flags = 0;
      var _messageColors = v.messageColors && v.messageColors.length;
      if (_messageColors)
        flags |= 1;
      var _wallpaper = v.wallpaper !== void 0;
      var _wallpaperSettings = v.wallpaperSettings !== void 0;
      var _flags_1 = _wallpaper || _wallpaperSettings;
      if (_flags_1)
        flags |= 2;
      if (v.messageColorsAnimated === true)
        flags |= 4;
      var _outboxAccentColor = v.outboxAccentColor !== void 0;
      if (_outboxAccentColor)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "baseTheme"));
      w.int(h(v, "accentColor"));
      if (_outboxAccentColor)
        w.int(v.outboxAccentColor);
      if (_messageColors)
        w.vector(w.int, v.messageColors);
      if (_flags_1)
        w.object(v.wallpaper);
      if (_flags_1)
        w.object(v.wallpaperSettings);
    },
    "themeSettings": function(w, v) {
      w.uint(4200117972);
      var flags = 0;
      var _messageColors = v.messageColors && v.messageColors.length;
      if (_messageColors)
        flags |= 1;
      var _wallpaper = v.wallpaper !== void 0;
      if (_wallpaper)
        flags |= 2;
      if (v.messageColorsAnimated === true)
        flags |= 4;
      var _outboxAccentColor = v.outboxAccentColor !== void 0;
      if (_outboxAccentColor)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "baseTheme"));
      w.int(h(v, "accentColor"));
      if (_outboxAccentColor)
        w.int(v.outboxAccentColor);
      if (_messageColors)
        w.vector(w.int, v.messageColors);
      if (_wallpaper)
        w.object(v.wallpaper);
    },
    "webPageAttributeTheme": function(w, v) {
      w.uint(1421174295);
      var flags = 0;
      var _documents = v.documents && v.documents.length;
      if (_documents)
        flags |= 1;
      var _settings = v.settings !== void 0;
      if (_settings)
        flags |= 2;
      w.uint(flags);
      if (_documents)
        w.vector(w.object, v.documents);
      if (_settings)
        w.object(v.settings);
    },
    "webPageAttributeStory": function(w, v) {
      w.uint(781501415);
      var flags = 0;
      var _story = v.story !== void 0;
      if (_story)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      if (_story)
        w.object(v.story);
    },
    "webPageAttributeStickerSet": function(w, v) {
      w.uint(1355547603);
      var flags = 0;
      if (v.emojis === true)
        flags |= 1;
      if (v.textColor === true)
        flags |= 2;
      w.uint(flags);
      w.vector(w.object, h(v, "stickers"));
    },
    "messages.votesList": function(w, v) {
      w.uint(1218005070);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "votes"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      if (_nextOffset)
        w.string(v.nextOffset);
    },
    "bankCardOpenUrl": function(w, v) {
      w.uint(4117234314);
      w.string(h(v, "url"));
      w.string(h(v, "name"));
    },
    "payments.bankCardData": function(w, v) {
      w.uint(1042605427);
      w.string(h(v, "title"));
      w.vector(w.object, h(v, "openUrls"));
    },
    "dialogFilter": function(w, v) {
      w.uint(1605718587);
      var flags = 0;
      if (v.contacts === true)
        flags |= 1;
      if (v.nonContacts === true)
        flags |= 2;
      if (v.groups === true)
        flags |= 4;
      if (v.broadcasts === true)
        flags |= 8;
      if (v.bots === true)
        flags |= 16;
      if (v.excludeMuted === true)
        flags |= 2048;
      if (v.excludeRead === true)
        flags |= 4096;
      if (v.excludeArchived === true)
        flags |= 8192;
      var _emoticon = v.emoticon !== void 0;
      if (_emoticon)
        flags |= 33554432;
      var _color = v.color !== void 0;
      if (_color)
        flags |= 134217728;
      w.uint(flags);
      w.int(h(v, "id"));
      w.string(h(v, "title"));
      if (_emoticon)
        w.string(v.emoticon);
      if (_color)
        w.int(v.color);
      w.vector(w.object, h(v, "pinnedPeers"));
      w.vector(w.object, h(v, "includePeers"));
      w.vector(w.object, h(v, "excludePeers"));
    },
    "dialogFilterDefault": function(w) {
      w.uint(909284270);
    },
    "dialogFilterChatlist": function(w, v) {
      w.uint(2682424996);
      var flags = 0;
      var _emoticon = v.emoticon !== void 0;
      if (_emoticon)
        flags |= 33554432;
      if (v.hasMyInvites === true)
        flags |= 67108864;
      var _color = v.color !== void 0;
      if (_color)
        flags |= 134217728;
      w.uint(flags);
      w.int(h(v, "id"));
      w.string(h(v, "title"));
      if (_emoticon)
        w.string(v.emoticon);
      if (_color)
        w.int(v.color);
      w.vector(w.object, h(v, "pinnedPeers"));
      w.vector(w.object, h(v, "includePeers"));
    },
    "dialogFilterSuggested": function(w, v) {
      w.uint(2004110666);
      w.object(h(v, "filter"));
      w.string(h(v, "description"));
    },
    "statsDateRangeDays": function(w, v) {
      w.uint(3057118639);
      w.int(h(v, "minDate"));
      w.int(h(v, "maxDate"));
    },
    "statsAbsValueAndPrev": function(w, v) {
      w.uint(3410210014);
      w.double(h(v, "current"));
      w.double(h(v, "previous"));
    },
    "statsPercentValue": function(w, v) {
      w.uint(3419287520);
      w.double(h(v, "part"));
      w.double(h(v, "total"));
    },
    "statsGraphAsync": function(w, v) {
      w.uint(1244130093);
      w.string(h(v, "token"));
    },
    "statsGraphError": function(w, v) {
      w.uint(3202127906);
      w.string(h(v, "error"));
    },
    "statsGraph": function(w, v) {
      w.uint(2393138358);
      var flags = 0;
      var _zoomToken = v.zoomToken !== void 0;
      if (_zoomToken)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "json"));
      if (_zoomToken)
        w.string(v.zoomToken);
    },
    "stats.broadcastStats": function(w, v) {
      w.uint(963421692);
      w.object(h(v, "period"));
      w.object(h(v, "followers"));
      w.object(h(v, "viewsPerPost"));
      w.object(h(v, "sharesPerPost"));
      w.object(h(v, "reactionsPerPost"));
      w.object(h(v, "viewsPerStory"));
      w.object(h(v, "sharesPerStory"));
      w.object(h(v, "reactionsPerStory"));
      w.object(h(v, "enabledNotifications"));
      w.object(h(v, "growthGraph"));
      w.object(h(v, "followersGraph"));
      w.object(h(v, "muteGraph"));
      w.object(h(v, "topHoursGraph"));
      w.object(h(v, "interactionsGraph"));
      w.object(h(v, "ivInteractionsGraph"));
      w.object(h(v, "viewsBySourceGraph"));
      w.object(h(v, "newFollowersBySourceGraph"));
      w.object(h(v, "languagesGraph"));
      w.object(h(v, "reactionsByEmotionGraph"));
      w.object(h(v, "storyInteractionsGraph"));
      w.object(h(v, "storyReactionsByEmotionGraph"));
      w.vector(w.object, h(v, "recentPostsInteractions"));
    },
    "help.promoDataEmpty": function(w, v) {
      w.uint(2566302837);
      w.int(h(v, "expires"));
    },
    "help.promoData": function(w, v) {
      w.uint(2352576831);
      var flags = 0;
      if (v.proxy === true)
        flags |= 1;
      var _psaType = v.psaType !== void 0;
      if (_psaType)
        flags |= 2;
      var _psaMessage = v.psaMessage !== void 0;
      if (_psaMessage)
        flags |= 4;
      w.uint(flags);
      w.int(h(v, "expires"));
      w.object(h(v, "peer"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      if (_psaType)
        w.string(v.psaType);
      if (_psaMessage)
        w.string(v.psaMessage);
    },
    "videoSize": function(w, v) {
      w.uint(3727929492);
      var flags = 0;
      var _videoStartTs = v.videoStartTs !== void 0;
      if (_videoStartTs)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "type"));
      w.int(h(v, "w"));
      w.int(h(v, "h"));
      w.int(h(v, "size"));
      if (_videoStartTs)
        w.double(v.videoStartTs);
    },
    "videoSizeEmojiMarkup": function(w, v) {
      w.uint(4166795580);
      w.long(h(v, "emojiId"));
      w.vector(w.int, h(v, "backgroundColors"));
    },
    "videoSizeStickerMarkup": function(w, v) {
      w.uint(228623102);
      w.object(h(v, "stickerset"));
      w.long(h(v, "stickerId"));
      w.vector(w.int, h(v, "backgroundColors"));
    },
    "statsGroupTopPoster": function(w, v) {
      w.uint(2634330011);
      w.int53(h(v, "userId"));
      w.int(h(v, "messages"));
      w.int(h(v, "avgChars"));
    },
    "statsGroupTopAdmin": function(w, v) {
      w.uint(3612888199);
      w.int53(h(v, "userId"));
      w.int(h(v, "deleted"));
      w.int(h(v, "kicked"));
      w.int(h(v, "banned"));
    },
    "statsGroupTopInviter": function(w, v) {
      w.uint(1398765469);
      w.int53(h(v, "userId"));
      w.int(h(v, "invitations"));
    },
    "stats.megagroupStats": function(w, v) {
      w.uint(4018141462);
      w.object(h(v, "period"));
      w.object(h(v, "members"));
      w.object(h(v, "messages"));
      w.object(h(v, "viewers"));
      w.object(h(v, "posters"));
      w.object(h(v, "growthGraph"));
      w.object(h(v, "membersGraph"));
      w.object(h(v, "newMembersBySourceGraph"));
      w.object(h(v, "languagesGraph"));
      w.object(h(v, "messagesGraph"));
      w.object(h(v, "actionsGraph"));
      w.object(h(v, "topHoursGraph"));
      w.object(h(v, "weekdaysGraph"));
      w.vector(w.object, h(v, "topPosters"));
      w.vector(w.object, h(v, "topAdmins"));
      w.vector(w.object, h(v, "topInviters"));
      w.vector(w.object, h(v, "users"));
    },
    "globalPrivacySettings": function(w, v) {
      w.uint(1934380235);
      var flags = 0;
      if (v.archiveAndMuteNewNoncontactPeers === true)
        flags |= 1;
      if (v.keepArchivedUnmuted === true)
        flags |= 2;
      if (v.keepArchivedFolders === true)
        flags |= 4;
      if (v.hideReadMarks === true)
        flags |= 8;
      if (v.newNoncontactPeersRequirePremium === true)
        flags |= 16;
      w.uint(flags);
    },
    "help.countryCode": function(w, v) {
      w.uint(1107543535);
      var flags = 0;
      var _prefixes = v.prefixes && v.prefixes.length;
      if (_prefixes)
        flags |= 1;
      var _patterns = v.patterns && v.patterns.length;
      if (_patterns)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "countryCode"));
      if (_prefixes)
        w.vector(w.string, v.prefixes);
      if (_patterns)
        w.vector(w.string, v.patterns);
    },
    "help.country": function(w, v) {
      w.uint(3280440867);
      var flags = 0;
      if (v.hidden === true)
        flags |= 1;
      var _name = v.name !== void 0;
      if (_name)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "iso2"));
      w.string(h(v, "defaultName"));
      if (_name)
        w.string(v.name);
      w.vector(w.object, h(v, "countryCodes"));
    },
    "help.countriesListNotModified": function(w) {
      w.uint(2479628082);
    },
    "help.countriesList": function(w, v) {
      w.uint(2278585758);
      w.vector(w.object, h(v, "countries"));
      w.int(h(v, "hash"));
    },
    "messageViews": function(w, v) {
      w.uint(1163625789);
      var flags = 0;
      var _views = v.views !== void 0;
      if (_views)
        flags |= 1;
      var _forwards = v.forwards !== void 0;
      if (_forwards)
        flags |= 2;
      var _replies = v.replies !== void 0;
      if (_replies)
        flags |= 4;
      w.uint(flags);
      if (_views)
        w.int(v.views);
      if (_forwards)
        w.int(v.forwards);
      if (_replies)
        w.object(v.replies);
    },
    "messages.messageViews": function(w, v) {
      w.uint(3066361155);
      w.vector(w.object, h(v, "views"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.discussionMessage": function(w, v) {
      w.uint(2788431746);
      var flags = 0;
      var _maxId = v.maxId !== void 0;
      if (_maxId)
        flags |= 1;
      var _readInboxMaxId = v.readInboxMaxId !== void 0;
      if (_readInboxMaxId)
        flags |= 2;
      var _readOutboxMaxId = v.readOutboxMaxId !== void 0;
      if (_readOutboxMaxId)
        flags |= 4;
      w.uint(flags);
      w.vector(w.object, h(v, "messages"));
      if (_maxId)
        w.int(v.maxId);
      if (_readInboxMaxId)
        w.int(v.readInboxMaxId);
      if (_readOutboxMaxId)
        w.int(v.readOutboxMaxId);
      w.int(h(v, "unreadCount"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messageReplyHeader": function(w, v) {
      w.uint(2948336091);
      var flags = 0;
      var _replyToPeerId = v.replyToPeerId !== void 0;
      if (_replyToPeerId)
        flags |= 1;
      var _replyToTopId = v.replyToTopId !== void 0;
      if (_replyToTopId)
        flags |= 2;
      if (v.replyToScheduled === true)
        flags |= 4;
      if (v.forumTopic === true)
        flags |= 8;
      var _replyToMsgId = v.replyToMsgId !== void 0;
      if (_replyToMsgId)
        flags |= 16;
      var _replyFrom = v.replyFrom !== void 0;
      if (_replyFrom)
        flags |= 32;
      var _quoteText = v.quoteText !== void 0;
      if (_quoteText)
        flags |= 64;
      var _quoteEntities = v.quoteEntities && v.quoteEntities.length;
      if (_quoteEntities)
        flags |= 128;
      var _replyMedia = v.replyMedia !== void 0;
      if (_replyMedia)
        flags |= 256;
      if (v.quote === true)
        flags |= 512;
      var _quoteOffset = v.quoteOffset !== void 0;
      if (_quoteOffset)
        flags |= 1024;
      w.uint(flags);
      if (_replyToMsgId)
        w.int(v.replyToMsgId);
      if (_replyToPeerId)
        w.object(v.replyToPeerId);
      if (_replyFrom)
        w.object(v.replyFrom);
      if (_replyMedia)
        w.object(v.replyMedia);
      if (_replyToTopId)
        w.int(v.replyToTopId);
      if (_quoteText)
        w.string(v.quoteText);
      if (_quoteEntities)
        w.vector(w.object, v.quoteEntities);
      if (_quoteOffset)
        w.int(v.quoteOffset);
    },
    "messageReplyStoryHeader": function(w, v) {
      w.uint(240843065);
      w.object(h(v, "peer"));
      w.int(h(v, "storyId"));
    },
    "messageReplies": function(w, v) {
      w.uint(2211844034);
      var flags = 0;
      var _channelId = v.channelId !== void 0;
      var _flags_0 = v.comments === true || _channelId;
      if (_flags_0)
        flags |= 1;
      var _recentRepliers = v.recentRepliers && v.recentRepliers.length;
      if (_recentRepliers)
        flags |= 2;
      var _maxId = v.maxId !== void 0;
      if (_maxId)
        flags |= 4;
      var _readMaxId = v.readMaxId !== void 0;
      if (_readMaxId)
        flags |= 8;
      w.uint(flags);
      w.int(h(v, "replies"));
      w.int(h(v, "repliesPts"));
      if (_recentRepliers)
        w.vector(w.object, v.recentRepliers);
      if (_flags_0)
        w.int53(v.channelId);
      if (_maxId)
        w.int(v.maxId);
      if (_readMaxId)
        w.int(v.readMaxId);
    },
    "peerBlocked": function(w, v) {
      w.uint(3908927508);
      w.object(h(v, "peerId"));
      w.int(h(v, "date"));
    },
    "stats.messageStats": function(w, v) {
      w.uint(2145983508);
      w.object(h(v, "viewsGraph"));
      w.object(h(v, "reactionsByEmotionGraph"));
    },
    "groupCallDiscarded": function(w, v) {
      w.uint(2004925620);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "duration"));
    },
    "groupCall": function(w, v) {
      w.uint(3583468812);
      var flags = 0;
      if (v.joinMuted === true)
        flags |= 2;
      if (v.canChangeJoinMuted === true)
        flags |= 4;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 8;
      var _streamDcId = v.streamDcId !== void 0;
      if (_streamDcId)
        flags |= 16;
      var _recordStartDate = v.recordStartDate !== void 0;
      if (_recordStartDate)
        flags |= 32;
      if (v.joinDateAsc === true)
        flags |= 64;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 128;
      if (v.scheduleStartSubscribed === true)
        flags |= 256;
      if (v.canStartVideo === true)
        flags |= 512;
      var _unmutedVideoCount = v.unmutedVideoCount !== void 0;
      if (_unmutedVideoCount)
        flags |= 1024;
      if (v.recordVideoActive === true)
        flags |= 2048;
      if (v.rtmpStream === true)
        flags |= 4096;
      if (v.listenersHidden === true)
        flags |= 8192;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.int(h(v, "participantsCount"));
      if (_title)
        w.string(v.title);
      if (_streamDcId)
        w.int(v.streamDcId);
      if (_recordStartDate)
        w.int(v.recordStartDate);
      if (_scheduleDate)
        w.int(v.scheduleDate);
      if (_unmutedVideoCount)
        w.int(v.unmutedVideoCount);
      w.int(h(v, "unmutedVideoLimit"));
      w.int(h(v, "version"));
    },
    "inputGroupCall": function(w, v) {
      w.uint(3635053583);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "groupCallParticipant": function(w, v) {
      w.uint(3953538814);
      var flags = 0;
      if (v.muted === true)
        flags |= 1;
      if (v.left === true)
        flags |= 2;
      if (v.canSelfUnmute === true)
        flags |= 4;
      var _activeDate = v.activeDate !== void 0;
      if (_activeDate)
        flags |= 8;
      if (v.justJoined === true)
        flags |= 16;
      if (v.versioned === true)
        flags |= 32;
      var _video = v.video !== void 0;
      if (_video)
        flags |= 64;
      var _volume = v.volume !== void 0;
      if (_volume)
        flags |= 128;
      if (v.min === true)
        flags |= 256;
      if (v.mutedByYou === true)
        flags |= 512;
      if (v.volumeByAdmin === true)
        flags |= 1024;
      var _about = v.about !== void 0;
      if (_about)
        flags |= 2048;
      if (v.self === true)
        flags |= 4096;
      var _raiseHandRating = v.raiseHandRating !== void 0;
      if (_raiseHandRating)
        flags |= 8192;
      var _presentation = v.presentation !== void 0;
      if (_presentation)
        flags |= 16384;
      if (v.videoJoined === true)
        flags |= 32768;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "date"));
      if (_activeDate)
        w.int(v.activeDate);
      w.int(h(v, "source"));
      if (_volume)
        w.int(v.volume);
      if (_about)
        w.string(v.about);
      if (_raiseHandRating)
        w.long(v.raiseHandRating);
      if (_video)
        w.object(v.video);
      if (_presentation)
        w.object(v.presentation);
    },
    "phone.groupCall": function(w, v) {
      w.uint(2658302637);
      w.object(h(v, "call"));
      w.vector(w.object, h(v, "participants"));
      w.string(h(v, "participantsNextOffset"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "phone.groupParticipants": function(w, v) {
      w.uint(4101460406);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "participants"));
      w.string(h(v, "nextOffset"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      w.int(h(v, "version"));
    },
    "inlineQueryPeerTypeSameBotPM": function(w) {
      w.uint(813821341);
    },
    "inlineQueryPeerTypePM": function(w) {
      w.uint(2201751468);
    },
    "inlineQueryPeerTypeChat": function(w) {
      w.uint(3613836554);
    },
    "inlineQueryPeerTypeMegagroup": function(w) {
      w.uint(1589952067);
    },
    "inlineQueryPeerTypeBroadcast": function(w) {
      w.uint(1664413338);
    },
    "inlineQueryPeerTypeBotPM": function(w) {
      w.uint(238759180);
    },
    "messages.historyImport": function(w, v) {
      w.uint(375566091);
      w.long(h(v, "id"));
    },
    "messages.historyImportParsed": function(w, v) {
      w.uint(1578088377);
      var flags = 0;
      if (v.pm === true)
        flags |= 1;
      if (v.group === true)
        flags |= 2;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 4;
      w.uint(flags);
      if (_title)
        w.string(v.title);
    },
    "messages.affectedFoundMessages": function(w, v) {
      w.uint(4019011180);
      w.int(h(v, "pts"));
      w.int(h(v, "ptsCount"));
      w.int(h(v, "offset"));
      w.vector(w.int, h(v, "messages"));
    },
    "chatInviteImporter": function(w, v) {
      w.uint(2354765785);
      var flags = 0;
      if (v.requested === true)
        flags |= 1;
      var _approvedBy = v.approvedBy !== void 0;
      if (_approvedBy)
        flags |= 2;
      var _about = v.about !== void 0;
      if (_about)
        flags |= 4;
      if (v.viaChatlist === true)
        flags |= 8;
      w.uint(flags);
      w.int53(h(v, "userId"));
      w.int(h(v, "date"));
      if (_about)
        w.string(v.about);
      if (_approvedBy)
        w.int53(v.approvedBy);
    },
    "messages.exportedChatInvites": function(w, v) {
      w.uint(3183881676);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "invites"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.exportedChatInvite": function(w, v) {
      w.uint(410107472);
      w.object(h(v, "invite"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.exportedChatInviteReplaced": function(w, v) {
      w.uint(572915951);
      w.object(h(v, "invite"));
      w.object(h(v, "newInvite"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.chatInviteImporters": function(w, v) {
      w.uint(2176233482);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "importers"));
      w.vector(w.object, h(v, "users"));
    },
    "chatAdminWithInvites": function(w, v) {
      w.uint(4075613987);
      w.int53(h(v, "adminId"));
      w.int(h(v, "invitesCount"));
      w.int(h(v, "revokedInvitesCount"));
    },
    "messages.chatAdminsWithInvites": function(w, v) {
      w.uint(3063640791);
      w.vector(w.object, h(v, "admins"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.checkedHistoryImportPeer": function(w, v) {
      w.uint(2723014423);
      w.string(h(v, "confirmText"));
    },
    "phone.joinAsPeers": function(w, v) {
      w.uint(2951045695);
      w.vector(w.object, h(v, "peers"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "phone.exportedGroupCallInvite": function(w, v) {
      w.uint(541839704);
      w.string(h(v, "link"));
    },
    "groupCallParticipantVideoSourceGroup": function(w, v) {
      w.uint(3702593719);
      w.string(h(v, "semantics"));
      w.vector(w.int, h(v, "sources"));
    },
    "groupCallParticipantVideo": function(w, v) {
      w.uint(1735736008);
      var flags = 0;
      if (v.paused === true)
        flags |= 1;
      var _audioSource = v.audioSource !== void 0;
      if (_audioSource)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "endpoint"));
      w.vector(w.object, h(v, "sourceGroups"));
      if (_audioSource)
        w.int(v.audioSource);
    },
    "stickers.suggestedShortName": function(w, v) {
      w.uint(2248056895);
      w.string(h(v, "shortName"));
    },
    "botCommandScopeDefault": function(w) {
      w.uint(795652779);
    },
    "botCommandScopeUsers": function(w) {
      w.uint(1011811544);
    },
    "botCommandScopeChats": function(w) {
      w.uint(1877059713);
    },
    "botCommandScopeChatAdmins": function(w) {
      w.uint(3114950762);
    },
    "botCommandScopePeer": function(w, v) {
      w.uint(3684534653);
      w.object(h(v, "peer"));
    },
    "botCommandScopePeerAdmins": function(w, v) {
      w.uint(1071145937);
      w.object(h(v, "peer"));
    },
    "botCommandScopePeerUser": function(w, v) {
      w.uint(169026035);
      w.object(h(v, "peer"));
      w.object(h(v, "userId"));
    },
    "account.resetPasswordFailedWait": function(w, v) {
      w.uint(3816265825);
      w.int(h(v, "retryDate"));
    },
    "account.resetPasswordRequestedWait": function(w, v) {
      w.uint(3924819069);
      w.int(h(v, "untilDate"));
    },
    "account.resetPasswordOk": function(w) {
      w.uint(3911636542);
    },
    "sponsoredMessage": function(w, v) {
      w.uint(1301522832);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      if (v.recommended === true)
        flags |= 32;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 64;
      var _sponsorInfo = v.sponsorInfo !== void 0;
      if (_sponsorInfo)
        flags |= 128;
      var _additionalInfo = v.additionalInfo !== void 0;
      if (_additionalInfo)
        flags |= 256;
      if (v.canReport === true)
        flags |= 4096;
      var _color = v.color !== void 0;
      if (_color)
        flags |= 8192;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 16384;
      w.uint(flags);
      w.bytes(h(v, "randomId"));
      w.string(h(v, "url"));
      w.string(h(v, "title"));
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_photo)
        w.object(v.photo);
      if (_media)
        w.object(v.media);
      if (_color)
        w.object(v.color);
      w.string(h(v, "buttonText"));
      if (_sponsorInfo)
        w.string(v.sponsorInfo);
      if (_additionalInfo)
        w.string(v.additionalInfo);
    },
    "messages.sponsoredMessages": function(w, v) {
      w.uint(3387825543);
      var flags = 0;
      var _postsBetween = v.postsBetween !== void 0;
      if (_postsBetween)
        flags |= 1;
      w.uint(flags);
      if (_postsBetween)
        w.int(v.postsBetween);
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.sponsoredMessagesEmpty": function(w) {
      w.uint(406407439);
    },
    "searchResultsCalendarPeriod": function(w, v) {
      w.uint(3383776159);
      w.int(h(v, "date"));
      w.int(h(v, "minMsgId"));
      w.int(h(v, "maxMsgId"));
      w.int(h(v, "count"));
    },
    "messages.searchResultsCalendar": function(w, v) {
      w.uint(343859772);
      var flags = 0;
      if (v.inexact === true)
        flags |= 1;
      var _offsetIdOffset = v.offsetIdOffset !== void 0;
      if (_offsetIdOffset)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "count"));
      w.int(h(v, "minDate"));
      w.int(h(v, "minMsgId"));
      if (_offsetIdOffset)
        w.int(v.offsetIdOffset);
      w.vector(w.object, h(v, "periods"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "searchResultPosition": function(w, v) {
      w.uint(2137295719);
      w.int(h(v, "msgId"));
      w.int(h(v, "date"));
      w.int(h(v, "offset"));
    },
    "messages.searchResultsPositions": function(w, v) {
      w.uint(1404185519);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "positions"));
    },
    "channels.sendAsPeers": function(w, v) {
      w.uint(4103516358);
      w.vector(w.object, h(v, "peers"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "users.userFull": function(w, v) {
      w.uint(997004590);
      w.object(h(v, "fullUser"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.peerSettings": function(w, v) {
      w.uint(1753266509);
      w.object(h(v, "settings"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "auth.loggedOut": function(w, v) {
      w.uint(3282207583);
      var flags = 0;
      var _futureAuthToken = v.futureAuthToken !== void 0;
      if (_futureAuthToken)
        flags |= 1;
      w.uint(flags);
      if (_futureAuthToken)
        w.bytes(v.futureAuthToken);
    },
    "reactionCount": function(w, v) {
      w.uint(2748435328);
      var flags = 0;
      var _chosenOrder = v.chosenOrder !== void 0;
      if (_chosenOrder)
        flags |= 1;
      w.uint(flags);
      if (_chosenOrder)
        w.int(v.chosenOrder);
      w.object(h(v, "reaction"));
      w.int(h(v, "count"));
    },
    "messageReactions": function(w, v) {
      w.uint(171155211);
      var flags = 0;
      if (v.min === true)
        flags |= 1;
      var _recentReactions = v.recentReactions && v.recentReactions.length;
      if (_recentReactions)
        flags |= 2;
      if (v.canSeeList === true)
        flags |= 4;
      if (v.reactionsAsTags === true)
        flags |= 8;
      var _topReactors = v.topReactors && v.topReactors.length;
      if (_topReactors)
        flags |= 16;
      w.uint(flags);
      w.vector(w.object, h(v, "results"));
      if (_recentReactions)
        w.vector(w.object, v.recentReactions);
      if (_topReactors)
        w.vector(w.object, v.topReactors);
    },
    "messages.messageReactionsList": function(w, v) {
      w.uint(834488621);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "reactions"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      if (_nextOffset)
        w.string(v.nextOffset);
    },
    "availableReaction": function(w, v) {
      w.uint(3229084673);
      var flags = 0;
      if (v.inactive === true)
        flags |= 1;
      var _aroundAnimation = v.aroundAnimation !== void 0;
      var _centerIcon = v.centerIcon !== void 0;
      var _flags_1 = _aroundAnimation || _centerIcon;
      if (_flags_1)
        flags |= 2;
      if (v.premium === true)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "reaction"));
      w.string(h(v, "title"));
      w.object(h(v, "staticIcon"));
      w.object(h(v, "appearAnimation"));
      w.object(h(v, "selectAnimation"));
      w.object(h(v, "activateAnimation"));
      w.object(h(v, "effectAnimation"));
      if (_flags_1)
        w.object(v.aroundAnimation);
      if (_flags_1)
        w.object(v.centerIcon);
    },
    "messages.availableReactionsNotModified": function(w) {
      w.uint(2668042583);
    },
    "messages.availableReactions": function(w, v) {
      w.uint(1989032621);
      w.int(h(v, "hash"));
      w.vector(w.object, h(v, "reactions"));
    },
    "messagePeerReaction": function(w, v) {
      w.uint(2356786748);
      var flags = 0;
      if (v.big === true)
        flags |= 1;
      if (v.unread === true)
        flags |= 2;
      if (v.my === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peerId"));
      w.int(h(v, "date"));
      w.object(h(v, "reaction"));
    },
    "groupCallStreamChannel": function(w, v) {
      w.uint(2162903215);
      w.int(h(v, "channel"));
      w.int(h(v, "scale"));
      w.long(h(v, "lastTimestampMs"));
    },
    "phone.groupCallStreamChannels": function(w, v) {
      w.uint(3504636594);
      w.vector(w.object, h(v, "channels"));
    },
    "phone.groupCallStreamRtmpUrl": function(w, v) {
      w.uint(767505458);
      w.string(h(v, "url"));
      w.string(h(v, "key"));
    },
    "attachMenuBotIconColor": function(w, v) {
      w.uint(1165423600);
      w.string(h(v, "name"));
      w.int(h(v, "color"));
    },
    "attachMenuBotIcon": function(w, v) {
      w.uint(2997303403);
      var flags = 0;
      var _colors = v.colors && v.colors.length;
      if (_colors)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "name"));
      w.object(h(v, "icon"));
      if (_colors)
        w.vector(w.object, v.colors);
    },
    "attachMenuBot": function(w, v) {
      w.uint(3641544190);
      var flags = 0;
      if (v.inactive === true)
        flags |= 1;
      if (v.hasSettings === true)
        flags |= 2;
      if (v.requestWriteAccess === true)
        flags |= 4;
      var _peerTypes = v.peerTypes && v.peerTypes.length;
      var _flags_3 = v.showInAttachMenu === true || _peerTypes;
      if (_flags_3)
        flags |= 8;
      if (v.showInSideMenu === true)
        flags |= 16;
      if (v.sideMenuDisclaimerNeeded === true)
        flags |= 32;
      w.uint(flags);
      w.int53(h(v, "botId"));
      w.string(h(v, "shortName"));
      if (_flags_3)
        w.vector(w.object, v.peerTypes);
      w.vector(w.object, h(v, "icons"));
    },
    "attachMenuBotsNotModified": function(w) {
      w.uint(4057500252);
    },
    "attachMenuBots": function(w, v) {
      w.uint(1011024320);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "bots"));
      w.vector(w.object, h(v, "users"));
    },
    "attachMenuBotsBot": function(w, v) {
      w.uint(2478794367);
      w.object(h(v, "bot"));
      w.vector(w.object, h(v, "users"));
    },
    "webViewResultUrl": function(w, v) {
      w.uint(1294139288);
      var flags = 0;
      var _queryId = v.queryId !== void 0;
      if (_queryId)
        flags |= 1;
      if (v.fullsize === true)
        flags |= 2;
      w.uint(flags);
      if (_queryId)
        w.long(v.queryId);
      w.string(h(v, "url"));
    },
    "webViewMessageSent": function(w, v) {
      w.uint(211046684);
      var flags = 0;
      var _msgId = v.msgId !== void 0;
      if (_msgId)
        flags |= 1;
      w.uint(flags);
      if (_msgId)
        w.object(v.msgId);
    },
    "botMenuButtonDefault": function(w) {
      w.uint(1966318984);
    },
    "botMenuButtonCommands": function(w) {
      w.uint(1113113093);
    },
    "botMenuButton": function(w, v) {
      w.uint(3350559974);
      w.string(h(v, "text"));
      w.string(h(v, "url"));
    },
    "account.savedRingtonesNotModified": function(w) {
      w.uint(4227262641);
    },
    "account.savedRingtones": function(w, v) {
      w.uint(3253284037);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "ringtones"));
    },
    "notificationSoundDefault": function(w) {
      w.uint(2548612798);
    },
    "notificationSoundNone": function(w) {
      w.uint(1863070943);
    },
    "notificationSoundLocal": function(w, v) {
      w.uint(2198575844);
      w.string(h(v, "title"));
      w.string(h(v, "data"));
    },
    "notificationSoundRingtone": function(w, v) {
      w.uint(4285300809);
      w.long(h(v, "id"));
    },
    "account.savedRingtone": function(w) {
      w.uint(3072737133);
    },
    "account.savedRingtoneConverted": function(w, v) {
      w.uint(523271863);
      w.object(h(v, "document"));
    },
    "attachMenuPeerTypeSameBotPM": function(w) {
      w.uint(2104224014);
    },
    "attachMenuPeerTypeBotPM": function(w) {
      w.uint(3274439194);
    },
    "attachMenuPeerTypePM": function(w) {
      w.uint(4047950623);
    },
    "attachMenuPeerTypeChat": function(w) {
      w.uint(84480319);
    },
    "attachMenuPeerTypeBroadcast": function(w) {
      w.uint(2080104188);
    },
    "inputInvoiceMessage": function(w, v) {
      w.uint(3317000281);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "inputInvoiceSlug": function(w, v) {
      w.uint(3274099439);
      w.string(h(v, "slug"));
    },
    "inputInvoicePremiumGiftCode": function(w, v) {
      w.uint(2560125965);
      w.object(h(v, "purpose"));
      w.object(h(v, "option"));
    },
    "inputInvoiceStars": function(w, v) {
      w.uint(1710230755);
      w.object(h(v, "purpose"));
    },
    "inputInvoiceChatInviteSubscription": function(w, v) {
      w.uint(887591921);
      w.string(h(v, "hash"));
    },
    "inputInvoiceStarGift": function(w, v) {
      w.uint(634962392);
      var flags = 0;
      if (v.hideName === true)
        flags |= 1;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "userId"));
      w.long(h(v, "giftId"));
      if (_message)
        w.object(v.message);
    },
    "payments.exportedInvoice": function(w, v) {
      w.uint(2932919257);
      w.string(h(v, "url"));
    },
    "messages.transcribedAudio": function(w, v) {
      w.uint(3485063511);
      var flags = 0;
      if (v.pending === true)
        flags |= 1;
      var _trialRemainsNum = v.trialRemainsNum !== void 0;
      var _trialRemainsUntilDate = v.trialRemainsUntilDate !== void 0;
      var _flags_1 = _trialRemainsNum || _trialRemainsUntilDate;
      if (_flags_1)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "transcriptionId"));
      w.string(h(v, "text"));
      if (_flags_1)
        w.int(v.trialRemainsNum);
      if (_flags_1)
        w.int(v.trialRemainsUntilDate);
    },
    "help.premiumPromo": function(w, v) {
      w.uint(1395946908);
      w.string(h(v, "statusText"));
      w.vector(w.object, h(v, "statusEntities"));
      w.vector(w.string, h(v, "videoSections"));
      w.vector(w.object, h(v, "videos"));
      w.vector(w.object, h(v, "periodOptions"));
      w.vector(w.object, h(v, "users"));
    },
    "inputStorePaymentPremiumSubscription": function(w, v) {
      w.uint(2792693350);
      var flags = 0;
      if (v.restore === true)
        flags |= 1;
      if (v.upgrade === true)
        flags |= 2;
      w.uint(flags);
    },
    "inputStorePaymentGiftPremium": function(w, v) {
      w.uint(1634697192);
      w.object(h(v, "userId"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "inputStorePaymentPremiumGiftCode": function(w, v) {
      w.uint(2743099199);
      var flags = 0;
      var _boostPeer = v.boostPeer !== void 0;
      if (_boostPeer)
        flags |= 1;
      w.uint(flags);
      w.vector(w.object, h(v, "users"));
      if (_boostPeer)
        w.object(v.boostPeer);
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "inputStorePaymentPremiumGiveaway": function(w, v) {
      w.uint(369444042);
      var flags = 0;
      if (v.onlyNewSubscribers === true)
        flags |= 1;
      var _additionalPeers = v.additionalPeers && v.additionalPeers.length;
      if (_additionalPeers)
        flags |= 2;
      var _countriesIso2 = v.countriesIso2 && v.countriesIso2.length;
      if (_countriesIso2)
        flags |= 4;
      if (v.winnersAreVisible === true)
        flags |= 8;
      var _prizeDescription = v.prizeDescription !== void 0;
      if (_prizeDescription)
        flags |= 16;
      w.uint(flags);
      w.object(h(v, "boostPeer"));
      if (_additionalPeers)
        w.vector(w.object, v.additionalPeers);
      if (_countriesIso2)
        w.vector(w.string, v.countriesIso2);
      if (_prizeDescription)
        w.string(v.prizeDescription);
      w.long(h(v, "randomId"));
      w.int(h(v, "untilDate"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "inputStorePaymentStarsTopup": function(w, v) {
      w.uint(3722252118);
      w.long(h(v, "stars"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "inputStorePaymentStarsGift": function(w, v) {
      w.uint(494149367);
      w.object(h(v, "userId"));
      w.long(h(v, "stars"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "inputStorePaymentStarsGiveaway": function(w, v) {
      w.uint(1964968186);
      var flags = 0;
      if (v.onlyNewSubscribers === true)
        flags |= 1;
      var _additionalPeers = v.additionalPeers && v.additionalPeers.length;
      if (_additionalPeers)
        flags |= 2;
      var _countriesIso2 = v.countriesIso2 && v.countriesIso2.length;
      if (_countriesIso2)
        flags |= 4;
      if (v.winnersAreVisible === true)
        flags |= 8;
      var _prizeDescription = v.prizeDescription !== void 0;
      if (_prizeDescription)
        flags |= 16;
      w.uint(flags);
      w.long(h(v, "stars"));
      w.object(h(v, "boostPeer"));
      if (_additionalPeers)
        w.vector(w.object, v.additionalPeers);
      if (_countriesIso2)
        w.vector(w.string, v.countriesIso2);
      if (_prizeDescription)
        w.string(v.prizeDescription);
      w.long(h(v, "randomId"));
      w.int(h(v, "untilDate"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
      w.int(h(v, "users"));
    },
    "premiumGiftOption": function(w, v) {
      w.uint(1958953753);
      var flags = 0;
      var _storeProduct = v.storeProduct !== void 0;
      if (_storeProduct)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "months"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
      w.string(h(v, "botUrl"));
      if (_storeProduct)
        w.string(v.storeProduct);
    },
    "paymentFormMethod": function(w, v) {
      w.uint(2298016283);
      w.string(h(v, "url"));
      w.string(h(v, "title"));
    },
    "emojiStatusEmpty": function(w) {
      w.uint(769727150);
    },
    "emojiStatus": function(w, v) {
      w.uint(2459656605);
      w.long(h(v, "documentId"));
    },
    "emojiStatusUntil": function(w, v) {
      w.uint(4197492935);
      w.long(h(v, "documentId"));
      w.int(h(v, "until"));
    },
    "account.emojiStatusesNotModified": function(w) {
      w.uint(3498894917);
    },
    "account.emojiStatuses": function(w, v) {
      w.uint(2428790737);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "statuses"));
    },
    "reactionEmpty": function(w) {
      w.uint(2046153753);
    },
    "reactionEmoji": function(w, v) {
      w.uint(455247544);
      w.string(h(v, "emoticon"));
    },
    "reactionCustomEmoji": function(w, v) {
      w.uint(2302016627);
      w.long(h(v, "documentId"));
    },
    "reactionPaid": function(w) {
      w.uint(1379771627);
    },
    "chatReactionsNone": function(w) {
      w.uint(3942396604);
    },
    "chatReactionsAll": function(w, v) {
      w.uint(1385335754);
      var flags = 0;
      if (v.allowCustom === true)
        flags |= 1;
      w.uint(flags);
    },
    "chatReactionsSome": function(w, v) {
      w.uint(1713193015);
      w.vector(w.object, h(v, "reactions"));
    },
    "messages.reactionsNotModified": function(w) {
      w.uint(2960120799);
    },
    "messages.reactions": function(w, v) {
      w.uint(3942512406);
      w.long(h(v, "hash"));
      w.vector(w.object, h(v, "reactions"));
    },
    "emailVerifyPurposeLoginSetup": function(w, v) {
      w.uint(1128644211);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
    },
    "emailVerifyPurposeLoginChange": function(w) {
      w.uint(1383932651);
    },
    "emailVerifyPurposePassport": function(w) {
      w.uint(3153401477);
    },
    "emailVerificationCode": function(w, v) {
      w.uint(2452510121);
      w.string(h(v, "code"));
    },
    "emailVerificationGoogle": function(w, v) {
      w.uint(3683688130);
      w.string(h(v, "token"));
    },
    "emailVerificationApple": function(w, v) {
      w.uint(2530243837);
      w.string(h(v, "token"));
    },
    "account.emailVerified": function(w, v) {
      w.uint(731303195);
      w.string(h(v, "email"));
    },
    "account.emailVerifiedLogin": function(w, v) {
      w.uint(3787132257);
      w.string(h(v, "email"));
      w.object(h(v, "sentCode"));
    },
    "premiumSubscriptionOption": function(w, v) {
      w.uint(1596792306);
      var flags = 0;
      var _storeProduct = v.storeProduct !== void 0;
      if (_storeProduct)
        flags |= 1;
      if (v.current === true)
        flags |= 2;
      if (v.canPurchaseUpgrade === true)
        flags |= 4;
      var _transaction = v.transaction !== void 0;
      if (_transaction)
        flags |= 8;
      w.uint(flags);
      if (_transaction)
        w.string(v.transaction);
      w.int(h(v, "months"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
      w.string(h(v, "botUrl"));
      if (_storeProduct)
        w.string(v.storeProduct);
    },
    "sendAsPeer": function(w, v) {
      w.uint(3088871476);
      var flags = 0;
      if (v.premiumRequired === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "messageExtendedMediaPreview": function(w, v) {
      w.uint(2908916936);
      var flags = 0;
      var _w = v.w !== void 0;
      var _h = v.h !== void 0;
      var _flags_0 = _w || _h;
      if (_flags_0)
        flags |= 1;
      var _thumb = v.thumb !== void 0;
      if (_thumb)
        flags |= 2;
      var _videoDuration = v.videoDuration !== void 0;
      if (_videoDuration)
        flags |= 4;
      w.uint(flags);
      if (_flags_0)
        w.int(v.w);
      if (_flags_0)
        w.int(v.h);
      if (_thumb)
        w.object(v.thumb);
      if (_videoDuration)
        w.int(v.videoDuration);
    },
    "messageExtendedMedia": function(w, v) {
      w.uint(3997670500);
      w.object(h(v, "media"));
    },
    "stickerKeyword": function(w, v) {
      w.uint(4244550300);
      w.long(h(v, "documentId"));
      w.vector(w.string, h(v, "keyword"));
    },
    "username": function(w, v) {
      w.uint(3020371527);
      var flags = 0;
      if (v.editable === true)
        flags |= 1;
      if (v.active === true)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "username"));
    },
    "forumTopicDeleted": function(w, v) {
      w.uint(37687451);
      w.int(h(v, "id"));
    },
    "forumTopic": function(w, v) {
      w.uint(1903173033);
      var flags = 0;
      var _iconEmojiId = v.iconEmojiId !== void 0;
      if (_iconEmojiId)
        flags |= 1;
      if (v.my === true)
        flags |= 2;
      if (v.closed === true)
        flags |= 4;
      if (v.pinned === true)
        flags |= 8;
      var _draft = v.draft !== void 0;
      if (_draft)
        flags |= 16;
      if (v.short === true)
        flags |= 32;
      if (v.hidden === true)
        flags |= 64;
      w.uint(flags);
      w.int(h(v, "id"));
      w.int(h(v, "date"));
      w.string(h(v, "title"));
      w.int(h(v, "iconColor"));
      if (_iconEmojiId)
        w.long(v.iconEmojiId);
      w.int(h(v, "topMessage"));
      w.int(h(v, "readInboxMaxId"));
      w.int(h(v, "readOutboxMaxId"));
      w.int(h(v, "unreadCount"));
      w.int(h(v, "unreadMentionsCount"));
      w.int(h(v, "unreadReactionsCount"));
      w.object(h(v, "fromId"));
      w.object(h(v, "notifySettings"));
      if (_draft)
        w.object(v.draft);
    },
    "messages.forumTopics": function(w, v) {
      w.uint(913709011);
      var flags = 0;
      if (v.orderByCreateDate === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "topics"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      w.int(h(v, "pts"));
    },
    "defaultHistoryTTL": function(w, v) {
      w.uint(1135897376);
      w.int(h(v, "period"));
    },
    "exportedContactToken": function(w, v) {
      w.uint(1103040667);
      w.string(h(v, "url"));
      w.int(h(v, "expires"));
    },
    "requestPeerTypeUser": function(w, v) {
      w.uint(1597737472);
      var flags = 0;
      var _bot = v.bot !== void 0;
      if (_bot)
        flags |= 1;
      var _premium = v.premium !== void 0;
      if (_premium)
        flags |= 2;
      w.uint(flags);
      if (_bot)
        w.boolean(v.bot);
      if (_premium)
        w.boolean(v.premium);
    },
    "requestPeerTypeChat": function(w, v) {
      w.uint(3387977243);
      var flags = 0;
      if (v.creator === true)
        flags |= 1;
      var _userAdminRights = v.userAdminRights !== void 0;
      if (_userAdminRights)
        flags |= 2;
      var _botAdminRights = v.botAdminRights !== void 0;
      if (_botAdminRights)
        flags |= 4;
      var _hasUsername = v.hasUsername !== void 0;
      if (_hasUsername)
        flags |= 8;
      var _forum = v.forum !== void 0;
      if (_forum)
        flags |= 16;
      if (v.botParticipant === true)
        flags |= 32;
      w.uint(flags);
      if (_hasUsername)
        w.boolean(v.hasUsername);
      if (_forum)
        w.boolean(v.forum);
      if (_userAdminRights)
        w.object(v.userAdminRights);
      if (_botAdminRights)
        w.object(v.botAdminRights);
    },
    "requestPeerTypeBroadcast": function(w, v) {
      w.uint(865857388);
      var flags = 0;
      if (v.creator === true)
        flags |= 1;
      var _userAdminRights = v.userAdminRights !== void 0;
      if (_userAdminRights)
        flags |= 2;
      var _botAdminRights = v.botAdminRights !== void 0;
      if (_botAdminRights)
        flags |= 4;
      var _hasUsername = v.hasUsername !== void 0;
      if (_hasUsername)
        flags |= 8;
      w.uint(flags);
      if (_hasUsername)
        w.boolean(v.hasUsername);
      if (_userAdminRights)
        w.object(v.userAdminRights);
      if (_botAdminRights)
        w.object(v.botAdminRights);
    },
    "emojiListNotModified": function(w) {
      w.uint(1209970170);
    },
    "emojiList": function(w, v) {
      w.uint(2048790993);
      w.long(h(v, "hash"));
      w.vector(w.long, h(v, "documentId"));
    },
    "emojiGroup": function(w, v) {
      w.uint(2056961449);
      w.string(h(v, "title"));
      w.long(h(v, "iconEmojiId"));
      w.vector(w.string, h(v, "emoticons"));
    },
    "emojiGroupGreeting": function(w, v) {
      w.uint(2161274055);
      w.string(h(v, "title"));
      w.long(h(v, "iconEmojiId"));
      w.vector(w.string, h(v, "emoticons"));
    },
    "emojiGroupPremium": function(w, v) {
      w.uint(154914612);
      w.string(h(v, "title"));
      w.long(h(v, "iconEmojiId"));
    },
    "messages.emojiGroupsNotModified": function(w) {
      w.uint(1874111879);
    },
    "messages.emojiGroups": function(w, v) {
      w.uint(2283780427);
      w.int(h(v, "hash"));
      w.vector(w.object, h(v, "groups"));
    },
    "textWithEntities": function(w, v) {
      w.uint(1964978502);
      w.string(h(v, "text"));
      w.vector(w.object, h(v, "entities"));
    },
    "messages.translateResult": function(w, v) {
      w.uint(870003448);
      w.vector(w.object, h(v, "result"));
    },
    "autoSaveSettings": function(w, v) {
      w.uint(3360175310);
      var flags = 0;
      if (v.photos === true)
        flags |= 1;
      if (v.videos === true)
        flags |= 2;
      var _videoMaxSize = v.videoMaxSize !== void 0;
      if (_videoMaxSize)
        flags |= 4;
      w.uint(flags);
      if (_videoMaxSize)
        w.long(v.videoMaxSize);
    },
    "autoSaveException": function(w, v) {
      w.uint(2170563911);
      w.object(h(v, "peer"));
      w.object(h(v, "settings"));
    },
    "account.autoSaveSettings": function(w, v) {
      w.uint(1279133341);
      w.object(h(v, "usersSettings"));
      w.object(h(v, "chatsSettings"));
      w.object(h(v, "broadcastsSettings"));
      w.vector(w.object, h(v, "exceptions"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "help.appConfigNotModified": function(w) {
      w.uint(2094949405);
    },
    "help.appConfig": function(w, v) {
      w.uint(3709368366);
      w.int(h(v, "hash"));
      w.object(h(v, "config"));
    },
    "inputBotAppID": function(w, v) {
      w.uint(2837495162);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
    },
    "inputBotAppShortName": function(w, v) {
      w.uint(2425095175);
      w.object(h(v, "botId"));
      w.string(h(v, "shortName"));
    },
    "botAppNotModified": function(w) {
      w.uint(1571189943);
    },
    "botApp": function(w, v) {
      w.uint(2516373974);
      var flags = 0;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "id"));
      w.long(h(v, "accessHash"));
      w.string(h(v, "shortName"));
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      w.object(h(v, "photo"));
      if (_document)
        w.object(v.document);
      w.long(h(v, "hash"));
    },
    "messages.botApp": function(w, v) {
      w.uint(3947933173);
      var flags = 0;
      if (v.inactive === true)
        flags |= 1;
      if (v.requestWriteAccess === true)
        flags |= 2;
      if (v.hasSettings === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "app"));
    },
    "inlineBotWebView": function(w, v) {
      w.uint(3044185557);
      w.string(h(v, "text"));
      w.string(h(v, "url"));
    },
    "readParticipantDate": function(w, v) {
      w.uint(1246753138);
      w.int53(h(v, "userId"));
      w.int(h(v, "date"));
    },
    "inputChatlistDialogFilter": function(w, v) {
      w.uint(4091599411);
      w.int(h(v, "filterId"));
    },
    "exportedChatlistInvite": function(w, v) {
      w.uint(206668204);
      var flags = 0;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "url"));
      w.vector(w.object, h(v, "peers"));
    },
    "chatlists.exportedChatlistInvite": function(w, v) {
      w.uint(283567014);
      w.object(h(v, "filter"));
      w.object(h(v, "invite"));
    },
    "chatlists.exportedInvites": function(w, v) {
      w.uint(279670215);
      w.vector(w.object, h(v, "invites"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "chatlists.chatlistInviteAlready": function(w, v) {
      w.uint(4203214425);
      w.int(h(v, "filterId"));
      w.vector(w.object, h(v, "missingPeers"));
      w.vector(w.object, h(v, "alreadyPeers"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "chatlists.chatlistInvite": function(w, v) {
      w.uint(500007837);
      var flags = 0;
      var _emoticon = v.emoticon !== void 0;
      if (_emoticon)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "title"));
      if (_emoticon)
        w.string(v.emoticon);
      w.vector(w.object, h(v, "peers"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "chatlists.chatlistUpdates": function(w, v) {
      w.uint(2478671757);
      w.vector(w.object, h(v, "missingPeers"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "bots.botInfo": function(w, v) {
      w.uint(3903288752);
      w.string(h(v, "name"));
      w.string(h(v, "about"));
      w.string(h(v, "description"));
    },
    "messagePeerVote": function(w, v) {
      w.uint(3066834268);
      w.object(h(v, "peer"));
      w.bytes(h(v, "option"));
      w.int(h(v, "date"));
    },
    "messagePeerVoteInputOption": function(w, v) {
      w.uint(1959634180);
      w.object(h(v, "peer"));
      w.int(h(v, "date"));
    },
    "messagePeerVoteMultiple": function(w, v) {
      w.uint(1177089766);
      w.object(h(v, "peer"));
      w.vector(w.bytes, h(v, "options"));
      w.int(h(v, "date"));
    },
    "storyViews": function(w, v) {
      w.uint(2371443926);
      var flags = 0;
      var _recentViewers = v.recentViewers && v.recentViewers.length;
      if (_recentViewers)
        flags |= 1;
      if (v.hasViewers === true)
        flags |= 2;
      var _forwardsCount = v.forwardsCount !== void 0;
      if (_forwardsCount)
        flags |= 4;
      var _reactions = v.reactions && v.reactions.length;
      if (_reactions)
        flags |= 8;
      var _reactionsCount = v.reactionsCount !== void 0;
      if (_reactionsCount)
        flags |= 16;
      w.uint(flags);
      w.int(h(v, "viewsCount"));
      if (_forwardsCount)
        w.int(v.forwardsCount);
      if (_reactions)
        w.vector(w.object, v.reactions);
      if (_reactionsCount)
        w.int(v.reactionsCount);
      if (_recentViewers)
        w.vector(w.int53, v.recentViewers);
    },
    "storyItemDeleted": function(w, v) {
      w.uint(1374088783);
      w.int(h(v, "id"));
    },
    "storyItemSkipped": function(w, v) {
      w.uint(4289579283);
      var flags = 0;
      if (v.closeFriends === true)
        flags |= 256;
      w.uint(flags);
      w.int(h(v, "id"));
      w.int(h(v, "date"));
      w.int(h(v, "expireDate"));
    },
    "storyItem": function(w, v) {
      w.uint(2041735716);
      var flags = 0;
      var _caption = v.caption !== void 0;
      if (_caption)
        flags |= 1;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      var _privacy = v.privacy && v.privacy.length;
      if (_privacy)
        flags |= 4;
      var _views = v.views !== void 0;
      if (_views)
        flags |= 8;
      if (v.pinned === true)
        flags |= 32;
      if (v.public === true)
        flags |= 128;
      if (v.closeFriends === true)
        flags |= 256;
      if (v.min === true)
        flags |= 512;
      if (v.noforwards === true)
        flags |= 1024;
      if (v.edited === true)
        flags |= 2048;
      if (v.contacts === true)
        flags |= 4096;
      if (v.selectedContacts === true)
        flags |= 8192;
      var _mediaAreas = v.mediaAreas && v.mediaAreas.length;
      if (_mediaAreas)
        flags |= 16384;
      var _sentReaction = v.sentReaction !== void 0;
      if (_sentReaction)
        flags |= 32768;
      if (v.out === true)
        flags |= 65536;
      var _fwdFrom = v.fwdFrom !== void 0;
      if (_fwdFrom)
        flags |= 131072;
      var _fromId = v.fromId !== void 0;
      if (_fromId)
        flags |= 262144;
      w.uint(flags);
      w.int(h(v, "id"));
      w.int(h(v, "date"));
      if (_fromId)
        w.object(v.fromId);
      if (_fwdFrom)
        w.object(v.fwdFrom);
      w.int(h(v, "expireDate"));
      if (_caption)
        w.string(v.caption);
      if (_entities)
        w.vector(w.object, v.entities);
      w.object(h(v, "media"));
      if (_mediaAreas)
        w.vector(w.object, v.mediaAreas);
      if (_privacy)
        w.vector(w.object, v.privacy);
      if (_views)
        w.object(v.views);
      if (_sentReaction)
        w.object(v.sentReaction);
    },
    "stories.allStoriesNotModified": function(w, v) {
      w.uint(291044926);
      var flags = 0;
      w.uint(flags);
      w.string(h(v, "state"));
      w.object(h(v, "stealthMode"));
    },
    "stories.allStories": function(w, v) {
      w.uint(1862033025);
      var flags = 0;
      if (v.hasMore === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.string(h(v, "state"));
      w.vector(w.object, h(v, "peerStories"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      w.object(h(v, "stealthMode"));
    },
    "stories.stories": function(w, v) {
      w.uint(1673780490);
      var flags = 0;
      var _pinnedToTop = v.pinnedToTop && v.pinnedToTop.length;
      if (_pinnedToTop)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "stories"));
      if (_pinnedToTop)
        w.vector(w.int, v.pinnedToTop);
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "storyView": function(w, v) {
      w.uint(2965236421);
      var flags = 0;
      if (v.blocked === true)
        flags |= 1;
      if (v.blockedMyStoriesFrom === true)
        flags |= 2;
      var _reaction = v.reaction !== void 0;
      if (_reaction)
        flags |= 4;
      w.uint(flags);
      w.int53(h(v, "userId"));
      w.int(h(v, "date"));
      if (_reaction)
        w.object(v.reaction);
    },
    "storyViewPublicForward": function(w, v) {
      w.uint(2424530699);
      var flags = 0;
      if (v.blocked === true)
        flags |= 1;
      if (v.blockedMyStoriesFrom === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "message"));
    },
    "storyViewPublicRepost": function(w, v) {
      w.uint(3178549065);
      var flags = 0;
      if (v.blocked === true)
        flags |= 1;
      if (v.blockedMyStoriesFrom === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peerId"));
      w.object(h(v, "story"));
    },
    "stories.storyViewsList": function(w, v) {
      w.uint(1507299269);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.int(h(v, "viewsCount"));
      w.int(h(v, "forwardsCount"));
      w.int(h(v, "reactionsCount"));
      w.vector(w.object, h(v, "views"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      if (_nextOffset)
        w.string(v.nextOffset);
    },
    "stories.storyViews": function(w, v) {
      w.uint(3734957341);
      w.vector(w.object, h(v, "views"));
      w.vector(w.object, h(v, "users"));
    },
    "inputReplyToMessage": function(w, v) {
      w.uint(583071445);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      var _replyToPeerId = v.replyToPeerId !== void 0;
      if (_replyToPeerId)
        flags |= 2;
      var _quoteText = v.quoteText !== void 0;
      if (_quoteText)
        flags |= 4;
      var _quoteEntities = v.quoteEntities && v.quoteEntities.length;
      if (_quoteEntities)
        flags |= 8;
      var _quoteOffset = v.quoteOffset !== void 0;
      if (_quoteOffset)
        flags |= 16;
      w.uint(flags);
      w.int(h(v, "replyToMsgId"));
      if (_topMsgId)
        w.int(v.topMsgId);
      if (_replyToPeerId)
        w.object(v.replyToPeerId);
      if (_quoteText)
        w.string(v.quoteText);
      if (_quoteEntities)
        w.vector(w.object, v.quoteEntities);
      if (_quoteOffset)
        w.int(v.quoteOffset);
    },
    "inputReplyToStory": function(w, v) {
      w.uint(1484862010);
      w.object(h(v, "peer"));
      w.int(h(v, "storyId"));
    },
    "exportedStoryLink": function(w, v) {
      w.uint(1070138683);
      w.string(h(v, "link"));
    },
    "storiesStealthMode": function(w, v) {
      w.uint(1898850301);
      var flags = 0;
      var _activeUntilDate = v.activeUntilDate !== void 0;
      if (_activeUntilDate)
        flags |= 1;
      var _cooldownUntilDate = v.cooldownUntilDate !== void 0;
      if (_cooldownUntilDate)
        flags |= 2;
      w.uint(flags);
      if (_activeUntilDate)
        w.int(v.activeUntilDate);
      if (_cooldownUntilDate)
        w.int(v.cooldownUntilDate);
    },
    "mediaAreaCoordinates": function(w, v) {
      w.uint(3486113794);
      var flags = 0;
      var _radius = v.radius !== void 0;
      if (_radius)
        flags |= 1;
      w.uint(flags);
      w.double(h(v, "x"));
      w.double(h(v, "y"));
      w.double(h(v, "w"));
      w.double(h(v, "h"));
      w.double(h(v, "rotation"));
      if (_radius)
        w.double(v.radius);
    },
    "mediaAreaVenue": function(w, v) {
      w.uint(3196246940);
      w.object(h(v, "coordinates"));
      w.object(h(v, "geo"));
      w.string(h(v, "title"));
      w.string(h(v, "address"));
      w.string(h(v, "provider"));
      w.string(h(v, "venueId"));
      w.string(h(v, "venueType"));
    },
    "inputMediaAreaVenue": function(w, v) {
      w.uint(2994872703);
      w.object(h(v, "coordinates"));
      w.long(h(v, "queryId"));
      w.string(h(v, "resultId"));
    },
    "mediaAreaGeoPoint": function(w, v) {
      w.uint(3402974509);
      var flags = 0;
      var _address = v.address !== void 0;
      if (_address)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "coordinates"));
      w.object(h(v, "geo"));
      if (_address)
        w.object(v.address);
    },
    "mediaAreaSuggestedReaction": function(w, v) {
      w.uint(340088945);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      if (v.flipped === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "coordinates"));
      w.object(h(v, "reaction"));
    },
    "mediaAreaChannelPost": function(w, v) {
      w.uint(1996756655);
      w.object(h(v, "coordinates"));
      w.int53(h(v, "channelId"));
      w.int(h(v, "msgId"));
    },
    "inputMediaAreaChannelPost": function(w, v) {
      w.uint(577893055);
      w.object(h(v, "coordinates"));
      w.object(h(v, "channel"));
      w.int(h(v, "msgId"));
    },
    "mediaAreaUrl": function(w, v) {
      w.uint(926421125);
      w.object(h(v, "coordinates"));
      w.string(h(v, "url"));
    },
    "mediaAreaWeather": function(w, v) {
      w.uint(1235637404);
      w.object(h(v, "coordinates"));
      w.string(h(v, "emoji"));
      w.double(h(v, "temperatureC"));
      w.int(h(v, "color"));
    },
    "peerStories": function(w, v) {
      w.uint(2587224473);
      var flags = 0;
      var _maxReadId = v.maxReadId !== void 0;
      if (_maxReadId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_maxReadId)
        w.int(v.maxReadId);
      w.vector(w.object, h(v, "stories"));
    },
    "stories.peerStories": function(w, v) {
      w.uint(3404105576);
      w.object(h(v, "stories"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.webPage": function(w, v) {
      w.uint(4250800829);
      w.object(h(v, "webpage"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "premiumGiftCodeOption": function(w, v) {
      w.uint(629052971);
      var flags = 0;
      var _storeProduct = v.storeProduct !== void 0;
      if (_storeProduct)
        flags |= 1;
      var _storeQuantity = v.storeQuantity !== void 0;
      if (_storeQuantity)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "users"));
      w.int(h(v, "months"));
      if (_storeProduct)
        w.string(v.storeProduct);
      if (_storeQuantity)
        w.int(v.storeQuantity);
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "payments.checkedGiftCode": function(w, v) {
      w.uint(675942550);
      var flags = 0;
      var _toId = v.toId !== void 0;
      if (_toId)
        flags |= 1;
      var _usedDate = v.usedDate !== void 0;
      if (_usedDate)
        flags |= 2;
      if (v.viaGiveaway === true)
        flags |= 4;
      var _giveawayMsgId = v.giveawayMsgId !== void 0;
      if (_giveawayMsgId)
        flags |= 8;
      var _fromId = v.fromId !== void 0;
      if (_fromId)
        flags |= 16;
      w.uint(flags);
      if (_fromId)
        w.object(v.fromId);
      if (_giveawayMsgId)
        w.int(v.giveawayMsgId);
      if (_toId)
        w.long(v.toId);
      w.int(h(v, "date"));
      w.int(h(v, "months"));
      if (_usedDate)
        w.int(v.usedDate);
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "payments.giveawayInfo": function(w, v) {
      w.uint(1130879648);
      var flags = 0;
      if (v.participating === true)
        flags |= 1;
      var _joinedTooEarlyDate = v.joinedTooEarlyDate !== void 0;
      if (_joinedTooEarlyDate)
        flags |= 2;
      var _adminDisallowedChatId = v.adminDisallowedChatId !== void 0;
      if (_adminDisallowedChatId)
        flags |= 4;
      if (v.preparingResults === true)
        flags |= 8;
      var _disallowedCountry = v.disallowedCountry !== void 0;
      if (_disallowedCountry)
        flags |= 16;
      w.uint(flags);
      w.int(h(v, "startDate"));
      if (_joinedTooEarlyDate)
        w.int(v.joinedTooEarlyDate);
      if (_adminDisallowedChatId)
        w.long(v.adminDisallowedChatId);
      if (_disallowedCountry)
        w.string(v.disallowedCountry);
    },
    "payments.giveawayInfoResults": function(w, v) {
      w.uint(3782600303);
      var flags = 0;
      if (v.winner === true)
        flags |= 1;
      if (v.refunded === true)
        flags |= 2;
      var _activatedCount = v.activatedCount !== void 0;
      if (_activatedCount)
        flags |= 4;
      var _giftCodeSlug = v.giftCodeSlug !== void 0;
      if (_giftCodeSlug)
        flags |= 8;
      var _starsPrize = v.starsPrize !== void 0;
      if (_starsPrize)
        flags |= 16;
      w.uint(flags);
      w.int(h(v, "startDate"));
      if (_giftCodeSlug)
        w.string(v.giftCodeSlug);
      if (_starsPrize)
        w.long(v.starsPrize);
      w.int(h(v, "finishDate"));
      w.int(h(v, "winnersCount"));
      if (_activatedCount)
        w.int(v.activatedCount);
    },
    "prepaidGiveaway": function(w, v) {
      w.uint(2991824212);
      w.long(h(v, "id"));
      w.int(h(v, "months"));
      w.int(h(v, "quantity"));
      w.int(h(v, "date"));
    },
    "prepaidStarsGiveaway": function(w, v) {
      w.uint(2594011104);
      w.long(h(v, "id"));
      w.long(h(v, "stars"));
      w.int(h(v, "quantity"));
      w.int(h(v, "boosts"));
      w.int(h(v, "date"));
    },
    "boost": function(w, v) {
      w.uint(1262359766);
      var flags = 0;
      var _userId = v.userId !== void 0;
      if (_userId)
        flags |= 1;
      if (v.gift === true)
        flags |= 2;
      var _giveawayMsgId = v.giveawayMsgId !== void 0;
      var _flags_2 = v.giveaway === true || _giveawayMsgId;
      if (_flags_2)
        flags |= 4;
      if (v.unclaimed === true)
        flags |= 8;
      var _usedGiftSlug = v.usedGiftSlug !== void 0;
      if (_usedGiftSlug)
        flags |= 16;
      var _multiplier = v.multiplier !== void 0;
      if (_multiplier)
        flags |= 32;
      var _stars = v.stars !== void 0;
      if (_stars)
        flags |= 64;
      w.uint(flags);
      w.string(h(v, "id"));
      if (_userId)
        w.int53(v.userId);
      if (_flags_2)
        w.int(v.giveawayMsgId);
      w.int(h(v, "date"));
      w.int(h(v, "expires"));
      if (_usedGiftSlug)
        w.string(v.usedGiftSlug);
      if (_multiplier)
        w.int(v.multiplier);
      if (_stars)
        w.long(v.stars);
    },
    "premium.boostsList": function(w, v) {
      w.uint(2264424764);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "boosts"));
      if (_nextOffset)
        w.string(v.nextOffset);
      w.vector(w.object, h(v, "users"));
    },
    "myBoost": function(w, v) {
      w.uint(3293069660);
      var flags = 0;
      var _peer = v.peer !== void 0;
      if (_peer)
        flags |= 1;
      var _cooldownUntilDate = v.cooldownUntilDate !== void 0;
      if (_cooldownUntilDate)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "slot"));
      if (_peer)
        w.object(v.peer);
      w.int(h(v, "date"));
      w.int(h(v, "expires"));
      if (_cooldownUntilDate)
        w.int(v.cooldownUntilDate);
    },
    "premium.myBoosts": function(w, v) {
      w.uint(2598512866);
      w.vector(w.object, h(v, "myBoosts"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "premium.boostsStatus": function(w, v) {
      w.uint(1230586490);
      var flags = 0;
      var _nextLevelBoosts = v.nextLevelBoosts !== void 0;
      if (_nextLevelBoosts)
        flags |= 1;
      var _premiumAudience = v.premiumAudience !== void 0;
      if (_premiumAudience)
        flags |= 2;
      var _myBoostSlots = v.myBoostSlots && v.myBoostSlots.length;
      var _flags_2 = v.myBoost === true || _myBoostSlots;
      if (_flags_2)
        flags |= 4;
      var _prepaidGiveaways = v.prepaidGiveaways && v.prepaidGiveaways.length;
      if (_prepaidGiveaways)
        flags |= 8;
      var _giftBoosts = v.giftBoosts !== void 0;
      if (_giftBoosts)
        flags |= 16;
      w.uint(flags);
      w.int(h(v, "level"));
      w.int(h(v, "currentLevelBoosts"));
      w.int(h(v, "boosts"));
      if (_giftBoosts)
        w.int(v.giftBoosts);
      if (_nextLevelBoosts)
        w.int(v.nextLevelBoosts);
      if (_premiumAudience)
        w.object(v.premiumAudience);
      w.string(h(v, "boostUrl"));
      if (_prepaidGiveaways)
        w.vector(w.object, v.prepaidGiveaways);
      if (_flags_2)
        w.vector(w.int, v.myBoostSlots);
    },
    "storyFwdHeader": function(w, v) {
      w.uint(3089555792);
      var flags = 0;
      var _from = v.from !== void 0;
      if (_from)
        flags |= 1;
      var _fromName = v.fromName !== void 0;
      if (_fromName)
        flags |= 2;
      var _storyId = v.storyId !== void 0;
      if (_storyId)
        flags |= 4;
      if (v.modified === true)
        flags |= 8;
      w.uint(flags);
      if (_from)
        w.object(v.from);
      if (_fromName)
        w.string(v.fromName);
      if (_storyId)
        w.int(v.storyId);
    },
    "postInteractionCountersMessage": function(w, v) {
      w.uint(3875901055);
      w.int(h(v, "msgId"));
      w.int(h(v, "views"));
      w.int(h(v, "forwards"));
      w.int(h(v, "reactions"));
    },
    "postInteractionCountersStory": function(w, v) {
      w.uint(2319978023);
      w.int(h(v, "storyId"));
      w.int(h(v, "views"));
      w.int(h(v, "forwards"));
      w.int(h(v, "reactions"));
    },
    "stats.storyStats": function(w, v) {
      w.uint(1355613820);
      w.object(h(v, "viewsGraph"));
      w.object(h(v, "reactionsByEmotionGraph"));
    },
    "publicForwardMessage": function(w, v) {
      w.uint(32685898);
      w.object(h(v, "message"));
    },
    "publicForwardStory": function(w, v) {
      w.uint(3992169936);
      w.object(h(v, "peer"));
      w.object(h(v, "story"));
    },
    "stats.publicForwards": function(w, v) {
      w.uint(2466479648);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "forwards"));
      if (_nextOffset)
        w.string(v.nextOffset);
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "peerColor": function(w, v) {
      w.uint(3041614543);
      var flags = 0;
      var _color = v.color !== void 0;
      if (_color)
        flags |= 1;
      var _backgroundEmojiId = v.backgroundEmojiId !== void 0;
      if (_backgroundEmojiId)
        flags |= 2;
      w.uint(flags);
      if (_color)
        w.int(v.color);
      if (_backgroundEmojiId)
        w.long(v.backgroundEmojiId);
    },
    "help.peerColorSet": function(w, v) {
      w.uint(639736408);
      w.vector(w.int, h(v, "colors"));
    },
    "help.peerColorProfileSet": function(w, v) {
      w.uint(1987928555);
      w.vector(w.int, h(v, "paletteColors"));
      w.vector(w.int, h(v, "bgColors"));
      w.vector(w.int, h(v, "storyColors"));
    },
    "help.peerColorOption": function(w, v) {
      w.uint(2917953214);
      var flags = 0;
      if (v.hidden === true)
        flags |= 1;
      var _colors = v.colors !== void 0;
      if (_colors)
        flags |= 2;
      var _darkColors = v.darkColors !== void 0;
      if (_darkColors)
        flags |= 4;
      var _channelMinLevel = v.channelMinLevel !== void 0;
      if (_channelMinLevel)
        flags |= 8;
      var _groupMinLevel = v.groupMinLevel !== void 0;
      if (_groupMinLevel)
        flags |= 16;
      w.uint(flags);
      w.int(h(v, "colorId"));
      if (_colors)
        w.object(v.colors);
      if (_darkColors)
        w.object(v.darkColors);
      if (_channelMinLevel)
        w.int(v.channelMinLevel);
      if (_groupMinLevel)
        w.int(v.groupMinLevel);
    },
    "help.peerColorsNotModified": function(w) {
      w.uint(732034510);
    },
    "help.peerColors": function(w, v) {
      w.uint(16313608);
      w.int(h(v, "hash"));
      w.vector(w.object, h(v, "colors"));
    },
    "storyReaction": function(w, v) {
      w.uint(1620104917);
      w.object(h(v, "peerId"));
      w.int(h(v, "date"));
      w.object(h(v, "reaction"));
    },
    "storyReactionPublicForward": function(w, v) {
      w.uint(3148555843);
      w.object(h(v, "message"));
    },
    "storyReactionPublicRepost": function(w, v) {
      w.uint(3486322451);
      w.object(h(v, "peerId"));
      w.object(h(v, "story"));
    },
    "stories.storyReactionsList": function(w, v) {
      w.uint(2858383516);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "reactions"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
      if (_nextOffset)
        w.string(v.nextOffset);
    },
    "savedDialog": function(w, v) {
      w.uint(3179793260);
      var flags = 0;
      if (v.pinned === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "topMessage"));
    },
    "messages.savedDialogs": function(w, v) {
      w.uint(4164608545);
      w.vector(w.object, h(v, "dialogs"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.savedDialogsSlice": function(w, v) {
      w.uint(1153080793);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "dialogs"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.savedDialogsNotModified": function(w, v) {
      w.uint(3223285736);
      w.int(h(v, "count"));
    },
    "savedReactionTag": function(w, v) {
      w.uint(3413112872);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "reaction"));
      if (_title)
        w.string(v.title);
      w.int(h(v, "count"));
    },
    "messages.savedReactionTagsNotModified": function(w) {
      w.uint(2291882479);
    },
    "messages.savedReactionTags": function(w, v) {
      w.uint(844731658);
      w.vector(w.object, h(v, "tags"));
      w.long(h(v, "hash"));
    },
    "outboxReadDate": function(w, v) {
      w.uint(1001931436);
      w.int(h(v, "date"));
    },
    "smsjobs.eligibleToJoin": function(w, v) {
      w.uint(3700114639);
      w.string(h(v, "termsUrl"));
      w.int(h(v, "monthlySentSms"));
    },
    "smsjobs.status": function(w, v) {
      w.uint(720277905);
      var flags = 0;
      if (v.allowInternational === true)
        flags |= 1;
      var _lastGiftSlug = v.lastGiftSlug !== void 0;
      if (_lastGiftSlug)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "recentSent"));
      w.int(h(v, "recentSince"));
      w.int(h(v, "recentRemains"));
      w.int(h(v, "totalSent"));
      w.int(h(v, "totalSince"));
      if (_lastGiftSlug)
        w.string(v.lastGiftSlug);
      w.string(h(v, "termsUrl"));
    },
    "smsJob": function(w, v) {
      w.uint(3869372088);
      w.string(h(v, "jobId"));
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "text"));
    },
    "businessWeeklyOpen": function(w, v) {
      w.uint(302717625);
      w.int(h(v, "startMinute"));
      w.int(h(v, "endMinute"));
    },
    "businessWorkHours": function(w, v) {
      w.uint(2358423704);
      var flags = 0;
      if (v.openNow === true)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "timezoneId"));
      w.vector(w.object, h(v, "weeklyOpen"));
    },
    "businessLocation": function(w, v) {
      w.uint(2891717367);
      var flags = 0;
      var _geoPoint = v.geoPoint !== void 0;
      if (_geoPoint)
        flags |= 1;
      w.uint(flags);
      if (_geoPoint)
        w.object(v.geoPoint);
      w.string(h(v, "address"));
    },
    "inputBusinessRecipients": function(w, v) {
      w.uint(1871393450);
      var flags = 0;
      if (v.existingChats === true)
        flags |= 1;
      if (v.newChats === true)
        flags |= 2;
      if (v.contacts === true)
        flags |= 4;
      if (v.nonContacts === true)
        flags |= 8;
      var _users = v.users && v.users.length;
      if (_users)
        flags |= 16;
      if (v.excludeSelected === true)
        flags |= 32;
      w.uint(flags);
      if (_users)
        w.vector(w.object, v.users);
    },
    "businessRecipients": function(w, v) {
      w.uint(554733559);
      var flags = 0;
      if (v.existingChats === true)
        flags |= 1;
      if (v.newChats === true)
        flags |= 2;
      if (v.contacts === true)
        flags |= 4;
      if (v.nonContacts === true)
        flags |= 8;
      var _users = v.users && v.users.length;
      if (_users)
        flags |= 16;
      if (v.excludeSelected === true)
        flags |= 32;
      w.uint(flags);
      if (_users)
        w.vector(w.int53, v.users);
    },
    "businessAwayMessageScheduleAlways": function(w) {
      w.uint(3384402617);
    },
    "businessAwayMessageScheduleOutsideWorkHours": function(w) {
      w.uint(3287479553);
    },
    "businessAwayMessageScheduleCustom": function(w, v) {
      w.uint(3427638988);
      w.int(h(v, "startDate"));
      w.int(h(v, "endDate"));
    },
    "inputBusinessGreetingMessage": function(w, v) {
      w.uint(26528571);
      w.int(h(v, "shortcutId"));
      w.object(h(v, "recipients"));
      w.int(h(v, "noActivityDays"));
    },
    "businessGreetingMessage": function(w, v) {
      w.uint(3843664811);
      w.int(h(v, "shortcutId"));
      w.object(h(v, "recipients"));
      w.int(h(v, "noActivityDays"));
    },
    "inputBusinessAwayMessage": function(w, v) {
      w.uint(2200008160);
      var flags = 0;
      if (v.offlineOnly === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "shortcutId"));
      w.object(h(v, "schedule"));
      w.object(h(v, "recipients"));
    },
    "businessAwayMessage": function(w, v) {
      w.uint(4011158108);
      var flags = 0;
      if (v.offlineOnly === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "shortcutId"));
      w.object(h(v, "schedule"));
      w.object(h(v, "recipients"));
    },
    "timezone": function(w, v) {
      w.uint(4287793653);
      w.string(h(v, "id"));
      w.string(h(v, "name"));
      w.int(h(v, "utcOffset"));
    },
    "help.timezonesListNotModified": function(w) {
      w.uint(2533820620);
    },
    "help.timezonesList": function(w, v) {
      w.uint(2071260529);
      w.vector(w.object, h(v, "timezones"));
      w.int(h(v, "hash"));
    },
    "quickReply": function(w, v) {
      w.uint(110563371);
      w.int(h(v, "shortcutId"));
      w.string(h(v, "shortcut"));
      w.int(h(v, "topMessage"));
      w.int(h(v, "count"));
    },
    "inputQuickReplyShortcut": function(w, v) {
      w.uint(609840449);
      w.string(h(v, "shortcut"));
    },
    "inputQuickReplyShortcutId": function(w, v) {
      w.uint(18418929);
      w.int(h(v, "shortcutId"));
    },
    "messages.quickReplies": function(w, v) {
      w.uint(3331155605);
      w.vector(w.object, h(v, "quickReplies"));
      w.vector(w.object, h(v, "messages"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.quickRepliesNotModified": function(w) {
      w.uint(1603398491);
    },
    "connectedBot": function(w, v) {
      w.uint(3171321345);
      var flags = 0;
      if (v.canReply === true)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "botId"));
      w.object(h(v, "recipients"));
    },
    "account.connectedBots": function(w, v) {
      w.uint(400029819);
      w.vector(w.object, h(v, "connectedBots"));
      w.vector(w.object, h(v, "users"));
    },
    "messages.dialogFilters": function(w, v) {
      w.uint(718878489);
      var flags = 0;
      if (v.tagsEnabled === true)
        flags |= 1;
      w.uint(flags);
      w.vector(w.object, h(v, "filters"));
    },
    "birthday": function(w, v) {
      w.uint(1821253126);
      var flags = 0;
      var _year = v.year !== void 0;
      if (_year)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "day"));
      w.int(h(v, "month"));
      if (_year)
        w.int(v.year);
    },
    "botBusinessConnection": function(w, v) {
      w.uint(2305045428);
      var flags = 0;
      if (v.canReply === true)
        flags |= 1;
      if (v.disabled === true)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "connectionId"));
      w.int53(h(v, "userId"));
      w.int(h(v, "dcId"));
      w.int(h(v, "date"));
    },
    "inputBusinessIntro": function(w, v) {
      w.uint(163867085);
      var flags = 0;
      var _sticker = v.sticker !== void 0;
      if (_sticker)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_sticker)
        w.object(v.sticker);
    },
    "businessIntro": function(w, v) {
      w.uint(1510606445);
      var flags = 0;
      var _sticker = v.sticker !== void 0;
      if (_sticker)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "description"));
      if (_sticker)
        w.object(v.sticker);
    },
    "messages.myStickers": function(w, v) {
      w.uint(4211040925);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "sets"));
    },
    "inputCollectibleUsername": function(w, v) {
      w.uint(3818152105);
      w.string(h(v, "username"));
    },
    "inputCollectiblePhone": function(w, v) {
      w.uint(2732725412);
      w.string(h(v, "phone"));
    },
    "fragment.collectibleInfo": function(w, v) {
      w.uint(1857945489);
      w.int(h(v, "purchaseDate"));
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
      w.string(h(v, "cryptoCurrency"));
      w.long(h(v, "cryptoAmount"));
      w.string(h(v, "url"));
    },
    "inputBusinessBotRecipients": function(w, v) {
      w.uint(3303379486);
      var flags = 0;
      if (v.existingChats === true)
        flags |= 1;
      if (v.newChats === true)
        flags |= 2;
      if (v.contacts === true)
        flags |= 4;
      if (v.nonContacts === true)
        flags |= 8;
      var _users = v.users && v.users.length;
      if (_users)
        flags |= 16;
      if (v.excludeSelected === true)
        flags |= 32;
      var _excludeUsers = v.excludeUsers && v.excludeUsers.length;
      if (_excludeUsers)
        flags |= 64;
      w.uint(flags);
      if (_users)
        w.vector(w.object, v.users);
      if (_excludeUsers)
        w.vector(w.object, v.excludeUsers);
    },
    "businessBotRecipients": function(w, v) {
      w.uint(3096245107);
      var flags = 0;
      if (v.existingChats === true)
        flags |= 1;
      if (v.newChats === true)
        flags |= 2;
      if (v.contacts === true)
        flags |= 4;
      if (v.nonContacts === true)
        flags |= 8;
      var _users = v.users && v.users.length;
      if (_users)
        flags |= 16;
      if (v.excludeSelected === true)
        flags |= 32;
      var _excludeUsers = v.excludeUsers && v.excludeUsers.length;
      if (_excludeUsers)
        flags |= 64;
      w.uint(flags);
      if (_users)
        w.vector(w.int53, v.users);
      if (_excludeUsers)
        w.vector(w.int53, v.excludeUsers);
    },
    "contactBirthday": function(w, v) {
      w.uint(496600883);
      w.int53(h(v, "contactId"));
      w.object(h(v, "birthday"));
    },
    "contacts.contactBirthdays": function(w, v) {
      w.uint(290452237);
      w.vector(w.object, h(v, "contacts"));
      w.vector(w.object, h(v, "users"));
    },
    "missingInvitee": function(w, v) {
      w.uint(1653379620);
      var flags = 0;
      if (v.premiumWouldAllowInvite === true)
        flags |= 1;
      if (v.premiumRequiredForPm === true)
        flags |= 2;
      w.uint(flags);
      w.int53(h(v, "userId"));
    },
    "messages.invitedUsers": function(w, v) {
      w.uint(2136862630);
      w.object(h(v, "updates"));
      w.vector(w.object, h(v, "missingInvitees"));
    },
    "inputBusinessChatLink": function(w, v) {
      w.uint(292003751);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 1;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_title)
        w.string(v.title);
    },
    "businessChatLink": function(w, v) {
      w.uint(3031328367);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 1;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "link"));
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_title)
        w.string(v.title);
      w.int(h(v, "views"));
    },
    "account.businessChatLinks": function(w, v) {
      w.uint(3963855569);
      w.vector(w.object, h(v, "links"));
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "account.resolvedBusinessChatLinks": function(w, v) {
      w.uint(2586029857);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "requestedPeerUser": function(w, v) {
      w.uint(3593466986);
      var flags = 0;
      var _firstName = v.firstName !== void 0;
      var _lastName = v.lastName !== void 0;
      var _flags_0 = _firstName || _lastName;
      if (_flags_0)
        flags |= 1;
      var _username = v.username !== void 0;
      if (_username)
        flags |= 2;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 4;
      w.uint(flags);
      w.int53(h(v, "userId"));
      if (_flags_0)
        w.string(v.firstName);
      if (_flags_0)
        w.string(v.lastName);
      if (_username)
        w.string(v.username);
      if (_photo)
        w.object(v.photo);
    },
    "requestedPeerChat": function(w, v) {
      w.uint(1929860175);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 4;
      w.uint(flags);
      w.int53(h(v, "chatId"));
      if (_title)
        w.string(v.title);
      if (_photo)
        w.object(v.photo);
    },
    "requestedPeerChannel": function(w, v) {
      w.uint(2342781924);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _username = v.username !== void 0;
      if (_username)
        flags |= 2;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 4;
      w.uint(flags);
      w.int53(h(v, "channelId"));
      if (_title)
        w.string(v.title);
      if (_username)
        w.string(v.username);
      if (_photo)
        w.object(v.photo);
    },
    "sponsoredMessageReportOption": function(w, v) {
      w.uint(1124938064);
      w.string(h(v, "text"));
      w.bytes(h(v, "option"));
    },
    "channels.sponsoredMessageReportResultChooseOption": function(w, v) {
      w.uint(2221907522);
      w.string(h(v, "title"));
      w.vector(w.object, h(v, "options"));
    },
    "channels.sponsoredMessageReportResultAdsHidden": function(w) {
      w.uint(1044107055);
    },
    "channels.sponsoredMessageReportResultReported": function(w) {
      w.uint(2910423113);
    },
    "stats.broadcastRevenueStats": function(w, v) {
      w.uint(1409802903);
      w.object(h(v, "topHoursGraph"));
      w.object(h(v, "revenueGraph"));
      w.object(h(v, "balances"));
      w.double(h(v, "usdRate"));
    },
    "stats.broadcastRevenueWithdrawalUrl": function(w, v) {
      w.uint(3966080823);
      w.string(h(v, "url"));
    },
    "broadcastRevenueTransactionProceeds": function(w, v) {
      w.uint(1434332356);
      w.long(h(v, "amount"));
      w.int(h(v, "fromDate"));
      w.int(h(v, "toDate"));
    },
    "broadcastRevenueTransactionWithdrawal": function(w, v) {
      w.uint(1515784568);
      var flags = 0;
      if (v.pending === true)
        flags |= 1;
      var _transactionDate = v.transactionDate !== void 0;
      var _transactionUrl = v.transactionUrl !== void 0;
      var _flags_1 = _transactionDate || _transactionUrl;
      if (_flags_1)
        flags |= 2;
      if (v.failed === true)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "amount"));
      w.int(h(v, "date"));
      w.string(h(v, "provider"));
      if (_flags_1)
        w.int(v.transactionDate);
      if (_flags_1)
        w.string(v.transactionUrl);
    },
    "broadcastRevenueTransactionRefund": function(w, v) {
      w.uint(1121127726);
      w.long(h(v, "amount"));
      w.int(h(v, "date"));
      w.string(h(v, "provider"));
    },
    "stats.broadcastRevenueTransactions": function(w, v) {
      w.uint(2266334310);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "transactions"));
    },
    "reactionNotificationsFromContacts": function(w) {
      w.uint(3133384218);
    },
    "reactionNotificationsFromAll": function(w) {
      w.uint(1268654752);
    },
    "reactionsNotifySettings": function(w, v) {
      w.uint(1457736048);
      var flags = 0;
      var _messagesNotifyFrom = v.messagesNotifyFrom !== void 0;
      if (_messagesNotifyFrom)
        flags |= 1;
      var _storiesNotifyFrom = v.storiesNotifyFrom !== void 0;
      if (_storiesNotifyFrom)
        flags |= 2;
      w.uint(flags);
      if (_messagesNotifyFrom)
        w.object(v.messagesNotifyFrom);
      if (_storiesNotifyFrom)
        w.object(v.storiesNotifyFrom);
      w.object(h(v, "sound"));
      w.boolean(h(v, "showPreviews"));
    },
    "broadcastRevenueBalances": function(w, v) {
      w.uint(3288297959);
      var flags = 0;
      if (v.withdrawalEnabled === true)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "currentBalance"));
      w.long(h(v, "availableBalance"));
      w.long(h(v, "overallRevenue"));
    },
    "availableEffect": function(w, v) {
      w.uint(2479088254);
      var flags = 0;
      var _staticIconId = v.staticIconId !== void 0;
      if (_staticIconId)
        flags |= 1;
      var _effectAnimationId = v.effectAnimationId !== void 0;
      if (_effectAnimationId)
        flags |= 2;
      if (v.premiumRequired === true)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "id"));
      w.string(h(v, "emoticon"));
      if (_staticIconId)
        w.long(v.staticIconId);
      w.long(h(v, "effectStickerId"));
      if (_effectAnimationId)
        w.long(v.effectAnimationId);
    },
    "messages.availableEffectsNotModified": function(w) {
      w.uint(3522009691);
    },
    "messages.availableEffects": function(w, v) {
      w.uint(3185271150);
      w.int(h(v, "hash"));
      w.vector(w.object, h(v, "effects"));
      w.vector(w.object, h(v, "documents"));
    },
    "factCheck": function(w, v) {
      w.uint(3097230543);
      var flags = 0;
      if (v.needCheck === true)
        flags |= 1;
      var _country = v.country !== void 0;
      var _text = v.text !== void 0;
      var _flags_1 = _country || _text;
      if (_flags_1)
        flags |= 2;
      w.uint(flags);
      if (_flags_1)
        w.string(v.country);
      if (_flags_1)
        w.object(v.text);
      w.long(h(v, "hash"));
    },
    "starsTransactionPeerUnsupported": function(w) {
      w.uint(2515714020);
    },
    "starsTransactionPeerAppStore": function(w) {
      w.uint(3025646453);
    },
    "starsTransactionPeerPlayMarket": function(w) {
      w.uint(2069236235);
    },
    "starsTransactionPeerPremiumBot": function(w) {
      w.uint(621656824);
    },
    "starsTransactionPeerFragment": function(w) {
      w.uint(3912227074);
    },
    "starsTransactionPeer": function(w, v) {
      w.uint(3624771933);
      w.object(h(v, "peer"));
    },
    "starsTransactionPeerAds": function(w) {
      w.uint(1617438738);
    },
    "starsTopupOption": function(w, v) {
      w.uint(198776256);
      var flags = 0;
      var _storeProduct = v.storeProduct !== void 0;
      if (_storeProduct)
        flags |= 1;
      if (v.extended === true)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "stars"));
      if (_storeProduct)
        w.string(v.storeProduct);
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "starsTransaction": function(w, v) {
      w.uint(178185410);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 2;
      var _photo = v.photo !== void 0;
      if (_photo)
        flags |= 4;
      if (v.refund === true)
        flags |= 8;
      if (v.pending === true)
        flags |= 16;
      var _transactionDate = v.transactionDate !== void 0;
      var _transactionUrl = v.transactionUrl !== void 0;
      var _flags_5 = _transactionDate || _transactionUrl;
      if (_flags_5)
        flags |= 32;
      if (v.failed === true)
        flags |= 64;
      var _botPayload = v.botPayload !== void 0;
      if (_botPayload)
        flags |= 128;
      var _msgId = v.msgId !== void 0;
      if (_msgId)
        flags |= 256;
      var _extendedMedia = v.extendedMedia && v.extendedMedia.length;
      if (_extendedMedia)
        flags |= 512;
      if (v.gift === true)
        flags |= 1024;
      if (v.reaction === true)
        flags |= 2048;
      var _subscriptionPeriod = v.subscriptionPeriod !== void 0;
      if (_subscriptionPeriod)
        flags |= 4096;
      var _giveawayPostId = v.giveawayPostId !== void 0;
      if (_giveawayPostId)
        flags |= 8192;
      var _stargift = v.stargift !== void 0;
      if (_stargift)
        flags |= 16384;
      w.uint(flags);
      w.string(h(v, "id"));
      w.long(h(v, "stars"));
      w.int(h(v, "date"));
      w.object(h(v, "peer"));
      if (_title)
        w.string(v.title);
      if (_description)
        w.string(v.description);
      if (_photo)
        w.object(v.photo);
      if (_flags_5)
        w.int(v.transactionDate);
      if (_flags_5)
        w.string(v.transactionUrl);
      if (_botPayload)
        w.bytes(v.botPayload);
      if (_msgId)
        w.int(v.msgId);
      if (_extendedMedia)
        w.vector(w.object, v.extendedMedia);
      if (_subscriptionPeriod)
        w.int(v.subscriptionPeriod);
      if (_giveawayPostId)
        w.int(v.giveawayPostId);
      if (_stargift)
        w.object(v.stargift);
    },
    "payments.starsStatus": function(w, v) {
      w.uint(3153736044);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      var _subscriptions = v.subscriptions && v.subscriptions.length;
      if (_subscriptions)
        flags |= 2;
      var _subscriptionsNextOffset = v.subscriptionsNextOffset !== void 0;
      if (_subscriptionsNextOffset)
        flags |= 4;
      var _history = v.history && v.history.length;
      if (_history)
        flags |= 8;
      var _subscriptionsMissingBalance = v.subscriptionsMissingBalance !== void 0;
      if (_subscriptionsMissingBalance)
        flags |= 16;
      w.uint(flags);
      w.long(h(v, "balance"));
      if (_subscriptions)
        w.vector(w.object, v.subscriptions);
      if (_subscriptionsNextOffset)
        w.string(v.subscriptionsNextOffset);
      if (_subscriptionsMissingBalance)
        w.long(v.subscriptionsMissingBalance);
      if (_history)
        w.vector(w.object, v.history);
      if (_nextOffset)
        w.string(v.nextOffset);
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "foundStory": function(w, v) {
      w.uint(3900361664);
      w.object(h(v, "peer"));
      w.object(h(v, "story"));
    },
    "stories.foundStories": function(w, v) {
      w.uint(3806230327);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "stories"));
      if (_nextOffset)
        w.string(v.nextOffset);
      w.vector(w.object, h(v, "chats"));
      w.vector(w.object, h(v, "users"));
    },
    "geoPointAddress": function(w, v) {
      w.uint(3729546643);
      var flags = 0;
      var _state = v.state !== void 0;
      if (_state)
        flags |= 1;
      var _city = v.city !== void 0;
      if (_city)
        flags |= 2;
      var _street = v.street !== void 0;
      if (_street)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "countryIso2"));
      if (_state)
        w.string(v.state);
      if (_city)
        w.string(v.city);
      if (_street)
        w.string(v.street);
    },
    "starsRevenueStatus": function(w, v) {
      w.uint(2033461574);
      var flags = 0;
      if (v.withdrawalEnabled === true)
        flags |= 1;
      var _nextWithdrawalAt = v.nextWithdrawalAt !== void 0;
      if (_nextWithdrawalAt)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "currentBalance"));
      w.long(h(v, "availableBalance"));
      w.long(h(v, "overallRevenue"));
      if (_nextWithdrawalAt)
        w.int(v.nextWithdrawalAt);
    },
    "payments.starsRevenueStats": function(w, v) {
      w.uint(3375085371);
      w.object(h(v, "revenueGraph"));
      w.object(h(v, "status"));
      w.double(h(v, "usdRate"));
    },
    "payments.starsRevenueWithdrawalUrl": function(w, v) {
      w.uint(497778871);
      w.string(h(v, "url"));
    },
    "payments.starsRevenueAdsAccountUrl": function(w, v) {
      w.uint(961445665);
      w.string(h(v, "url"));
    },
    "inputStarsTransaction": function(w, v) {
      w.uint(543876817);
      var flags = 0;
      if (v.refund === true)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "id"));
    },
    "starsGiftOption": function(w, v) {
      w.uint(1577421297);
      var flags = 0;
      var _storeProduct = v.storeProduct !== void 0;
      if (_storeProduct)
        flags |= 1;
      if (v.extended === true)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "stars"));
      if (_storeProduct)
        w.string(v.storeProduct);
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
    },
    "bots.popularAppBots": function(w, v) {
      w.uint(428978491);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      if (_nextOffset)
        w.string(v.nextOffset);
      w.vector(w.object, h(v, "users"));
    },
    "botPreviewMedia": function(w, v) {
      w.uint(602479523);
      w.int(h(v, "date"));
      w.object(h(v, "media"));
    },
    "bots.previewInfo": function(w, v) {
      w.uint(212278628);
      w.vector(w.object, h(v, "media"));
      w.vector(w.string, h(v, "langCodes"));
    },
    "starsSubscriptionPricing": function(w, v) {
      w.uint(88173912);
      w.int(h(v, "period"));
      w.long(h(v, "amount"));
    },
    "starsSubscription": function(w, v) {
      w.uint(1401868056);
      var flags = 0;
      if (v.canceled === true)
        flags |= 1;
      if (v.canRefulfill === true)
        flags |= 2;
      if (v.missingBalance === true)
        flags |= 4;
      var _chatInviteHash = v.chatInviteHash !== void 0;
      if (_chatInviteHash)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "id"));
      w.object(h(v, "peer"));
      w.int(h(v, "untilDate"));
      w.object(h(v, "pricing"));
      if (_chatInviteHash)
        w.string(v.chatInviteHash);
    },
    "messageReactor": function(w, v) {
      w.uint(1269016922);
      var flags = 0;
      if (v.top === true)
        flags |= 1;
      if (v.my === true)
        flags |= 2;
      if (v.anonymous === true)
        flags |= 4;
      var _peerId = v.peerId !== void 0;
      if (_peerId)
        flags |= 8;
      w.uint(flags);
      if (_peerId)
        w.object(v.peerId);
      w.int(h(v, "count"));
    },
    "starsGiveawayOption": function(w, v) {
      w.uint(2496562474);
      var flags = 0;
      if (v.extended === true)
        flags |= 1;
      if (v.default === true)
        flags |= 2;
      var _storeProduct = v.storeProduct !== void 0;
      if (_storeProduct)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "stars"));
      w.int(h(v, "yearlyBoosts"));
      if (_storeProduct)
        w.string(v.storeProduct);
      w.string(h(v, "currency"));
      w.long(h(v, "amount"));
      w.vector(w.object, h(v, "winners"));
    },
    "starsGiveawayWinnersOption": function(w, v) {
      w.uint(1411605001);
      var flags = 0;
      if (v.default === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "users"));
      w.long(h(v, "perUserStars"));
    },
    "starGift": function(w, v) {
      w.uint(2929816814);
      var flags = 0;
      var _availabilityRemains = v.availabilityRemains !== void 0;
      var _availabilityTotal = v.availabilityTotal !== void 0;
      var _flags_0 = v.limited === true || _availabilityRemains || _availabilityTotal;
      if (_flags_0)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "id"));
      w.object(h(v, "sticker"));
      w.long(h(v, "stars"));
      if (_flags_0)
        w.int(v.availabilityRemains);
      if (_flags_0)
        w.int(v.availabilityTotal);
      w.long(h(v, "convertStars"));
    },
    "payments.starGiftsNotModified": function(w) {
      w.uint(2743640936);
    },
    "payments.starGifts": function(w, v) {
      w.uint(2417396202);
      w.int(h(v, "hash"));
      w.vector(w.object, h(v, "gifts"));
    },
    "userStarGift": function(w, v) {
      w.uint(4003764846);
      var flags = 0;
      if (v.nameHidden === true)
        flags |= 1;
      var _fromId = v.fromId !== void 0;
      if (_fromId)
        flags |= 2;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 4;
      var _msgId = v.msgId !== void 0;
      if (_msgId)
        flags |= 8;
      var _convertStars = v.convertStars !== void 0;
      if (_convertStars)
        flags |= 16;
      if (v.unsaved === true)
        flags |= 32;
      w.uint(flags);
      if (_fromId)
        w.int53(v.fromId);
      w.int(h(v, "date"));
      w.object(h(v, "gift"));
      if (_message)
        w.object(v.message);
      if (_msgId)
        w.int(v.msgId);
      if (_convertStars)
        w.long(v.convertStars);
    },
    "payments.userStarGifts": function(w, v) {
      w.uint(1801827607);
      var flags = 0;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "count"));
      w.vector(w.object, h(v, "gifts"));
      if (_nextOffset)
        w.string(v.nextOffset);
      w.vector(w.object, h(v, "users"));
    },
    "messageReportOption": function(w, v) {
      w.uint(2030298073);
      w.string(h(v, "text"));
      w.bytes(h(v, "option"));
    },
    "reportResultChooseOption": function(w, v) {
      w.uint(4041531574);
      w.string(h(v, "title"));
      w.vector(w.object, h(v, "options"));
    },
    "reportResultAddComment": function(w, v) {
      w.uint(1862904881);
      var flags = 0;
      if (v.optional === true)
        flags |= 1;
      w.uint(flags);
      w.bytes(h(v, "option"));
    },
    "reportResultReported": function(w) {
      w.uint(2377333835);
    },
    "test.useConfigSimple": function(w) {
      w.uint(4189565501);
    },
    "test.parseInputAppEvent": function(w) {
      w.uint(3138226161);
    },
    "invokeWithBusinessConnectionPrefix": function(w, v) {
      w.uint(3710427022);
      w.string(h(v, "connectionId"));
    },
    "invokeWithGooglePlayIntegrityPrefix": function(w, v) {
      w.uint(502868356);
      w.string(h(v, "nonce"));
      w.string(h(v, "token"));
    },
    "invokeWithApnsSecretPrefix": function(w, v) {
      w.uint(229528824);
      w.string(h(v, "nonce"));
      w.string(h(v, "secret"));
    },
    "invokeAfterMsg": function(w, v) {
      w.uint(3416209197);
      w.long(h(v, "msgId"));
      w.object(h(v, "query"));
    },
    "invokeAfterMsgs": function(w, v) {
      w.uint(1036301552);
      w.vector(w.long, h(v, "msgIds"));
      w.object(h(v, "query"));
    },
    "initConnection": function(w, v) {
      w.uint(3251461801);
      var flags = 0;
      var _proxy = v.proxy !== void 0;
      if (_proxy)
        flags |= 1;
      var _params = v.params !== void 0;
      if (_params)
        flags |= 2;
      w.uint(flags);
      w.int(h(v, "apiId"));
      w.string(h(v, "deviceModel"));
      w.string(h(v, "systemVersion"));
      w.string(h(v, "appVersion"));
      w.string(h(v, "systemLangCode"));
      w.string(h(v, "langPack"));
      w.string(h(v, "langCode"));
      if (_proxy)
        w.object(v.proxy);
      if (_params)
        w.object(v.params);
      w.object(h(v, "query"));
    },
    "invokeWithLayer": function(w, v) {
      w.uint(3667594509);
      w.int(h(v, "layer"));
      w.object(h(v, "query"));
    },
    "invokeWithoutUpdates": function(w, v) {
      w.uint(3214170551);
      w.object(h(v, "query"));
    },
    "invokeWithMessagesRange": function(w, v) {
      w.uint(911373810);
      w.object(h(v, "range"));
      w.object(h(v, "query"));
    },
    "invokeWithTakeout": function(w, v) {
      w.uint(2896821550);
      w.long(h(v, "takeoutId"));
      w.object(h(v, "query"));
    },
    "invokeWithBusinessConnection": function(w, v) {
      w.uint(3710427022);
      w.string(h(v, "connectionId"));
      w.object(h(v, "query"));
    },
    "invokeWithGooglePlayIntegrity": function(w, v) {
      w.uint(502868356);
      w.string(h(v, "nonce"));
      w.string(h(v, "token"));
      w.object(h(v, "query"));
    },
    "invokeWithApnsSecret": function(w, v) {
      w.uint(229528824);
      w.string(h(v, "nonce"));
      w.string(h(v, "secret"));
      w.object(h(v, "query"));
    },
    "auth.sendCode": function(w, v) {
      w.uint(2792825935);
      w.string(h(v, "phoneNumber"));
      w.int(h(v, "apiId"));
      w.string(h(v, "apiHash"));
      w.object(h(v, "settings"));
    },
    "auth.signUp": function(w, v) {
      w.uint(2865215255);
      var flags = 0;
      if (v.noJoinedNotifications === true)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
    },
    "auth.signIn": function(w, v) {
      w.uint(2371004753);
      var flags = 0;
      var _phoneCode = v.phoneCode !== void 0;
      if (_phoneCode)
        flags |= 1;
      var _emailVerification = v.emailVerification !== void 0;
      if (_emailVerification)
        flags |= 2;
      w.uint(flags);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
      if (_phoneCode)
        w.string(v.phoneCode);
      if (_emailVerification)
        w.object(v.emailVerification);
    },
    "auth.logOut": function(w) {
      w.uint(1047706137);
    },
    "auth.resetAuthorizations": function(w) {
      w.uint(2678787354);
    },
    "auth.exportAuthorization": function(w, v) {
      w.uint(3854565325);
      w.int(h(v, "dcId"));
    },
    "auth.importAuthorization": function(w, v) {
      w.uint(2776268205);
      w.long(h(v, "id"));
      w.bytes(h(v, "bytes"));
    },
    "auth.bindTempAuthKey": function(w, v) {
      w.uint(3453233669);
      w.long(h(v, "permAuthKeyId"));
      w.long(h(v, "nonce"));
      w.int(h(v, "expiresAt"));
      w.bytes(h(v, "encryptedMessage"));
    },
    "auth.importBotAuthorization": function(w, v) {
      w.uint(1738800940);
      w.int(h(v, "flags"));
      w.int(h(v, "apiId"));
      w.string(h(v, "apiHash"));
      w.string(h(v, "botAuthToken"));
    },
    "auth.checkPassword": function(w, v) {
      w.uint(3515567382);
      w.object(h(v, "password"));
    },
    "auth.requestPasswordRecovery": function(w) {
      w.uint(3633822822);
    },
    "auth.recoverPassword": function(w, v) {
      w.uint(923364464);
      var flags = 0;
      var _newSettings = v.newSettings !== void 0;
      if (_newSettings)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "code"));
      if (_newSettings)
        w.object(v.newSettings);
    },
    "auth.resendCode": function(w, v) {
      w.uint(3403969827);
      var flags = 0;
      var _reason = v.reason !== void 0;
      if (_reason)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
      if (_reason)
        w.string(v.reason);
    },
    "auth.cancelCode": function(w, v) {
      w.uint(520357240);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
    },
    "auth.dropTempAuthKeys": function(w, v) {
      w.uint(2387124616);
      w.vector(w.long, h(v, "exceptAuthKeys"));
    },
    "auth.exportLoginToken": function(w, v) {
      w.uint(3084944894);
      w.int(h(v, "apiId"));
      w.string(h(v, "apiHash"));
      w.vector(w.long, h(v, "exceptIds"));
    },
    "auth.importLoginToken": function(w, v) {
      w.uint(2511101156);
      w.bytes(h(v, "token"));
    },
    "auth.acceptLoginToken": function(w, v) {
      w.uint(3902057805);
      w.bytes(h(v, "token"));
    },
    "auth.checkRecoveryPassword": function(w, v) {
      w.uint(221691769);
      w.string(h(v, "code"));
    },
    "auth.importWebTokenAuthorization": function(w, v) {
      w.uint(767062953);
      w.int(h(v, "apiId"));
      w.string(h(v, "apiHash"));
      w.string(h(v, "webAuthToken"));
    },
    "auth.requestFirebaseSms": function(w, v) {
      w.uint(2386109982);
      var flags = 0;
      var _safetyNetToken = v.safetyNetToken !== void 0;
      if (_safetyNetToken)
        flags |= 1;
      var _iosPushSecret = v.iosPushSecret !== void 0;
      if (_iosPushSecret)
        flags |= 2;
      var _playIntegrityToken = v.playIntegrityToken !== void 0;
      if (_playIntegrityToken)
        flags |= 4;
      w.uint(flags);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
      if (_safetyNetToken)
        w.string(v.safetyNetToken);
      if (_playIntegrityToken)
        w.string(v.playIntegrityToken);
      if (_iosPushSecret)
        w.string(v.iosPushSecret);
    },
    "auth.resetLoginEmail": function(w, v) {
      w.uint(2123760019);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
    },
    "auth.reportMissingCode": function(w, v) {
      w.uint(3416125430);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
      w.string(h(v, "mnc"));
    },
    "account.registerDevice": function(w, v) {
      w.uint(3968205178);
      var flags = 0;
      if (v.noMuted === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "tokenType"));
      w.string(h(v, "token"));
      w.boolean(h(v, "appSandbox"));
      w.bytes(h(v, "secret"));
      w.vector(w.int53, h(v, "otherUids"));
    },
    "account.unregisterDevice": function(w, v) {
      w.uint(1779249670);
      w.int(h(v, "tokenType"));
      w.string(h(v, "token"));
      w.vector(w.int53, h(v, "otherUids"));
    },
    "account.updateNotifySettings": function(w, v) {
      w.uint(2227067795);
      w.object(h(v, "peer"));
      w.object(h(v, "settings"));
    },
    "account.getNotifySettings": function(w, v) {
      w.uint(313765169);
      w.object(h(v, "peer"));
    },
    "account.resetNotifySettings": function(w) {
      w.uint(3682473799);
    },
    "account.updateProfile": function(w, v) {
      w.uint(2018596725);
      var flags = 0;
      var _firstName = v.firstName !== void 0;
      if (_firstName)
        flags |= 1;
      var _lastName = v.lastName !== void 0;
      if (_lastName)
        flags |= 2;
      var _about = v.about !== void 0;
      if (_about)
        flags |= 4;
      w.uint(flags);
      if (_firstName)
        w.string(v.firstName);
      if (_lastName)
        w.string(v.lastName);
      if (_about)
        w.string(v.about);
    },
    "account.updateStatus": function(w, v) {
      w.uint(1713919532);
      w.boolean(h(v, "offline"));
    },
    "account.getWallPapers": function(w, v) {
      w.uint(127302966);
      w.long(h(v, "hash"));
    },
    "account.reportPeer": function(w, v) {
      w.uint(3317316998);
      w.object(h(v, "peer"));
      w.object(h(v, "reason"));
      w.string(h(v, "message"));
    },
    "account.checkUsername": function(w, v) {
      w.uint(655677548);
      w.string(h(v, "username"));
    },
    "account.updateUsername": function(w, v) {
      w.uint(1040964988);
      w.string(h(v, "username"));
    },
    "account.getPrivacy": function(w, v) {
      w.uint(3671837008);
      w.object(h(v, "key"));
    },
    "account.setPrivacy": function(w, v) {
      w.uint(3388480744);
      w.object(h(v, "key"));
      w.vector(w.object, h(v, "rules"));
    },
    "account.deleteAccount": function(w, v) {
      w.uint(2730545012);
      var flags = 0;
      var _password = v.password !== void 0;
      if (_password)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "reason"));
      if (_password)
        w.object(v.password);
    },
    "account.getAccountTTL": function(w) {
      w.uint(150761757);
    },
    "account.setAccountTTL": function(w, v) {
      w.uint(608323678);
      w.object(h(v, "ttl"));
    },
    "account.sendChangePhoneCode": function(w, v) {
      w.uint(2186758885);
      w.string(h(v, "phoneNumber"));
      w.object(h(v, "settings"));
    },
    "account.changePhone": function(w, v) {
      w.uint(1891839707);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
      w.string(h(v, "phoneCode"));
    },
    "account.updateDeviceLocked": function(w, v) {
      w.uint(954152242);
      w.int(h(v, "period"));
    },
    "account.getAuthorizations": function(w) {
      w.uint(3810574680);
    },
    "account.resetAuthorization": function(w, v) {
      w.uint(3749180348);
      w.long(h(v, "hash"));
    },
    "account.getPassword": function(w) {
      w.uint(1418342645);
    },
    "account.getPasswordSettings": function(w, v) {
      w.uint(2631199481);
      w.object(h(v, "password"));
    },
    "account.updatePasswordSettings": function(w, v) {
      w.uint(2778402863);
      w.object(h(v, "password"));
      w.object(h(v, "newSettings"));
    },
    "account.sendConfirmPhoneCode": function(w, v) {
      w.uint(457157256);
      w.string(h(v, "hash"));
      w.object(h(v, "settings"));
    },
    "account.confirmPhone": function(w, v) {
      w.uint(1596029123);
      w.string(h(v, "phoneCodeHash"));
      w.string(h(v, "phoneCode"));
    },
    "account.getTmpPassword": function(w, v) {
      w.uint(1151208273);
      w.object(h(v, "password"));
      w.int(h(v, "period"));
    },
    "account.getWebAuthorizations": function(w) {
      w.uint(405695855);
    },
    "account.resetWebAuthorization": function(w, v) {
      w.uint(755087855);
      w.long(h(v, "hash"));
    },
    "account.resetWebAuthorizations": function(w) {
      w.uint(1747789204);
    },
    "account.getAllSecureValues": function(w) {
      w.uint(2995305597);
    },
    "account.getSecureValue": function(w, v) {
      w.uint(1936088002);
      w.vector(w.object, h(v, "types"));
    },
    "account.saveSecureValue": function(w, v) {
      w.uint(2308956957);
      w.object(h(v, "value"));
      w.long(h(v, "secureSecretId"));
    },
    "account.deleteSecureValue": function(w, v) {
      w.uint(3095444555);
      w.vector(w.object, h(v, "types"));
    },
    "account.getAuthorizationForm": function(w, v) {
      w.uint(2838059386);
      w.int53(h(v, "botId"));
      w.string(h(v, "scope"));
      w.string(h(v, "publicKey"));
    },
    "account.acceptAuthorization": function(w, v) {
      w.uint(4092415091);
      w.int53(h(v, "botId"));
      w.string(h(v, "scope"));
      w.string(h(v, "publicKey"));
      w.vector(w.object, h(v, "valueHashes"));
      w.object(h(v, "credentials"));
    },
    "account.sendVerifyPhoneCode": function(w, v) {
      w.uint(2778945273);
      w.string(h(v, "phoneNumber"));
      w.object(h(v, "settings"));
    },
    "account.verifyPhone": function(w, v) {
      w.uint(1305716726);
      w.string(h(v, "phoneNumber"));
      w.string(h(v, "phoneCodeHash"));
      w.string(h(v, "phoneCode"));
    },
    "account.sendVerifyEmailCode": function(w, v) {
      w.uint(2564831163);
      w.object(h(v, "purpose"));
      w.string(h(v, "email"));
    },
    "account.verifyEmail": function(w, v) {
      w.uint(53322959);
      w.object(h(v, "purpose"));
      w.object(h(v, "verification"));
    },
    "account.initTakeoutSession": function(w, v) {
      w.uint(239835e4);
      var flags = 0;
      if (v.contacts === true)
        flags |= 1;
      if (v.messageUsers === true)
        flags |= 2;
      if (v.messageChats === true)
        flags |= 4;
      if (v.messageMegagroups === true)
        flags |= 8;
      if (v.messageChannels === true)
        flags |= 16;
      var _fileMaxSize = v.fileMaxSize !== void 0;
      var _flags_5 = v.files === true || _fileMaxSize;
      if (_flags_5)
        flags |= 32;
      w.uint(flags);
      if (_flags_5)
        w.int53(v.fileMaxSize);
    },
    "account.finishTakeoutSession": function(w, v) {
      w.uint(489050862);
      var flags = 0;
      if (v.success === true)
        flags |= 1;
      w.uint(flags);
    },
    "account.confirmPasswordEmail": function(w, v) {
      w.uint(2413762848);
      w.string(h(v, "code"));
    },
    "account.resendPasswordEmail": function(w) {
      w.uint(2055154197);
    },
    "account.cancelPasswordEmail": function(w) {
      w.uint(3251361206);
    },
    "account.getContactSignUpNotification": function(w) {
      w.uint(2668087080);
    },
    "account.setContactSignUpNotification": function(w, v) {
      w.uint(3488890721);
      w.boolean(h(v, "silent"));
    },
    "account.getNotifyExceptions": function(w, v) {
      w.uint(1398240377);
      var flags = 0;
      var _peer = v.peer !== void 0;
      if (_peer)
        flags |= 1;
      if (v.compareSound === true)
        flags |= 2;
      if (v.compareStories === true)
        flags |= 4;
      w.uint(flags);
      if (_peer)
        w.object(v.peer);
    },
    "account.getWallPaper": function(w, v) {
      w.uint(4237155306);
      w.object(h(v, "wallpaper"));
    },
    "account.uploadWallPaper": function(w, v) {
      w.uint(3818557187);
      var flags = 0;
      if (v.forChat === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "file"));
      w.string(h(v, "mimeType"));
      w.object(h(v, "settings"));
    },
    "account.saveWallPaper": function(w, v) {
      w.uint(1817860919);
      w.object(h(v, "wallpaper"));
      w.boolean(h(v, "unsave"));
      w.object(h(v, "settings"));
    },
    "account.installWallPaper": function(w, v) {
      w.uint(4276967273);
      w.object(h(v, "wallpaper"));
      w.object(h(v, "settings"));
    },
    "account.resetWallPapers": function(w) {
      w.uint(3141244932);
    },
    "account.getAutoDownloadSettings": function(w) {
      w.uint(1457130303);
    },
    "account.saveAutoDownloadSettings": function(w, v) {
      w.uint(1995661875);
      var flags = 0;
      if (v.low === true)
        flags |= 1;
      if (v.high === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "settings"));
    },
    "account.uploadTheme": function(w, v) {
      w.uint(473805619);
      var flags = 0;
      var _thumb = v.thumb !== void 0;
      if (_thumb)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "file"));
      if (_thumb)
        w.object(v.thumb);
      w.string(h(v, "fileName"));
      w.string(h(v, "mimeType"));
    },
    "account.createTheme": function(w, v) {
      w.uint(1697530880);
      var flags = 0;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 4;
      var _settings = v.settings && v.settings.length;
      if (_settings)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "slug"));
      w.string(h(v, "title"));
      if (_document)
        w.object(v.document);
      if (_settings)
        w.vector(w.object, v.settings);
    },
    "account.updateTheme": function(w, v) {
      w.uint(737414348);
      var flags = 0;
      var _slug = v.slug !== void 0;
      if (_slug)
        flags |= 1;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      var _document = v.document !== void 0;
      if (_document)
        flags |= 4;
      var _settings = v.settings && v.settings.length;
      if (_settings)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "format"));
      w.object(h(v, "theme"));
      if (_slug)
        w.string(v.slug);
      if (_title)
        w.string(v.title);
      if (_document)
        w.object(v.document);
      if (_settings)
        w.vector(w.object, v.settings);
    },
    "account.saveTheme": function(w, v) {
      w.uint(4065792108);
      w.object(h(v, "theme"));
      w.boolean(h(v, "unsave"));
    },
    "account.installTheme": function(w, v) {
      w.uint(3341269819);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      var _theme = v.theme !== void 0;
      if (_theme)
        flags |= 2;
      var _format = v.format !== void 0;
      if (_format)
        flags |= 4;
      var _baseTheme = v.baseTheme !== void 0;
      if (_baseTheme)
        flags |= 8;
      w.uint(flags);
      if (_theme)
        w.object(v.theme);
      if (_format)
        w.string(v.format);
      if (_baseTheme)
        w.object(v.baseTheme);
    },
    "account.getTheme": function(w, v) {
      w.uint(978872812);
      w.string(h(v, "format"));
      w.object(h(v, "theme"));
    },
    "account.getThemes": function(w, v) {
      w.uint(1913054296);
      w.string(h(v, "format"));
      w.long(h(v, "hash"));
    },
    "account.setContentSettings": function(w, v) {
      w.uint(3044323691);
      var flags = 0;
      if (v.sensitiveEnabled === true)
        flags |= 1;
      w.uint(flags);
    },
    "account.getContentSettings": function(w) {
      w.uint(2342210990);
    },
    "account.getMultiWallPapers": function(w, v) {
      w.uint(1705865692);
      w.vector(w.object, h(v, "wallpapers"));
    },
    "account.getGlobalPrivacySettings": function(w) {
      w.uint(3945483510);
    },
    "account.setGlobalPrivacySettings": function(w, v) {
      w.uint(517647042);
      w.object(h(v, "settings"));
    },
    "account.reportProfilePhoto": function(w, v) {
      w.uint(4203529973);
      w.object(h(v, "peer"));
      w.object(h(v, "photoId"));
      w.object(h(v, "reason"));
      w.string(h(v, "message"));
    },
    "account.resetPassword": function(w) {
      w.uint(2466827803);
    },
    "account.declinePasswordReset": function(w) {
      w.uint(1284770294);
    },
    "account.getChatThemes": function(w, v) {
      w.uint(3594051209);
      w.long(h(v, "hash"));
    },
    "account.setAuthorizationTTL": function(w, v) {
      w.uint(3213466272);
      w.int(h(v, "authorizationTtlDays"));
    },
    "account.changeAuthorizationSettings": function(w, v) {
      w.uint(1089766498);
      var flags = 0;
      var _encryptedRequestsDisabled = v.encryptedRequestsDisabled !== void 0;
      if (_encryptedRequestsDisabled)
        flags |= 1;
      var _callRequestsDisabled = v.callRequestsDisabled !== void 0;
      if (_callRequestsDisabled)
        flags |= 2;
      if (v.confirmed === true)
        flags |= 8;
      w.uint(flags);
      w.long(h(v, "hash"));
      if (_encryptedRequestsDisabled)
        w.boolean(v.encryptedRequestsDisabled);
      if (_callRequestsDisabled)
        w.boolean(v.callRequestsDisabled);
    },
    "account.getSavedRingtones": function(w, v) {
      w.uint(3784319624);
      w.long(h(v, "hash"));
    },
    "account.saveRingtone": function(w, v) {
      w.uint(1038768899);
      w.object(h(v, "id"));
      w.boolean(h(v, "unsave"));
    },
    "account.uploadRingtone": function(w, v) {
      w.uint(2199552930);
      w.object(h(v, "file"));
      w.string(h(v, "fileName"));
      w.string(h(v, "mimeType"));
    },
    "account.updateEmojiStatus": function(w, v) {
      w.uint(4224966251);
      w.object(h(v, "emojiStatus"));
    },
    "account.getDefaultEmojiStatuses": function(w, v) {
      w.uint(3598005126);
      w.long(h(v, "hash"));
    },
    "account.getRecentEmojiStatuses": function(w, v) {
      w.uint(257392901);
      w.long(h(v, "hash"));
    },
    "account.clearRecentEmojiStatuses": function(w) {
      w.uint(404757166);
    },
    "account.reorderUsernames": function(w, v) {
      w.uint(4015001259);
      w.vector(w.string, h(v, "order"));
    },
    "account.toggleUsername": function(w, v) {
      w.uint(1490465654);
      w.string(h(v, "username"));
      w.boolean(h(v, "active"));
    },
    "account.getDefaultProfilePhotoEmojis": function(w, v) {
      w.uint(3799319336);
      w.long(h(v, "hash"));
    },
    "account.getDefaultGroupPhotoEmojis": function(w, v) {
      w.uint(2438488238);
      w.long(h(v, "hash"));
    },
    "account.getAutoSaveSettings": function(w) {
      w.uint(2915810522);
    },
    "account.saveAutoSaveSettings": function(w, v) {
      w.uint(3600515937);
      var flags = 0;
      if (v.users === true)
        flags |= 1;
      if (v.chats === true)
        flags |= 2;
      if (v.broadcasts === true)
        flags |= 4;
      var _peer = v.peer !== void 0;
      if (_peer)
        flags |= 8;
      w.uint(flags);
      if (_peer)
        w.object(v.peer);
      w.object(h(v, "settings"));
    },
    "account.deleteAutoSaveExceptions": function(w) {
      w.uint(1404829728);
    },
    "account.invalidateSignInCodes": function(w, v) {
      w.uint(3398101178);
      w.vector(w.string, h(v, "codes"));
    },
    "account.updateColor": function(w, v) {
      w.uint(2096079197);
      var flags = 0;
      var _backgroundEmojiId = v.backgroundEmojiId !== void 0;
      if (_backgroundEmojiId)
        flags |= 1;
      if (v.forProfile === true)
        flags |= 2;
      var _color = v.color !== void 0;
      if (_color)
        flags |= 4;
      w.uint(flags);
      if (_color)
        w.int(v.color);
      if (_backgroundEmojiId)
        w.long(v.backgroundEmojiId);
    },
    "account.getDefaultBackgroundEmojis": function(w, v) {
      w.uint(2785720782);
      w.long(h(v, "hash"));
    },
    "account.getChannelDefaultEmojiStatuses": function(w, v) {
      w.uint(1999087573);
      w.long(h(v, "hash"));
    },
    "account.getChannelRestrictedStatusEmojis": function(w, v) {
      w.uint(900325589);
      w.long(h(v, "hash"));
    },
    "account.updateBusinessWorkHours": function(w, v) {
      w.uint(1258348646);
      var flags = 0;
      var _businessWorkHours = v.businessWorkHours !== void 0;
      if (_businessWorkHours)
        flags |= 1;
      w.uint(flags);
      if (_businessWorkHours)
        w.object(v.businessWorkHours);
    },
    "account.updateBusinessLocation": function(w, v) {
      w.uint(2657817370);
      var flags = 0;
      var _address = v.address !== void 0;
      if (_address)
        flags |= 1;
      var _geoPoint = v.geoPoint !== void 0;
      if (_geoPoint)
        flags |= 2;
      w.uint(flags);
      if (_geoPoint)
        w.object(v.geoPoint);
      if (_address)
        w.string(v.address);
    },
    "account.updateBusinessGreetingMessage": function(w, v) {
      w.uint(1724755908);
      var flags = 0;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 1;
      w.uint(flags);
      if (_message)
        w.object(v.message);
    },
    "account.updateBusinessAwayMessage": function(w, v) {
      w.uint(2724888485);
      var flags = 0;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 1;
      w.uint(flags);
      if (_message)
        w.object(v.message);
    },
    "account.updateConnectedBot": function(w, v) {
      w.uint(1138250269);
      var flags = 0;
      if (v.canReply === true)
        flags |= 1;
      if (v.deleted === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "bot"));
      w.object(h(v, "recipients"));
    },
    "account.getConnectedBots": function(w) {
      w.uint(1319421967);
    },
    "account.getBotBusinessConnection": function(w, v) {
      w.uint(1990746736);
      w.string(h(v, "connectionId"));
    },
    "account.updateBusinessIntro": function(w, v) {
      w.uint(2786381876);
      var flags = 0;
      var _intro = v.intro !== void 0;
      if (_intro)
        flags |= 1;
      w.uint(flags);
      if (_intro)
        w.object(v.intro);
    },
    "account.toggleConnectedBotPaused": function(w, v) {
      w.uint(1684934807);
      w.object(h(v, "peer"));
      w.boolean(h(v, "paused"));
    },
    "account.disablePeerConnectedBot": function(w, v) {
      w.uint(1581481689);
      w.object(h(v, "peer"));
    },
    "account.updateBirthday": function(w, v) {
      w.uint(3429764113);
      var flags = 0;
      var _birthday = v.birthday !== void 0;
      if (_birthday)
        flags |= 1;
      w.uint(flags);
      if (_birthday)
        w.object(v.birthday);
    },
    "account.createBusinessChatLink": function(w, v) {
      w.uint(2287068814);
      w.object(h(v, "link"));
    },
    "account.editBusinessChatLink": function(w, v) {
      w.uint(2352222383);
      w.string(h(v, "slug"));
      w.object(h(v, "link"));
    },
    "account.deleteBusinessChatLink": function(w, v) {
      w.uint(1611085428);
      w.string(h(v, "slug"));
    },
    "account.getBusinessChatLinks": function(w) {
      w.uint(1869667809);
    },
    "account.resolveBusinessChatLink": function(w, v) {
      w.uint(1418913262);
      w.string(h(v, "slug"));
    },
    "account.updatePersonalChannel": function(w, v) {
      w.uint(3645048288);
      w.object(h(v, "channel"));
    },
    "account.toggleSponsoredMessages": function(w, v) {
      w.uint(3118048141);
      w.boolean(h(v, "enabled"));
    },
    "account.getReactionsNotifySettings": function(w) {
      w.uint(115172684);
    },
    "account.setReactionsNotifySettings": function(w, v) {
      w.uint(829220168);
      w.object(h(v, "settings"));
    },
    "users.getUsers": function(w, v) {
      w.uint(227648840);
      w.vector(w.object, h(v, "id"));
    },
    "users.getFullUser": function(w, v) {
      w.uint(3054459160);
      w.object(h(v, "id"));
    },
    "users.setSecureValueErrors": function(w, v) {
      w.uint(2429064373);
      w.object(h(v, "id"));
      w.vector(w.object, h(v, "errors"));
    },
    "users.getIsPremiumRequiredToContact": function(w, v) {
      w.uint(2787289616);
      w.vector(w.object, h(v, "id"));
    },
    "contacts.getContactIDs": function(w, v) {
      w.uint(2061264541);
      w.long(h(v, "hash"));
    },
    "contacts.getStatuses": function(w) {
      w.uint(3299038190);
    },
    "contacts.getContacts": function(w, v) {
      w.uint(1574346258);
      w.long(h(v, "hash"));
    },
    "contacts.importContacts": function(w, v) {
      w.uint(746589157);
      w.vector(w.object, h(v, "contacts"));
    },
    "contacts.deleteContacts": function(w, v) {
      w.uint(157945344);
      w.vector(w.object, h(v, "id"));
    },
    "contacts.deleteByPhones": function(w, v) {
      w.uint(269745566);
      w.vector(w.string, h(v, "phones"));
    },
    "contacts.block": function(w, v) {
      w.uint(774801204);
      var flags = 0;
      if (v.myStoriesFrom === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "id"));
    },
    "contacts.unblock": function(w, v) {
      w.uint(3041973032);
      var flags = 0;
      if (v.myStoriesFrom === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "id"));
    },
    "contacts.getBlocked": function(w, v) {
      w.uint(2592509824);
      var flags = 0;
      if (v.myStoriesFrom === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "contacts.search": function(w, v) {
      w.uint(301470424);
      w.string(h(v, "q"));
      w.int(h(v, "limit"));
    },
    "contacts.resolveUsername": function(w, v) {
      w.uint(4181511075);
      w.string(h(v, "username"));
    },
    "contacts.getTopPeers": function(w, v) {
      w.uint(2536798390);
      var flags = 0;
      if (v.correspondents === true)
        flags |= 1;
      if (v.botsPm === true)
        flags |= 2;
      if (v.botsInline === true)
        flags |= 4;
      if (v.phoneCalls === true)
        flags |= 8;
      if (v.forwardUsers === true)
        flags |= 16;
      if (v.forwardChats === true)
        flags |= 32;
      if (v.groups === true)
        flags |= 1024;
      if (v.channels === true)
        flags |= 32768;
      if (v.botsApp === true)
        flags |= 65536;
      w.uint(flags);
      w.int(h(v, "offset"));
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "contacts.resetTopPeerRating": function(w, v) {
      w.uint(451113900);
      w.object(h(v, "category"));
      w.object(h(v, "peer"));
    },
    "contacts.resetSaved": function(w) {
      w.uint(2274703345);
    },
    "contacts.getSaved": function(w) {
      w.uint(2196890527);
    },
    "contacts.toggleTopPeers": function(w, v) {
      w.uint(2232729050);
      w.boolean(h(v, "enabled"));
    },
    "contacts.addContact": function(w, v) {
      w.uint(3908330448);
      var flags = 0;
      if (v.addPhonePrivacyException === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "id"));
      w.string(h(v, "firstName"));
      w.string(h(v, "lastName"));
      w.string(h(v, "phone"));
    },
    "contacts.acceptContact": function(w, v) {
      w.uint(4164002319);
      w.object(h(v, "id"));
    },
    "contacts.getLocated": function(w, v) {
      w.uint(3544759364);
      var flags = 0;
      var _selfExpires = v.selfExpires !== void 0;
      if (_selfExpires)
        flags |= 1;
      if (v.background === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "geoPoint"));
      if (_selfExpires)
        w.int(v.selfExpires);
    },
    "contacts.blockFromReplies": function(w, v) {
      w.uint(698914348);
      var flags = 0;
      if (v.deleteMessage === true)
        flags |= 1;
      if (v.deleteHistory === true)
        flags |= 2;
      if (v.reportSpam === true)
        flags |= 4;
      w.uint(flags);
      w.int(h(v, "msgId"));
    },
    "contacts.resolvePhone": function(w, v) {
      w.uint(2331591492);
      w.string(h(v, "phone"));
    },
    "contacts.exportContactToken": function(w) {
      w.uint(4167385127);
    },
    "contacts.importContactToken": function(w, v) {
      w.uint(318789512);
      w.string(h(v, "token"));
    },
    "contacts.editCloseFriends": function(w, v) {
      w.uint(3127313904);
      w.vector(w.int53, h(v, "id"));
    },
    "contacts.setBlocked": function(w, v) {
      w.uint(2496027766);
      var flags = 0;
      if (v.myStoriesFrom === true)
        flags |= 1;
      w.uint(flags);
      w.vector(w.object, h(v, "id"));
      w.int(h(v, "limit"));
    },
    "contacts.getBirthdays": function(w) {
      w.uint(3673008228);
    },
    "messages.getMessages": function(w, v) {
      w.uint(1673946374);
      w.vector(w.object, h(v, "id"));
    },
    "messages.getDialogs": function(w, v) {
      w.uint(2700397391);
      var flags = 0;
      if (v.excludePinned === true)
        flags |= 1;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 2;
      w.uint(flags);
      if (_folderId)
        w.int(v.folderId);
      w.int(h(v, "offsetDate"));
      w.int(h(v, "offsetId"));
      w.object(h(v, "offsetPeer"));
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "messages.getHistory": function(w, v) {
      w.uint(1143203525);
      w.object(h(v, "peer"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "offsetDate"));
      w.int(h(v, "addOffset"));
      w.int(h(v, "limit"));
      w.int(h(v, "maxId"));
      w.int(h(v, "minId"));
      w.long(h(v, "hash"));
    },
    "messages.search": function(w, v) {
      w.uint(703497338);
      var flags = 0;
      var _fromId = v.fromId !== void 0;
      if (_fromId)
        flags |= 1;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 2;
      var _savedPeerId = v.savedPeerId !== void 0;
      if (_savedPeerId)
        flags |= 4;
      var _savedReaction = v.savedReaction && v.savedReaction.length;
      if (_savedReaction)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.string(h(v, "q"));
      if (_fromId)
        w.object(v.fromId);
      if (_savedPeerId)
        w.object(v.savedPeerId);
      if (_savedReaction)
        w.vector(w.object, v.savedReaction);
      if (_topMsgId)
        w.int(v.topMsgId);
      w.object(h(v, "filter"));
      w.int(h(v, "minDate"));
      w.int(h(v, "maxDate"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "addOffset"));
      w.int(h(v, "limit"));
      w.int(h(v, "maxId"));
      w.int(h(v, "minId"));
      w.long(h(v, "hash"));
    },
    "messages.readHistory": function(w, v) {
      w.uint(238054714);
      w.object(h(v, "peer"));
      w.int(h(v, "maxId"));
    },
    "messages.deleteHistory": function(w, v) {
      w.uint(2962199082);
      var flags = 0;
      if (v.justClear === true)
        flags |= 1;
      if (v.revoke === true)
        flags |= 2;
      var _minDate = v.minDate !== void 0;
      if (_minDate)
        flags |= 4;
      var _maxDate = v.maxDate !== void 0;
      if (_maxDate)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "maxId"));
      if (_minDate)
        w.int(v.minDate);
      if (_maxDate)
        w.int(v.maxDate);
    },
    "messages.deleteMessages": function(w, v) {
      w.uint(3851326930);
      var flags = 0;
      if (v.revoke === true)
        flags |= 1;
      w.uint(flags);
      w.vector(w.int, h(v, "id"));
    },
    "messages.receivedMessages": function(w, v) {
      w.uint(94983360);
      w.int(h(v, "maxId"));
    },
    "messages.setTyping": function(w, v) {
      w.uint(1486110434);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_topMsgId)
        w.int(v.topMsgId);
      w.object(h(v, "action"));
    },
    "messages.sendMessage": function(w, v) {
      w.uint(2554304325);
      var flags = 0;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 1;
      if (v.noWebpage === true)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 8;
      if (v.silent === true)
        flags |= 32;
      if (v.background === true)
        flags |= 64;
      if (v.clearDraft === true)
        flags |= 128;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 1024;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 8192;
      if (v.noforwards === true)
        flags |= 16384;
      if (v.updateStickersetsOrder === true)
        flags |= 32768;
      if (v.invertMedia === true)
        flags |= 65536;
      var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
      if (_quickReplyShortcut)
        flags |= 131072;
      var _effect = v.effect !== void 0;
      if (_effect)
        flags |= 262144;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_replyTo)
        w.object(v.replyTo);
      w.string(h(v, "message"));
      w.long(h(v, "randomId"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
      if (_entities)
        w.vector(w.object, v.entities);
      if (_scheduleDate)
        w.int(v.scheduleDate);
      if (_sendAs)
        w.object(v.sendAs);
      if (_quickReplyShortcut)
        w.object(v.quickReplyShortcut);
      if (_effect)
        w.long(v.effect);
    },
    "messages.sendMedia": function(w, v) {
      w.uint(2018673486);
      var flags = 0;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 1;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 8;
      if (v.silent === true)
        flags |= 32;
      if (v.background === true)
        flags |= 64;
      if (v.clearDraft === true)
        flags |= 128;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 1024;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 8192;
      if (v.noforwards === true)
        flags |= 16384;
      if (v.updateStickersetsOrder === true)
        flags |= 32768;
      if (v.invertMedia === true)
        flags |= 65536;
      var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
      if (_quickReplyShortcut)
        flags |= 131072;
      var _effect = v.effect !== void 0;
      if (_effect)
        flags |= 262144;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_replyTo)
        w.object(v.replyTo);
      w.object(h(v, "media"));
      w.string(h(v, "message"));
      w.long(h(v, "randomId"));
      if (_replyMarkup)
        w.object(v.replyMarkup);
      if (_entities)
        w.vector(w.object, v.entities);
      if (_scheduleDate)
        w.int(v.scheduleDate);
      if (_sendAs)
        w.object(v.sendAs);
      if (_quickReplyShortcut)
        w.object(v.quickReplyShortcut);
      if (_effect)
        w.long(v.effect);
    },
    "messages.forwardMessages": function(w, v) {
      w.uint(3573781e3);
      var flags = 0;
      if (v.silent === true)
        flags |= 32;
      if (v.background === true)
        flags |= 64;
      if (v.withMyScore === true)
        flags |= 256;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 512;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 1024;
      if (v.dropAuthor === true)
        flags |= 2048;
      if (v.dropMediaCaptions === true)
        flags |= 4096;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 8192;
      if (v.noforwards === true)
        flags |= 16384;
      var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
      if (_quickReplyShortcut)
        flags |= 131072;
      w.uint(flags);
      w.object(h(v, "fromPeer"));
      w.vector(w.int, h(v, "id"));
      w.vector(w.long, h(v, "randomId"));
      w.object(h(v, "toPeer"));
      if (_topMsgId)
        w.int(v.topMsgId);
      if (_scheduleDate)
        w.int(v.scheduleDate);
      if (_sendAs)
        w.object(v.sendAs);
      if (_quickReplyShortcut)
        w.object(v.quickReplyShortcut);
    },
    "messages.reportSpam": function(w, v) {
      w.uint(3474297563);
      w.object(h(v, "peer"));
    },
    "messages.getPeerSettings": function(w, v) {
      w.uint(4024018594);
      w.object(h(v, "peer"));
    },
    "messages.report": function(w, v) {
      w.uint(4235767707);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
      w.bytes(h(v, "option"));
      w.string(h(v, "message"));
    },
    "messages.getChats": function(w, v) {
      w.uint(1240027791);
      w.vector(w.int53, h(v, "id"));
    },
    "messages.getFullChat": function(w, v) {
      w.uint(2930772788);
      w.int53(h(v, "chatId"));
    },
    "messages.editChatTitle": function(w, v) {
      w.uint(1937260541);
      w.int53(h(v, "chatId"));
      w.string(h(v, "title"));
    },
    "messages.editChatPhoto": function(w, v) {
      w.uint(903730804);
      w.int53(h(v, "chatId"));
      w.object(h(v, "photo"));
    },
    "messages.addChatUser": function(w, v) {
      w.uint(3418804487);
      w.int53(h(v, "chatId"));
      w.object(h(v, "userId"));
      w.int(h(v, "fwdLimit"));
    },
    "messages.deleteChatUser": function(w, v) {
      w.uint(2719505579);
      var flags = 0;
      if (v.revokeHistory === true)
        flags |= 1;
      w.uint(flags);
      w.int53(h(v, "chatId"));
      w.object(h(v, "userId"));
    },
    "messages.createChat": function(w, v) {
      w.uint(2463030740);
      var flags = 0;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 1;
      w.uint(flags);
      w.vector(w.object, h(v, "users"));
      w.string(h(v, "title"));
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "messages.getDhConfig": function(w, v) {
      w.uint(651135312);
      w.int(h(v, "version"));
      w.int(h(v, "randomLength"));
    },
    "messages.requestEncryption": function(w, v) {
      w.uint(4132286275);
      w.object(h(v, "userId"));
      w.int(h(v, "randomId"));
      w.bytes(h(v, "gA"));
    },
    "messages.acceptEncryption": function(w, v) {
      w.uint(1035731989);
      w.object(h(v, "peer"));
      w.bytes(h(v, "gB"));
      w.long(h(v, "keyFingerprint"));
    },
    "messages.discardEncryption": function(w, v) {
      w.uint(4086541984);
      var flags = 0;
      if (v.deleteHistory === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "chatId"));
    },
    "messages.setEncryptedTyping": function(w, v) {
      w.uint(2031374829);
      w.object(h(v, "peer"));
      w.boolean(h(v, "typing"));
    },
    "messages.readEncryptedHistory": function(w, v) {
      w.uint(2135648522);
      w.object(h(v, "peer"));
      w.int(h(v, "maxDate"));
    },
    "messages.sendEncrypted": function(w, v) {
      w.uint(1157265941);
      var flags = 0;
      if (v.silent === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.long(h(v, "randomId"));
      w.bytes(h(v, "data"));
    },
    "messages.sendEncryptedFile": function(w, v) {
      w.uint(1431914525);
      var flags = 0;
      if (v.silent === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.long(h(v, "randomId"));
      w.bytes(h(v, "data"));
      w.object(h(v, "file"));
    },
    "messages.sendEncryptedService": function(w, v) {
      w.uint(852769188);
      w.object(h(v, "peer"));
      w.long(h(v, "randomId"));
      w.bytes(h(v, "data"));
    },
    "messages.receivedQueue": function(w, v) {
      w.uint(1436924774);
      w.int(h(v, "maxQts"));
    },
    "messages.reportEncryptedSpam": function(w, v) {
      w.uint(1259113487);
      w.object(h(v, "peer"));
    },
    "messages.readMessageContents": function(w, v) {
      w.uint(916930423);
      w.vector(w.int, h(v, "id"));
    },
    "messages.getStickers": function(w, v) {
      w.uint(3584414625);
      w.string(h(v, "emoticon"));
      w.long(h(v, "hash"));
    },
    "messages.getAllStickers": function(w, v) {
      w.uint(3097534888);
      w.long(h(v, "hash"));
    },
    "messages.getWebPagePreview": function(w, v) {
      w.uint(2338894028);
      var flags = 0;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 8;
      w.uint(flags);
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
    },
    "messages.exportChatInvite": function(w, v) {
      w.uint(2757090960);
      var flags = 0;
      var _expireDate = v.expireDate !== void 0;
      if (_expireDate)
        flags |= 1;
      var _usageLimit = v.usageLimit !== void 0;
      if (_usageLimit)
        flags |= 2;
      if (v.legacyRevokePermanent === true)
        flags |= 4;
      if (v.requestNeeded === true)
        flags |= 8;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 16;
      var _subscriptionPricing = v.subscriptionPricing !== void 0;
      if (_subscriptionPricing)
        flags |= 32;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_expireDate)
        w.int(v.expireDate);
      if (_usageLimit)
        w.int(v.usageLimit);
      if (_title)
        w.string(v.title);
      if (_subscriptionPricing)
        w.object(v.subscriptionPricing);
    },
    "messages.checkChatInvite": function(w, v) {
      w.uint(1051570619);
      w.string(h(v, "hash"));
    },
    "messages.importChatInvite": function(w, v) {
      w.uint(1817183516);
      w.string(h(v, "hash"));
    },
    "messages.getStickerSet": function(w, v) {
      w.uint(3365989492);
      w.object(h(v, "stickerset"));
      w.int(h(v, "hash"));
    },
    "messages.installStickerSet": function(w, v) {
      w.uint(3348096096);
      w.object(h(v, "stickerset"));
      w.boolean(h(v, "archived"));
    },
    "messages.uninstallStickerSet": function(w, v) {
      w.uint(4184757726);
      w.object(h(v, "stickerset"));
    },
    "messages.startBot": function(w, v) {
      w.uint(3873403768);
      w.object(h(v, "bot"));
      w.object(h(v, "peer"));
      w.long(h(v, "randomId"));
      w.string(h(v, "startParam"));
    },
    "messages.getMessagesViews": function(w, v) {
      w.uint(1468322785);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
      w.boolean(h(v, "increment"));
    },
    "messages.editChatAdmin": function(w, v) {
      w.uint(2824589762);
      w.int53(h(v, "chatId"));
      w.object(h(v, "userId"));
      w.boolean(h(v, "isAdmin"));
    },
    "messages.migrateChat": function(w, v) {
      w.uint(2726777625);
      w.int53(h(v, "chatId"));
    },
    "messages.searchGlobal": function(w, v) {
      w.uint(1271290010);
      var flags = 0;
      var _folderId = v.folderId !== void 0;
      if (_folderId)
        flags |= 1;
      if (v.broadcastsOnly === true)
        flags |= 2;
      w.uint(flags);
      if (_folderId)
        w.int(v.folderId);
      w.string(h(v, "q"));
      w.object(h(v, "filter"));
      w.int(h(v, "minDate"));
      w.int(h(v, "maxDate"));
      w.int(h(v, "offsetRate"));
      w.object(h(v, "offsetPeer"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "limit"));
    },
    "messages.reorderStickerSets": function(w, v) {
      w.uint(2016638777);
      var flags = 0;
      if (v.masks === true)
        flags |= 1;
      if (v.emojis === true)
        flags |= 2;
      w.uint(flags);
      w.vector(w.long, h(v, "order"));
    },
    "messages.getDocumentByHash": function(w, v) {
      w.uint(2985428511);
      w.bytes(h(v, "sha256"));
      w.int53(h(v, "size"));
      w.string(h(v, "mimeType"));
    },
    "messages.getSavedGifs": function(w, v) {
      w.uint(1559270965);
      w.long(h(v, "hash"));
    },
    "messages.saveGif": function(w, v) {
      w.uint(846868683);
      w.object(h(v, "id"));
      w.boolean(h(v, "unsave"));
    },
    "messages.getInlineBotResults": function(w, v) {
      w.uint(1364105629);
      var flags = 0;
      var _geoPoint = v.geoPoint !== void 0;
      if (_geoPoint)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "bot"));
      w.object(h(v, "peer"));
      if (_geoPoint)
        w.object(v.geoPoint);
      w.string(h(v, "query"));
      w.string(h(v, "offset"));
    },
    "messages.setInlineBotResults": function(w, v) {
      w.uint(3138561049);
      var flags = 0;
      if (v.gallery === true)
        flags |= 1;
      if (v.private === true)
        flags |= 2;
      var _nextOffset = v.nextOffset !== void 0;
      if (_nextOffset)
        flags |= 4;
      var _switchPm = v.switchPm !== void 0;
      if (_switchPm)
        flags |= 8;
      var _switchWebview = v.switchWebview !== void 0;
      if (_switchWebview)
        flags |= 16;
      w.uint(flags);
      w.long(h(v, "queryId"));
      w.vector(w.object, h(v, "results"));
      w.int(h(v, "cacheTime"));
      if (_nextOffset)
        w.string(v.nextOffset);
      if (_switchPm)
        w.object(v.switchPm);
      if (_switchWebview)
        w.object(v.switchWebview);
    },
    "messages.sendInlineBotResult": function(w, v) {
      w.uint(1052698730);
      var flags = 0;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 1;
      if (v.silent === true)
        flags |= 32;
      if (v.background === true)
        flags |= 64;
      if (v.clearDraft === true)
        flags |= 128;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 1024;
      if (v.hideVia === true)
        flags |= 2048;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 8192;
      var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
      if (_quickReplyShortcut)
        flags |= 131072;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_replyTo)
        w.object(v.replyTo);
      w.long(h(v, "randomId"));
      w.long(h(v, "queryId"));
      w.string(h(v, "id"));
      if (_scheduleDate)
        w.int(v.scheduleDate);
      if (_sendAs)
        w.object(v.sendAs);
      if (_quickReplyShortcut)
        w.object(v.quickReplyShortcut);
    },
    "messages.getMessageEditData": function(w, v) {
      w.uint(4255550774);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
    },
    "messages.editMessage": function(w, v) {
      w.uint(3755032581);
      var flags = 0;
      if (v.noWebpage === true)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 8;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 2048;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 16384;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 32768;
      if (v.invertMedia === true)
        flags |= 65536;
      var _quickReplyShortcutId = v.quickReplyShortcutId !== void 0;
      if (_quickReplyShortcutId)
        flags |= 131072;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      if (_message)
        w.string(v.message);
      if (_media)
        w.object(v.media);
      if (_replyMarkup)
        w.object(v.replyMarkup);
      if (_entities)
        w.vector(w.object, v.entities);
      if (_scheduleDate)
        w.int(v.scheduleDate);
      if (_quickReplyShortcutId)
        w.int(v.quickReplyShortcutId);
    },
    "messages.editInlineBotMessage": function(w, v) {
      w.uint(2203418042);
      var flags = 0;
      if (v.noWebpage === true)
        flags |= 2;
      var _replyMarkup = v.replyMarkup !== void 0;
      if (_replyMarkup)
        flags |= 4;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 8;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 2048;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 16384;
      if (v.invertMedia === true)
        flags |= 65536;
      w.uint(flags);
      w.object(h(v, "id"));
      if (_message)
        w.string(v.message);
      if (_media)
        w.object(v.media);
      if (_replyMarkup)
        w.object(v.replyMarkup);
      if (_entities)
        w.vector(w.object, v.entities);
    },
    "messages.getBotCallbackAnswer": function(w, v) {
      w.uint(2470627847);
      var flags = 0;
      var _data = v.data !== void 0;
      if (_data)
        flags |= 1;
      if (v.game === true)
        flags |= 2;
      var _password = v.password !== void 0;
      if (_password)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      if (_data)
        w.bytes(v.data);
      if (_password)
        w.object(v.password);
    },
    "messages.setBotCallbackAnswer": function(w, v) {
      w.uint(3582923530);
      var flags = 0;
      var _message = v.message !== void 0;
      if (_message)
        flags |= 1;
      if (v.alert === true)
        flags |= 2;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "queryId"));
      if (_message)
        w.string(v.message);
      if (_url)
        w.string(v.url);
      w.int(h(v, "cacheTime"));
    },
    "messages.getPeerDialogs": function(w, v) {
      w.uint(3832593661);
      w.vector(w.object, h(v, "peers"));
    },
    "messages.saveDraft": function(w, v) {
      w.uint(3547514318);
      var flags = 0;
      if (v.noWebpage === true)
        flags |= 2;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 8;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 16;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 32;
      if (v.invertMedia === true)
        flags |= 64;
      var _effect = v.effect !== void 0;
      if (_effect)
        flags |= 128;
      w.uint(flags);
      if (_replyTo)
        w.object(v.replyTo);
      w.object(h(v, "peer"));
      w.string(h(v, "message"));
      if (_entities)
        w.vector(w.object, v.entities);
      if (_media)
        w.object(v.media);
      if (_effect)
        w.long(v.effect);
    },
    "messages.getAllDrafts": function(w) {
      w.uint(1782549861);
    },
    "messages.getFeaturedStickers": function(w, v) {
      w.uint(1685588756);
      w.long(h(v, "hash"));
    },
    "messages.readFeaturedStickers": function(w, v) {
      w.uint(1527873830);
      w.vector(w.long, h(v, "id"));
    },
    "messages.getRecentStickers": function(w, v) {
      w.uint(2645114939);
      var flags = 0;
      if (v.attached === true)
        flags |= 1;
      w.uint(flags);
      w.long(h(v, "hash"));
    },
    "messages.saveRecentSticker": function(w, v) {
      w.uint(958863608);
      var flags = 0;
      if (v.attached === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "id"));
      w.boolean(h(v, "unsave"));
    },
    "messages.clearRecentStickers": function(w, v) {
      w.uint(2308530221);
      var flags = 0;
      if (v.attached === true)
        flags |= 1;
      w.uint(flags);
    },
    "messages.getArchivedStickers": function(w, v) {
      w.uint(1475442322);
      var flags = 0;
      if (v.masks === true)
        flags |= 1;
      if (v.emojis === true)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "offsetId"));
      w.int(h(v, "limit"));
    },
    "messages.getMaskStickers": function(w, v) {
      w.uint(1678738104);
      w.long(h(v, "hash"));
    },
    "messages.getAttachedStickers": function(w, v) {
      w.uint(3428542412);
      w.object(h(v, "media"));
    },
    "messages.setGameScore": function(w, v) {
      w.uint(2398678208);
      var flags = 0;
      if (v.editMessage === true)
        flags |= 1;
      if (v.force === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      w.object(h(v, "userId"));
      w.int(h(v, "score"));
    },
    "messages.setInlineGameScore": function(w, v) {
      w.uint(363700068);
      var flags = 0;
      if (v.editMessage === true)
        flags |= 1;
      if (v.force === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "id"));
      w.object(h(v, "userId"));
      w.int(h(v, "score"));
    },
    "messages.getGameHighScores": function(w, v) {
      w.uint(3894568093);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      w.object(h(v, "userId"));
    },
    "messages.getInlineGameHighScores": function(w, v) {
      w.uint(258170395);
      w.object(h(v, "id"));
      w.object(h(v, "userId"));
    },
    "messages.getCommonChats": function(w, v) {
      w.uint(3826032900);
      w.object(h(v, "userId"));
      w.int53(h(v, "maxId"));
      w.int(h(v, "limit"));
    },
    "messages.getWebPage": function(w, v) {
      w.uint(2375455395);
      w.string(h(v, "url"));
      w.int(h(v, "hash"));
    },
    "messages.toggleDialogPin": function(w, v) {
      w.uint(2805064279);
      var flags = 0;
      if (v.pinned === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "messages.reorderPinnedDialogs": function(w, v) {
      w.uint(991616823);
      var flags = 0;
      if (v.force === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "folderId"));
      w.vector(w.object, h(v, "order"));
    },
    "messages.getPinnedDialogs": function(w, v) {
      w.uint(3602468338);
      w.int(h(v, "folderId"));
    },
    "messages.setBotShippingResults": function(w, v) {
      w.uint(3858133754);
      var flags = 0;
      var _error = v.error !== void 0;
      if (_error)
        flags |= 1;
      var _shippingOptions = v.shippingOptions && v.shippingOptions.length;
      if (_shippingOptions)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "queryId"));
      if (_error)
        w.string(v.error);
      if (_shippingOptions)
        w.vector(w.object, v.shippingOptions);
    },
    "messages.setBotPrecheckoutResults": function(w, v) {
      w.uint(163765653);
      var flags = 0;
      var _error = v.error !== void 0;
      if (_error)
        flags |= 1;
      if (v.success === true)
        flags |= 2;
      w.uint(flags);
      w.long(h(v, "queryId"));
      if (_error)
        w.string(v.error);
    },
    "messages.uploadMedia": function(w, v) {
      w.uint(345405816);
      var flags = 0;
      var _businessConnectionId = v.businessConnectionId !== void 0;
      if (_businessConnectionId)
        flags |= 1;
      w.uint(flags);
      if (_businessConnectionId)
        w.string(v.businessConnectionId);
      w.object(h(v, "peer"));
      w.object(h(v, "media"));
    },
    "messages.sendScreenshotNotification": function(w, v) {
      w.uint(2705348631);
      w.object(h(v, "peer"));
      w.object(h(v, "replyTo"));
      w.long(h(v, "randomId"));
    },
    "messages.getFavedStickers": function(w, v) {
      w.uint(82946729);
      w.long(h(v, "hash"));
    },
    "messages.faveSticker": function(w, v) {
      w.uint(3120547163);
      w.object(h(v, "id"));
      w.boolean(h(v, "unfave"));
    },
    "messages.getUnreadMentions": function(w, v) {
      w.uint(4043827088);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_topMsgId)
        w.int(v.topMsgId);
      w.int(h(v, "offsetId"));
      w.int(h(v, "addOffset"));
      w.int(h(v, "limit"));
      w.int(h(v, "maxId"));
      w.int(h(v, "minId"));
    },
    "messages.readMentions": function(w, v) {
      w.uint(921026381);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_topMsgId)
        w.int(v.topMsgId);
    },
    "messages.getRecentLocations": function(w, v) {
      w.uint(1881817312);
      w.object(h(v, "peer"));
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "messages.sendMultiMedia": function(w, v) {
      w.uint(934757205);
      var flags = 0;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 1;
      if (v.silent === true)
        flags |= 32;
      if (v.background === true)
        flags |= 64;
      if (v.clearDraft === true)
        flags |= 128;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 1024;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 8192;
      if (v.noforwards === true)
        flags |= 16384;
      if (v.updateStickersetsOrder === true)
        flags |= 32768;
      if (v.invertMedia === true)
        flags |= 65536;
      var _quickReplyShortcut = v.quickReplyShortcut !== void 0;
      if (_quickReplyShortcut)
        flags |= 131072;
      var _effect = v.effect !== void 0;
      if (_effect)
        flags |= 262144;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_replyTo)
        w.object(v.replyTo);
      w.vector(w.object, h(v, "multiMedia"));
      if (_scheduleDate)
        w.int(v.scheduleDate);
      if (_sendAs)
        w.object(v.sendAs);
      if (_quickReplyShortcut)
        w.object(v.quickReplyShortcut);
      if (_effect)
        w.long(v.effect);
    },
    "messages.uploadEncryptedFile": function(w, v) {
      w.uint(1347929239);
      w.object(h(v, "peer"));
      w.object(h(v, "file"));
    },
    "messages.searchStickerSets": function(w, v) {
      w.uint(896555914);
      var flags = 0;
      if (v.excludeFeatured === true)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "q"));
      w.long(h(v, "hash"));
    },
    "messages.getSplitRanges": function(w) {
      w.uint(486505992);
    },
    "messages.markDialogUnread": function(w, v) {
      w.uint(3263617423);
      var flags = 0;
      if (v.unread === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "messages.getDialogUnreadMarks": function(w) {
      w.uint(585256482);
    },
    "messages.clearAllDrafts": function(w) {
      w.uint(2119757468);
    },
    "messages.updatePinnedMessage": function(w, v) {
      w.uint(3534419948);
      var flags = 0;
      if (v.silent === true)
        flags |= 1;
      if (v.unpin === true)
        flags |= 2;
      if (v.pmOneside === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
    },
    "messages.sendVote": function(w, v) {
      w.uint(283795844);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.vector(w.bytes, h(v, "options"));
    },
    "messages.getPollResults": function(w, v) {
      w.uint(1941660731);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "messages.getOnlines": function(w, v) {
      w.uint(1848369232);
      w.object(h(v, "peer"));
    },
    "messages.editChatAbout": function(w, v) {
      w.uint(3740665751);
      w.object(h(v, "peer"));
      w.string(h(v, "about"));
    },
    "messages.editChatDefaultBannedRights": function(w, v) {
      w.uint(2777049921);
      w.object(h(v, "peer"));
      w.object(h(v, "bannedRights"));
    },
    "messages.getEmojiKeywords": function(w, v) {
      w.uint(899735650);
      w.string(h(v, "langCode"));
    },
    "messages.getEmojiKeywordsDifference": function(w, v) {
      w.uint(352892591);
      w.string(h(v, "langCode"));
      w.int(h(v, "fromVersion"));
    },
    "messages.getEmojiKeywordsLanguages": function(w, v) {
      w.uint(1318675378);
      w.vector(w.string, h(v, "langCodes"));
    },
    "messages.getEmojiURL": function(w, v) {
      w.uint(3585149990);
      w.string(h(v, "langCode"));
    },
    "messages.getSearchCounters": function(w, v) {
      w.uint(465367808);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      var _savedPeerId = v.savedPeerId !== void 0;
      if (_savedPeerId)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_savedPeerId)
        w.object(v.savedPeerId);
      if (_topMsgId)
        w.int(v.topMsgId);
      w.vector(w.object, h(v, "filters"));
    },
    "messages.requestUrlAuth": function(w, v) {
      w.uint(428848198);
      var flags = 0;
      var _peer = v.peer !== void 0;
      var _msgId = v.msgId !== void 0;
      var _buttonId = v.buttonId !== void 0;
      var _flags_1 = _peer || _msgId || _buttonId;
      if (_flags_1)
        flags |= 2;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 4;
      w.uint(flags);
      if (_flags_1)
        w.object(v.peer);
      if (_flags_1)
        w.int(v.msgId);
      if (_flags_1)
        w.int(v.buttonId);
      if (_url)
        w.string(v.url);
    },
    "messages.acceptUrlAuth": function(w, v) {
      w.uint(2972479781);
      var flags = 0;
      if (v.writeAllowed === true)
        flags |= 1;
      var _peer = v.peer !== void 0;
      var _msgId = v.msgId !== void 0;
      var _buttonId = v.buttonId !== void 0;
      var _flags_1 = _peer || _msgId || _buttonId;
      if (_flags_1)
        flags |= 2;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 4;
      w.uint(flags);
      if (_flags_1)
        w.object(v.peer);
      if (_flags_1)
        w.int(v.msgId);
      if (_flags_1)
        w.int(v.buttonId);
      if (_url)
        w.string(v.url);
    },
    "messages.hidePeerSettingsBar": function(w, v) {
      w.uint(1336717624);
      w.object(h(v, "peer"));
    },
    "messages.getScheduledHistory": function(w, v) {
      w.uint(4111889931);
      w.object(h(v, "peer"));
      w.long(h(v, "hash"));
    },
    "messages.getScheduledMessages": function(w, v) {
      w.uint(3183150180);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "messages.sendScheduledMessages": function(w, v) {
      w.uint(3174597898);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "messages.deleteScheduledMessages": function(w, v) {
      w.uint(1504586518);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "messages.getPollVotes": function(w, v) {
      w.uint(3094231054);
      var flags = 0;
      var _option = v.option !== void 0;
      if (_option)
        flags |= 1;
      var _offset = v.offset !== void 0;
      if (_offset)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      if (_option)
        w.bytes(v.option);
      if (_offset)
        w.string(v.offset);
      w.int(h(v, "limit"));
    },
    "messages.toggleStickerSets": function(w, v) {
      w.uint(3037016042);
      var flags = 0;
      if (v.uninstall === true)
        flags |= 1;
      if (v.archive === true)
        flags |= 2;
      if (v.unarchive === true)
        flags |= 4;
      w.uint(flags);
      w.vector(w.object, h(v, "stickersets"));
    },
    "messages.getDialogFilters": function(w) {
      w.uint(4023684233);
    },
    "messages.getSuggestedDialogFilters": function(w) {
      w.uint(2728186924);
    },
    "messages.updateDialogFilter": function(w, v) {
      w.uint(450142282);
      var flags = 0;
      var _filter = v.filter !== void 0;
      if (_filter)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "id"));
      if (_filter)
        w.object(v.filter);
    },
    "messages.updateDialogFiltersOrder": function(w, v) {
      w.uint(3311649252);
      w.vector(w.int, h(v, "order"));
    },
    "messages.getOldFeaturedStickers": function(w, v) {
      w.uint(2127598753);
      w.int(h(v, "offset"));
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "messages.getReplies": function(w, v) {
      w.uint(584962828);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "offsetDate"));
      w.int(h(v, "addOffset"));
      w.int(h(v, "limit"));
      w.int(h(v, "maxId"));
      w.int(h(v, "minId"));
      w.long(h(v, "hash"));
    },
    "messages.getDiscussionMessage": function(w, v) {
      w.uint(1147761405);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "messages.readDiscussion": function(w, v) {
      w.uint(4147227124);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int(h(v, "readMaxId"));
    },
    "messages.unpinAllMessages": function(w, v) {
      w.uint(3995253160);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_topMsgId)
        w.int(v.topMsgId);
    },
    "messages.deleteChat": function(w, v) {
      w.uint(1540419152);
      w.int53(h(v, "chatId"));
    },
    "messages.deletePhoneCallHistory": function(w, v) {
      w.uint(4190888969);
      var flags = 0;
      if (v.revoke === true)
        flags |= 1;
      w.uint(flags);
    },
    "messages.checkHistoryImport": function(w, v) {
      w.uint(1140726259);
      w.string(h(v, "importHead"));
    },
    "messages.initHistoryImport": function(w, v) {
      w.uint(873008187);
      w.object(h(v, "peer"));
      w.object(h(v, "file"));
      w.int(h(v, "mediaCount"));
    },
    "messages.uploadImportedMedia": function(w, v) {
      w.uint(713433234);
      w.object(h(v, "peer"));
      w.long(h(v, "importId"));
      w.string(h(v, "fileName"));
      w.object(h(v, "media"));
    },
    "messages.startHistoryImport": function(w, v) {
      w.uint(3023958852);
      w.object(h(v, "peer"));
      w.long(h(v, "importId"));
    },
    "messages.getExportedChatInvites": function(w, v) {
      w.uint(2729812982);
      var flags = 0;
      var _offsetDate = v.offsetDate !== void 0;
      var _offsetLink = v.offsetLink !== void 0;
      var _flags_2 = _offsetDate || _offsetLink;
      if (_flags_2)
        flags |= 4;
      if (v.revoked === true)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "adminId"));
      if (_flags_2)
        w.int(v.offsetDate);
      if (_flags_2)
        w.string(v.offsetLink);
      w.int(h(v, "limit"));
    },
    "messages.getExportedChatInvite": function(w, v) {
      w.uint(1937010524);
      w.object(h(v, "peer"));
      w.string(h(v, "link"));
    },
    "messages.editExportedChatInvite": function(w, v) {
      w.uint(3184144245);
      var flags = 0;
      var _expireDate = v.expireDate !== void 0;
      if (_expireDate)
        flags |= 1;
      var _usageLimit = v.usageLimit !== void 0;
      if (_usageLimit)
        flags |= 2;
      if (v.revoked === true)
        flags |= 4;
      var _requestNeeded = v.requestNeeded !== void 0;
      if (_requestNeeded)
        flags |= 8;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 16;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.string(h(v, "link"));
      if (_expireDate)
        w.int(v.expireDate);
      if (_usageLimit)
        w.int(v.usageLimit);
      if (_requestNeeded)
        w.boolean(v.requestNeeded);
      if (_title)
        w.string(v.title);
    },
    "messages.deleteRevokedExportedChatInvites": function(w, v) {
      w.uint(1452833749);
      w.object(h(v, "peer"));
      w.object(h(v, "adminId"));
    },
    "messages.deleteExportedChatInvite": function(w, v) {
      w.uint(3563365419);
      w.object(h(v, "peer"));
      w.string(h(v, "link"));
    },
    "messages.getAdminsWithInvites": function(w, v) {
      w.uint(958457583);
      w.object(h(v, "peer"));
    },
    "messages.getChatInviteImporters": function(w, v) {
      w.uint(3741637966);
      var flags = 0;
      if (v.requested === true)
        flags |= 1;
      var _link = v.link !== void 0;
      if (_link)
        flags |= 2;
      var _q = v.q !== void 0;
      if (_q)
        flags |= 4;
      if (v.subscriptionExpired === true)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_link)
        w.string(v.link);
      if (_q)
        w.string(v.q);
      w.int(h(v, "offsetDate"));
      w.object(h(v, "offsetUser"));
      w.int(h(v, "limit"));
    },
    "messages.setHistoryTTL": function(w, v) {
      w.uint(3087949796);
      w.object(h(v, "peer"));
      w.int(h(v, "period"));
    },
    "messages.checkHistoryImportPeer": function(w, v) {
      w.uint(1573261059);
      w.object(h(v, "peer"));
    },
    "messages.setChatTheme": function(w, v) {
      w.uint(3862683967);
      w.object(h(v, "peer"));
      w.string(h(v, "emoticon"));
    },
    "messages.getMessageReadParticipants": function(w, v) {
      w.uint(834782287);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "messages.getSearchResultsCalendar": function(w, v) {
      w.uint(1789130429);
      var flags = 0;
      var _savedPeerId = v.savedPeerId !== void 0;
      if (_savedPeerId)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_savedPeerId)
        w.object(v.savedPeerId);
      w.object(h(v, "filter"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "offsetDate"));
    },
    "messages.getSearchResultsPositions": function(w, v) {
      w.uint(2625580816);
      var flags = 0;
      var _savedPeerId = v.savedPeerId !== void 0;
      if (_savedPeerId)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_savedPeerId)
        w.object(v.savedPeerId);
      w.object(h(v, "filter"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "limit"));
    },
    "messages.hideChatJoinRequest": function(w, v) {
      w.uint(2145904661);
      var flags = 0;
      if (v.approved === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "userId"));
    },
    "messages.hideAllChatJoinRequests": function(w, v) {
      w.uint(3766875370);
      var flags = 0;
      if (v.approved === true)
        flags |= 1;
      var _link = v.link !== void 0;
      if (_link)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_link)
        w.string(v.link);
    },
    "messages.toggleNoForwards": function(w, v) {
      w.uint(2971578274);
      w.object(h(v, "peer"));
      w.boolean(h(v, "enabled"));
    },
    "messages.saveDefaultSendAs": function(w, v) {
      w.uint(3439189910);
      w.object(h(v, "peer"));
      w.object(h(v, "sendAs"));
    },
    "messages.sendReaction": function(w, v) {
      w.uint(3540875476);
      var flags = 0;
      var _reaction = v.reaction && v.reaction.length;
      if (_reaction)
        flags |= 1;
      if (v.big === true)
        flags |= 2;
      if (v.addToRecent === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      if (_reaction)
        w.vector(w.object, v.reaction);
    },
    "messages.getMessagesReactions": function(w, v) {
      w.uint(2344259814);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "messages.getMessageReactionsList": function(w, v) {
      w.uint(1176190792);
      var flags = 0;
      var _reaction = v.reaction !== void 0;
      if (_reaction)
        flags |= 1;
      var _offset = v.offset !== void 0;
      if (_offset)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      if (_reaction)
        w.object(v.reaction);
      if (_offset)
        w.string(v.offset);
      w.int(h(v, "limit"));
    },
    "messages.setChatAvailableReactions": function(w, v) {
      w.uint(2253071745);
      var flags = 0;
      var _reactionsLimit = v.reactionsLimit !== void 0;
      if (_reactionsLimit)
        flags |= 1;
      var _paidEnabled = v.paidEnabled !== void 0;
      if (_paidEnabled)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "availableReactions"));
      if (_reactionsLimit)
        w.int(v.reactionsLimit);
      if (_paidEnabled)
        w.boolean(v.paidEnabled);
    },
    "messages.getAvailableReactions": function(w, v) {
      w.uint(417243308);
      w.int(h(v, "hash"));
    },
    "messages.setDefaultReaction": function(w, v) {
      w.uint(1330094102);
      w.object(h(v, "reaction"));
    },
    "messages.translateText": function(w, v) {
      w.uint(1662529584);
      var flags = 0;
      var _peer = v.peer !== void 0;
      var _id = v.id && v.id.length;
      var _flags_0 = _peer || _id;
      if (_flags_0)
        flags |= 1;
      var _text = v.text && v.text.length;
      if (_text)
        flags |= 2;
      w.uint(flags);
      if (_flags_0)
        w.object(v.peer);
      if (_flags_0)
        w.vector(w.int, v.id);
      if (_text)
        w.vector(w.object, v.text);
      w.string(h(v, "toLang"));
    },
    "messages.getUnreadReactions": function(w, v) {
      w.uint(841173339);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_topMsgId)
        w.int(v.topMsgId);
      w.int(h(v, "offsetId"));
      w.int(h(v, "addOffset"));
      w.int(h(v, "limit"));
      w.int(h(v, "maxId"));
      w.int(h(v, "minId"));
    },
    "messages.readReactions": function(w, v) {
      w.uint(1420459918);
      var flags = 0;
      var _topMsgId = v.topMsgId !== void 0;
      if (_topMsgId)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_topMsgId)
        w.int(v.topMsgId);
    },
    "messages.searchSentMedia": function(w, v) {
      w.uint(276705696);
      w.string(h(v, "q"));
      w.object(h(v, "filter"));
      w.int(h(v, "limit"));
    },
    "messages.getAttachMenuBots": function(w, v) {
      w.uint(385663691);
      w.long(h(v, "hash"));
    },
    "messages.getAttachMenuBot": function(w, v) {
      w.uint(1998676370);
      w.object(h(v, "bot"));
    },
    "messages.toggleBotInAttachMenu": function(w, v) {
      w.uint(1777704297);
      var flags = 0;
      if (v.writeAllowed === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "bot"));
      w.boolean(h(v, "enabled"));
    },
    "messages.requestWebView": function(w, v) {
      w.uint(647873217);
      var flags = 0;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 1;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 2;
      var _themeParams = v.themeParams !== void 0;
      if (_themeParams)
        flags |= 4;
      var _startParam = v.startParam !== void 0;
      if (_startParam)
        flags |= 8;
      if (v.fromBotMenu === true)
        flags |= 16;
      if (v.silent === true)
        flags |= 32;
      if (v.compact === true)
        flags |= 128;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 8192;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "bot"));
      if (_url)
        w.string(v.url);
      if (_startParam)
        w.string(v.startParam);
      if (_themeParams)
        w.object(v.themeParams);
      w.string(h(v, "platform"));
      if (_replyTo)
        w.object(v.replyTo);
      if (_sendAs)
        w.object(v.sendAs);
    },
    "messages.prolongWebView": function(w, v) {
      w.uint(2966952579);
      var flags = 0;
      var _replyTo = v.replyTo !== void 0;
      if (_replyTo)
        flags |= 1;
      if (v.silent === true)
        flags |= 32;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 8192;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "bot"));
      w.long(h(v, "queryId"));
      if (_replyTo)
        w.object(v.replyTo);
      if (_sendAs)
        w.object(v.sendAs);
    },
    "messages.requestSimpleWebView": function(w, v) {
      w.uint(1094336115);
      var flags = 0;
      var _themeParams = v.themeParams !== void 0;
      if (_themeParams)
        flags |= 1;
      if (v.fromSwitchWebview === true)
        flags |= 2;
      if (v.fromSideMenu === true)
        flags |= 4;
      var _url = v.url !== void 0;
      if (_url)
        flags |= 8;
      var _startParam = v.startParam !== void 0;
      if (_startParam)
        flags |= 16;
      if (v.compact === true)
        flags |= 128;
      w.uint(flags);
      w.object(h(v, "bot"));
      if (_url)
        w.string(v.url);
      if (_startParam)
        w.string(v.startParam);
      if (_themeParams)
        w.object(v.themeParams);
      w.string(h(v, "platform"));
    },
    "messages.sendWebViewResultMessage": function(w, v) {
      w.uint(172168437);
      w.string(h(v, "botQueryId"));
      w.object(h(v, "result"));
    },
    "messages.sendWebViewData": function(w, v) {
      w.uint(3691135688);
      w.object(h(v, "bot"));
      w.long(h(v, "randomId"));
      w.string(h(v, "buttonText"));
      w.string(h(v, "data"));
    },
    "messages.transcribeAudio": function(w, v) {
      w.uint(647928393);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "messages.rateTranscribedAudio": function(w, v) {
      w.uint(2132608815);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.long(h(v, "transcriptionId"));
      w.boolean(h(v, "good"));
    },
    "messages.getCustomEmojiDocuments": function(w, v) {
      w.uint(3651866452);
      w.vector(w.long, h(v, "documentId"));
    },
    "messages.getEmojiStickers": function(w, v) {
      w.uint(4227637647);
      w.long(h(v, "hash"));
    },
    "messages.getFeaturedEmojiStickers": function(w, v) {
      w.uint(248473398);
      w.long(h(v, "hash"));
    },
    "messages.reportReaction": function(w, v) {
      w.uint(1063567478);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      w.object(h(v, "reactionPeer"));
    },
    "messages.getTopReactions": function(w, v) {
      w.uint(3145803194);
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "messages.getRecentReactions": function(w, v) {
      w.uint(960896434);
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "messages.clearRecentReactions": function(w) {
      w.uint(2650730420);
    },
    "messages.getExtendedMedia": function(w, v) {
      w.uint(2230847508);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "messages.setDefaultHistoryTTL": function(w, v) {
      w.uint(2662667333);
      w.int(h(v, "period"));
    },
    "messages.getDefaultHistoryTTL": function(w) {
      w.uint(1703637384);
    },
    "messages.sendBotRequestedPeer": function(w, v) {
      w.uint(2444415072);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int(h(v, "buttonId"));
      w.vector(w.object, h(v, "requestedPeers"));
    },
    "messages.getEmojiGroups": function(w, v) {
      w.uint(1955122779);
      w.int(h(v, "hash"));
    },
    "messages.getEmojiStatusGroups": function(w, v) {
      w.uint(785209037);
      w.int(h(v, "hash"));
    },
    "messages.getEmojiProfilePhotoGroups": function(w, v) {
      w.uint(564480243);
      w.int(h(v, "hash"));
    },
    "messages.searchCustomEmoji": function(w, v) {
      w.uint(739360983);
      w.string(h(v, "emoticon"));
      w.long(h(v, "hash"));
    },
    "messages.togglePeerTranslations": function(w, v) {
      w.uint(3833378169);
      var flags = 0;
      if (v.disabled === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "messages.getBotApp": function(w, v) {
      w.uint(889046467);
      w.object(h(v, "app"));
      w.long(h(v, "hash"));
    },
    "messages.requestAppWebView": function(w, v) {
      w.uint(1398901710);
      var flags = 0;
      if (v.writeAllowed === true)
        flags |= 1;
      var _startParam = v.startParam !== void 0;
      if (_startParam)
        flags |= 2;
      var _themeParams = v.themeParams !== void 0;
      if (_themeParams)
        flags |= 4;
      if (v.compact === true)
        flags |= 128;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "app"));
      if (_startParam)
        w.string(v.startParam);
      if (_themeParams)
        w.object(v.themeParams);
      w.string(h(v, "platform"));
    },
    "messages.setChatWallPaper": function(w, v) {
      w.uint(2415577825);
      var flags = 0;
      var _wallpaper = v.wallpaper !== void 0;
      if (_wallpaper)
        flags |= 1;
      var _id = v.id !== void 0;
      if (_id)
        flags |= 2;
      var _settings = v.settings !== void 0;
      if (_settings)
        flags |= 4;
      if (v.forBoth === true)
        flags |= 8;
      if (v.revert === true)
        flags |= 16;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_wallpaper)
        w.object(v.wallpaper);
      if (_settings)
        w.object(v.settings);
      if (_id)
        w.int(v.id);
    },
    "messages.searchEmojiStickerSets": function(w, v) {
      w.uint(2461288780);
      var flags = 0;
      if (v.excludeFeatured === true)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "q"));
      w.long(h(v, "hash"));
    },
    "messages.getSavedDialogs": function(w, v) {
      w.uint(1401016858);
      var flags = 0;
      if (v.excludePinned === true)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "offsetDate"));
      w.int(h(v, "offsetId"));
      w.object(h(v, "offsetPeer"));
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "messages.getSavedHistory": function(w, v) {
      w.uint(1033519437);
      w.object(h(v, "peer"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "offsetDate"));
      w.int(h(v, "addOffset"));
      w.int(h(v, "limit"));
      w.int(h(v, "maxId"));
      w.int(h(v, "minId"));
      w.long(h(v, "hash"));
    },
    "messages.deleteSavedHistory": function(w, v) {
      w.uint(1855459371);
      var flags = 0;
      var _minDate = v.minDate !== void 0;
      if (_minDate)
        flags |= 4;
      var _maxDate = v.maxDate !== void 0;
      if (_maxDate)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "maxId"));
      if (_minDate)
        w.int(v.minDate);
      if (_maxDate)
        w.int(v.maxDate);
    },
    "messages.getPinnedSavedDialogs": function(w) {
      w.uint(3594360032);
    },
    "messages.toggleSavedDialogPin": function(w, v) {
      w.uint(2894183390);
      var flags = 0;
      if (v.pinned === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "messages.reorderPinnedSavedDialogs": function(w, v) {
      w.uint(2339464583);
      var flags = 0;
      if (v.force === true)
        flags |= 1;
      w.uint(flags);
      w.vector(w.object, h(v, "order"));
    },
    "messages.getSavedReactionTags": function(w, v) {
      w.uint(909631579);
      var flags = 0;
      var _peer = v.peer !== void 0;
      if (_peer)
        flags |= 1;
      w.uint(flags);
      if (_peer)
        w.object(v.peer);
      w.long(h(v, "hash"));
    },
    "messages.updateSavedReactionTag": function(w, v) {
      w.uint(1613331948);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "reaction"));
      if (_title)
        w.string(v.title);
    },
    "messages.getDefaultTagReactions": function(w, v) {
      w.uint(3187225640);
      w.long(h(v, "hash"));
    },
    "messages.getOutboxReadDate": function(w, v) {
      w.uint(2353790557);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "messages.getQuickReplies": function(w, v) {
      w.uint(3565417128);
      w.long(h(v, "hash"));
    },
    "messages.reorderQuickReplies": function(w, v) {
      w.uint(1613961479);
      w.vector(w.int, h(v, "order"));
    },
    "messages.checkQuickReplyShortcut": function(w, v) {
      w.uint(4057005011);
      w.string(h(v, "shortcut"));
    },
    "messages.editQuickReplyShortcut": function(w, v) {
      w.uint(1543519471);
      w.int(h(v, "shortcutId"));
      w.string(h(v, "shortcut"));
    },
    "messages.deleteQuickReplyShortcut": function(w, v) {
      w.uint(1019234112);
      w.int(h(v, "shortcutId"));
    },
    "messages.getQuickReplyMessages": function(w, v) {
      w.uint(2493814211);
      var flags = 0;
      var _id = v.id && v.id.length;
      if (_id)
        flags |= 1;
      w.uint(flags);
      w.int(h(v, "shortcutId"));
      if (_id)
        w.vector(w.int, v.id);
      w.long(h(v, "hash"));
    },
    "messages.sendQuickReplyMessages": function(w, v) {
      w.uint(1819610593);
      w.object(h(v, "peer"));
      w.int(h(v, "shortcutId"));
      w.vector(w.int, h(v, "id"));
      w.vector(w.long, h(v, "randomId"));
    },
    "messages.deleteQuickReplyMessages": function(w, v) {
      w.uint(3775260944);
      w.int(h(v, "shortcutId"));
      w.vector(w.int, h(v, "id"));
    },
    "messages.toggleDialogFilterTags": function(w, v) {
      w.uint(4247640649);
      w.boolean(h(v, "enabled"));
    },
    "messages.getMyStickers": function(w, v) {
      w.uint(3501580796);
      w.long(h(v, "offsetId"));
      w.int(h(v, "limit"));
    },
    "messages.getEmojiStickerGroups": function(w, v) {
      w.uint(500711669);
      w.int(h(v, "hash"));
    },
    "messages.getAvailableEffects": function(w, v) {
      w.uint(3735161401);
      w.int(h(v, "hash"));
    },
    "messages.editFactCheck": function(w, v) {
      w.uint(92925557);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.object(h(v, "text"));
    },
    "messages.deleteFactCheck": function(w, v) {
      w.uint(3520762892);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "messages.getFactCheck": function(w, v) {
      w.uint(3117270510);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "msgId"));
    },
    "messages.requestMainWebView": function(w, v) {
      w.uint(3386908283);
      var flags = 0;
      var _themeParams = v.themeParams !== void 0;
      if (_themeParams)
        flags |= 1;
      var _startParam = v.startParam !== void 0;
      if (_startParam)
        flags |= 2;
      if (v.compact === true)
        flags |= 128;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "bot"));
      if (_startParam)
        w.string(v.startParam);
      if (_themeParams)
        w.object(v.themeParams);
      w.string(h(v, "platform"));
    },
    "messages.sendPaidReaction": function(w, v) {
      w.uint(2648090235);
      var flags = 0;
      var _private = v.private !== void 0;
      if (_private)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.int(h(v, "count"));
      w.long(h(v, "randomId"));
      if (_private)
        w.boolean(v.private);
    },
    "messages.togglePaidReactionPrivacy": function(w, v) {
      w.uint(2224739223);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
      w.boolean(h(v, "private"));
    },
    "messages.getPaidReactionPrivacy": function(w) {
      w.uint(1193563562);
    },
    "updates.getState": function(w) {
      w.uint(3990128682);
    },
    "updates.getDifference": function(w, v) {
      w.uint(432207715);
      var flags = 0;
      var _ptsTotalLimit = v.ptsTotalLimit !== void 0;
      if (_ptsTotalLimit)
        flags |= 1;
      var _ptsLimit = v.ptsLimit !== void 0;
      if (_ptsLimit)
        flags |= 2;
      var _qtsLimit = v.qtsLimit !== void 0;
      if (_qtsLimit)
        flags |= 4;
      w.uint(flags);
      w.int(h(v, "pts"));
      if (_ptsLimit)
        w.int(v.ptsLimit);
      if (_ptsTotalLimit)
        w.int(v.ptsTotalLimit);
      w.int(h(v, "date"));
      w.int(h(v, "qts"));
      if (_qtsLimit)
        w.int(v.qtsLimit);
    },
    "updates.getChannelDifference": function(w, v) {
      w.uint(51854712);
      var flags = 0;
      if (v.force === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.object(h(v, "filter"));
      w.int(h(v, "pts"));
      w.int(h(v, "limit"));
    },
    "photos.updateProfilePhoto": function(w, v) {
      w.uint(166207545);
      var flags = 0;
      if (v.fallback === true)
        flags |= 1;
      var _bot = v.bot !== void 0;
      if (_bot)
        flags |= 2;
      w.uint(flags);
      if (_bot)
        w.object(v.bot);
      w.object(h(v, "id"));
    },
    "photos.uploadProfilePhoto": function(w, v) {
      w.uint(59286453);
      var flags = 0;
      var _file = v.file !== void 0;
      if (_file)
        flags |= 1;
      var _video = v.video !== void 0;
      if (_video)
        flags |= 2;
      var _videoStartTs = v.videoStartTs !== void 0;
      if (_videoStartTs)
        flags |= 4;
      if (v.fallback === true)
        flags |= 8;
      var _videoEmojiMarkup = v.videoEmojiMarkup !== void 0;
      if (_videoEmojiMarkup)
        flags |= 16;
      var _bot = v.bot !== void 0;
      if (_bot)
        flags |= 32;
      w.uint(flags);
      if (_bot)
        w.object(v.bot);
      if (_file)
        w.object(v.file);
      if (_video)
        w.object(v.video);
      if (_videoStartTs)
        w.double(v.videoStartTs);
      if (_videoEmojiMarkup)
        w.object(v.videoEmojiMarkup);
    },
    "photos.deletePhotos": function(w, v) {
      w.uint(2278522671);
      w.vector(w.object, h(v, "id"));
    },
    "photos.getUserPhotos": function(w, v) {
      w.uint(2446144168);
      w.object(h(v, "userId"));
      w.int(h(v, "offset"));
      w.long(h(v, "maxId"));
      w.int(h(v, "limit"));
    },
    "photos.uploadContactProfilePhoto": function(w, v) {
      w.uint(3779873393);
      var flags = 0;
      var _file = v.file !== void 0;
      if (_file)
        flags |= 1;
      var _video = v.video !== void 0;
      if (_video)
        flags |= 2;
      var _videoStartTs = v.videoStartTs !== void 0;
      if (_videoStartTs)
        flags |= 4;
      if (v.suggest === true)
        flags |= 8;
      if (v.save === true)
        flags |= 16;
      var _videoEmojiMarkup = v.videoEmojiMarkup !== void 0;
      if (_videoEmojiMarkup)
        flags |= 32;
      w.uint(flags);
      w.object(h(v, "userId"));
      if (_file)
        w.object(v.file);
      if (_video)
        w.object(v.video);
      if (_videoStartTs)
        w.double(v.videoStartTs);
      if (_videoEmojiMarkup)
        w.object(v.videoEmojiMarkup);
    },
    "upload.saveFilePart": function(w, v) {
      w.uint(3003426337);
      w.long(h(v, "fileId"));
      w.int(h(v, "filePart"));
      w.bytes(h(v, "bytes"));
    },
    "upload.getFile": function(w, v) {
      w.uint(3193124286);
      var flags = 0;
      if (v.precise === true)
        flags |= 1;
      if (v.cdnSupported === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "location"));
      w.int53(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "upload.saveBigFilePart": function(w, v) {
      w.uint(3732629309);
      w.long(h(v, "fileId"));
      w.int(h(v, "filePart"));
      w.int(h(v, "fileTotalParts"));
      w.bytes(h(v, "bytes"));
    },
    "upload.getWebFile": function(w, v) {
      w.uint(619086221);
      w.object(h(v, "location"));
      w.int(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "upload.getCdnFile": function(w, v) {
      w.uint(962554330);
      w.bytes(h(v, "fileToken"));
      w.int53(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "upload.reuploadCdnFile": function(w, v) {
      w.uint(2603046056);
      w.bytes(h(v, "fileToken"));
      w.bytes(h(v, "requestToken"));
    },
    "upload.getCdnFileHashes": function(w, v) {
      w.uint(2447130417);
      w.bytes(h(v, "fileToken"));
      w.int53(h(v, "offset"));
    },
    "upload.getFileHashes": function(w, v) {
      w.uint(2438371370);
      w.object(h(v, "location"));
      w.int53(h(v, "offset"));
    },
    "help.getConfig": function(w) {
      w.uint(3304659051);
    },
    "help.getNearestDc": function(w) {
      w.uint(531836966);
    },
    "help.getAppUpdate": function(w, v) {
      w.uint(1378703997);
      w.string(h(v, "source"));
    },
    "help.getInviteText": function(w) {
      w.uint(1295590211);
    },
    "help.getSupport": function(w) {
      w.uint(2631862477);
    },
    "help.setBotUpdatesStatus": function(w, v) {
      w.uint(3961704397);
      w.int(h(v, "pendingUpdatesCount"));
      w.string(h(v, "message"));
    },
    "help.getCdnConfig": function(w) {
      w.uint(1375900482);
    },
    "help.getRecentMeUrls": function(w, v) {
      w.uint(1036054804);
      w.string(h(v, "referer"));
    },
    "help.getTermsOfServiceUpdate": function(w) {
      w.uint(749019089);
    },
    "help.acceptTermsOfService": function(w, v) {
      w.uint(4000511898);
      w.object(h(v, "id"));
    },
    "help.getDeepLinkInfo": function(w, v) {
      w.uint(1072547679);
      w.string(h(v, "path"));
    },
    "help.getAppConfig": function(w, v) {
      w.uint(1642330196);
      w.int(h(v, "hash"));
    },
    "help.saveAppLog": function(w, v) {
      w.uint(1862465352);
      w.vector(w.object, h(v, "events"));
    },
    "help.getPassportConfig": function(w, v) {
      w.uint(3328290056);
      w.int(h(v, "hash"));
    },
    "help.getSupportName": function(w) {
      w.uint(3546343212);
    },
    "help.getUserInfo": function(w, v) {
      w.uint(59377875);
      w.object(h(v, "userId"));
    },
    "help.editUserInfo": function(w, v) {
      w.uint(1723407216);
      w.object(h(v, "userId"));
      w.string(h(v, "message"));
      w.vector(w.object, h(v, "entities"));
    },
    "help.getPromoData": function(w) {
      w.uint(3231151137);
    },
    "help.hidePromoData": function(w, v) {
      w.uint(505748629);
      w.object(h(v, "peer"));
    },
    "help.dismissSuggestion": function(w, v) {
      w.uint(4111317665);
      w.object(h(v, "peer"));
      w.string(h(v, "suggestion"));
    },
    "help.getCountriesList": function(w, v) {
      w.uint(1935116200);
      w.string(h(v, "langCode"));
      w.int(h(v, "hash"));
    },
    "help.getPremiumPromo": function(w) {
      w.uint(3088815060);
    },
    "help.getPeerColors": function(w, v) {
      w.uint(3665884207);
      w.int(h(v, "hash"));
    },
    "help.getPeerProfileColors": function(w, v) {
      w.uint(2882513405);
      w.int(h(v, "hash"));
    },
    "help.getTimezonesList": function(w, v) {
      w.uint(1236468288);
      w.int(h(v, "hash"));
    },
    "channels.readHistory": function(w, v) {
      w.uint(3423619383);
      w.object(h(v, "channel"));
      w.int(h(v, "maxId"));
    },
    "channels.deleteMessages": function(w, v) {
      w.uint(2227305806);
      w.object(h(v, "channel"));
      w.vector(w.int, h(v, "id"));
    },
    "channels.reportSpam": function(w, v) {
      w.uint(4098523925);
      w.object(h(v, "channel"));
      w.object(h(v, "participant"));
      w.vector(w.int, h(v, "id"));
    },
    "channels.getMessages": function(w, v) {
      w.uint(2911672867);
      w.object(h(v, "channel"));
      w.vector(w.object, h(v, "id"));
    },
    "channels.getParticipants": function(w, v) {
      w.uint(2010044880);
      w.object(h(v, "channel"));
      w.object(h(v, "filter"));
      w.int(h(v, "offset"));
      w.int(h(v, "limit"));
      w.long(h(v, "hash"));
    },
    "channels.getParticipant": function(w, v) {
      w.uint(2695589062);
      w.object(h(v, "channel"));
      w.object(h(v, "participant"));
    },
    "channels.getChannels": function(w, v) {
      w.uint(176122811);
      w.vector(w.object, h(v, "id"));
    },
    "channels.getFullChannel": function(w, v) {
      w.uint(141781513);
      w.object(h(v, "channel"));
    },
    "channels.createChannel": function(w, v) {
      w.uint(2432722695);
      var flags = 0;
      if (v.broadcast === true)
        flags |= 1;
      if (v.megagroup === true)
        flags |= 2;
      var _geoPoint = v.geoPoint !== void 0;
      var _address = v.address !== void 0;
      var _flags_2 = _geoPoint || _address;
      if (_flags_2)
        flags |= 4;
      if (v.forImport === true)
        flags |= 8;
      var _ttlPeriod = v.ttlPeriod !== void 0;
      if (_ttlPeriod)
        flags |= 16;
      if (v.forum === true)
        flags |= 32;
      w.uint(flags);
      w.string(h(v, "title"));
      w.string(h(v, "about"));
      if (_flags_2)
        w.object(v.geoPoint);
      if (_flags_2)
        w.string(v.address);
      if (_ttlPeriod)
        w.int(v.ttlPeriod);
    },
    "channels.editAdmin": function(w, v) {
      w.uint(3543959810);
      w.object(h(v, "channel"));
      w.object(h(v, "userId"));
      w.object(h(v, "adminRights"));
      w.string(h(v, "rank"));
    },
    "channels.editTitle": function(w, v) {
      w.uint(1450044624);
      w.object(h(v, "channel"));
      w.string(h(v, "title"));
    },
    "channels.editPhoto": function(w, v) {
      w.uint(4046346185);
      w.object(h(v, "channel"));
      w.object(h(v, "photo"));
    },
    "channels.checkUsername": function(w, v) {
      w.uint(283557164);
      w.object(h(v, "channel"));
      w.string(h(v, "username"));
    },
    "channels.updateUsername": function(w, v) {
      w.uint(890549214);
      w.object(h(v, "channel"));
      w.string(h(v, "username"));
    },
    "channels.joinChannel": function(w, v) {
      w.uint(615851205);
      w.object(h(v, "channel"));
    },
    "channels.leaveChannel": function(w, v) {
      w.uint(4164332181);
      w.object(h(v, "channel"));
    },
    "channels.inviteToChannel": function(w, v) {
      w.uint(3387112788);
      w.object(h(v, "channel"));
      w.vector(w.object, h(v, "users"));
    },
    "channels.deleteChannel": function(w, v) {
      w.uint(3222347747);
      w.object(h(v, "channel"));
    },
    "channels.exportMessageLink": function(w, v) {
      w.uint(3862932971);
      var flags = 0;
      if (v.grouped === true)
        flags |= 1;
      if (v.thread === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.int(h(v, "id"));
    },
    "channels.toggleSignatures": function(w, v) {
      w.uint(1099781276);
      var flags = 0;
      if (v.signaturesEnabled === true)
        flags |= 1;
      if (v.profilesEnabled === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "channel"));
    },
    "channels.getAdminedPublicChannels": function(w, v) {
      w.uint(4172297903);
      var flags = 0;
      if (v.byLocation === true)
        flags |= 1;
      if (v.checkLimit === true)
        flags |= 2;
      if (v.forPersonal === true)
        flags |= 4;
      w.uint(flags);
    },
    "channels.editBanned": function(w, v) {
      w.uint(2531708289);
      w.object(h(v, "channel"));
      w.object(h(v, "participant"));
      w.object(h(v, "bannedRights"));
    },
    "channels.getAdminLog": function(w, v) {
      w.uint(870184064);
      var flags = 0;
      var _eventsFilter = v.eventsFilter !== void 0;
      if (_eventsFilter)
        flags |= 1;
      var _admins = v.admins && v.admins.length;
      if (_admins)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.string(h(v, "q"));
      if (_eventsFilter)
        w.object(v.eventsFilter);
      if (_admins)
        w.vector(w.object, v.admins);
      w.long(h(v, "maxId"));
      w.long(h(v, "minId"));
      w.int(h(v, "limit"));
    },
    "channels.setStickers": function(w, v) {
      w.uint(3935085817);
      w.object(h(v, "channel"));
      w.object(h(v, "stickerset"));
    },
    "channels.readMessageContents": function(w, v) {
      w.uint(3937786936);
      w.object(h(v, "channel"));
      w.vector(w.int, h(v, "id"));
    },
    "channels.deleteHistory": function(w, v) {
      w.uint(2611648071);
      var flags = 0;
      if (v.forEveryone === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.int(h(v, "maxId"));
    },
    "channels.togglePreHistoryHidden": function(w, v) {
      w.uint(3938171212);
      w.object(h(v, "channel"));
      w.boolean(h(v, "enabled"));
    },
    "channels.getLeftChannels": function(w, v) {
      w.uint(2202135744);
      w.int(h(v, "offset"));
    },
    "channels.getGroupsForDiscussion": function(w) {
      w.uint(4124758904);
    },
    "channels.setDiscussionGroup": function(w, v) {
      w.uint(1079520178);
      w.object(h(v, "broadcast"));
      w.object(h(v, "group"));
    },
    "channels.editCreator": function(w, v) {
      w.uint(2402864415);
      w.object(h(v, "channel"));
      w.object(h(v, "userId"));
      w.object(h(v, "password"));
    },
    "channels.editLocation": function(w, v) {
      w.uint(1491484525);
      w.object(h(v, "channel"));
      w.object(h(v, "geoPoint"));
      w.string(h(v, "address"));
    },
    "channels.toggleSlowMode": function(w, v) {
      w.uint(3990134512);
      w.object(h(v, "channel"));
      w.int(h(v, "seconds"));
    },
    "channels.getInactiveChannels": function(w) {
      w.uint(300429806);
    },
    "channels.convertToGigagroup": function(w, v) {
      w.uint(187239529);
      w.object(h(v, "channel"));
    },
    "channels.viewSponsoredMessage": function(w, v) {
      w.uint(3199130516);
      w.object(h(v, "channel"));
      w.bytes(h(v, "randomId"));
    },
    "channels.getSponsoredMessages": function(w, v) {
      w.uint(3961589695);
      w.object(h(v, "channel"));
    },
    "channels.getSendAs": function(w, v) {
      w.uint(231174382);
      w.object(h(v, "peer"));
    },
    "channels.deleteParticipantHistory": function(w, v) {
      w.uint(913655003);
      w.object(h(v, "channel"));
      w.object(h(v, "participant"));
    },
    "channels.toggleJoinToSend": function(w, v) {
      w.uint(3838547328);
      w.object(h(v, "channel"));
      w.boolean(h(v, "enabled"));
    },
    "channels.toggleJoinRequest": function(w, v) {
      w.uint(1277789622);
      w.object(h(v, "channel"));
      w.boolean(h(v, "enabled"));
    },
    "channels.reorderUsernames": function(w, v) {
      w.uint(3025988893);
      w.object(h(v, "channel"));
      w.vector(w.string, h(v, "order"));
    },
    "channels.toggleUsername": function(w, v) {
      w.uint(1358053637);
      w.object(h(v, "channel"));
      w.string(h(v, "username"));
      w.boolean(h(v, "active"));
    },
    "channels.deactivateAllUsernames": function(w, v) {
      w.uint(170155475);
      w.object(h(v, "channel"));
    },
    "channels.toggleForum": function(w, v) {
      w.uint(2754186025);
      w.object(h(v, "channel"));
      w.boolean(h(v, "enabled"));
    },
    "channels.createForumTopic": function(w, v) {
      w.uint(4094427684);
      var flags = 0;
      var _iconColor = v.iconColor !== void 0;
      if (_iconColor)
        flags |= 1;
      var _sendAs = v.sendAs !== void 0;
      if (_sendAs)
        flags |= 4;
      var _iconEmojiId = v.iconEmojiId !== void 0;
      if (_iconEmojiId)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.string(h(v, "title"));
      if (_iconColor)
        w.int(v.iconColor);
      if (_iconEmojiId)
        w.long(v.iconEmojiId);
      w.long(h(v, "randomId"));
      if (_sendAs)
        w.object(v.sendAs);
    },
    "channels.getForumTopics": function(w, v) {
      w.uint(233136337);
      var flags = 0;
      var _q = v.q !== void 0;
      if (_q)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
      if (_q)
        w.string(v.q);
      w.int(h(v, "offsetDate"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "offsetTopic"));
      w.int(h(v, "limit"));
    },
    "channels.getForumTopicsByID": function(w, v) {
      w.uint(2961383097);
      w.object(h(v, "channel"));
      w.vector(w.int, h(v, "topics"));
    },
    "channels.editForumTopic": function(w, v) {
      w.uint(4108296581);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _iconEmojiId = v.iconEmojiId !== void 0;
      if (_iconEmojiId)
        flags |= 2;
      var _closed = v.closed !== void 0;
      if (_closed)
        flags |= 4;
      var _hidden = v.hidden !== void 0;
      if (_hidden)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.int(h(v, "topicId"));
      if (_title)
        w.string(v.title);
      if (_iconEmojiId)
        w.long(v.iconEmojiId);
      if (_closed)
        w.boolean(v.closed);
      if (_hidden)
        w.boolean(v.hidden);
    },
    "channels.updatePinnedForumTopic": function(w, v) {
      w.uint(1814925350);
      w.object(h(v, "channel"));
      w.int(h(v, "topicId"));
      w.boolean(h(v, "pinned"));
    },
    "channels.deleteTopicHistory": function(w, v) {
      w.uint(876830509);
      w.object(h(v, "channel"));
      w.int(h(v, "topMsgId"));
    },
    "channels.reorderPinnedForumTopics": function(w, v) {
      w.uint(693150095);
      var flags = 0;
      if (v.force === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.vector(w.int, h(v, "order"));
    },
    "channels.toggleAntiSpam": function(w, v) {
      w.uint(1760814315);
      w.object(h(v, "channel"));
      w.boolean(h(v, "enabled"));
    },
    "channels.reportAntiSpamFalsePositive": function(w, v) {
      w.uint(2823857811);
      w.object(h(v, "channel"));
      w.int(h(v, "msgId"));
    },
    "channels.toggleParticipantsHidden": function(w, v) {
      w.uint(1785624660);
      w.object(h(v, "channel"));
      w.boolean(h(v, "enabled"));
    },
    "channels.clickSponsoredMessage": function(w, v) {
      w.uint(21257589);
      var flags = 0;
      if (v.media === true)
        flags |= 1;
      if (v.fullscreen === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.bytes(h(v, "randomId"));
    },
    "channels.updateColor": function(w, v) {
      w.uint(3635033713);
      var flags = 0;
      var _backgroundEmojiId = v.backgroundEmojiId !== void 0;
      if (_backgroundEmojiId)
        flags |= 1;
      if (v.forProfile === true)
        flags |= 2;
      var _color = v.color !== void 0;
      if (_color)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "channel"));
      if (_color)
        w.int(v.color);
      if (_backgroundEmojiId)
        w.long(v.backgroundEmojiId);
    },
    "channels.toggleViewForumAsMessages": function(w, v) {
      w.uint(2537077525);
      w.object(h(v, "channel"));
      w.boolean(h(v, "enabled"));
    },
    "channels.getChannelRecommendations": function(w, v) {
      w.uint(631707458);
      var flags = 0;
      var _channel = v.channel !== void 0;
      if (_channel)
        flags |= 1;
      w.uint(flags);
      if (_channel)
        w.object(v.channel);
    },
    "channels.updateEmojiStatus": function(w, v) {
      w.uint(4040418984);
      w.object(h(v, "channel"));
      w.object(h(v, "emojiStatus"));
    },
    "channels.setBoostsToUnblockRestrictions": function(w, v) {
      w.uint(2906234094);
      w.object(h(v, "channel"));
      w.int(h(v, "boosts"));
    },
    "channels.setEmojiStickers": function(w, v) {
      w.uint(1020866743);
      w.object(h(v, "channel"));
      w.object(h(v, "stickerset"));
    },
    "channels.reportSponsoredMessage": function(w, v) {
      w.uint(2945447609);
      w.object(h(v, "channel"));
      w.bytes(h(v, "randomId"));
      w.bytes(h(v, "option"));
    },
    "channels.restrictSponsoredMessages": function(w, v) {
      w.uint(2598966553);
      w.object(h(v, "channel"));
      w.boolean(h(v, "restricted"));
    },
    "channels.searchPosts": function(w, v) {
      w.uint(3516897403);
      w.string(h(v, "hashtag"));
      w.int(h(v, "offsetRate"));
      w.object(h(v, "offsetPeer"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "limit"));
    },
    "bots.sendCustomRequest": function(w, v) {
      w.uint(2854709741);
      w.string(h(v, "customMethod"));
      w.object(h(v, "params"));
    },
    "bots.answerWebhookJSONQuery": function(w, v) {
      w.uint(3860938573);
      w.long(h(v, "queryId"));
      w.object(h(v, "data"));
    },
    "bots.setBotCommands": function(w, v) {
      w.uint(85399130);
      w.object(h(v, "scope"));
      w.string(h(v, "langCode"));
      w.vector(w.object, h(v, "commands"));
    },
    "bots.resetBotCommands": function(w, v) {
      w.uint(1032708345);
      w.object(h(v, "scope"));
      w.string(h(v, "langCode"));
    },
    "bots.getBotCommands": function(w, v) {
      w.uint(3813412310);
      w.object(h(v, "scope"));
      w.string(h(v, "langCode"));
    },
    "bots.setBotMenuButton": function(w, v) {
      w.uint(1157944655);
      w.object(h(v, "userId"));
      w.object(h(v, "button"));
    },
    "bots.getBotMenuButton": function(w, v) {
      w.uint(2623597352);
      w.object(h(v, "userId"));
    },
    "bots.setBotBroadcastDefaultAdminRights": function(w, v) {
      w.uint(2021942497);
      w.object(h(v, "adminRights"));
    },
    "bots.setBotGroupDefaultAdminRights": function(w, v) {
      w.uint(2455685610);
      w.object(h(v, "adminRights"));
    },
    "bots.setBotInfo": function(w, v) {
      w.uint(282013987);
      var flags = 0;
      var _about = v.about !== void 0;
      if (_about)
        flags |= 1;
      var _description = v.description !== void 0;
      if (_description)
        flags |= 2;
      var _bot = v.bot !== void 0;
      if (_bot)
        flags |= 4;
      var _name = v.name !== void 0;
      if (_name)
        flags |= 8;
      w.uint(flags);
      if (_bot)
        w.object(v.bot);
      w.string(h(v, "langCode"));
      if (_name)
        w.string(v.name);
      if (_about)
        w.string(v.about);
      if (_description)
        w.string(v.description);
    },
    "bots.getBotInfo": function(w, v) {
      w.uint(3705214205);
      var flags = 0;
      var _bot = v.bot !== void 0;
      if (_bot)
        flags |= 1;
      w.uint(flags);
      if (_bot)
        w.object(v.bot);
      w.string(h(v, "langCode"));
    },
    "bots.reorderUsernames": function(w, v) {
      w.uint(2533994946);
      w.object(h(v, "bot"));
      w.vector(w.string, h(v, "order"));
    },
    "bots.toggleUsername": function(w, v) {
      w.uint(87861619);
      w.object(h(v, "bot"));
      w.string(h(v, "username"));
      w.boolean(h(v, "active"));
    },
    "bots.canSendMessage": function(w, v) {
      w.uint(324662502);
      w.object(h(v, "bot"));
    },
    "bots.allowSendMessage": function(w, v) {
      w.uint(4046644207);
      w.object(h(v, "bot"));
    },
    "bots.invokeWebViewCustomMethod": function(w, v) {
      w.uint(142591463);
      w.object(h(v, "bot"));
      w.string(h(v, "customMethod"));
      w.object(h(v, "params"));
    },
    "bots.getPopularAppBots": function(w, v) {
      w.uint(3260088722);
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "bots.addPreviewMedia": function(w, v) {
      w.uint(397326170);
      w.object(h(v, "bot"));
      w.string(h(v, "langCode"));
      w.object(h(v, "media"));
    },
    "bots.editPreviewMedia": function(w, v) {
      w.uint(2233819247);
      w.object(h(v, "bot"));
      w.string(h(v, "langCode"));
      w.object(h(v, "media"));
      w.object(h(v, "newMedia"));
    },
    "bots.deletePreviewMedia": function(w, v) {
      w.uint(755054003);
      w.object(h(v, "bot"));
      w.string(h(v, "langCode"));
      w.vector(w.object, h(v, "media"));
    },
    "bots.reorderPreviewMedias": function(w, v) {
      w.uint(3056071594);
      w.object(h(v, "bot"));
      w.string(h(v, "langCode"));
      w.vector(w.object, h(v, "order"));
    },
    "bots.getPreviewInfo": function(w, v) {
      w.uint(1111143341);
      w.object(h(v, "bot"));
      w.string(h(v, "langCode"));
    },
    "bots.getPreviewMedias": function(w, v) {
      w.uint(2728745293);
      w.object(h(v, "bot"));
    },
    "payments.getPaymentForm": function(w, v) {
      w.uint(924093883);
      var flags = 0;
      var _themeParams = v.themeParams !== void 0;
      if (_themeParams)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "invoice"));
      if (_themeParams)
        w.object(v.themeParams);
    },
    "payments.getPaymentReceipt": function(w, v) {
      w.uint(611897804);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "payments.validateRequestedInfo": function(w, v) {
      w.uint(3066622251);
      var flags = 0;
      if (v.save === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "invoice"));
      w.object(h(v, "info"));
    },
    "payments.sendPaymentForm": function(w, v) {
      w.uint(755192367);
      var flags = 0;
      var _requestedInfoId = v.requestedInfoId !== void 0;
      if (_requestedInfoId)
        flags |= 1;
      var _shippingOptionId = v.shippingOptionId !== void 0;
      if (_shippingOptionId)
        flags |= 2;
      var _tipAmount = v.tipAmount !== void 0;
      if (_tipAmount)
        flags |= 4;
      w.uint(flags);
      w.long(h(v, "formId"));
      w.object(h(v, "invoice"));
      if (_requestedInfoId)
        w.string(v.requestedInfoId);
      if (_shippingOptionId)
        w.string(v.shippingOptionId);
      w.object(h(v, "credentials"));
      if (_tipAmount)
        w.long(v.tipAmount);
    },
    "payments.getSavedInfo": function(w) {
      w.uint(578650699);
    },
    "payments.clearSavedInfo": function(w, v) {
      w.uint(3627905217);
      var flags = 0;
      if (v.credentials === true)
        flags |= 1;
      if (v.info === true)
        flags |= 2;
      w.uint(flags);
    },
    "payments.getBankCardData": function(w, v) {
      w.uint(779736953);
      w.string(h(v, "number"));
    },
    "payments.exportInvoice": function(w, v) {
      w.uint(261206117);
      w.object(h(v, "invoiceMedia"));
    },
    "payments.assignAppStoreTransaction": function(w, v) {
      w.uint(2163045501);
      w.bytes(h(v, "receipt"));
      w.object(h(v, "purpose"));
    },
    "payments.assignPlayMarketTransaction": function(w, v) {
      w.uint(3757920467);
      w.object(h(v, "receipt"));
      w.object(h(v, "purpose"));
    },
    "payments.canPurchasePremium": function(w, v) {
      w.uint(2680266422);
      w.object(h(v, "purpose"));
    },
    "payments.getPremiumGiftCodeOptions": function(w, v) {
      w.uint(660060756);
      var flags = 0;
      var _boostPeer = v.boostPeer !== void 0;
      if (_boostPeer)
        flags |= 1;
      w.uint(flags);
      if (_boostPeer)
        w.object(v.boostPeer);
    },
    "payments.checkGiftCode": function(w, v) {
      w.uint(2387719361);
      w.string(h(v, "slug"));
    },
    "payments.applyGiftCode": function(w, v) {
      w.uint(4142032980);
      w.string(h(v, "slug"));
    },
    "payments.getGiveawayInfo": function(w, v) {
      w.uint(4095972389);
      w.object(h(v, "peer"));
      w.int(h(v, "msgId"));
    },
    "payments.launchPrepaidGiveaway": function(w, v) {
      w.uint(1609928480);
      w.object(h(v, "peer"));
      w.long(h(v, "giveawayId"));
      w.object(h(v, "purpose"));
    },
    "payments.getStarsTopupOptions": function(w) {
      w.uint(3222194131);
    },
    "payments.getStarsStatus": function(w, v) {
      w.uint(273665959);
      w.object(h(v, "peer"));
    },
    "payments.getStarsTransactions": function(w, v) {
      w.uint(1775912279);
      var flags = 0;
      if (v.inbound === true)
        flags |= 1;
      if (v.outbound === true)
        flags |= 2;
      if (v.ascending === true)
        flags |= 4;
      var _subscriptionId = v.subscriptionId !== void 0;
      if (_subscriptionId)
        flags |= 8;
      w.uint(flags);
      if (_subscriptionId)
        w.string(v.subscriptionId);
      w.object(h(v, "peer"));
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "payments.sendStarsForm": function(w, v) {
      w.uint(2040056084);
      w.long(h(v, "formId"));
      w.object(h(v, "invoice"));
    },
    "payments.refundStarsCharge": function(w, v) {
      w.uint(632196938);
      w.object(h(v, "userId"));
      w.string(h(v, "chargeId"));
    },
    "payments.getStarsRevenueStats": function(w, v) {
      w.uint(3642751702);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
    },
    "payments.getStarsRevenueWithdrawalUrl": function(w, v) {
      w.uint(331081907);
      w.object(h(v, "peer"));
      w.long(h(v, "stars"));
      w.object(h(v, "password"));
    },
    "payments.getStarsRevenueAdsAccountUrl": function(w, v) {
      w.uint(3520589765);
      w.object(h(v, "peer"));
    },
    "payments.getStarsTransactionsByID": function(w, v) {
      w.uint(662973742);
      w.object(h(v, "peer"));
      w.vector(w.object, h(v, "id"));
    },
    "payments.getStarsGiftOptions": function(w, v) {
      w.uint(3553192904);
      var flags = 0;
      var _userId = v.userId !== void 0;
      if (_userId)
        flags |= 1;
      w.uint(flags);
      if (_userId)
        w.object(v.userId);
    },
    "payments.getStarsSubscriptions": function(w, v) {
      w.uint(52761285);
      var flags = 0;
      if (v.missingBalance === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.string(h(v, "offset"));
    },
    "payments.changeStarsSubscription": function(w, v) {
      w.uint(3346466936);
      var flags = 0;
      var _canceled = v.canceled !== void 0;
      if (_canceled)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.string(h(v, "subscriptionId"));
      if (_canceled)
        w.boolean(v.canceled);
    },
    "payments.fulfillStarsSubscription": function(w, v) {
      w.uint(3428576179);
      w.object(h(v, "peer"));
      w.string(h(v, "subscriptionId"));
    },
    "payments.getStarsGiveawayOptions": function(w) {
      w.uint(3172924734);
    },
    "payments.getStarGifts": function(w, v) {
      w.uint(3293984144);
      w.int(h(v, "hash"));
    },
    "payments.getUserStarGifts": function(w, v) {
      w.uint(1584580577);
      w.object(h(v, "userId"));
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "payments.saveStarGift": function(w, v) {
      w.uint(2276257934);
      var flags = 0;
      if (v.unsave === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "userId"));
      w.int(h(v, "msgId"));
    },
    "payments.convertStarGift": function(w, v) {
      w.uint(69328935);
      w.object(h(v, "userId"));
      w.int(h(v, "msgId"));
    },
    "stickers.createStickerSet": function(w, v) {
      w.uint(2418125671);
      var flags = 0;
      if (v.masks === true)
        flags |= 1;
      var _thumb = v.thumb !== void 0;
      if (_thumb)
        flags |= 4;
      var _software = v.software !== void 0;
      if (_software)
        flags |= 8;
      if (v.emojis === true)
        flags |= 32;
      if (v.textColor === true)
        flags |= 64;
      w.uint(flags);
      w.object(h(v, "userId"));
      w.string(h(v, "title"));
      w.string(h(v, "shortName"));
      if (_thumb)
        w.object(v.thumb);
      w.vector(w.object, h(v, "stickers"));
      if (_software)
        w.string(v.software);
    },
    "stickers.removeStickerFromSet": function(w, v) {
      w.uint(4151709521);
      w.object(h(v, "sticker"));
    },
    "stickers.changeStickerPosition": function(w, v) {
      w.uint(4290172106);
      w.object(h(v, "sticker"));
      w.int(h(v, "position"));
    },
    "stickers.addStickerToSet": function(w, v) {
      w.uint(2253651646);
      w.object(h(v, "stickerset"));
      w.object(h(v, "sticker"));
    },
    "stickers.setStickerSetThumb": function(w, v) {
      w.uint(2808763282);
      var flags = 0;
      var _thumb = v.thumb !== void 0;
      if (_thumb)
        flags |= 1;
      var _thumbDocumentId = v.thumbDocumentId !== void 0;
      if (_thumbDocumentId)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "stickerset"));
      if (_thumb)
        w.object(v.thumb);
      if (_thumbDocumentId)
        w.long(v.thumbDocumentId);
    },
    "stickers.checkShortName": function(w, v) {
      w.uint(676017721);
      w.string(h(v, "shortName"));
    },
    "stickers.suggestShortName": function(w, v) {
      w.uint(1303364867);
      w.string(h(v, "title"));
    },
    "stickers.changeSticker": function(w, v) {
      w.uint(4115889852);
      var flags = 0;
      var _emoji = v.emoji !== void 0;
      if (_emoji)
        flags |= 1;
      var _maskCoords = v.maskCoords !== void 0;
      if (_maskCoords)
        flags |= 2;
      var _keywords = v.keywords !== void 0;
      if (_keywords)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "sticker"));
      if (_emoji)
        w.string(v.emoji);
      if (_maskCoords)
        w.object(v.maskCoords);
      if (_keywords)
        w.string(v.keywords);
    },
    "stickers.renameStickerSet": function(w, v) {
      w.uint(306912256);
      w.object(h(v, "stickerset"));
      w.string(h(v, "title"));
    },
    "stickers.deleteStickerSet": function(w, v) {
      w.uint(2272281492);
      w.object(h(v, "stickerset"));
    },
    "stickers.replaceSticker": function(w, v) {
      w.uint(1184253338);
      w.object(h(v, "sticker"));
      w.object(h(v, "newSticker"));
    },
    "phone.getCallConfig": function(w) {
      w.uint(1430593449);
    },
    "phone.requestCall": function(w, v) {
      w.uint(1124046573);
      var flags = 0;
      if (v.video === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "userId"));
      w.int(h(v, "randomId"));
      w.bytes(h(v, "gAHash"));
      w.object(h(v, "protocol"));
    },
    "phone.acceptCall": function(w, v) {
      w.uint(1003664544);
      w.object(h(v, "peer"));
      w.bytes(h(v, "gB"));
      w.object(h(v, "protocol"));
    },
    "phone.confirmCall": function(w, v) {
      w.uint(788404002);
      w.object(h(v, "peer"));
      w.bytes(h(v, "gA"));
      w.long(h(v, "keyFingerprint"));
      w.object(h(v, "protocol"));
    },
    "phone.receivedCall": function(w, v) {
      w.uint(399855457);
      w.object(h(v, "peer"));
    },
    "phone.discardCall": function(w, v) {
      w.uint(2999697856);
      var flags = 0;
      if (v.video === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "duration"));
      w.object(h(v, "reason"));
      w.long(h(v, "connectionId"));
    },
    "phone.setCallRating": function(w, v) {
      w.uint(1508562471);
      var flags = 0;
      if (v.userInitiative === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "rating"));
      w.string(h(v, "comment"));
    },
    "phone.saveCallDebug": function(w, v) {
      w.uint(662363518);
      w.object(h(v, "peer"));
      w.object(h(v, "debug"));
    },
    "phone.sendSignalingData": function(w, v) {
      w.uint(4286223235);
      w.object(h(v, "peer"));
      w.bytes(h(v, "data"));
    },
    "phone.createGroupCall": function(w, v) {
      w.uint(1221445336);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 1;
      var _scheduleDate = v.scheduleDate !== void 0;
      if (_scheduleDate)
        flags |= 2;
      if (v.rtmpStream === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "randomId"));
      if (_title)
        w.string(v.title);
      if (_scheduleDate)
        w.int(v.scheduleDate);
    },
    "phone.joinGroupCall": function(w, v) {
      w.uint(2972909435);
      var flags = 0;
      if (v.muted === true)
        flags |= 1;
      var _inviteHash = v.inviteHash !== void 0;
      if (_inviteHash)
        flags |= 2;
      if (v.videoStopped === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "call"));
      w.object(h(v, "joinAs"));
      if (_inviteHash)
        w.string(v.inviteHash);
      w.object(h(v, "params"));
    },
    "phone.leaveGroupCall": function(w, v) {
      w.uint(1342404601);
      w.object(h(v, "call"));
      w.int(h(v, "source"));
    },
    "phone.inviteToGroupCall": function(w, v) {
      w.uint(2067345760);
      w.object(h(v, "call"));
      w.vector(w.object, h(v, "users"));
    },
    "phone.discardGroupCall": function(w, v) {
      w.uint(2054648117);
      w.object(h(v, "call"));
    },
    "phone.toggleGroupCallSettings": function(w, v) {
      w.uint(1958458429);
      var flags = 0;
      var _joinMuted = v.joinMuted !== void 0;
      if (_joinMuted)
        flags |= 1;
      if (v.resetInviteHash === true)
        flags |= 2;
      w.uint(flags);
      w.object(h(v, "call"));
      if (_joinMuted)
        w.boolean(v.joinMuted);
    },
    "phone.getGroupCall": function(w, v) {
      w.uint(68699611);
      w.object(h(v, "call"));
      w.int(h(v, "limit"));
    },
    "phone.getGroupParticipants": function(w, v) {
      w.uint(3310934187);
      w.object(h(v, "call"));
      w.vector(w.object, h(v, "ids"));
      w.vector(w.int, h(v, "sources"));
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "phone.checkGroupCall": function(w, v) {
      w.uint(3046963575);
      w.object(h(v, "call"));
      w.vector(w.int, h(v, "sources"));
    },
    "phone.toggleGroupCallRecord": function(w, v) {
      w.uint(4045981448);
      var flags = 0;
      if (v.start === true)
        flags |= 1;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      var _videoPortrait = v.videoPortrait !== void 0;
      var _flags_2 = v.video === true || _videoPortrait;
      if (_flags_2)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "call"));
      if (_title)
        w.string(v.title);
      if (_flags_2)
        w.boolean(v.videoPortrait);
    },
    "phone.editGroupCallParticipant": function(w, v) {
      w.uint(2770811583);
      var flags = 0;
      var _muted = v.muted !== void 0;
      if (_muted)
        flags |= 1;
      var _volume = v.volume !== void 0;
      if (_volume)
        flags |= 2;
      var _raiseHand = v.raiseHand !== void 0;
      if (_raiseHand)
        flags |= 4;
      var _videoStopped = v.videoStopped !== void 0;
      if (_videoStopped)
        flags |= 8;
      var _videoPaused = v.videoPaused !== void 0;
      if (_videoPaused)
        flags |= 16;
      var _presentationPaused = v.presentationPaused !== void 0;
      if (_presentationPaused)
        flags |= 32;
      w.uint(flags);
      w.object(h(v, "call"));
      w.object(h(v, "participant"));
      if (_muted)
        w.boolean(v.muted);
      if (_volume)
        w.int(v.volume);
      if (_raiseHand)
        w.boolean(v.raiseHand);
      if (_videoStopped)
        w.boolean(v.videoStopped);
      if (_videoPaused)
        w.boolean(v.videoPaused);
      if (_presentationPaused)
        w.boolean(v.presentationPaused);
    },
    "phone.editGroupCallTitle": function(w, v) {
      w.uint(480685066);
      w.object(h(v, "call"));
      w.string(h(v, "title"));
    },
    "phone.getGroupCallJoinAs": function(w, v) {
      w.uint(4017889594);
      w.object(h(v, "peer"));
    },
    "phone.exportGroupCallInvite": function(w, v) {
      w.uint(3869926527);
      var flags = 0;
      if (v.canSelfUnmute === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "call"));
    },
    "phone.toggleGroupCallStartSubscription": function(w, v) {
      w.uint(563885286);
      w.object(h(v, "call"));
      w.boolean(h(v, "subscribed"));
    },
    "phone.startScheduledGroupCall": function(w, v) {
      w.uint(1451287362);
      w.object(h(v, "call"));
    },
    "phone.saveDefaultGroupCallJoinAs": function(w, v) {
      w.uint(1465786252);
      w.object(h(v, "peer"));
      w.object(h(v, "joinAs"));
    },
    "phone.joinGroupCallPresentation": function(w, v) {
      w.uint(3421137860);
      w.object(h(v, "call"));
      w.object(h(v, "params"));
    },
    "phone.leaveGroupCallPresentation": function(w, v) {
      w.uint(475058500);
      w.object(h(v, "call"));
    },
    "phone.getGroupCallStreamChannels": function(w, v) {
      w.uint(447879488);
      w.object(h(v, "call"));
    },
    "phone.getGroupCallStreamRtmpUrl": function(w, v) {
      w.uint(3736316863);
      w.object(h(v, "peer"));
      w.boolean(h(v, "revoke"));
    },
    "phone.saveCallLog": function(w, v) {
      w.uint(1092913030);
      w.object(h(v, "peer"));
      w.object(h(v, "file"));
    },
    "langpack.getLangPack": function(w, v) {
      w.uint(4075959050);
      w.string(h(v, "langPack"));
      w.string(h(v, "langCode"));
    },
    "langpack.getStrings": function(w, v) {
      w.uint(4025104387);
      w.string(h(v, "langPack"));
      w.string(h(v, "langCode"));
      w.vector(w.string, h(v, "keys"));
    },
    "langpack.getDifference": function(w, v) {
      w.uint(3449309861);
      w.string(h(v, "langPack"));
      w.string(h(v, "langCode"));
      w.int(h(v, "fromVersion"));
    },
    "langpack.getLanguages": function(w, v) {
      w.uint(1120311183);
      w.string(h(v, "langPack"));
    },
    "langpack.getLanguage": function(w, v) {
      w.uint(1784243458);
      w.string(h(v, "langPack"));
      w.string(h(v, "langCode"));
    },
    "folders.editPeerFolders": function(w, v) {
      w.uint(1749536939);
      w.vector(w.object, h(v, "folderPeers"));
    },
    "stats.getBroadcastStats": function(w, v) {
      w.uint(2873246746);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
    },
    "stats.loadAsyncGraph": function(w, v) {
      w.uint(1646092192);
      var flags = 0;
      var _x = v.x !== void 0;
      if (_x)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "token"));
      if (_x)
        w.long(v.x);
    },
    "stats.getMegagroupStats": function(w, v) {
      w.uint(3705636359);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
    },
    "stats.getMessagePublicForwards": function(w, v) {
      w.uint(1595212100);
      w.object(h(v, "channel"));
      w.int(h(v, "msgId"));
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "stats.getMessageStats": function(w, v) {
      w.uint(3068175349);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
      w.int(h(v, "msgId"));
    },
    "stats.getStoryStats": function(w, v) {
      w.uint(927985472);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
    },
    "stats.getStoryPublicForwards": function(w, v) {
      w.uint(2789441270);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "stats.getBroadcastRevenueStats": function(w, v) {
      w.uint(1977595505);
      var flags = 0;
      if (v.dark === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "channel"));
    },
    "stats.getBroadcastRevenueWithdrawalUrl": function(w, v) {
      w.uint(711323507);
      w.object(h(v, "channel"));
      w.object(h(v, "password"));
    },
    "stats.getBroadcastRevenueTransactions": function(w, v) {
      w.uint(6891535);
      w.object(h(v, "channel"));
      w.int(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "chatlists.exportChatlistInvite": function(w, v) {
      w.uint(2222081934);
      w.object(h(v, "chatlist"));
      w.string(h(v, "title"));
      w.vector(w.object, h(v, "peers"));
    },
    "chatlists.deleteExportedInvite": function(w, v) {
      w.uint(1906072670);
      w.object(h(v, "chatlist"));
      w.string(h(v, "slug"));
    },
    "chatlists.editExportedInvite": function(w, v) {
      w.uint(1698543165);
      var flags = 0;
      var _title = v.title !== void 0;
      if (_title)
        flags |= 2;
      var _peers = v.peers && v.peers.length;
      if (_peers)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "chatlist"));
      w.string(h(v, "slug"));
      if (_title)
        w.string(v.title);
      if (_peers)
        w.vector(w.object, v.peers);
    },
    "chatlists.getExportedInvites": function(w, v) {
      w.uint(3456359043);
      w.object(h(v, "chatlist"));
    },
    "chatlists.checkChatlistInvite": function(w, v) {
      w.uint(1103171583);
      w.string(h(v, "slug"));
    },
    "chatlists.joinChatlistInvite": function(w, v) {
      w.uint(2796675994);
      w.string(h(v, "slug"));
      w.vector(w.object, h(v, "peers"));
    },
    "chatlists.getChatlistUpdates": function(w, v) {
      w.uint(2302776609);
      w.object(h(v, "chatlist"));
    },
    "chatlists.joinChatlistUpdates": function(w, v) {
      w.uint(3767138549);
      w.object(h(v, "chatlist"));
      w.vector(w.object, h(v, "peers"));
    },
    "chatlists.hideChatlistUpdates": function(w, v) {
      w.uint(1726252795);
      w.object(h(v, "chatlist"));
    },
    "chatlists.getLeaveChatlistSuggestions": function(w, v) {
      w.uint(4257011476);
      w.object(h(v, "chatlist"));
    },
    "chatlists.leaveChatlist": function(w, v) {
      w.uint(1962598714);
      w.object(h(v, "chatlist"));
      w.vector(w.object, h(v, "peers"));
    },
    "stories.canSendStory": function(w, v) {
      w.uint(3353337821);
      w.object(h(v, "peer"));
    },
    "stories.sendStory": function(w, v) {
      w.uint(3840305483);
      var flags = 0;
      var _caption = v.caption !== void 0;
      if (_caption)
        flags |= 1;
      var _entities = v.entities && v.entities.length;
      if (_entities)
        flags |= 2;
      if (v.pinned === true)
        flags |= 4;
      var _period = v.period !== void 0;
      if (_period)
        flags |= 8;
      if (v.noforwards === true)
        flags |= 16;
      var _mediaAreas = v.mediaAreas && v.mediaAreas.length;
      if (_mediaAreas)
        flags |= 32;
      var _fwdFromId = v.fwdFromId !== void 0;
      var _fwdFromStory = v.fwdFromStory !== void 0;
      var _flags_6 = _fwdFromId || _fwdFromStory;
      if (_flags_6)
        flags |= 64;
      if (v.fwdModified === true)
        flags |= 128;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.object(h(v, "media"));
      if (_mediaAreas)
        w.vector(w.object, v.mediaAreas);
      if (_caption)
        w.string(v.caption);
      if (_entities)
        w.vector(w.object, v.entities);
      w.vector(w.object, h(v, "privacyRules"));
      w.long(h(v, "randomId"));
      if (_period)
        w.int(v.period);
      if (_flags_6)
        w.object(v.fwdFromId);
      if (_flags_6)
        w.int(v.fwdFromStory);
    },
    "stories.editStory": function(w, v) {
      w.uint(3045308998);
      var flags = 0;
      var _media = v.media !== void 0;
      if (_media)
        flags |= 1;
      var _caption = v.caption !== void 0;
      var _entities = v.entities && v.entities.length;
      var _flags_1 = _caption || _entities;
      if (_flags_1)
        flags |= 2;
      var _privacyRules = v.privacyRules && v.privacyRules.length;
      if (_privacyRules)
        flags |= 4;
      var _mediaAreas = v.mediaAreas && v.mediaAreas.length;
      if (_mediaAreas)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      if (_media)
        w.object(v.media);
      if (_mediaAreas)
        w.vector(w.object, v.mediaAreas);
      if (_flags_1)
        w.string(v.caption);
      if (_flags_1)
        w.vector(w.object, v.entities);
      if (_privacyRules)
        w.vector(w.object, v.privacyRules);
    },
    "stories.deleteStories": function(w, v) {
      w.uint(2925124447);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "stories.togglePinned": function(w, v) {
      w.uint(2591400431);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
      w.boolean(h(v, "pinned"));
    },
    "stories.getAllStories": function(w, v) {
      w.uint(4004566565);
      var flags = 0;
      var _state = v.state !== void 0;
      if (_state)
        flags |= 1;
      if (v.next === true)
        flags |= 2;
      if (v.hidden === true)
        flags |= 4;
      w.uint(flags);
      if (_state)
        w.string(v.state);
    },
    "stories.getPinnedStories": function(w, v) {
      w.uint(1478600156);
      w.object(h(v, "peer"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "limit"));
    },
    "stories.getStoriesArchive": function(w, v) {
      w.uint(3023380502);
      w.object(h(v, "peer"));
      w.int(h(v, "offsetId"));
      w.int(h(v, "limit"));
    },
    "stories.getStoriesByID": function(w, v) {
      w.uint(1467271796);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "stories.toggleAllStoriesHidden": function(w, v) {
      w.uint(2082822084);
      w.boolean(h(v, "hidden"));
    },
    "stories.readStories": function(w, v) {
      w.uint(2773932744);
      w.object(h(v, "peer"));
      w.int(h(v, "maxId"));
    },
    "stories.incrementStoryViews": function(w, v) {
      w.uint(2986511099);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "stories.getStoryViewsList": function(w, v) {
      w.uint(2127707223);
      var flags = 0;
      if (v.justContacts === true)
        flags |= 1;
      var _q = v.q !== void 0;
      if (_q)
        flags |= 2;
      if (v.reactionsFirst === true)
        flags |= 4;
      if (v.forwardsFirst === true)
        flags |= 8;
      w.uint(flags);
      w.object(h(v, "peer"));
      if (_q)
        w.string(v.q);
      w.int(h(v, "id"));
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "stories.getStoriesViews": function(w, v) {
      w.uint(685862088);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "stories.exportStoryLink": function(w, v) {
      w.uint(2072899360);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
    },
    "stories.report": function(w, v) {
      w.uint(433646405);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
      w.bytes(h(v, "option"));
      w.string(h(v, "message"));
    },
    "stories.activateStealthMode": function(w, v) {
      w.uint(1471926630);
      var flags = 0;
      if (v.past === true)
        flags |= 1;
      if (v.future === true)
        flags |= 2;
      w.uint(flags);
    },
    "stories.sendReaction": function(w, v) {
      w.uint(2144810674);
      var flags = 0;
      if (v.addToRecent === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "storyId"));
      w.object(h(v, "reaction"));
    },
    "stories.getPeerStories": function(w, v) {
      w.uint(743103056);
      w.object(h(v, "peer"));
    },
    "stories.getAllReadPeerStories": function(w) {
      w.uint(2606426105);
    },
    "stories.getPeerMaxIDs": function(w, v) {
      w.uint(1398375363);
      w.vector(w.object, h(v, "id"));
    },
    "stories.getChatsToSend": function(w) {
      w.uint(2775223136);
    },
    "stories.togglePeerStoriesHidden": function(w, v) {
      w.uint(3171161540);
      w.object(h(v, "peer"));
      w.boolean(h(v, "hidden"));
    },
    "stories.getStoryReactionsList": function(w, v) {
      w.uint(3115485215);
      var flags = 0;
      var _reaction = v.reaction !== void 0;
      if (_reaction)
        flags |= 1;
      var _offset = v.offset !== void 0;
      if (_offset)
        flags |= 2;
      if (v.forwardsFirst === true)
        flags |= 4;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.int(h(v, "id"));
      if (_reaction)
        w.object(v.reaction);
      if (_offset)
        w.string(v.offset);
      w.int(h(v, "limit"));
    },
    "stories.togglePinnedToTop": function(w, v) {
      w.uint(187268763);
      w.object(h(v, "peer"));
      w.vector(w.int, h(v, "id"));
    },
    "stories.searchPosts": function(w, v) {
      w.uint(1827279210);
      var flags = 0;
      var _hashtag = v.hashtag !== void 0;
      if (_hashtag)
        flags |= 1;
      var _area = v.area !== void 0;
      if (_area)
        flags |= 2;
      w.uint(flags);
      if (_hashtag)
        w.string(v.hashtag);
      if (_area)
        w.object(v.area);
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "premium.getBoostsList": function(w, v) {
      w.uint(1626764896);
      var flags = 0;
      if (v.gifts === true)
        flags |= 1;
      w.uint(flags);
      w.object(h(v, "peer"));
      w.string(h(v, "offset"));
      w.int(h(v, "limit"));
    },
    "premium.getMyBoosts": function(w) {
      w.uint(199719754);
    },
    "premium.applyBoost": function(w, v) {
      w.uint(1803396934);
      var flags = 0;
      var _slots = v.slots && v.slots.length;
      if (_slots)
        flags |= 1;
      w.uint(flags);
      if (_slots)
        w.vector(w.int, v.slots);
      w.object(h(v, "peer"));
    },
    "premium.getBoostsStatus": function(w, v) {
      w.uint(70197089);
      w.object(h(v, "peer"));
    },
    "premium.getUserBoosts": function(w, v) {
      w.uint(965037343);
      w.object(h(v, "peer"));
      w.object(h(v, "userId"));
    },
    "smsjobs.isEligibleToJoin": function(w) {
      w.uint(249313744);
    },
    "smsjobs.join": function(w) {
      w.uint(2806959661);
    },
    "smsjobs.leave": function(w) {
      w.uint(2560142707);
    },
    "smsjobs.updateSettings": function(w, v) {
      w.uint(155164863);
      var flags = 0;
      if (v.allowInternational === true)
        flags |= 1;
      w.uint(flags);
    },
    "smsjobs.getStatus": function(w) {
      w.uint(279353576);
    },
    "smsjobs.getSmsJob": function(w, v) {
      w.uint(2005766191);
      w.string(h(v, "jobId"));
    },
    "smsjobs.finishJob": function(w, v) {
      w.uint(1327415076);
      var flags = 0;
      var _error = v.error !== void 0;
      if (_error)
        flags |= 1;
      w.uint(flags);
      w.string(h(v, "jobId"));
      if (_error)
        w.string(v.error);
    },
    "fragment.getCollectibleInfo": function(w, v) {
      w.uint(3189671354);
      w.object(h(v, "collectible"));
    },
    "mtcute.customMethod": function(w, v) {
      w.raw(h(v, "bytes"));
    },
    "mt_resPQ": function(w, v) {
      w.uint(85337187);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.bytes(h(v, "pq"));
      w.vector(w.long, h(v, "serverPublicKeyFingerprints"));
    },
    "mt_p_q_inner_data_dc": function(w, v) {
      w.uint(2851430293);
      w.bytes(h(v, "pq"));
      w.bytes(h(v, "p"));
      w.bytes(h(v, "q"));
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.int256(h(v, "newNonce"));
      w.int(h(v, "dc"));
    },
    "mt_p_q_inner_data_temp_dc": function(w, v) {
      w.uint(1459478408);
      w.bytes(h(v, "pq"));
      w.bytes(h(v, "p"));
      w.bytes(h(v, "q"));
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.int256(h(v, "newNonce"));
      w.int(h(v, "dc"));
      w.int(h(v, "expiresIn"));
    },
    "mt_server_DH_params_ok": function(w, v) {
      w.uint(3504867164);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.bytes(h(v, "encryptedAnswer"));
    },
    "mt_server_DH_inner_data": function(w, v) {
      w.uint(3045658042);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.int(h(v, "g"));
      w.bytes(h(v, "dhPrime"));
      w.bytes(h(v, "gA"));
      w.int(h(v, "serverTime"));
    },
    "mt_client_DH_inner_data": function(w, v) {
      w.uint(1715713620);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.long(h(v, "retryId"));
      w.bytes(h(v, "gB"));
    },
    "mt_dh_gen_ok": function(w, v) {
      w.uint(1003222836);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.int128(h(v, "newNonceHash1"));
    },
    "mt_dh_gen_retry": function(w, v) {
      w.uint(1188831161);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.int128(h(v, "newNonceHash2"));
    },
    "mt_dh_gen_fail": function(w, v) {
      w.uint(2795351554);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.int128(h(v, "newNonceHash3"));
    },
    "mt_bind_auth_key_inner": function(w, v) {
      w.uint(1973679973);
      w.long(h(v, "nonce"));
      w.long(h(v, "tempAuthKeyId"));
      w.long(h(v, "permAuthKeyId"));
      w.long(h(v, "tempSessionId"));
      w.int(h(v, "expiresAt"));
    },
    "mt_rpc_error": function(w, v) {
      w.uint(558156313);
      w.int(h(v, "errorCode"));
      w.string(h(v, "errorMessage"));
    },
    "mt_rpc_answer_unknown": function(w) {
      w.uint(1579864942);
    },
    "mt_rpc_answer_dropped_running": function(w) {
      w.uint(3447252358);
    },
    "mt_rpc_answer_dropped": function(w, v) {
      w.uint(2755319991);
      w.long(h(v, "msgId"));
      w.int(h(v, "seqNo"));
      w.int(h(v, "bytes"));
    },
    "mt_future_salt": function(w, v) {
      w.uint(155834844);
      w.int(h(v, "validSince"));
      w.int(h(v, "validUntil"));
      w.long(h(v, "salt"));
    },
    "mt_future_salts": function(w, v) {
      w.uint(2924480661);
      w.long(h(v, "reqMsgId"));
      w.int(h(v, "now"));
      w.vector(m._bare[155834844], h(v, "salts"), 1);
    },
    "mt_pong": function(w, v) {
      w.uint(880243653);
      w.long(h(v, "msgId"));
      w.long(h(v, "pingId"));
    },
    "mt_destroy_session_ok": function(w, v) {
      w.uint(3793765884);
      w.long(h(v, "sessionId"));
    },
    "mt_destroy_session_none": function(w, v) {
      w.uint(1658015945);
      w.long(h(v, "sessionId"));
    },
    "mt_new_session_created": function(w, v) {
      w.uint(2663516424);
      w.long(h(v, "firstMsgId"));
      w.long(h(v, "uniqueId"));
      w.long(h(v, "serverSalt"));
    },
    "mt_msgs_ack": function(w, v) {
      w.uint(1658238041);
      w.vector(w.long, h(v, "msgIds"));
    },
    "mt_bad_msg_notification": function(w, v) {
      w.uint(2817521681);
      w.long(h(v, "badMsgId"));
      w.int(h(v, "badMsgSeqno"));
      w.int(h(v, "errorCode"));
    },
    "mt_bad_server_salt": function(w, v) {
      w.uint(3987424379);
      w.long(h(v, "badMsgId"));
      w.int(h(v, "badMsgSeqno"));
      w.int(h(v, "errorCode"));
      w.long(h(v, "newServerSalt"));
    },
    "mt_msg_resend_req": function(w, v) {
      w.uint(2105940488);
      w.vector(w.long, h(v, "msgIds"));
    },
    "mt_msgs_state_req": function(w, v) {
      w.uint(3664378706);
      w.vector(w.long, h(v, "msgIds"));
    },
    "mt_msgs_state_info": function(w, v) {
      w.uint(81704317);
      w.long(h(v, "reqMsgId"));
      w.bytes(h(v, "info"));
    },
    "mt_msgs_all_info": function(w, v) {
      w.uint(2361446705);
      w.vector(w.long, h(v, "msgIds"));
      w.bytes(h(v, "info"));
    },
    "mt_msg_detailed_info": function(w, v) {
      w.uint(661470918);
      w.long(h(v, "msgId"));
      w.long(h(v, "answerMsgId"));
      w.int(h(v, "bytes"));
      w.int(h(v, "status"));
    },
    "mt_msg_new_detailed_info": function(w, v) {
      w.uint(2157819615);
      w.long(h(v, "answerMsgId"));
      w.int(h(v, "bytes"));
      w.int(h(v, "status"));
    },
    "mt_destroy_auth_key_ok": function(w) {
      w.uint(4133544404);
    },
    "mt_destroy_auth_key_none": function(w) {
      w.uint(178201177);
    },
    "mt_destroy_auth_key_fail": function(w) {
      w.uint(3926956819);
    },
    "mt_http_wait": function(w, v) {
      w.uint(2459514271);
      w.int(h(v, "maxDelay"));
      w.int(h(v, "waitAfter"));
      w.int(h(v, "maxWait"));
    },
    "mt_req_pq_multi": function(w, v) {
      w.uint(3195965169);
      w.int128(h(v, "nonce"));
    },
    "mt_req_DH_params": function(w, v) {
      w.uint(3608339646);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.bytes(h(v, "p"));
      w.bytes(h(v, "q"));
      w.long(h(v, "publicKeyFingerprint"));
      w.bytes(h(v, "encryptedData"));
    },
    "mt_set_client_DH_params": function(w, v) {
      w.uint(4110704415);
      w.int128(h(v, "nonce"));
      w.int128(h(v, "serverNonce"));
      w.bytes(h(v, "encryptedData"));
    },
    "mt_rpc_drop_answer": function(w, v) {
      w.uint(1491380032);
      w.long(h(v, "reqMsgId"));
    },
    "mt_get_future_salts": function(w, v) {
      w.uint(3105996036);
      w.int(h(v, "num"));
    },
    "mt_ping": function(w, v) {
      w.uint(2059302892);
      w.long(h(v, "pingId"));
    },
    "mt_ping_delay_disconnect": function(w, v) {
      w.uint(4081220492);
      w.long(h(v, "pingId"));
      w.int(h(v, "disconnectDelay"));
    },
    "mt_destroy_session": function(w, v) {
      w.uint(3880853798);
      w.long(h(v, "sessionId"));
    },
    "mt_destroy_auth_key": function(w) {
      w.uint(3510849888);
    },
    _bare: {
      155834844: function(w = this, v) {
        w.int(h(v, "validSince"));
        w.int(h(v, "validUntil"));
        w.long(h(v, "salt"));
      }
    },
    _staticSize: {
      "ipPort": 12,
      "inputPeerEmpty": 4,
      "inputPeerSelf": 4,
      "inputPeerChat": 12,
      "inputPeerUser": 20,
      "inputPeerChannel": 20,
      "inputUserEmpty": 4,
      "inputUserSelf": 4,
      "inputUser": 20,
      "inputMediaEmpty": 4,
      "inputChatPhotoEmpty": 4,
      "inputGeoPointEmpty": 4,
      "inputPhotoEmpty": 4,
      "inputEncryptedFileLocation": 20,
      "inputSecureFileLocation": 20,
      "inputTakeoutFileLocation": 4,
      "peerUser": 12,
      "peerChat": 12,
      "peerChannel": 12,
      "storage.fileUnknown": 4,
      "storage.filePartial": 4,
      "storage.fileJpeg": 4,
      "storage.fileGif": 4,
      "storage.filePng": 4,
      "storage.filePdf": 4,
      "storage.fileMp3": 4,
      "storage.fileMov": 4,
      "storage.fileMp4": 4,
      "storage.fileWebp": 4,
      "userEmpty": 12,
      "userProfilePhotoEmpty": 4,
      "userStatusEmpty": 4,
      "userStatusOnline": 8,
      "userStatusOffline": 8,
      "userStatusRecently": 8,
      "userStatusLastWeek": 8,
      "userStatusLastMonth": 8,
      "chatEmpty": 12,
      "chatParticipant": 24,
      "chatParticipantCreator": 12,
      "chatParticipantAdmin": 24,
      "chatPhotoEmpty": 4,
      "messageMediaEmpty": 4,
      "messageMediaUnsupported": 4,
      "messageActionEmpty": 4,
      "messageActionChatDeletePhoto": 4,
      "messageActionChatDeleteUser": 12,
      "messageActionChatJoinedByLink": 12,
      "messageActionChatMigrateTo": 12,
      "messageActionPinMessage": 4,
      "messageActionHistoryClear": 4,
      "messageActionGameScore": 16,
      "messageActionScreenshotTaken": 4,
      "messageActionContactSignUp": 4,
      "messageActionGeoProximityReached": 32,
      "messageActionChatJoinedByRequest": 4,
      "messageActionGiveawayResults": 16,
      "messageActionBoostApply": 8,
      "photoEmpty": 12,
      "geoPointEmpty": 4,
      "inputNotifyUsers": 4,
      "inputNotifyChats": 4,
      "inputNotifyBroadcasts": 4,
      "inputReportReasonSpam": 4,
      "inputReportReasonViolence": 4,
      "inputReportReasonPornography": 4,
      "inputReportReasonChildAbuse": 4,
      "inputReportReasonOther": 4,
      "inputReportReasonCopyright": 4,
      "inputReportReasonGeoIrrelevant": 4,
      "inputReportReasonFake": 4,
      "inputReportReasonIllegalDrugs": 4,
      "inputReportReasonPersonalDetails": 4,
      "contact": 16,
      "importedContact": 20,
      "contacts.contactsNotModified": 4,
      "messages.dialogsNotModified": 8,
      "messages.messagesNotModified": 8,
      "messages.affectedHistory": 16,
      "inputMessagesFilterEmpty": 4,
      "inputMessagesFilterPhotos": 4,
      "inputMessagesFilterVideo": 4,
      "inputMessagesFilterPhotoVideo": 4,
      "inputMessagesFilterDocument": 4,
      "inputMessagesFilterUrl": 4,
      "inputMessagesFilterGif": 4,
      "inputMessagesFilterVoice": 4,
      "inputMessagesFilterMusic": 4,
      "inputMessagesFilterChatPhotos": 4,
      "inputMessagesFilterPhoneCalls": 8,
      "inputMessagesFilterRoundVoice": 4,
      "inputMessagesFilterRoundVideo": 4,
      "inputMessagesFilterMyMentions": 4,
      "inputMessagesFilterGeo": 4,
      "inputMessagesFilterContacts": 4,
      "inputMessagesFilterPinned": 4,
      "updateMessageID": 16,
      "updateEncryptedChatTyping": 8,
      "updateEncryptedMessagesRead": 16,
      "updateChatParticipantAdd": 36,
      "updateChatParticipantDelete": 24,
      "updateReadHistoryOutbox": 28,
      "updateChannel": 12,
      "updateChannelMessageViews": 20,
      "updateChatParticipantAdmin": 28,
      "updateStickerSets": 8,
      "updateSavedGifs": 4,
      "updateReadChannelOutbox": 16,
      "updateReadFeaturedStickers": 4,
      "updateRecentStickers": 4,
      "updateConfig": 4,
      "updatePtsChanged": 4,
      "updateFavedStickers": 4,
      "updateContactsReset": 4,
      "updateChannelAvailableMessages": 16,
      "updateGeoLiveViewed": 20,
      "updateLoginToken": 4,
      "updateDialogFilters": 4,
      "updateChannelMessageForwards": 20,
      "updateReadChannelDiscussionOutbox": 20,
      "updatePeerBlocked": 20,
      "updateChat": 12,
      "updateBotStopped": 24,
      "updateAttachMenuBots": 4,
      "updateWebViewResultSent": 12,
      "updateSavedRingtones": 4,
      "updateReadFeaturedEmojiStickers": 4,
      "updateRecentEmojiStatuses": 4,
      "updateRecentReactions": 4,
      "updateMoveStickerSetToTop": 16,
      "updateChannelPinnedTopic": 20,
      "updateUser": 12,
      "updateAutoSaveSettings": 4,
      "updateReadStories": 20,
      "updateStoryID": 16,
      "updateChannelViewForumAsMessages": 16,
      "updateSavedReactionTags": 4,
      "updateDeleteQuickReply": 8,
      "updateStarsBalance": 12,
      "updatePaidReactionPrivacy": 8,
      "updates.state": 24,
      "updates.differenceEmpty": 12,
      "updates.differenceTooLong": 8,
      "updatesTooLong": 4,
      "help.noAppUpdate": 4,
      "encryptedChatEmpty": 8,
      "encryptedChatWaiting": 36,
      "encryptedChatDiscarded": 12,
      "inputEncryptedChat": 16,
      "encryptedFileEmpty": 4,
      "encryptedFile": 36,
      "inputEncryptedFileEmpty": 4,
      "inputEncryptedFile": 20,
      "inputEncryptedFileBigUploaded": 20,
      "messages.sentEncryptedMessage": 8,
      "inputDocumentEmpty": 4,
      "documentEmpty": 12,
      "notifyPeer": 16,
      "notifyUsers": 4,
      "notifyChats": 4,
      "notifyBroadcasts": 4,
      "notifyForumTopic": 20,
      "sendMessageTypingAction": 4,
      "sendMessageCancelAction": 4,
      "sendMessageRecordVideoAction": 4,
      "sendMessageUploadVideoAction": 8,
      "sendMessageRecordAudioAction": 4,
      "sendMessageUploadAudioAction": 8,
      "sendMessageUploadPhotoAction": 8,
      "sendMessageUploadDocumentAction": 8,
      "sendMessageGeoLocationAction": 4,
      "sendMessageChooseContactAction": 4,
      "sendMessageGamePlayAction": 4,
      "sendMessageRecordRoundAction": 4,
      "sendMessageUploadRoundAction": 8,
      "speakingInGroupCallAction": 4,
      "sendMessageHistoryImportAction": 8,
      "sendMessageChooseStickerAction": 4,
      "inputPrivacyKeyStatusTimestamp": 4,
      "inputPrivacyKeyChatInvite": 4,
      "inputPrivacyKeyPhoneCall": 4,
      "inputPrivacyKeyPhoneP2P": 4,
      "inputPrivacyKeyForwards": 4,
      "inputPrivacyKeyProfilePhoto": 4,
      "inputPrivacyKeyPhoneNumber": 4,
      "inputPrivacyKeyAddedByPhone": 4,
      "inputPrivacyKeyVoiceMessages": 4,
      "inputPrivacyKeyAbout": 4,
      "inputPrivacyKeyBirthday": 4,
      "privacyKeyStatusTimestamp": 4,
      "privacyKeyChatInvite": 4,
      "privacyKeyPhoneCall": 4,
      "privacyKeyPhoneP2P": 4,
      "privacyKeyForwards": 4,
      "privacyKeyProfilePhoto": 4,
      "privacyKeyPhoneNumber": 4,
      "privacyKeyAddedByPhone": 4,
      "privacyKeyVoiceMessages": 4,
      "privacyKeyAbout": 4,
      "privacyKeyBirthday": 4,
      "inputPrivacyValueAllowContacts": 4,
      "inputPrivacyValueAllowAll": 4,
      "inputPrivacyValueDisallowContacts": 4,
      "inputPrivacyValueDisallowAll": 4,
      "inputPrivacyValueAllowCloseFriends": 4,
      "inputPrivacyValueAllowPremium": 4,
      "privacyValueAllowContacts": 4,
      "privacyValueAllowAll": 4,
      "privacyValueDisallowContacts": 4,
      "privacyValueDisallowAll": 4,
      "privacyValueAllowCloseFriends": 4,
      "privacyValueAllowPremium": 4,
      "accountDaysTTL": 8,
      "documentAttributeImageSize": 12,
      "documentAttributeAnimated": 4,
      "documentAttributeHasStickers": 4,
      "messages.stickersNotModified": 4,
      "messages.allStickersNotModified": 4,
      "messages.affectedMessages": 12,
      "receivedNotifyMessage": 12,
      "chatInvitePublicJoinRequests": 4,
      "inputStickerSetEmpty": 4,
      "inputStickerSetID": 20,
      "inputStickerSetAnimatedEmoji": 4,
      "inputStickerSetAnimatedEmojiAnimations": 4,
      "inputStickerSetPremiumGifts": 4,
      "inputStickerSetEmojiGenericAnimations": 4,
      "inputStickerSetEmojiDefaultStatuses": 4,
      "inputStickerSetEmojiDefaultTopicIcons": 4,
      "inputStickerSetEmojiChannelDefaultStatuses": 4,
      "messages.stickerSetNotModified": 4,
      "replyKeyboardHide": 8,
      "messageEntityUnknown": 12,
      "messageEntityMention": 12,
      "messageEntityHashtag": 12,
      "messageEntityBotCommand": 12,
      "messageEntityUrl": 12,
      "messageEntityEmail": 12,
      "messageEntityBold": 12,
      "messageEntityItalic": 12,
      "messageEntityCode": 12,
      "messageEntityMentionName": 20,
      "messageEntityPhone": 12,
      "messageEntityCashtag": 12,
      "messageEntityUnderline": 12,
      "messageEntityStrike": 12,
      "messageEntityBankCard": 12,
      "messageEntitySpoiler": 12,
      "messageEntityCustomEmoji": 20,
      "messageEntityBlockquote": 16,
      "inputChannelEmpty": 4,
      "inputChannel": 20,
      "messageRange": 12,
      "channelMessagesFilterEmpty": 4,
      "channelParticipantLeft": 16,
      "channelParticipantsRecent": 4,
      "channelParticipantsAdmins": 4,
      "channelParticipantsBots": 4,
      "channels.channelParticipantsNotModified": 4,
      "messages.savedGifsNotModified": 4,
      "auth.codeTypeSms": 4,
      "auth.codeTypeCall": 4,
      "auth.codeTypeFlashCall": 4,
      "auth.codeTypeMissedCall": 4,
      "auth.codeTypeFragmentSms": 4,
      "auth.sentCodeTypeApp": 8,
      "auth.sentCodeTypeSms": 8,
      "auth.sentCodeTypeCall": 8,
      "auth.sentCodeTypeSetUpEmailRequired": 8,
      "messages.messageEditData": 8,
      "inputBotInlineMessageID": 24,
      "inputBotInlineMessageID64": 28,
      "topPeer": 24,
      "topPeerCategoryBotsPM": 4,
      "topPeerCategoryBotsInline": 4,
      "topPeerCategoryCorrespondents": 4,
      "topPeerCategoryGroups": 4,
      "topPeerCategoryChannels": 4,
      "topPeerCategoryPhoneCalls": 4,
      "topPeerCategoryForwardUsers": 4,
      "topPeerCategoryForwardChats": 4,
      "topPeerCategoryBotsApp": 4,
      "contacts.topPeersNotModified": 4,
      "contacts.topPeersDisabled": 4,
      "messages.featuredStickersNotModified": 8,
      "messages.recentStickersNotModified": 4,
      "messages.stickerSetInstallResultSuccess": 4,
      "maskCoords": 32,
      "inputGameID": 20,
      "highScore": 20,
      "textEmpty": 4,
      "textImage": 20,
      "pageBlockUnsupported": 4,
      "pageBlockDivider": 4,
      "phoneCallDiscardReasonMissed": 4,
      "phoneCallDiscardReasonDisconnect": 4,
      "phoneCallDiscardReasonHangup": 4,
      "phoneCallDiscardReasonBusy": 4,
      "inputPhoneCall": 20,
      "phoneCallEmpty": 12,
      "channelAdminLogEventActionToggleInvites": 8,
      "channelAdminLogEventActionToggleSignatures": 8,
      "channelAdminLogEventActionParticipantJoin": 4,
      "channelAdminLogEventActionParticipantLeave": 4,
      "channelAdminLogEventActionTogglePreHistoryHidden": 8,
      "channelAdminLogEventActionChangeLinkedChat": 20,
      "channelAdminLogEventActionToggleSlowMode": 12,
      "channelAdminLogEventActionToggleGroupCallSetting": 8,
      "channelAdminLogEventActionChangeHistoryTTL": 12,
      "channelAdminLogEventActionToggleNoForwards": 8,
      "channelAdminLogEventActionToggleForum": 8,
      "channelAdminLogEventActionToggleAntiSpam": 8,
      "channelAdminLogEventActionToggleSignatureProfiles": 8,
      "channelAdminLogEventsFilter": 8,
      "popularContact": 16,
      "messages.favedStickersNotModified": 4,
      "inputMessageID": 8,
      "inputMessageReplyTo": 8,
      "inputMessagePinned": 4,
      "inputMessageCallbackQuery": 16,
      "inputDialogPeerFolder": 8,
      "dialogPeer": 16,
      "dialogPeerFolder": 8,
      "messages.foundStickerSetsNotModified": 4,
      "help.termsOfServiceUpdateEmpty": 8,
      "inputSecureFile": 20,
      "secureFileEmpty": 4,
      "secureValueTypePersonalDetails": 4,
      "secureValueTypePassport": 4,
      "secureValueTypeDriverLicense": 4,
      "secureValueTypeIdentityCard": 4,
      "secureValueTypeInternalPassport": 4,
      "secureValueTypeAddress": 4,
      "secureValueTypeUtilityBill": 4,
      "secureValueTypeBankStatement": 4,
      "secureValueTypeRentalAgreement": 4,
      "secureValueTypePassportRegistration": 4,
      "secureValueTypeTemporaryRegistration": 4,
      "secureValueTypePhone": 4,
      "secureValueTypeEmail": 4,
      "help.deepLinkInfoEmpty": 4,
      "account.takeout": 12,
      "passwordKdfAlgoUnknown": 4,
      "securePasswordKdfAlgoUnknown": 4,
      "inputCheckPasswordEmpty": 4,
      "secureRequiredType": 12,
      "help.passportConfigNotModified": 4,
      "jsonNull": 4,
      "jsonBool": 8,
      "jsonNumber": 12,
      "help.userInfoEmpty": 4,
      "chatOnlines": 8,
      "chatAdminRights": 8,
      "chatBannedRights": 12,
      "inputWallPaper": 20,
      "inputWallPaperNoFile": 12,
      "account.wallPapersNotModified": 4,
      "autoDownloadSettings": 40,
      "account.autoDownloadSettings": 124,
      "folderPeer": 20,
      "urlAuthResultDefault": 4,
      "channelLocationEmpty": 4,
      "peerLocated": 24,
      "peerSelfLocated": 8,
      "inputTheme": 20,
      "account.themesNotModified": 4,
      "account.contentSettings": 8,
      "baseThemeClassic": 4,
      "baseThemeDay": 4,
      "baseThemeNight": 4,
      "baseThemeTinted": 4,
      "baseThemeArctic": 4,
      "dialogFilterDefault": 4,
      "statsDateRangeDays": 12,
      "statsAbsValueAndPrev": 20,
      "statsPercentValue": 20,
      "help.promoDataEmpty": 8,
      "statsGroupTopPoster": 20,
      "statsGroupTopAdmin": 24,
      "statsGroupTopInviter": 16,
      "globalPrivacySettings": 8,
      "help.countriesListNotModified": 4,
      "messageReplyStoryHeader": 20,
      "peerBlocked": 20,
      "groupCallDiscarded": 24,
      "inputGroupCall": 20,
      "inlineQueryPeerTypeSameBotPM": 4,
      "inlineQueryPeerTypePM": 4,
      "inlineQueryPeerTypeChat": 4,
      "inlineQueryPeerTypeMegagroup": 4,
      "inlineQueryPeerTypeBroadcast": 4,
      "inlineQueryPeerTypeBotPM": 4,
      "messages.historyImport": 12,
      "chatAdminWithInvites": 20,
      "botCommandScopeDefault": 4,
      "botCommandScopeUsers": 4,
      "botCommandScopeChats": 4,
      "botCommandScopeChatAdmins": 4,
      "account.resetPasswordFailedWait": 8,
      "account.resetPasswordRequestedWait": 8,
      "account.resetPasswordOk": 4,
      "messages.sponsoredMessagesEmpty": 4,
      "searchResultsCalendarPeriod": 20,
      "searchResultPosition": 16,
      "messages.availableReactionsNotModified": 4,
      "groupCallStreamChannel": 20,
      "attachMenuBotsNotModified": 4,
      "botMenuButtonDefault": 4,
      "botMenuButtonCommands": 4,
      "account.savedRingtonesNotModified": 4,
      "notificationSoundDefault": 4,
      "notificationSoundNone": 4,
      "notificationSoundRingtone": 12,
      "account.savedRingtone": 4,
      "attachMenuPeerTypeSameBotPM": 4,
      "attachMenuPeerTypeBotPM": 4,
      "attachMenuPeerTypePM": 4,
      "attachMenuPeerTypeChat": 4,
      "attachMenuPeerTypeBroadcast": 4,
      "inputStorePaymentPremiumSubscription": 8,
      "emojiStatusEmpty": 4,
      "emojiStatus": 12,
      "emojiStatusUntil": 16,
      "account.emojiStatusesNotModified": 4,
      "reactionEmpty": 4,
      "reactionCustomEmoji": 12,
      "reactionPaid": 4,
      "chatReactionsNone": 4,
      "chatReactionsAll": 8,
      "messages.reactionsNotModified": 4,
      "emailVerifyPurposeLoginChange": 4,
      "emailVerifyPurposePassport": 4,
      "sendAsPeer": 20,
      "forumTopicDeleted": 8,
      "defaultHistoryTTL": 8,
      "emojiListNotModified": 4,
      "messages.emojiGroupsNotModified": 4,
      "help.appConfigNotModified": 4,
      "inputBotAppID": 20,
      "botAppNotModified": 4,
      "readParticipantDate": 16,
      "inputChatlistDialogFilter": 8,
      "messagePeerVoteInputOption": 20,
      "storyItemDeleted": 8,
      "storyItemSkipped": 20,
      "prepaidGiveaway": 24,
      "prepaidStarsGiveaway": 32,
      "postInteractionCountersMessage": 20,
      "postInteractionCountersStory": 20,
      "help.peerColorsNotModified": 4,
      "savedDialog": 24,
      "messages.savedDialogsNotModified": 8,
      "messages.savedReactionTagsNotModified": 4,
      "outboxReadDate": 8,
      "businessWeeklyOpen": 12,
      "businessAwayMessageScheduleAlways": 4,
      "businessAwayMessageScheduleOutsideWorkHours": 4,
      "businessAwayMessageScheduleCustom": 12,
      "help.timezonesListNotModified": 4,
      "inputQuickReplyShortcutId": 8,
      "messages.quickRepliesNotModified": 4,
      "missingInvitee": 16,
      "channels.sponsoredMessageReportResultAdsHidden": 4,
      "channels.sponsoredMessageReportResultReported": 4,
      "broadcastRevenueTransactionProceeds": 20,
      "reactionNotificationsFromContacts": 4,
      "reactionNotificationsFromAll": 4,
      "broadcastRevenueBalances": 32,
      "messages.availableEffectsNotModified": 4,
      "starsTransactionPeerUnsupported": 4,
      "starsTransactionPeerAppStore": 4,
      "starsTransactionPeerPlayMarket": 4,
      "starsTransactionPeerPremiumBot": 4,
      "starsTransactionPeerFragment": 4,
      "starsTransactionPeer": 16,
      "starsTransactionPeerAds": 4,
      "starsSubscriptionPricing": 16,
      "starsGiveawayWinnersOption": 20,
      "payments.starGiftsNotModified": 4,
      "reportResultReported": 4,
      "test.useConfigSimple": 4,
      "test.parseInputAppEvent": 4,
      "auth.logOut": 4,
      "auth.resetAuthorizations": 4,
      "auth.exportAuthorization": 8,
      "auth.requestPasswordRecovery": 4,
      "account.resetNotifySettings": 4,
      "account.updateStatus": 8,
      "account.getWallPapers": 12,
      "account.getPrivacy": 8,
      "account.getAccountTTL": 4,
      "account.setAccountTTL": 12,
      "account.updateDeviceLocked": 8,
      "account.getAuthorizations": 4,
      "account.resetAuthorization": 12,
      "account.getPassword": 4,
      "account.getWebAuthorizations": 4,
      "account.resetWebAuthorization": 12,
      "account.resetWebAuthorizations": 4,
      "account.getAllSecureValues": 4,
      "account.finishTakeoutSession": 8,
      "account.resendPasswordEmail": 4,
      "account.cancelPasswordEmail": 4,
      "account.getContactSignUpNotification": 4,
      "account.setContactSignUpNotification": 8,
      "account.resetWallPapers": 4,
      "account.getAutoDownloadSettings": 4,
      "account.saveAutoDownloadSettings": 48,
      "account.setContentSettings": 8,
      "account.getContentSettings": 4,
      "account.getGlobalPrivacySettings": 4,
      "account.setGlobalPrivacySettings": 12,
      "account.resetPassword": 4,
      "account.declinePasswordReset": 4,
      "account.getChatThemes": 12,
      "account.setAuthorizationTTL": 8,
      "account.getSavedRingtones": 12,
      "account.getDefaultEmojiStatuses": 12,
      "account.getRecentEmojiStatuses": 12,
      "account.clearRecentEmojiStatuses": 4,
      "account.getDefaultProfilePhotoEmojis": 12,
      "account.getDefaultGroupPhotoEmojis": 12,
      "account.getAutoSaveSettings": 4,
      "account.deleteAutoSaveExceptions": 4,
      "account.getDefaultBackgroundEmojis": 12,
      "account.getChannelDefaultEmojiStatuses": 12,
      "account.getChannelRestrictedStatusEmojis": 12,
      "account.getConnectedBots": 4,
      "account.getBusinessChatLinks": 4,
      "account.toggleSponsoredMessages": 8,
      "account.getReactionsNotifySettings": 4,
      "contacts.getContactIDs": 12,
      "contacts.getStatuses": 4,
      "contacts.getContacts": 12,
      "contacts.getBlocked": 16,
      "contacts.getTopPeers": 24,
      "contacts.resetSaved": 4,
      "contacts.getSaved": 4,
      "contacts.toggleTopPeers": 8,
      "contacts.blockFromReplies": 12,
      "contacts.exportContactToken": 4,
      "contacts.getBirthdays": 4,
      "messages.receivedMessages": 8,
      "messages.getFullChat": 12,
      "messages.getDhConfig": 12,
      "messages.discardEncryption": 12,
      "messages.setEncryptedTyping": 24,
      "messages.readEncryptedHistory": 24,
      "messages.receivedQueue": 8,
      "messages.reportEncryptedSpam": 20,
      "messages.getAllStickers": 12,
      "messages.migrateChat": 12,
      "messages.getSavedGifs": 12,
      "messages.getAllDrafts": 4,
      "messages.getFeaturedStickers": 12,
      "messages.getRecentStickers": 16,
      "messages.clearRecentStickers": 8,
      "messages.getArchivedStickers": 20,
      "messages.getMaskStickers": 12,
      "messages.getPinnedDialogs": 8,
      "messages.getFavedStickers": 12,
      "messages.getSplitRanges": 4,
      "messages.getDialogUnreadMarks": 4,
      "messages.clearAllDrafts": 4,
      "messages.getDialogFilters": 4,
      "messages.getSuggestedDialogFilters": 4,
      "messages.getOldFeaturedStickers": 20,
      "messages.deleteChat": 12,
      "messages.deletePhoneCallHistory": 8,
      "messages.getAvailableReactions": 8,
      "messages.getAttachMenuBots": 12,
      "messages.getEmojiStickers": 12,
      "messages.getFeaturedEmojiStickers": 12,
      "messages.getTopReactions": 16,
      "messages.getRecentReactions": 16,
      "messages.clearRecentReactions": 4,
      "messages.setDefaultHistoryTTL": 8,
      "messages.getDefaultHistoryTTL": 4,
      "messages.getEmojiGroups": 8,
      "messages.getEmojiStatusGroups": 8,
      "messages.getEmojiProfilePhotoGroups": 8,
      "messages.getPinnedSavedDialogs": 4,
      "messages.getDefaultTagReactions": 12,
      "messages.getQuickReplies": 12,
      "messages.deleteQuickReplyShortcut": 8,
      "messages.toggleDialogFilterTags": 8,
      "messages.getMyStickers": 16,
      "messages.getEmojiStickerGroups": 8,
      "messages.getAvailableEffects": 8,
      "messages.getPaidReactionPrivacy": 4,
      "updates.getState": 4,
      "help.getConfig": 4,
      "help.getNearestDc": 4,
      "help.getInviteText": 4,
      "help.getSupport": 4,
      "help.getCdnConfig": 4,
      "help.getTermsOfServiceUpdate": 4,
      "help.getAppConfig": 8,
      "help.getPassportConfig": 8,
      "help.getSupportName": 4,
      "help.getPromoData": 4,
      "help.getPremiumPromo": 4,
      "help.getPeerColors": 8,
      "help.getPeerProfileColors": 8,
      "help.getTimezonesList": 8,
      "channels.getAdminedPublicChannels": 8,
      "channels.getLeftChannels": 8,
      "channels.getGroupsForDiscussion": 4,
      "channels.getInactiveChannels": 4,
      "bots.setBotBroadcastDefaultAdminRights": 12,
      "bots.setBotGroupDefaultAdminRights": 12,
      "payments.getSavedInfo": 4,
      "payments.clearSavedInfo": 8,
      "payments.getStarsTopupOptions": 4,
      "payments.getStarsGiveawayOptions": 4,
      "payments.getStarGifts": 8,
      "phone.getCallConfig": 4,
      "phone.receivedCall": 24,
      "phone.discardCall": 44,
      "phone.leaveGroupCall": 28,
      "phone.discardGroupCall": 24,
      "phone.getGroupCall": 28,
      "phone.exportGroupCallInvite": 28,
      "phone.toggleGroupCallStartSubscription": 28,
      "phone.startScheduledGroupCall": 24,
      "phone.leaveGroupCallPresentation": 24,
      "phone.getGroupCallStreamChannels": 24,
      "chatlists.getExportedInvites": 12,
      "chatlists.getChatlistUpdates": 12,
      "chatlists.hideChatlistUpdates": 12,
      "chatlists.getLeaveChatlistSuggestions": 12,
      "stories.toggleAllStoriesHidden": 8,
      "stories.activateStealthMode": 8,
      "stories.getAllReadPeerStories": 4,
      "stories.getChatsToSend": 4,
      "premium.getMyBoosts": 4,
      "smsjobs.isEligibleToJoin": 4,
      "smsjobs.join": 4,
      "smsjobs.leave": 4,
      "smsjobs.updateSettings": 8,
      "smsjobs.getStatus": 4,
      "mt_dh_gen_ok": 52,
      "mt_dh_gen_retry": 52,
      "mt_dh_gen_fail": 52,
      "mt_bind_auth_key_inner": 40,
      "mt_rpc_answer_unknown": 4,
      "mt_rpc_answer_dropped_running": 4,
      "mt_rpc_answer_dropped": 20,
      "mt_future_salt": 20,
      "mt_pong": 20,
      "mt_destroy_session_ok": 12,
      "mt_destroy_session_none": 12,
      "mt_new_session_created": 28,
      "mt_bad_msg_notification": 20,
      "mt_bad_server_salt": 28,
      "mt_msg_detailed_info": 28,
      "mt_msg_new_detailed_info": 20,
      "mt_destroy_auth_key_ok": 4,
      "mt_destroy_auth_key_none": 4,
      "mt_destroy_auth_key_fail": 4,
      "mt_http_wait": 16,
      "mt_req_pq_multi": 20,
      "mt_rpc_drop_answer": 12,
      "mt_get_future_salts": 8,
      "mt_ping": 12,
      "mt_ping_delay_disconnect": 16,
      "mt_destroy_session": 12,
      "mt_destroy_auth_key": 4,
      "messageActionGroupCallScheduled": 28,
      "updateChatDefaultBannedRights": 32,
      "updateBroadcastRevenueTransactions": 48,
      "channelParticipantBanned": 44,
      "channelAdminLogEventActionDefaultBannedRights": 28,
      "channelAdminLogEventActionStartGroupCall": 24,
      "channelAdminLogEventActionDiscardGroupCall": 24
    }
  };
  var __tlWriterMap = writer.__tlWriterMap = m;
  /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e) {
  }
  function Long(low2, high, unsigned) {
    this.low = low2 | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  Long.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO$1;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -9223372036854776e3)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL$2 | 0, value / TWO_PWR_32_DBL$2 | 0, unsigned);
  }
  Long.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  Long.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix2) {
    if (str.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix2 = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return unsigned ? UZERO : ZERO$1;
    radix2 = radix2 || 10;
    if (radix2 < 2 || 36 < radix2)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix2).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix2, 8));
    var result = ZERO$1;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix2);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix2, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long.fromString = fromString;
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  Long.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL$2 = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL$2 * TWO_PWR_32_DBL$2;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO$1 = fromInt(0);
  Long.ZERO = ZERO$1;
  var UZERO = fromInt(0, true);
  Long.UZERO = UZERO;
  var ONE$1 = fromInt(1);
  Long.ONE = ONE$1;
  var UONE = fromInt(1, true);
  Long.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL$2 + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL$2 + (this.low >>> 0);
  };
  LongPrototype.toString = function toString2(radix2) {
    radix2 = radix2 || 10;
    if (radix2 < 2 || 36 < radix2)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix2), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix2) + rem1.toInt().toString(radix2);
      } else
        return "-" + this.neg().toString(radix2);
    }
    var radixToPower = fromNumber(pow_dbl(radix2, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix2);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero2() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
      /* validates */
      other
    );
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
      /* validates */
      other
    ) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
      /* validates */
      other
    ) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE$1);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return this;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low2 = wasm["mul"](
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low2, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero())
      return this.unsigned ? UZERO : ZERO$1;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO$1;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO$1;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low2 = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low2, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO$1;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE$1) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE$1;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO$1)) {
            return divisor.isNegative() ? ONE$1 : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO$1;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO$1;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE$1;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low2 = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low2, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32)
      return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
  };
  LongPrototype.rotl = LongPrototype.rotateLeft;
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
  };
  LongPrototype.rotr = LongPrototype.rotateRight;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi2 = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi2 & 255,
      hi2 >>> 8 & 255,
      hi2 >>> 16 & 255,
      hi2 >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi2 = this.high, lo = this.low;
    return [
      hi2 >>> 24,
      hi2 >>> 16 & 255,
      hi2 >>> 8 & 255,
      hi2 & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
  const _TlBinaryReader = class _TlBinaryReader {
    /**
     * @param objectsMap  Readers map
     * @param data  Buffer to read from
     * @param start  Position to start reading from
     */
    constructor(objectsMap, data2, start2 = 0) {
      __publicField(this, "dataView");
      __publicField(this, "uint8View");
      __publicField(this, "pos", 0);
      this.objectsMap = objectsMap;
      if (ArrayBuffer.isView(data2)) {
        this.pos = start2;
        this.dataView = new DataView(data2.buffer, data2.byteOffset, data2.byteLength);
        this.uint8View = new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      } else {
        this.pos = start2;
        this.dataView = new DataView(data2);
        this.uint8View = new Uint8Array(data2);
      }
    }
    /**
     * Create a new reader without objects map for manual usage
     *
     * @param data  Buffer to read from
     * @param start  Position to start reading from
     */
    static manual(data2, start2 = 0) {
      return new _TlBinaryReader(void 0, data2, start2);
    }
    /**
     * Deserialize a single object
     *
     * @param objectsMap  Readers map
     * @param data  Buffer to read from
     * @param start  Position to start reading from
     */
    static deserializeObject(objectsMap, data2, start2 = 0) {
      return new _TlBinaryReader(objectsMap, data2, start2).object();
    }
    int() {
      const res = this.dataView.getInt32(this.pos, true);
      this.pos += 4;
      return res;
    }
    uint() {
      const res = this.dataView.getUint32(this.pos, true);
      this.pos += 4;
      return res;
    }
    /**
     * Get the next {@link uint} without advancing the reader cursor
     */
    peekUint() {
      return this.dataView.getUint32(this.pos, true);
    }
    int53() {
      const res = (this.dataView.getInt32(this.pos, true) >>> 0) + TWO_PWR_32_DBL$1 * this.dataView.getInt32(this.pos + 4, true);
      this.pos += 8;
      return res;
    }
    long(unsigned = false) {
      const lo = this.dataView.getInt32(this.pos, true);
      const hi2 = this.dataView.getInt32(this.pos + 4, true);
      this.pos += 8;
      return new Long(lo, hi2, unsigned);
    }
    float() {
      const res = this.dataView.getFloat32(this.pos, true);
      this.pos += 4;
      return res;
    }
    double() {
      const res = this.dataView.getFloat64(this.pos, true);
      this.pos += 8;
      return res;
    }
    boolean() {
      const val = this.uint();
      if (val === 3162085175)
        return false;
      if (val === 2574415285)
        return true;
      throw new Error(`Expected either boolTrue or boolFalse, got 0x${val.toString(16)}`);
    }
    /**
     * Read raw bytes of the given length
     * @param bytes  Length of the buffer to read
     */
    raw(bytes = -1) {
      if (bytes === -1)
        bytes = this.uint8View.length - this.pos;
      return this.uint8View.subarray(this.pos, this.pos += bytes);
    }
    int128() {
      return this.uint8View.subarray(this.pos, this.pos += 16);
    }
    int256() {
      return this.uint8View.subarray(this.pos, this.pos += 32);
    }
    bytes() {
      const firstByte = this.uint8View[this.pos++];
      let length;
      let padding;
      if (firstByte === 254) {
        length = this.uint8View[this.pos++] | this.uint8View[this.pos++] << 8 | this.uint8View[this.pos++] << 16;
        padding = length % 4;
      } else {
        length = firstByte;
        padding = (length + 1) % 4;
      }
      const data2 = this.raw(length);
      if (padding > 0)
        this.pos += 4 - padding;
      return data2;
    }
    string() {
      return _TlBinaryReader.platform.utf8Decode(this.bytes());
    }
    object(id2 = this.uint()) {
      if (id2 === 481674261) {
        return this.vector(this.object, true);
      }
      if (id2 === 3162085175)
        return false;
      if (id2 === 2574415285)
        return true;
      if (id2 === 1072550713)
        return true;
      if (id2 === 1450380236)
        return null;
      const reader2 = this.objectsMap[id2];
      if (!reader2) {
        this.seek(-4);
        const pos = this.pos;
        const error = new TypeError(`Unknown object id: 0x${id2.toString(16)}`);
        this.pos = pos;
        throw error;
      }
      return reader2(this);
    }
    vector(reader2 = this.object, bare = false) {
      if (!bare) {
        const uint = this.uint();
        if (uint !== 481674261) {
          throw new Error(
            `Invalid object code, expected 0x1cb5c415 (vector), got 0x${uint.toString(16)} at ${this.pos - 4}`
          );
        }
      }
      const length = this.uint();
      const ret = [];
      for (let i = 0; i < length; i++)
        ret.push(reader2.call(this));
      return ret;
    }
    /**
     * Advance the reader cursor by the given amount of bytes
     *
     * @param delta  Amount of bytes to advance (can be negative)
     */
    seek(delta) {
      this.seekTo(this.pos + delta);
    }
    /**
     * Seek to the given position
     *
     * @param pos  Position to seek to
     */
    seekTo(pos) {
      if (pos >= this.uint8View.length || pos < 0) {
        throw new RangeError("New position is out of range");
      }
      this.pos = pos;
    }
  };
  __publicField(_TlBinaryReader, "platform");
  let TlBinaryReader = _TlBinaryReader;
  const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
  class TlSerializationCounter {
    /**
     * @param objectMap  Writers map
     */
    constructor(objectMap) {
      __publicField(this, "count", 0);
      this.objectMap = objectMap;
    }
    /**
     * Count bytes required to serialize the given object.
     *
     * @param objectMap  Writers map
     * @param obj  Object to count bytes for
     */
    static countNeededBytes(objectMap, obj) {
      const cnt = new TlSerializationCounter(objectMap);
      cnt.object(obj);
      return cnt.count;
    }
    /**
     * Count overhead in bytes for the given number of bytes when
     * encoded as `bytes` TL type.
     *
     * @param size  Number of bytes
     */
    static countBytesOverhead(size) {
      let res = 0;
      let padding;
      if (size <= 253) {
        res += 1;
        padding = (size + 1) % 4;
      } else {
        res += 4;
        padding = size % 4;
      }
      if (padding > 0)
        res += 4 - padding;
      return res;
    }
    boolean() {
      this.count += 4;
    }
    double() {
      this.count += 8;
    }
    float() {
      this.count += 4;
    }
    int128() {
      this.count += 16;
    }
    int256() {
      this.count += 32;
    }
    int() {
      this.count += 4;
    }
    uint() {
      this.count += 4;
    }
    int53() {
      this.count += 8;
    }
    long() {
      this.count += 8;
    }
    null() {
      this.count += 4;
    }
    raw(val) {
      this.count += val.byteLength;
    }
    bytes(val) {
      this.count += TlSerializationCounter.countBytesOverhead(val.length) + val.length;
    }
    string(val) {
      const length = TlBinaryWriter.platform.utf8ByteLength(val);
      this.count += TlSerializationCounter.countBytesOverhead(length) + length;
    }
    object(obj) {
      if (!this.objectMap[obj._])
        throw new Error(`Unknown object ${obj._}`);
      this.objectMap[obj._](this, obj);
    }
    vector(fn, items) {
      this.count += 8;
      items.forEach((it) => fn.call(this, it));
    }
  }
  const _TlBinaryWriter = class _TlBinaryWriter {
    /**
     * @param objectMap  Writers map
     * @param buffer  Buffer to write to
     * @param start  Position to start writing at
     */
    constructor(objectMap, data2, start2 = 0) {
      __publicField(this, "dataView");
      __publicField(this, "uint8View");
      /**
       * Current position in the buffer.
       */
      __publicField(this, "pos");
      this.objectMap = objectMap;
      if (ArrayBuffer.isView(data2)) {
        this.pos = start2;
        this.dataView = new DataView(data2.buffer, data2.byteOffset, data2.byteLength);
        this.uint8View = new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      } else {
        this.pos = start2;
        this.dataView = new DataView(data2);
        this.uint8View = new Uint8Array(data2);
      }
    }
    /**
     * Create a new writer with the given size.
     *
     * @param objectMap  Writers map
     * @param size  Size of the writer's buffer
     */
    static alloc(objectMap, size) {
      return new _TlBinaryWriter(objectMap, new ArrayBuffer(size));
    }
    /**
     * Create a new writer without objects map for manual usage
     *
     * @param buffer  Buffer to write to, or its size
     * @param start  Position to start writing at
     */
    static manual(buffer, start2 = 0) {
      if (typeof buffer === "number")
        buffer = new ArrayBuffer(buffer);
      return new _TlBinaryWriter(void 0, buffer, start2);
    }
    /**
     * Serialize a single object
     *
     * @param objectMap  Writers map
     * @param obj  Object to serialize
     * @param knownSize  In case the size is known, pass it here
     */
    static serializeObject(objectMap, obj, knownSize = -1) {
      if (knownSize === -1) {
        knownSize = objectMap._staticSize[obj._] || TlSerializationCounter.countNeededBytes(objectMap, obj);
      }
      const writer2 = _TlBinaryWriter.alloc(objectMap, knownSize);
      writer2.object(obj);
      return writer2.uint8View;
    }
    int(val) {
      this.dataView.setInt32(this.pos, val, true);
      this.pos += 4;
    }
    uint(val) {
      this.dataView.setUint32(this.pos, val, true);
      this.pos += 4;
    }
    int53(val) {
      this.dataView.setInt32(this.pos, val % TWO_PWR_32_DBL | 0, true);
      if (val < 0) {
        this.dataView.setInt32(this.pos + 4, val / TWO_PWR_32_DBL - 1 | 0, true);
      } else {
        this.dataView.setInt32(this.pos + 4, val / TWO_PWR_32_DBL | 0, true);
      }
      this.pos += 8;
    }
    null() {
      this.uint(1450380236);
    }
    long(val) {
      this.dataView.setInt32(this.pos, val.low, true);
      this.dataView.setInt32(this.pos + 4, val.high, true);
      this.pos += 8;
    }
    float(val) {
      this.dataView.setFloat32(this.pos, val, true);
      this.pos += 4;
    }
    double(val) {
      this.dataView.setFloat64(this.pos, val, true);
      this.pos += 8;
    }
    boolean(val) {
      this.dataView.setInt32(this.pos, val ? 2574415285 : 3162085175, true);
      this.pos += 4;
    }
    /**
     * Write raw bytes to the buffer
     * @param val  Buffer to write
     */
    raw(val) {
      this.uint8View.set(val, this.pos);
      this.pos += val.byteLength;
    }
    int128(val) {
      if (val.byteLength !== 16)
        throw new Error("Invalid int128 length");
      this.raw(val);
    }
    int256(val) {
      if (val.byteLength !== 32)
        throw new Error("Invalid int256 length");
      this.raw(val);
    }
    bytes(val) {
      const length = val.byteLength;
      let padding;
      if (length <= 253) {
        this.uint8View[this.pos++] = length;
        padding = (length + 1) % 4;
      } else {
        this.uint8View[this.pos++] = 254;
        this.uint8View[this.pos++] = length & 255;
        this.uint8View[this.pos++] = length >> 8 & 255;
        this.uint8View[this.pos++] = length >> 16 & 255;
        padding = length % 4;
      }
      this.uint8View.set(val, this.pos);
      this.pos += length;
      if (padding > 0) {
        padding = 4 - padding;
        while (padding--)
          this.uint8View[this.pos++] = 0;
      }
    }
    string(val) {
      this.bytes(_TlBinaryWriter.platform.utf8Encode(val));
    }
    // hot path, avoid additional runtime checks
    object(obj) {
      const fn = this.objectMap[obj._];
      if (!fn)
        throw new Error(`Unknown object ${obj._}`);
      fn(this, obj);
    }
    vector(fn, val, bare) {
      if (!bare)
        this.uint(481674261);
      this.uint(val.length);
      val.forEach((it) => fn.call(this, it, bare));
    }
    /**
     * Get the resulting buffer
     */
    result() {
      return this.uint8View.subarray(0, this.pos);
    }
  };
  __publicField(_TlBinaryWriter, "platform");
  let TlBinaryWriter = _TlBinaryWriter;
  const platformKey = typeof Symbol !== "undefined" ? Symbol.for("mtcute.platform") : "__MTCUTE_PLATFORM__";
  let _platform = (_a = globalThis == null ? void 0 : globalThis[platformKey]) != null ? _a : null;
  function setPlatform(platform) {
    if (_platform) {
      if (_platform.constructor !== platform.constructor) {
        throw new MtUnsupportedError("Platform may not be changed at runtime!");
      }
      return;
    }
    _platform = platform;
    TlBinaryReader.platform = platform;
    TlBinaryWriter.platform = platform;
    globalThis[platformKey] = platform;
  }
  function getPlatform() {
    if (!_platform) {
      throw new MtUnsupportedError("Platform is not set! Have you instantiated the client?");
    }
    return _platform;
  }
  const setTimeoutWrap = (...args) => setTimeout(...args);
  const setIntervalWrap = (...args) => setInterval(...args);
  let setImmediateWrap;
  if (typeof setImmediate !== "undefined") {
    setImmediateWrap = (...args) => setImmediate(...args);
  } else {
    setImmediateWrap = (fn, ...args) => setTimeout(fn, 0, ...args);
  }
  const setImmediateWrapExported = setImmediateWrap;
  const clearTimeoutWrap = (...args) => clearTimeout(...args);
  const clearIntervalWrap = (...args) => clearInterval(...args);
  let clearImmediateWrap;
  if (typeof clearImmediate !== "undefined") {
    clearImmediateWrap = (...args) => clearImmediate(...args);
  } else {
    clearImmediateWrap = (timer) => clearTimeout(timer);
  }
  const clearImmediateWrapExported = clearImmediateWrap;
  function buffersEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function concatBuffers(buffers) {
    if (buffers.length === 1)
      return buffers[0];
    if (typeof Buffer !== "undefined") {
      return Buffer.concat(buffers);
    }
    let length = 0;
    for(let   buf of buffers) {
      length += buf.length;
    }
    const ret = new Uint8Array(length);
    let offset = 0;
    for(let   buf of buffers) {
      ret.set(buf, offset);
      offset += buf.length;
    }
    return ret;
  }
  function dataViewFromBuffer(buf) {
    return new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  function bufferToReversed(buf, start2 = 0, end = buf.length) {
    const len = end - start2;
    const ret = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      ret[i] = buf[end - i - 1];
    }
    return ret;
  }
  function determinePartSize(fileSize) {
    if (fileSize <= 262078465)
      return 128;
    if (fileSize <= 786432e3)
      return 256;
    if (fileSize <= 2097152e3)
      return 512;
    throw new MtArgumentError("File is too large");
  }
  function isProbablyPlainText(buf) {
    return !buf.some(
      (it) => !(it >= 32 && it < 127 || it === 13 || it === 10 || it === 9)
    );
  }
  function JPEG_HEADER() {
    return getPlatform().hexDecode(
      "ffd8ffe000104a46494600010100000100010000ffdb004300281c1e231e19282321232d2b28303c64413c37373c7b585d4964918099968f808c8aa0b4e6c3a0aadaad8a8cc8ffcbdaeef5ffffff9bc1fffffffaffe6fdfff8ffdb0043012b2d2d3c353c76414176f8a58ca5f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8ffc00011080000000003012200021101031101ffc4001f0000010501010101010100000000000000000102030405060708090a0bffc400b5100002010303020403050504040000017d01020300041105122131410613516107227114328191a1082342b1c11552d1f02433627282090a161718191a25262728292a3435363738393a434445464748494a535455565758595a636465666768696a737475767778797a838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae1e2e3e4e5e6e7e8e9eaf1f2f3f4f5f6f7f8f9faffc4001f0100030101010101010101010000000000000102030405060708090a0bffc400b51100020102040403040705040400010277000102031104052131061241510761711322328108144291a1b1c109233352f0156272d10a162434e125f11718191a262728292a35363738393a434445464748494a535455565758595a636465666768696a737475767778797a82838485868788898a92939495969798999aa2a3a4a5a6a7a8a9aab2b3b4b5b6b7b8b9bac2c3c4c5c6c7c8c9cad2d3d4d5d6d7d8d9dae2e3e4e5e6e7e8e9eaf2f3f4f5f6f7f8f9faffda000c03010002110311003f00"
    );
  }
  let JPEG_HEADER_BYTES = null;
  const JPEG_FOOTER = new Uint8Array([255, 217]);
  function strippedPhotoToJpg(stripped) {
    if (stripped.length < 3 || stripped[0] !== 1) {
      throw new MtArgumentError("Invalid stripped JPEG");
    }
    if (JPEG_HEADER_BYTES === null) {
      JPEG_HEADER_BYTES = JPEG_HEADER();
    }
    const result = concatBuffers([JPEG_HEADER_BYTES, stripped.slice(3), JPEG_FOOTER]);
    result[164] = stripped[1];
    result[166] = stripped[2];
    return result;
  }
  const SVG_LOOKUP = "AACAAAAHAAALMAAAQASTAVAAAZaacaaaahaaalmaaaqastava.az0123456789-,";
  function inflateSvgPath(encoded) {
    let path2 = "M";
    const len = encoded.length;
    for (let i = 0; i < len; i++) {
      const num = encoded[i];
      if (num >= 192) {
        path2 += SVG_LOOKUP[num - 192];
      } else {
        if (num >= 128) {
          path2 += ",";
        } else if (num >= 64) {
          path2 += "-";
        }
        path2 += num & 63;
      }
    }
    path2 += "z";
    return path2;
  }
  function svgPathToFile(path2, size) {
    var _a2, _b;
    return getPlatform().utf8Encode(
      `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"viewBox="0 0 ${(_a2 = size == null ? void 0 : size.w) != null ? _a2 : 512} ${(_b = size == null ? void 0 : size.h) != null ? _b : 512}" xml:space="preserve"><path d="${path2}"/></svg>`
    );
  }
  function extractFileName(path2) {
    if (path2.startsWith("file:"))
      path2 = path2.slice(5);
    return path2.split(/[\\/]/).pop().split("?")[0];
  }
  function parseInlineMessageId(id2) {
    const buf = getPlatform().base64Decode(id2, true);
    const reader2 = TlBinaryReader.manual(buf);
    if (buf.length === 20) {
      return {
        _: "inputBotInlineMessageID",
        dcId: reader2.int(),
        id: reader2.long(),
        accessHash: reader2.long()
      };
    }
    return {
      _: "inputBotInlineMessageID64",
      dcId: reader2.int(),
      ownerId: reader2.long(),
      id: reader2.int(),
      accessHash: reader2.long()
    };
  }
  function encodeInlineMessageId(id2) {
    let writer2;
    switch (id2._) {
      case "inputBotInlineMessageID":
        writer2 = TlBinaryWriter.manual(20);
        writer2.int(id2.dcId);
        writer2.long(id2.id);
        writer2.long(id2.accessHash);
        break;
      case "inputBotInlineMessageID64":
        writer2 = TlBinaryWriter.manual(24);
        writer2.int(id2.dcId);
        writer2.long(id2.ownerId);
        writer2.int(id2.id);
        writer2.long(id2.accessHash);
        break;
      default:
        assertNever$1();
    }
    return getPlatform().base64Encode(writer2.result(), true);
  }
  function normalizeInlineId(id2) {
    if (typeof id2 === "string") {
      return parseInlineMessageId(id2);
    }
    return id2;
  }
  function normalizePhoneNumber(phone) {
    phone = phone.trim().replace(/[+()\s-]/g, "");
    if (!phone.match(/^\d+$/))
      throw new MtArgumentError("Invalid phone number");
    return phone;
  }
  function resolveMaybeDynamic(val) {
    return __async(this, null, function* () {
      return val instanceof Function ? yield val() : yield val;
    });
  }
  function makeArrayWithTotal(arr, total) {
    const a = arr;
    a.total = total;
    return a;
  }
  function makeArrayPaginated(arr, total, next) {
    const a = arr;
    a.total = total;
    a.next = next;
    return a;
  }
  function normalizeDate(date) {
    return date ? ~~((typeof date === "number" ? date : date.getTime()) / 1e3) : void 0;
  }
  function normalizeMessageId(msg) {
    if (!msg)
      return void 0;
    return typeof msg === "number" ? msg : msg.id;
  }
  class MtPeerNotFoundError extends MtcuteError {
  }
  class MtMessageNotFoundError extends MtcuteError {
    constructor(peerId, messageId, context) {
      super(`Message${context ? ` ${context}` : ""} ${messageId} not found in ${peerId}`);
      this.peerId = peerId;
      this.messageId = messageId;
      this.context = context;
    }
  }
  class MtInvalidPeerTypeError extends MtcuteError {
    constructor(peer, expected) {
      super(`Provided identifier ${JSON.stringify(peer)} is not a ${expected}`);
    }
  }
  class MtEmptyError extends MtcuteError {
    constructor() {
      super("Property is not available on an empty object");
    }
  }
  const INVITE_LINK_REGEX = /^(?:https?:\/\/)?(?:www\.)?t(?:elegram)?\.(?:org|me|dog)\/(?:joinchat\/|\+)([\w-]+)$/i;
  function toInputPeer(res) {
    if (tl.tl.isAnyInputPeer(res))
      return res;
    switch (res._) {
      case "inputChannelEmpty":
      case "inputUserEmpty":
        return { _: "inputPeerEmpty" };
      case "inputUser":
        return {
          _: "inputPeerUser",
          userId: res.userId,
          accessHash: res.accessHash
        };
      case "inputUserSelf":
        return { _: "inputPeerSelf" };
      case "inputChannel":
        return {
          _: "inputPeerChannel",
          channelId: res.channelId,
          accessHash: res.accessHash
        };
      case "inputChannelFromMessage":
        return {
          _: "inputPeerChannelFromMessage",
          channelId: res.channelId,
          msgId: res.msgId,
          peer: res.peer
        };
      case "inputUserFromMessage":
        return {
          _: "inputPeerUserFromMessage",
          userId: res.userId,
          msgId: res.msgId,
          peer: res.peer
        };
      default:
        assertNever$1();
    }
  }
  function toInputUser(res, input) {
    if (tl.tl.isAnyInputUser(res))
      return res;
    switch (res._) {
      case "inputPeerSelf":
        return { _: "inputUserSelf" };
      case "inputPeerUser":
        return {
          _: "inputUser",
          userId: res.userId,
          accessHash: res.accessHash
        };
      case "inputPeerUserFromMessage":
        return {
          _: "inputUserFromMessage",
          userId: res.userId,
          msgId: res.msgId,
          peer: res.peer
        };
    }
    throw new MtInvalidPeerTypeError(input != null ? input : res, "user");
  }
  function toInputChannel(res, input) {
    if (tl.tl.isAnyInputChannel(res))
      return res;
    switch (res._) {
      case "inputPeerChannel":
        return {
          _: "inputChannel",
          channelId: res.channelId,
          accessHash: res.accessHash
        };
      case "inputPeerChannelFromMessage":
        return {
          _: "inputChannelFromMessage",
          channelId: res.channelId,
          msgId: res.msgId,
          peer: res.peer
        };
    }
    throw new MtInvalidPeerTypeError(input != null ? input : res, "channel");
  }
  function isInputPeerUser(obj) {
    switch (obj._) {
      case "inputPeerUser":
      case "inputPeerUserFromMessage":
      case "inputPeerSelf":
        return true;
    }
    return false;
  }
  function isInputPeerChannel(obj) {
    switch (obj._) {
      case "inputPeerChannel":
      case "inputPeerChannelFromMessage":
        return true;
    }
    return false;
  }
  function isInputPeerChat(obj) {
    return obj._ === "inputPeerChat";
  }
  function inputPeerToPeer(inp) {
    switch (inp._) {
      case "inputPeerUser":
      case "inputPeerUserFromMessage":
        return { _: "peerUser", userId: inp.userId };
      case "inputPeerChannel":
      case "inputPeerChannelFromMessage":
        return { _: "peerChannel", channelId: inp.channelId };
      case "inputPeerChat":
        return { _: "peerChat", chatId: inp.chatId };
      default:
        throw new MtInvalidPeerTypeError(inp, `Cannot convert ${inp._} to peer`);
    }
  }
  function extractUsernames(obj) {
    var _a2;
    if ((_a2 = obj.usernames) == null ? void 0 : _a2.length)
      return obj.usernames.map((x) => x.username.toLowerCase());
    if (obj.username)
      return [obj.username.toLowerCase()];
    return [];
  }
  const MIN_INITIAL_CAPACITY = 8;
  function arraycopy(src, srcPos, dest, destPos, length) {
    for (let i = 0; i < length; i++) {
      dest[destPos + i] = src[srcPos + i];
    }
  }
  class Deque {
    constructor(maxLength = Infinity, minCapacity = maxLength === Infinity ? MIN_INITIAL_CAPACITY : maxLength) {
      // another implementation variant would be to use
      // blocks of fixed size instead of a single array
      // to avoid copying stuff around
      __publicField(this, "_elements");
      __publicField(this, "_head", 0);
      __publicField(this, "_tail", 0);
      __publicField(this, "_capacity");
      this.maxLength = maxLength;
      let capacity = minCapacity;
      if (capacity < MIN_INITIAL_CAPACITY) {
        capacity = MIN_INITIAL_CAPACITY;
      }
      if (capacity !== MIN_INITIAL_CAPACITY) {
        capacity |= capacity >>> 1;
        capacity |= capacity >>> 2;
        capacity |= capacity >>> 4;
        capacity |= capacity >>> 8;
        capacity |= capacity >>> 16;
        capacity += 1;
        if (capacity < 0) {
          capacity >>>= 1;
        }
      }
      this._elements = new Array(capacity);
      this._capacity = capacity;
    }
    _resize() {
      const p = this._head;
      const n = this._capacity;
      const r = n - p;
      const newCapacity = n << 1;
      if (newCapacity < 0)
        throw new Error("Deque is too big");
      const arr = new Array(newCapacity);
      arraycopy(this._elements, p, arr, 0, r);
      arraycopy(this._elements, 0, arr, r, p);
      this._elements = arr;
      this._head = 0;
      this._tail = n;
      this._capacity = newCapacity;
    }
    pushBack(item) {
      if (item === void 0)
        throw new Error("item can not be undefined");
      this._elements[this._tail] = item;
      if ((this._tail = this._tail + 1 & this._capacity - 1) === this._head) {
        this._resize();
      }
      if (this.length > this.maxLength) {
        this.popFront();
      }
    }
    pushFront(item) {
      if (item === void 0)
        throw new Error("item can not be undefined");
      this._elements[this._head = this._head - 1 & this._capacity - 1] = item;
      if (this._head === this._tail) {
        this._resize();
      }
      if (this.length > this.maxLength) {
        this.popBack();
      }
    }
    popFront() {
      const h2 = this._head;
      const res = this._elements[h2];
      if (res === void 0)
        return void 0;
      this._elements[h2] = void 0;
      this._head = h2 + 1 & this._capacity - 1;
      return res;
    }
    popBack() {
      const t2 = this._tail - 1 & this._capacity - 1;
      const res = this._elements[t2];
      if (res === void 0)
        return void 0;
      this._elements[t2] = void 0;
      this._tail = t2;
      return res;
    }
    peekFront() {
      return this._elements[this._head];
    }
    peekBack() {
      return this._elements[this._tail - 1 & this._capacity - 1];
    }
    get length() {
      return this._tail - this._head & this._capacity - 1;
    }
    toArray() {
      const sz = this.length;
      if (sz === 0)
        return [];
      const arr = new Array(sz);
      if (this._head < this._tail) {
        arraycopy(this._elements, this._head, arr, 0, sz);
      } else {
        const headPortion = this._capacity - this._head;
        arraycopy(this._elements, this._head, arr, 0, headPortion);
        arraycopy(this._elements, 0, arr, headPortion, this._tail);
      }
      return arr;
    }
    _delete(i) {
      const els = this._elements;
      const mask2 = this._capacity - 1;
      const h2 = this._head;
      const t2 = this._tail;
      const front = i - h2 & mask2;
      const back = t2 - i & mask2;
      if (front < back) {
        if (h2 <= i) {
          arraycopy(els, h2, els, h2 + 1, front);
        } else {
          arraycopy(els, 0, els, 1, i);
          els[0] = els[mask2];
          arraycopy(els, h2, els, h2 + 1, mask2 - h2);
        }
        els[h2] = void 0;
        this._head = h2 + 1 & mask2;
      } else if (i < t2) {
        arraycopy(els, i + 1, els, i, back);
        this._tail = t2 - 1;
      } else {
        arraycopy(els, i + 1, els, i, mask2 - i);
        els[mask2] = els[0];
        arraycopy(els, 1, els, 0, t2);
        this._tail = t2 - 1 & mask2;
      }
    }
    remove(item) {
      const mask2 = this._capacity - 1;
      let i = this._head;
      let val;
      while ((val = this._elements[i]) !== void 0) {
        if (item === val) {
          this._delete(i);
          return;
        }
        i = i + 1 & mask2;
      }
    }
    removeBy(pred) {
      const mask2 = this._capacity - 1;
      let i = this._head;
      let val;
      while ((val = this._elements[i]) !== void 0) {
        if (pred(val)) {
          this._delete(i);
          return;
        }
        i = i + 1 & mask2;
      }
    }
    at(idx) {
      return this._elements[this._head + idx & this._capacity - 1];
    }
    *iter() {
      const sz = this.length;
      if (sz === 0)
        return;
      if (this._head < this._tail) {
        for (let i = 0; i < sz; i++) {
          yield this._elements[this._head + i];
        }
      } else {
        const headPortion = this._capacity - this._head;
        for (let i = 0; i < headPortion; i++) {
          yield this._elements[this._head + i];
        }
        for (let i = 0; i < this._tail; i++) {
          yield this._elements[i];
        }
      }
    }
    clear() {
      this._elements = new Array(this._capacity);
      this._head = this._tail = 0;
    }
  }
  class AsyncLock {
    constructor() {
      __publicField(this, "_queue", new Deque());
    }
    acquire() {
      return __async(this, null, function* () {
        let info;
        while (info = this._queue.peekFront()) {
          yield info[0];
        }
        let unlock;
        const prom = new Promise((resolve) => {
          unlock = resolve;
        });
        this._queue.pushBack([prom, unlock]);
      });
    }
    release() {
      if (!this._queue.length)
        throw new Error("Nothing to release");
      this._queue.popFront()[1]();
    }
    with(func) {
      let err2 = null;
      return this.acquire().then(() => func()).catch((e) => void (err2 = e)).then(() => {
        this.release();
        if (err2)
          throw err2;
      });
    }
  }
  function bufferToStream(buf) {
    return new ReadableStream({
      start(controller) {
        controller.enqueue(buf);
        controller.close();
      }
    });
  }
  function streamToBuffer(stream) {
    return __async(this, null, function* () {
      const chunks = [];
      const reader2 = stream.getReader();
      while (true) {
        const { done, value } = yield reader2.read();
        if (done)
          break;
        chunks.push(value);
      }
      return concatBuffers(chunks);
    });
  }
  function createChunkedReader(stream, chunkSize) {
    const reader2 = stream.getReader();
    const lock = new AsyncLock();
    const buffer = [];
    let bufferLength = 0;
    let next;
    let first = true;
    function readInner() {
      return __async(this, null, function* () {
        const { value } = yield reader2.read();
        if (first) {
          first = false;
          const { value: nextValue } = yield reader2.read();
          next = nextValue;
          return value;
        }
        const tmp = next;
        next = value;
        return tmp;
      });
    }
    function read() {
      return __async(this, null, function* () {
        if (bufferLength > chunkSize) {
          const chunks = [];
          let length = 0;
          while (length < chunkSize && buffer.length) {
            const chunk = buffer.shift();
            length += chunk.length;
            chunks.push(chunk);
          }
          if (length > chunkSize) {
            const lastChunk = chunks.pop();
            const diff = length - chunkSize;
            chunks.push(lastChunk.subarray(0, lastChunk.length - diff));
            buffer.unshift(lastChunk.subarray(lastChunk.length - diff));
            length = chunkSize;
          }
          if (length === chunkSize) {
            bufferLength -= chunkSize;
            return concatBuffers(chunks);
          }
        } else if (next === void 0 && bufferLength > 0) {
          bufferLength = 0;
          return concatBuffers(buffer);
        }
        const value = yield readInner();
        if (!value)
          return null;
        if (bufferLength > 0) {
          buffer.push(value);
          bufferLength += value.length;
          return read();
        }
        if (value.length > chunkSize) {
          const rest = value.subarray(chunkSize);
          buffer.push(rest);
          bufferLength += rest.length;
          return value.subarray(0, chunkSize);
        }
        if (value.length === chunkSize) {
          return value;
        }
        buffer.push(value);
        bufferLength += value.length;
        return read();
      });
    }
    function readLocked() {
      return __async(this, null, function* () {
        yield lock.acquire();
        let res = null;
        let err2 = null;
        try {
          res = yield read();
        } catch (e) {
          err2 = e;
        }
        lock.release();
        if (err2)
          throw err2;
        return res;
      });
    }
    return {
      ended: () => bufferLength === 0 && next === void 0,
      read: readLocked
    };
  }
  function serializeBasicDcOption(dc) {
    const writer2 = TlBinaryWriter.manual(64);
    const flags = (dc.ipv6 ? 1 : 0) | (dc.mediaOnly ? 2 : 0);
    writer2.raw(
      new Uint8Array([
        1,
        // version
        dc.id,
        flags
      ])
    );
    writer2.string(dc.ipAddress);
    writer2.int(dc.port);
    return writer2.result();
  }
  function parseBasicDcOption(data2) {
    const reader2 = TlBinaryReader.manual(data2);
    const [version2, id2, flags] = reader2.raw(3);
    if (version2 !== 1)
      return null;
    const ipAddress = reader2.string();
    const port = reader2.int();
    return {
      id: id2,
      ipAddress,
      port,
      ipv6: (flags & 1) !== 0,
      mediaOnly: (flags & 2) !== 0
    };
  }
  const defaultProductionDc = {
    main: {
      ipAddress: "149.154.167.50",
      port: 443,
      id: 2
    },
    media: {
      ipAddress: "149.154.167.222",
      port: 443,
      id: 2,
      mediaOnly: true
    }
  };
  const defaultProductionIpv6Dc = {
    main: {
      ipAddress: "2001:067c:04e8:f002:0000:0000:0000:000a",
      ipv6: true,
      port: 443,
      id: 2
    },
    media: {
      ipAddress: "2001:067c:04e8:f002:0000:0000:0000:000b",
      ipv6: true,
      port: 443,
      id: 2,
      mediaOnly: true
    }
  };
  const defaultTestDc = {
    main: {
      ipAddress: "149.154.167.40",
      port: 443,
      id: 2
    },
    media: {
      ipAddress: "149.154.167.40",
      port: 443,
      id: 2,
      mediaOnly: true
    }
  };
  const defaultTestIpv6Dc = {
    main: {
      ipAddress: "2001:67c:4e8:f002::e",
      port: 443,
      ipv6: true,
      id: 2
    },
    media: {
      ipAddress: "2001:67c:4e8:f002::e",
      port: 443,
      ipv6: true,
      id: 2,
      mediaOnly: true
    }
  };
  function readTlDcOption(reader2) {
    const ctorId = reader2.uint();
    if (ctorId !== 414687501) {
      throw new MtArgumentError(`Invalid dcOption constructor id: ${ctorId}`);
    }
    const flags = reader2.uint();
    const id2 = reader2.int();
    const ipAddress = reader2.string();
    const port = reader2.int();
    if (flags & 1024) {
      reader2.bytes();
    }
    return {
      id: id2,
      ipAddress,
      port,
      ipv6: Boolean(flags & 1),
      mediaOnly: Boolean(flags & 2)
    };
  }
  function writeStringSession(data2) {
    const writer2 = TlBinaryWriter.manual(512);
    const version2 = data2.version;
    if (version2 !== 3) {
      throw new MtArgumentError(`Unsupported string session version: ${version2}`);
    }
    let flags = 0;
    if (data2.self) {
      flags |= 1;
    }
    if (data2.testMode) {
      flags |= 2;
    }
    writer2.uint8View[0] = version2;
    writer2.pos += 1;
    if (version2 >= 2 && data2.primaryDcs.media !== data2.primaryDcs.main) {
      flags |= 4;
    }
    writer2.int(flags);
    writer2.bytes(serializeBasicDcOption(data2.primaryDcs.main));
    if (version2 >= 2 && data2.primaryDcs.media !== data2.primaryDcs.main) {
      writer2.bytes(serializeBasicDcOption(data2.primaryDcs.media));
    }
    if (data2.self) {
      writer2.int53(data2.self.userId);
      writer2.boolean(data2.self.isBot);
    }
    writer2.bytes(data2.authKey);
    return getPlatform().base64Encode(writer2.result(), true);
  }
  function readStringSession(data2) {
    const buf = getPlatform().base64Decode(data2, true);
    const version2 = buf[0];
    if (version2 !== 1 && version2 !== 2 && version2 !== 3) {
      throw new Error(`Invalid session string (version = ${version2})`);
    }
    if (version2 < 3) {
      console.warn(
        `You are using a deprecated session string (${data2.slice(
          0,
          10
        )}...). Please update your session string, as it will stop working in the future.`
      );
    }
    const reader2 = TlBinaryReader.manual(buf, 1);
    const flags = reader2.int();
    const hasSelf = flags & 1;
    const testMode = Boolean(flags & 2);
    const hasMedia = version2 >= 2 && Boolean(flags & 4);
    let primaryDc;
    let primaryMediaDc;
    if (version2 <= 2) {
      const primaryDc_ = readTlDcOption(reader2);
      const primaryMediaDc_ = hasMedia ? readTlDcOption(reader2) : primaryDc_;
      primaryDc = primaryDc_;
      primaryMediaDc = primaryMediaDc_;
    } else if (version2 === 3) {
      const primaryDc_ = parseBasicDcOption(reader2.bytes());
      if (primaryDc_ === null) {
        throw new MtArgumentError("Invalid session string (failed to parse primaryDc)");
      }
      const primaryMediaDc_ = hasMedia ? parseBasicDcOption(reader2.bytes()) : primaryDc_;
      if (primaryMediaDc_ === null) {
        throw new MtArgumentError("Invalid session string (failed to parse primaryMediaDc)");
      }
      primaryDc = primaryDc_;
      primaryMediaDc = primaryMediaDc_;
    } else {
      throw new Error("unreachable");
    }
    let self2 = null;
    if (hasSelf) {
      const selfId = reader2.int53();
      const selfBot = reader2.boolean();
      self2 = {
        userId: selfId,
        isBot: selfBot,
        // todo: we should make sure we fetch this from the server at first start
        isPremium: false,
        usernames: []
      };
    }
    const key = reader2.bytes();
    return {
      version: version2,
      testMode,
      primaryDcs: {
        main: primaryDc,
        media: primaryMediaDc
      },
      self: self2,
      authKey: key
    };
  }
  function decodeWaveform(wf) {
    const bitsCount = wf.length * 8;
    const valuesCount = ~~(bitsCount / 5);
    if (!valuesCount)
      return [];
    const lastIdx = valuesCount - 1;
    const result = [];
    const dv = dataViewFromBuffer(wf);
    for (let i = 0, j = 0; i < lastIdx; i++, j += 5) {
      const byteIdx = ~~(j / 8);
      const bitShift = j % 8;
      result[i] = dv.getUint16(byteIdx, true) >> bitShift & 31;
    }
    const lastByteIdx = ~~(lastIdx * 5 / 8);
    const lastBitShift = lastIdx * 5 % 8;
    const lastValue = lastByteIdx === wf.length - 1 ? wf[lastByteIdx] : dv.getUint16(lastByteIdx, true);
    result[lastIdx] = lastValue >> lastBitShift & 31;
    return result;
  }
  function encodeWaveform(wf) {
    const bitsCount = wf.length * 5;
    const bytesCount = ~~((bitsCount + 7) / 8);
    const result = new Uint8Array(bytesCount + 1);
    const dv = dataViewFromBuffer(result);
    for (let i = 0, j = 0; i < wf.length; i++, j += 5) {
      const byteIdx = ~~(j / 8);
      const bitShift = j % 8;
      const value = (wf[i] & 31) << bitShift;
      dv.setUint16(byteIdx, dv.getUint16(byteIdx, true) | value, true);
    }
    return result.slice(0, bytesCount);
  }
  class BaseService {
    constructor(opts) {
      __publicField(this, "_driver");
      __publicField(this, "_readerMap");
      __publicField(this, "_writerMap");
      __publicField(this, "_log");
      this._driver = opts.driver;
      this._readerMap = opts.readerMap;
      this._writerMap = opts.writerMap;
      this._log = opts.log;
    }
    _serializeTl(obj) {
      return TlBinaryWriter.serializeObject(this._writerMap, obj);
    }
    _deserializeTl(data2) {
      try {
        return TlBinaryReader.deserializeObject(this._readerMap, data2);
      } catch (e) {
        return null;
      }
    }
  }
  function isPresent(t2) {
    return t2 !== void 0 && t2 !== null;
  }
  function hasValueAtKey(k2, v) {
    return function(a) {
      return a[k2] === v;
    };
  }
  function assertTypeIs(context, obj, expected) {
    if (obj._ !== expected) {
      throw new MtTypeAssertionError(context, expected, obj._);
    }
  }
  function assertTypeIsNot(context, obj, expectedNot) {
    if (obj._ === expectedNot) {
      throw new MtTypeAssertionError(context, `not ${expectedNot}`, obj._);
    }
  }
  function mtpAssertTypeIs(context, obj, expected) {
    if (obj._ !== expected) {
      throw new MtTypeAssertionError(context, expected, obj._);
    }
  }
  function assertTrue(context, cond) {
    if (!cond) {
      throw new MtTypeAssertionError(context, "true", "false");
    }
  }
  function isTlRpcError(obj) {
    return typeof obj === "object" && obj !== null && obj._ === "mt_rpc_error";
  }
  const KV_CURRENT_USER = "current_user";
  function serialize(info) {
    if (!info)
      return new Uint8Array(0);
    const hasUsernames = info.usernames.length > 0;
    let usernamesOverhead = hasUsernames ? 4 : 0;
    for(let   username of info.usernames) {
      usernamesOverhead += TlSerializationCounter.countBytesOverhead(username.length) + username.length;
    }
    const writer2 = TlBinaryWriter.manual(16 + usernamesOverhead);
    writer2.int(1);
    let flags = 0;
    if (info.isBot)
      flags |= 1;
    if (hasUsernames)
      flags |= 2;
    if (info.isPremium)
      flags |= 4;
    writer2.int(flags);
    writer2.int53(info.userId);
    if (hasUsernames) {
      writer2.int(info.usernames.length);
      for(let   username of info.usernames) {
        writer2.string(username);
      }
    }
    return writer2.result();
  }
  function parse(data2) {
    if (data2.length === 0)
      return null;
    const reader2 = TlBinaryReader.manual(data2);
    if (reader2.int() !== 1)
      return null;
    const flags = reader2.int();
    const userId = reader2.int53();
    let usernames = [];
    if (flags & 2) {
      const len = reader2.int();
      usernames = new Array(len);
      for (let i = 0; i < len; i++) {
        usernames[i] = reader2.string();
      }
    }
    return {
      userId,
      isBot: (flags & 1) !== 0,
      isPremium: (flags & 4) !== 0,
      usernames
    };
  }
  class CurrentUserService extends BaseService {
    constructor(_kv, opts) {
      super(opts);
      __publicField(this, "_cached");
      this._kv = _kv;
    }
    store(info) {
      return __async(this, null, function* () {
        var _a2, _b;
        if (info && this._cached) {
          if (this._cached.userId === info.userId) {
            return;
          }
          this._cached.userId = info.userId;
          this._cached.isBot = info.isBot;
        } else {
          this._cached = info;
        }
        yield this._kv.set(KV_CURRENT_USER, serialize(info));
        yield (_b = (_a2 = this._driver).save) == null ? void 0 : _b.call(_a2);
      });
    }
    storeFrom(user) {
      return __async(this, null, function* () {
        assertTypeIs("storeFrom", user, "user");
        const obj = {
          userId: user.id,
          isBot: user.bot,
          isPremium: user.premium,
          usernames: extractUsernames(user)
        };
        yield this.store(obj);
        return obj;
      });
    }
    fetch() {
      return __async(this, null, function* () {
        if (this._cached)
          return this._cached;
        const data2 = yield this._kv.get(KV_CURRENT_USER);
        if (!data2)
          return null;
        const info = parse(data2);
        this._cached = info;
        return info;
      });
    }
    getCached(safe = false) {
      if (this._cached === void 0) {
        if (safe)
          return null;
        throw new MtArgumentError("User info is not cached yet");
      }
      return this._cached;
    }
    update(params) {
      return __async(this, null, function* () {
        const info = yield this.fetch();
        if (!info)
          return;
        const { username, usernames, isPremium } = params;
        if (isPremium !== void 0)
          info.isPremium = isPremium;
        if (username !== void 0) {
          info.usernames[0] = username;
        } else if (usernames !== void 0) {
          info.usernames = usernames;
        }
        return this.store(info);
      });
    }
  }
  const KV_PTS = "updates_pts";
  const KV_QTS = "updates_qts";
  const KV_DATE = "updates_date";
  const KV_SEQ = "updates_seq";
  const KV_CHANNEL_PREFIX = "updates_channel:";
  class UpdatesStateService extends BaseService {
    constructor(_kv, opts) {
      super(opts);
      this._kv = _kv;
    }
    _getInt(key) {
      return __async(this, null, function* () {
        const val = yield this._kv.get(key);
        if (!val)
          return null;
        return dataViewFromBuffer(val).getInt32(0, true);
      });
    }
    _setInt(key, val) {
      return __async(this, null, function* () {
        const buf = new Uint8Array(4);
        dataViewFromBuffer(buf).setInt32(0, val, true);
        yield this._kv.set(key, buf);
      });
    }
    getState() {
      return __async(this, null, function* () {
        const [pts, qts, date, seq] = yield Promise.all([
          this._getInt(KV_PTS),
          this._getInt(KV_QTS),
          this._getInt(KV_DATE),
          this._getInt(KV_SEQ)
        ]);
        if (pts === null || qts === null || date === null || seq === null) {
          return null;
        }
        return [pts, qts, date, seq];
      });
    }
    setPts(pts) {
      return __async(this, null, function* () {
        yield this._setInt(KV_PTS, pts);
      });
    }
    setQts(qts) {
      return __async(this, null, function* () {
        yield this._setInt(KV_QTS, qts);
      });
    }
    setDate(date) {
      return __async(this, null, function* () {
        yield this._setInt(KV_DATE, date);
      });
    }
    setSeq(seq) {
      return __async(this, null, function* () {
        yield this._setInt(KV_SEQ, seq);
      });
    }
    getChannelPts(channelId) {
      return __async(this, null, function* () {
        const val = yield this._kv.get(KV_CHANNEL_PREFIX + channelId);
        if (!val)
          return null;
        return dataViewFromBuffer(val).getUint32(0, true);
      });
    }
    setChannelPts(channelId, pts) {
      return __async(this, null, function* () {
        const buf = new Uint8Array(4);
        dataViewFromBuffer(buf).setUint32(0, pts, true);
        yield this._kv.set(KV_CHANNEL_PREFIX + channelId, buf);
      });
    }
    setManyChannelPts(cpts) {
      return __async(this, null, function* () {
        const promises = [];
        for(let   [channelId, pts] of cpts.entries()) {
          promises.push(this.setChannelPts(channelId, pts));
        }
        yield Promise.all(promises);
      });
    }
  }
  const KV_MAIN = "dc_main";
  const KV_MEDIA = "dc_media";
  class DefaultDcsService extends BaseService {
    constructor(_kv, opts) {
      super(opts);
      __publicField(this, "_cached");
      this._kv = _kv;
    }
    store(dcs) {
      return __async(this, null, function* () {
        if (this._cached) {
          if (this._cached.main === dcs.main && this._cached.media === dcs.media) {
            return;
          }
        }
        this._cached = dcs;
        const { main, media } = dcs;
        const mainData = serializeBasicDcOption(main);
        yield this._kv.set(KV_MAIN, mainData);
        if (media !== main) {
          const mediaData = serializeBasicDcOption(media);
          yield this._kv.set(KV_MEDIA, mediaData);
        } else {
          yield this._kv.delete(KV_MEDIA);
        }
      });
    }
    fetch() {
      return __async(this, null, function* () {
        if (this._cached)
          return this._cached;
        const [mainData, mediaData] = yield Promise.all([
          this._kv.get(KV_MAIN),
          this._kv.get(KV_MEDIA)
        ]);
        if (!mainData)
          return null;
        const main = parseBasicDcOption(mainData);
        if (!main)
          return null;
        const dcs = { main, media: main };
        if (mediaData) {
          const media = parseBasicDcOption(mediaData);
          if (media) {
            dcs.media = media;
          }
        }
        this._cached = dcs;
        return dcs;
      });
    }
  }
  class JSBI extends Array {
    constructor(i, _) {
      if (super(i), this.sign = _, Object.setPrototypeOf(this, JSBI.prototype), i > JSBI.__kMaxLength)
        throw new RangeError("Maximum BigInt size exceeded");
    }
    static BigInt(i) {
      var _ = Math.floor, t2 = Number.isFinite;
      if ("number" == typeof i) {
        if (0 === i)
          return JSBI.__zero();
        if (JSBI.__isOneDigitInt(i))
          return 0 > i ? JSBI.__oneDigit(-i, true) : JSBI.__oneDigit(i, false);
        if (!t2(i) || _(i) !== i)
          throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
        return JSBI.__fromDouble(i);
      }
      if ("string" == typeof i) {
        const _2 = JSBI.__fromString(i);
        if (null === _2)
          throw new SyntaxError("Cannot convert " + i + " to a BigInt");
        return _2;
      }
      if ("boolean" == typeof i)
        return true === i ? JSBI.__oneDigit(1, false) : JSBI.__zero();
      if ("object" == typeof i) {
        if (i.constructor === JSBI)
          return i;
        const _2 = JSBI.__toPrimitive(i);
        return JSBI.BigInt(_2);
      }
      throw new TypeError("Cannot convert " + i + " to a BigInt");
    }
    toDebugString() {
      const i = ["BigInt["];
      for(let   _ of this)
        i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
      return i.push("]"), i.join("");
    }
    toString(i = 10) {
      if (2 > i || 36 < i)
        throw new RangeError("toString() radix argument must be between 2 and 36");
      return 0 === this.length ? "0" : 0 == (i & i - 1) ? JSBI.__toStringBasePowerOfTwo(this, i) : JSBI.__toStringGeneric(this, i, false);
    }
    valueOf() {
      throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
    }
    static toNumber(i) {
      const _ = i.length;
      if (0 === _)
        return 0;
      if (1 === _) {
        const _2 = i.__unsignedDigit(0);
        return i.sign ? -_2 : _2;
      }
      const t2 = i.__digit(_ - 1), e = JSBI.__clz30(t2), n = 30 * _ - e;
      if (1024 < n)
        return i.sign ? -Infinity : 1 / 0;
      let g = n - 1, o = t2, s = _ - 1;
      const l = e + 3;
      let r = 32 === l ? 0 : o << l;
      r >>>= 12;
      const a = l - 12;
      let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l;
      for (0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s; )
        s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30;
      const h2 = JSBI.__decideRounding(i, d, s, o);
      if ((1 === h2 || 0 === h2 && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r++, 0 != r >>> 20 && (r = 0, g++, 1023 < g))))
        return i.sign ? -Infinity : 1 / 0;
      const m2 = i.sign ? -2147483648 : 0;
      return g = g + 1023 << 20, JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] = m2 | g | r, JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow] = u, JSBI.__kBitConversionDouble[0];
    }
    static unaryMinus(i) {
      if (0 === i.length)
        return i;
      const _ = i.__copy();
      return _.sign = !i.sign, _;
    }
    static bitwiseNot(i) {
      return i.sign ? JSBI.__absoluteSubOne(i).__trim() : JSBI.__absoluteAddOne(i, true);
    }
    static exponentiate(i, _) {
      if (_.sign)
        throw new RangeError("Exponent must be positive");
      if (0 === _.length)
        return JSBI.__oneDigit(1, false);
      if (0 === i.length)
        return i;
      if (1 === i.length && 1 === i.__digit(0))
        return i.sign && 0 == (1 & _.__digit(0)) ? JSBI.unaryMinus(i) : i;
      if (1 < _.length)
        throw new RangeError("BigInt too big");
      let t2 = _.__unsignedDigit(0);
      if (1 === t2)
        return i;
      if (t2 >= JSBI.__kMaxLengthBits)
        throw new RangeError("BigInt too big");
      if (1 === i.length && 2 === i.__digit(0)) {
        const _2 = 1 + (0 | t2 / 30), e2 = i.sign && 0 != (1 & t2), n2 = new JSBI(_2, e2);
        n2.__initializeDigits();
        const g = 1 << t2 % 30;
        return n2.__setDigit(_2 - 1, g), n2;
      }
      let e = null, n = i;
      for (0 != (1 & t2) && (e = i), t2 >>= 1; 0 !== t2; t2 >>= 1)
        n = JSBI.multiply(n, n), 0 != (1 & t2) && (null === e ? e = n : e = JSBI.multiply(e, n));
      return e;
    }
    static multiply(_, t2) {
      if (0 === _.length)
        return _;
      if (0 === t2.length)
        return t2;
      let i = _.length + t2.length;
      30 <= _.__clzmsd() + t2.__clzmsd() && i--;
      const e = new JSBI(i, _.sign !== t2.sign);
      e.__initializeDigits();
      for (let n = 0; n < _.length; n++)
        JSBI.__multiplyAccumulate(t2, _.__digit(n), e, n);
      return e.__trim();
    }
    static divide(i, _) {
      if (0 === _.length)
        throw new RangeError("Division by zero");
      if (0 > JSBI.__absoluteCompare(i, _))
        return JSBI.__zero();
      const t2 = i.sign !== _.sign, e = _.__unsignedDigit(0);
      let n;
      if (1 === _.length && 32767 >= e) {
        if (1 === e)
          return t2 === i.sign ? i : JSBI.unaryMinus(i);
        n = JSBI.__absoluteDivSmall(i, e, null);
      } else
        n = JSBI.__absoluteDivLarge(i, _, true, false);
      return n.sign = t2, n.__trim();
    }
    static remainder(i, _) {
      if (0 === _.length)
        throw new RangeError("Division by zero");
      if (0 > JSBI.__absoluteCompare(i, _))
        return i;
      const t2 = _.__unsignedDigit(0);
      if (1 === _.length && 32767 >= t2) {
        if (1 === t2)
          return JSBI.__zero();
        const _2 = JSBI.__absoluteModSmall(i, t2);
        return 0 === _2 ? JSBI.__zero() : JSBI.__oneDigit(_2, i.sign);
      }
      const e = JSBI.__absoluteDivLarge(i, _, false, true);
      return e.sign = i.sign, e.__trim();
    }
    static add(i, _) {
      const t2 = i.sign;
      return t2 === _.sign ? JSBI.__absoluteAdd(i, _, t2) : 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t2) : JSBI.__absoluteSub(_, i, !t2);
    }
    static subtract(i, _) {
      const t2 = i.sign;
      return t2 === _.sign ? 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t2) : JSBI.__absoluteSub(_, i, !t2) : JSBI.__absoluteAdd(i, _, t2);
    }
    static leftShift(i, _) {
      return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__rightShiftByAbsolute(i, _) : JSBI.__leftShiftByAbsolute(i, _);
    }
    static signedRightShift(i, _) {
      return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__leftShiftByAbsolute(i, _) : JSBI.__rightShiftByAbsolute(i, _);
    }
    static unsignedRightShift() {
      throw new TypeError("BigInts have no unsigned right shift; use >> instead");
    }
    static lessThan(i, _) {
      return 0 > JSBI.__compareToBigInt(i, _);
    }
    static lessThanOrEqual(i, _) {
      return 0 >= JSBI.__compareToBigInt(i, _);
    }
    static greaterThan(i, _) {
      return 0 < JSBI.__compareToBigInt(i, _);
    }
    static greaterThanOrEqual(i, _) {
      return 0 <= JSBI.__compareToBigInt(i, _);
    }
    static equal(_, t2) {
      if (_.sign !== t2.sign)
        return false;
      if (_.length !== t2.length)
        return false;
      for (let e = 0; e < _.length; e++)
        if (_.__digit(e) !== t2.__digit(e))
          return false;
      return true;
    }
    static notEqual(i, _) {
      return !JSBI.equal(i, _);
    }
    static bitwiseAnd(i, _) {
      var t2 = Math.max;
      if (!i.sign && !_.sign)
        return JSBI.__absoluteAnd(i, _).__trim();
      if (i.sign && _.sign) {
        const e = t2(i.length, _.length) + 1;
        let n = JSBI.__absoluteSubOne(i, e);
        const g = JSBI.__absoluteSubOne(_);
        return n = JSBI.__absoluteOr(n, g, n), JSBI.__absoluteAddOne(n, true, n).__trim();
      }
      return i.sign && ([i, _] = [_, i]), JSBI.__absoluteAndNot(i, JSBI.__absoluteSubOne(_)).__trim();
    }
    static bitwiseXor(i, _) {
      var t2 = Math.max;
      if (!i.sign && !_.sign)
        return JSBI.__absoluteXor(i, _).__trim();
      if (i.sign && _.sign) {
        const e2 = t2(i.length, _.length), n2 = JSBI.__absoluteSubOne(i, e2), g = JSBI.__absoluteSubOne(_);
        return JSBI.__absoluteXor(n2, g, n2).__trim();
      }
      const e = t2(i.length, _.length) + 1;
      i.sign && ([i, _] = [_, i]);
      let n = JSBI.__absoluteSubOne(_, e);
      return n = JSBI.__absoluteXor(n, i, n), JSBI.__absoluteAddOne(n, true, n).__trim();
    }
    static bitwiseOr(i, _) {
      var t2 = Math.max;
      const e = t2(i.length, _.length);
      if (!i.sign && !_.sign)
        return JSBI.__absoluteOr(i, _).__trim();
      if (i.sign && _.sign) {
        let t3 = JSBI.__absoluteSubOne(i, e);
        const n2 = JSBI.__absoluteSubOne(_);
        return t3 = JSBI.__absoluteAnd(t3, n2, t3), JSBI.__absoluteAddOne(t3, true, t3).__trim();
      }
      i.sign && ([i, _] = [_, i]);
      let n = JSBI.__absoluteSubOne(_, e);
      return n = JSBI.__absoluteAndNot(n, i, n), JSBI.__absoluteAddOne(n, true, n).__trim();
    }
    static asIntN(_, t2) {
      var i = Math.floor;
      if (0 === t2.length)
        return t2;
      if (_ = i(_), 0 > _)
        throw new RangeError("Invalid value: not (convertible to) a safe integer");
      if (0 === _)
        return JSBI.__zero();
      if (_ >= JSBI.__kMaxLengthBits)
        return t2;
      const e = 0 | (_ + 29) / 30;
      if (t2.length < e)
        return t2;
      const g = t2.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30;
      if (t2.length === e && g < o)
        return t2;
      if (!((g & o) === o))
        return JSBI.__truncateToNBits(_, t2);
      if (!t2.sign)
        return JSBI.__truncateAndSubFromPowerOfTwo(_, t2, true);
      if (0 == (g & o - 1)) {
        for (let n = e - 2; 0 <= n; n--)
          if (0 !== t2.__digit(n))
            return JSBI.__truncateAndSubFromPowerOfTwo(_, t2, false);
        return t2.length === e && g === o ? t2 : JSBI.__truncateToNBits(_, t2);
      }
      return JSBI.__truncateAndSubFromPowerOfTwo(_, t2, false);
    }
    static asUintN(i, _) {
      var t2 = Math.floor;
      if (0 === _.length)
        return _;
      if (i = t2(i), 0 > i)
        throw new RangeError("Invalid value: not (convertible to) a safe integer");
      if (0 === i)
        return JSBI.__zero();
      if (_.sign) {
        if (i > JSBI.__kMaxLengthBits)
          throw new RangeError("BigInt too big");
        return JSBI.__truncateAndSubFromPowerOfTwo(i, _, false);
      }
      if (i >= JSBI.__kMaxLengthBits)
        return _;
      const e = 0 | (i + 29) / 30;
      if (_.length < e)
        return _;
      const g = i % 30;
      if (_.length == e) {
        if (0 === g)
          return _;
        const i2 = _.__digit(e - 1);
        if (0 == i2 >>> g)
          return _;
      }
      return JSBI.__truncateToNBits(i, _);
    }
    static ADD(i, _) {
      if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i)
        return "string" != typeof _ && (_ = _.toString()), i + _;
      if ("string" == typeof _)
        return i.toString() + _;
      if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i) && JSBI.__isBigInt(_))
        return JSBI.add(i, _);
      if ("number" == typeof i && "number" == typeof _)
        return i + _;
      throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
    }
    static LT(i, _) {
      return JSBI.__compare(i, _, 0);
    }
    static LE(i, _) {
      return JSBI.__compare(i, _, 1);
    }
    static GT(i, _) {
      return JSBI.__compare(i, _, 2);
    }
    static GE(i, _) {
      return JSBI.__compare(i, _, 3);
    }
    static EQ(i, _) {
      for (; ; ) {
        if (JSBI.__isBigInt(i))
          return JSBI.__isBigInt(_) ? JSBI.equal(i, _) : JSBI.EQ(_, i);
        if ("number" == typeof i) {
          if (JSBI.__isBigInt(_))
            return JSBI.__equalToNumber(_, i);
          if ("object" != typeof _)
            return i == _;
          _ = JSBI.__toPrimitive(_);
        } else if ("string" == typeof i) {
          if (JSBI.__isBigInt(_))
            return i = JSBI.__fromString(i), null !== i && JSBI.equal(i, _);
          if ("object" != typeof _)
            return i == _;
          _ = JSBI.__toPrimitive(_);
        } else if ("boolean" == typeof i) {
          if (JSBI.__isBigInt(_))
            return JSBI.__equalToNumber(_, +i);
          if ("object" != typeof _)
            return i == _;
          _ = JSBI.__toPrimitive(_);
        } else if ("symbol" == typeof i) {
          if (JSBI.__isBigInt(_))
            return false;
          if ("object" != typeof _)
            return i == _;
          _ = JSBI.__toPrimitive(_);
        } else if ("object" == typeof i) {
          if ("object" == typeof _ && _.constructor !== JSBI)
            return i == _;
          i = JSBI.__toPrimitive(i);
        } else
          return i == _;
      }
    }
    static NE(i, _) {
      return !JSBI.EQ(i, _);
    }
    static DataViewGetBigInt64(i, _, t2 = false) {
      return JSBI.asIntN(64, JSBI.DataViewGetBigUint64(i, _, t2));
    }
    static DataViewGetBigUint64(i, _, t2 = false) {
      const [e, n] = t2 ? [4, 0] : [0, 4], g = i.getUint32(_ + e, t2), o = i.getUint32(_ + n, t2), s = new JSBI(3, false);
      return s.__setDigit(0, 1073741823 & o), s.__setDigit(1, (268435455 & g) << 2 | o >>> 30), s.__setDigit(2, g >>> 28), s.__trim();
    }
    static DataViewSetBigInt64(i, _, t2, e = false) {
      JSBI.DataViewSetBigUint64(i, _, t2, e);
    }
    static DataViewSetBigUint64(i, _, t2, e = false) {
      t2 = JSBI.asUintN(64, t2);
      let n = 0, g = 0;
      if (0 < t2.length && (g = t2.__digit(0), 1 < t2.length)) {
        const i2 = t2.__digit(1);
        g |= i2 << 30, n = i2 >>> 2, 2 < t2.length && (n |= t2.__digit(2) << 28);
      }
      const [o, s] = e ? [4, 0] : [0, 4];
      i.setUint32(_ + o, n, e), i.setUint32(_ + s, g, e);
    }
    static __zero() {
      return new JSBI(0, false);
    }
    static __oneDigit(i, _) {
      const t2 = new JSBI(1, _);
      return t2.__setDigit(0, i), t2;
    }
    __copy() {
      const _ = new JSBI(this.length, this.sign);
      for (let t2 = 0; t2 < this.length; t2++)
        _[t2] = this[t2];
      return _;
    }
    __trim() {
      let i = this.length, _ = this[i - 1];
      for (; 0 === _; )
        i--, _ = this[i - 1], this.pop();
      return 0 === i && (this.sign = false), this;
    }
    __initializeDigits() {
      for (let _ = 0; _ < this.length; _++)
        this[_] = 0;
    }
    static __decideRounding(i, _, t2, e) {
      if (0 < _)
        return -1;
      let n;
      if (0 > _)
        n = -_ - 1;
      else {
        if (0 === t2)
          return -1;
        t2--, e = i.__digit(t2), n = 29;
      }
      let g = 1 << n;
      if (0 == (e & g))
        return -1;
      if (g -= 1, 0 != (e & g))
        return 1;
      for (; 0 < t2; )
        if (t2--, 0 !== i.__digit(t2))
          return 1;
      return 0;
    }
    static __fromDouble(i) {
      JSBI.__kBitConversionDouble[0] = i;
      const _ = 2047 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] >>> 20, t2 = _ - 1023, e = (0 | t2 / 30) + 1, n = new JSBI(e, 0 > i);
      let g = 1048575 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] | 1048576, o = JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow];
      const s = 20, l = t2 % 30;
      let r, a = 0;
      if (l < 20) {
        const i2 = s - l;
        a = i2 + 32, r = g >>> i2, g = g << 32 - i2 | o >>> i2, o <<= 32 - i2;
      } else if (l === 20)
        a = 32, r = g, g = o, o = 0;
      else {
        const i2 = l - s;
        a = 32 - i2, r = g << i2 | o >>> 32 - i2, g = o << i2, o = 0;
      }
      n.__setDigit(e - 1, r);
      for (let _2 = e - 2; 0 <= _2; _2--)
        0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_2, r);
      return n.__trim();
    }
    static __isWhitespace(i) {
      return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);
    }
    static __fromString(i, _ = 0) {
      let t2 = 0;
      const e = i.length;
      let n = 0;
      if (n === e)
        return JSBI.__zero();
      let g = i.charCodeAt(n);
      for (; JSBI.__isWhitespace(g); ) {
        if (++n === e)
          return JSBI.__zero();
        g = i.charCodeAt(n);
      }
      if (43 === g) {
        if (++n === e)
          return null;
        g = i.charCodeAt(n), t2 = 1;
      } else if (45 === g) {
        if (++n === e)
          return null;
        g = i.charCodeAt(n), t2 = -1;
      }
      if (0 === _) {
        if (_ = 10, 48 === g) {
          if (++n === e)
            return JSBI.__zero();
          if (g = i.charCodeAt(n), 88 === g || 120 === g) {
            if (_ = 16, ++n === e)
              return null;
            g = i.charCodeAt(n);
          } else if (79 === g || 111 === g) {
            if (_ = 8, ++n === e)
              return null;
            g = i.charCodeAt(n);
          } else if (66 === g || 98 === g) {
            if (_ = 2, ++n === e)
              return null;
            g = i.charCodeAt(n);
          }
        }
      } else if (16 === _ && 48 === g) {
        if (++n === e)
          return JSBI.__zero();
        if (g = i.charCodeAt(n), 88 === g || 120 === g) {
          if (++n === e)
            return null;
          g = i.charCodeAt(n);
        }
      }
      if (0 != t2 && 10 !== _)
        return null;
      for (; 48 === g; ) {
        if (++n === e)
          return JSBI.__zero();
        g = i.charCodeAt(n);
      }
      const o = e - n;
      let s = JSBI.__kMaxBitsPerChar[_], l = JSBI.__kBitsPerCharTableMultiplier - 1;
      if (o > 1073741824 / s)
        return null;
      const r = s * o + l >>> JSBI.__kBitsPerCharTableShift, a = new JSBI(0 | (r + 29) / 30, false), u = 10 > _ ? _ : 10, h2 = 10 < _ ? _ - 10 : 0;
      if (0 == (_ & _ - 1)) {
        s >>= JSBI.__kBitsPerCharTableShift;
        const _2 = [], t3 = [];
        let o2 = false;
        do {
          let l2 = 0, r2 = 0;
          for (; ; ) {
            let _3;
            if (g - 48 >>> 0 < u)
              _3 = g - 48;
            else if ((32 | g) - 97 >>> 0 < h2)
              _3 = (32 | g) - 87;
            else {
              o2 = true;
              break;
            }
            if (r2 += s, l2 = l2 << s | _3, ++n === e) {
              o2 = true;
              break;
            }
            if (g = i.charCodeAt(n), 30 < r2 + s)
              break;
          }
          _2.push(l2), t3.push(r2);
        } while (!o2);
        JSBI.__fillFromParts(a, _2, t3);
      } else {
        a.__initializeDigits();
        let t3 = false, o2 = 0;
        do {
          let r2 = 0, b = 1;
          for (; ; ) {
            let s2;
            if (g - 48 >>> 0 < u)
              s2 = g - 48;
            else if ((32 | g) - 97 >>> 0 < h2)
              s2 = (32 | g) - 87;
            else {
              t3 = true;
              break;
            }
            const l2 = b * _;
            if (1073741823 < l2)
              break;
            if (b = l2, r2 = r2 * _ + s2, o2++, ++n === e) {
              t3 = true;
              break;
            }
            g = i.charCodeAt(n);
          }
          l = 30 * JSBI.__kBitsPerCharTableMultiplier - 1;
          const D = 0 | (s * o2 + l >>> JSBI.__kBitsPerCharTableShift) / 30;
          a.__inplaceMultiplyAdd(b, r2, D);
        } while (!t3);
      }
      if (n !== e) {
        if (!JSBI.__isWhitespace(g))
          return null;
        for (n++; n < e; n++)
          if (g = i.charCodeAt(n), !JSBI.__isWhitespace(g))
            return null;
      }
      return a.sign = -1 == t2, a.__trim();
    }
    static __fillFromParts(_, t2, e) {
      let n = 0, g = 0, o = 0;
      for (let s = t2.length - 1; 0 <= s; s--) {
        const i = t2[s], l = e[s];
        g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);
      }
      if (0 !== g) {
        if (n >= _.length)
          throw new Error("implementation bug");
        _.__setDigit(n++, g);
      }
      for (; n < _.length; n++)
        _.__setDigit(n, 0);
    }
    static __toStringBasePowerOfTwo(_, i) {
      const t2 = _.length;
      let e = i - 1;
      e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
      const n = e, g = i - 1, o = _.__digit(t2 - 1), s = JSBI.__clz30(o);
      let l = 0 | (30 * t2 - s + n - 1) / n;
      if (_.sign && l++, 268435456 < l)
        throw new Error("string too long");
      const r = Array(l);
      let a = l - 1, u = 0, d = 0;
      for (let e2 = 0; e2 < t2 - 1; e2++) {
        const i2 = _.__digit(e2), t3 = (u | i2 << d) & g;
        r[a--] = JSBI.__kConversionChars[t3];
        const o2 = n - d;
        for (u = i2 >>> o2, d = 30 - o2; d >= n; )
          r[a--] = JSBI.__kConversionChars[u & g], u >>>= n, d -= n;
      }
      const h2 = (u | o << d) & g;
      for (r[a--] = JSBI.__kConversionChars[h2], u = o >>> n - d; 0 !== u; )
        r[a--] = JSBI.__kConversionChars[u & g], u >>>= n;
      if (_.sign && (r[a--] = "-"), -1 != a)
        throw new Error("implementation bug");
      return r.join("");
    }
    static __toStringGeneric(_, i, t2) {
      const e = _.length;
      if (0 === e)
        return "";
      if (1 === e) {
        let e2 = _.__unsignedDigit(0).toString(i);
        return false === t2 && _.sign && (e2 = "-" + e2), e2;
      }
      const n = 30 * e - JSBI.__clz30(_.__digit(e - 1)), g = JSBI.__kMaxBitsPerChar[i], o = g - 1;
      let s = n * JSBI.__kBitsPerCharTableMultiplier;
      s += o - 1, s = 0 | s / o;
      const l = s + 1 >> 1, r = JSBI.exponentiate(JSBI.__oneDigit(i, false), JSBI.__oneDigit(l, false));
      let a, u;
      const d = r.__unsignedDigit(0);
      if (1 === r.length && 32767 >= d) {
        a = new JSBI(_.length, false), a.__initializeDigits();
        let t3 = 0;
        for (let e2 = 2 * _.length - 1; 0 <= e2; e2--) {
          const i2 = t3 << 15 | _.__halfDigit(e2);
          a.__setHalfDigit(e2, 0 | i2 / d), t3 = 0 | i2 % d;
        }
        u = t3.toString(i);
      } else {
        const t3 = JSBI.__absoluteDivLarge(_, r, true, true);
        a = t3.quotient;
        const e2 = t3.remainder.__trim();
        u = JSBI.__toStringGeneric(e2, i, true);
      }
      a.__trim();
      let h2 = JSBI.__toStringGeneric(a, i, true);
      for (; u.length < l; )
        u = "0" + u;
      return false === t2 && _.sign && (h2 = "-" + h2), h2 + u;
    }
    static __unequalSign(i) {
      return i ? -1 : 1;
    }
    static __absoluteGreater(i) {
      return i ? -1 : 1;
    }
    static __absoluteLess(i) {
      return i ? 1 : -1;
    }
    static __compareToBigInt(i, _) {
      const t2 = i.sign;
      if (t2 !== _.sign)
        return JSBI.__unequalSign(t2);
      const e = JSBI.__absoluteCompare(i, _);
      return 0 < e ? JSBI.__absoluteGreater(t2) : 0 > e ? JSBI.__absoluteLess(t2) : 0;
    }
    static __compareToNumber(i, _) {
      if (JSBI.__isOneDigitInt(_)) {
        const t2 = i.sign, e = 0 > _;
        if (t2 !== e)
          return JSBI.__unequalSign(t2);
        if (0 === i.length) {
          if (e)
            throw new Error("implementation bug");
          return 0 === _ ? 0 : -1;
        }
        if (1 < i.length)
          return JSBI.__absoluteGreater(t2);
        const n = Math.abs(_), g = i.__unsignedDigit(0);
        return g > n ? JSBI.__absoluteGreater(t2) : g < n ? JSBI.__absoluteLess(t2) : 0;
      }
      return JSBI.__compareToDouble(i, _);
    }
    static __compareToDouble(i, _) {
      if (_ !== _)
        return _;
      if (_ === 1 / 0)
        return -1;
      if (_ === -Infinity)
        return 1;
      const t2 = i.sign;
      if (t2 !== 0 > _)
        return JSBI.__unequalSign(t2);
      if (0 === _)
        throw new Error("implementation bug: should be handled elsewhere");
      if (0 === i.length)
        return -1;
      JSBI.__kBitConversionDouble[0] = _;
      const e = 2047 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh] >>> 20;
      if (2047 == e)
        throw new Error("implementation bug: handled elsewhere");
      const n = e - 1023;
      if (0 > n)
        return JSBI.__absoluteGreater(t2);
      const g = i.length;
      let o = i.__digit(g - 1);
      const s = JSBI.__clz30(o), l = 30 * g - s, r = n + 1;
      if (l < r)
        return JSBI.__absoluteLess(t2);
      if (l > r)
        return JSBI.__absoluteGreater(t2);
      let a = 1048576 | 1048575 & JSBI.__kBitConversionInts[JSBI.__kBitConversionIntHigh], u = JSBI.__kBitConversionInts[JSBI.__kBitConversionIntLow];
      const d = 20, h2 = 29 - s;
      if (h2 !== (0 | (l - 1) % 30))
        throw new Error("implementation bug");
      let m2, b = 0;
      if (20 > h2) {
        const i2 = d - h2;
        b = i2 + 32, m2 = a >>> i2, a = a << 32 - i2 | u >>> i2, u <<= 32 - i2;
      } else if (20 === h2)
        b = 32, m2 = a, a = u, u = 0;
      else {
        const i2 = h2 - d;
        b = 32 - i2, m2 = a << i2 | u >>> 32 - i2, a = u << i2, u = 0;
      }
      if (o >>>= 0, m2 >>>= 0, o > m2)
        return JSBI.__absoluteGreater(t2);
      if (o < m2)
        return JSBI.__absoluteLess(t2);
      for (let e2 = g - 2; 0 <= e2; e2--) {
        0 < b ? (b -= 30, m2 = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m2 = 0;
        const _2 = i.__unsignedDigit(e2);
        if (_2 > m2)
          return JSBI.__absoluteGreater(t2);
        if (_2 < m2)
          return JSBI.__absoluteLess(t2);
      }
      if (0 !== a || 0 !== u) {
        if (0 === b)
          throw new Error("implementation bug");
        return JSBI.__absoluteLess(t2);
      }
      return 0;
    }
    static __equalToNumber(i, _) {
      var t2 = Math.abs;
      return JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t2(_) : 0 === JSBI.__compareToDouble(i, _);
    }
    static __comparisonResultToBool(i, _) {
      return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;
    }
    static __compare(i, _, t2) {
      if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _)
        switch (t2) {
          case 0:
            return i < _;
          case 1:
            return i <= _;
          case 2:
            return i > _;
          case 3:
            return i >= _;
        }
      if (JSBI.__isBigInt(i) && "string" == typeof _)
        return _ = JSBI.__fromString(_), null !== _ && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t2);
      if ("string" == typeof i && JSBI.__isBigInt(_))
        return i = JSBI.__fromString(i), null !== i && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t2);
      if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i)) {
        if (JSBI.__isBigInt(_))
          return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t2);
        if ("number" != typeof _)
          throw new Error("implementation bug");
        return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i, _), t2);
      }
      if ("number" != typeof i)
        throw new Error("implementation bug");
      if (JSBI.__isBigInt(_))
        return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_, i), 2 ^ t2);
      if ("number" != typeof _)
        throw new Error("implementation bug");
      return 0 === t2 ? i < _ : 1 === t2 ? i <= _ : 2 === t2 ? i > _ : 3 === t2 ? i >= _ : void 0;
    }
    __clzmsd() {
      return JSBI.__clz30(this.__digit(this.length - 1));
    }
    static __absoluteAdd(_, t2, e) {
      if (_.length < t2.length)
        return JSBI.__absoluteAdd(t2, _, e);
      if (0 === _.length)
        return _;
      if (0 === t2.length)
        return _.sign === e ? _ : JSBI.unaryMinus(_);
      let n = _.length;
      (0 === _.__clzmsd() || t2.length === _.length && 0 === t2.__clzmsd()) && n++;
      const g = new JSBI(n, e);
      let o = 0, s = 0;
      for (; s < t2.length; s++) {
        const i = _.__digit(s) + t2.__digit(s) + o;
        o = i >>> 30, g.__setDigit(s, 1073741823 & i);
      }
      for (; s < _.length; s++) {
        const i = _.__digit(s) + o;
        o = i >>> 30, g.__setDigit(s, 1073741823 & i);
      }
      return s < g.length && g.__setDigit(s, o), g.__trim();
    }
    static __absoluteSub(_, t2, e) {
      if (0 === _.length)
        return _;
      if (0 === t2.length)
        return _.sign === e ? _ : JSBI.unaryMinus(_);
      const n = new JSBI(_.length, e);
      let g = 0, o = 0;
      for (; o < t2.length; o++) {
        const i = _.__digit(o) - t2.__digit(o) - g;
        g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
      }
      for (; o < _.length; o++) {
        const i = _.__digit(o) - g;
        g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
      }
      return n.__trim();
    }
    static __absoluteAddOne(_, i, t2 = null) {
      const e = _.length;
      null === t2 ? t2 = new JSBI(e, i) : t2.sign = i;
      let n = 1;
      for (let g = 0; g < e; g++) {
        const i2 = _.__digit(g) + n;
        n = i2 >>> 30, t2.__setDigit(g, 1073741823 & i2);
      }
      return 0 != n && t2.__setDigitGrow(e, 1), t2;
    }
    static __absoluteSubOne(_, t2) {
      const e = _.length;
      t2 = t2 || e;
      const n = new JSBI(t2, false);
      let g = 1;
      for (let o = 0; o < e; o++) {
        const i = _.__digit(o) - g;
        g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
      }
      if (0 != g)
        throw new Error("implementation bug");
      for (let g2 = e; g2 < t2; g2++)
        n.__setDigit(g2, 0);
      return n;
    }
    static __absoluteAnd(_, t2, e = null) {
      let n = _.length, g = t2.length, o = g;
      if (n < g) {
        o = n;
        const i = _, e2 = n;
        _ = t2, n = g, t2 = i, g = e2;
      }
      let s = o;
      null === e ? e = new JSBI(s, false) : s = e.length;
      let l = 0;
      for (; l < o; l++)
        e.__setDigit(l, _.__digit(l) & t2.__digit(l));
      for (; l < s; l++)
        e.__setDigit(l, 0);
      return e;
    }
    static __absoluteAndNot(_, t2, e = null) {
      const n = _.length, g = t2.length;
      let o = g;
      n < g && (o = n);
      let s = n;
      null === e ? e = new JSBI(s, false) : s = e.length;
      let l = 0;
      for (; l < o; l++)
        e.__setDigit(l, _.__digit(l) & ~t2.__digit(l));
      for (; l < n; l++)
        e.__setDigit(l, _.__digit(l));
      for (; l < s; l++)
        e.__setDigit(l, 0);
      return e;
    }
    static __absoluteOr(_, t2, e = null) {
      let n = _.length, g = t2.length, o = g;
      if (n < g) {
        o = n;
        const i = _, e2 = n;
        _ = t2, n = g, t2 = i, g = e2;
      }
      let s = n;
      null === e ? e = new JSBI(s, false) : s = e.length;
      let l = 0;
      for (; l < o; l++)
        e.__setDigit(l, _.__digit(l) | t2.__digit(l));
      for (; l < n; l++)
        e.__setDigit(l, _.__digit(l));
      for (; l < s; l++)
        e.__setDigit(l, 0);
      return e;
    }
    static __absoluteXor(_, t2, e = null) {
      let n = _.length, g = t2.length, o = g;
      if (n < g) {
        o = n;
        const i = _, e2 = n;
        _ = t2, n = g, t2 = i, g = e2;
      }
      let s = n;
      null === e ? e = new JSBI(s, false) : s = e.length;
      let l = 0;
      for (; l < o; l++)
        e.__setDigit(l, _.__digit(l) ^ t2.__digit(l));
      for (; l < n; l++)
        e.__setDigit(l, _.__digit(l));
      for (; l < s; l++)
        e.__setDigit(l, 0);
      return e;
    }
    static __absoluteCompare(_, t2) {
      const e = _.length - t2.length;
      if (0 != e)
        return e;
      let n = _.length - 1;
      for (; 0 <= n && _.__digit(n) === t2.__digit(n); )
        n--;
      return 0 > n ? 0 : _.__unsignedDigit(n) > t2.__unsignedDigit(n) ? 1 : -1;
    }
    static __multiplyAccumulate(_, t2, e, n) {
      if (0 === t2)
        return;
      const g = 32767 & t2, o = t2 >>> 15;
      let s = 0, l = 0;
      for (let r, a = 0; a < _.length; a++, n++) {
        r = e.__digit(n);
        const i = _.__digit(a), t3 = 32767 & i, u = i >>> 15, d = JSBI.__imul(t3, g), h2 = JSBI.__imul(t3, o), m2 = JSBI.__imul(u, g), b = JSBI.__imul(u, o);
        r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h2) << 15) + ((32767 & m2) << 15), s += r >>> 30, l = b + (h2 >>> 15) + (m2 >>> 15), e.__setDigit(n, 1073741823 & r);
      }
      for (; 0 != s || 0 !== l; n++) {
        let i = e.__digit(n);
        i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i);
      }
    }
    static __internalMultiplyAdd(_, t2, e, g, o) {
      let s = e, l = 0;
      for (let n = 0; n < g; n++) {
        const i = _.__digit(n), e2 = JSBI.__imul(32767 & i, t2), g2 = JSBI.__imul(i >>> 15, t2), a = e2 + ((32767 & g2) << 15) + l + s;
        s = a >>> 30, l = g2 >>> 15, o.__setDigit(n, 1073741823 & a);
      }
      if (o.length > g)
        for (o.__setDigit(g++, s + l); g < o.length; )
          o.__setDigit(g++, 0);
      else if (0 !== s + l)
        throw new Error("implementation bug");
    }
    __inplaceMultiplyAdd(i, _, t2) {
      t2 > this.length && (t2 = this.length);
      const e = 32767 & i, n = i >>> 15;
      let g = 0, o = _;
      for (let s = 0; s < t2; s++) {
        const i2 = this.__digit(s), _2 = 32767 & i2, t3 = i2 >>> 15, l = JSBI.__imul(_2, e), r = JSBI.__imul(_2, n), a = JSBI.__imul(t3, e), u = JSBI.__imul(t3, n);
        let d = o + l + g;
        g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
      }
      if (0 != g || 0 !== o)
        throw new Error("implementation bug");
    }
    static __absoluteDivSmall(_, t2, e = null) {
      null === e && (e = new JSBI(_.length, false));
      let n = 0;
      for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) {
        g = (n << 15 | _.__halfDigit(o)) >>> 0;
        const i = 0 | g / t2;
        n = 0 | g % t2, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;
        const s = 0 | g / t2;
        n = 0 | g % t2, e.__setDigit(o >>> 1, i << 15 | s);
      }
      return e;
    }
    static __absoluteModSmall(_, t2) {
      let e = 0;
      for (let n = 2 * _.length - 1; 0 <= n; n--) {
        const i = (e << 15 | _.__halfDigit(n)) >>> 0;
        e = 0 | i % t2;
      }
      return e;
    }
    static __absoluteDivLarge(i, _, t2, e) {
      const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g;
      let s = null;
      t2 && (s = new JSBI(o + 2 >>> 1, false), s.__initializeDigits());
      const l = new JSBI(g + 2 >>> 1, false);
      l.__initializeDigits();
      const r = JSBI.__clz15(_.__halfDigit(g - 1));
      0 < r && (_ = JSBI.__specialLeftShift(_, r, 0));
      const a = JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1);
      let d = 0;
      for (let r2, h2 = o; 0 <= h2; h2--) {
        r2 = 32767;
        const i2 = a.__halfDigit(h2 + g);
        if (i2 !== u) {
          const t3 = (i2 << 15 | a.__halfDigit(h2 + g - 1)) >>> 0;
          r2 = 0 | t3 / u;
          let e3 = 0 | t3 % u;
          const n2 = _.__halfDigit(g - 2), o2 = a.__halfDigit(h2 + g - 2);
          for (; JSBI.__imul(r2, n2) >>> 0 > (e3 << 16 | o2) >>> 0 && (r2--, e3 += u, !(32767 < e3)); )
            ;
        }
        JSBI.__internalMultiplyAdd(_, r2, 0, n, l);
        let e2 = a.__inplaceSub(l, h2, g + 1);
        0 !== e2 && (e2 = a.__inplaceAdd(_, h2, g), a.__setHalfDigit(h2 + g, 32767 & a.__halfDigit(h2 + g) + e2), r2--), t2 && (1 & h2 ? d = r2 << 15 : s.__setDigit(h2 >>> 1, d | r2));
      }
      if (e)
        return a.__inplaceRightShift(r), t2 ? { quotient: s, remainder: a } : a;
      if (t2)
        return s;
      throw new Error("unreachable");
    }
    static __clz15(i) {
      return JSBI.__clz30(i) - 15;
    }
    __inplaceAdd(_, t2, e) {
      let n = 0;
      for (let g = 0; g < e; g++) {
        const i = this.__halfDigit(t2 + g) + _.__halfDigit(g) + n;
        n = i >>> 15, this.__setHalfDigit(t2 + g, 32767 & i);
      }
      return n;
    }
    __inplaceSub(_, t2, e) {
      let n = 0;
      if (1 & t2) {
        t2 >>= 1;
        let g = this.__digit(t2), o = 32767 & g, s = 0;
        for (; s < e - 1 >>> 1; s++) {
          const i2 = _.__digit(s), e2 = (g >>> 15) - (32767 & i2) - n;
          n = 1 & e2 >>> 15, this.__setDigit(t2 + s, (32767 & e2) << 15 | 32767 & o), g = this.__digit(t2 + s + 1), o = (32767 & g) - (i2 >>> 15) - n, n = 1 & o >>> 15;
        }
        const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n;
        n = 1 & l >>> 15, this.__setDigit(t2 + s, (32767 & l) << 15 | 32767 & o);
        if (t2 + s + 1 >= this.length)
          throw new RangeError("out of bounds");
        0 == (1 & e) && (g = this.__digit(t2 + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t2 + _.length, 1073709056 & g | 32767 & o));
      } else {
        t2 >>= 1;
        let g = 0;
        for (; g < _.length - 1; g++) {
          const i2 = this.__digit(t2 + g), e2 = _.__digit(g), o2 = (32767 & i2) - (32767 & e2) - n;
          n = 1 & o2 >>> 15;
          const s2 = (i2 >>> 15) - (e2 >>> 15) - n;
          n = 1 & s2 >>> 15, this.__setDigit(t2 + g, (32767 & s2) << 15 | 32767 & o2);
        }
        const i = this.__digit(t2 + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n;
        n = 1 & s >>> 15;
        let l = 0;
        0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t2 + g, (32767 & l) << 15 | 32767 & s);
      }
      return n;
    }
    __inplaceRightShift(_) {
      if (0 === _)
        return;
      let t2 = this.__digit(0) >>> _;
      const e = this.length - 1;
      for (let n = 0; n < e; n++) {
        const i = this.__digit(n + 1);
        this.__setDigit(n, 1073741823 & i << 30 - _ | t2), t2 = i >>> _;
      }
      this.__setDigit(e, t2);
    }
    static __specialLeftShift(_, t2, e) {
      const g = _.length, n = new JSBI(g + e, false);
      if (0 === t2) {
        for (let t3 = 0; t3 < g; t3++)
          n.__setDigit(t3, _.__digit(t3));
        return 0 < e && n.__setDigit(g, 0), n;
      }
      let o = 0;
      for (let s = 0; s < g; s++) {
        const i = _.__digit(s);
        n.__setDigit(s, 1073741823 & i << t2 | o), o = i >>> 30 - t2;
      }
      return 0 < e && n.__setDigit(g, o), n;
    }
    static __leftShiftByAbsolute(_, i) {
      const t2 = JSBI.__toShiftAmount(i);
      if (0 > t2)
        throw new RangeError("BigInt too big");
      const e = 0 | t2 / 30, n = t2 % 30, g = _.length, o = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n, s = g + e + (o ? 1 : 0), l = new JSBI(s, _.sign);
      if (0 === n) {
        let t3 = 0;
        for (; t3 < e; t3++)
          l.__setDigit(t3, 0);
        for (; t3 < s; t3++)
          l.__setDigit(t3, _.__digit(t3 - e));
      } else {
        let t3 = 0;
        for (let _2 = 0; _2 < e; _2++)
          l.__setDigit(_2, 0);
        for (let o2 = 0; o2 < g; o2++) {
          const i2 = _.__digit(o2);
          l.__setDigit(o2 + e, 1073741823 & i2 << n | t3), t3 = i2 >>> 30 - n;
        }
        if (o)
          l.__setDigit(g + e, t3);
        else if (0 !== t3)
          throw new Error("implementation bug");
      }
      return l.__trim();
    }
    static __rightShiftByAbsolute(_, i) {
      const t2 = _.length, e = _.sign, n = JSBI.__toShiftAmount(i);
      if (0 > n)
        return JSBI.__rightShiftByMaximum(e);
      const g = 0 | n / 30, o = n % 30;
      let s = t2 - g;
      if (0 >= s)
        return JSBI.__rightShiftByMaximum(e);
      let l = false;
      if (e) {
        if (0 != (_.__digit(g) & (1 << o) - 1))
          l = true;
        else
          for (let t3 = 0; t3 < g; t3++)
            if (0 !== _.__digit(t3)) {
              l = true;
              break;
            }
      }
      if (l && 0 === o) {
        const i2 = _.__digit(t2 - 1);
        0 == ~i2 && s++;
      }
      let r = new JSBI(s, e);
      if (0 === o) {
        r.__setDigit(s - 1, 0);
        for (let e2 = g; e2 < t2; e2++)
          r.__setDigit(e2 - g, _.__digit(e2));
      } else {
        let e2 = _.__digit(g) >>> o;
        const n2 = t2 - g - 1;
        for (let t3 = 0; t3 < n2; t3++) {
          const i2 = _.__digit(t3 + g + 1);
          r.__setDigit(t3, 1073741823 & i2 << 30 - o | e2), e2 = i2 >>> o;
        }
        r.__setDigit(n2, e2);
      }
      return l && (r = JSBI.__absoluteAddOne(r, true, r)), r.__trim();
    }
    static __rightShiftByMaximum(i) {
      return i ? JSBI.__oneDigit(1, true) : JSBI.__zero();
    }
    static __toShiftAmount(i) {
      if (1 < i.length)
        return -1;
      const _ = i.__unsignedDigit(0);
      return _ > JSBI.__kMaxLengthBits ? -1 : _;
    }
    static __toPrimitive(i, _ = "default") {
      if ("object" != typeof i)
        return i;
      if (i.constructor === JSBI)
        return i;
      if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive && i[Symbol.toPrimitive]) {
        const t3 = i[Symbol.toPrimitive](_);
        if ("object" != typeof t3)
          return t3;
        throw new TypeError("Cannot convert object to primitive value");
      }
      const t2 = i.valueOf;
      if (t2) {
        const _2 = t2.call(i);
        if ("object" != typeof _2)
          return _2;
      }
      const e = i.toString;
      if (e) {
        const _2 = e.call(i);
        if ("object" != typeof _2)
          return _2;
      }
      throw new TypeError("Cannot convert object to primitive value");
    }
    static __toNumeric(i) {
      return JSBI.__isBigInt(i) ? i : +i;
    }
    static __isBigInt(i) {
      return "object" == typeof i && null !== i && i.constructor === JSBI;
    }
    static __truncateToNBits(i, _) {
      const t2 = 0 | (i + 29) / 30, e = new JSBI(t2, _.sign), n = t2 - 1;
      for (let t3 = 0; t3 < n; t3++)
        e.__setDigit(t3, _.__digit(t3));
      let g = _.__digit(n);
      if (0 != i % 30) {
        const _2 = 32 - i % 30;
        g = g << _2 >>> _2;
      }
      return e.__setDigit(n, g), e.__trim();
    }
    static __truncateAndSubFromPowerOfTwo(_, t2, e) {
      var n = Math.min;
      const g = 0 | (_ + 29) / 30, o = new JSBI(g, e);
      let s = 0;
      const l = g - 1;
      let a = 0;
      for(let   i = n(l, t2.length); s < i; s++) {
        const i2 = 0 - t2.__digit(s) - a;
        a = 1 & i2 >>> 30, o.__setDigit(s, 1073741823 & i2);
      }
      for (; s < l; s++)
        o.__setDigit(s, 0 | 1073741823 & -a);
      let u = l < t2.length ? t2.__digit(l) : 0;
      const d = _ % 30;
      let h2;
      if (0 == d)
        h2 = 0 - u - a, h2 &= 1073741823;
      else {
        const i = 32 - d;
        u = u << i >>> i;
        const _2 = 1 << 32 - i;
        h2 = _2 - u - a, h2 &= _2 - 1;
      }
      return o.__setDigit(l, h2), o.__trim();
    }
    __digit(_) {
      return this[_];
    }
    __unsignedDigit(_) {
      return this[_] >>> 0;
    }
    __setDigit(_, i) {
      this[_] = 0 | i;
    }
    __setDigitGrow(_, i) {
      this[_] = 0 | i;
    }
    __halfDigitLength() {
      const i = this.length;
      return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
    }
    __halfDigit(_) {
      return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
    }
    __setHalfDigit(_, i) {
      const t2 = _ >>> 1, e = this.__digit(t2), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;
      this.__setDigit(t2, n);
    }
    static __digitPow(i, _) {
      let t2 = 1;
      for (; 0 < _; )
        1 & _ && (t2 *= i), _ >>>= 1, i *= i;
      return t2;
    }
    static __detectBigEndian() {
      return JSBI.__kBitConversionDouble[0] = -0, 0 !== JSBI.__kBitConversionInts[0];
    }
    static __isOneDigitInt(i) {
      return (1073741823 & i) === i;
    }
  }
  JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionIntHigh = JSBI.__detectBigEndian() ? 0 : 1, JSBI.__kBitConversionIntLow = JSBI.__detectBigEndian() ? 1 : 0, JSBI.__clz30 = Math.clz32 ? function(i) {
    return Math.clz32(i) - 2;
  } : function(i) {
    return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
  }, JSBI.__imul = Math.imul || function(i, _) {
    return 0 | i * _;
  };
  var jsbn = { exports: {} };
  (function(module, exports) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a)
            this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a)
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h2 = this[i++] >> 15;
          var m2 = xh * l + h2 * xl;
          l = xl * l + ((m2 & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m2 >>> 15) + xh * h2 + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h2 = this[i++] >> 14;
          var m2 = xh * l + h2 * xl;
          l = xl * l + ((m2 & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m2 >> 14) + xh * h2;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k2;
        if (b == 16)
          k2 = 4;
        else if (b == 8)
          k2 = 3;
        else if (b == 256)
          k2 = 8;
        else if (b == 2)
          k2 = 1;
        else if (b == 32)
          k2 = 5;
        else if (b == 4)
          k2 = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k2 == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k2 > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k2;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k2 == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k2;
        if (b == 16)
          k2 = 4;
        else if (b == 8)
          k2 = 3;
        else if (b == 2)
          k2 = 1;
        else if (b == 32)
          k2 = 5;
        else if (b == 4)
          k2 = 2;
        else
          return this.toRadix(b);
        var km = (1 << k2) - 1, d, m2 = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k2;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m2 = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k2) {
              d = (this[i] & (1 << p) - 1) << k2 - p;
              d |= this[--i] >> (p += this.DB - k2);
            } else {
              d = this[i] >> (p -= k2) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m2 = true;
            if (m2)
              r += int2char(d);
          }
        }
        return m2 ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t3;
        if ((t3 = x >>> 16) != 0) {
          x = t3;
          r += 16;
        }
        if ((t3 = x >> 8) != 0) {
          x = t3;
          r += 8;
        }
        if ((t3 = x >> 4) != 0) {
          x = t3;
          r += 4;
        }
        if ((t3 = x >> 2) != 0) {
          x = t3;
          r += 2;
        }
        if ((t3 = x >> 1) != 0) {
          x = t3;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m2 = Math.min(a.t, this.t);
        while (i < m2) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m2, q, r) {
        var pm = m2.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null)
            q.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m2.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t3 = q == null ? nbi() : q;
        y.dlShiftTo(j, t3);
        if (r.compareTo(t3) >= 0) {
          r[r.t++] = 1;
          r.subTo(t3, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t3);
        t3.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t3);
            r.subTo(t3, r);
            while (r[i] < --qd)
              r.subTo(t3, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms)
            BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m2) {
        this.m = m2;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m2) {
        this.m = m2;
        this.mp = m2.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m2.DB - 15) - 1;
        this.mt2 = 2 * m2.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t3 = r;
            r = r2;
            r2 = t3;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m2) {
        var z2;
        if (e < 256 || m2.isEven())
          z2 = new Classic(m2);
        else
          z2 = new Montgomery(m2);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t3 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t3 > 0)
            x[0] &= (1 << t3) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k2 = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k2++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k2 == 0 && (this.s & 128) != (d & 128))
              ++k2;
            if (k2 > 0 || d != this.s)
              r[k2++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m2 = Math.min(a.t, this.t);
        for (i = 0; i < m2; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m2; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m2; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m2 = Math.min(a.t, this.t);
        while (i < m2) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m2) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
        this.mu = this.r2.divide(m2);
        this.m = m2;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m2) {
        var i = e.bitLength(), k2, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k2 = 1;
        else if (i < 48)
          k2 = 3;
        else if (i < 144)
          k2 = 4;
        else if (i < 768)
          k2 = 5;
        else
          k2 = 6;
        if (i < 8)
          z2 = new Classic(m2);
        else if (m2.isEven())
          z2 = new Barrett(m2);
        else
          z2 = new Montgomery(m2);
        var g = new Array(), n = 3, k1 = k2 - 1, km = (1 << k2) - 1;
        g[1] = z2.convert(this);
        if (k2 > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t3;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k2;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t3 = r;
              r = r2;
              r2 = t3;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t3 = r;
            r = r2;
            r2 = t3;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t3 = x;
          x = y;
          y = t3;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m2) {
        var ac = m2.isEven();
        if (this.isEven() && ac || m2.signum() == 0)
          return BigInteger.ZERO;
        var u = m2.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m2, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m2, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m2, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m2, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m2) >= 0)
          return d.subtract(m2);
        if (d.signum() < 0)
          d.addTo(m2, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m2);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t3) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m2 = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m2 < lplim)
            m2 *= lowprimes[j++];
          m2 = x.modInt(m2);
          while (i < j)
            if (m2 % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t3);
      }
      function bnpMillerRabin(t3) {
        var n1 = this.subtract(BigInteger.ONE);
        var k2 = n1.getLowestSetBit();
        if (k2 <= 0)
          return false;
        var r = n1.shiftRight(k2);
        t3 = t3 + 1 >> 1;
        if (t3 > lowprimes.length)
          t3 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t3; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k2 && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t2;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t2 = 0; t2 < 32; ++t2)
              rng_pool[rng_pptr++] = ua[t2];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t2 = 0; t2 < z.length; ++t2)
              rng_pool[rng_pptr++] = z.charCodeAt(t2) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t2 = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t2 >>> 8;
          rng_pool[rng_pptr++] = t2 & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t3;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t3 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t3;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t3;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t3 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t3;
        return this.S[t3 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      {
        module.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      }
    }).call(commonjsGlobal);
  })(jsbn);
  var jsbnExports = jsbn.exports;
  const ZERO = JSBI.BigInt(0);
  const ONE = JSBI.BigInt(1);
  const TWO = JSBI.BigInt(2);
  function bigIntBitLength(n) {
    const i = (n.toString(16).length - 1) * 4;
    return i + 32 - Math.clz32(JSBI.toNumber(JSBI.signedRightShift(n, JSBI.BigInt(i))));
  }
  function bigIntToBuffer(value, length = 0, le = false) {
    const bits2 = bigIntBitLength(value);
    const bytes = Math.ceil(bits2 / 8);
    if (length !== 0 && bytes > length) {
      throw new Error("Value out of bounds");
    }
    if (length === 0)
      length = bytes;
    const buf = new ArrayBuffer(length);
    const u82 = new Uint8Array(buf);
    const unaligned = length % 8;
    const dv = new DataView(buf, 0, length - unaligned);
    for (let i = 0; i < dv.byteLength; i += 8) {
      JSBI.DataViewSetBigUint64(dv, i, JSBI.bitwiseAnd(value, JSBI.BigInt("0xFFFFFFFFFFFFFFFF")), true);
      value = JSBI.signedRightShift(value, JSBI.BigInt(64));
    }
    if (unaligned > 0) {
      for (let i = length - unaligned; i < length; i++) {
        u82[i] = JSBI.toNumber(JSBI.bitwiseAnd(value, JSBI.BigInt("0xFF")));
        value = JSBI.signedRightShift(value, JSBI.BigInt(8));
      }
    }
    if (!le)
      u82.reverse();
    return u82;
  }
  function bufferToBigInt(buffer, le = false) {
    if (le)
      buffer = bufferToReversed(buffer);
    const unaligned = buffer.length % 8;
    const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength - unaligned);
    let res = ZERO;
    for (let i = 0; i < dv.byteLength; i += 8) {
      res = JSBI.bitwiseOr(JSBI.leftShift(res, JSBI.BigInt(64)), JSBI.DataViewGetBigUint64(dv, i, false));
    }
    if (unaligned > 0) {
      for (let i = buffer.length - unaligned; i < buffer.length; i++) {
        res = JSBI.bitwiseOr(JSBI.leftShift(res, JSBI.BigInt(8)), JSBI.BigInt(buffer[i]));
      }
    }
    return res;
  }
  function randomBigInt(crypto2, size) {
    return bufferToBigInt(crypto2.randomBytes(size));
  }
  function randomBigIntBits(crypto2, bits2) {
    let num = randomBigInt(crypto2, Math.ceil(bits2 / 8));
    const bitLength = bigIntBitLength(num);
    if (bitLength > bits2) {
      const toTrim = bitLength - bits2;
      num = JSBI.signedRightShift(num, JSBI.BigInt(toTrim));
    }
    return num;
  }
  function randomBigIntInRange(crypto2, max2, min2 = JSBI.BigInt(1)) {
    const interval = JSBI.subtract(max2, min2);
    if (JSBI.lessThan(interval, ZERO))
      throw new Error("expected min < max");
    const byteSize = Math.ceil(bigIntBitLength(interval) / 8);
    let result = randomBigInt(crypto2, byteSize);
    while (JSBI.greaterThan(result, interval))
      result = JSBI.subtract(result, interval);
    return JSBI.add(min2, result);
  }
  function twoMultiplicity(n) {
    if (JSBI.equal(n, ZERO))
      return ZERO;
    let m2 = ZERO;
    let pow = ONE;
    while (true) {
      if (JSBI.notEqual(JSBI.bitwiseAnd(n, pow), ZERO))
        return m2;
      m2 = JSBI.add(m2, ONE);
      pow = JSBI.leftShift(pow, ONE);
    }
  }
  function bigIntMin(a, b) {
    return JSBI.lessThan(a, b) ? a : b;
  }
  function bigIntAbs(a) {
    return JSBI.lessThan(a, ZERO) ? JSBI.unaryMinus(a) : a;
  }
  function bigIntGcd(a, b) {
    while (JSBI.notEqual(b, ZERO)) {
      const t2 = b;
      b = JSBI.remainder(a, b);
      a = t2;
    }
    return a;
  }
  const native = typeof BigInt !== "undefined";
  function bigIntModPow(_base, _exp, _mod) {
    if (native) {
      _base = JSBI.remainder(_base, _mod);
      let result = ONE;
      while (JSBI.greaterThan(_exp, ONE)) {
        if (JSBI.equal(JSBI.remainder(_exp, TWO), ONE)) {
          result = JSBI.remainder(JSBI.multiply(result, _base), _mod);
        }
        _exp = JSBI.signedRightShift(_exp, ONE);
        _base = JSBI.remainder(JSBI.exponentiate(_base, TWO), _mod);
      }
      return result;
    } else {
      const base = new jsbnExports.BigInteger(_base.toString(16), 16);
      const exp = new jsbnExports.BigInteger(_exp.toString(16), 16);
      const mod = new jsbnExports.BigInteger(_mod.toString(16), 16);
      const result = base.modPow(exp, mod);
      const final = JSBI.BigInt(`0x${result.toString(16)}`);
      return final;
    }
  }
  function composeMiddlewares(middlewares, final) {
    middlewares = middlewares.slice();
    middlewares.push(final);
    function dispatch(i, ctx) {
      const fn = middlewares[i];
      if (!fn)
        return final(ctx);
      return fn(ctx, boundDispatches[i + 1]);
    }
    const boundDispatches = [];
    for (let i = 0; i < middlewares.length; i++) {
      boundDispatches.push(dispatch.bind(null, i));
    }
    return function(context) {
      return boundDispatches[0](context);
    };
  }
  class ConditionVariable {
    constructor() {
      __publicField(this, "_notify");
      __publicField(this, "_timeout");
    }
    wait(timeout) {
      const prom = new Promise((resolve) => {
        this._notify = resolve;
      });
      if (timeout) {
        this._timeout = setTimeoutWrap(() => {
          var _a2;
          (_a2 = this._notify) == null ? void 0 : _a2.call(this);
          this._timeout = void 0;
        }, timeout);
      }
      return prom;
    }
    notify() {
      var _a2;
      (_a2 = this._notify) == null ? void 0 : _a2.call(this);
      if (this._timeout)
        clearTimeoutWrap(this._timeout);
      this._notify = void 0;
    }
  }
  function createControllablePromise() {
    let _resolve;
    let _reject;
    const promise = new Promise((resolve, reject) => {
      _resolve = resolve;
      _reject = reject;
    });
    promise.resolve = _resolve;
    promise.reject = _reject;
    return promise;
  }
  function factorizePQSync(crypto2, pq) {
    const pq_ = bufferToBigInt(pq);
    const n = PollardRhoBrent(crypto2, pq_);
    const m2 = JSBI.divide(pq_, n);
    let p;
    let q;
    if (JSBI.lessThan(n, m2)) {
      p = n;
      q = m2;
    } else {
      p = m2;
      q = n;
    }
    return [bigIntToBuffer(p), bigIntToBuffer(q)];
  }
  function PollardRhoBrent(crypto2, n) {
    if (JSBI.equal(JSBI.remainder(n, TWO), ZERO))
      return TWO;
    let y = randomBigIntInRange(crypto2, JSBI.subtract(n, ONE));
    const c = randomBigIntInRange(crypto2, JSBI.subtract(n, ONE));
    const m2 = randomBigIntInRange(crypto2, JSBI.subtract(n, ONE));
    let g = ONE;
    let r = ONE;
    let q = ONE;
    let ys;
    let x;
    while (JSBI.equal(g, ONE)) {
      x = y;
      for (let i = 0; JSBI.GE(r, i); i++)
        y = JSBI.remainder(JSBI.add(JSBI.remainder(JSBI.multiply(y, y), n), c), n);
      let k2 = ZERO;
      while (JSBI.lessThan(k2, r) && JSBI.equal(g, ONE)) {
        ys = y;
        for (let i = ZERO; JSBI.lessThan(i, bigIntMin(m2, JSBI.subtract(r, k2))); i = JSBI.add(i, ONE)) {
          y = JSBI.remainder(JSBI.add(JSBI.remainder(JSBI.multiply(y, y), n), c), n);
          q = JSBI.remainder(JSBI.multiply(q, bigIntAbs(JSBI.subtract(x, y))), n);
        }
        g = bigIntGcd(q, n);
        k2 = JSBI.add(k2, m2);
      }
      r = JSBI.leftShift(r, ONE);
    }
    if (JSBI.equal(g, n)) {
      do {
        ys = JSBI.remainder(JSBI.add(JSBI.remainder(JSBI.multiply(ys, ys), n), c), n);
        g = bigIntGcd(JSBI.subtract(x, ys), n);
      } while (JSBI.lessThanOrEqual(g, ONE));
    }
    return g;
  }
  class BaseCryptoProvider {
    factorizePQ(pq) {
      return factorizePQSync(this, pq);
    }
    randomBytes(size) {
      const buf = new Uint8Array(size);
      this.randomFill(buf);
      return buf;
    }
  }
  var rsaKeys = {};
  Object.defineProperty(rsaKeys, "__esModule", { value: true });
  var __publicKeyIndex = rsaKeys.__publicKeyIndex = JSON.parse('{"b25898df208d2603":{"modulus":"c8c11d635691fac091dd9489aedced2932aa8a0bcefef05fa800892d9b52ed03200865c9e97211cb2ee6c7ae96d3fb0e15aeffd66019b44a08a240cfdd2868a85e1f54d6fa5deaa041f6941ddf302690d61dc476385c2fa655142353cb4e4b59f6e5b6584db76fe8b1370263246c010c93d011014113ebdf987d093f9d37c2be48352d69a1683f8f6e6c2167983c761e3ab169fde5daaa12123fa1beab621e4da5935e9c198f82f35eae583a99386d8110ea6bd1abb0f568759f62694419ea5f69847c43462abef858b4cb5edc84e7b9226cd7bd7e183aa974a712c079dde85b9dc063b8a5c08e8f859c0ee5dcd824c7807f20153361a7f63cfd2a433a1be7f5","exponent":"010001","fingerprint":"b25898df208d2603","old":false},"d09d1d85de64fd85":{"modulus":"e8bb3305c0b52c6cf2afdf7637313489e63e05268e5badb601af417786472e5f93b85438968e20e6729a301c0afc121bf7151f834436f7fda680847a66bf64accec78ee21c0b316f0edafe2f41908da7bd1f4a5107638eeb67040ace472a14f90d9f7c2b7def99688ba3073adb5750bb02964902a359fe745d8170e36876d4fd8a5d41b2a76cbff9a13267eb9580b2d06d10357448d20d9da2191cb5d8c93982961cdfdeda629e37f1fb09a0722027696032fe61ed663db7a37f6f263d370f69db53a0dc0a1748bdaaff6209d5645485e6e001d1953255757e4b8e42813347b11da6ab500fd0ace7e6dfa3736199ccaf9397ed0745a427dcfa6cd67bcb1acff3","exponent":"010001","fingerprint":"d09d1d85de64fd85","old":false},"0bc35f3509f7b7a5":{"modulus":"aeec36c8ffc109cb099624685b97815415657bd76d8c9c3e398103d7ad16c9bba6f525ed0412d7ae2c2de2b44e77d72cbf4b7438709a4e646a05c43427c7f184debf72947519680e651500890c6832796dd11f772c25ff8f576755afe055b0a3752c696eb7d8da0d8be1faf38c9bdd97ce0a77d3916230c4032167100edd0f9e7a3a9b602d04367b689536af0d64b613ccba7962939d3b57682beb6dae5b608130b2e52aca78ba023cf6ce806b1dc49c72cf928a7199d22e3d7ac84e47bc9427d0236945d10dbd15177bab413fbf0edfda09f014c7a7da088dde9759702ca760af2b8e4e97cc055c617bd74c3d97008635b98dc4d621b4891da9fb0473047927","exponent":"010001","fingerprint":"0bc35f3509f7b7a5","old":true},"15ae5fa8b5529542":{"modulus":"bdf2c77d81f6afd47bd30f29ac76e55adfe70e487e5e48297e5a9055c9c07d2b93b4ed3994d3eca5098bf18d978d54f8b7c713eb10247607e69af9ef44f38e28f8b439f257a11572945cc0406fe3f37bb92b79112db69eedf2dc71584a661638ea5becb9e23585074b80d57d9f5710dd30d2da940e0ada2f1b878397dc1a72b5ce2531b6f7dd158e09c828d03450ca0ff8a174deacebcaa22dde84ef66ad370f259d18af806638012da0ca4a70baa83d9c158f3552bc9158e69bf332a45809e1c36905a5caa12348dd57941a482131be7b2355a5f4635374f3bd3ddf5ff925bf4809ee27c1e67d9120c5fe08a9de458b1b4a3c5d0a428437f2beca81f4e2d5ff","exponent":"010001","fingerprint":"15ae5fa8b5529542","old":true},"aeae98e13cd7f94f":{"modulus":"b3f762b739be98f343eb1921cf0148cfa27ff7af02b6471213fed9daa0098976e667750324f1abcea4c31e43b7d11f1579133f2b3d9fe27474e462058884e5e1b123be9cbbc6a443b2925c08520e7325e6f1a6d50e117eb61ea49d2534c8bb4d2ae4153fabe832b9edf4c5755fdd8b19940b81d1d96cf433d19e6a22968a85dc80f0312f596bd2530c1cfb28b5fe019ac9bc25cd9c2a5d8a0f3a1c0c79bcca524d315b5e21b5c26b46babe3d75d06d1cd33329ec782a0f22891ed1db42a1d6c0dea431428bc4d7aabdcf3e0eb6fda4e23eb7733e7727e9a1915580796c55188d2596d2665ad1182ba7abf15aaa5a8b779ea996317a20ae044b820bff35b6e8a1","exponent":"010001","fingerprint":"aeae98e13cd7f94f","old":true},"5a181b2235057d98":{"modulus":"be6a71558ee577ff03023cfa17aab4e6c86383cff8a7ad38edb9fafe6f323f2d5106cbc8cafb83b869cffd1ccf121cd743d509e589e68765c96601e813dc5b9dfc4be415c7a6526132d0035ca33d6d6075d4f535122a1cdfe017041f1088d1419f65c8e5490ee613e16dbf662698c0f54870f0475fa893fc41eb55b08ff1ac211bc045ded31be27d12c96d8d3cfc6a7ae8aa50bf2ee0f30ed507cc2581e3dec56de94f5dc0a7abee0be990b893f2887bd2c6310a1e0a9e3e38bd34fded2541508dc102a9c9b4c95effd9dd2dfe96c29be647d6c69d66ca500843cfaed6e440196f1dbe0e2e22163c61ca48c79116fa77216726749a976a1c4b0944b5121e8c01","exponent":"010001","fingerprint":"5a181b2235057d98","old":true},"c3b42b026ce86b21":{"modulus":"c150023e2f70db7985ded064759cfecf0af328e69a41daf4d6f01b538135a6f91f8f8b2a0ec9ba9720ce352efcf6c5680ffc424bd634864902de0b4bd6d49f4e580230e3ae97d95c8b19442b3c0a10d8f5633fecedd6926a7f6dab0ddb7d457f9ea81b8465fcd6fffeed114011df91c059caedaf97625f6c96ecc74725556934ef781d866b34f011fce4d835a090196e9a5f0e4449af7eb697ddb9076494ca5f81104a305b6dd27665722c46b60e5df680fb16b210607ef217652e60236c255f6a28315f4083a96791d7214bf64c1df4fd0db1944fb26a2a57031b32eee64ad15a8ba68885cde74a5bfc920f6abf59ba5c75506373e7130f9042da922179251f","exponent":"010001","fingerprint":"c3b42b026ce86b21","old":true},"9a996a1db11c729b":{"modulus":"c6aeda78b02a251db4b6441031f467fa871faed32526c436524b1fb3b5dca28efb8c089dd1b46d92c895993d87108254951c5f001a0f055f3063dcd14d431a300eb9e29517e359a1c9537e5e87ab1b116faecf5d17546ebc21db234d9d336a693efcb2b6fbcca1e7d1a0be414dca408a11609b9c4269a920b09fed1f9a1597be02761430f09e4bc48fcafbe289054c99dba51b6b5eb7d9c3a2ab4e490545b4676bd620e93804bcac93bf94f73f92c729ca899477ff17625ef14a934d51dc11d5f8650a3364586b3a52fcff2fedec8a8406cac4e751705a472e55707e3c8cd5594342b119c6c3293532d85dbe9271ed54a2fd18b4dc79c04a30951107d5639397","exponent":"010001","fingerprint":"9a996a1db11c729b","old":true},"b05b2a6f70cdea78":{"modulus":"b1066749655935f0a5936f517034c943bea7f3365a8931ae52c8bcb14856f004b83d26cf2839be0f22607470d67481771c1ce5ec31de16b20bbaa4ecd2f7d2ecf6b6356f27501c226984263edc046b89fb6d3981546b01d7bd34fedcfcc1058e2d494bda732ff813e50e1c6ae249890b225f82b22b1e55fcb063dc3c0e18e91c28d0c4aa627dec8353eee6038a95a4fd1ca984eb09f94aeb7a2220635a8ceb450ea7e61d915cdb4eecedaa083aa3801daf071855ec1fb38516cb6c2996d2d60c0ecbcfa57e4cf1fb0ed39b2f37e94ab4202ecf595e167b3ca62669a6da520859fb6d6c6203dfdfc79c75ec3ee97da8774b2da903e3435f2cd294670a75a526c1","exponent":"010001","fingerprint":"b05b2a6f70cdea78","old":true},"71e025b6c76033e3":{"modulus":"c2a8c55b4a62e2b78a19b91cf692bcdc4ba7c23fe4d06f194e2a0c30f6d9996f7d1a2bcc89bc1ac4333d44359a6c433252d1a8402d9970378b5912b75bc8cc3fa76710a025bcb9032df0b87d7607cc53b928712a174ea2a80a8176623588119d42ffce40205c6d72160860d8d80b22a8b8651907cf388effbef29cd7cf2b4eb8a872052da1351cfe7fec214ce48304ea472bd66329d60115b3420d08f6894b0410b6ab9450249967617670c932f7cbdb5d6fbcce1e492c595f483109999b2661fcdeec31b196429b7834c7211a93c6789d9ee601c18c39e521fda9d7264e61e518add6f0712d2d5228204b851e13c4f322e5c5431c3b7f31089668486aadc59f","exponent":"010001","fingerprint":"71e025b6c76033e3","old":true}}');
  function findKeyByFingerprints(fingerprints, allowOld = false) {
    for (let fp of fingerprints) {
      if (typeof fp !== "string") {
        fp = fp.toUnsigned().toString(16);
      }
      if (fp in __publicKeyIndex) {
        if (__publicKeyIndex[fp].old && !allowOld)
          continue;
        return __publicKeyIndex[fp];
      }
    }
    if (!allowOld)
      return findKeyByFingerprints(fingerprints, true);
    return null;
  }
  const FOUR$1 = JSBI.BigInt(4);
  function millerRabin(crypto2, n, rounds = 20) {
    if (JSBI.lessThan(n, FOUR$1))
      return JSBI.greaterThan(n, ONE);
    if (JSBI.equal(JSBI.remainder(n, TWO), ZERO) || JSBI.lessThan(n, ZERO))
      return false;
    const nBits = bigIntBitLength(n);
    const nSub = JSBI.subtract(n, ONE);
    const r = twoMultiplicity(nSub);
    const d = JSBI.signedRightShift(nSub, r);
    for (let i = 0; i < rounds; i++) {
      let base;
      do {
        base = randomBigIntBits(crypto2, nBits);
      } while (JSBI.lessThanOrEqual(base, ONE) || JSBI.greaterThanOrEqual(base, nSub));
      let x = bigIntModPow(base, d, n);
      if (JSBI.equal(x, ONE) || JSBI.equal(x, nSub))
        continue;
      let i2 = ZERO;
      let y;
      while (JSBI.lessThan(i2, r)) {
        y = bigIntModPow(x, TWO, n);
        if (JSBI.equal(x, ONE))
          return false;
        if (JSBI.equal(x, nSub))
          break;
        i2 = JSBI.add(i2, ONE);
        x = y;
      }
      if (JSBI.equal(i2, r))
        return false;
    }
    return true;
  }
  function generateKeyAndIvFromNonce(crypto2, serverNonce, newNonce) {
    const hash1 = crypto2.sha1(concatBuffers([newNonce, serverNonce]));
    const hash2 = crypto2.sha1(concatBuffers([serverNonce, newNonce]));
    const hash3 = crypto2.sha1(concatBuffers([newNonce, newNonce]));
    const key = concatBuffers([hash1, hash2.subarray(0, 12)]);
    const iv = concatBuffers([hash2.subarray(12, 20), hash3, newNonce.subarray(0, 4)]);
    return [key, iv];
  }
  function createAesIgeForMessage(crypto2, authKey, messageKey, client) {
    const x = client ? 0 : 8;
    const sha256a = crypto2.sha256(concatBuffers([messageKey, authKey.subarray(x, 36 + x)]));
    const sha256b = crypto2.sha256(concatBuffers([authKey.subarray(40 + x, 76 + x), messageKey]));
    const key = concatBuffers([sha256a.subarray(0, 8), sha256b.subarray(8, 24), sha256a.subarray(24, 32)]);
    const iv = concatBuffers([sha256b.subarray(0, 8), sha256a.subarray(8, 24), sha256b.subarray(24, 32)]);
    return crypto2.createAesIge(key, iv);
  }
  function createAesIgeForMessageOld(crypto2, authKey, messageKey, client) {
    const x = 0;
    const sha1a = crypto2.sha1(concatBuffers([messageKey, authKey.subarray(x, 32 + x)]));
    const sha1b = crypto2.sha1(
      concatBuffers([authKey.subarray(32 + x, 48 + x), messageKey, authKey.subarray(48 + x, 64 + x)])
    );
    const sha1c = crypto2.sha1(concatBuffers([authKey.subarray(64 + x, 96 + x), messageKey]));
    const sha1d = crypto2.sha1(concatBuffers([messageKey, authKey.subarray(96 + x, 128 + x)]));
    const key = concatBuffers([sha1a.subarray(0, 8), sha1b.subarray(8, 20), sha1c.subarray(4, 16)]);
    const iv = concatBuffers([
      sha1a.subarray(8, 20),
      sha1b.subarray(0, 8),
      sha1c.subarray(16, 20),
      sha1d.subarray(0, 8)
    ]);
    return crypto2.createAesIge(key, iv);
  }
  function xorBuffer(data2, key) {
    const ret = new Uint8Array(data2.length);
    for (let i = 0; i < data2.length; i++) {
      ret[i] = data2[i] ^ key[i];
    }
    return ret;
  }
  function xorBufferInPlace(data2, key) {
    for (let i = 0; i < data2.length; i++) {
      data2[i] ^= key[i];
    }
  }
  function computePasswordHash(crypto2, password, salt1, salt2) {
    return __async(this, null, function* () {
      const SH = (data2, salt) => crypto2.sha256(concatBuffers([salt, data2, salt]));
      const PH1 = (pwd, salt12, salt22) => SH(SH(pwd, salt12), salt22);
      return SH(yield crypto2.pbkdf2(PH1(password, salt1, salt2), salt1, 1e5), salt2);
    });
  }
  function computeNewPasswordHash(crypto2, algo, password) {
    return __async(this, null, function* () {
      assertTypeIs("account.getPassword", algo, "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow");
      const salt1 = new Uint8Array(algo.salt1.length + 32);
      salt1.set(algo.salt1);
      crypto2.randomFill(salt1.subarray(algo.salt1.length));
      algo.salt1 = salt1;
      const _x = yield computePasswordHash(crypto2, getPlatform().utf8Encode(password), algo.salt1, algo.salt2);
      const g = JSBI.BigInt(algo.g);
      const p = bufferToBigInt(algo.p);
      const x = bufferToBigInt(_x);
      return bigIntToBuffer(bigIntModPow(g, x, p), 256);
    });
  }
  function computeSrpParams(crypto2, request, password) {
    return __async(this, null, function* () {
      var _a2;
      if (!request.currentAlgo || request.currentAlgo._ !== "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow") {
        throw new MtUnsupportedError(`Unknown algo ${(_a2 = request.currentAlgo) == null ? void 0 : _a2._}`);
      }
      const algo = request.currentAlgo;
      if (!request.srpB) {
        throw new MtSecurityError("SRP_B is not present in the request");
      }
      if (!request.srpId) {
        throw new MtSecurityError("SRP_ID is not present in the request");
      }
      const g = JSBI.BigInt(algo.g);
      const _g = bigIntToBuffer(g, 256);
      const p = bufferToBigInt(algo.p);
      const gB = bufferToBigInt(request.srpB);
      const a = bufferToBigInt(crypto2.randomBytes(256));
      const gA = bigIntModPow(g, a, p);
      const _gA = bigIntToBuffer(gA, 256);
      const H = (data2) => crypto2.sha256(data2);
      const _k = crypto2.sha256(concatBuffers([algo.p, _g]));
      const _u = crypto2.sha256(concatBuffers([_gA, request.srpB]));
      const _x = yield computePasswordHash(crypto2, getPlatform().utf8Encode(password), algo.salt1, algo.salt2);
      const k2 = bufferToBigInt(_k);
      const u = bufferToBigInt(_u);
      const x = bufferToBigInt(_x);
      const v = bigIntModPow(g, x, p);
      const kV = JSBI.remainder(JSBI.multiply(k2, v), p);
      let t2 = JSBI.subtract(gB, kV);
      if (JSBI.lessThan(t2, ZERO))
        t2 = JSBI.add(t2, p);
      const sA = bigIntModPow(t2, JSBI.add(a, JSBI.multiply(u, x)), p);
      const _kA = H(bigIntToBuffer(sA, 256));
      const _M1 = H(concatBuffers([xorBuffer(H(algo.p), H(_g)), H(algo.salt1), H(algo.salt2), _gA, request.srpB, _kA]));
      return {
        _: "inputCheckPasswordSRP",
        srpId: request.srpId,
        A: _gA,
        M1: _M1
      };
    });
  }
  class EarlyTimer {
    constructor() {
      __publicField(this, "_timeout");
      __publicField(this, "_immediate");
      __publicField(this, "_timeoutTs");
      __publicField(this, "_handler", () => {
      });
      this.emitNow = this.emitNow.bind(this);
    }
    /**
     * Emit the timer when the event loop is idle
     * (basically `setImmediate()`)
     */
    emitWhenIdle() {
      if (this._immediate)
        return;
      clearTimeoutWrap(this._timeout);
      this._timeoutTs = Date.now();
      if (typeof setImmediateWrapExported !== "undefined") {
        this._immediate = setImmediateWrapExported(this.emitNow);
      } else {
        this._timeout = setTimeoutWrap(this.emitNow, 0);
      }
    }
    /**
     * Emit the timer before the next given milliseconds
     *
     * Shorthand for `emitBefore(Date.now() + ms)`
     *
     * @param ms  Milliseconds to schedule for
     */
    emitBeforeNext(ms) {
      return this.emitBefore(Date.now() + ms);
    }
    /**
     * Emit the timer before the given time
     *
     * @param ts  Unix time in MS
     */
    emitBefore(ts) {
      if (!this._timeoutTs || ts < this._timeoutTs) {
        this.reset();
        this._timeout = setTimeoutWrap(this.emitNow, ts - Date.now());
        this._timeoutTs = ts;
      }
    }
    /**
     * Emit the timer right now
     */
    emitNow() {
      this.reset();
      this._handler();
    }
    /**
     * Cancel the timer
     */
    reset() {
      if (this._immediate) {
        clearImmediateWrapExported(this._immediate);
        this._immediate = void 0;
      } else {
        clearTimeoutWrap(this._timeout);
      }
      this._timeoutTs = void 0;
    }
    /**
     * Set timeout handler
     */
    onTimeout(handler) {
      this._handler = handler;
    }
  }
  function asyncResettable(func) {
    let runningPromise = null;
    let finished = false;
    const run2 = function(...args) {
      if (finished)
        return Promise.resolve();
      if (runningPromise) {
        return runningPromise;
      }
      runningPromise = func(...args);
      void runningPromise.then(() => {
        runningPromise = null;
        finished = true;
      });
      return runningPromise;
    };
    return {
      run: run2,
      finished: () => finished,
      wait: () => runningPromise,
      reset: () => {
        finished = false;
      }
    };
  }
  class SortedLinkedList {
    constructor(comparator) {
      __publicField(this, "_first");
      __publicField(this, "_last");
      __publicField(this, "_size", 0);
      this.comparator = comparator;
    }
    get length() {
      return this._size;
    }
    _remove(item) {
      if (this._first === item) {
        this._first = item.n;
      }
      if (this._last === item) {
        this._last = item.p;
      }
      if (item.p)
        item.p.n = item.n;
      if (item.n)
        item.n.p = item.p;
      this._size -= 1;
    }
    popFront() {
      if (!this._first)
        return void 0;
      const it = this._first;
      this._first = this._first.n;
      if (!this._first)
        this._last = void 0;
      this._size -= 1;
      return it.v;
    }
    add(item) {
      const it = { v: item };
      if (!this._first) {
        this._first = this._last = it;
      } else {
        let cur = this._first;
        while (cur && this.comparator(cur.v, it.v) < 0) {
          cur = cur.n;
        }
        if (!cur) {
          this._last.n = it;
          it.p = this._last;
          this._last = it;
        } else {
          it.n = cur;
          it.p = cur.p;
          if (cur.p)
            cur.p.n = it;
          cur.p = it;
          if (cur === this._first)
            this._first = it;
        }
      }
      this._size += 1;
    }
    clear() {
      this._first = this._last = void 0;
      this._size = 0;
    }
  }
  function writeQuery(query) {
    if (!query)
      return "";
    let str = "";
    for(let   [key, value] of Object.entries(query)) {
      if (value == void 0)
        continue;
      if (str)
        str += "&";
      if (value === true) {
        str += `${key}`;
        continue;
      }
      str += `${key}=${encodeURIComponent(value)}`;
    }
    if (!str)
      return "";
    return `?${str}`;
  }
  // @__NO_SIDE_EFFECTS__
  function deeplinkBuilder(params) {
    const { internalBuild, internalParse, externalBuild, externalParse } = params;
    const fn_ = (options) => {
      const _a2 = options, { protocol = "https", domain = "t.me" } = _a2, rest = __objRest(_a2, ["protocol", "domain"]);
      if (protocol === "tg") {
        if (!internalBuild)
          throw new Error("tg:// deeplink is not supported");
        const [path22, query2] = internalBuild(rest);
        return `tg://${path22}${writeQuery(query2)}`;
      }
      if (!externalBuild)
        throw new Error("t.me deeplink is not supported");
      const [path2, query] = externalBuild(rest);
      return `${protocol}://${domain}/${path2}${writeQuery(query)}`;
    };
    const fn = fn_;
    fn.parse = (url) => {
      const isInternal = url.startsWith("tg://");
      if (isInternal)
        url = `https://fake/${url.slice(5)}`;
      const parsed = new URL(url);
      if (isInternal) {
        if (!internalParse)
          throw new Error("tg:// deeplink is not supported");
        const path22 = parsed.pathname.slice(1);
        return internalParse(path22, parsed.searchParams);
      }
      if (!externalParse)
        throw new Error("t.me deeplink is not supported");
      const path2 = parsed.pathname.slice(1);
      return externalParse(path2, parsed.searchParams);
    };
    return fn;
  }
  function parseMediaTimestamp(timestamp) {
    let m2;
    if (m2 = timestamp.match(/^(\d+)$/)) {
      return Number(m2[1]);
    }
    if (m2 = timestamp.match(/^(\d+):(\d{1,2})$/)) {
      return Number(m2[1]) * 60 + Number(m2[2]);
    }
    if (m2 = timestamp.match(/^(?:(\d+)h)?(?:(\d{1,2})m)?(\d{1,2})s$/)) {
      return (Number(m2[1]) || 0) * 3600 + (Number(m2[2]) || 0) * 60 + (Number(m2[3]) || 0);
    }
    return void 0;
  }
  const message = /* @__PURE__ */ deeplinkBuilder({
    internalBuild: (params) => {
      const common = {
        post: params.id,
        thread: params.threadId,
        comment: params.commentId,
        t: params.mediaTimestamp,
        single: params.single ? "" : void 0
      };
      if ("username" in params) {
        return ["resolve", __spreadValues({ domain: params.username }, common)];
      }
      return ["privatepost", __spreadValues({ channel: params.channelId }, common)];
    },
    internalParse: (path2, query) => {
      const common = {
        id: Number(query.get("post")),
        threadId: query.has("thread") ? Number(query.get("thread")) : void 0,
        commentId: query.has("comment") ? Number(query.get("comment")) : void 0,
        mediaTimestamp: query.has("t") ? parseMediaTimestamp(query.get("t")) : void 0,
        single: query.has("single")
      };
      if (path2 === "resolve") {
        const username = query.get("domain");
        if (!username)
          return null;
        return __spreadValues({ username }, common);
      }
      if (path2 === "privatepost") {
        const channelId = Number(query.get("channel"));
        if (!channelId)
          return null;
        return __spreadValues({ channelId }, common);
      }
      return null;
    },
    externalBuild: (params) => {
      const common = {
        comment: params.commentId,
        t: params.mediaTimestamp,
        single: params.single ? "" : void 0
      };
      if ("username" in params) {
        if (params.threadId) {
          return [`${params.username}/${params.threadId}/${params.id}`, common];
        }
        return [`${params.username}/${params.id}`, common];
      }
      if (params.threadId) {
        return [`c/${params.channelId}/${params.threadId}/${params.id}`, common];
      }
      return [`c/${params.channelId}/${params.id}`, common];
    },
    externalParse: (path2, query) => {
      const chunks = path2.split("/");
      if (chunks.length < 2)
        return null;
      const id2 = Number(chunks[chunks.length - 1]);
      if (Number.isNaN(id2))
        return null;
      const common = {
        id: id2,
        commentId: query.has("comment") ? Number(query.get("comment")) : void 0,
        mediaTimestamp: query.has("t") ? parseMediaTimestamp(query.get("t")) : void 0,
        single: query.has("single")
      };
      if (chunks[0] === "c") {
        const channelId = Number(chunks[1]);
        if (Number.isNaN(channelId))
          return null;
        return __spreadValues({
          channelId,
          threadId: chunks[3] ? Number(chunks[2]) : void 0
        }, common);
      }
      const username = chunks[0];
      if (username[0] === "+")
        return null;
      return __spreadValues({
        username,
        threadId: chunks[2] ? Number(chunks[1]) : void 0
      }, common);
    }
  });
  const DEFAULT_LOG_LEVEL = 2;
  const FORMATTER_RE = /%[a-z]/gi;
  class Logger {
    constructor(mgr, tag, parent = mgr) {
      __publicField(this, "color");
      __publicField(this, "prefix", "");
      __publicField(this, "error", this.log.bind(this, LogManager.ERROR));
      __publicField(this, "warn", this.log.bind(this, LogManager.WARN));
      __publicField(this, "info", this.log.bind(this, LogManager.INFO));
      __publicField(this, "debug", this.log.bind(this, LogManager.DEBUG));
      __publicField(this, "verbose", this.log.bind(this, LogManager.VERBOSE));
      this.mgr = mgr;
      this.tag = tag;
      this.parent = parent;
      let hash = 0;
      for (let i = 0; i < tag.length; i++) {
        hash = (hash << 5) - hash + tag.charCodeAt(i);
        hash |= 0;
      }
      this.color = Math.abs(hash) % 6;
    }
    getPrefix() {
      let s = "";
      let obj = this;
      while (obj) {
        if (obj.prefix)
          s = obj.prefix + s;
        obj = obj.parent;
      }
      return s;
    }
    log(level, fmt, ...args) {
      if (level > this.mgr.level)
        return;
      if (!this.mgr["_filter"](this.tag))
        return;
      if (fmt.includes("%h") || fmt.includes("%b") || fmt.includes("%j") || fmt.includes("%J") || fmt.includes("%l") || fmt.includes("%L") || fmt.includes("%e")) {
        let idx = 0;
        fmt = fmt.replace(FORMATTER_RE, (m2) => {
          if (m2 === "%h" || m2 === "%b" || m2 === "%j" || m2 === "%J" || m2 === "%l" || m2 === "%L" || m2 === "%e") {
            let val = args[idx];
            args.splice(idx, 1);
            if (m2 === "%h") {
              if (ArrayBuffer.isView(val))
                return this.mgr.platform.hexEncode(val);
              if (typeof val === "number" || typeof val === "bigint")
                return val.toString(16);
              return String(val);
            }
            if (m2 === "%b")
              return String(Boolean(val));
            if (m2 === "%j" || m2 === "%J") {
              if (m2 === "%J") {
                val = [...val];
              }
              return JSON.stringify(val, (k2, v) => {
                if (ArrayBuffer.isView(v) || typeof v === "object" && v.type === "Buffer" && Array.isArray(v.data)) {
                  let str = v.data ? Buffer.from(v.data).toString("hex") : this.mgr.platform.hexEncode(v);
                  if (str.length > 300) {
                    str = `${str.slice(0, 300)}...`;
                  }
                  return str;
                }
                return v;
              });
            }
            if (m2 === "%l")
              return String(val);
            if (m2 === "%L") {
              if (!Array.isArray(val))
                return "n/a";
              return `[${val.map(String).join(", ")}]`;
            }
            if (m2 === "%e") {
              if (isTlRpcError(val)) {
                return `${val.errorCode} ${val.errorMessage}`;
              }
              if (tl.tl.RpcError.is(val)) {
                return `${val.code} ${val.text}`;
              }
              return val && typeof val === "object" ? val.stack || val.message : String(val);
            }
          }
          idx++;
          return m2;
        });
      }
      this.mgr.handler(this.color, level, this.tag, this.getPrefix() + fmt, args);
    }
    /**
     * Create a {@link Logger} with the given tag
     * from the same {@link LogManager} as the current
     * Logger.
     *
     * @param tag  Logger tag
     */
    create(tag) {
      return new Logger(this.mgr, tag, this);
    }
  }
  const defaultFilter = () => true;
  class LogManager extends Logger {
    constructor(tag = "base") {
      var _a2;
      super(null, tag);
      __publicField(this, "platform");
      __publicField(this, "level");
      __publicField(this, "handler");
      __publicField(this, "_filter", defaultFilter);
      this.mgr = this;
      this.platform = getPlatform();
      this.level = (_a2 = this.platform.getDefaultLogLevel()) != null ? _a2 : DEFAULT_LOG_LEVEL;
      this.handler = this.platform.log.bind(this.platform);
    }
    /**
     * Create a {@link Logger} with the given tag
     *
     * @param tag  Logger tag
     */
    create(tag) {
      return new Logger(this, tag);
    }
    /**
     * Filter logging by tags.
     *
     * @param cb
     */
    filter(cb) {
      this._filter = cb != null ? cb : defaultFilter;
    }
  }
  __publicField(LogManager, "OFF", 0);
  __publicField(LogManager, "ERROR", 1);
  __publicField(LogManager, "WARN", 2);
  __publicField(LogManager, "INFO", 3);
  __publicField(LogManager, "DEBUG", 4);
  __publicField(LogManager, "VERBOSE", 5);
  function sleepWithAbort(ms, signal) {
    return new Promise((resolve, reject) => {
      let timeout;
      const onAbort = () => {
        clearTimeoutWrap(timeout);
        reject(signal.reason);
      };
      signal.addEventListener("abort", onAbort);
      timeout = setTimeoutWrap(() => {
        signal.removeEventListener("abort", onAbort);
        resolve();
      }, ms);
    });
  }
  function getRandomInt(top) {
    return Math.floor(Math.random() * top);
  }
  function randomLong(unsigned = false) {
    const lo = getRandomInt(4294967295);
    const hi2 = getRandomInt(4294967295);
    return new Long(lo, hi2, unsigned);
  }
  function longFromBuffer(buf, unsigned = false, le = true) {
    const dv = dataViewFromBuffer(buf);
    if (le) {
      return new Long(dv.getInt32(0, true), dv.getInt32(4, true), unsigned);
    }
    return new Long(dv.getInt32(4, false), dv.getInt32(0, false), unsigned);
  }
  function removeFromLongArray(arr, val) {
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i];
      if (v === val || v.eq(val)) {
        arr.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  function compareLongs(a, b) {
    if (a.eq(b))
      return 0;
    if (a.gt(b))
      return 1;
    return -1;
  }
  function longToFastString(val) {
    return `${val.low}|${val.high}`;
  }
  function longFromFastString(val, unsigned = false) {
    const parts = val.split("|");
    if (parts.length !== 2)
      throw new Error(`Invalid long fast string: ${val}`);
    const low2 = Number.parseInt(parts[0]);
    const high = Number.parseInt(parts[1]);
    if (Number.isNaN(low2) || Number.isNaN(high)) {
      throw new TypeError(`Invalid long fast string: ${val}`);
    }
    return new Long(low2, high, unsigned);
  }
  class LongMap {
    constructor() {
      __publicField(this, "_map", /* @__PURE__ */ new Map());
    }
    set(key, value) {
      this._map.set(longToFastString(key), value);
    }
    has(key) {
      return this._map.has(longToFastString(key));
    }
    get(key) {
      return this._map.get(longToFastString(key));
    }
    delete(key) {
      this._map.delete(longToFastString(key));
    }
    *keys(unsigned) {
      for(let   v of this._map.keys()) {
        yield longFromFastString(v, unsigned);
      }
    }
    values() {
      return this._map.values();
    }
    clear() {
      this._map.clear();
    }
    size() {
      return this._map.size;
    }
  }
  class LongSet {
    constructor() {
      __publicField(this, "_set", /* @__PURE__ */ new Set());
    }
    get size() {
      return this._set.size;
    }
    add(val) {
      this._set.add(longToFastString(val));
    }
    delete(val) {
      this._set.delete(longToFastString(val));
    }
    has(val) {
      return this._set.has(longToFastString(val));
    }
    clear() {
      this._set.clear();
    }
    toArray() {
      const arr = [];
      for(let   v of this._set) {
        arr.push(longFromFastString(v));
      }
      return arr;
    }
  }
  class LruMap {
    constructor(capacity, forLong = false) {
      __publicField(this, "_capacity");
      __publicField(this, "_first");
      __publicField(this, "_last");
      __publicField(this, "_map");
      __publicField(this, "_size", 0);
      this._capacity = capacity;
      this._map = forLong ? new LongMap() : /* @__PURE__ */ new Map();
    }
    _markUsed(item) {
      if (item === this._first) {
        return;
      }
      if (item.p) {
        if (item === this._last) {
          this._last = item.p;
        }
        item.p.n = item.n;
      }
      if (item.n) {
        item.n.p = item.p;
      }
      item.p = void 0;
      item.n = this._first;
      if (this._first) {
        this._first.p = item;
      }
      this._first = item;
    }
    get(key) {
      const item = this._map.get(key);
      if (!item)
        return void 0;
      this._markUsed(item);
      return item.v;
    }
    has(key) {
      return this._map.has(key);
    }
    _remove(item) {
      if (item.p) {
        this._last = item.p;
        this._last.n = void 0;
      } else {
        this._last = void 0;
        this._first = void 0;
      }
      item.p = item.n = void 0;
      this._map.delete(item.k);
      this._size -= 1;
    }
    set(key, value) {
      let item = this._map.get(key);
      if (item) {
        item.v = value;
        this._markUsed(item);
        return;
      }
      item = {
        k: key,
        v: value,
        // for jit to optimize stuff
        n: void 0,
        p: void 0
      };
      this._map.set(key, item);
      if (this._first) {
        this._first.p = item;
        item.n = this._first;
      } else {
        this._last = item;
      }
      this._first = item;
      this._size += 1;
      if (this._size > this._capacity) {
        const oldest = this._last;
        if (oldest) {
          this._remove(oldest);
        }
      }
    }
    delete(key) {
      const item = this._map.get(key);
      if (item)
        this._remove(item);
    }
    clear() {
      this._map.clear();
      this._first = void 0;
      this._last = void 0;
      this._size = 0;
    }
  }
  class LruSet {
    constructor(capacity, forLong = false) {
      __publicField(this, "_capacity");
      __publicField(this, "_first");
      __publicField(this, "_last");
      __publicField(this, "_set");
      this._capacity = capacity;
      this._set = forLong ? new LongSet() : /* @__PURE__ */ new Set();
    }
    clear() {
      this._first = this._last = void 0;
      this._set.clear();
    }
    add(val) {
      if (this._set.has(val))
        return;
      if (!this._first)
        this._first = { v: val };
      if (!this._last) {
        this._last = this._first;
      } else {
        this._last.n = { v: val };
        this._last = this._last.n;
      }
      this._set.add(val);
      if (this._set.size > this._capacity && this._first) {
        this._set.delete(this._first.v);
        this._first = this._first.n;
      }
    }
    has(val) {
      return this._set.has(val);
    }
  }
  const ZERO_CHANNEL_ID = -1e12;
  const ZERO_SECRET_CHAT_ID = -2e12;
  const MAX_SECRET_CHAT_ID = -1997852516353;
  const MIN_MARKED_CHAT_ID = -999999999999;
  const MAX_USER_ID = 1099511627775;
  const MIN_MARKED_CHANNEL_ID = -1997852516352;
  function toggleChannelIdMark(id2) {
    return ZERO_CHANNEL_ID - id2;
  }
  function getBarePeerId(peer) {
    switch (peer._) {
      case "peerUser":
        return peer.userId;
      case "peerChat":
        return peer.chatId;
      case "peerChannel":
        return peer.channelId;
    }
  }
  function getMarkedPeerId(peer, peerType) {
    if (typeof peer === "number") {
      switch (peerType) {
        case "user":
          return peer;
        case "chat":
          return -peer;
        case "channel":
          return ZERO_CHANNEL_ID - peer;
      }
      throw new MtArgumentError("Invalid peer type");
    }
    switch (peer._) {
      case "mtcute.dummyInputPeerMinUser":
      case "peerUser":
      case "inputPeerUser":
      case "inputPeerUserFromMessage":
      case "inputUser":
      case "inputUserFromMessage":
        return peer.userId;
      case "peerChat":
      case "inputPeerChat":
        return -peer.chatId;
      case "mtcute.dummyInputPeerMinChannel":
      case "peerChannel":
      case "inputPeerChannel":
      case "inputPeerChannelFromMessage":
      case "inputChannel":
      case "inputChannelFromMessage":
        return ZERO_CHANNEL_ID - peer.channelId;
    }
    throw new MtArgumentError(`Invalid peer: ${peer._}`);
  }
  function parseMarkedPeerId(id2) {
    if (id2 < 0) {
      if (MIN_MARKED_CHAT_ID <= id2) {
        return ["chat", -id2];
      }
      if (MIN_MARKED_CHANNEL_ID <= id2 && id2 !== ZERO_CHANNEL_ID) {
        return ["channel", ZERO_CHANNEL_ID - id2];
      }
      if (MAX_SECRET_CHAT_ID >= id2 && id2 !== ZERO_SECRET_CHAT_ID) {
        throw new MtUnsupportedError("Secret chats are not supported");
      }
    } else if (id2 > 0 && id2 <= MAX_USER_ID) {
      return ["user", id2];
    }
    throw new MtArgumentError(`Invalid marked peer id: ${id2}`);
  }
  function* getAllPeersFrom(obj) {
    if (typeof obj !== "object")
      return;
    if (Array.isArray(obj)) {
      for(let   it of obj) {
        yield* __yieldStar(getAllPeersFrom(it));
      }
      return;
    }
    switch (obj._) {
      case "user":
      case "chat":
      case "channel":
      case "chatForbidden":
      case "channelForbidden":
        yield obj;
        return;
    }
    if ("user" in obj && typeof obj.user === "object" && obj.user._ === "user") {
      yield obj.user;
    }
    if ("chat" in obj && typeof obj.chat === "object") {
      switch (obj.chat._) {
        case "chat":
        case "channel":
        case "chatForbidden":
        case "channelForbidden":
          yield obj.chat;
          break;
      }
    }
    if ("channel" in obj && typeof obj.channel === "object") {
      switch (obj.channel._) {
        case "chat":
        case "channel":
        case "chatForbidden":
        case "channelForbidden":
          yield obj.channel;
          break;
      }
    }
    if ("users" in obj && Array.isArray(obj.users) && obj.users.length) {
      for(let   user of obj.users) {
        if (typeof user === "object" && user._ === "user") {
          yield user;
        }
      }
    }
    if ("chats" in obj && Array.isArray(obj.chats) && obj.chats.length) {
      for(let   chat of obj.chats) {
        if (typeof chat === "object") {
          switch (chat._) {
            case "chat":
            case "channel":
            case "chatForbidden":
            case "channelForbidden":
              yield chat;
              break;
          }
        }
      }
    }
  }
  class SortedArray {
    constructor(array = [], comparator) {
      __publicField(this, "raw");
      this.comparator = comparator;
      this.raw = array.sort(comparator);
      this.comparator = comparator;
    }
    get length() {
      return this.raw.length;
    }
    insert(item) {
      if (Array.isArray(item)) {
        let ind = -1;
        item.forEach((it) => {
          ind = this.insert(it);
        });
        return ind;
      }
      if (this.raw.length === 0) {
        this.raw.push(item);
        return 0;
      }
      let lo = 0;
      let hi2 = this.raw.length;
      while (lo < hi2) {
        const mid = Math.floor((lo + hi2) / 2);
        if (this.comparator(this.raw[mid], item) > 0) {
          hi2 = mid;
        } else {
          lo = mid + 1;
        }
      }
      this.raw.splice(lo, 0, item);
      return lo;
    }
    // closest: return the closest value (right-hand side)
    // meaning that raw[idx - 1] <= item <= raw[idx]
    // in other words, smallest idx such that raw[idx] >= item
    index(item, closest = false) {
      let lo = 0;
      let hi2 = this.raw.length;
      while (lo < hi2) {
        const mid = Math.floor((lo + hi2) / 2);
        const cmp = this.comparator(this.raw[mid], item);
        if (cmp === 0) {
          return mid;
        }
        if (cmp > 0) {
          hi2 = mid;
        } else {
          lo = mid + 1;
        }
      }
      return closest ? lo : -1;
    }
    remove(item) {
      const idx = this.index(item);
      if (idx === -1)
        return;
      this.raw.splice(idx, 1);
    }
    includes(item) {
      return this.index(item) !== -1;
    }
    find(item) {
      const ind = this.index(item);
      return ind === -1 ? null : this.raw[ind];
    }
    clear() {
      this.raw.length = 0;
    }
  }
  function tlJsonToJson(obj) {
    switch (obj._) {
      case "jsonNull":
        return null;
      case "jsonBool":
      case "jsonNumber":
      case "jsonString":
        return obj.value;
      case "jsonArray":
        return obj.value.map(tlJsonToJson);
    }
    const ret = {};
    obj.value.forEach((item) => {
      ret[item.key] = tlJsonToJson(item.value);
    });
    return ret;
  }
  class AuthKeysService extends BaseService {
    constructor(_keys, _salts, opts) {
      super(opts);
      this._keys = _keys;
      this._salts = _salts;
    }
    deleteByDc(dc) {
      return __async(this, null, function* () {
        yield this._keys.deleteByDc(dc);
        yield this._salts.delete(dc);
      });
    }
  }
  const KV_PREFIX = "salts:";
  class FutureSaltsService extends BaseService {
    constructor(_kv, opts) {
      super(opts);
      __publicField(this, "_cached", /* @__PURE__ */ new Map());
      this._kv = _kv;
    }
    store(dcId, salts) {
      return __async(this, null, function* () {
        if (this._cached.get(dcId) === salts)
          return;
        const writer2 = TlBinaryWriter.alloc(this._writerMap, 8 + 20 * salts.length);
        writer2.vector(writer2.object, salts);
        yield this._kv.set(KV_PREFIX + dcId, writer2.result());
      });
    }
    fetch(dcId) {
      return __async(this, null, function* () {
        const cached = this._cached.get(dcId);
        if (cached)
          return cached;
        const data2 = yield this._kv.get(KV_PREFIX + dcId);
        if (!data2)
          return null;
        const reader2 = new TlBinaryReader(this._readerMap, data2);
        const salts = reader2.vector();
        for(let   salt of salts) {
          if (salt._ !== "mt_future_salt")
            return null;
        }
        const salts_ = salts;
        this._cached.set(dcId, salts_);
        return salts_;
      });
    }
    delete(dcId) {
      return __async(this, null, function* () {
        this._cached.delete(dcId);
        yield this._kv.delete(KV_PREFIX + dcId);
      });
    }
  }
  class StorageManager {
    constructor(options) {
      __publicField(this, "provider");
      __publicField(this, "driver");
      __publicField(this, "log");
      __publicField(this, "dcs");
      __publicField(this, "salts");
      __publicField(this, "keys");
      __publicField(this, "_cleanupRestore");
      __publicField(this, "_load", asyncResettable(() => __async(this, null, function* () {
        var _a2, _b, _c, _d, _e;
        (_b = (_a2 = this.driver).setup) == null ? void 0 : _b.call(_a2, this.log);
        if ((_c = this.options.cleanup) != null ? _c : true) {
          this._cleanupRestore = getPlatform().beforeExit(() => {
            this._destroy().catch((err2) => this.log.error("cleanup error: %e", err2));
          });
        }
        yield (_e = (_d = this.driver).load) == null ? void 0 : _e.call(_d);
      })));
      this.options = options;
      this.provider = this.options.provider;
      this.driver = this.provider.driver;
      this.log = this.options.log.create("storage");
      const serviceOptions = {
        driver: this.driver,
        readerMap: this.options.readerMap,
        writerMap: this.options.writerMap,
        log: this.log
      };
      this.dcs = new DefaultDcsService(this.provider.kv, serviceOptions);
      this.salts = new FutureSaltsService(this.provider.kv, serviceOptions);
      this.keys = new AuthKeysService(this.provider.authKeys, this.salts, serviceOptions);
    }
    load() {
      return this._load.run();
    }
    save() {
      return __async(this, null, function* () {
        var _a2, _b;
        yield (_b = (_a2 = this.driver).save) == null ? void 0 : _b.call(_a2);
      });
    }
    clear(withAuthKeys = false) {
      return __async(this, null, function* () {
        if (withAuthKeys) {
          yield this.provider.authKeys.deleteAll();
        }
        yield this.provider.kv.deleteAll();
        yield this.save();
      });
    }
    _destroy() {
      return __async(this, null, function* () {
        var _a2, _b;
        if (!this._load.finished())
          return;
        yield this._load.wait();
        yield (_b = (_a2 = this.driver).destroy) == null ? void 0 : _b.call(_a2);
        this._load.reset();
      });
    }
    destroy() {
      return __async(this, null, function* () {
        if (this._cleanupRestore) {
          this._cleanupRestore();
          this._cleanupRestore = void 0;
        }
        yield this._destroy();
      });
    }
  }
  class Reloadable {
    constructor(params) {
      __publicField(this, "_data");
      __publicField(this, "_expiresAt", 0);
      __publicField(this, "_listeners", []);
      __publicField(this, "_timeout");
      __publicField(this, "_reload", asyncResettable(() => __async(this, null, function* () {
        const data2 = yield this.params.reload(this._data);
        this.setData(data2);
        this._listeners.forEach((cb) => cb(data2));
      })));
      this.params = params;
    }
    get isStale() {
      return !this._data || this._expiresAt <= Date.now();
    }
    setData(data2) {
      const expiresAt = this.params.getExpiresAt(data2);
      this._data = data2;
      this._expiresAt = expiresAt;
      if (this._timeout)
        clearTimeoutWrap(this._timeout);
      if (!this.params.disableAutoReload) {
        this._timeout = setTimeoutWrap(() => {
          this._reload.reset();
          this.update().catch((err2) => {
            var _a2, _b;
            (_b = (_a2 = this.params).onError) == null ? void 0 : _b.call(_a2, err2);
          });
        }, expiresAt - Date.now());
      }
    }
    update(force = false) {
      if (!force && !this.isStale)
        return Promise.resolve();
      return this._reload.run();
    }
    onReload(cb) {
      this._listeners.push(cb);
    }
    offReload(cb) {
      const idx = this._listeners.indexOf(cb);
      if (idx >= 0)
        this._listeners.splice(idx, 1);
    }
    getNow() {
      return this._data;
    }
    get() {
      return __async(this, null, function* () {
        yield this.update();
        return this._data;
      });
    }
    destroy() {
      if (this._timeout)
        clearTimeoutWrap(this._timeout);
      this._listeners.length = 0;
      this._reload.reset();
    }
  }
  class ConfigManager extends Reloadable {
    constructor(update) {
      super({
        reload: update,
        getExpiresAt: (data2) => data2.expires * 1e3
      });
    }
    findOption(params) {
      return __async(this, null, function* () {
        if (this.isStale)
          yield this.update();
        const options = this._data.dcOptions.filter((opt) => {
          if (opt.tcpoOnly)
            return false;
          if (opt.ipv6 && !params.allowIpv6)
            return false;
          if (opt.mediaOnly && !params.allowMedia)
            return false;
          if (opt.cdn && !params.cdn)
            return false;
          return opt.id === params.dcId;
        });
        if (params.preferMedia && params.preferIpv6) {
          const r = options.find((opt) => opt.mediaOnly && opt.ipv6);
          if (r)
            return r;
        }
        if (params.preferMedia) {
          const r = options.find((opt) => opt.mediaOnly);
          if (r)
            return r;
        }
        if (params.preferIpv6) {
          const r = options.find((opt) => opt.ipv6);
          if (r)
            return r;
        }
        return options[0];
      });
    }
  }
  function combineAbortSignals(signal1, signal2) {
    if (!signal2)
      return signal1;
    const controller = new AbortController();
    signal1.addEventListener("abort", () => controller.abort());
    signal2.addEventListener("abort", () => controller.abort());
    return controller.signal;
  }
  function floodWaiter(options) {
    const { maxWait = 1e4, maxRetries = 5, store: store2 = true, minStoredWait = 3e3 } = options;
    const storage = /* @__PURE__ */ new Map();
    return (ctx, next) => __async(this, null, function* () {
      var _a2, _b, _c, _d;
      const method = ctx.request._;
      const storedWaitUntil = store2 ? storage.get(method) : void 0;
      const floodSleepThreshold = (_b = (_a2 = ctx.params) == null ? void 0 : _a2.floodSleepThreshold) != null ? _b : maxWait;
      if (storedWaitUntil !== void 0) {
        const delta = storedWaitUntil - Date.now();
        if (delta <= minStoredWait) {
          storage.delete(method);
        } else if (delta <= floodSleepThreshold) {
          yield sleepWithAbort(delta, combineAbortSignals(ctx.manager.params.stopSignal, (_c = ctx.params) == null ? void 0 : _c.abortSignal));
          storage.delete(method);
        } else {
          return {
            _: "mt_rpc_error",
            errorCode: 420,
            errorMessage: `FLOOD_WAIT_${Math.ceil(delta / 1e3)}`
          };
        }
      }
      let lastError;
      for (let i = 0; i <= maxRetries; i++) {
        const res = yield next(ctx);
        if (!isTlRpcError(res)) {
          return res;
        }
        lastError = res;
        const err2 = res.errorMessage;
        if (err2.startsWith("FLOOD_WAIT_") || err2.startsWith("SLOWMODE_WAIT_") || err2.startsWith("FLOOD_TEST_PHONE_WAIT_")) {
          let seconds = Number(err2.slice(err2.lastIndexOf("_") + 1));
          if (Number.isNaN(seconds)) {
            ctx.manager._log.warn("invalid flood wait error received: %s, ignoring", err2);
            return res;
          }
          if (store2 && !err2.startsWith("SLOWMODE_WAIT_")) {
            storage.set(method, Date.now() + seconds * 1e3);
          }
          if (seconds === 0) {
            seconds = 1;
          }
          const ms = seconds * 1e3;
          if (ms <= floodSleepThreshold) {
            ctx.manager._log.warn("%s resulted in a flood wait, will retry in %d seconds", method, seconds);
            yield sleepWithAbort(
              ms,
              combineAbortSignals(ctx.manager.params.stopSignal, (_d = ctx.params) == null ? void 0 : _d.abortSignal)
            );
            continue;
          }
        }
        return res;
      }
      return lastError;
    });
  }
  const CLIENT_ERRORS = /* @__PURE__ */ new Set([
    tl.tl.RpcError.BAD_REQUEST,
    tl.tl.RpcError.UNAUTHORIZED,
    tl.tl.RpcError.FORBIDDEN,
    tl.tl.RpcError.NOT_FOUND,
    tl.tl.RpcError.FLOOD,
    tl.tl.RpcError.SEE_OTHER,
    tl.tl.RpcError.NOT_ACCEPTABLE
  ]);
  function internalErrorsHandler(params) {
    const { maxRetries = Infinity, waitTime = 1 } = params;
    return (ctx, next) => __async(this, null, function* () {
      var _a2, _b, _c, _d;
      const numRetries = (_b = (_a2 = ctx.params) == null ? void 0 : _a2.maxRetryCount) != null ? _b : maxRetries;
      for (let i = 0; i <= numRetries; i++) {
        const res = yield next(ctx);
        if (!isTlRpcError(res))
          return res;
        if (!CLIENT_ERRORS.has(res.errorCode)) {
          if (((_c = ctx.params) == null ? void 0 : _c.throw503) && res.errorCode === -503) {
            throw new MtTimeoutError();
          }
          const waitSeconds = res.errorMessage === "WORKER_BUSY_TOO_LONG_RETRY" ? Math.max(1, waitTime) : waitTime;
          ctx.manager._log.warn(
            "Telegram is having internal issues: %d:%s, retrying in %ds",
            res.errorCode,
            res.errorMessage,
            waitSeconds
          );
          if (waitSeconds > 0) {
            yield sleepWithAbort(
              waitSeconds * 1e3,
              combineAbortSignals(ctx.manager.params.stopSignal, (_d = ctx.params) == null ? void 0 : _d.abortSignal)
            );
          }
          continue;
        }
        return res;
      }
    });
  }
  function basic(options) {
    return [floodWaiter({}), internalErrorsHandler({})];
  }
  class AuthKey {
    constructor(_crypto, log, _readerMap) {
      __publicField(this, "ready", false);
      __publicField(this, "key");
      __publicField(this, "id");
      __publicField(this, "clientSalt");
      __publicField(this, "serverSalt");
      this._crypto = _crypto;
      this.log = log;
      this._readerMap = _readerMap;
    }
    match(keyId) {
      return this.ready && buffersEqual(keyId, this.id);
    }
    setup(authKey) {
      if (!authKey)
        return this.reset();
      this.ready = true;
      this.key = authKey;
      this.clientSalt = authKey.subarray(88, 120);
      this.serverSalt = authKey.subarray(96, 128);
      this.id = this._crypto.sha1(authKey).subarray(-8);
      this.log.verbose("auth key set up, id = %h", this.id);
    }
    encryptMessage(message2, serverSalt, sessionId) {
      if (!this.ready)
        throw new MtcuteError("Keys are not set up!");
      let padding = (16 + message2.length + 12) % 16;
      padding = 12 + (padding ? 16 - padding : 0);
      const buf = new Uint8Array(16 + message2.length + padding);
      const dv = dataViewFromBuffer(buf);
      dv.setInt32(0, serverSalt.low, true);
      dv.setInt32(4, serverSalt.high, true);
      dv.setInt32(8, sessionId.low, true);
      dv.setInt32(12, sessionId.high, true);
      buf.set(message2, 16);
      this._crypto.randomFill(buf.subarray(16 + message2.length, 16 + message2.length + padding));
      const messageKey = this._crypto.sha256(concatBuffers([this.clientSalt, buf])).subarray(8, 24);
      const ige = createAesIgeForMessage(this._crypto, this.key, messageKey, true);
      const encryptedData = ige.encrypt(buf);
      return concatBuffers([this.id, messageKey, encryptedData]);
    }
    decryptMessage(data2, sessionId, callback) {
      const messageKey = data2.subarray(8, 24);
      let encryptedData = data2.subarray(24);
      const mod16 = encryptedData.byteLength % 16;
      if (mod16 !== 0) {
        encryptedData = encryptedData.subarray(0, encryptedData.byteLength - mod16);
      }
      const ige = createAesIgeForMessage(this._crypto, this.key, messageKey, false);
      const innerData = ige.decrypt(encryptedData);
      const msgKeySource = this._crypto.sha256(concatBuffers([this.serverSalt, innerData]));
      const expectedMessageKey = msgKeySource.subarray(8, 24);
      if (!buffersEqual(messageKey, expectedMessageKey)) {
        this.log.warn("received message with invalid messageKey = %h (expected %h)", messageKey, expectedMessageKey);
        return;
      }
      const innerReader = new TlBinaryReader(this._readerMap, innerData);
      innerReader.seek(8);
      const sessionId_ = innerReader.long();
      const messageId = innerReader.long(true);
      if (sessionId_.neq(sessionId)) {
        this.log.warn("ignoring message with invalid sessionId = %h", sessionId_);
        return;
      }
      const seqNo = innerReader.uint();
      const length = innerReader.uint();
      if (length > innerData.length - 32) {
        this.log.warn("ignoring message with invalid length: %d > %d", length, innerData.length - 32);
        return;
      }
      if (length % 4 !== 0) {
        this.log.warn("ignoring message with invalid length: %d is not a multiple of 4", length);
        return;
      }
      const paddingSize = innerData.length - length - 32;
      if (paddingSize < 12 || paddingSize > 1024) {
        this.log.warn("ignoring message with invalid padding size: %d", paddingSize);
        return;
      }
      callback(messageId, seqNo, innerReader);
    }
    copyFrom(authKey) {
      this.ready = authKey.ready;
      this.key = authKey.key;
      this.id = authKey.id;
      this.serverSalt = authKey.serverSalt;
      this.clientSalt = authKey.clientSalt;
    }
    reset() {
      this.ready = false;
    }
  }
  class MtprotoSession {
    constructor(_crypto, log, _readerMap, _writerMap, _salts) {
      __publicField(this, "_sessionId", randomLong());
      __publicField(this, "_authKey");
      __publicField(this, "_authKeyTemp");
      __publicField(this, "_authKeyTempSecondary");
      __publicField(this, "_timeOffset", 0);
      __publicField(this, "_lastMessageId", Long.ZERO);
      __publicField(this, "_seqNo", 0);
      /// state ///
      // recent msg ids
      __publicField(this, "recentOutgoingMsgIds", new LruSet(1e3, true));
      __publicField(this, "recentIncomingMsgIds", new LruSet(1e3, true));
      // queues
      __publicField(this, "queuedRpc", new Deque());
      __publicField(this, "queuedAcks", []);
      __publicField(this, "queuedStateReq", []);
      __publicField(this, "queuedResendReq", []);
      __publicField(this, "queuedCancelReq", []);
      __publicField(this, "getStateSchedule", new SortedArray([], (a, b) => a.getState - b.getState));
      __publicField(this, "chains", /* @__PURE__ */ new Map());
      __publicField(this, "chainsPendingFails", /* @__PURE__ */ new Map());
      // requests info
      __publicField(this, "pendingMessages", new LongMap());
      __publicField(this, "destroySessionIdToMsgId", new LongMap());
      __publicField(this, "lastPingRtt", Number.NaN);
      __publicField(this, "lastPingTime", 0);
      __publicField(this, "lastPingMsgId", Long.ZERO);
      __publicField(this, "lastSessionCreatedUid", Long.ZERO);
      __publicField(this, "initConnectionCalled", false);
      __publicField(this, "authorizationPending", false);
      __publicField(this, "next429Timeout", 1e3);
      __publicField(this, "current429Timeout");
      __publicField(this, "next429ResetTimeout");
      this._crypto = _crypto;
      this.log = log;
      this._readerMap = _readerMap;
      this._writerMap = _writerMap;
      this._salts = _salts;
      this.log.prefix = `[SESSION ${this._sessionId.toString(16)}] `;
      this._authKey = new AuthKey(_crypto, log, _readerMap);
      this._authKeyTemp = new AuthKey(_crypto, log, _readerMap);
      this._authKeyTempSecondary = new AuthKey(_crypto, log, _readerMap);
    }
    get hasPendingMessages() {
      return Boolean(
        this.queuedRpc.length || this.queuedAcks.length || this.queuedStateReq.length || this.queuedResendReq.length
      );
    }
    /**
     * Reset session by resetting auth key(s) and session state
     */
    reset(withAuthKey = false) {
      if (withAuthKey) {
        this.resetAuthKey();
      }
      clearTimeoutWrap(this.current429Timeout);
      this.resetState(withAuthKey);
      this.resetLastPing(true);
    }
    resetAuthKey() {
      this._authKey.reset();
      this._authKeyTemp.reset();
      this._authKeyTempSecondary.reset();
    }
    updateTimeOffset(offset) {
      this.log.debug("time offset updated: %d", offset);
      this._timeOffset = offset;
      this._lastMessageId = Long.ZERO;
    }
    /**
     * Reset session state and generate a new session ID.
     *
     * By default, also cancels any pending RPC requests.
     * If `keepPending` is set to `true`, pending requests will be kept
     */
    resetState(keepPending = false) {
      this._lastMessageId = Long.ZERO;
      this._seqNo = 0;
      this._sessionId = randomLong();
      this.log.debug("session reset, new sid = %h", this._sessionId);
      this.log.prefix = `[SESSION ${this._sessionId.toString(16)}] `;
      if (!keepPending) {
        for(let   info of this.pendingMessages.values()) {
          if (info._ === "rpc") {
            this.log.debug("rejecting pending rpc %s", info.rpc.method);
            info.rpc.promise.reject(new MtcuteError("Session is reset"));
          }
        }
        this.pendingMessages.clear();
      }
      this.recentOutgoingMsgIds.clear();
      this.recentIncomingMsgIds.clear();
      if (!keepPending) {
        while (this.queuedRpc.length) {
          const rpc = this.queuedRpc.popFront();
          if (rpc.sent === false) {
            this.log.debug("rejecting pending rpc %s", rpc.method);
            rpc.promise.reject(new MtcuteError("Session is reset"));
          }
        }
      }
      this.queuedAcks.length = 0;
      this.queuedStateReq.length = 0;
      this.queuedResendReq.length = 0;
      this.queuedCancelReq.length = 0;
      this.getStateSchedule.clear();
      this.chains.clear();
      this.chainsPendingFails.clear();
    }
    enqueueRpc(rpc, force) {
      if (!force && !rpc.sent || rpc.cancelled)
        return false;
      rpc.sent = false;
      rpc.containerId = void 0;
      this.log.debug("enqueued %s for sending (msg_id = %s)", rpc.method, rpc.msgId || "n/a");
      this.queuedRpc.pushBack(rpc);
      return true;
    }
    getMessageId() {
      const timeTicks = Date.now();
      const timeSec = Math.floor(timeTicks / 1e3) - this._timeOffset;
      const timeMSec = timeTicks % 1e3;
      const random = getRandomInt(65535);
      let messageId = new Long(timeMSec << 21 | random << 3 | 4, timeSec);
      if (this._lastMessageId.ge(messageId)) {
        messageId = this._lastMessageId.add(4);
      }
      this._lastMessageId = messageId;
      return messageId;
    }
    getSeqNo(isContentRelated = true) {
      let seqNo = this._seqNo;
      if (isContentRelated) {
        seqNo += 1;
        this._seqNo += 2;
      }
      return seqNo;
    }
    /** Encrypt a single MTProto message using session's keys */
    encryptMessage(message2) {
      const key = this._authKeyTemp.ready ? this._authKeyTemp : this._authKey;
      return key.encryptMessage(message2, this._salts.currentSalt, this._sessionId);
    }
    /** Decrypt a single MTProto message using session's keys */
    decryptMessage(data2, callback) {
      if (!this._authKey.ready)
        throw new MtcuteError("Keys are not set up!");
      const authKeyId = data2.subarray(0, 8);
      let key;
      if (this._authKey.match(authKeyId)) {
        key = this._authKey;
      } else if (this._authKeyTemp.match(authKeyId)) {
        key = this._authKeyTemp;
      } else if (this._authKeyTempSecondary.match(authKeyId)) {
        key = this._authKeyTempSecondary;
      } else {
        this.log.warn(
          "received message with unknown authKey = %h (expected %h or %h or %h)",
          authKeyId,
          this._authKey.id,
          this._authKeyTemp.id,
          this._authKeyTempSecondary.id
        );
        return;
      }
      return key.decryptMessage(data2, this._sessionId, callback);
    }
    writeMessage(writer2, content, isContentRelated = true) {
      const messageId = this.getMessageId();
      const seqNo = this.getSeqNo(isContentRelated);
      const length = ArrayBuffer.isView(content) ? content.length : TlSerializationCounter.countNeededBytes(writer2.objectMap, content);
      writer2.long(messageId);
      writer2.int(seqNo);
      writer2.uint(length);
      if (ArrayBuffer.isView(content))
        writer2.raw(content);
      else
        writer2.object(content);
      return messageId;
    }
    onTransportFlood(callback) {
      if (this.current429Timeout)
        return;
      this.resetLastPing(true);
      const timeout = this.next429Timeout;
      this.next429Timeout = Math.min(this.next429Timeout * 2, 32e3);
      clearTimeoutWrap(this.current429Timeout);
      clearTimeoutWrap(this.next429ResetTimeout);
      this.current429Timeout = setTimeoutWrap(() => {
        this.current429Timeout = void 0;
        callback();
      }, timeout);
      this.next429ResetTimeout = setTimeoutWrap(() => {
        this.next429ResetTimeout = void 0;
        this.next429Timeout = 1e3;
      }, 6e4);
      this.log.debug("transport flood, waiting for %d ms before proceeding", timeout);
      return Date.now() + timeout;
    }
    resetLastPing(withTime = false) {
      if (withTime)
        this.lastPingTime = 0;
      if (!this.lastPingMsgId.isZero()) {
        this.pendingMessages.delete(this.lastPingMsgId);
      }
      this.lastPingMsgId = Long.ZERO;
    }
    addToChain(chainId, msgId) {
      const prevMsgId = this.chains.get(chainId);
      this.chains.set(chainId, msgId);
      this.log.debug("added message %l to chain %s (prev: %l)", msgId, chainId, prevMsgId);
      return prevMsgId;
    }
    removeFromChain(chainId, msgId) {
      const lastMsgId = this.chains.get(chainId);
      if (!lastMsgId) {
        this.log.warn("tried to remove message %l from empty chain %s", msgId, chainId);
        return;
      }
      if (lastMsgId.eq(msgId)) {
        this.log.debug("chain %s: exhausted, last message %l", chainId, msgId);
        this.chains.delete(chainId);
      }
    }
    getPendingChainedFails(chainId) {
      let arr = this.chainsPendingFails.get(chainId);
      if (!arr) {
        arr = new SortedArray([], (a, b) => compareLongs(a.invokeAfter, b.invokeAfter));
        this.chainsPendingFails.set(chainId, arr);
      }
      return arr;
    }
  }
  const TWO_ZERO_FOUR_EIGHT = JSBI.BigInt(2048);
  const DH_SAFETY_RANGE = JSBI.exponentiate(TWO, JSBI.subtract(TWO_ZERO_FOUR_EIGHT, JSBI.BigInt(64)));
  const KNOWN_DH_PRIME = JSBI.BigInt("0xC71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F87FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B");
  const TWO_POW_2047 = JSBI.exponentiate(TWO, JSBI.BigInt(2047));
  const TWO_POW_2048 = JSBI.exponentiate(TWO, TWO_ZERO_FOUR_EIGHT);
  const checkedPrimesCache = [];
  const THREE = JSBI.BigInt(3);
  const FOUR = JSBI.BigInt(4);
  const FIVE = JSBI.BigInt(5);
  const SIX = JSBI.BigInt(6);
  const SEVEN = JSBI.BigInt(7);
  const EIGHT = JSBI.BigInt(8);
  const TWENTYFOUR = JSBI.BigInt(24);
  const NINETEEN = JSBI.BigInt(19);
  const TWENTYTHREE = JSBI.BigInt(23);
  function checkDhPrime(crypto2, log, dhPrime, g) {
    if (JSBI.equal(KNOWN_DH_PRIME, dhPrime)) {
      log.debug("server is using known dh prime, skipping validation");
      return;
    }
    let checkedPrime = checkedPrimesCache.find((x) => JSBI.equal(x.prime, dhPrime));
    if (!checkedPrime) {
      if (JSBI.lessThanOrEqual(dhPrime, TWO_POW_2047) || JSBI.greaterThanOrEqual(dhPrime, TWO_POW_2048)) {
        throw new MtSecurityError("Step 3: dh_prime is not in the 2048-bit range");
      }
      if (!millerRabin(crypto2, dhPrime)) {
        throw new MtSecurityError("Step 3: dh_prime is not prime");
      }
      if (!millerRabin(crypto2, JSBI.divide(JSBI.subtract(dhPrime, ONE), TWO))) {
        throw new MtSecurityError("Step 3: dh_prime is not a safe prime - (dh_prime-1)/2 is not prime");
      }
      log.debug("dh_prime is probably prime");
      checkedPrime = {
        prime: dhPrime,
        generators: []
      };
      checkedPrimesCache.push(checkedPrime);
    } else {
      log.debug("dh_prime is probably prime (cached)");
    }
    const generatorChecked = checkedPrime.generators.includes(g);
    if (generatorChecked) {
      log.debug("g = %d is already checked for dh_prime", g);
      return;
    }
    switch (g) {
      case 2:
        if (JSBI.notEqual(JSBI.remainder(dhPrime, EIGHT), SEVEN)) {
          throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 8 != 7");
        }
        break;
      case 3:
        if (JSBI.notEqual(JSBI.remainder(dhPrime, THREE), TWO)) {
          throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 3 != 2");
        }
        break;
      case 4:
        break;
      case 5: {
        const mod = JSBI.remainder(dhPrime, FIVE);
        if (JSBI.notEqual(mod, ONE) && JSBI.notEqual(mod, FOUR)) {
          throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 5 != 1 && dh_prime mod 5 != 4");
        }
        break;
      }
      case 6: {
        const mod = JSBI.remainder(dhPrime, TWENTYFOUR);
        if (JSBI.notEqual(mod, NINETEEN) && JSBI.notEqual(mod, TWENTYTHREE)) {
          throw new MtSecurityError("Step 3: ivalid g - dh_prime mod 24 != 19 && dh_prime mod 24 != 23");
        }
        break;
      }
      case 7: {
        const mod = JSBI.remainder(dhPrime, SEVEN);
        if (JSBI.notEqual(mod, THREE) && JSBI.notEqual(mod, FIVE) && JSBI.notEqual(mod, SIX)) {
          throw new MtSecurityError(
            "Step 3: ivalid g - dh_prime mod 7 != 3 && dh_prime mod 7 != 5 && dh_prime mod 7 != 6"
          );
        }
        break;
      }
      default:
        throw new MtSecurityError(`Step 3: ivalid g - unknown g = ${g}`);
    }
    checkedPrime.generators.push(g);
    log.debug("g = %d is safe to use with dh_prime", g);
  }
  function rsaPad(data2, crypto2, key) {
    const keyModulus = JSBI.BigInt(`0x${key.modulus}`);
    const keyExponent = JSBI.BigInt(`0x${key.exponent}`);
    if (data2.length > 144) {
      throw new MtArgumentError("Failed to pad: too big data");
    }
    const dataPadded = new Uint8Array(192);
    dataPadded.set(data2, 0);
    crypto2.randomFill(dataPadded.subarray(data2.length));
    data2 = dataPadded;
    for (; ; ) {
      const aesIv = new Uint8Array(32);
      const aesKey = crypto2.randomBytes(32);
      const dataWithHash = concatBuffers([data2, crypto2.sha256(concatBuffers([aesKey, data2]))]);
      dataWithHash.subarray(0, 192).reverse();
      const aes = crypto2.createAesIge(aesKey, aesIv);
      const encrypted = aes.encrypt(dataWithHash);
      const encryptedHash = crypto2.sha256(encrypted);
      xorBufferInPlace(aesKey, encryptedHash);
      const decryptedData = concatBuffers([aesKey, encrypted]);
      const decryptedDataBigint = bufferToBigInt(decryptedData);
      if (JSBI.greaterThanOrEqual(decryptedDataBigint, keyModulus)) {
        continue;
      }
      const encryptedBigint = bigIntModPow(decryptedDataBigint, keyExponent, keyModulus);
      return bigIntToBuffer(encryptedBigint, 256);
    }
  }
  function rsaEncrypt(data2, crypto2, key) {
    const toEncrypt = concatBuffers([
      crypto2.sha1(data2),
      data2,
      // sha1 is always 20 bytes, so we're left with 255 - 20 - x padding
      crypto2.randomBytes(235 - data2.length)
    ]);
    const encryptedBigInt = bigIntModPow(
      bufferToBigInt(toEncrypt),
      JSBI.BigInt(`0x${key.exponent}`),
      JSBI.BigInt(`0x${key.modulus}`)
    );
    return bigIntToBuffer(encryptedBigInt);
  }
  function doAuthorization(connection, crypto2, expiresIn) {
    return __async(this, null, function* () {
      const session = connection["_session"];
      const readerMap = session._readerMap;
      const writerMap = session._writerMap;
      const log = connection.log.create("auth");
      function sendPlainMessage(message2) {
        const length = TlSerializationCounter.countNeededBytes(writerMap, message2);
        const writer2 = TlBinaryWriter.alloc(writerMap, length + 20);
        const messageId = session.getMessageId();
        log.verbose("[PLAIN] >>> %j", message2);
        writer2.long(Long.ZERO);
        writer2.long(messageId);
        writer2.uint(length);
        writer2.object(message2);
        return connection.send(writer2.result());
      }
      function readNext() {
        return __async(this, null, function* () {
          const res = TlBinaryReader.deserializeObject(
            readerMap,
            yield connection.waitForUnencryptedMessage(),
            20
            // skip mtproto header
          );
          log.verbose("[PLAIN] <<< %j", res);
          return res;
        });
      }
      if (expiresIn)
        log.prefix = "[PFS] ";
      const nonce = crypto2.randomBytes(16);
      log.debug("starting PQ handshake (temp = %b), nonce = %h", expiresIn, nonce);
      yield sendPlainMessage({ _: "mt_req_pq_multi", nonce });
      const resPq = yield readNext();
      mtpAssertTypeIs("auth step 1", resPq, "mt_resPQ");
      if (!buffersEqual(resPq.nonce, nonce)) {
        throw new MtSecurityError("Step 1: invalid nonce from server");
      }
      const serverKeys = resPq.serverPublicKeyFingerprints.map((it) => it.toUnsigned().toString(16));
      log.debug("received PQ, keys: %j", serverKeys);
      const publicKey = findKeyByFingerprints(serverKeys);
      if (!publicKey) {
        throw new MtSecurityError(
          `Step 2: Could not find server public key with any of these fingerprints: ${serverKeys.join(", ")}`
        );
      }
      log.debug("found server key, fp = %s, old = %s", publicKey.fingerprint, publicKey.old);
      if (millerRabin(crypto2, bufferToBigInt(resPq.pq))) {
        throw new MtSecurityError("Step 2: pq is prime");
      }
      const [p, q] = yield crypto2.factorizePQ(resPq.pq);
      log.debug("factorized PQ: PQ = %h, P = %h, Q = %h", resPq.pq, p, q);
      const newNonce = crypto2.randomBytes(32);
      let dcId = connection.params.dc.id;
      if (connection.params.testMode)
        dcId += 1e4;
      if (connection.params.dc.mediaOnly)
        dcId = -dcId;
      const _pqInnerData = {
        _: expiresIn ? "mt_p_q_inner_data_temp_dc" : "mt_p_q_inner_data_dc",
        pq: resPq.pq,
        p,
        q,
        nonce,
        newNonce,
        serverNonce: resPq.serverNonce,
        dc: dcId,
        expiresIn
        // whatever
      };
      const pqInnerData = TlBinaryWriter.serializeObject(writerMap, _pqInnerData);
      const encryptedData = publicKey.old ? rsaEncrypt(pqInnerData, crypto2, publicKey) : rsaPad(pqInnerData, crypto2, publicKey);
      log.debug("requesting DH params");
      yield sendPlainMessage({
        _: "mt_req_DH_params",
        nonce,
        serverNonce: resPq.serverNonce,
        p,
        q,
        publicKeyFingerprint: Long.fromString(publicKey.fingerprint, true, 16),
        encryptedData
      });
      const serverDhParams = yield readNext();
      mtpAssertTypeIs("auth step 2", serverDhParams, "mt_server_DH_params_ok");
      if (!buffersEqual(serverDhParams.nonce, nonce)) {
        throw new MtSecurityError("Step 2: invalid nonce from server");
      }
      if (!buffersEqual(serverDhParams.serverNonce, resPq.serverNonce)) {
        throw new MtSecurityError("Step 2: invalid server nonce from server");
      }
      log.debug("server DH ok");
      if (serverDhParams.encryptedAnswer.length % 16 !== 0) {
        throw new MtSecurityError("Step 2: AES block size is invalid");
      }
      const [key, iv] = generateKeyAndIvFromNonce(crypto2, resPq.serverNonce, newNonce);
      const ige = crypto2.createAesIge(key, iv);
      const plainTextAnswer = ige.decrypt(serverDhParams.encryptedAnswer);
      const innerDataHash = plainTextAnswer.subarray(0, 20);
      const serverDhInnerReader = new TlBinaryReader(readerMap, plainTextAnswer, 20);
      const serverDhInner = serverDhInnerReader.object();
      if (!buffersEqual(innerDataHash, crypto2.sha1(plainTextAnswer.subarray(20, serverDhInnerReader.pos)))) {
        throw new MtSecurityError("Step 3: invalid inner data hash");
      }
      mtpAssertTypeIs("auth step 3", serverDhInner, "mt_server_DH_inner_data");
      if (!buffersEqual(serverDhInner.nonce, nonce)) {
        throw new Error("Step 3: invalid nonce from server");
      }
      if (!buffersEqual(serverDhInner.serverNonce, resPq.serverNonce)) {
        throw new Error("Step 3: invalid server nonce from server");
      }
      const dhPrime = bufferToBigInt(serverDhInner.dhPrime);
      const timeOffset = Math.floor(Date.now() / 1e3) - serverDhInner.serverTime;
      session.updateTimeOffset(timeOffset);
      const g = JSBI.BigInt(serverDhInner.g);
      const gA = bufferToBigInt(serverDhInner.gA);
      checkDhPrime(crypto2, log, dhPrime, serverDhInner.g);
      let retryId = Long.ZERO;
      const serverSalt = xorBuffer(newNonce.subarray(0, 8), resPq.serverNonce.subarray(0, 8));
      for (; ; ) {
        const b = bufferToBigInt(crypto2.randomBytes(256));
        const gB = bigIntModPow(g, b, dhPrime);
        const authKey = bigIntToBuffer(bigIntModPow(gA, b, dhPrime));
        const authKeyAuxHash = crypto2.sha1(authKey).subarray(0, 8);
        if (JSBI.lessThanOrEqual(g, ONE) || JSBI.greaterThanOrEqual(g, JSBI.subtract(dhPrime, ONE))) {
          throw new MtSecurityError("g is not within (1, dh_prime - 1)");
        }
        if (JSBI.lessThanOrEqual(gA, ONE) || JSBI.greaterThanOrEqual(gA, JSBI.subtract(dhPrime, ONE))) {
          throw new MtSecurityError("g_a is not within (1, dh_prime - 1)");
        }
        if (JSBI.lessThanOrEqual(gB, ONE) || JSBI.greaterThanOrEqual(gB, JSBI.subtract(dhPrime, ONE))) {
          throw new MtSecurityError("g_b is not within (1, dh_prime - 1)");
        }
        if (JSBI.lessThanOrEqual(gA, DH_SAFETY_RANGE) || JSBI.greaterThanOrEqual(gA, JSBI.subtract(dhPrime, DH_SAFETY_RANGE))) {
          throw new MtSecurityError("g_a is not within (2^{2048-64}, dh_prime - 2^{2048-64})");
        }
        if (JSBI.lessThanOrEqual(gB, DH_SAFETY_RANGE) || JSBI.greaterThanOrEqual(gB, JSBI.subtract(dhPrime, DH_SAFETY_RANGE))) {
          throw new MtSecurityError("g_b is not within (2^{2048-64}, dh_prime - 2^{2048-64})");
        }
        const gB_ = bigIntToBuffer(gB, 0, false);
        const clientDhInner = {
          _: "mt_client_DH_inner_data",
          nonce,
          serverNonce: resPq.serverNonce,
          retryId,
          gB: gB_
        };
        let innerLength = TlSerializationCounter.countNeededBytes(writerMap, clientDhInner) + 20;
        const innerPaddingLength = innerLength % 16;
        if (innerPaddingLength > 0)
          innerLength += 16 - innerPaddingLength;
        const clientDhInnerWriter = TlBinaryWriter.alloc(writerMap, innerLength);
        clientDhInnerWriter.pos = 20;
        clientDhInnerWriter.object(clientDhInner);
        const clientDhInnerHash = crypto2.sha1(clientDhInnerWriter.uint8View.subarray(20, clientDhInnerWriter.pos));
        clientDhInnerWriter.pos = 0;
        clientDhInnerWriter.raw(clientDhInnerHash);
        log.debug("sending client DH (timeOffset = %d)", timeOffset);
        const clientDhEncrypted = ige.encrypt(clientDhInnerWriter.uint8View);
        yield sendPlainMessage({
          _: "mt_set_client_DH_params",
          nonce,
          serverNonce: resPq.serverNonce,
          encryptedData: clientDhEncrypted
        });
        const dhGen = yield readNext();
        if (!tl.mtp.isAnySet_client_DH_params_answer(dhGen)) {
          throw new MtTypeAssertionError("auth step 4", "set_client_DH_params_answer", dhGen._);
        }
        if (!buffersEqual(dhGen.nonce, nonce)) {
          throw new MtSecurityError("Step 4: invalid nonce from server");
        }
        if (!buffersEqual(dhGen.serverNonce, resPq.serverNonce)) {
          throw new MtSecurityError("Step 4: invalid server nonce from server");
        }
        log.debug("DH result: %s", dhGen._);
        if (dhGen._ === "mt_dh_gen_fail") {
          throw new MtTypeAssertionError("auth step 4", "!mt_dh_gen_fail", dhGen._);
        }
        if (dhGen._ === "mt_dh_gen_retry") {
          const expectedHash2 = crypto2.sha1(concatBuffers([newNonce, new Uint8Array([2]), authKeyAuxHash]));
          if (!buffersEqual(expectedHash2.subarray(4, 20), dhGen.newNonceHash2)) {
            throw new MtSecurityError("Step 4: invalid retry nonce hash from server");
          }
          retryId = Long.fromBytesLE(authKeyAuxHash);
          continue;
        }
        if (dhGen._ !== "mt_dh_gen_ok")
          throw new Error("unreachable");
        const expectedHash = crypto2.sha1(concatBuffers([newNonce, new Uint8Array([1]), authKeyAuxHash]));
        if (!buffersEqual(expectedHash.subarray(4, 20), dhGen.newNonceHash1)) {
          throw new MtSecurityError("Step 4: invalid nonce hash from server");
        }
        log.info("authorization successful");
        const dv = dataViewFromBuffer(serverSalt);
        return [authKey, new Long(dv.getInt32(0, true), dv.getInt32(4, true)), timeOffset];
      }
    });
  }
  var TransportState = /* @__PURE__ */ ((TransportState2) => {
    TransportState2["Idle"] = "idle";
    TransportState2["Connecting"] = "connecting";
    TransportState2["Ready"] = "ready";
    return TransportState2;
  })(TransportState || {});
  class TransportError extends Error {
    constructor(code2) {
      super(`Transport error: ${code2}`);
      __publicField(this, "code");
      this.code = code2;
    }
  }
  class StreamedCodec extends EventEmitter {
    constructor() {
      super(...arguments);
      __publicField(this, "_stream", new Uint8Array(0));
    }
    feed(data2) {
      this._stream = concatBuffers([this._stream, data2]);
      while (this._packetAvailable()) {
        if (!this._handlePacket())
          break;
      }
    }
    reset() {
      this._stream = new Uint8Array(0);
    }
  }
  const TAG = new Uint8Array([238, 238, 238, 238]);
  class IntermediatePacketCodec extends StreamedCodec {
    tag() {
      return TAG;
    }
    encode(packet) {
      const ret = new Uint8Array(packet.length + 4);
      const dv = dataViewFromBuffer(ret);
      dv.setUint32(0, packet.length, true);
      ret.set(packet, 4);
      return ret;
    }
    _packetAvailable() {
      return this._stream.length >= 8;
    }
    _handlePacket() {
      const dv = dataViewFromBuffer(this._stream);
      const payloadLength = dv.getUint32(0, true);
      if (payloadLength <= this._stream.length - 4) {
        if (payloadLength === 4) {
          const code2 = dv.getInt32(4, true) * -1;
          this.emit("error", new TransportError(code2));
        } else {
          const payload = this._stream.subarray(4, payloadLength + 4);
          this.emit("packet", payload);
        }
        this._stream = this._stream.subarray(payloadLength + 4);
        return true;
      }
      return false;
    }
  }
  class WrappedCodec extends EventEmitter {
    constructor(inner) {
      super();
      __publicField(this, "_crypto");
      __publicField(this, "_inner");
      this._inner = inner;
      this._inner.on("error", (err2) => this.emit("error", err2));
      this._inner.on("packet", (buf) => this.emit("packet", buf));
    }
    removeAllListeners() {
      super.removeAllListeners();
      this._inner.removeAllListeners();
      return this;
    }
    setup(crypto2, log) {
      var _a2, _b;
      this._crypto = crypto2;
      (_b = (_a2 = this._inner).setup) == null ? void 0 : _b.call(_a2, crypto2, log);
    }
  }
  class ObfuscatedPacketCodec extends WrappedCodec {
    constructor(inner, proxy2) {
      super(inner);
      __publicField(this, "_encryptor");
      __publicField(this, "_decryptor");
      __publicField(this, "_proxy");
      this._proxy = proxy2;
    }
    tag() {
      return __async(this, null, function* () {
        let random;
        let dv;
        for (; ; ) {
          random = this._crypto.randomBytes(64);
          if (random[0] === 239)
            continue;
          dv = dataViewFromBuffer(random);
          const firstInt = dv.getUint32(0, true);
          if (firstInt === 1145128264 || firstInt === 1414745936 || firstInt === 542393671 || firstInt === 1230262351 || firstInt === 3722304989 || firstInt === 4008636142 || firstInt === 33620758) {
            continue;
          }
          if (dv.getInt32(4, true) === 0)
            continue;
          break;
        }
        let innerTag = yield this._inner.tag();
        if (innerTag.length !== 4) {
          const b = innerTag[0];
          innerTag = new Uint8Array([b, b, b, b]);
        }
        random.set(innerTag, 56);
        if (this._proxy) {
          let dcId = this._proxy.dcId;
          if (this._proxy.test)
            dcId += 1e4;
          if (this._proxy.media)
            dcId = -dcId;
          dv.setInt16(60, dcId, true);
        }
        const randomRev = bufferToReversed(random, 8, 56);
        let encryptKey = random.subarray(8, 40);
        const encryptIv = random.subarray(40, 56);
        let decryptKey = randomRev.subarray(0, 32);
        const decryptIv = randomRev.subarray(32, 48);
        if (this._proxy) {
          encryptKey = this._crypto.sha256(concatBuffers([encryptKey, this._proxy.secret]));
          decryptKey = this._crypto.sha256(concatBuffers([decryptKey, this._proxy.secret]));
        }
        this._encryptor = this._crypto.createAesCtr(encryptKey, encryptIv, true);
        this._decryptor = this._crypto.createAesCtr(decryptKey, decryptIv, false);
        const encrypted = this._encryptor.process(random);
        random.set(encrypted.subarray(56, 64), 56);
        return random;
      });
    }
    encode(packet) {
      return __async(this, null, function* () {
        return this._encryptor.process(yield this._inner.encode(packet));
      });
    }
    feed(data2) {
      const dec = this._decryptor.process(data2);
      this._inner.feed(dec);
    }
    reset() {
      var _a2, _b, _c, _d;
      this._inner.reset();
      (_b = (_a2 = this._encryptor) == null ? void 0 : _a2.close) == null ? void 0 : _b.call(_a2);
      (_d = (_c = this._decryptor) == null ? void 0 : _c.close) == null ? void 0 : _d.call(_c);
      this._encryptor = void 0;
      this._decryptor = void 0;
    }
  }
  let nextConnectionUid = 0;
  class PersistentConnection extends EventEmitter {
    constructor(params, log) {
      super();
      __publicField(this, "_uid", nextConnectionUid++);
      __publicField(this, "params");
      __publicField(this, "_transport");
      __publicField(this, "_sendOnceConnected", []);
      // reconnection
      __publicField(this, "_lastError", null);
      __publicField(this, "_consequentFails", 0);
      __publicField(this, "_previousWait", null);
      __publicField(this, "_reconnectionTimeout", null);
      __publicField(this, "_shouldReconnectImmediately", false);
      __publicField(this, "_disconnectedManually", false);
      // inactivity timeout
      __publicField(this, "_inactivityTimeout", null);
      __publicField(this, "_inactive", true);
      __publicField(this, "_destroyed", false);
      __publicField(this, "_usable", false);
      this.log = log;
      this.params = params;
      this.changeTransport(params.transportFactory);
      this.log.prefix = `[UID ${this._uid}] `;
      this._onInactivityTimeout = this._onInactivityTimeout.bind(this);
    }
    get isConnected() {
      return this._transport.state() !== TransportState.Idle;
    }
    changeTransport(factory) {
      var _a2, _b;
      if (this._transport) {
        Promise.resolve(this._transport.close()).catch((err2) => {
          this.log.warn("error closing previous transport: %e", err2);
        });
      }
      this._transport = factory();
      (_b = (_a2 = this._transport).setup) == null ? void 0 : _b.call(_a2, this.params.crypto, this.log);
      this._transport.on("ready", this.onTransportReady.bind(this));
      this._transport.on("message", this.onMessage.bind(this));
      this._transport.on("error", this.onTransportError.bind(this));
      this._transport.on("close", this.onTransportClose.bind(this));
    }
    onTransportReady() {
      if (this._sendOnceConnected.length) {
        const sendNext = () => {
          if (!this._sendOnceConnected.length) {
            this.onConnected();
            return;
          }
          const data2 = this._sendOnceConnected.shift();
          this._transport.send(data2).then(sendNext).catch((err2) => {
            this.log.error("error sending queued data: %e", err2);
            this._sendOnceConnected.unshift(data2);
          });
        };
        sendNext();
        return;
      }
      this.onConnected();
    }
    onConnectionUsable() {
      const isReconnection = this._consequentFails > 0;
      this._lastError = null;
      this._consequentFails = 0;
      this._previousWait = null;
      this._usable = true;
      this.emit("usable", isReconnection);
      this._rescheduleInactivity();
    }
    onTransportError(err2) {
      this._lastError = err2;
      this.onError(err2);
    }
    onTransportClose() {
      if (this._inactive || this._disconnectedManually)
        return;
      if (this._shouldReconnectImmediately) {
        this._shouldReconnectImmediately = false;
        this.connect();
        return;
      }
      this._consequentFails += 1;
      const wait = this.params.reconnectionStrategy(
        this.params,
        this._lastError,
        this._consequentFails,
        this._previousWait
      );
      if (wait === false) {
        this.destroy().catch((err2) => {
          this.log.warn("error destroying connection: %e", err2);
        });
        return;
      }
      this.emit("wait", wait);
      this._previousWait = wait;
      if (this._reconnectionTimeout != null) {
        clearTimeoutWrap(this._reconnectionTimeout);
      }
      this._reconnectionTimeout = setTimeoutWrap(() => {
        if (this._destroyed)
          return;
        this._reconnectionTimeout = null;
        this.connect();
      }, wait);
    }
    connect() {
      if (this.isConnected) {
        throw new MtcuteError("Connection is already opened!");
      }
      if (this._destroyed) {
        throw new MtcuteError("Connection is already destroyed!");
      }
      if (this._reconnectionTimeout != null) {
        clearTimeoutWrap(this._reconnectionTimeout);
        this._reconnectionTimeout = null;
      }
      this._inactive = false;
      this._disconnectedManually = false;
      this._transport.connect(this.params.dc, this.params.testMode);
    }
    reconnect() {
      if (this._inactive)
        return;
      if (this.isConnected) {
        this._shouldReconnectImmediately = true;
        Promise.resolve(this._transport.close()).catch((err2) => {
          this.log.error("error closing transport: %e", err2);
        });
        return;
      }
      this.connect();
    }
    disconnectManual() {
      return __async(this, null, function* () {
        this._disconnectedManually = true;
        yield this._transport.close();
      });
    }
    destroy() {
      return __async(this, null, function* () {
        this._disconnectedManually = true;
        if (this._reconnectionTimeout != null) {
          clearTimeoutWrap(this._reconnectionTimeout);
        }
        if (this._inactivityTimeout != null) {
          clearTimeoutWrap(this._inactivityTimeout);
        }
        yield this._transport.close();
        this._transport.removeAllListeners();
        this._destroyed = true;
      });
    }
    _rescheduleInactivity() {
      if (!this.params.inactivityTimeout)
        return;
      if (this._inactivityTimeout)
        clearTimeoutWrap(this._inactivityTimeout);
      this._inactivityTimeout = setTimeoutWrap(this._onInactivityTimeout, this.params.inactivityTimeout);
    }
    _onInactivityTimeout() {
      this.log.info("disconnected because of inactivity for %d", this.params.inactivityTimeout);
      this._inactive = true;
      this._inactivityTimeout = null;
      Promise.resolve(this._transport.close()).catch((err2) => {
        this.log.warn("error closing transport: %e", err2);
      });
    }
    setInactivityTimeout(timeout) {
      this.params.inactivityTimeout = timeout;
      if (this._inactivityTimeout) {
        clearTimeoutWrap(this._inactivityTimeout);
      }
      if (timeout) {
        this._rescheduleInactivity();
      }
    }
    send(data2) {
      return __async(this, null, function* () {
        if (this._inactive) {
          this.connect();
        }
        if (this._transport.state() === TransportState.Ready) {
          yield this._transport.send(data2);
        } else {
          this._sendOnceConnected.push(data2);
        }
      });
    }
  }
  const TEMP_AUTH_KEY_EXPIRY = 86400;
  const PING_INTERVAL = 6e4;
  const GET_STATE_INTERVAL = 1500;
  const GZIP_PACKED_ID = 812830625;
  const MSG_CONTAINER_ID = 1945237724;
  const RPC_RESULT_ID = 4082920705;
  const RPC_ERROR_ID = 558156313;
  const INVOKE_AFTER_MSG_ID = 3416209197;
  const INVOKE_AFTER_MSG_SIZE = 12;
  class SessionConnection extends PersistentConnection {
    constructor(params, _session) {
      var _a2, _b, _c, _d;
      super(params, _session.log.create("conn"));
      __publicField(this, "_flushTimer", new EarlyTimer());
      __publicField(this, "_queuedDestroySession", []);
      // waitForMessage
      __publicField(this, "_pendingWaitForUnencrypted", []);
      __publicField(this, "_usePfs");
      __publicField(this, "_isPfsBindingPending", false);
      __publicField(this, "_isPfsBindingPendingInBackground", false);
      __publicField(this, "_pfsUpdateTimeout");
      __publicField(this, "_inactivityPendingFlush", false);
      __publicField(this, "_readerMap");
      __publicField(this, "_writerMap");
      __publicField(this, "_crypto");
      __publicField(this, "_salts");
      __publicField(this, "_online");
      this._session = _session;
      this._flushTimer.onTimeout(this._flush.bind(this));
      this._readerMap = params.readerMap;
      this._writerMap = params.writerMap;
      this._crypto = params.crypto;
      this._salts = params.salts;
      this._handleRawMessage = this._handleRawMessage.bind(this);
      this._usePfs = (_a2 = this.params.usePfs) != null ? _a2 : false;
      this._online = (_d = (_c = (_b = getPlatform()).isOnline) == null ? void 0 : _c.call(_b)) != null ? _d : true;
    }
    getAuthKey(temp = false) {
      const key = temp ? this._session._authKeyTemp : this._session._authKey;
      if (!key.ready)
        return null;
      return key.key;
    }
    setUsePfs(usePfs) {
      if (this._usePfs === usePfs)
        return;
      this.log.debug("use pfs changed to %s", usePfs);
      this._usePfs = usePfs;
      if (!usePfs) {
        this._isPfsBindingPending = false;
        this._isPfsBindingPendingInBackground = false;
        this._session._authKeyTemp.reset();
        clearTimeoutWrap(this._pfsUpdateTimeout);
      }
      this._resetSession();
    }
    onTransportClose() {
      super.onTransportClose();
      Object.values(this._pendingWaitForUnencrypted).forEach(([prom, timeout]) => {
        prom.reject(new MtcuteError("Connection closed"));
        clearTimeoutWrap(timeout);
      });
      for(let   msgId of this._session.pendingMessages.keys()) {
        const pending = this._session.pendingMessages.get(msgId);
        if (pending._ === "state") {
          this._onMessageFailed(msgId, "connection loss", true);
        }
      }
      this.emit("disconnect");
      this.reset();
    }
    destroy() {
      return __async(this, null, function* () {
        yield __superGet(SessionConnection.prototype, this, "destroy").call(this);
        this.reset(true);
      });
    }
    reset(forever = false) {
      this._session.initConnectionCalled = false;
      this._flushTimer.reset();
      this._salts.isFetching = false;
      if (forever) {
        clearTimeoutWrap(this._pfsUpdateTimeout);
        this.removeAllListeners();
        this.on("error", (err2) => {
          this.log.warn("caught error after destroying: %s", err2);
        });
      }
    }
    onConnected() {
      if (!this._session._authKey.ready) {
        if (!this.params.isMainConnection) {
          this.log.info("no auth key, waiting for main connection");
          return;
        }
        this.log.info("no perm auth key, authorizing...");
        this._authorize();
        return;
      }
      if (this._usePfs && !this._session._authKeyTemp.ready) {
        this.log.info("no temp auth key but using pfs, authorizing");
        this._authorizePfs();
        return;
      }
      this.log.info("auth keys are already available");
      this.onConnectionUsable();
    }
    onError(error) {
      if (error instanceof TransportError) {
        if (error.code === 404) {
          if (this._usePfs) {
            if (!this._isPfsBindingPending && this._session._authKeyTemp.ready) {
              this.log.info("transport error 404, reauthorizing pfs");
              this._session._authKeyTemp.reset();
              this._authorizePfs();
              this._onAllFailed("temp key expired, binding started");
              return;
            } else if (this._isPfsBindingPending) {
              this.log.info("transport error 404, pfs binding in progress");
              this._onAllFailed("temp key expired, binding pending");
              return;
            }
          }
          this.log.info("transport error 404, reauthorizing");
          this._session.resetAuthKey();
          this._resetSession();
          this.emit("key-change", null);
          this.emit("error", error);
          return;
        }
        this.log.error("transport error %d", error.code);
        this._onAllFailed(`transport error ${error.code}`);
        if (error.code === 429) {
          this._session.onTransportFlood(this.emit.bind(this, "flood-done"));
          return;
        }
      }
      this.emit("error", error);
    }
    onConnectionUsable() {
      super.onConnectionUsable();
      if (this.params.withUpdates) {
        this.sendRpc({ _: "updates.getState" }).catch((err2) => {
          if (this._destroyed || tl.tl.RpcError.is(err2, "AUTH_KEY_UNREGISTERED"))
            return;
          this.log.warn("failed to send updates.getState: %e", err2);
        });
      }
      this._flushTimer.emitBeforeNext(1e3);
    }
    _authorize() {
      if (this._session.authorizationPending) {
        this.log.info("_authorize(): authorization already in progress");
        return;
      }
      if (!this.params.isMainConnection) {
        this.log.debug("_authorize(): non-main connection, requesting...");
        this.emit("request-auth");
        return;
      }
      this._session.authorizationPending = true;
      this.emit("auth-begin");
      doAuthorization(this, this._crypto).then(([authKey, serverSalt, timeOffset]) => {
        this._session._authKey.setup(authKey);
        this._salts.currentSalt = serverSalt;
        this._session.updateTimeOffset(timeOffset);
        this._session.authorizationPending = false;
        this.emit("key-change", authKey);
        if (this._usePfs) {
          return this._authorizePfs();
        }
        this.onConnectionUsable();
      }).catch((err2) => {
        this._session.authorizationPending = false;
        if (this._destroyed)
          return;
        this.log.error("Authorization error: %e", err2);
        this.onError(err2);
        this.reconnect();
      });
    }
    _authorizePfs(background = false) {
      if (this._isPfsBindingPending)
        return;
      if (this._pfsUpdateTimeout) {
        clearTimeoutWrap(this._pfsUpdateTimeout);
        this._pfsUpdateTimeout = void 0;
      }
      if (this._isPfsBindingPendingInBackground) {
        this._isPfsBindingPendingInBackground = false;
        this._isPfsBindingPending = true;
        return;
      }
      if (background) {
        this._isPfsBindingPendingInBackground = true;
      } else {
        this._isPfsBindingPending = true;
      }
      doAuthorization(this, this._crypto, TEMP_AUTH_KEY_EXPIRY).then((_0) => __async(this, [_0], function* ([tempAuthKey, tempServerSalt]) {
        if (!this._usePfs) {
          this.log.info("pfs has been disabled while generating temp key");
          return;
        }
        const tempKey = this._session._authKeyTempSecondary;
        tempKey.setup(tempAuthKey);
        const msgId = this._session.getMessageId();
        this.log.debug(
          "binding temp_auth_key (%h) to perm_auth_key (%h), msg_id = %l...",
          tempKey.id,
          this._session._authKey.id,
          msgId
        );
        const inner = {
          _: "mt_bind_auth_key_inner",
          nonce: randomLong(),
          tempAuthKeyId: longFromBuffer(tempKey.id),
          permAuthKeyId: longFromBuffer(this._session._authKey.id),
          tempSessionId: this._session._sessionId,
          expiresAt: Math.floor(Date.now() / 1e3) + TEMP_AUTH_KEY_EXPIRY
        };
        const writer2 = TlBinaryWriter.alloc(this.params.writerMap, 80);
        writer2.raw(this._crypto.randomBytes(16));
        writer2.long(msgId);
        writer2.int(0);
        writer2.int(40);
        writer2.object(inner);
        const msgWithoutPadding = writer2.result();
        writer2.raw(this._crypto.randomBytes(8));
        const msgWithPadding = writer2.result();
        const hash = this._crypto.sha1(msgWithoutPadding);
        const msgKey = hash.subarray(4, 20);
        const ige = createAesIgeForMessageOld(this._crypto, this._session._authKey.key, msgKey);
        const encryptedData = ige.encrypt(msgWithPadding);
        const encryptedMessage = concatBuffers([this._session._authKey.id, msgKey, encryptedData]);
        const promise = createControllablePromise();
        this._session.pendingMessages.set(msgId, {
          _: "bind",
          promise
        });
        const request = {
          _: "auth.bindTempAuthKey",
          permAuthKeyId: inner.permAuthKeyId,
          nonce: inner.nonce,
          expiresAt: inner.expiresAt,
          encryptedMessage
        };
        const reqSize = TlSerializationCounter.countNeededBytes(this._writerMap, request);
        const reqWriter = TlBinaryWriter.alloc(this._writerMap, reqSize + 16);
        reqWriter.long(this._registerOutgoingMsgId(msgId));
        reqWriter.uint(this._session.getSeqNo());
        reqWriter.uint(reqSize);
        reqWriter.object(request);
        const requestEncrypted = tempKey.encryptMessage(
          reqWriter.result(),
          tempServerSalt,
          this._session._sessionId
        );
        yield this.send(requestEncrypted);
        const res = yield promise;
        this._session.pendingMessages.delete(msgId);
        if (!this._usePfs) {
          this.log.info("pfs has been disabled while binding temp key");
          return;
        }
        if (typeof res === "object") {
          this.log.error("failed to bind temp key: %s:%s", res.errorCode, res.errorMessage);
          throw new MtcuteError("Failed to bind temporary key");
        }
        this._session._authKeyTempSecondary = this._session._authKeyTemp;
        this._session._authKeyTemp = tempKey;
        this._salts.currentSalt = tempServerSalt;
        this.log.debug("temp key has been bound, exp = %d", inner.expiresAt);
        this._isPfsBindingPending = false;
        this._isPfsBindingPendingInBackground = false;
        this._session.initConnectionCalled = false;
        this.emit("tmp-key-change", tempAuthKey, inner.expiresAt);
        this.onConnectionUsable();
        this._pfsUpdateTimeout = setTimeoutWrap(
          () => {
            this._pfsUpdateTimeout = void 0;
            this.log.debug("temp key is expiring soon");
            this._authorizePfs(true);
          },
          (TEMP_AUTH_KEY_EXPIRY - 60) * 1e3
        );
      })).catch((err2) => {
        if (this._destroyed)
          return;
        this.log.error("PFS Authorization error: %e", err2);
        if (this._isPfsBindingPendingInBackground) {
          this._isPfsBindingPendingInBackground = false;
          return this._authorizePfs(true);
        }
        this._isPfsBindingPending = false;
        this.onError(err2);
        this.reconnect();
      });
    }
    waitForUnencryptedMessage(timeout = 5e3) {
      if (this._destroyed) {
        return Promise.reject(new MtcuteError("Connection destroyed"));
      }
      const promise = createControllablePromise();
      const timeoutId = setTimeoutWrap(() => {
        promise.reject(new MtTimeoutError(timeout));
        this._pendingWaitForUnencrypted = this._pendingWaitForUnencrypted.filter((it) => it[0] !== promise);
      }, timeout);
      this._pendingWaitForUnencrypted.push([promise, timeoutId]);
      return promise;
    }
    onMessage(data2) {
      if (this._pendingWaitForUnencrypted.length) {
        const int32 = new Int32Array(data2.buffer, data2.byteOffset, 2);
        if (int32[0] === 0 && int32[1] === 0) {
          const [promise, timeout] = this._pendingWaitForUnencrypted.shift();
          clearTimeoutWrap(timeout);
          promise.resolve(data2);
          return;
        }
      }
      if (!this._session._authKey.ready) {
        this.log.warn("received message before authorization: %h", data2);
        return;
      }
      try {
        this._session.decryptMessage(data2, this._handleRawMessage);
      } catch (err2) {
        this.log.error("failed to decrypt message: %s\ndata: %h", err2, data2);
      }
    }
    _handleRawMessage(messageId, seqNo, message2) {
      const objectId = message2.uint();
      if (objectId === GZIP_PACKED_ID) {
        return this._handleRawMessage(
          messageId,
          seqNo,
          new TlBinaryReader(this._readerMap, this._crypto.gunzip(message2.bytes()))
        );
      }
      if (objectId === MSG_CONTAINER_ID) {
        const count = message2.uint();
        for (let i = 0; i < count; i++) {
          const msgId = message2.long();
          const seqNo2 = message2.uint();
          const length = message2.uint();
          const obj = message2.raw(length);
          this._handleRawMessage(msgId, seqNo2, new TlBinaryReader(this._readerMap, obj));
        }
        return;
      }
      if (objectId === RPC_RESULT_ID) {
        return this._onRpcResult(messageId, message2);
      }
      this._handleMessage(messageId, message2.object(objectId));
    }
    _handleMessage(messageId, message_) {
      if (messageId.isEven()) {
        this.log.warn("warn: ignoring message with invalid messageId = %s (is even)", messageId);
        return;
      }
      if (this._session.recentIncomingMsgIds.has(messageId)) {
        this.log.debug("ignoring duplicate message %s", messageId);
        return;
      }
      const message2 = message_;
      this.log.debug("received %s (msg_id: %l)", message2._, messageId);
      this._session.recentIncomingMsgIds.add(messageId);
      switch (message2._) {
        case "mt_msgs_ack":
        case "mt_http_wait":
        case "mt_bad_msg_notification":
        case "mt_bad_server_salt":
        case "mt_msgs_all_info":
        case "mt_msgs_state_info":
        case "mt_msg_detailed_info":
        case "mt_msg_new_detailed_info":
          break;
        default:
          this._sendAck(messageId);
      }
      switch (message2._) {
        case "mt_pong":
          this._onPong(message2);
          break;
        case "mt_bad_server_salt":
          this._onBadServerSalt(message2);
          break;
        case "mt_bad_msg_notification":
          this._onBadMsgNotification(messageId, message2);
          break;
        case "mt_msgs_ack":
          message2.msgIds.forEach((msgId) => this._onMessageAcked(msgId));
          break;
        case "mt_new_session_created":
          this._onNewSessionCreated(message2);
          break;
        case "mt_msgs_all_info":
          this._onMessagesInfo(message2.msgIds, message2.info);
          break;
        case "mt_msg_detailed_info":
          this._onMessageInfo(message2.msgId, message2.status, message2.answerMsgId);
          break;
        case "mt_msg_new_detailed_info":
          this._onMessageInfo(Long.ZERO, 0, message2.answerMsgId);
          break;
        case "mt_msgs_state_info":
          this._onMsgsStateInfo(message2);
          break;
        case "mt_future_salts":
          this._onFutureSalts(message2);
          break;
        case "mt_msgs_state_req":
        case "mt_msg_resend_req":
          this.log.warn("received %s (msg_id = %l): %j", message2._, messageId, message2);
          break;
        case "mt_destroy_session_ok":
        case "mt_destroy_session_none":
          this._onDestroySessionResult(message2);
          break;
        default:
          if (tl.tl.isAnyUpdates(message2)) {
            if (this._usable && this.params.inactivityTimeout) {
              this._rescheduleInactivity();
            }
            this.log.verbose("<<< %j", message2);
            if (this.params.disableUpdates) {
              this.log.warn("received updates, but updates are disabled");
              break;
            }
            this.emit("update", message2);
            return;
          }
          this.log.warn("unknown message received: %j", message2);
      }
    }
    _onRpcResult(messageId, message2) {
      if (this._usable && this.params.inactivityTimeout) {
        this._rescheduleInactivity();
      }
      const reqMsgId = message2.long();
      if (reqMsgId.isZero()) {
        let resultType;
        try {
          resultType = message2.object()._;
        } catch (e) {
          resultType = message2.peekUint();
        }
        this.log.warn("received rpc_result with %j with req_msg_id = 0", resultType);
        return;
      }
      const msg = this._session.pendingMessages.get(reqMsgId);
      if (!msg) {
        let result2;
        try {
          result2 = message2.object();
        } catch (e) {
          result2 = "[failed to parse]";
        }
        if (this._session.recentOutgoingMsgIds.has(reqMsgId)) {
          this.log.debug("received rpc_result again for %l (contains %j)", reqMsgId, result2);
        } else {
          this.log.warn("received rpc_result for unknown message %l: %j", reqMsgId, result2);
        }
        return;
      }
      this._sendAck(messageId);
      if (msg._ !== "rpc") {
        if (msg._ === "bind") {
          this._sendAck(messageId);
          msg.promise.resolve(message2.object());
          return;
        }
        if (msg._ === "cancel") {
          let result2;
          try {
            result2 = message2.object();
          } catch (e) {
            this.log.debug("failed to parse rpc_result for cancel request %l, ignoring", reqMsgId);
            return;
          }
          this.log.debug("received %s for cancelled request %l: %j", result2._, reqMsgId, result2);
          this._onMessageAcked(reqMsgId);
          return;
        }
        this.log.error("received rpc_result for %s request %l", msg._, reqMsgId);
        return;
      }
      const rpc = msg.rpc;
      const resultConstructorId = message2.peekUint();
      let result;
      const customReader = this._readerMap._results[rpc.method];
      if (resultConstructorId === RPC_ERROR_ID) {
        result = message2.object();
      } else if (customReader) {
        result = customReader(message2);
      } else {
        const objectId = message2.uint();
        if (objectId === GZIP_PACKED_ID) {
          const inner = this._crypto.gunzip(message2.bytes());
          result = TlBinaryReader.deserializeObject(this._readerMap, inner);
        } else {
          result = message2.object(objectId);
        }
      }
      if (rpc.initConn) {
        this._session.initConnectionCalled = true;
      }
      rpc.done = true;
      this.log.verbose("<<< (%s:%l) %j", rpc.method, reqMsgId, result);
      if (result._ === "mt_rpc_error") {
        const res = result;
        this.log.debug(
          "received rpc_error [%d:%s] for %l (%s)",
          res.errorCode,
          res.errorMessage,
          reqMsgId,
          rpc.method
        );
        if (rpc.cancelled)
          return;
        switch (res.errorMessage) {
          case "AUTH_KEY_PERM_EMPTY":
            this._authorizePfs();
            this._onMessageFailed(reqMsgId, "AUTH_KEY_PERM_EMPTY", true);
            return;
          case "CONNECTION_NOT_INITED": {
            this._session.initConnectionCalled = false;
            this._onMessageFailed(reqMsgId, res.errorMessage, true);
            this.sendRpc({ _: "help.getNearestDc" }).then(() => {
              this.log.debug("additional help.getNearestDc for initConnection ok");
            }).catch((err2) => {
              this.log.debug("additional help.getNearestDc for initConnection error: %e", err2);
            });
            return;
          }
          case "MSG_WAIT_TIMEOUT":
          case "MSG_WAIT_FAILED": {
            if (!rpc.invokeAfter) {
              this.log.warn("received %s for non-chained request %l", res.errorMessage, reqMsgId);
              break;
            }
            if (this._session.pendingMessages.has(rpc.invokeAfter)) {
              this.log.debug(
                "chain %s: waiting for %l before processing %l",
                rpc.chainId,
                rpc.invokeAfter,
                reqMsgId
              );
              this._session.getPendingChainedFails(rpc.chainId).insert(rpc);
            } else {
              this._session.chains.delete(rpc.chainId);
              this._onMessageFailed(reqMsgId, "MSG_WAIT_FAILED", true);
            }
            return;
          }
        }
        rpc.promise.resolve(res);
      } else {
        this.log.debug("received rpc_result (%s) for request %l (%s)", result._, reqMsgId, rpc.method);
        if (rpc.cancelled)
          return;
        rpc.promise.resolve(result);
      }
      if (rpc.chainId) {
        this._processPendingChainedFails(rpc.chainId, reqMsgId);
      }
      this._onMessageAcked(reqMsgId);
      this._session.pendingMessages.delete(reqMsgId);
    }
    _processPendingChainedFails(chainId, sinceMsgId) {
      this._session.removeFromChain(chainId, sinceMsgId);
      const oldPending = this._session.chainsPendingFails.get(chainId);
      if (!(oldPending == null ? void 0 : oldPending.length)) {
        return;
      }
      const idx = oldPending.index({ invokeAfter: sinceMsgId }, true);
      if (idx === -1)
        return;
      const toFail = oldPending.raw.splice(idx);
      this.log.debug("chain %s: failing %d dependant messages: %L", chainId, toFail.length, toFail);
      this._session.chains.delete(chainId);
      for(let   rpc of toFail) {
        this._onMessageFailed(rpc.msgId, "MSG_WAIT_FAILED", true);
      }
    }
    _onMessageAcked(msgId, inContainer = false) {
      const msg = this._session.pendingMessages.get(msgId);
      if (!msg) {
        if (!this._session.recentOutgoingMsgIds.has(msgId)) {
          this.log.warn("received ack for unknown message %l", msgId);
        }
        return;
      }
      switch (msg._) {
        case "container":
          this.log.debug("received ack for container %l (size = %d)", msgId, msg.msgIds.length);
          msg.msgIds.forEach((msgId2) => this._onMessageAcked(msgId2, true));
          this._session.pendingMessages.delete(msgId);
          break;
        case "rpc": {
          const rpc = msg.rpc;
          this.log.debug("received ack for rpc query %l (%s, acked before = %s)", msgId, rpc.method, rpc.acked);
          rpc.acked = true;
          if (!inContainer && rpc.containerId && this._session.pendingMessages.has(rpc.containerId)) {
            this._onMessageAcked(rpc.containerId);
          }
          removeFromLongArray(this._session.queuedStateReq, msgId);
          removeFromLongArray(this._session.queuedResendReq, msgId);
          this._session.getStateSchedule.remove(rpc);
          break;
        }
        case "bind":
        case "cancel":
          break;
        default:
          if (!inContainer) {
            this.log.warn("received unexpected ack for %s query %l", msg._, msgId);
          }
      }
    }
    _onAllFailed(reason) {
      this.log.debug("all messages failed because of %s", reason);
      for(let   msgId of this._session.pendingMessages.keys()) {
        const info = this._session.pendingMessages.get(msgId);
        switch (info._) {
          case "container":
          case "state":
          case "resend":
          case "ping":
            this.log.debug("forgetting about %s message %l", info._, msgId);
            this._session.pendingMessages.delete(msgId);
            break;
          default:
            this._onMessageFailed(msgId, reason, true);
            break;
        }
      }
    }
    _onMessageFailed(msgId, reason, inContainer = false) {
      const msgInfo = this._session.pendingMessages.get(msgId);
      if (!msgInfo) {
        this.log.debug("unknown message %l failed because of %s", msgId, reason);
        return;
      }
      switch (msgInfo._) {
        case "container":
          this.log.debug("container %l (size = %d) failed because of %s", msgId, msgInfo.msgIds.length, reason);
          msgInfo.msgIds.forEach((msgId2) => this._onMessageFailed(msgId2, reason, true));
          break;
        case "ping":
          this.log.debug("ping (msg_id = %l) failed because of %s", msgId, reason);
          this._session.resetLastPing(true);
          break;
        case "rpc": {
          const rpc = msgInfo.rpc;
          this.log.debug("rpc query %l (%s) failed because of %s", msgId, rpc.method, reason);
          this._session.pendingMessages.delete(msgId);
          rpc.msgId = void 0;
          this._enqueueRpc(rpc, true);
          if (!inContainer && rpc.containerId && this._session.pendingMessages.has(rpc.containerId)) {
            this._onMessageFailed(rpc.containerId, reason);
          }
          removeFromLongArray(this._session.queuedStateReq, msgId);
          removeFromLongArray(this._session.queuedResendReq, msgId);
          this._session.getStateSchedule.remove(rpc);
          break;
        }
        case "resend":
          this.log.debug(
            "resend request %l (size = %d) failed because of %s",
            msgId,
            msgInfo.msgIds.length,
            reason
          );
          this._session.queuedResendReq.splice(0, 0, ...msgInfo.msgIds);
          this._flushTimer.emitWhenIdle();
          break;
        case "state":
          this.log.debug(
            "state request %l (size = %d) failed because of %s",
            msgId,
            msgInfo.msgIds.length,
            reason
          );
          this._session.queuedStateReq.splice(0, 0, ...msgInfo.msgIds);
          this._flushTimer.emitWhenIdle();
          break;
        case "bind":
          this.log.debug("temp key binding request %l failed because of %s, retrying", msgId, reason);
          msgInfo.promise.reject(new Error(reason));
          break;
        case "future_salts":
          this.log.debug("future_salts request %l failed because of %s, will retry", msgId, reason);
          this._salts.isFetching = false;
          break;
      }
      this._session.pendingMessages.delete(msgId);
    }
    _registerOutgoingMsgId(msgId) {
      this._session.recentOutgoingMsgIds.add(msgId);
      return msgId;
    }
    _onPong({ msgId, pingId }) {
      const info = this._session.pendingMessages.get(msgId);
      if (!info) {
        this.log.warn("received pong to unknown ping (msg_id %l, ping_id %l)", msgId, pingId);
        return;
      }
      if (info._ !== "ping") {
        this.log.warn("received pong to %s query, not ping (msg_id %l, ping_id %l)", info._, msgId, pingId);
        return;
      }
      if (info.pingId.neq(pingId)) {
        this.log.warn("received pong to %l, but expected ping_id = %l (got %l)", msgId, info.pingId, pingId);
      }
      const rtt = Date.now() - this._session.lastPingTime;
      this._session.lastPingRtt = rtt;
      if (info.containerId.neq(msgId)) {
        this._onMessageAcked(info.containerId);
      }
      this.log.debug("received pong: msg_id %l, ping_id %l, rtt = %dms", msgId, pingId, rtt);
      this._session.resetLastPing();
    }
    _onBadServerSalt(msg) {
      this._salts.currentSalt = msg.newServerSalt;
      this._onMessageFailed(msg.badMsgId, "bad_server_salt");
    }
    _onBadMsgNotification(msgId, msg) {
      switch (msg.errorCode) {
        case 16:
        case 17:
        case 20: {
          if (msg.errorCode !== 20) {
            const serverTime = msgId.high >>> 0;
            const timeOffset = Math.floor(Date.now() / 1e3) - serverTime;
            this._session.updateTimeOffset(timeOffset);
            this.log.debug("server time: %d, corrected offset to %d", serverTime, timeOffset);
          }
          this._onMessageFailed(msg.badMsgId, `bad_msg_notification ${msg.errorCode}`);
          break;
        }
        default:
          this.log.error(
            "received bad_msg_notification for msg_id = %l, code = %d. session will be reset",
            msg.badMsgId,
            msg.errorCode
          );
          this._resetSession();
          break;
      }
    }
    _onNewSessionCreated({ firstMsgId, serverSalt, uniqueId }) {
      if (uniqueId.eq(this._session.lastSessionCreatedUid)) {
        this.log.debug("received new_session_created with the same uid = %l, ignoring", uniqueId);
        return;
      }
      if (!this._session.lastSessionCreatedUid.isZero() && !this.params.disableUpdates) {
        this.emit("update", { _: "updatesTooLong" });
      }
      this._salts.currentSalt = serverSalt;
      this.log.debug("received new_session_created, uid = %l, first msg_id = %l", uniqueId, firstMsgId);
      for(let   msgId of this._session.pendingMessages.keys()) {
        const val = this._session.pendingMessages.get(msgId);
        if (val._ === "bind") {
          if (msgId.lt(firstMsgId)) {
            this._onMessageFailed(msgId, "received in wrong session");
          }
          continue;
        }
        if (val._ === "container") {
          if (msgId.lt(firstMsgId)) {
            this._session.pendingMessages.delete(msgId);
          }
          return;
        }
        const containerId = val._ === "rpc" ? val.rpc.containerId || msgId : val.containerId;
        if (containerId.lt(firstMsgId)) {
          this._onMessageFailed(msgId, "new_session_created", true);
        }
      }
    }
    _onMessageInfo(msgId, status, answerMsgId) {
      if (!msgId.isZero()) {
        const info = this._session.pendingMessages.get(msgId);
        if (!info) {
          if (!this._session.recentOutgoingMsgIds.has(msgId)) {
            this.log.warn("received message info about unknown message %l", msgId);
          }
          return;
        }
        switch (status & 7) {
          case 1:
          case 2:
          case 3:
            return this._onMessageFailed(msgId, `message info state ${status}`);
          case 0:
            if (!answerMsgId.isZero()) {
              this.log.warn(
                "received message info with status = 0: msg_id = %l, status = %d, ans_id = %l",
                msgId,
                status,
                answerMsgId
              );
              return this._onMessageFailed(msgId, "message info state = 0, ans_id = 0");
            }
          case 4:
            this._onMessageAcked(msgId);
            break;
        }
      }
      if (!answerMsgId.isZero() && !this._session.recentIncomingMsgIds.has(answerMsgId)) {
        this.log.debug("received message info for %l, but answer (%l) was not received yet", msgId, answerMsgId);
        this._session.queuedResendReq.push(answerMsgId);
        this._flushTimer.emitWhenIdle();
        return;
      }
      if (answerMsgId.isZero()) {
        this.log.debug("received message info for %l: message is still pending (status = %d)", msgId, status);
        return;
      }
      this.log.debug("received message info for %l, and answer (%l) was already received", msgId, answerMsgId);
    }
    _onMessagesInfo(msgIds, info) {
      if (msgIds.length !== info.length) {
        this.log.warn("messages state info was invalid: msg_ids.length !== info.length");
      }
      for (let i = 0; i < msgIds.length; i++) {
        this._onMessageInfo(msgIds[i], info[i], Long.ZERO);
      }
    }
    _onMsgsStateInfo(msg) {
      const info = this._session.pendingMessages.get(msg.reqMsgId);
      if (!info) {
        this.log.warn("received msgs_state_info to unknown request %l", msg.reqMsgId);
        return;
      }
      if (info._ !== "state") {
        this.log.warn("received msgs_state_info to %s query %l", info._, msg.reqMsgId);
        return;
      }
      this._session.pendingMessages.delete(msg.reqMsgId);
      this._onMessagesInfo(info.msgIds, msg.info);
    }
    _onFutureSalts(msg) {
      const info = this._session.pendingMessages.get(msg.reqMsgId);
      if (!info) {
        this.log.warn("received future_salts to unknown request %l", msg.reqMsgId);
        return;
      }
      if (info._ !== "future_salts") {
        this.log.warn("received future_salts to %s query %l", info._, msg.reqMsgId);
        return;
      }
      this._session.pendingMessages.delete(msg.reqMsgId);
      this.log.debug("received future_salts: %d salts", msg.salts.length);
      this._salts.isFetching = false;
      this._salts.setFutureSalts(msg.salts.slice());
      this.emit("future-salts", msg.salts);
    }
    _onDestroySessionResult(msg) {
      const reqMsgId = this._session.destroySessionIdToMsgId.get(msg.sessionId);
      if (!reqMsgId) {
        this.log.warn("received %s for unknown session %h", msg._, msg.sessionId);
        return;
      }
      this._session.destroySessionIdToMsgId.delete(msg.sessionId);
      this._session.pendingMessages.delete(reqMsgId);
      this.log.debug("received %s for session %h", msg._, msg.sessionId);
    }
    _enqueueRpc(rpc, force) {
      if (this._session.enqueueRpc(rpc, force)) {
        this._flushTimer.emitWhenIdle();
      }
    }
    _resetSession() {
      this._queuedDestroySession.push(this._session._sessionId);
      this._session.resetState(true);
      this._onAllFailed("session reset");
      this.reconnect();
      this._flushTimer.reset();
    }
    _sendAck(msgId) {
      if (this._session.queuedAcks.length === 0) {
        this._flushTimer.emitBeforeNext(3e4);
      }
      this._session.queuedAcks.push(msgId);
      if (this._session.queuedAcks.length >= 100) {
        this._flushTimer.emitWhenIdle();
      }
    }
    sendRpc(request, timeout, abortSignal, chainId) {
      var _a2, _b;
      if (this._usable && this.params.inactivityTimeout) {
        this._rescheduleInactivity();
      }
      const method = request._;
      let obj = request;
      let initConn = false;
      if (this.params.disableUpdates) {
        obj = {
          _: "invokeWithoutUpdates",
          query: obj
        };
      }
      if (!this._session.initConnectionCalled) {
        this.log.debug("wrapping %s with initConnection, layer: %d", method, this.params.layer);
        const proxy2 = (_b = (_a2 = this._transport).getMtproxyInfo) == null ? void 0 : _b.call(_a2);
        obj = {
          _: "invokeWithLayer",
          layer: this.params.layer,
          query: __spreadProps(__spreadValues({}, this.params.initConnection), {
            proxy: proxy2,
            query: obj
          })
        };
        initConn = true;
      }
      this.log.verbose(">>> %j", obj);
      let content = TlBinaryWriter.serializeObject(this._writerMap, obj);
      if (content.length > 1044404) {
        throw new MtArgumentError(`Payload is too big (${content.length} > 1044404)`);
      }
      let shouldGzip = content.length > 128;
      if (content.length > 16384) {
        const middle = ~~((content.length - 1024) / 2);
        const middlePart = content.subarray(middle, middle + 1024);
        const gzipped = this._crypto.gzip(middlePart, Math.floor(middlePart.length * 0.9));
        if (!gzipped)
          shouldGzip = false;
      }
      if (shouldGzip) {
        const gzipped = this._crypto.gzip(content, Math.floor(content.length * 0.9));
        if (gzipped) {
          this.log.debug("gzipped %s (%db -> %db)", method, content.length, gzipped.length);
          content = gzipped;
        } else {
          shouldGzip = false;
        }
      }
      const pending = {
        method,
        promise: createControllablePromise(),
        data: content,
        // we will need to know size of gzip_packed overhead in _flush()
        gzipOverhead: shouldGzip ? 4 + TlSerializationCounter.countBytesOverhead(content.length) : 0,
        initConn,
        chainId,
        // setting them as well so jit can optimize stuff
        invokeAfter: void 0,
        sent: void 0,
        done: void 0,
        getState: void 0,
        msgId: void 0,
        seqNo: void 0,
        containerId: void 0,
        acked: void 0,
        cancelled: void 0,
        timeout: void 0
      };
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        pending.promise.reject(abortSignal.reason);
        return pending.promise;
      }
      if (timeout) {
        pending.timeout = setTimeoutWrap(() => this._cancelRpc(pending, true), timeout);
      }
      if (abortSignal) {
        abortSignal.addEventListener("abort", () => this._cancelRpc(pending, false, abortSignal));
      }
      this._enqueueRpc(pending, true);
      return pending.promise;
    }
    notifyNetworkChanged(online) {
      this._online = online;
      if (online) {
        this.reconnect();
      } else {
        this.disconnectManual().catch((err2) => {
          this.log.warn("error while disconnecting: %e", err2);
        });
      }
    }
    _cancelRpc(rpc, onTimeout = false, abortSignal) {
      if (rpc.done)
        return;
      if (rpc.cancelled && !onTimeout) {
        throw new MtcuteError("RPC was already cancelled");
      }
      if (!onTimeout && rpc.timeout) {
        clearTimeoutWrap(rpc.timeout);
      }
      if (onTimeout) {
        rpc.promise.resolve({
          _: "mt_rpc_error",
          errorCode: 400,
          errorMessage: "TIMEOUT"
        });
      } else if (abortSignal) {
        rpc.promise.reject(abortSignal.reason);
      }
      rpc.cancelled = true;
      if (rpc.msgId) {
        this._session.queuedCancelReq.push(rpc.msgId);
        this._session.getStateSchedule.remove(rpc);
        this._flushTimer.emitWhenIdle();
      } else {
        this._session.queuedRpc.remove(rpc);
      }
    }
    _onInactivityTimeout() {
      let hasPendingRpc = false;
      for(let   it of this._session.pendingMessages.values()) {
        if (it._ === "rpc") {
          hasPendingRpc = true;
          break;
        }
      }
      if (hasPendingRpc) {
        this.log.debug("waiting for pending rpc queries to finish before closing connection");
        this._rescheduleInactivity();
        return;
      }
      if (!this._session.hasPendingMessages) {
        this.log.debug("no pending service messages, closing connection");
        super._onInactivityTimeout();
        return;
      }
      this._inactivityPendingFlush = true;
      this._flush();
    }
    flushWhenIdle() {
      this._flushTimer.emitWhenIdle();
    }
    _flush() {
      var _a2;
      if (this._disconnectedManually || !this._session._authKey.ready || this._isPfsBindingPending || this._session.current429Timeout) {
        this.log.debug(
          "skipping flush, connection is not usable (offline = %b, auth key ready = %b, pfs binding pending = %b, 429 timeout = %b)",
          this._disconnectedManually,
          this._session._authKey.ready,
          this._isPfsBindingPending,
          this._session.current429Timeout
        );
        return;
      }
      try {
        this._doFlush();
      } catch (e) {
        this.log.error("flush error: %s", e.stack);
      }
      if (this._session.hasPendingMessages) {
        this._flushTimer.emitWhenIdle();
      } else {
        const nextPingTime = this._session.lastPingTime + PING_INTERVAL;
        const nextGetScheduleTime = ((_a2 = this._session.getStateSchedule.raw[0]) == null ? void 0 : _a2.getState) || Infinity;
        this._flushTimer.emitBefore(Math.min(nextPingTime, nextGetScheduleTime));
      }
    }
    _doFlush() {
      this.log.debug("flushing send queue. queued rpc: %d", this._session.queuedRpc.length);
      let packetSize = 0;
      let messageCount = 0;
      let containerMessageCount = 0;
      let containerSize = 0;
      let ackRequest = null;
      let ackMsgIds = null;
      let getFutureSaltsRequest = null;
      let getFutureSaltsMsgId = null;
      let pingRequest = null;
      let pingId = null;
      let pingMsgId = null;
      let getStateRequest = null;
      let getStateMsgId = null;
      let getStateMsgIds = null;
      let resendRequest = null;
      let resendMsgId = null;
      let resendMsgIds = null;
      let cancelRpcs = null;
      let destroySessions = null;
      let rootMsgId = null;
      const now = Date.now();
      if (this._session.queuedAcks.length) {
        let acks = this._session.queuedAcks;
        if (acks.length > 8192) {
          this._session.queuedAcks = acks.slice(8192);
          acks = acks.slice(0, 8192);
        } else {
          this._session.queuedAcks = [];
        }
        const obj = {
          _: "mt_msgs_ack",
          msgIds: acks
        };
        ackMsgIds = obj.msgIds;
        ackRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
        packetSize += ackRequest.length + 16;
        messageCount += 1;
      }
      if (now - this._session.lastPingTime > PING_INTERVAL) {
        if (!this._session.lastPingMsgId.isZero()) {
          this.log.warn("didn't receive pong for previous ping (msg_id = %l)", this._session.lastPingMsgId);
          this._session.pendingMessages.delete(this._session.lastPingMsgId);
        }
        pingId = randomLong();
        const obj = {
          _: "mt_ping_delay_disconnect",
          pingId,
          disconnectDelay: 75
        };
        this._session.lastPingTime = Date.now();
        pingRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
        containerSize += pingRequest.length + 16;
        containerMessageCount += 1;
      }
      {
        if (this._session.queuedStateReq.length) {
          let ids = this._session.queuedStateReq;
          if (ids.length > 8192) {
            this._session.queuedStateReq = ids.slice(8192);
            ids = ids.slice(0, 8192);
          } else {
            this._session.queuedStateReq = [];
          }
          getStateMsgIds = ids;
        }
        const idx = this._session.getStateSchedule.index({ getState: now }, true);
        if (idx > 0) {
          const toGetState = this._session.getStateSchedule.raw.splice(0, idx);
          if (!getStateMsgIds)
            getStateMsgIds = [];
          toGetState.forEach((it) => getStateMsgIds.push(it.msgId));
        }
        if (getStateMsgIds) {
          const obj = {
            _: "mt_msgs_state_req",
            msgIds: getStateMsgIds
          };
          getStateRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
          packetSize += getStateRequest.length + 16;
          messageCount += 1;
        }
      }
      if (this._session.queuedResendReq.length) {
        resendMsgIds = this._session.queuedResendReq;
        if (resendMsgIds.length > 8192) {
          this._session.queuedResendReq = resendMsgIds.slice(8192);
          resendMsgIds = resendMsgIds.slice(0, 8192);
        } else {
          this._session.queuedResendReq = [];
        }
        const obj = {
          _: "mt_msg_resend_req",
          msgIds: resendMsgIds
        };
        resendRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
        packetSize += resendRequest.length + 16;
        messageCount += 1;
      }
      if (this._session.queuedCancelReq.length) {
        containerMessageCount += this._session.queuedCancelReq.length;
        containerSize += this._session.queuedCancelReq.length * 28;
        cancelRpcs = this._session.queuedCancelReq;
        this._session.queuedCancelReq = [];
      }
      if (this._queuedDestroySession.length) {
        containerMessageCount += this._queuedDestroySession.length;
        containerSize += this._queuedDestroySession.length * 28;
        destroySessions = this._queuedDestroySession;
        this._queuedDestroySession = [];
      }
      if (this._salts.shouldFetchSalts()) {
        const obj = {
          _: "mt_get_future_salts",
          num: 64
        };
        getFutureSaltsRequest = TlBinaryWriter.serializeObject(this._writerMap, obj);
        containerSize += getFutureSaltsRequest.length + 16;
        containerMessageCount += 1;
        this._salts.isFetching = true;
      }
      let forceContainer = false;
      const rpcToSend = [];
      while (this._session.queuedRpc.length && containerSize < 32768 && containerMessageCount < 1020) {
        const msg = this._session.queuedRpc.popFront();
        if (msg.cancelled)
          continue;
        rpcToSend.push(msg);
        containerSize += msg.data.length + 16;
        if (msg.gzipOverhead)
          containerSize += msg.gzipOverhead;
        if (msg.chainId) {
          containerSize += INVOKE_AFTER_MSG_SIZE;
        }
        if (msg.msgId)
          forceContainer = true;
        if (msg.method === "upload.getFile")
          break;
      }
      packetSize += containerSize;
      messageCount += containerMessageCount + rpcToSend.length;
      if (!messageCount) {
        this.log.debug("flush did not happen: nothing to flush");
        return;
      }
      const useContainer = forceContainer || messageCount > 1;
      if (useContainer)
        packetSize += 24;
      const writer2 = TlBinaryWriter.alloc(this._writerMap, packetSize);
      if (useContainer) {
        writer2.pos += 16;
        writer2.uint(MSG_CONTAINER_ID);
        writer2.uint(messageCount);
      }
      const otherPendings = [];
      if (ackRequest) {
        this._registerOutgoingMsgId(this._session.writeMessage(writer2, ackRequest));
      }
      if (pingRequest) {
        pingMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, pingRequest));
        this._session.lastPingMsgId = pingMsgId;
        const pingPending = {
          _: "ping",
          pingId,
          containerId: pingMsgId
        };
        this._session.pendingMessages.set(pingMsgId, pingPending);
        otherPendings.push(pingPending);
      }
      if (getStateRequest) {
        getStateMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, getStateRequest));
        const getStatePending = {
          _: "state",
          msgIds: getStateMsgIds,
          containerId: getStateMsgId
        };
        this._session.pendingMessages.set(getStateMsgId, getStatePending);
        otherPendings.push(getStatePending);
      }
      if (resendRequest) {
        resendMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, resendRequest));
        const resendPending = {
          _: "resend",
          msgIds: resendMsgIds,
          containerId: resendMsgId
        };
        this._session.pendingMessages.set(resendMsgId, resendPending);
        otherPendings.push(resendPending);
      }
      if (cancelRpcs) {
        cancelRpcs.forEach((msgId) => {
          const cancelMsgId = this._registerOutgoingMsgId(
            this._session.writeMessage(writer2, {
              _: "mt_rpc_drop_answer",
              reqMsgId: msgId
            })
          );
          const pending = {
            _: "cancel",
            msgId,
            containerId: cancelMsgId
          };
          this._session.pendingMessages.set(cancelMsgId, pending);
          otherPendings.push(pending);
        });
      }
      if (destroySessions) {
        destroySessions.forEach((sessionId) => {
          const msgId = this._registerOutgoingMsgId(
            this._session.writeMessage(writer2, {
              _: "mt_destroy_session",
              sessionId
            })
          );
          const pending = {
            _: "destroy_session",
            sessionId,
            containerId: msgId
          };
          this._session.pendingMessages.set(msgId, pending);
          this._session.destroySessionIdToMsgId.set(sessionId, msgId);
          otherPendings.push(pending);
        });
      }
      if (getFutureSaltsRequest) {
        getFutureSaltsMsgId = this._registerOutgoingMsgId(this._session.writeMessage(writer2, getFutureSaltsRequest));
        const pending = {
          _: "future_salts",
          containerId: getFutureSaltsMsgId
        };
        this._session.pendingMessages.set(getFutureSaltsMsgId, pending);
        otherPendings.push(pending);
      }
      const getStateTime = now + GET_STATE_INTERVAL;
      for (let i = 0; i < rpcToSend.length; i++) {
        const msg = rpcToSend[i];
        if (!msg.msgId) {
          const msgId = this._session.getMessageId();
          const seqNo = this._session.getSeqNo();
          this.log.debug("%s: msg_id assigned %l, seqno: %d", msg.method, msgId, seqNo);
          msg.msgId = msgId;
          msg.seqNo = seqNo;
          this._session.pendingMessages.set(msgId, {
            _: "rpc",
            rpc: msg
          });
          if (msg.chainId) {
            msg.invokeAfter = this._session.addToChain(msg.chainId, msgId);
            this.log.debug("chain %s: invoke %l after %l", msg.chainId, msg.msgId, msg.invokeAfter);
          }
        } else {
          this.log.debug("%s: msg_id already assigned, reusing %l, seqno: %d", msg.method, msg.msgId, msg.seqNo);
        }
        if (msg.getState) {
          this._session.getStateSchedule.remove(msg);
        }
        if (!msg.acked) {
          msg.getState = getStateTime;
          this._session.getStateSchedule.insert(msg);
        }
        if (rootMsgId === null)
          rootMsgId = msg.msgId;
        writer2.long(this._registerOutgoingMsgId(msg.msgId));
        writer2.uint(msg.seqNo);
        const invokeAfterSize = msg.invokeAfter ? INVOKE_AFTER_MSG_SIZE : 0;
        const writeInvokeAfter = () => {
          if (!msg.invokeAfter)
            return;
          writer2.uint(INVOKE_AFTER_MSG_ID);
          writer2.long(msg.invokeAfter);
        };
        if (msg.gzipOverhead) {
          writer2.uint(msg.data.length + msg.gzipOverhead + invokeAfterSize);
          writeInvokeAfter();
          writer2.uint(GZIP_PACKED_ID);
          writer2.bytes(msg.data);
        } else {
          writer2.uint(msg.data.length + invokeAfterSize);
          writeInvokeAfter();
          writer2.raw(msg.data);
        }
        msg.sent = true;
      }
      if (useContainer) {
        packetSize = writer2.pos;
        const containerId = this._session.getMessageId();
        const seqNo = this._session.getSeqNo(false);
        this.log.debug("container: msg_id assigned %l, seqno: %d", containerId, seqNo);
        writer2.pos = 0;
        rootMsgId = containerId;
        writer2.long(this._registerOutgoingMsgId(containerId));
        writer2.uint(seqNo);
        writer2.uint(packetSize - 16);
        writer2.pos = packetSize;
        const msgIds = [];
        for (let i = 0; i < rpcToSend.length; i++) {
          const msg = rpcToSend[i];
          msg.containerId = containerId;
          msgIds.push(msg.msgId);
        }
        if (otherPendings.length) {
          otherPendings.forEach((msg) => {
            msgIds.push(msg.containerId);
            msg.containerId = containerId;
          });
        }
        this._session.pendingMessages.set(containerId, {
          _: "container",
          msgIds
        });
      }
      const result = writer2.result();
      this.log.debug(
        "sending %d messages: size = %db, acks = %L, ping = %b (msg_id = %l), state_req = %L (msg_id = %l), resend = %L (msg_id = %l), cancels = %L (msg_id = %l), salts_req = %b (msg_id = %l), rpc = %s, container = %b, root msg_id = %l",
        messageCount,
        packetSize,
        ackMsgIds,
        pingRequest,
        pingMsgId,
        getStateMsgIds,
        getStateMsgId,
        resendMsgIds,
        cancelRpcs,
        cancelRpcs,
        resendMsgId,
        getFutureSaltsRequest,
        getFutureSaltsMsgId,
        rpcToSend.map((it) => it.method),
        useContainer,
        rootMsgId
      );
      const enc = this._session.encryptMessage(result);
      const promise = this.send(enc).catch((err2) => {
        this.log.error("error while sending pending messages (root msg_id = %l): %e", rootMsgId, err2);
        if (ackMsgIds) {
          this._session.queuedAcks.splice(0, 0, ...ackMsgIds);
        }
        if (rootMsgId) {
          this._onMessageFailed(rootMsgId, "unknown error");
        }
      });
      if (this._inactivityPendingFlush && !this._session.hasPendingMessages) {
        void promise.then(() => {
          this.log.debug("pending messages sent, closing connection");
          this._flushTimer.reset();
          this._inactivityPendingFlush = false;
          super._onInactivityTimeout();
        });
      }
    }
  }
  class MultiSessionConnection extends EventEmitter {
    constructor(params, _count, log, logPrefix = "") {
      super();
      __publicField(this, "_log");
      __publicField(this, "_sessions");
      __publicField(this, "_enforcePfs", false);
      __publicField(this, "_connections", []);
      __publicField(this, "_destroyed", false);
      __publicField(this, "_nextConnection", 0);
      this.params = params;
      this._count = _count;
      this._log = log.create("multi");
      if (logPrefix)
        this._log.prefix = `[${logPrefix}] `;
      this._enforcePfs = _count > 1 && params.isMainConnection;
      this._sessions = [];
      this._updateConnections();
    }
    setCount(count, connect = this.params.isMainConnection) {
      this._count = count;
      this._updateConnections(connect);
    }
    _updateSessions() {
      this._log.debug("updating sessions count: %d -> %d", this._sessions.length, this._count);
      if (this._sessions.length === this._count)
        return;
      if (this._sessions.length > this._count) {
        for (let i = this._sessions.length - 1; i >= this._count; i--) {
          this._sessions[i].reset();
        }
        this._sessions.splice(this._count);
        return;
      }
      while (this._sessions.length < this._count) {
        const idx = this._sessions.length;
        const session = new MtprotoSession(
          this.params.crypto,
          this._log.create("session"),
          this.params.readerMap,
          this.params.writerMap,
          this.params.salts
        );
        if (idx !== 0)
          session._authKey = this._sessions[0]._authKey;
        this._sessions.push(session);
      }
    }
    _updateConnections(connect = false) {
      this._updateSessions();
      if (this._connections.length === this._count)
        return;
      this._log.debug("updating connections count: %d -> %d", this._connections.length, this._count);
      const newEnforcePfs = this._count > 1 && this.params.isMainConnection;
      const enforcePfsChanged = newEnforcePfs !== this._enforcePfs;
      if (enforcePfsChanged) {
        this._log.debug("enforcePfs changed: %s -> %s", this._enforcePfs, newEnforcePfs);
        this._enforcePfs = newEnforcePfs;
      }
      if (this._connections.length > this._count) {
        for (let i = this._connections.length - 1; i >= this._count; i--) {
          this._connections[i].removeAllListeners();
          this._connections[i].destroy().catch((err2) => {
            this._log.warn("error destroying connection: %e", err2);
          });
        }
        this._connections.splice(this._count);
        return;
      }
      if (enforcePfsChanged) {
        const promise = createControllablePromise();
        this.emit("request-keys", promise);
        promise.then(() => {
          this._connections.forEach((conn) => {
            conn.setUsePfs(this.params.usePfs || this._enforcePfs);
            if (connect)
              conn.connect();
          });
        }).catch((err2) => {
          this.emit("error", err2);
        });
      }
      for (let i = this._connections.length; i < this._count; i++) {
        const session = this._sessions[i];
        const conn = new SessionConnection(
          __spreadProps(__spreadValues({}, this.params), {
            usePfs: this.params.usePfs || this._enforcePfs,
            isMainConnection: this.params.isMainConnection && i === 0,
            withUpdates: this.params.isMainConnection && this.params.isMainDcConnection && !this.params.disableUpdates
          }),
          session
        );
        if (this.params.isMainConnection && this.params.isMainDcConnection) {
          conn.on("update", (update) => this.emit("update", update));
        }
        conn.on("error", (err2) => this.emit("error", err2, conn));
        conn.on("key-change", (key) => {
          this.emit("key-change", i, key);
          for(let   conn_ of this._connections) {
            if (conn_ === conn)
              continue;
            conn_.onConnected();
          }
        });
        conn.on("tmp-key-change", (key, expires) => this.emit("tmp-key-change", i, key, expires));
        conn.on("future-salts", (salts) => this.emit("future-salts", salts));
        conn.on("auth-begin", () => {
          this._log.debug("received auth-begin from connection %d", i);
          this.emit("auth-begin", i);
          this._connections.forEach((conn_) => {
            conn_._session._authKeyTemp.reset();
            if (conn_ !== conn)
              conn_.reconnect();
          });
        });
        conn.on("usable", () => this.emit("usable", i));
        conn.on("wait", () => this.emit("wait", i));
        conn.on("request-auth", () => this.emit("request-auth", i));
        conn.on("flood-done", () => {
          this._log.debug("received flood-done from connection %d", i);
          this._connections.forEach((it) => it.flushWhenIdle());
        });
        this._connections.push(conn);
        if (connect && !enforcePfsChanged)
          conn.connect();
      }
    }
    destroy() {
      return __async(this, null, function* () {
        yield Promise.all(this._connections.map((conn) => conn.destroy()));
        this._sessions.forEach((sess) => sess.reset());
        this.removeAllListeners();
        this._destroyed = true;
      });
    }
    sendRpc(request, timeout, abortSignal, chainId) {
      let min2 = Infinity;
      let minIdx = 0;
      for (let i = 0; i < this._connections.length; i++) {
        const conn = this._connections[i];
        const total = conn._session.queuedRpc.length + conn._session.pendingMessages.size();
        if (total < min2) {
          min2 = total;
          minIdx = i;
        }
      }
      return this._connections[minIdx].sendRpc(request, timeout, abortSignal, chainId);
    }
    connect() {
      for(let   conn of this._connections) {
        conn.connect();
      }
    }
    ensureConnected() {
      if (this._connections[0].isConnected)
        return;
      this.connect();
    }
    setAuthKey(authKey, temp = false, idx = 0) {
      const session = this._sessions[idx];
      const key = temp ? session._authKeyTemp : session._authKey;
      key.setup(authKey);
    }
    resetAuthKeys() {
      for(let   session of this._sessions) {
        session.reset(true);
      }
      this.notifyKeyChange();
    }
    setInactivityTimeout(timeout) {
      this._log.debug("setting inactivity timeout to %s", timeout);
      this.params.inactivityTimeout = timeout;
      for(let   conn of this._connections) {
        conn.setInactivityTimeout(timeout);
      }
    }
    notifyKeyChange() {
      const session = this._sessions[0];
      if (this.params.usePfs && !session._authKeyTemp.ready) {
        this._log.debug("temp auth key needed but not ready, ignoring key change");
        return;
      }
      if (this._sessions[0].queuedRpc.length) {
        this._log.debug("notifying key change on the connection due to queued rpc");
        this._connections[0].onConnected();
      }
    }
    notifyNetworkChanged(connected) {
      for(let   conn of this._connections) {
        conn.notifyNetworkChanged(connected);
      }
    }
    requestAuth() {
      this._connections[0]._authorize();
    }
    resetSessions() {
      if (this.params.isMainConnection) {
        for(let   conn of this._connections) {
          conn._resetSession();
        }
      } else {
        this._connections[0]._resetSession();
      }
    }
    changeTransport(factory) {
      this._connections.forEach((conn) => conn.changeTransport(factory));
    }
    getPoolSize() {
      return this._connections.length;
    }
  }
  const defaultReconnectionStrategy = (params, lastError, consequentFails, previousWait) => {
    if (previousWait === null)
      return 0;
    if (previousWait === 0)
      return 1e3;
    if (previousWait >= 5e3)
      return 5e3;
    return Math.min(5e3, previousWait + 1e3);
  };
  class ServerSaltManager {
    constructor() {
      __publicField(this, "_futureSalts", []);
      __publicField(this, "currentSalt", Long.ZERO);
      __publicField(this, "isFetching", false);
      __publicField(this, "_timer");
    }
    shouldFetchSalts() {
      return !this.isFetching && !this.currentSalt.isZero() && this._futureSalts.length < 2;
    }
    setFutureSalts(salts) {
      this._futureSalts = salts;
      const now = Date.now() / 1e3;
      while (salts.length > 0 && now > salts[0].validSince) {
        this.currentSalt = salts[0].salt;
        this._futureSalts.shift();
      }
      if (!this._futureSalts.length)
        this.currentSalt = Long.ZERO;
      else
        this._scheduleNext();
    }
    _scheduleNext() {
      if (this._timer)
        clearTimeoutWrap(this._timer);
      if (this._futureSalts.length === 0)
        return;
      const next = this._futureSalts.shift();
      this._timer = setTimeoutWrap(
        () => {
          this.currentSalt = next.salt;
          this._scheduleNext();
        },
        next.validSince * 1e3 - Date.now()
      );
    }
    destroy() {
      clearTimeoutWrap(this._timer);
    }
  }
  const defaultConnectionCountDelegate = (kind, dcId, isPremium) => {
    switch (kind) {
      case "main":
        return 0;
      case "upload":
        return isPremium || dcId !== 2 && dcId !== 4 ? 8 : 4;
      case "download":
        return isPremium ? 8 : 2;
      case "downloadSmall":
        return 2;
    }
  };
  class DcConnectionManager {
    constructor(manager, dcId, _dcs, isPrimary = false) {
      __publicField(this, "_salts", new ServerSaltManager());
      __publicField(this, "_log");
      /** Main connection pool */
      __publicField(this, "main");
      /** Upload connection pool */
      __publicField(this, "upload");
      /** Download connection pool */
      __publicField(this, "download");
      /** Download connection pool (for small files) */
      __publicField(this, "downloadSmall");
      var _a2, _b;
      this.manager = manager;
      this.dcId = dcId;
      this._dcs = _dcs;
      this.isPrimary = isPrimary;
      this._log = this.manager._log.create("dc-manager");
      this._log.prefix = `[DC ${dcId}] `;
      const baseConnectionParams = () => {
        var _a3;
        return {
          crypto: this.manager.params.crypto,
          initConnection: this.manager._initConnectionParams,
          transportFactory: this.manager._transportFactory,
          dc: this._dcs.media,
          testMode: this.manager.params.testMode,
          reconnectionStrategy: this.manager._reconnectionStrategy,
          layer: this.manager.params.layer,
          disableUpdates: this.manager.params.disableUpdates,
          readerMap: this.manager.params.readerMap,
          writerMap: this.manager.params.writerMap,
          usePfs: this.manager.params.usePfs,
          isMainConnection: false,
          isMainDcConnection: this.isPrimary,
          inactivityTimeout: (_a3 = this.manager.params.inactivityTimeout) != null ? _a3 : 6e4,
          enableErrorReporting: this.manager.params.enableErrorReporting,
          salts: this._salts
        };
      };
      const mainParams = baseConnectionParams();
      mainParams.isMainConnection = true;
      mainParams.dc = _dcs.main;
      if (isPrimary) {
        mainParams.inactivityTimeout = void 0;
      }
      let mainCount;
      if (this.isPrimary) {
        mainCount = this._mainCountOverride;
        if (mainCount === 0) {
          mainCount = (_b = (_a2 = this.manager.config.getNow()) == null ? void 0 : _a2.tmpSessions) != null ? _b : 1;
        }
      } else {
        mainCount = 1;
      }
      this.main = new MultiSessionConnection(mainParams, mainCount, this._log, "MAIN");
      this.upload = new MultiSessionConnection(
        baseConnectionParams(),
        this.manager._connectionCount("upload", this.dcId, this.manager.params.isPremium),
        this._log,
        "UPLOAD"
      );
      this.download = new MultiSessionConnection(
        baseConnectionParams(),
        this.manager._connectionCount("download", this.dcId, this.manager.params.isPremium),
        this._log,
        "DOWNLOAD"
      );
      this.downloadSmall = new MultiSessionConnection(
        baseConnectionParams(),
        this.manager._connectionCount("downloadSmall", this.dcId, this.manager.params.isPremium),
        this._log,
        "DOWNLOAD_SMALL"
      );
      this._setupMulti("main");
      this._setupMulti("upload");
      this._setupMulti("download");
      this._setupMulti("downloadSmall");
    }
    get _mainCountOverride() {
      var _a2, _b, _c;
      return (_c = (_b = (_a2 = this.manager.params).connectionCount) == null ? void 0 : _b.call(_a2, "main", this.dcId, this.manager.params.isPremium)) != null ? _c : 0;
    }
    _setupMulti(kind) {
      const connection = this[kind];
      connection.on("key-change", (idx, key) => {
        if (kind !== "main") {
          this.manager._log.warn("got key-change from non-main connection, ignoring");
          return;
        }
        this.manager._log.debug("key change for dc %d from connection %d", this.dcId, idx);
        this.upload.setAuthKey(key);
        this.download.setAuthKey(key);
        this.downloadSmall.setAuthKey(key);
        Promise.resolve(this.manager._storage.provider.authKeys.set(this.dcId, key)).then(() => {
          this.upload.notifyKeyChange();
          this.download.notifyKeyChange();
          this.downloadSmall.notifyKeyChange();
        }).catch((e) => {
          this.manager._log.warn("failed to save auth key for dc %d: %e", this.dcId, e);
          this.manager.params.emitError(e);
        });
      });
      connection.on("tmp-key-change", (idx, key, expires) => {
        if (kind !== "main") {
          this.manager._log.warn("got tmp-key-change from non-main connection, ignoring");
          return;
        }
        this.manager._log.debug("temp key change for dc %d from connection %d", this.dcId, idx);
        this.upload.setAuthKey(key, true);
        this.download.setAuthKey(key, true);
        this.downloadSmall.setAuthKey(key, true);
        Promise.resolve(this.manager._storage.provider.authKeys.setTemp(this.dcId, idx, key, expires * 1e3)).then(() => {
          this.upload.notifyKeyChange();
          this.download.notifyKeyChange();
          this.downloadSmall.notifyKeyChange();
        }).catch((e) => {
          this.manager._log.warn("failed to save temp auth key %d for dc %d: %e", idx, this.dcId, e);
          this.manager.params.emitError(e);
        });
      });
      connection.on("future-salts", (salts) => {
        Promise.resolve(this.manager._storage.salts.store(this.dcId, salts)).catch(
          (e) => this.manager.params.emitError(e)
        );
      });
      connection.on("auth-begin", () => {
        if (kind !== "main") {
          this.manager._log.warn("got auth-begin from non-main connection, ignoring");
          return;
        }
        this.upload.resetAuthKeys();
        this.download.resetAuthKeys();
        this.downloadSmall.resetAuthKeys();
      });
      connection.on("request-auth", () => {
        this.main.requestAuth();
      });
      connection.on("request-keys", (promise) => {
        this.loadKeys(true).then(() => promise.resolve()).catch((e) => promise.reject(e));
      });
      connection.on("error", (err2, conn) => {
        this.manager.params.emitError(err2, conn);
      });
    }
    setIsPrimary(isPrimary) {
      var _a2;
      if (this.isPrimary === isPrimary)
        return;
      this.isPrimary = isPrimary;
      this.main.params.isMainDcConnection = isPrimary;
      if (isPrimary) {
        this.main.setInactivityTimeout(void 0);
      } else {
        this.main.setInactivityTimeout((_a2 = this.manager.params.inactivityTimeout) != null ? _a2 : 6e4);
      }
    }
    setIsPremium(isPremium) {
      this.upload.setCount(this.manager._connectionCount("upload", this.dcId, isPremium));
      this.download.setCount(this.manager._connectionCount("download", this.dcId, isPremium));
      this.downloadSmall.setCount(this.manager._connectionCount("downloadSmall", this.dcId, isPremium));
    }
    loadKeys(forcePfs = false) {
      return __async(this, null, function* () {
        const [permanent, salts] = yield Promise.all([
          this.manager._storage.provider.authKeys.get(this.dcId),
          this.manager._storage.salts.fetch(this.dcId)
        ]);
        this.main.setAuthKey(permanent);
        this.upload.setAuthKey(permanent);
        this.download.setAuthKey(permanent);
        this.downloadSmall.setAuthKey(permanent);
        if (salts) {
          this._salts.setFutureSalts(salts);
        }
        if (!permanent) {
          return false;
        }
        if (this.manager.params.usePfs || forcePfs) {
          const now = Date.now();
          yield Promise.all(
            this.main._sessions.map((_, i) => __async(this, null, function* () {
              const temp = yield this.manager._storage.provider.authKeys.getTemp(this.dcId, i, now);
              this.main.setAuthKey(temp, true, i);
              if (i === 0) {
                this.upload.setAuthKey(temp, true);
                this.download.setAuthKey(temp, true);
                this.downloadSmall.setAuthKey(temp, true);
              }
            }))
          );
        }
        return true;
      });
    }
    setMainConnectionCount(count) {
      if (this._mainCountOverride > 0)
        return;
      this.main.setCount(count);
    }
    destroy() {
      return __async(this, null, function* () {
        yield this.main.destroy();
        yield this.upload.destroy();
        yield this.download.destroy();
        yield this.downloadSmall.destroy();
        this._salts.destroy();
      });
    }
  }
  class NetworkManager {
    constructor(params, config) {
      __publicField(this, "_log");
      __publicField(this, "_storage");
      __publicField(this, "_initConnectionParams");
      __publicField(this, "_transportFactory");
      __publicField(this, "_reconnectionStrategy");
      __publicField(this, "_connectionCount");
      __publicField(this, "_dcConnections", /* @__PURE__ */ new Map());
      __publicField(this, "_primaryDc");
      __publicField(this, "_updateHandler");
      __publicField(this, "_resetOnNetworkChange");
      __publicField(this, "_dcCreationPromise", /* @__PURE__ */ new Map());
      __publicField(this, "_pendingExports", {});
      __publicField(this, "call");
      __publicField(this, "_composeCall", (middlewares) => {
        if (!middlewares) {
          middlewares = basic();
        }
        if (!middlewares.length) {
          return this._call;
        }
        const final = (ctx) => __async(this, null, function* () {
          return this._call(ctx.request, ctx.params);
        });
        const composed = composeMiddlewares(middlewares, final);
        return (message2, params) => __async(this, null, function* () {
          return composed({
            request: message2,
            manager: this,
            params
          });
        });
      });
      __publicField(this, "_call", (message2, params) => __async(this, null, function* () {
        var _a2;
        if (!this._primaryDc) {
          throw new MtcuteError("Not connected to any DC");
        }
        const kind = (_a2 = params == null ? void 0 : params.kind) != null ? _a2 : "main";
        let manager;
        if (params == null ? void 0 : params.manager) {
          manager = params.manager;
        } else if ((params == null ? void 0 : params.dcId) && params.dcId !== this._primaryDc.dcId) {
          manager = yield this._getOtherDc(params.dcId);
        } else {
          manager = this._primaryDc;
        }
        let multi = manager[kind];
        let res = yield multi.sendRpc(message2, params == null ? void 0 : params.timeout, params == null ? void 0 : params.abortSignal, params == null ? void 0 : params.chainId);
        if (!isTlRpcError(res)) {
          return res;
        }
        const err2 = res.errorMessage;
        if (manager === this._primaryDc) {
          if (err2.startsWith("PHONE_MIGRATE_") || err2.startsWith("NETWORK_MIGRATE_") || err2.startsWith("USER_MIGRATE_")) {
            const newDc = Number(err2.slice(err2.lastIndexOf("_") + 1));
            if (Number.isNaN(newDc)) {
              this._log.warn("invalid migrate error received: %s, ignoring", err2);
              return res;
            }
            if (params == null ? void 0 : params.localMigrate) {
              manager = yield this._getOtherDc(newDc);
            } else {
              this._log.info("received %s, migrating to dc %d", err2, newDc);
              yield this.changePrimaryDc(newDc);
              manager = this._primaryDc;
            }
            multi = manager[kind];
            res = yield multi.sendRpc(message2, params == null ? void 0 : params.timeout, params == null ? void 0 : params.abortSignal, params == null ? void 0 : params.chainId);
          }
        } else if (err2 === "AUTH_KEY_UNREGISTERED") {
          this._log.warn("exported auth key error, trying re-exporting..");
          yield this._exportAuthTo(manager);
          res = yield multi.sendRpc(message2, params == null ? void 0 : params.timeout, params == null ? void 0 : params.abortSignal, params == null ? void 0 : params.chainId);
        }
        return res;
      }));
      var _a2, _b, _c;
      this.params = params;
      this.config = config;
      const deviceModel = `mtcute on ${getPlatform().getDeviceModel()}`;
      this._initConnectionParams = __spreadProps(__spreadValues({
        _: "initConnection",
        deviceModel,
        systemVersion: "1.0",
        appVersion: "%VERSION%",
        systemLangCode: "en",
        langPack: "",
        // "langPacks are for official apps only"
        langCode: "en"
      }, (_a2 = params.initConnectionOptions) != null ? _a2 : {}), {
        apiId: params.apiId,
        // eslint-disable-next-line
        query: null
      });
      this._transportFactory = params.transport;
      this._reconnectionStrategy = (_b = params.reconnectionStrategy) != null ? _b : defaultReconnectionStrategy;
      this._connectionCount = (_c = params.connectionCount) != null ? _c : defaultConnectionCountDelegate;
      this._updateHandler = params.onUpdate;
      this.call = this._composeCall(params.middlewares);
      this._onConfigChanged = this._onConfigChanged.bind(this);
      config.onReload(this._onConfigChanged);
      this._log = params.log.create("network");
      this._storage = params.storage;
    }
    _findDcOptions(dcId) {
      return __async(this, null, function* () {
        const main = yield this.config.findOption({
          dcId,
          allowIpv6: this.params.useIpv6,
          preferIpv6: this.params.useIpv6,
          allowMedia: false,
          cdn: false
        });
        const media = yield this.config.findOption({
          dcId,
          allowIpv6: this.params.useIpv6,
          preferIpv6: this.params.useIpv6,
          allowMedia: true,
          preferMedia: true,
          cdn: false
        });
        if (!main || !media) {
          throw new MtArgumentError(`Could not find DC ${dcId}`);
        }
        return { main, media };
      });
    }
    _switchPrimaryDc(dc) {
      if (this._primaryDc && this._primaryDc !== dc) {
        this._primaryDc.setIsPrimary(false);
      }
      this._primaryDc = dc;
      dc.setIsPrimary(true);
      this.params.onConnecting();
      dc.main.on("usable", () => {
        if (dc !== this._primaryDc)
          return;
        this.params.onUsable();
      });
      dc.main.on("wait", () => {
        if (dc !== this._primaryDc)
          return;
        this.params.onConnecting();
      });
      dc.main.on("update", (update) => {
        this._updateHandler(update, false);
      });
      return dc.loadKeys().then(() => dc.main.ensureConnected());
    }
    _getOtherDc(dcId) {
      return __async(this, null, function* () {
        if (!this._dcConnections.has(dcId)) {
          if (this._dcCreationPromise.has(dcId)) {
            this._log.debug("waiting for DC %d to be created", dcId);
            yield this._dcCreationPromise.get(dcId);
            return this._dcConnections.get(dcId);
          }
          const promise = createControllablePromise();
          this._dcCreationPromise.set(dcId, promise);
          this._log.debug("creating new DC %d", dcId);
          try {
            const dcOptions = yield this._findDcOptions(dcId);
            const dc = new DcConnectionManager(this, dcId, dcOptions);
            if (!(yield dc.loadKeys())) {
              dc.main.requestAuth();
            }
            this._dcConnections.set(dcId, dc);
            promise.resolve();
          } catch (e) {
            promise.reject(e);
          }
        }
        return this._dcConnections.get(dcId);
      });
    }
    /**
     * Perform initial connection to the default DC
     *
     * @param defaultDcs  Default DCs to connect to
     */
    connect(defaultDcs) {
      return __async(this, null, function* () {
        var _a2, _b;
        if (defaultDcs.main.id !== defaultDcs.media.id) {
          throw new MtArgumentError("Default DCs must be the same");
        }
        if (this._dcConnections.has(defaultDcs.main.id)) {
          throw new MtArgumentError("DC manager already exists");
        }
        this._resetOnNetworkChange = (_b = (_a2 = getPlatform()).onNetworkChanged) == null ? void 0 : _b.call(_a2, this.notifyNetworkChanged.bind(this));
        const dc = new DcConnectionManager(this, defaultDcs.main.id, defaultDcs, true);
        this._dcConnections.set(defaultDcs.main.id, dc);
        yield this._switchPrimaryDc(dc);
      });
    }
    _exportAuthTo(manager) {
      return __async(this, null, function* () {
        if (manager.dcId in this._pendingExports) {
          this._log.debug("waiting for auth export to dc %d", manager.dcId);
          return this._pendingExports[manager.dcId];
        }
        this._log.debug("exporting auth to dc %d", manager.dcId);
        const promise = createControllablePromise();
        this._pendingExports[manager.dcId] = promise;
        try {
          const auth = yield this.call({
            _: "auth.exportAuthorization",
            dcId: manager.dcId
          });
          if (isTlRpcError(auth)) {
            throw new MtcuteError(`Failed to export (${auth.errorCode}: ${auth.errorMessage})`);
          }
          const res = yield this.call(
            {
              _: "auth.importAuthorization",
              id: auth.id,
              bytes: auth.bytes
            },
            { manager }
          );
          if (isTlRpcError(res)) {
            throw new MtcuteError(`Failed to import (${res.errorCode}: ${res.errorMessage})`);
          }
          assertTypeIs("auth.importAuthorization", res, "auth.authorization");
          promise.resolve();
          delete this._pendingExports[manager.dcId];
        } catch (e) {
          this._log.warn("failed to export auth to dc %d: %s", manager.dcId, e);
          promise.reject(e);
          throw e;
        }
      });
    }
    setIsPremium(isPremium) {
      this._log.debug("setting isPremium to %s", isPremium);
      this.params.isPremium = isPremium;
      for(let   dc of this._dcConnections.values()) {
        dc.setIsPremium(isPremium);
      }
    }
    notifyLoggedIn(auth) {
      var _a2;
      if (auth._ === "auth.authorizationSignUpRequired") {
        throw new MtUnsupportedError(
          "Signup is no longer supported by Telegram for non-official clients. Please use your mobile device to sign up."
        );
      }
      let user;
      if (auth._ === "auth.authorization") {
        if (auth.tmpSessions) {
          (_a2 = this._primaryDc) == null ? void 0 : _a2.setMainConnectionCount(auth.tmpSessions);
        }
        user = auth.user;
      } else {
        if (auth.bot) {
          this.config.update(true).catch((e) => this.params.emitError(e));
        }
        user = auth;
      }
      this.setIsPremium(user.premium);
      if (auth._ === "auth.authorization" && this.params.disableUpdates) {
        this.resetSessions();
      }
      return user;
    }
    notifyLoggedOut() {
      this.setIsPremium(false);
      this.resetSessions();
    }
    notifyNetworkChanged(connected) {
      this._log.debug("network changed: %s", connected ? "connected" : "disconnected");
      this.params.onNetworkChanged(connected);
      for(let   dc of this._dcConnections.values()) {
        dc.main.notifyNetworkChanged(connected);
        dc.upload.notifyNetworkChanged(connected);
        dc.download.notifyNetworkChanged(connected);
        dc.downloadSmall.notifyNetworkChanged(connected);
      }
    }
    resetSessions() {
      const dc = this._primaryDc;
      if (!dc)
        return;
      dc.main.resetSessions();
      dc.upload.resetSessions();
      dc.download.resetSessions();
      dc.downloadSmall.resetSessions();
    }
    _onConfigChanged(config) {
      var _a2;
      if (config.tmpSessions) {
        (_a2 = this._primaryDc) == null ? void 0 : _a2.setMainConnectionCount(config.tmpSessions);
      }
    }
    changePrimaryDc(newDc) {
      return __async(this, null, function* () {
        var _a2;
        if (newDc === ((_a2 = this._primaryDc) == null ? void 0 : _a2.dcId))
          return;
        const options = yield this._findDcOptions(newDc);
        if (!this._dcConnections.has(newDc)) {
          this._dcConnections.set(newDc, new DcConnectionManager(this, newDc, options, true));
        }
        yield this._storage.dcs.store(options);
        yield this._switchPrimaryDc(this._dcConnections.get(newDc));
      });
    }
    changeTransport(factory) {
      for(let   dc of this._dcConnections.values()) {
        dc.main.changeTransport(factory);
        dc.upload.changeTransport(factory);
        dc.download.changeTransport(factory);
        dc.downloadSmall.changeTransport(factory);
      }
    }
    getPoolSize(kind, dcId) {
      const dc = dcId ? this._dcConnections.get(dcId) : this._primaryDc;
      if (!dc) {
        if (!this._primaryDc) {
          throw new MtcuteError("Not connected to any DC");
        }
        return this._connectionCount(kind, dcId != null ? dcId : this._primaryDc.dcId, this.params.isPremium);
      }
      return dc[kind].getPoolSize();
    }
    getPrimaryDcId() {
      if (!this._primaryDc)
        throw new MtcuteError("Not connected to any DC");
      return this._primaryDc.dcId;
    }
    destroy() {
      return __async(this, null, function* () {
        var _a2;
        for(let   dc of this._dcConnections.values()) {
          yield dc.destroy();
        }
        this._dcConnections.clear();
        this.config.offReload(this._onConfigChanged);
        (_a2 = this._resetOnNetworkChange) == null ? void 0 : _a2.call(this);
      });
    }
    getMtprotoMessageId() {
      return this._primaryDc.main._sessions[0].getMessageId();
    }
  }
  class MtClient extends EventEmitter {
    constructor(params) {
      var _a2, _b, _c, _d, _e, _f;
      super();
      /**
       * Crypto provider taken from {@link MtClientOptions.crypto}
       */
      __publicField(this, "crypto");
      /** Storage manager */
      __publicField(this, "storage");
      /**
       * "Test mode" taken from {@link MtClientOptions.testMode}
       */
      __publicField(this, "_testMode");
      /**
       * Primary DCs taken from {@link MtClientOptions.defaultDcs},
       * loaded from session or changed by other means (like redirecting).
       */
      __publicField(this, "_defaultDcs");
      /** TL layer used by the client */
      __publicField(this, "_layer");
      /** TL readers map used by the client */
      __publicField(this, "_readerMap");
      /** TL writers map used by the client */
      __publicField(this, "_writerMap");
      __publicField(this, "_config", new ConfigManager(() => __async(this, null, function* () {
        const res = yield this.call({ _: "help.getConfig" });
        if (isTlRpcError(res))
          throw new Error(`Failed to get config: ${res.errorMessage}`);
        return res;
      })));
      __publicField(this, "_emitError");
      __publicField(this, "log");
      __publicField(this, "network");
      __publicField(this, "_abortController");
      __publicField(this, "stopSignal");
      __publicField(this, "_prepare", asyncResettable(() => __async(this, null, function* () {
        var _a2, _b;
        yield (_b = (_a2 = this.crypto).initialize) == null ? void 0 : _b.call(_a2);
        yield this.storage.load();
        const primaryDc = yield this.storage.dcs.fetch();
        if (primaryDc !== null)
          this._defaultDcs = primaryDc;
      })));
      __publicField(this, "_connect", asyncResettable(() => __async(this, null, function* () {
        yield this._prepare.run();
        yield this.network.connect(this._defaultDcs);
      })));
      this.params = params;
      this.log = (_a2 = params.logger) != null ? _a2 : new LogManager();
      if (params.logLevel !== void 0) {
        this.log.mgr.level = params.logLevel;
      }
      this.crypto = params.crypto;
      this._testMode = Boolean(params.testMode);
      let dc = params.defaultDcs;
      if (!dc) {
        if (params.testMode) {
          dc = params.useIpv6 ? defaultTestIpv6Dc : defaultTestDc;
        } else {
          dc = params.useIpv6 ? defaultProductionIpv6Dc : defaultProductionDc;
        }
      }
      this._defaultDcs = dc;
      this._layer = (_b = params.overrideLayer) != null ? _b : tl.tl.LAYER;
      this._readerMap = (_c = params.readerMap) != null ? _c : __tlReaderMap;
      this._writerMap = (_d = params.writerMap) != null ? _d : __tlWriterMap;
      this._abortController = new AbortController();
      this.stopSignal = this._abortController.signal;
      this.storage = new StorageManager(__spreadValues({
        provider: params.storage,
        log: this.log,
        readerMap: this._readerMap,
        writerMap: this._writerMap
      }, params.storageOptions));
      this.network = new NetworkManager(
        __spreadValues({
          apiId: params.apiId,
          crypto: this.crypto,
          disableUpdates: (_e = params.disableUpdates) != null ? _e : false,
          initConnectionOptions: params.initConnectionOptions,
          layer: this._layer,
          log: this.log,
          readerMap: this._readerMap,
          writerMap: this._writerMap,
          reconnectionStrategy: params.reconnectionStrategy,
          storage: this.storage,
          testMode: Boolean(params.testMode),
          transport: params.transport,
          emitError: this.emitError.bind(this),
          isPremium: false,
          useIpv6: Boolean(params.useIpv6),
          enableErrorReporting: (_f = params.enableErrorReporting) != null ? _f : false,
          onUsable: () => this.emit("usable"),
          onConnecting: () => this.emit("connecting"),
          onNetworkChanged: (connected) => this.emit("networkChanged", connected),
          onUpdate: (upd) => this.emit("update", upd),
          stopSignal: this.stopSignal
        }, params.network),
        this._config
      );
    }
    emitError(err2) {
      if (this._emitError) {
        this._emitError(err2);
      } else if (this._connect.finished()) {
        this.log.error("unhandled error:", err2);
      }
    }
    /**
     * **ADVANCED**
     *
     * Do all the preparations, but don't connect just yet.
     * Useful when you want to do some preparations before
     * connecting, like setting up session.
     *
     * Call {@link connect} to actually connect.
     */
    prepare() {
      return this._prepare.run();
    }
    /**
     * Initialize the connection to the primary DC.
     *
     * You shouldn't usually call this method directly as it is called
     * implicitly the first time you call {@link call}.
     */
    connect() {
      return __async(this, null, function* () {
        return this._connect.run();
      });
    }
    /**
     * Close all connections and finalize the client.
     */
    close() {
      return __async(this, null, function* () {
        var _a2, _b;
        this.log.debug("closing client");
        this._config.destroy();
        yield this.network.destroy();
        yield this.storage.save();
        yield (_b = (_a2 = this.storage).destroy) == null ? void 0 : _b.call(_a2);
        this._prepare.reset();
        this._connect.reset();
        this._abortController.abort();
        this.log.debug("client closed successfully");
      });
    }
    /**
     * Make an RPC call.
     *
     * The connection must have been {@link connect}-ed
     * before calling this method.
     *
     * This method is still quite low-level and you shouldn't use this
     * when using high-level API provided by `@mtcute/client`.
     *
     * @param message  RPC method to call
     * @param params  Additional call parameters
     */
    call(message2, params) {
      return __async(this, null, function* () {
        return this.network.call(message2, params);
      });
    }
    /**
     * Register an error handler for the client
     *
     * @param handler Error handler.
     */
    onError(handler) {
      this._emitError = handler;
    }
  }
  function reportUnknownError(log, error, method) {
    if (typeof fetch !== "function")
      return;
    fetch(`https://report-rpc-error.madelineproto.xyz/?code=${error.code}&method=${method}&error=${error.text}`).then((r) => r.json()).then((r) => {
      if (r.result) {
        log.info("telerpc responded with error info for %s: %s", error.text, r.result);
      } else {
        log.info(
          "Reported error %s to telerpc. You can disable this using `enableErrorReporting: false`",
          error.text
        );
      }
    }).catch((e) => {
      log.debug("failed to report error %s to telerpc: %e", error.text, e);
    });
  }
  class AppConfigManager {
    constructor(client) {
      __publicField(this, "_reloadable", new Reloadable({
        reload: this._reload.bind(this),
        getExpiresAt: () => 36e5,
        disableAutoReload: true
      }));
      __publicField(this, "_object");
      this.client = client;
    }
    _reload(old) {
      return __async(this, null, function* () {
        var _a2;
        const res = yield this.client.call({
          _: "help.getAppConfig",
          hash: (_a2 = old == null ? void 0 : old.hash) != null ? _a2 : 0
        });
        if (res._ === "help.appConfigNotModified")
          return old;
        return res;
      });
    }
    get() {
      return __async(this, null, function* () {
        if (!this._reloadable.isStale && this._object)
          return this._object;
        const obj = tlJsonToJson((yield this._reloadable.get()).config);
        if (!obj || typeof obj !== "object") {
          throw new MtTypeAssertionError("appConfig", "object", typeof obj);
        }
        this._object = obj;
        return this._object;
      });
    }
    getField(field, fallback) {
      return __async(this, null, function* () {
        var _a2;
        const obj = yield this.get();
        return (_a2 = obj[field]) != null ? _a2 : fallback;
      });
    }
  }
  const USERNAME_TTL = 24 * 60 * 60 * 1e3;
  function getInputPeer(dto) {
    const [type, id2] = parseMarkedPeerId(dto.id);
    switch (type) {
      case "user":
        return {
          _: "inputPeerUser",
          userId: id2,
          accessHash: longFromFastString(dto.accessHash)
        };
      case "chat":
        return {
          _: "inputPeerChat",
          chatId: id2
        };
      case "channel":
        return {
          _: "inputPeerChannel",
          channelId: id2,
          accessHash: longFromFastString(dto.accessHash)
        };
    }
  }
  class PeersService extends BaseService {
    constructor(options, _peers, _refs, common) {
      var _a2;
      super(common);
      __publicField(this, "_cache");
      __publicField(this, "_pendingWrites", /* @__PURE__ */ new Map());
      this.options = options;
      this._peers = _peers;
      this._refs = _refs;
      this._cache = new LruMap((_a2 = options.cacheSize) != null ? _a2 : 100);
    }
    updatePeersFrom(obj) {
      return __async(this, null, function* () {
        var _a2, _b;
        let count = 0;
        let minCount = 0;
        for(let   peer of getAllPeersFrom(obj)) {
          if (peer.min) {
            minCount += 1;
          }
          count += 1;
          yield this.store(peer);
        }
        if (count > 0) {
          yield (_b = (_a2 = this._driver).save) == null ? void 0 : _b.call(_a2);
          this._log.debug("cached %d peers (%d min)", count, minCount);
          return true;
        }
        return false;
      });
    }
    store(peer) {
      return __async(this, null, function* () {
        var _a2, _b;
        let dto;
        let accessHash;
        switch (peer._) {
          case "user": {
            if (!peer.accessHash) {
              this._log.warn("received user without access hash: %j", peer);
              return;
            }
            dto = {
              id: peer.id,
              accessHash: longToFastString(peer.accessHash),
              isMin: peer.min && !(peer.phone !== void 0 && peer.phone.length === 0),
              phone: peer.phone,
              usernames: extractUsernames(peer),
              updated: Date.now(),
              complete: this._serializeTl(peer)
            };
            accessHash = peer.accessHash;
            break;
          }
          case "chat":
          case "chatForbidden": {
            dto = {
              id: -peer.id,
              accessHash: "",
              isMin: false,
              // chats can't be "min"
              updated: Date.now(),
              complete: this._serializeTl(peer),
              usernames: []
            };
            accessHash = Long.ZERO;
            break;
          }
          case "channel":
          case "channelForbidden": {
            if (!peer.accessHash) {
              this._log.warn("received channel without access hash: %j", peer);
              return;
            }
            dto = {
              id: toggleChannelIdMark(peer.id),
              accessHash: longToFastString(peer.accessHash),
              isMin: peer._ === "channel" ? peer.min : false,
              usernames: extractUsernames(peer),
              updated: Date.now(),
              complete: this._serializeTl(peer)
            };
            accessHash = peer.accessHash;
            break;
          }
          default:
            return;
        }
        const cached = this._cache.get(peer.id);
        if (cached && this.options.updatesWriteInterval !== 0) {
          const oldAccessHash = cached.peer.accessHash;
          if (oldAccessHash == null ? void 0 : oldAccessHash.eq(accessHash)) {
            this._pendingWrites.set(peer.id, dto);
            cached.complete = peer;
            return;
          }
        }
        let newComplete = peer;
        if (peer.min) {
          const existing = (_b = (_a2 = this._cache.get(peer.id)) == null ? void 0 : _a2.complete) != null ? _b : yield this.getCompleteById(peer.id);
          if (existing && !existing.min) {
            if (existing._ === "channel" && peer._ === "channel") {
              newComplete = __spreadProps(__spreadValues({}, existing), {
                title: peer.title,
                megagroup: peer.megagroup,
                color: peer.color,
                photo: peer.photo,
                username: peer.username,
                usernames: peer.usernames,
                hasGeo: peer.hasGeo,
                noforwards: peer.noforwards,
                emojiStatus: peer.emojiStatus,
                hasLink: peer.hasLink,
                slowmodeEnabled: peer.slowmodeEnabled,
                scam: peer.scam,
                fake: peer.fake,
                gigagroup: peer.gigagroup,
                forum: peer.forum,
                level: peer.level,
                restricted: peer.restricted,
                restrictionReason: peer.restrictionReason,
                joinToSend: peer.joinToSend,
                joinRequest: peer.joinRequest,
                verified: peer.verified,
                defaultBannedRights: peer.defaultBannedRights
              });
            } else if (existing._ === "user" && peer._ === "user") {
              newComplete = __spreadProps(__spreadValues({}, existing), {
                deleted: peer.deleted,
                bot: peer.bot,
                botChatHistory: peer.botChatHistory,
                botNochats: peer.botNochats,
                verified: peer.verified,
                restricted: peer.restricted,
                botInlineGeo: peer.botInlineGeo,
                support: peer.support,
                scam: peer.scam,
                fake: peer.fake,
                botAttachMenu: peer.botAttachMenu,
                premium: peer.premium,
                storiesUnavailable: peer.storiesUnavailable,
                contactRequirePremium: peer.contactRequirePremium,
                botBusiness: peer.botBusiness,
                botHasMainApp: peer.botHasMainApp,
                photo: peer.applyMinPhoto ? peer.photo : existing.photo,
                status: !existing.status || existing.status._ === "userStatusEmpty" ? peer.status : existing.status,
                botInfoVersion: peer.botInfoVersion,
                restrictionReason: peer.restrictionReason,
                botInlinePlaceholder: peer.botInlinePlaceholder,
                langCode: peer.langCode,
                emojiStatus: peer.emojiStatus,
                color: peer.color,
                profileColor: peer.profileColor,
                botActiveUsers: peer.botActiveUsers
              });
            }
          }
        }
        yield this._peers.store(dto);
        this._cache.set(peer.id, {
          peer: getInputPeer(dto),
          complete: newComplete
        });
        yield this._refs.deleteByPeer(peer.id);
      });
    }
    _returnCaching(id2, dto) {
      const peer = getInputPeer(dto);
      const complete = this._deserializeTl(dto.complete);
      this._cache.set(id2, {
        peer,
        complete
      });
      return peer;
    }
    getById(id2, allowRefs = true) {
      return __async(this, null, function* () {
        const cached = this._cache.get(id2);
        if (cached)
          return cached.peer;
        const dto = yield this._peers.getById(id2, false);
        if (dto) {
          return this._returnCaching(id2, dto);
        }
        if (allowRefs) {
          const ref = yield this._refs.getForPeer(id2);
          if (!ref)
            return null;
          const [chatId, msgId] = ref;
          const chat = yield this.getById(chatId, false);
          if (!chat)
            return null;
          if (id2 > 0) {
            return {
              _: "inputPeerUserFromMessage",
              peer: chat,
              msgId,
              userId: id2
            };
          }
          return {
            _: "inputPeerChannelFromMessage",
            peer: chat,
            msgId,
            channelId: toggleChannelIdMark(id2)
          };
        }
        return null;
      });
    }
    getByPhone(phone) {
      return __async(this, null, function* () {
        const dto = yield this._peers.getByPhone(phone);
        if (!dto)
          return null;
        return this._returnCaching(dto.id, dto);
      });
    }
    getByUsername(username) {
      return __async(this, null, function* () {
        const dto = yield this._peers.getByUsername(username.toLowerCase());
        if (!dto)
          return null;
        if (Date.now() - dto.updated > USERNAME_TTL) {
          return null;
        }
        return this._returnCaching(dto.id, dto);
      });
    }
    getCompleteById(id2, allowMin = false) {
      return __async(this, null, function* () {
        const cached = this._cache.get(id2);
        if (cached)
          return cached.complete;
        const dto = yield this._peers.getById(id2, allowMin);
        if (!dto)
          return null;
        const cacheItem = {
          peer: getInputPeer(dto),
          complete: this._deserializeTl(dto.complete)
        };
        this._cache.set(id2, cacheItem);
        return cacheItem.complete;
      });
    }
  }
  class RefMessagesService extends BaseService {
    constructor(options, _refs, common) {
      var _a2;
      super(common);
      __publicField(this, "_cache");
      this.options = options;
      this._refs = _refs;
      this._cache = new LruMap((_a2 = options.cacheSize) != null ? _a2 : 1e3);
    }
    store(peerId, chatId, msgId) {
      return __async(this, null, function* () {
        yield this._refs.store(peerId, chatId, msgId);
        this._cache.set(peerId, [chatId, msgId]);
      });
    }
    getForPeer(peerId) {
      return __async(this, null, function* () {
        const cached = this._cache.get(peerId);
        if (cached)
          return cached;
        const ref = yield this._refs.getByPeer(peerId);
        if (ref)
          this._cache.set(peerId, ref);
        return ref;
      });
    }
    delete(chatId, msgIds) {
      return __async(this, null, function* () {
        yield this._refs.delete(chatId, msgIds);
        this._cache.clear();
      });
    }
    deleteByPeer(peerId) {
      return __async(this, null, function* () {
        yield this._refs.deleteByPeer(peerId);
        this._cache.delete(peerId);
      });
    }
  }
  class TelegramStorageManager {
    constructor(mt, options) {
      __publicField(this, "provider");
      __publicField(this, "updates");
      __publicField(this, "self");
      __publicField(this, "refMsgs");
      __publicField(this, "peers");
      var _a2, _b;
      this.mt = mt;
      this.options = options;
      this.provider = this.options.provider;
      const serviceOptions = {
        driver: this.mt.driver,
        readerMap: this.mt.options.readerMap,
        writerMap: this.mt.options.writerMap,
        log: this.mt.log
      };
      this.updates = new UpdatesStateService(this.provider.kv, serviceOptions);
      this.self = new CurrentUserService(this.provider.kv, serviceOptions);
      this.refMsgs = new RefMessagesService(
        (_a2 = this.options.refMessages) != null ? _a2 : {},
        this.provider.refMessages,
        serviceOptions
      );
      this.peers = new PeersService(
        (_b = this.options.peers) != null ? _b : {},
        this.provider.peers,
        this.refMsgs,
        serviceOptions
      );
    }
    clear(withAuthKeys = false) {
      return __async(this, null, function* () {
        yield this.provider.peers.deleteAll();
        yield this.provider.refMessages.deleteAll();
        yield this.mt.clear(withAuthKeys);
      });
    }
  }
  const ERROR_MSG = "Given peer is not available in this index. This is most likely an internal library error.";
  class PeersIndex {
    constructor(users = /* @__PURE__ */ new Map(), chats = /* @__PURE__ */ new Map()) {
      __publicField(this, "hasMin", false);
      this.users = users;
      this.chats = chats;
    }
    static from(obj) {
      var _a2, _b;
      const index = new PeersIndex();
      (_a2 = obj.users) == null ? void 0 : _a2.forEach((user) => {
        index.users.set(user.id, user);
        if (user.min) {
          index.hasMin = true;
        }
      });
      (_b = obj.chats) == null ? void 0 : _b.forEach((chat) => {
        index.chats.set(chat.id, chat);
        if (chat.min) {
          index.hasMin = true;
        }
      });
      return index;
    }
    get empty() {
      return this.users.size === 0 && this.chats.size === 0;
    }
    user(id2) {
      const r = this.users.get(id2);
      if (!r) {
        throw new MtArgumentError(ERROR_MSG);
      }
      return r;
    }
    chat(id2) {
      const r = this.chats.get(id2);
      if (!r) {
        throw new MtArgumentError(ERROR_MSG);
      }
      return r;
    }
    get(peer) {
      switch (peer._) {
        case "peerUser":
          return this.user(peer.userId);
        case "peerChat":
          return this.chat(peer.chatId);
        case "peerChannel":
          return this.chat(peer.channelId);
      }
    }
  }
  function batchedQuery(params) {
    const { inputKey, outputKey, fetch: fetch2, maxBatchSize = Infinity, maxConcurrent = 1, retrySingleOnError } = params;
    const symbol = Symbol("batchedQueryState");
    function getState(client_) {
      const client = client_;
      if (!client[symbol]) {
        client[symbol] = {
          waiters: /* @__PURE__ */ new Map(),
          fetchingKeys: /* @__PURE__ */ new Set(),
          retryQueue: new Deque(),
          numRunning: 0
        };
      }
      return client[symbol];
    }
    function addWaiter(client, waiters, item) {
      const key = inputKey(item, client);
      let arr = waiters.get(key);
      if (!arr) {
        arr = [];
        waiters.set(key, arr);
      }
      return new Promise((resolve, reject) => {
        arr.push([item, resolve, reject]);
      });
    }
    function popWaiters(waiters, key) {
      const arr = waiters.get(key);
      if (!arr)
        return [];
      waiters.delete(key);
      return arr;
    }
    function startLoops(client, state) {
      for (let i = state.numRunning; i <= maxConcurrent; i++) {
        processPending(client, state);
      }
    }
    function processPending(client, state) {
      const { waiters, fetchingKeys, retryQueue } = state;
      if (state.numRunning >= maxConcurrent)
        return;
      const request = [];
      const requestKeys = [];
      let isRetryRequest = false;
      if (retryQueue.length > 0) {
        isRetryRequest = true;
        const it = retryQueue.popFront();
        request.push(it);
        const key = inputKey(it, client);
        requestKeys.push(key);
        fetchingKeys.add(key);
      } else {
        for(let   it of waiters.keys()) {
          if (fetchingKeys.has(it))
            continue;
          request.push(waiters.get(it)[0][0]);
          requestKeys.push(it);
          fetchingKeys.add(it);
          if (request.length === maxBatchSize)
            break;
        }
        if (request.length === 0)
          return;
      }
      state.numRunning += 1;
      fetch2(client, request).then((res) => {
        const receivedKeys = /* @__PURE__ */ new Set();
        for(let   it of res) {
          const key = outputKey(it, client);
          receivedKeys.add(key);
          for(let   waiter of popWaiters(waiters, key)) {
            waiter[1](it);
          }
          fetchingKeys.delete(key);
        }
        for(let   key of requestKeys) {
          if (!receivedKeys.has(key)) {
            for(let   waiter of popWaiters(waiters, key)) {
              waiter[1](null);
            }
            fetchingKeys.delete(key);
          }
        }
      }).catch((err2) => {
        if (retrySingleOnError && !isRetryRequest) {
          const retry = retrySingleOnError(request, err2);
          if (retry === true) {
            for(let   it of request) {
              retryQueue.pushBack(it);
            }
            return;
          } else if (Array.isArray(retry)) {
            for(let   req of retry) {
              const requestKeysIdx = request.indexOf(req);
              if (requestKeysIdx < 0)
                continue;
              retryQueue.pushBack(req);
              request.splice(requestKeysIdx, 1);
              requestKeys.splice(requestKeysIdx, 1);
            }
          }
        }
        for(let   key of requestKeys) {
          for(let   waiter of popWaiters(waiters, key)) {
            waiter[2](err2);
          }
          fetchingKeys.delete(key);
        }
      }).then(() => {
        state.numRunning -= 1;
        if (waiters.size > 0)
          processPending(client, state);
      });
    }
    return function(client, item) {
      const state = getState(client);
      const promise = addWaiter(client, state.waiters, item);
      startLoops(client, state);
      return promise;
    };
  }
  const _getUsersBatched = batchedQuery({
    fetch: (client, items) => client.call({
      _: "users.getUsers",
      id: items
      // there's actually not much point in filtering, since telegram currently simply omits the missing users
      // but maybe it will change in the future and i don't want to think about it
    }).then((res) => res.filter((it) => it._ !== "userEmpty")),
    inputKey: (item, client) => {
      switch (item._) {
        case "inputUser":
        case "inputUserFromMessage":
          return item.userId;
        case "inputUserSelf":
          return client.storage.self.getCached().userId;
        default:
          throw new MtArgumentError("Invalid input user");
      }
    },
    outputKey: (item) => item.id,
    maxBatchSize: 50,
    maxConcurrent: 3,
    retrySingleOnError: (items, err2) => {
      if (!tl.tl.RpcError.is(err2))
        return false;
      let fromMessageCount = 0;
      for(let   item of items) {
        if (item._ === "inputUserFromMessage")
          fromMessageCount++;
      }
      if (fromMessageCount === 0) {
        return false;
      }
      switch (err2.text) {
        case "CHANNEL_INVALID":
        case "USER_BANNED_IN_CHANNEL":
        case "CHANNEL_PRIVATE":
        case "MSG_ID_INVALID":
          return true;
        default:
          return false;
      }
    }
  });
  const _getChatsBatched = batchedQuery({
    fetch: (client, items) => client.call({
      _: "messages.getChats",
      id: items
    }).then((res) => res.chats.filter((it) => it._ === "chat")),
    inputKey: (id2) => id2,
    outputKey: (item) => item.id,
    maxBatchSize: 50,
    maxConcurrent: 3
  });
  const _getChannelsBatched = batchedQuery({
    fetch: (client, items) => client.call({
      _: "channels.getChannels",
      id: items
    }).then(
      (res) => res.chats.filter(
        (it) => it._ === "channel" || it._ === "channelForbidden"
      )
    ),
    inputKey: (id2) => {
      switch (id2._) {
        case "inputChannel":
        case "inputChannelFromMessage":
          return id2.channelId;
        default:
          throw new MtArgumentError("Invalid input channel");
      }
    },
    outputKey: (item) => item.id,
    maxBatchSize: 50,
    maxConcurrent: 3,
    retrySingleOnError: (items, err2) => {
      if (!tl.tl.RpcError.is(err2))
        return false;
      let fromMessageCount = 0;
      for(let   item of items) {
        if (item._ === "inputChannelFromMessage")
          fromMessageCount++;
      }
      if (fromMessageCount === 0) {
        return false;
      }
      switch (err2.text) {
        case "CHANNEL_INVALID":
        case "USER_BANNED_IN_CHANNEL":
        case "CHANNEL_PRIVATE":
        case "MSG_ID_INVALID":
          return true;
        default:
          return false;
      }
    }
  });
  function _getRawPeerBatched(client, peer) {
    if (isInputPeerUser(peer)) {
      return _getUsersBatched(client, toInputUser(peer));
    } else if (isInputPeerChannel(peer)) {
      return _getChannelsBatched(client, toInputChannel(peer));
    } else if (isInputPeerChat(peer)) {
      return _getChatsBatched(client, peer.chatId);
    }
    throw new MtArgumentError("Invalid peer");
  }
  function messageToUpdate(message2) {
    switch (message2.peerId._) {
      case "peerUser":
      case "peerChat":
        return {
          _: "updateNewMessage",
          message: message2,
          pts: 0,
          ptsCount: 0
        };
      case "peerChannel":
        return {
          _: "updateNewChannelMessage",
          message: message2,
          pts: 0,
          ptsCount: 0
        };
    }
  }
  function extractChannelIdFromUpdate(upd) {
    let res = 0;
    if ("channelId" in upd) {
      res = upd.channelId;
    } else if ("message" in upd && typeof upd.message !== "string" && "peerId" in upd.message && upd.message.peerId && "channelId" in upd.message.peerId) {
      res = upd.message.peerId.channelId;
    }
    if (res === 0)
      return void 0;
    return res;
  }
  function toPendingUpdate(upd, peers, fromDifference = false) {
    const channelId = extractChannelIdFromUpdate(upd) || 0;
    const pts = "pts" in upd ? upd.pts : void 0;
    const ptsCount = "ptsCount" in upd ? upd.ptsCount : pts ? 0 : void 0;
    const qts = "qts" in upd ? upd.qts : void 0;
    return {
      update: upd,
      channelId,
      pts,
      ptsBefore: pts ? pts - ptsCount : void 0,
      qts,
      qtsBefore: qts ? qts - 1 : void 0,
      peers,
      fromDifference
    };
  }
  function isMessageEmpty(upd) {
    var _a2;
    return ((_a2 = upd.message) == null ? void 0 : _a2._) === "messageEmpty";
  }
  function createDummyUpdatesContainer(updates, seq = 0) {
    return {
      _: "updates",
      seq,
      date: 0,
      chats: [],
      users: [],
      updates
    };
  }
  function createDummyUpdate(pts, ptsCount, channelId = 0) {
    return createDummyUpdatesContainer([
      {
        _: "mtcute.dummyUpdate",
        channelId,
        pts,
        ptsCount
      }
    ]);
  }
  function assertIsUpdatesGroup(ctx, upd) {
    switch (upd._) {
      case "updates":
      case "updatesCombined":
        return;
    }
    throw new MtTypeAssertionError(ctx, "updates | updatesCombined", upd._);
  }
  const KEEP_ALIVE_INTERVAL = 15 * 60 * 1e3;
  const UPDATES_TOO_LONG = { _: "updatesTooLong" };
  class UpdatesManager {
    constructor(client, params = {}) {
      __publicField(this, "updatesLoopActive", false);
      __publicField(this, "updatesLoopCv", new ConditionVariable());
      __publicField(this, "postponedTimer", new EarlyTimer());
      __publicField(this, "hasTimedoutPostponed", false);
      __publicField(this, "pendingUpdateContainers", new SortedLinkedList((a, b) => a.seqStart - b.seqStart));
      __publicField(this, "pendingPtsUpdates", new SortedLinkedList((a, b) => a.ptsBefore - b.ptsBefore));
      __publicField(this, "pendingPtsUpdatesPostponed", new SortedLinkedList((a, b) => a.ptsBefore - b.ptsBefore));
      __publicField(this, "pendingQtsUpdates", new SortedLinkedList((a, b) => a.qtsBefore - b.qtsBefore));
      __publicField(this, "pendingQtsUpdatesPostponed", new SortedLinkedList((a, b) => a.qtsBefore - b.qtsBefore));
      __publicField(this, "pendingUnorderedUpdates", new Deque());
      __publicField(this, "noDispatchEnabled");
      // channel id or 0 => msg id
      __publicField(this, "noDispatchMsg", /* @__PURE__ */ new Map());
      // channel id or 0 => pts
      __publicField(this, "noDispatchPts", /* @__PURE__ */ new Map());
      __publicField(this, "noDispatchQts", /* @__PURE__ */ new Set());
      __publicField(this, "lock", new AsyncLock());
      // rpsIncoming?: RpsMeter
      // rpsProcessing?: RpsMeter
      // accessing storage every time might be expensive,
      // so store everything here, and load & save
      // every time session is loaded & saved.
      __publicField(this, "pts");
      __publicField(this, "qts");
      __publicField(this, "date");
      __publicField(this, "seq");
      // old values of the updates state (i.e. as in DB)
      // used to avoid redundant storage calls
      __publicField(this, "oldPts");
      __publicField(this, "oldQts");
      __publicField(this, "oldDate");
      __publicField(this, "oldSeq");
      // whether to catch up channels from the locally stored pts
      __publicField(this, "catchingUp", false);
      __publicField(this, "catchUpOnStart");
      __publicField(this, "cpts", /* @__PURE__ */ new Map());
      __publicField(this, "cptsMod", /* @__PURE__ */ new Map());
      __publicField(this, "channelDiffTimeouts", /* @__PURE__ */ new Map());
      __publicField(this, "channelsOpened", /* @__PURE__ */ new Map());
      __publicField(this, "log");
      __publicField(this, "_handler", () => {
      });
      __publicField(this, "_onCatchingUp", () => {
      });
      // eslint-disable-next-line ts/no-unsafe-function-type
      __publicField(this, "_channelPtsLimit");
      __publicField(this, "auth");
      // todo: do we need a local copy?
      __publicField(this, "keepAliveInterval");
      var _a2;
      this.client = client;
      this.params = params;
      if (client.params.disableUpdates) {
        throw new MtArgumentError("Updates must be enabled to use updates manager");
      }
      this._onKeepAlive = this._onKeepAlive.bind(this);
      this.postponedTimer.onTimeout(() => {
        this.hasTimedoutPostponed = true;
        this.updatesLoopCv.notify();
      });
      this.log = client.log.create("updates");
      this.catchUpOnStart = (_a2 = params.catchUp) != null ? _a2 : false;
      this.noDispatchEnabled = !params.disableNoDispatch;
      if (params.channelPtsLimit) {
        if (typeof params.channelPtsLimit === "function") {
          this._channelPtsLimit = params.channelPtsLimit;
        } else {
          const limit = params.channelPtsLimit;
          this._channelPtsLimit = () => limit;
        }
      } else {
        this._channelPtsLimit = () => {
          var _a3;
          return ((_a3 = this.auth) == null ? void 0 : _a3.isBot) ? 1e5 : 100;
        };
      }
    }
    setHandler(handler) {
      this._handler = handler;
    }
    getHandler() {
      return this._handler;
    }
    onCatchingUp(handler) {
      this._onCatchingUp = handler;
    }
    destroy() {
      this.stopLoop();
    }
    notifyLoggedIn(self2) {
      this.auth = self2;
      this.startLoop().catch((err2) => this.client.emitError(err2));
    }
    notifyLoggedOut() {
      this.stopLoop();
      this.cpts.clear();
      this.cptsMod.clear();
      this.pts = this.qts = this.date = this.seq = void 0;
    }
    prepare() {
      return __async(this, null, function* () {
        yield this._loadUpdatesStorage();
      });
    }
    _onKeepAlive() {
      this.log.debug("no updates for >15 minutes, catching up");
      this.handleUpdate(UPDATES_TOO_LONG);
    }
    /**
     * Start updates loop.
     *
     * You must first call {@link enableUpdatesProcessing} to use this method.
     *
     * It is recommended to use this method in callback to {@link start},
     * or otherwise make sure the user is logged in.
     *
     * > **Note**: If you are using {@link UpdatesManagerParams.catchUp} option,
     * > catching up will be done in background, you can't await it.
     * > Instead, listen for the `updating` and `connected` connection state events.
     */
    startLoop() {
      return __async(this, null, function* () {
        if (this.updatesLoopActive)
          return;
        if (!this.catchUpOnStart) {
          yield this._fetchUpdatesState();
        }
        this.updatesLoopActive = true;
        clearIntervalWrap(this.keepAliveInterval);
        this.keepAliveInterval = setIntervalWrap(this._onKeepAlive, KEEP_ALIVE_INTERVAL);
        this._loop().catch((err2) => this.client.emitError(err2));
        if (this.catchUpOnStart) {
          this.catchUp();
        }
      });
    }
    /**
     * **ADVANCED**
     *
     * Manually stop updates loop.
     * Usually done automatically when stopping the client with {@link close}
     */
    stopLoop() {
      if (!this.updatesLoopActive)
        return;
      clearIntervalWrap(this.keepAliveInterval);
      for(let   timer of this.channelDiffTimeouts.values()) {
        clearTimeoutWrap(timer);
      }
      this.channelDiffTimeouts.clear();
      this.updatesLoopActive = false;
      this.pendingUpdateContainers.clear();
      this.pendingUnorderedUpdates.clear();
      this.pendingPtsUpdates.clear();
      this.pendingQtsUpdates.clear();
      this.pendingPtsUpdatesPostponed.clear();
      this.pendingQtsUpdatesPostponed.clear();
      this.postponedTimer.reset();
      this.updatesLoopCv.notify();
    }
    /**
     * Catch up with the server by loading missed updates.
     *.
     * > **Note**: In case the storage was not properly
     * > closed the last time, "catching up" might
     * > result in duplicate updates.
     */
    catchUp() {
      if (!this.updatesLoopActive) {
        this.log.warn("catch up requested, but updates loop is not active, ignoring");
        return;
      }
      this.log.debug("catch up requested");
      this._onCatchingUp(true);
      this.catchingUp = true;
      this.handleUpdate(UPDATES_TOO_LONG);
    }
    handleClientUpdate(update, noDispatch = true) {
      if (noDispatch && this.noDispatchEnabled) {
        this._addToNoDispatchIndex(update);
      }
      this.handleUpdate(update);
    }
    handleUpdate(update) {
      this.log.debug(
        "received %s, queueing for processing. containers queue size: %d",
        update._,
        this.pendingUpdateContainers.length
      );
      switch (update._) {
        case "updatesTooLong":
        case "updateShortMessage":
        case "updateShortChatMessage":
        case "updateShort":
        case "updateShortSentMessage":
          this.pendingUpdateContainers.add({
            upd: update,
            seqStart: 0,
            seqEnd: 0
          });
          break;
        case "updates":
        case "updatesCombined":
          this.pendingUpdateContainers.add({
            upd: update,
            seqStart: update._ === "updatesCombined" ? update.seqStart : update.seq,
            seqEnd: update.seq
          });
          break;
        default:
          assertNever$1();
      }
      this.updatesLoopCv.notify();
    }
    /**
     * **ADVANCED**
     *
     * Notify the updates manager that some channel was "opened".
     * Channel difference for "opened" channels will be fetched on a regular basis.
     * This is a low-level method, prefer using {@link openChat} instead.
     *
     * Channel must be resolve-able with `resolvePeer` method (i.e. be in cache);
     * base chat PTS must either be passed (e.g. from {@link Dialog}), or cached in storage.
     *
     * @param channelId  Bare ID of the channel
     * @param pts  PTS of the channel, if known (e.g. from {@link Dialog})
     * @returns `true` if the channel was opened for the first time, `false` if it is already opened
     */
    notifyChannelOpened(channelId, pts) {
      if (this.channelsOpened.has(channelId)) {
        this.log.debug("channel %d opened again", channelId);
        this.channelsOpened.set(channelId, this.channelsOpened.get(channelId) + 1);
        return false;
      }
      this.channelsOpened.set(channelId, 1);
      this.log.debug("channel %d opened (pts=%d)", channelId, pts);
      this._fetchChannelDifferenceViaUpdate(channelId, pts);
      return true;
    }
    /**
     * **ADVANCED**
     *
     * Notify the updates manager that some channel was "closed".
     * Basically the opposite of {@link notifyChannelOpened}.
     * This is a low-level method, prefer using {@link closeChat} instead.
     *
     * @param channelId  Bare channel ID
     * @returns `true` if the chat was closed for the last time, `false` otherwise
     */
    notifyChannelClosed(channelId) {
      const opened = this.channelsOpened.get(channelId);
      if (opened === void 0) {
        return false;
      }
      if (opened > 1) {
        this.log.debug("channel %d closed, but is opened %d more times", channelId, opened - 1);
        this.channelsOpened.set(channelId, opened - 1);
        return false;
      }
      this.channelsOpened.delete(channelId);
      this.log.debug("channel %d closed", channelId);
      return true;
    }
    /// /////////////////////////////////////////// IMPLEMENTATION //////////////////////////////////////////////
    _fetchUpdatesState() {
      return __async(this, null, function* () {
        const { client, lock, log } = this;
        yield lock.acquire();
        log.debug("fetching initial state");
        try {
          let fetchedState = yield client.call({ _: "updates.getState" });
          log.debug(
            "updates.getState returned state: pts=%d, qts=%d, date=%d, seq=%d",
            fetchedState.pts,
            fetchedState.qts,
            fetchedState.date,
            fetchedState.seq
          );
          const diff = yield client.call({
            _: "updates.getDifference",
            pts: fetchedState.pts,
            qts: fetchedState.qts,
            date: fetchedState.date
          });
          switch (diff._) {
            case "updates.differenceEmpty":
              break;
            case "updates.differenceTooLong":
              fetchedState.pts = diff.pts;
              break;
            case "updates.differenceSlice":
              fetchedState = diff.intermediateState;
              break;
            case "updates.difference":
              fetchedState = diff.state;
              break;
            default:
              assertNever$1(diff);
          }
          this.qts = fetchedState.qts;
          this.pts = fetchedState.pts;
          this.date = fetchedState.date;
          this.seq = fetchedState.seq;
          log.debug("loaded initial state: pts=%d, qts=%d, date=%d, seq=%d", this.pts, this.qts, this.date, this.seq);
        } catch (e) {
          if (tl.tl.RpcError.is(e, "AUTH_KEY_UNREGISTERED")) {
            lock.release();
            this.stopLoop();
            return;
          }
          if (this.client.isConnected) {
            log.error("failed to fetch updates state: %s", e);
          }
          lock.release();
          throw e;
        }
        lock.release();
      });
    }
    _loadUpdatesStorage() {
      return __async(this, null, function* () {
        const storedState = yield this.client.storage.updates.getState();
        if (storedState) {
          this.pts = this.oldPts = storedState[0];
          this.qts = this.oldQts = storedState[1];
          this.date = this.oldDate = storedState[2];
          this.seq = this.oldSeq = storedState[3];
          this.log.debug(
            "loaded stored state: pts=%d, qts=%d, date=%d, seq=%d",
            storedState[0],
            storedState[1],
            storedState[2],
            storedState[3]
          );
        }
      });
    }
    _saveUpdatesStorage(save = false) {
      return __async(this, null, function* () {
        const { client } = this;
        if (this.pts !== void 0) {
          if (this.oldPts === void 0 || this.oldPts !== this.pts) {
            yield client.storage.updates.setPts(this.pts);
          }
          if (this.oldQts === void 0 || this.oldQts !== this.qts) {
            yield client.storage.updates.setQts(this.qts);
          }
          if (this.oldDate === void 0 || this.oldDate !== this.date) {
            yield client.storage.updates.setDate(this.date);
          }
          if (this.oldSeq === void 0 || this.oldSeq !== this.seq) {
            yield client.storage.updates.setSeq(this.seq);
          }
          this.oldPts = this.pts;
          this.oldQts = this.qts;
          this.oldDate = this.date;
          this.oldSeq = this.seq;
          yield client.storage.updates.setManyChannelPts(this.cptsMod);
          this.cptsMod.clear();
          if (save) {
            yield client.mt.storage.save();
          }
        }
      });
    }
    _addToNoDispatchIndex(updates) {
      if (!updates)
        return;
      const { noDispatchMsg, noDispatchPts, noDispatchQts } = this;
      const addUpdate = (upd) => {
        var _a2, _b;
        const channelId = (_a2 = extractChannelIdFromUpdate(upd)) != null ? _a2 : 0;
        const pts = "pts" in upd ? upd.pts : void 0;
        if (pts) {
          const set2 = noDispatchPts.get(channelId);
          if (!set2)
            noDispatchPts.set(channelId, /* @__PURE__ */ new Set([pts]));
          else
            set2.add(pts);
        }
        const qts = "qts" in upd ? upd.qts : void 0;
        if (qts) {
          noDispatchQts.add(qts);
        }
        switch (upd._) {
          case "updateNewMessage":
          case "updateNewChannelMessage":
          case "updateBotNewBusinessMessage": {
            const channelId2 = ((_b = upd.message.peerId) == null ? void 0 : _b._) === "peerChannel" ? upd.message.peerId.channelId : 0;
            const set2 = noDispatchMsg.get(channelId2);
            if (!set2)
              noDispatchMsg.set(channelId2, /* @__PURE__ */ new Set([upd.message.id]));
            else
              set2.add(upd.message.id);
            break;
          }
        }
      };
      switch (updates._) {
        case "updates":
        case "updatesCombined":
          updates.updates.forEach(addUpdate);
          break;
        case "updateShortMessage":
        case "updateShortChatMessage":
        case "updateShortSentMessage": {
          let set2 = noDispatchMsg.get(0);
          if (!set2)
            noDispatchMsg.set(0, /* @__PURE__ */ new Set([updates.id]));
          else
            set2.add(updates.id);
          set2 = noDispatchPts.get(0);
          if (!set2)
            noDispatchPts.set(0, /* @__PURE__ */ new Set([updates.pts]));
          else
            set2.add(updates.pts);
          break;
        }
        case "updateShort":
          addUpdate(updates.update);
          break;
        case "updatesTooLong":
          break;
        default:
          assertNever$1();
      }
    }
    _fetchMissingPeers(upd, peers, fromDifference = false) {
      return __async(this, null, function* () {
        const { client, log } = this;
        const missing = /* @__PURE__ */ new Set();
        function fetchPeer(peer, allowZeroHash = false) {
          return __async(this, null, function* () {
            if (!peer)
              return true;
            const bare = typeof peer === "number" ? parseMarkedPeerId(peer)[1] : getBarePeerId(peer);
            const marked = typeof peer === "number" ? peer : getMarkedPeerId(peer);
            const index = marked > 0 ? peers.users : peers.chats;
            const fromIndex = index.get(bare);
            if (fromIndex && !fromIndex.min)
              return true;
            if (missing.has(marked))
              return false;
            const cached = yield client.storage.peers.getCompleteById(marked);
            if (!cached) {
              if (fromDifference && allowZeroHash && parseMarkedPeerId(marked)[0] === "channel") {
                log.debug("trying to fetch peer %d with zero access hash", marked);
                const fetched = yield _getChannelsBatched(client, {
                  _: "inputChannel",
                  channelId: bare,
                  accessHash: Long.ZERO
                });
                if ((fetched == null ? void 0 : fetched._) === "channel" && !fetched.min) {
                  index.set(bare, fetched);
                  return true;
                }
              }
              missing.add(marked);
              return fromDifference;
            }
            index.set(bare, cached);
            return true;
          });
        }
        switch (upd._) {
          case "updateNewMessage":
          case "updateNewChannelMessage":
          case "updateEditMessage":
          case "updateEditChannelMessage": {
            const msg = upd.message;
            if (msg._ === "messageEmpty")
              return missing;
            if (!(yield fetchPeer(msg.peerId, true)))
              return missing;
            if (!(yield fetchPeer(msg.fromId)))
              return missing;
            if (msg.replyTo) {
              if (msg.replyTo._ === "messageReplyHeader" && !(yield fetchPeer(msg.replyTo.replyToPeerId))) {
                return missing;
              }
              if (msg.replyTo._ === "messageReplyStoryHeader" && !(yield fetchPeer(msg.replyTo.peer))) {
                return missing;
              }
            }
            if (msg._ !== "messageService") {
              if (msg.fwdFrom && (!(yield fetchPeer(msg.fwdFrom.fromId)) || !(yield fetchPeer(msg.fwdFrom.savedFromPeer, true)))) {
                return missing;
              }
              if (!(yield fetchPeer(msg.viaBotId)))
                return missing;
              if (msg.entities) {
                for(let   ent of msg.entities) {
                  if (ent._ === "messageEntityMentionName") {
                    if (!(yield fetchPeer(ent.userId)))
                      return missing;
                  }
                }
              }
              if (msg.media) {
                switch (msg.media._) {
                  case "messageMediaContact":
                    if (msg.media.userId && !(yield fetchPeer(msg.media.userId))) {
                      return missing;
                    }
                }
              }
            } else {
              switch (msg.action._) {
                case "messageActionChatCreate":
                case "messageActionChatAddUser":
                case "messageActionInviteToGroupCall":
                  for(let   user of msg.action.users) {
                    if (!(yield fetchPeer(user)))
                      return missing;
                  }
                  break;
                case "messageActionChatJoinedByLink":
                  if (!(yield fetchPeer(msg.action.inviterId))) {
                    return missing;
                  }
                  break;
                case "messageActionChatDeleteUser":
                  if (!(yield fetchPeer(msg.action.userId)))
                    return missing;
                  break;
                case "messageActionChatMigrateTo":
                  if (!(yield fetchPeer(toggleChannelIdMark(msg.action.channelId), true))) {
                    return missing;
                  }
                  break;
                case "messageActionChannelMigrateFrom":
                  if (!(yield fetchPeer(-msg.action.chatId)))
                    return missing;
                  break;
                case "messageActionGeoProximityReached":
                  if (!(yield fetchPeer(msg.action.fromId)))
                    return missing;
                  if (!(yield fetchPeer(msg.action.toId)))
                    return missing;
                  break;
              }
            }
            break;
          }
          case "updateDraftMessage":
            if ("entities" in upd.draft && upd.draft.entities) {
              for(let   ent of upd.draft.entities) {
                if (ent._ === "messageEntityMentionName") {
                  if (!(yield fetchPeer(ent.userId)))
                    return missing;
                }
              }
            }
        }
        return missing;
      });
    }
    _storeMessageReferences(msg) {
      return __async(this, null, function* () {
        var _a2, _b;
        if (msg._ === "messageEmpty")
          return;
        const { client } = this;
        const peerId = msg.peerId;
        if (peerId._ !== "peerChannel")
          return;
        const channelId = toggleChannelIdMark(peerId.channelId);
        const promises = [];
        function store2(peer) {
          if (!peer)
            return;
          if (Array.isArray(peer)) {
            peer.forEach(store2);
            return;
          }
          const marked = typeof peer === "number" ? peer : getMarkedPeerId(peer);
          promises.push(client.storage.refMsgs.store(marked, channelId, msg.id));
        }
        store2(msg.fromId);
        if (msg._ === "message") {
          store2(msg.viaBotId);
          store2((_a2 = msg.fwdFrom) == null ? void 0 : _a2.fromId);
          if (msg.media) {
            switch (msg.media._) {
              case "messageMediaWebPage":
                if (msg.media.webpage._ === "webPage" && msg.media.webpage.attributes) {
                  for(let   attr of msg.media.webpage.attributes) {
                    if (attr._ === "webPageAttributeStory") {
                      store2(attr.peer);
                    }
                  }
                }
                break;
              case "messageMediaContact":
                store2(msg.media.userId);
                break;
              case "messageMediaStory":
                store2(msg.media.peer);
                break;
              case "messageMediaGiveaway":
                store2(msg.media.channels.map(toggleChannelIdMark));
                break;
            }
          }
        } else {
          switch (msg.action._) {
            case "messageActionChatCreate":
            case "messageActionChatAddUser":
            case "messageActionInviteToGroupCall":
              store2(msg.action.users);
              break;
            case "messageActionChatDeleteUser":
              store2(msg.action.userId);
              break;
          }
        }
        if (msg.replyTo) {
          switch (msg.replyTo._) {
            case "messageReplyHeader":
              store2(msg.replyTo.replyToPeerId);
              store2((_b = msg.replyTo.replyFrom) == null ? void 0 : _b.fromId);
              break;
            case "messageReplyStoryHeader":
              store2(msg.replyTo.peer);
              break;
          }
        }
        yield Promise.all(promises);
      });
    }
    _fetchChannelDifference(channelId, fallbackPts) {
      return __async(this, null, function* () {
        const { channelDiffTimeouts, cpts, cptsMod, channelsOpened, client, log, pendingUnorderedUpdates } = this;
        if (channelDiffTimeouts.has(channelId)) {
          clearTimeoutWrap(channelDiffTimeouts.get(channelId));
          channelDiffTimeouts.delete(channelId);
        }
        let _pts = cpts.get(channelId);
        if (!_pts && this.catchingUp) {
          _pts = yield client.storage.updates.getChannelPts(channelId);
        }
        if (!_pts)
          _pts = fallbackPts;
        if (!_pts) {
          log.debug("fetchChannelDifference failed for channel %d: base pts not available", channelId);
          return false;
        }
        const channelPeer = yield client.storage.peers.getById(toggleChannelIdMark(channelId));
        if (!channelPeer) {
          log.debug("fetchChannelDifference failed for channel %d: input peer not found", channelId);
          return false;
        }
        const channel = toInputChannel(channelPeer);
        let pts = _pts;
        let limit = this._channelPtsLimit(channelId);
        if (pts <= 0) {
          pts = 1;
          limit = 1;
        }
        let lastTimeout = 0;
        for (; ; ) {
          const diff = yield client.call({
            _: "updates.getChannelDifference",
            force: true,
            // Set to true to skip some possibly unneeded updates and reduce server-side load
            channel,
            pts,
            limit,
            filter: { _: "channelMessagesFilterEmpty" }
          });
          if (diff.timeout) {
            lastTimeout = this.params.overrideOpenChatTimeout ? this.params.overrideOpenChatTimeout(diff) : diff.timeout;
          }
          if (diff._ === "updates.channelDifferenceEmpty") {
            log.debug("getChannelDifference (cid = %d) returned channelDifferenceEmpty", channelId);
            break;
          }
          const peers = PeersIndex.from(diff);
          if (diff._ === "updates.channelDifferenceTooLong") {
            if (diff.dialog._ === "dialog") {
              pts = diff.dialog.pts;
            }
            if (this.params.onChannelTooLong) {
              this.params.onChannelTooLong(channelId, diff);
            } else {
              log.warn(
                "getChannelDifference (cid = %d) returned channelDifferenceTooLong. new pts: %d, recent msgs: %d",
                channelId,
                pts,
                diff.messages.length
              );
              diff.messages.forEach((message2) => {
                log.debug(
                  "processing message %d (%s) from TooLong diff for channel %d",
                  message2.id,
                  message2._,
                  channelId
                );
                if (message2._ === "messageEmpty")
                  return;
                pendingUnorderedUpdates.pushBack(toPendingUpdate(messageToUpdate(message2), peers, true));
              });
            }
            break;
          }
          log.debug(
            "getChannelDifference (cid = %d) returned %d messages, %d updates. new pts: %d, final: %b",
            channelId,
            diff.newMessages.length,
            diff.otherUpdates.length,
            diff.pts,
            diff.final
          );
          diff.newMessages.forEach((message2) => {
            log.debug("processing message %d (%s) from diff for channel %d", message2.id, message2._, channelId);
            if (message2._ === "messageEmpty")
              return;
            pendingUnorderedUpdates.pushBack(toPendingUpdate(messageToUpdate(message2), peers, true));
          });
          diff.otherUpdates.forEach((upd) => {
            const parsed = toPendingUpdate(upd, peers, true);
            log.debug(
              "processing %s from diff for channel %d, pts_before: %d, pts: %d",
              upd._,
              channelId,
              parsed.ptsBefore,
              parsed.pts
            );
            if (isMessageEmpty(upd))
              return;
            pendingUnorderedUpdates.pushBack(parsed);
          });
          pts = diff.pts;
          if (diff.final)
            break;
        }
        cpts.set(channelId, pts);
        cptsMod.set(channelId, pts);
        if (lastTimeout !== 0 && channelsOpened.has(channelId)) {
          log.debug("scheduling next fetch for channel %d in %d seconds", channelId, lastTimeout);
          channelDiffTimeouts.set(
            channelId,
            setTimeoutWrap(() => this._fetchChannelDifferenceViaUpdate(channelId), lastTimeout * 1e3)
          );
        }
        return true;
      });
    }
    _fetchChannelDifferenceLater(requestedDiff, channelId, fallbackPts) {
      if (!requestedDiff.has(channelId)) {
        requestedDiff.set(
          channelId,
          this._fetchChannelDifference(channelId, fallbackPts).catch((err2) => {
            this.log.warn("error fetching difference for %d: %e", channelId, err2);
          }).then((ok) => {
            requestedDiff.delete(channelId);
            if (!ok) {
              this.log.debug("channel difference for %d failed, falling back to common diff", channelId);
              this._fetchDifferenceLater(requestedDiff);
            }
          })
        );
      }
    }
    _fetchChannelDifferenceViaUpdate(channelId, pts) {
      this.handleUpdate(
        createDummyUpdatesContainer([
          {
            _: "updateChannelTooLong",
            channelId,
            pts
          }
        ])
      );
    }
    _fetchDifference(requestedDiff) {
      return __async(this, null, function* () {
        const { client, log, pendingPtsUpdates, pendingUnorderedUpdates } = this;
        const diff = yield client.call({
          _: "updates.getDifference",
          pts: this.pts,
          date: this.date,
          qts: this.qts
        });
        switch (diff._) {
          case "updates.differenceEmpty":
            log.debug("updates.getDifference returned updates.differenceEmpty");
            return;
          case "updates.differenceTooLong":
            this.pts = diff.pts;
            log.debug("updates.getDifference returned updates.differenceTooLong");
            return;
        }
        const fetchedState = diff._ === "updates.difference" ? diff.state : diff.intermediateState;
        log.debug(
          "updates.getDifference returned %d messages, %d updates. new pts: %d, qts: %d, seq: %d, final: %b",
          diff.newMessages.length,
          diff.otherUpdates.length,
          fetchedState.pts,
          fetchedState.qts,
          fetchedState.seq,
          diff._ === "updates.difference"
        );
        const peers = PeersIndex.from(diff);
        diff.newMessages.forEach((message2) => {
          log.debug("processing message %d in %j (%s) from common diff", message2.id, message2.peerId, message2._);
          if (message2._ === "messageEmpty")
            return;
          pendingUnorderedUpdates.pushBack(toPendingUpdate(messageToUpdate(message2), peers, true));
        });
        diff.otherUpdates.forEach((upd) => {
          if (upd._ === "updateChannelTooLong") {
            log.debug(
              "received updateChannelTooLong for channel %d in common diff (pts = %d), fetching diff",
              upd.channelId,
              upd.pts
            );
            this._fetchChannelDifferenceLater(requestedDiff, upd.channelId, upd.pts);
            return;
          }
          if (isMessageEmpty(upd))
            return;
          const parsed = toPendingUpdate(upd, peers, true);
          if (parsed.channelId && parsed.ptsBefore) {
            pendingPtsUpdates.add(parsed);
          } else {
            pendingUnorderedUpdates.pushBack(parsed);
          }
          log.debug(
            "received %s from common diff, cid: %d, pts_before: %d, pts: %d, qts_before: %d",
            upd._,
            parsed.channelId,
            parsed.ptsBefore,
            parsed.pts,
            parsed.qtsBefore
          );
        });
        this.pts = fetchedState.pts;
        this.qts = fetchedState.qts;
        this.seq = fetchedState.seq;
        this.date = fetchedState.date;
        if (diff._ === "updates.difference") {
          return;
        }
        this.handleUpdate(UPDATES_TOO_LONG);
      });
    }
    _fetchDifferenceLater(requestedDiff) {
      if (!requestedDiff.has(0)) {
        requestedDiff.set(
          0,
          this._fetchDifference(requestedDiff).catch((err2) => {
            if (tl.tl.RpcError.is(err2, "AUTH_KEY_UNREGISTERED")) {
              this.stopLoop();
              return;
            }
            this.log.warn("error fetching common difference: %e", err2);
            if (tl.tl.RpcError.is(err2, "PERSISTENT_TIMESTAMP_INVALID")) {
              return this._fetchUpdatesState();
            }
          }).then(() => {
            requestedDiff.delete(0);
          })
        );
      }
    }
    _onUpdate(pending, requestedDiff, postponed = false, unordered = false) {
      return __async(this, null, function* () {
        var _a2, _b, _c, _d, _e, _f;
        const { client, log } = this;
        const upd = pending.update;
        let missing;
        if (pending.peers.hasMin || pending.peers.empty) {
          log.debug("loading missing peers for %s (pts = %d, cid = %d)", upd._, pending.pts, pending.channelId);
          missing = yield this._fetchMissingPeers(upd, pending.peers, pending.fromDifference);
          if (!pending.fromDifference && missing.size) {
            log.debug(
              "fetching difference because some peers were min (%J) and not cached for %s (pts = %d, cid = %d)",
              missing,
              upd._,
              pending.pts,
              pending.channelId
            );
            if (pending.channelId && !(upd._ === "updateNewChannelMessage" && upd.message._ === "messageService")) {
              this._fetchChannelDifferenceLater(requestedDiff, pending.channelId, pending.ptsBefore);
            } else {
              this._fetchDifferenceLater(requestedDiff);
            }
            return;
          }
          if (missing.size) {
            log.debug(
              "peers still missing after fetching difference: %J for %s (pts = %d, cid = %d)",
              missing,
              upd._,
              pending.pts,
              pending.channelId
            );
          }
        }
        if (!unordered) {
          if (pending.pts) {
            const localPts = pending.channelId ? this.cpts.get(pending.channelId) : this.pts;
            if (localPts && pending.ptsBefore !== localPts) {
              log.warn(
                "pts_before does not match local_pts for %s (cid = %d, pts_before = %d, pts = %d, local_pts = %d)",
                upd._,
                pending.channelId,
                pending.ptsBefore,
                pending.pts,
                localPts
              );
            }
            log.debug(
              "applying new pts (cid = %d) because received %s: %d -> %d (before: %d, count: %d) (postponed = %s)",
              pending.channelId,
              upd._,
              localPts,
              pending.pts,
              pending.ptsBefore,
              pending.pts - pending.ptsBefore,
              postponed
            );
            if (pending.channelId) {
              this.cpts.set(pending.channelId, pending.pts);
              this.cptsMod.set(pending.channelId, pending.pts);
            } else {
              this.pts = pending.pts;
            }
          }
          if (pending.qtsBefore) {
            log.debug(
              "applying new qts because received %s: %d -> %d (postponed = %s)",
              upd._,
              this.qts,
              pending.qtsBefore + 1,
              postponed
            );
            this.qts = pending.qts;
          }
        }
        if (isMessageEmpty(upd))
          return;
        switch (upd._) {
          case "mtcute.dummyUpdate":
            return;
          case "updateDcOptions": {
            const config = client.mt.network.config.getNow();
            if (config) {
              client.mt.network.config.setData(__spreadProps(__spreadValues({}, config), {
                dcOptions: upd.dcOptions
              }));
            } else {
              client.mt.network.config.update(true).catch((err2) => client.emitError(err2));
            }
            break;
          }
          case "updateConfig":
            client.mt.network.config.update(true).catch((err2) => client.emitError(err2));
            break;
          case "updateUserName":
            break;
          case "updateDeleteChannelMessages":
            if (!((_a2 = this.auth) == null ? void 0 : _a2.isBot)) {
              yield client.storage.refMsgs.delete(toggleChannelIdMark(upd.channelId), upd.messages);
            }
            break;
          case "updateNewMessage":
          case "updateEditMessage":
          case "updateNewChannelMessage":
          case "updateEditChannelMessage":
            if (!((_b = this.auth) == null ? void 0 : _b.isBot)) {
              yield this._storeMessageReferences(upd.message);
            }
            break;
        }
        if (missing == null ? void 0 : missing.size) {
          if ((_c = this.auth) == null ? void 0 : _c.isBot) {
            this.log.warn(
              "missing peers (%J) after getDifference for %s (pts = %d, cid = %d)",
              missing,
              upd._,
              pending.pts,
              pending.channelId
            );
          } else {
            yield client.mt.storage.save();
            for(let   id2 of missing) {
              Promise.resolve(client.storage.peers.getById(id2)).then((peer) => {
                if (!peer) {
                  this.log.warn("cannot fetch full peer %d - getPeerById returned null", id2);
                  return;
                }
                log.warn("cannot fetch full peer %d - unknown peer type %s", id2, peer._);
              }).catch((err2) => {
                log.warn("error fetching full peer %d: %e", id2, err2);
              });
            }
          }
        }
        if (this.noDispatchEnabled) {
          const channelId = (_d = pending.channelId) != null ? _d : 0;
          const msgId = upd._ === "updateNewMessage" || upd._ === "updateNewChannelMessage" || upd._ === "updateBotNewBusinessMessage" ? upd.message.id : void 0;
          const foundByMsgId = msgId && ((_e = this.noDispatchMsg.get(channelId)) == null ? void 0 : _e.delete(msgId));
          const foundByPts = (_f = this.noDispatchPts.get(channelId)) == null ? void 0 : _f.delete(pending.pts);
          const foundByQts = this.noDispatchQts.delete(pending.qts);
          if (foundByMsgId || foundByPts || foundByQts) {
            log.debug("not dispatching %s because it is in no_dispatch index", upd._);
            return;
          }
        }
        log.debug("dispatching %s (postponed = %s)", upd._, postponed);
        this._handler(upd, pending.peers);
      });
    }
    _loop() {
      return __async(this, null, function* () {
        const {
          log,
          client,
          cpts,
          cptsMod,
          pendingUpdateContainers,
          pendingPtsUpdates,
          pendingPtsUpdatesPostponed,
          pendingQtsUpdates,
          pendingQtsUpdatesPostponed,
          pendingUnorderedUpdates,
          updatesLoopCv,
          postponedTimer
        } = this;
        log.debug("updates loop started, state available? %b", this.pts);
        try {
          if (!this.pts) {
            yield this._fetchUpdatesState();
          }
          while (this.updatesLoopActive) {
            if (!(pendingUpdateContainers.length || pendingPtsUpdates.length || pendingQtsUpdates.length || pendingUnorderedUpdates.length || this.hasTimedoutPostponed)) {
              if (this.catchingUp) {
                this.log.debug("catching up completed");
                this.catchingUp = false;
                this._onCatchingUp(false);
              }
              yield updatesLoopCv.wait();
            }
            if (!this.updatesLoopActive)
              break;
            log.debug(
              "updates loop tick. pending containers: %d, pts: %d, pts_postponed: %d, qts: %d, qts_postponed: %d, unordered: %d",
              pendingUpdateContainers.length,
              pendingPtsUpdates.length,
              pendingPtsUpdatesPostponed.length,
              pendingQtsUpdates.length,
              pendingQtsUpdatesPostponed.length,
              pendingUnorderedUpdates.length
            );
            const requestedDiff = /* @__PURE__ */ new Map();
            this.log.debug("processing pending containers");
            while (pendingUpdateContainers.length) {
              const { upd, seqStart, seqEnd } = pendingUpdateContainers.popFront();
              switch (upd._) {
                case "updatesTooLong":
                  log.debug("received updatesTooLong, fetching difference");
                  this._fetchDifferenceLater(requestedDiff);
                  break;
                case "updatesCombined":
                case "updates": {
                  if (seqStart !== 0) {
                    const nextLocalSeq = this.seq + 1;
                    log.debug(
                      "received seq-ordered %s (seq_start = %d, seq_end = %d, size = %d)",
                      upd._,
                      seqStart,
                      seqEnd,
                      upd.updates.length
                    );
                    if (nextLocalSeq > seqStart) {
                      log.debug(
                        "ignoring updates group because already applied (by seq: exp %d, got %d)",
                        nextLocalSeq,
                        seqStart
                      );
                      continue;
                    }
                    if (nextLocalSeq < seqStart) {
                      log.debug(
                        "fetching difference because gap detected (by seq: exp %d, got %d)",
                        nextLocalSeq,
                        seqStart
                      );
                      this._fetchDifferenceLater(requestedDiff);
                    }
                  } else {
                    log.debug("received %s (size = %d)", upd._, upd.updates.length);
                  }
                  yield client.storage.peers.updatePeersFrom(upd);
                  const peers = PeersIndex.from(upd);
                  for(let   update of upd.updates) {
                    switch (update._) {
                      case "updateChannelTooLong":
                        log.debug(
                          "received updateChannelTooLong for channel %d (pts = %d) in container, fetching diff",
                          update.channelId,
                          update.pts
                        );
                        this._fetchChannelDifferenceLater(requestedDiff, update.channelId, update.pts);
                        continue;
                      case "updatePtsChanged":
                        if (client.mt.network.getPoolSize("main") > 1) {
                          log.debug(
                            "updatePtsChanged received, resetting pts to 1 and fetching difference"
                          );
                          this.pts = 1;
                          this._fetchDifferenceLater(requestedDiff);
                        } else {
                          log.debug("updatePtsChanged received, fetching updates state");
                          yield this._fetchUpdatesState();
                        }
                        continue;
                    }
                    const parsed = toPendingUpdate(update, peers);
                    if (parsed.ptsBefore !== void 0) {
                      pendingPtsUpdates.add(parsed);
                    } else if (parsed.qtsBefore !== void 0) {
                      pendingQtsUpdates.add(parsed);
                    } else {
                      pendingUnorderedUpdates.pushBack(parsed);
                    }
                  }
                  if (seqEnd !== 0 && seqEnd > this.seq) {
                    this.seq = seqEnd;
                    this.date = upd.date;
                  }
                  break;
                }
                case "updateShort": {
                  log.debug("received short %s", upd._);
                  const parsed = toPendingUpdate(upd.update, new PeersIndex());
                  if (parsed.ptsBefore !== void 0) {
                    pendingPtsUpdates.add(parsed);
                  } else if (parsed.qtsBefore !== void 0) {
                    pendingQtsUpdates.add(parsed);
                  } else {
                    pendingUnorderedUpdates.pushBack(parsed);
                  }
                  break;
                }
                case "updateShortMessage": {
                  log.debug("received updateShortMessage");
                  const message2 = {
                    _: "message",
                    out: upd.out,
                    mentioned: upd.mentioned,
                    mediaUnread: upd.mediaUnread,
                    silent: upd.silent,
                    id: upd.id,
                    fromId: {
                      _: "peerUser",
                      userId: upd.out ? this.auth.userId : upd.userId
                    },
                    peerId: {
                      _: "peerUser",
                      userId: upd.userId
                    },
                    fwdFrom: upd.fwdFrom,
                    viaBotId: upd.viaBotId,
                    replyTo: upd.replyTo,
                    date: upd.date,
                    message: upd.message,
                    entities: upd.entities,
                    ttlPeriod: upd.ttlPeriod
                  };
                  const update = {
                    _: "updateNewMessage",
                    message: message2,
                    pts: upd.pts,
                    ptsCount: upd.ptsCount
                  };
                  pendingPtsUpdates.add({
                    update,
                    ptsBefore: upd.pts - upd.ptsCount,
                    pts: upd.pts,
                    peers: new PeersIndex(),
                    fromDifference: false
                  });
                  break;
                }
                case "updateShortChatMessage": {
                  log.debug("received updateShortChatMessage");
                  const message2 = {
                    _: "message",
                    out: upd.out,
                    mentioned: upd.mentioned,
                    mediaUnread: upd.mediaUnread,
                    silent: upd.silent,
                    id: upd.id,
                    fromId: {
                      _: "peerUser",
                      userId: upd.fromId
                    },
                    peerId: {
                      _: "peerChat",
                      chatId: upd.chatId
                    },
                    fwdFrom: upd.fwdFrom,
                    viaBotId: upd.viaBotId,
                    replyTo: upd.replyTo,
                    date: upd.date,
                    message: upd.message,
                    entities: upd.entities,
                    ttlPeriod: upd.ttlPeriod
                  };
                  const update = {
                    _: "updateNewMessage",
                    message: message2,
                    pts: upd.pts,
                    ptsCount: upd.ptsCount
                  };
                  pendingPtsUpdates.add({
                    update,
                    ptsBefore: upd.pts - upd.ptsCount,
                    pts: upd.pts,
                    peers: new PeersIndex(),
                    fromDifference: false
                  });
                  break;
                }
                case "updateShortSentMessage": {
                  log.warn("received updateShortSentMessage");
                  break;
                }
                default:
                  assertNever$1(upd);
              }
            }
            this.log.debug("processing pending pts-ordered updates");
            while (pendingPtsUpdates.length) {
              const pending = pendingPtsUpdates.popFront();
              const upd = pending.update;
              let localPts = null;
              if (!pending.channelId) {
                localPts = this.pts;
              } else if (cpts.has(pending.channelId)) {
                localPts = cpts.get(pending.channelId);
              } else if (this.catchingUp) {
                const saved = yield client.storage.updates.getChannelPts(pending.channelId);
                if (saved) {
                  cpts.set(pending.channelId, saved);
                  localPts = saved;
                }
              }
              if (localPts) {
                const diff = localPts - pending.ptsBefore;
                const isPtsDrop = diff > 1000009;
                if (diff > 0 && !isPtsDrop) {
                  log.debug(
                    "ignoring %s (cid = %d) because already applied (by pts: exp %d, got %d)",
                    upd._,
                    pending.channelId,
                    localPts,
                    pending.ptsBefore
                  );
                  continue;
                }
                if (diff < 0) {
                  if (diff > -3) {
                    log.debug(
                      "postponing %s for 0.5s (cid = %d) because small gap detected (by pts: exp %d, got %d, diff=%d)",
                      upd._,
                      pending.channelId,
                      localPts,
                      pending.ptsBefore,
                      diff
                    );
                    pending.timeout = Date.now() + 500;
                    pendingPtsUpdatesPostponed.add(pending);
                    postponedTimer.emitBefore(pending.timeout);
                  } else if (diff > -1e6) {
                    log.debug(
                      "fetching difference after %s (cid = %d) because pts gap detected (by pts: exp %d, got %d, diff=%d)",
                      upd._,
                      pending.channelId,
                      localPts,
                      pending.ptsBefore,
                      diff
                    );
                    if (pending.channelId) {
                      this._fetchChannelDifferenceLater(requestedDiff, pending.channelId);
                    } else {
                      this._fetchDifferenceLater(requestedDiff);
                    }
                  } else {
                    log.debug(
                      "skipping all updates because pts gap is too big (by pts: exp %d, got %d, diff=%d)",
                      localPts,
                      pending.ptsBefore,
                      diff
                    );
                    if (pending.channelId) {
                      cpts.set(pending.channelId, 0);
                      cptsMod.set(pending.channelId, 0);
                    } else {
                      yield this._fetchUpdatesState();
                    }
                  }
                  continue;
                }
                if (isPtsDrop) {
                  log.debug("pts drop detected (%d -> %d)", localPts, pending.ptsBefore);
                }
              }
              yield this._onUpdate(pending, requestedDiff);
            }
            this.log.debug("processing postponed pts-ordered updates");
            for (let item = pendingPtsUpdatesPostponed._first; item; item = item.n) {
              const pending = item.v;
              const upd = pending.update;
              let localPts;
              if (!pending.channelId) {
                localPts = this.pts;
              } else if (cpts.has(pending.channelId)) {
                localPts = cpts.get(pending.channelId);
              }
              if (!localPts) {
                log.warn(
                  "local pts not available for postponed %s (cid = %d), skipping",
                  upd._,
                  pending.channelId
                );
                continue;
              }
              if (localPts > pending.ptsBefore) {
                log.debug(
                  "ignoring postponed %s (cid = %d) because already applied (by pts: exp %d, got %d)",
                  upd._,
                  pending.channelId,
                  localPts,
                  pending.ptsBefore
                );
                pendingPtsUpdatesPostponed._remove(item);
                continue;
              }
              if (localPts < pending.ptsBefore) {
                const now = Date.now();
                if (now < pending.timeout) {
                  log.debug(
                    "postponed %s (cid = %d) is still waiting (%dms left) (current pts %d, need %d)",
                    upd._,
                    pending.channelId,
                    pending.timeout - now,
                    localPts,
                    pending.ptsBefore
                  );
                } else {
                  log.debug(
                    "gap for postponed %s (cid = %d) wasn't filled, fetching diff (current pts %d, need %d)",
                    upd._,
                    pending.channelId,
                    localPts,
                    pending.ptsBefore
                  );
                  pendingPtsUpdatesPostponed._remove(item);
                  if (pending.channelId) {
                    this._fetchChannelDifferenceLater(requestedDiff, pending.channelId);
                  } else {
                    this._fetchDifferenceLater(requestedDiff);
                  }
                }
                continue;
              }
              yield this._onUpdate(pending, requestedDiff, true);
              pendingPtsUpdatesPostponed._remove(item);
            }
            this.log.debug("processing pending qts-ordered updates");
            while (pendingQtsUpdates.length) {
              const pending = pendingQtsUpdates.popFront();
              const upd = pending.update;
              const diff = this.qts - pending.qtsBefore;
              const isQtsDrop = diff > 1000009;
              if (diff > 0 && !isQtsDrop) {
                log.debug(
                  "ignoring %s because already applied (by qts: exp %d, got %d)",
                  upd._,
                  this.qts,
                  pending.qtsBefore
                );
                continue;
              }
              if (this.qts < pending.qtsBefore) {
                if (diff > -3) {
                  log.debug(
                    "postponing %s for 0.5s because small gap detected (by qts: exp %d, got %d, diff=%d)",
                    upd._,
                    this.qts,
                    pending.qtsBefore,
                    diff
                  );
                  pending.timeout = Date.now() + 500;
                  pendingQtsUpdatesPostponed.add(pending);
                  postponedTimer.emitBefore(pending.timeout);
                } else {
                  log.debug(
                    "fetching difference after %s because qts gap detected (by qts: exp %d, got %d, diff=%d)",
                    upd._,
                    this.qts,
                    pending.qtsBefore,
                    diff
                  );
                  this._fetchDifferenceLater(requestedDiff);
                }
                continue;
              }
              if (isQtsDrop) {
                log.debug("qts drop detected (%d -> %d)", this.qts, pending.qtsBefore);
              }
              yield this._onUpdate(pending, requestedDiff);
            }
            this.log.debug("processing postponed qts-ordered updates");
            for (let item = pendingQtsUpdatesPostponed._first; item; item = item.n) {
              const pending = item.v;
              const upd = pending.update;
              if (this.qts > pending.qtsBefore) {
                log.debug(
                  "ignoring postponed %s because already applied (by qts: exp %d, got %d)",
                  upd._,
                  this.qts,
                  pending.qtsBefore
                );
                continue;
              }
              if (this.qts < pending.qtsBefore) {
                const now = Date.now();
                if (now < pending.timeout) {
                  log.debug(
                    "postponed %s is still waiting (%dms left) (current qts %d, need %d)",
                    upd._,
                    pending.timeout - now,
                    this.qts,
                    pending.qtsBefore
                  );
                } else {
                  log.debug(
                    "gap for postponed %s wasn't filled, fetching diff (current qts %d, need %d)",
                    upd._,
                    this.qts,
                    pending.qtsBefore
                  );
                  pendingQtsUpdatesPostponed._remove(item);
                  this._fetchDifferenceLater(requestedDiff);
                }
                continue;
              }
              yield this._onUpdate(pending, requestedDiff, true);
              pendingQtsUpdatesPostponed._remove(item);
            }
            this.hasTimedoutPostponed = false;
            while (requestedDiff.size) {
              log.debug(
                "waiting for %d pending diffs before processing unordered: %J",
                requestedDiff.size,
                requestedDiff.keys()
              );
              yield Promise.all([...requestedDiff.values()]);
              log.debug(
                "pending diffs awaited, new diffs requested: %d (%J)",
                requestedDiff.size,
                requestedDiff.keys()
              );
            }
            this.log.debug("processing pending unordered updates");
            while (pendingUnorderedUpdates.length) {
              const pending = pendingUnorderedUpdates.popFront();
              yield this._onUpdate(pending, requestedDiff, false, true);
            }
            while (requestedDiff.size) {
              log.debug(
                "waiting for %d pending diffs after processing unordered: %J",
                requestedDiff.size,
                requestedDiff.keys()
              );
              yield Promise.all([...requestedDiff.values()]);
              log.debug(
                "pending diffs awaited, new diffs requested: %d (%j)",
                requestedDiff.size,
                requestedDiff.keys()
              );
            }
            yield this._saveUpdatesStorage(true);
          }
          log.debug("updates loop stopped");
        } catch (e) {
          log.error("updates loop encountered error, restarting: %s", e);
          return this._loop();
        }
      });
    }
  }
  function makeRpcError(raw, stack, method) {
    const error = tl.tl.RpcError.fromTl(raw);
    error.stack = `RpcError (${error.code} ${error.text}): ${error.message}
    at ${method}
${stack.split("\n").slice(2).join("\n")}`;
    return error;
  }
  let BaseTelegramClient$1 = class BaseTelegramClient {
    constructor(params) {
      __publicField(this, "updates");
      __publicField(this, "_serverUpdatesHandler", () => {
      });
      __publicField(this, "_connectionStateHandler", () => {
      });
      __publicField(this, "log");
      __publicField(this, "mt");
      __publicField(this, "crypto");
      __publicField(this, "storage");
      __publicField(this, "appConfig", new AppConfigManager(this));
      __publicField(this, "_prepare", asyncResettable(() => __async(this, null, function* () {
        var _a2, _b, _c;
        yield this.mt.prepare();
        const self2 = yield this.storage.self.fetch();
        this.log.prefix = `[USER ${(_a2 = self2 == null ? void 0 : self2.userId) != null ? _a2 : "n/a"}] `;
        this.mt.network.setIsPremium((_b = self2 == null ? void 0 : self2.isPremium) != null ? _b : false);
        yield (_c = this.updates) == null ? void 0 : _c.prepare();
      })));
      // used in a hot path, avoid extra function calls
      __publicField(this, "_connected", false);
      __publicField(this, "_connect", asyncResettable(() => __async(this, null, function* () {
        yield this._prepare.run();
        yield this.mt.connect();
        this._connected = true;
      })));
      var _a2;
      this.params = params;
      this.log = (_a2 = this.params.logger) != null ? _a2 : new LogManager("client");
      this.mt = new MtClient(__spreadProps(__spreadValues({}, this.params), {
        logger: this.log.create("mtproto")
      }));
      if (!params.disableUpdates && params.updates !== false) {
        this.updates = new UpdatesManager(this, params.updates);
        this._serverUpdatesHandler = this.updates.handleUpdate.bind(this.updates);
        this.updates.onCatchingUp((catchingUp) => {
          this._connectionStateHandler(catchingUp ? "updating" : "connected");
        });
      }
      this.mt.on("update", (update) => {
        this._serverUpdatesHandler(update);
      });
      this.mt.on("usable", () => {
        this._connectionStateHandler("connected");
      });
      this.mt.on("wait", () => {
        this._connectionStateHandler("connecting");
      });
      this.mt.on("networkChanged", (connected) => {
        if (!connected) {
          this._connectionStateHandler("offline");
        }
      });
      this.crypto = this.mt.crypto;
      this.storage = new TelegramStorageManager(this.mt.storage, __spreadValues({
        provider: this.params.storage
      }, this.params.storageOptions));
    }
    /**
     * **ADVANCED**
     *
     * Do all the preparations, but don't connect just yet.
     * Useful when you want to do some preparations before
     * connecting, like setting up session.
     *
     * Call {@link connect} to actually connect.
     */
    prepare() {
      return this._prepare.run();
    }
    /**
     * Initialize the connection to the primary DC.
     *
     * You shouldn't usually call this method directly as it is called
     * implicitly the first time you call {@link call}.
     */
    connect() {
      return __async(this, null, function* () {
        return this._connect.run();
      });
    }
    get isConnected() {
      return this._connected;
    }
    close() {
      return __async(this, null, function* () {
        var _a2;
        this._connected = false;
        yield this.mt.close();
        (_a2 = this.updates) == null ? void 0 : _a2.stopLoop();
        this._prepare.reset();
        this._connect.reset();
      });
    }
    notifyLoggedIn(auth) {
      return __async(this, null, function* () {
        var _a2;
        const user = this.mt.network.notifyLoggedIn(auth);
        this.log.prefix = `[USER ${user.id}] `;
        const self2 = yield this.storage.self.storeFrom(user);
        (_a2 = this.updates) == null ? void 0 : _a2.notifyLoggedIn(self2);
        return user;
      });
    }
    notifyLoggedOut() {
      return __async(this, null, function* () {
        this.mt.network.notifyLoggedOut();
        this.log.prefix = "[USER n/a] ";
        yield this.storage.self.store(null);
      });
    }
    notifyChannelOpened(channelId, pts) {
      return __async(this, null, function* () {
        var _a2, _b;
        return (_b = (_a2 = this.updates) == null ? void 0 : _a2.notifyChannelOpened(channelId, pts)) != null ? _b : false;
      });
    }
    notifyChannelClosed(channelId) {
      return __async(this, null, function* () {
        var _a2, _b;
        return (_b = (_a2 = this.updates) == null ? void 0 : _a2.notifyChannelClosed(channelId)) != null ? _b : false;
      });
    }
    startUpdatesLoop() {
      return __async(this, null, function* () {
        var _a2;
        yield (_a2 = this.updates) == null ? void 0 : _a2.startLoop();
      });
    }
    stopUpdatesLoop() {
      return __async(this, null, function* () {
        var _a2;
        (_a2 = this.updates) == null ? void 0 : _a2.stopLoop();
      });
    }
    /**
     * Make an RPC call
     *
     * This method is still quite low-level and you shouldn't use this
     * when using high-level API provided by `@mtcute/client`.
     *
     * @param message  RPC method to call
     * @param params  Additional call parameters
     */
    call(message2, params) {
      return __async(this, null, function* () {
        var _a2;
        if (!this._connected) {
          yield this._connect.run();
        }
        const res = yield this.mt.call(message2, params);
        if (isTlRpcError(res)) {
          const error = makeRpcError(res, (_a2 = new Error().stack) != null ? _a2 : "", message2._);
          if (error.unknown && this.params.enableErrorReporting) {
            reportUnknownError(this.log, error, message2._);
          }
          throw error;
        }
        yield this.storage.peers.updatePeersFrom(res);
        return res;
      });
    }
    /**
     * Import the session from the given session string.
     *
     * Note that the session will only be imported in case
     * the storage is missing authorization (i.e. does not contain
     * auth key for the primary DC), otherwise it will be ignored (unless `force`).
     *
     * @param session  Session string to import
     * @param force  Whether to overwrite existing session
     */
    importSession(session, force = false) {
      return __async(this, null, function* () {
        yield this.prepare();
        const defaultDcAuthKey = yield this.mt.storage.provider.authKeys.get(this.mt._defaultDcs.main.id);
        if (defaultDcAuthKey && !force)
          return;
        const data2 = typeof session === "string" ? readStringSession(session) : session;
        if (data2.testMode && !this.params.testMode) {
          throw new Error(
            `This session string is not for the current backend. Session is ${data2.testMode ? "test" : "prod"}, but the client is ${this.params.testMode ? "test" : "prod"}`
          );
        }
        this.mt._defaultDcs = data2.primaryDcs;
        yield this.mt.storage.dcs.store(data2.primaryDcs);
        if (data2.self) {
          yield this.storage.self.store(data2.self);
        }
        yield this.mt.storage.provider.authKeys.set(data2.primaryDcs.main.id, data2.authKey);
        yield this.mt.storage.save();
      });
    }
    /**
     * Export current session to a single *LONG* string, containing
     * all the needed information.
     *
     * > **Warning!** Anyone with this string will be able
     * > to authorize as you and do anything. Treat this
     * > as your password, and never give it away!
     * >
     * > In case you have accidentally leaked this string,
     * > make sure to revoke this session in account settings:
     * > "Privacy & Security" > "Active sessions" >
     * > find the one containing `mtcute` > Revoke,
     * > or, in case this is a bot, revoke bot token
     * > with [@BotFather](//t.me/botfather)
     */
    exportSession() {
      return __async(this, null, function* () {
        var _a2;
        yield this._prepare.run();
        const primaryDcs = (_a2 = yield this.mt.storage.dcs.fetch()) != null ? _a2 : this.mt._defaultDcs;
        const authKey = yield this.mt.storage.provider.authKeys.get(primaryDcs.main.id);
        if (!authKey)
          throw new Error("Auth key is not ready yet");
        return writeStringSession({
          version: 3,
          self: yield this.storage.self.fetch(),
          testMode: Boolean(this.params.testMode),
          primaryDcs,
          authKey
        });
      });
    }
    /**
     * Register an error handler for the client
     *
     * @param handler  Error handler.
     */
    onError(handler) {
      this.mt.onError(handler);
    }
    emitError(err2) {
      this.mt.emitError(err2);
    }
    handleClientUpdate(updates, noDispatch) {
      var _a2;
      (_a2 = this.updates) == null ? void 0 : _a2.handleClientUpdate(updates, noDispatch);
    }
    onServerUpdate(handler) {
      this._serverUpdatesHandler = handler;
    }
    getServerUpdateHandler() {
      return this._serverUpdatesHandler;
    }
    onUpdate(handler) {
      if (!this.updates) {
        throw new MtArgumentError("Updates manager is disabled");
      }
      this.updates.setHandler(handler);
    }
    onConnectionState(handler) {
      this._connectionStateHandler = handler;
    }
    getApiCrenetials() {
      return __async(this, null, function* () {
        return {
          id: this.params.apiId,
          hash: this.params.apiHash
        };
      });
    }
    getPoolSize(kind, dcId) {
      return __async(this, null, function* () {
        if (!this._connected) {
          yield this._connect.run();
        }
        return this.mt.network.getPoolSize(kind, dcId);
      });
    }
    getPrimaryDcId() {
      return __async(this, null, function* () {
        if (!this._connected) {
          yield this._connect.run();
        }
        return this.mt.network.getPrimaryDcId();
      });
    }
    computeSrpParams(request, password) {
      return computeSrpParams(this.crypto, request, password);
    }
    computeNewPasswordHash(algo, password) {
      return computeNewPasswordHash(this.crypto, algo, password);
    }
    get stopSignal() {
      return this.mt.stopSignal;
    }
    changePrimaryDc(dcId) {
      return this.mt.network.changePrimaryDc(dcId);
    }
    getMtprotoMessageId() {
      return __async(this, null, function* () {
        return this.mt.network.getMtprotoMessageId();
      });
    }
  };
  function memoizeGetters(cls, fields) {
    for(let   field of fields) {
      const desc = Object.getOwnPropertyDescriptor(cls.prototype, field);
      if (!desc)
        continue;
      const { get: get2 } = desc;
      if (!get2)
        continue;
      Object.defineProperty(cls.prototype, field, {
        get() {
          const val = get2.call(this);
          Object.defineProperty(this, field, {
            value: val,
            enumerable: true,
            writable: true
          });
          return val;
        },
        enumerable: true,
        configurable: true
      });
    }
    return cls;
  }
  class MessageEntity {
    constructor(raw, _text) {
      this.raw = raw;
      this._text = _text;
    }
    /**
     * Offset in UTF-16 code units to the start of the entity.
     *
     * Since JS strings are UTF-16, you can use this as-is
     */
    get offset() {
      return this.raw.offset;
    }
    /**
     * Length of the entity in UTF-16 code units.
     *
     * Since JS strings are UTF-16, you can use this as-is
     */
    get length() {
      return this.raw.length;
    }
    /**
     * Kind of the entity (see {@link MessageEntityParams})
     */
    get kind() {
      return this.params.kind;
    }
    /**
     * Params of the entity
     */
    get params() {
      switch (this.raw._) {
        case "messageEntityMention":
          return { kind: "mention" };
        case "messageEntityHashtag":
          return { kind: "hashtag" };
        case "messageEntityCashtag":
          return { kind: "cashtag" };
        case "messageEntityBotCommand":
          return { kind: "bot_command" };
        case "messageEntityUrl":
          return { kind: "url" };
        case "messageEntityEmail":
          return { kind: "email" };
        case "messageEntityPhone":
          return { kind: "phone_number" };
        case "messageEntityBold":
          return { kind: "bold" };
        case "messageEntityItalic":
          return { kind: "italic" };
        case "messageEntityUnderline":
          return { kind: "underline" };
        case "messageEntityStrike":
          return { kind: "strikethrough" };
        case "messageEntitySpoiler":
          return { kind: "spoiler" };
        case "messageEntityCode":
          return { kind: "code" };
        case "messageEntityPre":
          return { kind: "pre", language: this.raw.language };
        case "messageEntityTextUrl":
          return { kind: "text_link", url: this.raw.url };
        case "messageEntityMentionName":
          return { kind: "text_mention", userId: this.raw.userId };
        case "messageEntityBlockquote":
          return { kind: "blockquote", collapsible: this.raw.collapsed };
        case "messageEntityCustomEmoji":
          return { kind: "emoji", emojiId: this.raw.documentId };
        case "messageEntityBankCard":
          return { kind: "bank_card" };
      }
      return { kind: "unknown" };
    }
    /**
     * Text contained in this entity.
     *
     * > **Note**: This does not take into account that entities may overlap,
     * > and is only useful for simple cases.
     */
    get text() {
      if (!this._text)
        return "";
      return this._text.slice(this.raw.offset, this.raw.offset + this.raw.length);
    }
    /**
     * Checks if this entity is of the given type, and adjusts the type accordingly.
     * @param kind
     * @returns
     */
    is(kind) {
      return this.params.kind === kind;
    }
  }
  memoizeGetters(MessageEntity, ["params"]);
  class EmojiStatus {
    constructor(raw) {
      this.raw = raw;
    }
    /** ID of the custom emoji */
    get emoji() {
      return this.raw.documentId;
    }
    /** This status is valid at most until this date */
    get expireDate() {
      if (this.raw._ === "emojiStatus")
        return null;
      return new Date(this.raw.until * 1e3);
    }
  }
  class ChatColors {
    constructor(_peerId, raw) {
      this._peerId = _peerId;
      this.raw = raw;
    }
    /**
     * Color ID
     *
     * Note that this value is **not** an RGB color representation. Instead, it is
     * a number which should be used to pick a color from a predefined
     * list of colors:
     *  - `0-6` are the default colors used by Telegram clients:
     *    `red, orange, purple, green, sea, blue, pink`
     *  - `>= 7` are returned by `help.getAppConfig`.
     */
    get color() {
      var _a2, _b;
      return (_b = (_a2 = this.raw) == null ? void 0 : _a2.color) != null ? _b : this._peerId % 7;
    }
    /**
     * ID of the emoji that should be used as a background pattern
     * when rendering the color
     */
    get backgroundEmojiId() {
      var _a2, _b;
      return (_b = (_a2 = this.raw) == null ? void 0 : _a2.backgroundEmojiId) != null ? _b : null;
    }
  }
  class ChatPermissions {
    constructor(bannedRights) {
      __publicField(this, "raw");
      this.raw = bannedRights;
    }
    /**
     * Whether users can view messages
     */
    get canViewMessages() {
      return !this.raw.viewMessages;
    }
    /**
     * Whether users can send text messages,
     * contacts, locations and venues
     */
    get canSendMessages() {
      return !this.raw.sendMessages;
    }
    /**
     * Whether users can send media messages,
     * including documents, photos, videos, video notes and voice notes.
     *
     * Implies {@link canSendMessages}
     */
    get canSendMedia() {
      return !this.raw.sendMedia;
    }
    /**
     * Whether users can send stickers.
     *
     * Implies {@link canSendMedia}
     */
    get canSendStickers() {
      return !this.raw.sendStickers;
    }
    /**
     * Whether users can send GIFs.
     *
     * Implies {@link canSendMedia}
     */
    get canSendGifs() {
      return !this.raw.sendGifs;
    }
    /**
     * Whether users can send photos.
     *
     * Implies {@link canSendMedia}
     */
    get canSendPhotos() {
      return !this.raw.sendPhotos;
    }
    /**
     * Whether users can send videos.
     *
     * Implies {@link canSendMedia}
     */
    get canSendVideos() {
      return !this.raw.sendVideos;
    }
    /**
     * Whether users can send round videos (i.e. video notes).
     *
     * Implies {@link canSendMedia}
     */
    get canSendRoundVideos() {
      return !this.raw.sendRoundvideos;
    }
    /**
     * Whether users can send audio files.
     *
     * Implies {@link canSendMedia}
     */
    get canSendAudios() {
      return !this.raw.sendAudios;
    }
    /**
     * Whether users can send voice notes.
     *
     * Implies {@link canSendMedia}
     */
    get canSendVoices() {
      return !this.raw.sendVoices;
    }
    /**
     * Whether users can send files.
     *
     * Implies {@link canSendMedia}
     */
    get canSendFiles() {
      return !this.raw.sendDocs;
    }
    /**
     * Whether users can send games.
     *
     * Implies {@link canSendMedia}
     */
    get canSendGames() {
      return !this.raw.sendGames;
    }
    /**
     * Whether users can use inline bots.
     *
     * Implies {@link canSendMedia}
     */
    get canUseInline() {
      return !this.raw.sendInline;
    }
    /**
     * Whether users can use inline bots.
     *
     * Implies {@link canSendMedia}
     */
    get canAddWebPreviews() {
      return !this.raw.embedLinks;
    }
    /**
     * Whether users can send text messages.
     *
     * Implies {@link canSendMessages}
     */
    get canSendText() {
      return !this.raw.sendPlain;
    }
    /**
     * Whether users can send polls.
     *
     * Implies {@link canSendMessages}
     */
    get canSendPolls() {
      return !this.raw.sendPolls;
    }
    /**
     * Whether users can change the chat title,
     * photo and other settings.
     */
    get canChangeInfo() {
      return !this.raw.changeInfo;
    }
    /**
     * Whether users can invite other users to the chat
     */
    get canInviteUsers() {
      return !this.raw.inviteUsers;
    }
    /**
     * Whether users can pin messages
     */
    get canPinMessages() {
      return !this.raw.pinMessages;
    }
    /**
     * Whether users can pin messages
     */
    get canManageTopics() {
      return !this.raw.manageTopics;
    }
    /**
     * UNIX date until which these permissions are valid,
     * or `null` if forever.
     *
     * For example, represents the time when the restrictions
     * will be lifted from a {@link ChatMember}
     */
    get untilDate() {
      return this.raw.untilDate === 0 ? null : new Date(this.raw.untilDate * 1e3);
    }
  }
  const PERSISTENT_ID_VERSION_OLD = 2;
  const PERSISTENT_ID_VERSION = 4;
  const WEB_LOCATION_FLAG = 1 << 24;
  const FILE_REFERENCE_FLAG = 1 << 25;
  const CURRENT_VERSION = 54;
  class FileIdError extends Error {
  }
  class UnsupportedError extends FileIdError {
  }
  class InvalidFileIdError extends FileIdError {
  }
  class ConversionError extends FileIdError {
    constructor(to) {
      super(`Cannot convert given File ID to ${to}`);
    }
  }
  var FileType$1 = /* @__PURE__ */ ((FileType2) => {
    FileType2[FileType2["Thumbnail"] = 0] = "Thumbnail";
    FileType2[FileType2["ProfilePhoto"] = 1] = "ProfilePhoto";
    FileType2[FileType2["Photo"] = 2] = "Photo";
    FileType2[FileType2["VoiceNote"] = 3] = "VoiceNote";
    FileType2[FileType2["Video"] = 4] = "Video";
    FileType2[FileType2["Document"] = 5] = "Document";
    FileType2[FileType2["Encrypted"] = 6] = "Encrypted";
    FileType2[FileType2["Temp"] = 7] = "Temp";
    FileType2[FileType2["Sticker"] = 8] = "Sticker";
    FileType2[FileType2["Audio"] = 9] = "Audio";
    FileType2[FileType2["Animation"] = 10] = "Animation";
    FileType2[FileType2["EncryptedThumbnail"] = 11] = "EncryptedThumbnail";
    FileType2[FileType2["Wallpaper"] = 12] = "Wallpaper";
    FileType2[FileType2["VideoNote"] = 13] = "VideoNote";
    FileType2[FileType2["SecureRaw"] = 14] = "SecureRaw";
    FileType2[FileType2["Secure"] = 15] = "Secure";
    FileType2[FileType2["Background"] = 16] = "Background";
    FileType2[FileType2["DocumentAsFile"] = 17] = "DocumentAsFile";
    FileType2[FileType2["Size"] = 18] = "Size";
    FileType2[FileType2["None"] = 19] = "None";
    return FileType2;
  })(FileType$1 || {});
  function isFileIdLike(obj) {
    return typeof obj === "string" || obj !== null && typeof obj === "object" && obj._ === "remoteFileLocation";
  }
  const typesInner = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CURRENT_VERSION,
    ConversionError,
    FILE_REFERENCE_FLAG,
    FileIdError,
    FileType: FileType$1,
    InvalidFileIdError,
    PERSISTENT_ID_VERSION,
    PERSISTENT_ID_VERSION_OLD,
    UnsupportedError,
    WEB_LOCATION_FLAG,
    isFileIdLike
  }, Symbol.toStringTag, { value: "Module" }));
  function telegramRleEncode(buf) {
    const len = buf.length;
    const ret = [];
    let count = 0;
    for (let i = 0; i < len; i++) {
      const cur = buf[i];
      if (cur === 0) {
        count += 1;
      } else {
        if (count > 0) {
          ret.push(0, count);
          count = 0;
        }
        ret.push(cur);
      }
    }
    if (count > 0) {
      ret.push(0, count);
    }
    return new Uint8Array(ret);
  }
  function telegramRleDecode(buf) {
    const len = buf.length;
    const ret = [];
    let prev = -1;
    for (let i = 0; i < len; i++) {
      const cur = buf[i];
      if (prev === 0) {
        for (let j = 0; j < cur; j++) {
          ret.push(prev);
        }
        prev = -1;
      } else {
        if (prev !== -1)
          ret.push(prev);
        prev = cur;
      }
    }
    if (prev !== -1)
      ret.push(prev);
    return new Uint8Array(ret);
  }
  function assertNever(_) {
    throw new Error("unreachable");
  }
  function parseWebFileLocation(reader2) {
    return {
      _: "web",
      url: reader2.string(),
      accessHash: reader2.long()
    };
  }
  function parsePhotoSizeSource(platform, reader2) {
    const variant = reader2.int();
    switch (variant) {
      case 0:
        return {
          _: "legacy",
          secret: reader2.long()
        };
      case 1: {
        const fileType = reader2.int();
        if (fileType < 0 || fileType >= FileType$1.Size) {
          throw new UnsupportedError(
            `Unsupported file type: ${fileType} (${platform.base64Encode(reader2.uint8View)})`
          );
        }
        const thumbnailType = reader2.int();
        if (thumbnailType < 0 || thumbnailType > 255) {
          throw new InvalidFileIdError(
            `Wrong thumbnail type: ${thumbnailType} (${platform.base64Encode(reader2.uint8View)})`
          );
        }
        return {
          _: "thumbnail",
          fileType,
          thumbnailType: String.fromCharCode(thumbnailType)
        };
      }
      case 2:
      case 3:
        return {
          _: "dialogPhoto",
          big: variant === 3,
          id: reader2.int53(),
          accessHash: reader2.long()
        };
      case 4:
        return {
          _: "stickerSetThumbnail",
          id: reader2.long(),
          accessHash: reader2.long()
        };
      case 5: {
        const res = {
          _: "fullLegacy",
          volumeId: reader2.long(),
          secret: reader2.long(),
          localId: reader2.int()
        };
        if (res.localId < 0) {
          throw new InvalidFileIdError("Wrong local_id (< 0)");
        }
        return res;
      }
      case 6:
      case 7: {
        const res = {
          _: "dialogPhotoLegacy",
          big: variant === 7,
          id: reader2.int53(),
          accessHash: reader2.long(),
          volumeId: reader2.long(),
          localId: reader2.int()
        };
        if (res.localId < 0) {
          throw new InvalidFileIdError("Wrong local_id (< 0)");
        }
        return res;
      }
      case 8: {
        const res = {
          _: "stickerSetThumbnailLegacy",
          id: reader2.long(),
          accessHash: reader2.long(),
          volumeId: reader2.long(),
          localId: reader2.int()
        };
        if (res.localId < 0) {
          throw new InvalidFileIdError("Wrong local_id (< 0)");
        }
        return res;
      }
      case 9:
        return {
          _: "stickerSetThumbnailVersion",
          id: reader2.long(),
          accessHash: reader2.long(),
          version: reader2.int()
        };
      default:
        throw new UnsupportedError(
          `Unsupported photo size source ${variant} (${platform.base64Encode(reader2.uint8View)})`
        );
    }
  }
  function parsePhotoFileLocation(platform, reader2, version2) {
    const id2 = reader2.long();
    const accessHash = reader2.long();
    let source;
    if (version2 >= 32) {
      source = parsePhotoSizeSource(platform, reader2);
    } else {
      const volumeId = reader2.long();
      let localId = 0;
      if (version2 >= 22) {
        source = parsePhotoSizeSource(platform, reader2);
        localId = reader2.int();
      } else {
        source = {
          _: "fullLegacy",
          secret: reader2.long(),
          localId: reader2.int(),
          volumeId
        };
      }
      switch (source._) {
        case "legacy":
          source = {
            _: "fullLegacy",
            secret: reader2.long(),
            localId: reader2.int(),
            volumeId
          };
          break;
        case "fullLegacy":
        case "thumbnail":
          break;
        case "dialogPhoto":
          source = {
            _: "dialogPhotoLegacy",
            id: source.id,
            accessHash: source.accessHash,
            big: source.big,
            localId,
            volumeId
          };
          break;
        case "stickerSetThumbnail":
          source = {
            _: "stickerSetThumbnailLegacy",
            id: source.id,
            accessHash: source.accessHash,
            localId,
            volumeId
          };
          break;
        default:
          throw new InvalidFileIdError("Invalid PhotoSizeSource in legacy PhotoRemoteFileLocation");
      }
    }
    return {
      _: "photo",
      id: id2,
      accessHash,
      source
    };
  }
  function parseCommonFileLocation(reader2) {
    return {
      _: "common",
      id: reader2.long(),
      accessHash: reader2.long()
    };
  }
  function fromPersistentIdV23(platform, binary, version2) {
    if (version2 < 0 || version2 > CURRENT_VERSION) {
      throw new UnsupportedError(`Unsupported file ID v3 subversion: ${version2} (${platform.base64Encode(binary)})`);
    }
    binary = telegramRleDecode(binary);
    const reader2 = TlBinaryReader.manual(binary);
    let fileType = reader2.int();
    const isWeb = Boolean(fileType & WEB_LOCATION_FLAG);
    const hasFileReference = Boolean(fileType & FILE_REFERENCE_FLAG);
    fileType &= -16777217;
    fileType &= -33554433;
    if (fileType < 0 || fileType >= FileType$1.Size) {
      throw new UnsupportedError(`Unsupported file type: ${fileType} (${platform.base64Encode(binary)})`);
    }
    const dcId = reader2.int();
    let fileReference = null;
    if (hasFileReference) {
      fileReference = reader2.bytes();
      if (fileReference.length === 1 && fileReference[0] === 35) {
        fileReference = null;
      }
    }
    let location;
    if (isWeb) {
      location = parseWebFileLocation(reader2);
    } else {
      switch (fileType) {
        case FileType$1.Photo:
        case FileType$1.ProfilePhoto:
        case FileType$1.Thumbnail:
        case FileType$1.EncryptedThumbnail:
        case FileType$1.Wallpaper: {
          location = parsePhotoFileLocation(platform, reader2, version2);
          switch (location.source._) {
            case "thumbnail":
              if (location.source.fileType !== fileType || fileType !== FileType$1.Photo && fileType !== FileType$1.Thumbnail && fileType !== FileType$1.EncryptedThumbnail) {
                throw new InvalidFileIdError("Invalid FileType in PhotoRemoteFileLocation Thumbnail");
              }
              break;
            case "dialogPhoto":
            case "dialogPhotoLegacy":
              if (fileType !== FileType$1.ProfilePhoto) {
                throw new InvalidFileIdError("Invalid FileType in PhotoRemoteFileLocation DialogPhoto");
              }
              break;
            case "stickerSetThumbnail":
            case "stickerSetThumbnailLegacy":
            case "stickerSetThumbnailVersion":
              if (fileType !== FileType$1.Thumbnail) {
                throw new InvalidFileIdError(
                  "Invalid FileType in PhotoRemoteFileLocation StickerSetThumbnail"
                );
              }
              break;
          }
          break;
        }
        case FileType$1.Video:
        case FileType$1.VoiceNote:
        case FileType$1.Document:
        case FileType$1.Sticker:
        case FileType$1.Audio:
        case FileType$1.Animation:
        case FileType$1.Encrypted:
        case FileType$1.VideoNote:
        case FileType$1.SecureRaw:
        case FileType$1.Secure:
        case FileType$1.Background:
        case FileType$1.DocumentAsFile: {
          location = parseCommonFileLocation(reader2);
          break;
        }
        default:
          throw new UnsupportedError(`Invalid file type: ${fileType} (${platform.base64Encode(binary)})`);
      }
    }
    return {
      _: "remoteFileLocation",
      dcId,
      type: fileType,
      fileReference,
      location
    };
  }
  function fromPersistentIdV2(platform, binary) {
    return fromPersistentIdV23(platform, binary.subarray(0, -1), 0);
  }
  function fromPersistentIdV3(platform, binary) {
    const subversion = binary[binary.length - 2];
    return fromPersistentIdV23(platform, binary.subarray(0, -2), subversion);
  }
  function parseFileId(platform, fileId) {
    if (typeof fileId === "string")
      fileId = platform.base64Decode(fileId, true);
    const version2 = fileId[fileId.length - 1];
    if (version2 === PERSISTENT_ID_VERSION_OLD) {
      return fromPersistentIdV2(platform, fileId);
    }
    if (version2 === PERSISTENT_ID_VERSION) {
      return fromPersistentIdV3(platform, fileId);
    }
    throw new UnsupportedError(`Unsupported file ID version: ${version2} (${platform.base64Encode(fileId)})`);
  }
  const SUFFIX = new Uint8Array([CURRENT_VERSION, PERSISTENT_ID_VERSION]);
  function toFileId(platform, location) {
    const loc = location.location;
    let type = location.type;
    if (loc._ === "web")
      type |= WEB_LOCATION_FLAG;
    if (location.fileReference)
      type |= FILE_REFERENCE_FLAG;
    const writer2 = TlBinaryWriter.manual(loc._ === "web" ? platform.utf8ByteLength(loc.url) + 32 : 100);
    writer2.int(type);
    writer2.int(location.dcId);
    if (location.fileReference) {
      writer2.bytes(location.fileReference);
    }
    switch (loc._) {
      case "web":
        writer2.string(loc.url);
        writer2.long(loc.accessHash);
        break;
      case "photo":
        writer2.long(loc.id);
        writer2.long(loc.accessHash);
        switch (loc.source._) {
          case "legacy":
            writer2.int(0);
            writer2.long(loc.source.secret);
            break;
          case "thumbnail":
            writer2.int(1);
            writer2.int(loc.source.fileType);
            writer2.int(loc.source.thumbnailType.charCodeAt(0));
            break;
          case "dialogPhoto":
            writer2.int(loc.source.big ? 3 : 2);
            writer2.int53(loc.source.id);
            writer2.long(loc.source.accessHash);
            break;
          case "stickerSetThumbnail":
            writer2.int(4);
            writer2.long(loc.source.id);
            writer2.long(loc.source.accessHash);
            break;
          case "fullLegacy":
            writer2.int(5);
            writer2.long(loc.source.volumeId);
            writer2.long(loc.source.secret);
            writer2.int(loc.source.localId);
            break;
          case "dialogPhotoLegacy":
            writer2.int(loc.source.big ? 7 : 6);
            writer2.int53(loc.source.id);
            writer2.long(loc.source.accessHash);
            writer2.long(loc.source.volumeId);
            writer2.int(loc.source.localId);
            break;
          case "stickerSetThumbnailLegacy":
            writer2.int(8);
            writer2.long(loc.source.id);
            writer2.long(loc.source.accessHash);
            writer2.long(loc.source.volumeId);
            writer2.int(loc.source.localId);
            break;
          case "stickerSetThumbnailVersion":
            writer2.int(9);
            writer2.long(loc.source.id);
            writer2.long(loc.source.accessHash);
            writer2.int(loc.source.version);
            break;
          default:
            assertNever(loc.source);
        }
        break;
      case "common":
        writer2.long(loc.id);
        writer2.long(loc.accessHash);
        break;
      default:
        assertNever();
    }
    const result = telegramRleEncode(writer2.result());
    const withSuffix = new Uint8Array(result.length + SUFFIX.length);
    withSuffix.set(result);
    withSuffix.set(SUFFIX, result.length);
    return platform.base64Encode(withSuffix, true);
  }
  function toUniqueFileId(platform, first, second) {
    const inputType = typeof first === "number" ? first : first.type;
    const inputLocation = typeof first === "number" ? second : first.location;
    let type;
    if (inputLocation._ === "web") {
      type = 0;
    } else {
      switch (inputType) {
        case FileType$1.Photo:
        case FileType$1.ProfilePhoto:
        case FileType$1.Thumbnail:
        case FileType$1.EncryptedThumbnail:
        case FileType$1.Wallpaper:
          type = 1;
          break;
        case FileType$1.Video:
        case FileType$1.VoiceNote:
        case FileType$1.Document:
        case FileType$1.Sticker:
        case FileType$1.Audio:
        case FileType$1.Animation:
        case FileType$1.VideoNote:
        case FileType$1.Background:
        case FileType$1.DocumentAsFile:
          type = 2;
          break;
        case FileType$1.SecureRaw:
        case FileType$1.Secure:
          type = 3;
          break;
        case FileType$1.Encrypted:
          type = 4;
          break;
        case FileType$1.Temp:
          type = 5;
          break;
        default:
          throw new InvalidFileIdError(`Invalid file type: ${inputType}`);
      }
    }
    let writer2;
    switch (inputLocation._) {
      case "photo": {
        const source = inputLocation.source;
        switch (source._) {
          case "legacy": {
            writer2 = TlBinaryWriter.manual(16);
            writer2.int(type);
            writer2.int(100);
            writer2.long(source.secret);
            break;
          }
          case "stickerSetThumbnail": {
            writer2 = TlBinaryWriter.manual(24);
            writer2.int(type);
            writer2.int(150);
            writer2.long(source.id);
            writer2.long(source.accessHash);
            break;
          }
          case "dialogPhoto": {
            writer2 = TlBinaryWriter.manual(13);
            writer2.int(type);
            writer2.long(inputLocation.id);
            writer2.raw(new Uint8Array([Number(source.big)]));
            break;
          }
          case "thumbnail": {
            writer2 = TlBinaryWriter.manual(13);
            let thumbType = source.thumbnailType.charCodeAt(0);
            if (thumbType === 97) {
              thumbType = 0;
            } else if (thumbType === 99) {
              thumbType = 1;
            } else {
              thumbType += 5;
            }
            writer2.int(type);
            writer2.long(inputLocation.id);
            writer2.raw(new Uint8Array([thumbType]));
            break;
          }
          case "fullLegacy":
          case "dialogPhotoLegacy":
          case "stickerSetThumbnailLegacy":
            writer2 = TlBinaryWriter.manual(16);
            writer2.int(type);
            writer2.long(source.volumeId);
            writer2.int(source.localId);
            break;
          case "stickerSetThumbnailVersion":
            writer2 = TlBinaryWriter.manual(17);
            writer2.int(type);
            writer2.raw(new Uint8Array([2]));
            writer2.long(source.id);
            writer2.int(source.version);
            break;
        }
        break;
      }
      case "web":
        writer2 = TlBinaryWriter.manual(platform.utf8ByteLength(inputLocation.url) + 8);
        writer2.int(type);
        writer2.string(inputLocation.url);
        break;
      case "common":
        writer2 = TlBinaryWriter.manual(12);
        writer2.int(type);
        writer2.long(inputLocation.id);
        break;
      default:
        assertNever();
    }
    return platform.base64Encode(telegramRleEncode(writer2.result()), true);
  }
  class FileLocation {
    constructor(location, fileSize, dcId) {
      this.location = location;
      this.fileSize = fileSize;
      this.dcId = dcId;
    }
  }
  function isUploadedFile(obj) {
    return obj !== null && typeof obj === "object" && "inputFile" in obj && "size" in obj && "mime" in obj;
  }
  function STUB_LOCATION() {
    throw new MtArgumentError("This web document is not downloadable through Telegram");
  }
  class WebDocument extends FileLocation {
    constructor(raw) {
      super(
        raw._ === "webDocument" ? {
          _: "inputWebFileLocation",
          url: raw.url,
          accessHash: raw.accessHash
        } : STUB_LOCATION,
        raw.size
      );
      this.raw = raw;
      this.raw = raw;
    }
    /**
     * URL to the file
     */
    get url() {
      return this.raw.url;
    }
    /**
     * MIME type of the file
     */
    get mimeType() {
      return this.raw.mimeType;
    }
    /**
     * Whether this file can be downloaded through Telegram.
     *
     * If `false`, you should use {@link url} to manually
     * fetch data via HTTP(s), and trying to use `download*` methods
     * will result in an error
     */
    get isDownloadable() {
      return this.raw._ === "webDocument";
    }
  }
  class ChatPhotoSize extends FileLocation {
    constructor(peer, obj, big) {
      super(
        {
          _: "inputPeerPhotoFileLocation",
          peer,
          photoId: obj.photoId,
          big
        },
        void 0,
        obj.dcId
      );
      this.peer = peer;
      this.obj = obj;
      this.big = big;
      this.peer = peer;
      this.obj = obj;
      this.big = big;
    }
    /**
     * TDLib and Bot API compatible File ID representing this size
     */
    get fileId() {
      const peer = this.peer;
      let id2;
      let hash;
      switch (peer._) {
        case "inputPeerUser":
          id2 = peer.userId;
          hash = peer.accessHash;
          break;
        case "inputPeerChat":
          id2 = -peer.chatId;
          hash = Long.ZERO;
          break;
        case "inputPeerChannel":
          id2 = toggleChannelIdMark(peer.channelId);
          hash = peer.accessHash;
          break;
        default:
          throw new MtArgumentError("Input peer was invalid");
      }
      return toFileId(getPlatform(), {
        dcId: this.obj.dcId,
        type: typesInner.FileType.ProfilePhoto,
        fileReference: null,
        location: {
          _: "photo",
          id: this.obj.photoId,
          accessHash: Long.ZERO,
          source: {
            _: "dialogPhoto",
            big: this.big,
            id: id2,
            accessHash: hash
          }
        }
      });
    }
    /**
     * TDLib and Bot API compatible unique File ID representing this size
     */
    get uniqueFileId() {
      return toUniqueFileId(getPlatform(), typesInner.FileType.ProfilePhoto, {
        _: "photo",
        id: this.obj.photoId,
        // eslint-disable-next-line ts/no-unsafe-assignment
        source: {
          _: "dialogPhoto",
          big: this.big
        }
      });
    }
  }
  memoizeGetters(ChatPhotoSize, ["fileId", "uniqueFileId"]);
  class ChatPhoto {
    constructor(peer, raw) {
      this.peer = peer;
      this.raw = raw;
    }
    /**
     * Whether this photo is personal (i.e. you set it yourself for this peer)
     */
    get isPersonal() {
      return this.raw._ === "userProfilePhoto" && this.raw.personal;
    }
    /** Chat photo file location in small resolution (160x160) */
    get small() {
      return new ChatPhotoSize(this.peer, this.raw, false);
    }
    /** Chat photo file location in big resolution (640x640) */
    get big() {
      return new ChatPhotoSize(this.peer, this.raw, true);
    }
    /**
     * Chat photo preview in *very* small resolution, if available
     */
    get thumb() {
      if (!this.raw.strippedThumb)
        return null;
      return strippedPhotoToJpg(this.raw.strippedThumb);
    }
  }
  memoizeGetters(ChatPhoto, ["small", "big", "thumb"]);
  class User {
    constructor(user) {
      __publicField(this, "type", "user");
      /**
       * Underlying raw TL object
       */
      __publicField(this, "raw");
      assertTypeIs("User#init", user, "user");
      this.raw = user;
    }
    /** Unique identifier for this user or bot */
    get id() {
      return this.raw.id;
    }
    /**
     * Whether this user's information is incomplete.
     *
     * This usually only happens in large chats, where
     * the server sometimes sends only a part of the user's
     * information. Basic info like name and profile photo
     * are always available, but other fields may be omitted
     * despite being available.
     *
     * For a rough list of fields that may be missing, see the
     * [official docs](https://core.telegram.org/constructor/user).
     *
     * This currently only ever happens for non-bot users, so if you are building
     * a normal bot, you can safely ignore this field.
     *
     * To fetch the "complete" user information, use one of these methods:
     *  - {@link TelegramClient.getUsers}
     *  - {@link TelegramClient.getChat}
     *  - {@link TelegramClient.getFullChat}.
     *
     * Learn more: [Incomplete peers](https://mtcute.dev/guide/topics/peers.html#incomplete-peers)
     */
    get isMin() {
      return this.raw.min;
    }
    /** Whether this user is you yourself */
    get isSelf() {
      return this.raw.self;
    }
    /** Whether this user is in your contacts */
    get isContact() {
      return this.raw.contact;
    }
    /** Whether you both have each other's contact */
    get isMutualContact() {
      return this.raw.mutualContact;
    }
    /** Whether this user is in yout "close friends" list */
    get isCloseFriend() {
      return this.raw.closeFriend;
    }
    /** Whether this user is deleted */
    get isDeleted() {
      return this.raw.deleted;
    }
    /** Whether this user is a bot */
    get isBot() {
      return this.raw.bot;
    }
    /**
     * Whether this user is a bot that can be connected to a
     * Telegram Business account to receive its messages
     */
    get isBusinessBot() {
      return this.raw.botBusiness;
    }
    /** Whether this user is a bot that has access to all messages */
    get isBotWithHistory() {
      return this.raw.botChatHistory;
    }
    /** Whether this user is a bot that can't be added to chats */
    get isBotWithoutChats() {
      return this.raw.botNochats;
    }
    /** Whether this bot offers an attachment menu web app */
    get isBotWithAttachmentMenu() {
      return this.raw.botAttachMenu;
    }
    /** Whether this bot can be edited by the current user */
    get isBotEditable() {
      return this.raw.botCanEdit;
    }
    /** Whether this user has been verified by Telegram */
    get isVerified() {
      return this.raw.verified;
    }
    /**
     * Whether this user has been restricted. Bots only.
     * See {@link restrictionReason} for details
     */
    get isRestricted() {
      return this.raw.restricted;
    }
    /**
     * Reason why this bot was restricted
     */
    get restrictionReason() {
      var _a2;
      return (_a2 = this.raw.restrictionReason) != null ? _a2 : [];
    }
    /** Whether this user has been flagged for scam */
    get isScam() {
      return this.raw.scam;
    }
    /** Whether this user has been flagged for impersonation */
    get isFake() {
      return this.raw.fake;
    }
    /** Whether this user is part of the Telegram support team */
    get isSupport() {
      return this.raw.support;
    }
    /** Whether this user has Premium subscription */
    get isPremium() {
      return this.raw.premium;
    }
    /** Whether Premium is required to contact this user */
    get isPremiumRequired() {
      return this.raw.contactRequirePremium;
    }
    /** Number of bot's active users, if available */
    get botActiveUsers() {
      var _a2;
      return (_a2 = this.raw.botActiveUsers) != null ? _a2 : null;
    }
    /** Whether this bot has a main app */
    get hasMainApp() {
      return this.raw.botHasMainApp;
    }
    /** User's or bot's first name */
    get firstName() {
      var _a2;
      return (_a2 = this.raw.firstName) != null ? _a2 : "Deleted Account";
    }
    /** User's or bot's last name */
    get lastName() {
      var _a2;
      return (_a2 = this.raw.lastName) != null ? _a2 : null;
    }
    static parseStatus(status, bot = false) {
      let ret;
      let date;
      let byMe = false;
      const us = status;
      if (bot) {
        ret = "bot";
      } else if (!us) {
        ret = "long_time_ago";
      } else {
        switch (us._) {
          case "userStatusOnline":
            ret = "online";
            date = new Date(us.expires * 1e3);
            break;
          case "userStatusOffline":
            ret = "offline";
            date = new Date(us.wasOnline * 1e3);
            break;
          case "userStatusRecently":
            ret = "recently";
            byMe = us.byMe;
            break;
          case "userStatusLastWeek":
            ret = "within_week";
            byMe = us.byMe;
            break;
          case "userStatusLastMonth":
            ret = "within_month";
            byMe = us.byMe;
            break;
          default:
            ret = "long_time_ago";
            break;
        }
      }
      return {
        status: ret,
        lastOnline: ret === "offline" ? date : null,
        nextOffline: ret === "online" ? date : null,
        byMe
      };
    }
    get _parsedStatus() {
      return User.parseStatus(this.raw.status, this.raw.bot);
    }
    /** User's Last Seen & Online status */
    get status() {
      return this._parsedStatus.status;
    }
    /**
     * Whether user's online status is hidden because
     * we have hidden our own online status from them,
     * and we don't have Premium subscription.
     */
    get statusHiddenByMe() {
      return this._parsedStatus.byMe;
    }
    /**
     * Last time this user was seen online.
     * Only available if {@link status} is `offline`
     */
    get lastOnline() {
      return this._parsedStatus.lastOnline;
    }
    /**
     * Time when this user will automatically go offline.
     * Only available if {@link status} is `online`
     */
    get nextOffline() {
      return this._parsedStatus.nextOffline;
    }
    /** User's or bot's username */
    get username() {
      var _a2, _b, _c, _d;
      return (_d = (_c = this.raw.username) != null ? _c : (_b = (_a2 = this.raw.usernames) == null ? void 0 : _a2[0]) == null ? void 0 : _b.username) != null ? _d : null;
    }
    /** User's or bot's usernames (including collectibles) */
    get usernames() {
      var _a2;
      if (this.raw.username) {
        return [{ _: "username", username: this.raw.username, active: true }];
      }
      if (!((_a2 = this.raw.usernames) == null ? void 0 : _a2.length)) {
        return null;
      }
      return this.raw.usernames;
    }
    /**
     * IETF language tag of the user's language
     *
     * Only available in some contexts
     */
    get language() {
      var _a2;
      return (_a2 = this.raw.langCode) != null ? _a2 : null;
    }
    /**
     * User's or bot's assigned DC (data center).
     * Available only in case the user has set a public profile photo.
     *
     * **Note**: this information is approximate; it is based on where
     * Telegram stores a user profile pictures and does not by any means tell
     * you the user location (i.e. a user might travel far away, but will still connect
     * to its assigned DC).
     * More info at [Pyrogram FAQ](https://docs.pyrogram.org/faq#what-are-the-ip-addresses-of-telegram-data-centers).
     */
    get dcId() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.photo) == null ? void 0 : _a2.dcId) != null ? _b : null;
    }
    /** User's phone number */
    get phoneNumber() {
      var _a2;
      return (_a2 = this.raw.phone) != null ? _a2 : null;
    }
    /**
     * Get this user's input peer for advanced use-cases.
     *
     * > **Note**: for {@link min} users, this method will return
     * > `mtcute.dummyInputPeerMinUser`, which is actually not a valid input peer.
     * > These are used to indicate that the user is incomplete, and a message
     * > reference is needed to resolve the peer.
     * >
     * > Such objects are handled by {@link TelegramClient.resolvePeer} method,
     * > so prefer using it whenever you need an input peer.
     */
    get inputPeer() {
      if (this.raw.min) {
        return {
          _: "mtcute.dummyInputPeerMinUser",
          userId: this.raw.id
        };
      }
      if (!this.raw.accessHash) {
        throw new MtArgumentError("user's access hash is not available!");
      }
      return {
        _: "inputPeerUser",
        userId: this.raw.id,
        accessHash: this.raw.accessHash
      };
    }
    /**
     * User's or bot's current profile photo, if any.
     * Suitable for downloads only
     */
    get photo() {
      var _a2;
      if (((_a2 = this.raw.photo) == null ? void 0 : _a2._) !== "userProfilePhoto")
        return null;
      return new ChatPhoto(this.inputPeer, this.raw.photo);
    }
    /**
     * The list of reasons why this bot might be unavailable to some users.
     * This field is available only in case *isRestricted* is `true`
     */
    get restrictions() {
      var _a2;
      return (_a2 = this.raw.restrictionReason) != null ? _a2 : null;
    }
    /**
     * User's display name.
     *
     * First name and last name if available,
     * only first name otherwise.
     */
    get displayName() {
      if (!this.firstName)
        return "Deleted Account";
      if (this.lastName)
        return `${this.firstName} ${this.lastName}`;
      return this.firstName;
    }
    /**
     * User's emoji status, if any.
     */
    get emojiStatus() {
      if (!this.raw.emojiStatus || this.raw.emojiStatus._ === "emojiStatusEmpty")
        return null;
      return new EmojiStatus(this.raw.emojiStatus);
    }
    /** Whether you have hidden (arhived) this user's stories */
    get storiesHidden() {
      return this.raw.storiesHidden;
    }
    get storiesUnavailable() {
      return this.raw.storiesUnavailable;
    }
    /**
     * Maximum ID of stories this user has (or 0 if none)
     */
    get storiesMaxId() {
      var _a2;
      return (_a2 = this.raw.storiesMaxId) != null ? _a2 : 0;
    }
    /**
     * Color that should be used when rendering replies to
     * their messages and web previews sent by them,
     * as well as to render the chat title
     */
    get color() {
      return new ChatColors(this.raw.id, this.raw.color);
    }
    /**
     * Color that should be used when rendering the header of
     * the user's profile
     *
     * If `null`, a generic header should be used instead
     */
    get profileColors() {
      return this.raw.profileColor ? new ChatColors(this.raw.id, this.raw.profileColor) : null;
    }
    /**
     * Create a mention for the user.
     *
     * When available and `text` is omitted, this method will return `@username`.
     * Otherwise, text mention is created.
     *
     * Use `null` as `text` (first parameter) to force create a text
     * mention with display name, even if there is a username.
     *
     * > **Note**: This method doesn't format anything on its own.
     * > Instead, it returns a {@link MessageEntity} that can later
     * > be used with `html` or `md` template tags
     *
     * @param text  Text of the mention.
     * @example
     * ```typescript
     * msg.replyText(html`Hello, ${msg.sender.mention()`)
     * ```
     */
    mention(text) {
      if (text === void 0 && this.username) {
        return `@${this.username}`;
      }
      if (!text)
        text = this.displayName;
      return new MessageEntity(
        {
          _: "messageEntityMentionName",
          offset: 0,
          length: text.length,
          userId: this.raw.id
        },
        text
      );
    }
    /**
     * Create a permanent mention for this user.
     *
     * Permanent* means that this mention will also
     * contain user's access hash, so even if the user
     * changes their username or the client forgets
     * about that user, it can still be mentioned.
     *
     * Telegram might change access hash in some cases,
     * so it may not exactly be *permanent*. The only way
     * to actually make it permanent is to send it as a message
     * somewhere and load it from there if needed.
     *
     * Note that some users (particularly, users with hidden forwards)
     * may not be mentioned like this outside the chats you have in common.
     *
     * This method is only needed when the result will be
     * stored somewhere outside current mtcute instance (e.g. saved for later use),
     * otherwise {@link mention} will be enough.
     *
     * > **Note**: This method doesn't format anything on its own.
     * > Instead, it returns a {@link MessageEntity} that can later
     * > be used with `html` or `md` template tags
     *
     * > **Note**: the resulting text can only be used by clients
     * > that support mtcute notation of permanent
     * > mention links (`tg://user?id=123&hash=abc`).
     * >
     * > Also note that these permanent mentions are only
     * > valid for current account, since peer access hashes are
     * > account-specific and can't be used on another account.
     * >
     * > Also note that for some users such mentions might not work at all
     * > due to privacy settings.
     *
     * @param text  Mention text
     */
    permanentMention(text) {
      if (!this.raw.accessHash) {
        throw new MtArgumentError("User's access hash is not available!");
      }
      if (!text)
        text = this.displayName;
      return new MessageEntity(
        {
          _: "messageEntityTextUrl",
          offset: 0,
          length: text.length,
          url: `tg://user?id=${this.id}&hash=${this.raw.accessHash.toString(16)}`
        },
        text
      );
    }
  }
  memoizeGetters(User, [
    "_parsedStatus",
    "usernames",
    "inputPeer",
    "photo",
    "emojiStatus",
    "color",
    "profileColors"
  ]);
  class Chat {
    constructor(peer) {
      __publicField(this, "type", "chat");
      /**
       * Raw peer object that this {@link Chat} represents.
       */
      __publicField(this, "peer");
      /**
       * Distance in meters of this group chat from your location
       * Returned only in {@link TelegramClient.getNearbyChats}
       */
      __publicField(this, "distance");
      if (!peer)
        throw new MtArgumentError("peer is not available");
      switch (peer._) {
        case "user":
        case "chat":
        case "channel":
        case "chatForbidden":
        case "channelForbidden":
          break;
        default:
          throw new MtTypeAssertionError("peer", "user | chat | channel", peer._);
      }
      this.peer = peer;
    }
    /** Marked ID of this chat */
    get id() {
      return getMarkedPeerId(this.inputPeer);
    }
    /**
     * Whether this chat's information is incomplete.
     *
     * This usually only happens in large chats, where
     * the server sometimes sends only a part of the chat's
     * information. Basic info like name and profile photo
     * are always available, but other fields may be omitted
     * despite being available.
     *
     * For a rough list of fields that may be missing, see the
     * official docs for [channel](https://core.telegram.org/constructor/channel)
     * and [user](https://core.telegram.org/constructor/user).
     *
     * This currently only ever happens for non-bot users, so if you are building
     * a normal bot, you can safely ignore this field.
     *
     * To fetch the "complete" user information, use one of these methods:
     *  - {@link TelegramClient.getChat}
     *  - {@link TelegramClient.getFullChat}.
     *
     * Learn more: [Incomplete peers](https://mtcute.dev/guide/topics/peers.html#incomplete-peers)
     */
    get isMin() {
      return Boolean(this.peer.min);
    }
    /**
     * Chat's input peer for advanced use-cases.
     *
     * > **Note**: for {@link min} chats, this method will return
     * > `mtcute.dummyInputPeerMin*`, which are actually not a valid input peer,
     * > These are used to indicate that the user is incomplete, and a message
     * > reference is needed to resolve the peer.
     * >
     * > Such objects are handled by {@link TelegramClient.resolvePeer} method,
     * so prefer using it whenever you need an input peer.
     */
    get inputPeer() {
      switch (this.peer._) {
        case "user":
          if (this.peer.min) {
            return {
              _: "mtcute.dummyInputPeerMinUser",
              userId: this.peer.id
            };
          }
          if (!this.peer.accessHash) {
            throw new MtArgumentError("Peer's access hash is not available!");
          }
          return {
            _: "inputPeerUser",
            userId: this.peer.id,
            accessHash: this.peer.accessHash
          };
        case "chat":
        case "chatForbidden":
          return {
            _: "inputPeerChat",
            chatId: this.peer.id
          };
        case "channel":
        case "channelForbidden":
          if (this.peer.min) {
            return {
              _: "mtcute.dummyInputPeerMinChannel",
              channelId: this.peer.id
            };
          }
          if (!this.peer.accessHash) {
            throw new MtArgumentError("Peer's access hash is not available!");
          }
          return {
            _: "inputPeerChannel",
            channelId: this.peer.id,
            accessHash: this.peer.accessHash
          };
      }
    }
    /** Type of chat */
    get chatType() {
      switch (this.peer._) {
        case "user":
          return this.peer.bot ? "bot" : "private";
        case "chat":
        case "chatForbidden":
          return "group";
        case "channel":
        case "channelForbidden":
          if (this.peer._ === "channel" && this.peer.gigagroup) {
            return "gigagroup";
          } else if (this.peer.broadcast) {
            return "channel";
          }
          return "supergroup";
      }
    }
    /**
     * Whether this chat is a group chat
     * (i.e. not a channel and not PM)
     */
    get isGroup() {
      switch (this.chatType) {
        case "group":
        case "supergroup":
        case "gigagroup":
          return true;
      }
      return false;
    }
    /**
     * Whether this chat has been verified by Telegram.
     * Supergroups, channels and groups only
     */
    get isVerified() {
      return "verified" in this.peer ? this.peer.verified : false;
    }
    /**
     * Whether this chat has been restricted.
     * See {@link restrictions} for details
     */
    get isRestricted() {
      return "restricted" in this.peer ? this.peer.restricted : false;
    }
    /**
     * Whether this chat is owned by the current user.
     * Supergroups, channels and groups only
     */
    get isCreator() {
      return "creator" in this.peer ? this.peer.creator : false;
    }
    /**
     * Whether current user has admin rights in this chat.
     * Supergroups, channels and groups only.
     */
    get isAdmin() {
      return "adminRights" in this.peer && Boolean(this.peer.adminRights);
    }
    /** Whether this chat has been flagged for scam */
    get isScam() {
      return "scam" in this.peer ? this.peer.scam : false;
    }
    /** Whether this chat has been flagged for impersonation */
    get isFake() {
      return "fake" in this.peer ? this.peer.fake : false;
    }
    /** Whether this chat is part of the Telegram support team. Users and bots only */
    get isSupport() {
      return this.peer._ === "user" && this.peer.support;
    }
    /** Whether this chat is chat with yourself (i.e. Saved Messages) */
    get isSelf() {
      return this.peer._ === "user" && this.peer.self;
    }
    /** Whether this peer is your contact */
    get isContact() {
      return this.peer._ === "user" && this.peer.contact;
    }
    /** Whether this peer is a forum supergroup */
    get isForum() {
      return this.peer._ === "channel" && this.peer.forum;
    }
    /** Whether the chat is not available (e.g. because the user was banned from there) */
    get isUnavailable() {
      return this.peer._ === "chatForbidden" || this.peer._ === "channelForbidden";
    }
    /**
     * Whether the current user is a member of the chat.
     *
     * For users, this is always `true`.
     */
    get isMember() {
      switch (this.peer._) {
        case "user":
          return true;
        case "channel":
        case "chat":
          return !this.peer.left;
        default:
          return false;
      }
    }
    /** Whether you have hidden (arhived) this chat's stories */
    get storiesHidden() {
      return "storiesHidden" in this.peer ? this.peer.storiesHidden : false;
    }
    get storiesUnavailable() {
      return "storiesUnavailable" in this.peer ? this.peer.storiesUnavailable : false;
    }
    /** Whether this group is a channel/supergroup with join requests enabled */
    get hasJoinRequests() {
      return this.peer._ === "channel" && this.peer.joinRequest;
    }
    /** Whether this group is a supergroup with join-to-send rule enabled */
    get hasJoinToSend() {
      return this.peer._ === "channel" && this.peer.joinToSend;
    }
    /** Whether this group has content protection (i.e. disabled forwards) */
    get hasContentProtection() {
      return (this.peer._ === "channel" || this.peer._ === "chat") && this.peer.noforwards;
    }
    /** Whether this channel has profile signatures (i.e. "Super Channel") */
    get hasProfileSignatures() {
      return this.peer._ === "channel" && this.peer.signatureProfiles;
    }
    /**
     * Title, for supergroups, channels and groups
     */
    get title() {
      var _a2;
      return this.peer._ !== "user" ? (_a2 = this.peer.title) != null ? _a2 : null : null;
    }
    /**
     * Username, for private chats, bots, supergroups and channels if available
     */
    get username() {
      var _a2, _b, _c;
      if (!("username" in this.peer))
        return null;
      return (_c = (_b = this.peer.username) != null ? _b : (_a2 = this.peer.usernames) == null ? void 0 : _a2[0].username) != null ? _c : null;
    }
    /**
     * Usernames (inclufing collectibles), for private chats, bots, supergroups and channels if available
     */
    get usernames() {
      var _a2;
      if (!("usernames" in this.peer))
        return null;
      return (_a2 = this.peer.usernames) != null ? _a2 : this.peer.username ? [{ _: "username", username: this.peer.username, active: true }] : null;
    }
    /**
     * First name of the other party in a private chat,
     * for private chats and bots
     */
    get firstName() {
      var _a2;
      return this.peer._ === "user" ? (_a2 = this.peer.firstName) != null ? _a2 : null : null;
    }
    /**
     * Last name of the other party in a private chat, for private chats
     */
    get lastName() {
      var _a2;
      return this.peer._ === "user" ? (_a2 = this.peer.lastName) != null ? _a2 : null : null;
    }
    /**
     * Get the display name of the chat.
     *
     * Title for groups and channels,
     * name (and last name if available) for users
     */
    get displayName() {
      var _a2;
      if (this.peer._ === "user") {
        if (this.peer.lastName) {
          return `${this.peer.firstName} ${this.peer.lastName}`;
        }
        return (_a2 = this.peer.firstName) != null ? _a2 : "Deleted Account";
      }
      return this.peer.title;
    }
    /**
     * Chat photo, if any.
     * Suitable for downloads only.
     *
     * If full chat information is available, prefer {@link FullChat#fullPhoto} instead.
     */
    get photo() {
      if (!("photo" in this.peer) || !this.peer.photo || this.peer.photo._ !== "userProfilePhoto" && this.peer.photo._ !== "chatPhoto") {
        return null;
      }
      return new ChatPhoto(this.inputPeer, this.peer.photo);
    }
    /**
     * User's or bot's assigned DC (data center).
     * Available only in case the user has set a public profile photo.
     *
     * **Note**: this information is approximate; it is based on where
     * Telegram stores the current chat photo. It is accurate only in case
     * the owner has set the chat photo, otherwise it will be the DC assigned
     * to the administrator who set the current profile photo.
     */
    get dcId() {
      var _a2, _b;
      if (!("photo" in this.peer))
        return null;
      return (_b = (_a2 = this.peer.photo) == null ? void 0 : _a2.dcId) != null ? _b : null;
    }
    /**
     * The list of reasons why this chat might be unavailable to some users.
     * This field is available only in case {@link isRestricted} is `true`
     */
    get restrictions() {
      var _a2;
      return "restrictionReason" in this.peer ? (_a2 = this.peer.restrictionReason) != null ? _a2 : null : null;
    }
    /**
     * Current user's permissions, for supergroups.
     */
    get permissions() {
      if (!("bannedRights" in this.peer && this.peer.bannedRights)) {
        return null;
      }
      return new ChatPermissions(this.peer.bannedRights);
    }
    /**
     * Default chat member permissions, for groups and supergroups.
     */
    get defaultPermissions() {
      if (!("defaultBannedRights" in this.peer) || !this.peer.defaultBannedRights) {
        return null;
      }
      return new ChatPermissions(this.peer.defaultBannedRights);
    }
    /**
     * Admin rights of the current user in this chat.
     * `null` for PMs and non-administered chats
     */
    get adminRights() {
      var _a2;
      return "adminRights" in this.peer ? (_a2 = this.peer.adminRights) != null ? _a2 : null : null;
    }
    /**
     * Maximum ID of stories this chat has (or 0 if none)
     */
    get storiesMaxId() {
      var _a2;
      switch (this.peer._) {
        case "channel":
        case "user":
          return (_a2 = this.peer.storiesMaxId) != null ? _a2 : 0;
      }
      return 0;
    }
    /**
     * Color that should be used when rendering replies to
     * the messages and web previews sent by this chat,
     * as well as to render the chat title
     */
    get color() {
      const color = this.peer._ === "user" || this.peer._ === "channel" ? this.peer.color : void 0;
      return new ChatColors(this.peer.id, color);
    }
    /**
     * Chat's emoji status, if any.
     */
    get emojiStatus() {
      if (this.peer._ !== "user" && this.peer._ !== "channel")
        return null;
      if (!this.peer.emojiStatus || this.peer.emojiStatus._ === "emojiStatusEmpty")
        return null;
      return new EmojiStatus(this.peer.emojiStatus);
    }
    /**
     * Color that should be used when rendering the header of
     * the user's profile
     *
     * If `null`, a generic header should be used instead
     */
    get profileColors() {
      const color = this.peer._ === "user" || this.peer._ === "channel" ? this.peer.profileColor : void 0;
      return new ChatColors(this.peer.id, color);
    }
    /** Boosts level this chat has (0 if none or is not a channel) */
    get boostsLevel() {
      var _a2;
      return this.peer._ === "channel" ? (_a2 = this.peer.level) != null ? _a2 : 0 : 0;
    }
    /**
     * Get a {@link User} from this chat.
     *
     * Returns `null` if this is not a chat with user
     */
    get user() {
      if (this.peer._ !== "user")
        return null;
      return new User(this.peer);
    }
    /**
     * If a subscription to this channel was bought using Telegram Stars,
     * this field will contain the date when the subscription will expire.
     */
    get subscriptionUntilDate() {
      if (this.peer._ !== "channel" || !this.peer.subscriptionUntilDate)
        return null;
      return new Date(this.peer.subscriptionUntilDate * 1e3);
    }
    /** @internal */
    static _parseFromMessage(message2, peers) {
      return Chat._parseFromPeer(message2.peerId, peers);
    }
    /** @internal */
    static _parseFromPeer(peer, peers) {
      switch (peer._) {
        case "peerUser":
          return new Chat(peers.user(peer.userId));
        case "peerChat":
          return new Chat(peers.chat(peer.chatId));
      }
      return new Chat(peers.chat(peer.channelId));
    }
    /**
     * Create a mention for the chat.
     *
     * If this is a user, works just like {@link User.mention}.
     * Otherwise, if the chat has a username, a `@username` is created
     * (or text link, if `text` is passed). If it does not, chat title is
     * simply returned without additional formatting.
     *
     * When available and `text` is omitted, this method will return `@username`.
     * Otherwise, text mention is created for the given (or default) parse mode
     *
     * Use `null` as `text` (first parameter) to force create a text
     * mention with display name, even if there is a username.
     *
     * > **Note**: This method doesn't format anything on its own.
     * > Instead, it returns a {@link MessageEntity} that can later
     * > be used with `html` or `md` template tags, or `unparse` method directly.
     *
     * @param text  Text of the mention.
     * @example
     * ```typescript
     * msg.replyText(html`Hello, ${msg.chat.mention()`)
     * ```
     */
    mention(text) {
      if (this.user)
        return this.user.mention(text);
      if (text === void 0 && this.username) {
        return `@${this.username}`;
      }
      if (!text)
        text = this.displayName;
      if (!this.username)
        return text;
      return new MessageEntity(
        {
          _: "messageEntityTextUrl",
          offset: 0,
          length: text.length,
          url: `https://t.me/${this.username}`
        },
        text
      );
    }
  }
  memoizeGetters(Chat, [
    "inputPeer",
    "chatType",
    "usernames",
    "photo",
    "permissions",
    "defaultPermissions",
    "user",
    "color"
  ]);
  class DraftMessage {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Text of the draft message
     */
    get text() {
      return this.raw.message;
    }
    /**
     * Information about replies/quotes in this message
     */
    get replyToMessage() {
      var _a2;
      if (((_a2 = this.raw.replyTo) == null ? void 0 : _a2._) !== "inputReplyToMessage")
        return null;
      return this.raw.replyTo;
    }
    /**
     * Date of the last time this draft was updated
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Whether no webpage preview will be generated
     */
    get disableWebPreview() {
      return this.raw.noWebpage;
    }
    /**
     * Message text entities (may be empty)
     */
    get entities() {
      var _a2;
      const entities = [];
      if ((_a2 = this.raw.entities) == null ? void 0 : _a2.length) {
        for(let   ent of this.raw.entities) {
          entities.push(new MessageEntity(ent, this.raw.message));
        }
      }
      return entities;
    }
  }
  memoizeGetters(DraftMessage, ["entities"]);
  function _rowsTo2d(rows) {
    return rows.map((it) => it.buttons);
  }
  function _2dToRows(arr, inline2) {
    return arr.map((row) => {
      if (!inline2) {
        row = row.map(
          (btn) => btn._ === "keyboardButtonWebView" ? __spreadProps(__spreadValues({}, btn), {
            _: "keyboardButtonSimpleWebView"
          }) : btn
        );
      }
      return {
        _: "keyboardButtonRow",
        buttons: row
      };
    });
  }
  function _convertToTl$2(obj) {
    if (!obj)
      return obj;
    if (tl.tl.isAnyReplyMarkup(obj))
      return obj;
    switch (obj.type) {
      case "reply":
        return {
          _: "replyKeyboardMarkup",
          resize: obj.resize,
          singleUse: obj.singleUse,
          selective: obj.selective,
          persistent: obj.persistent,
          placeholder: obj.placeholder,
          rows: _2dToRows(obj.buttons, false)
        };
      case "reply_hide":
        return {
          _: "replyKeyboardHide",
          selective: obj.selective
        };
      case "force_reply":
        return {
          _: "replyKeyboardForceReply",
          singleUse: obj.singleUse,
          selective: obj.selective,
          placeholder: obj.placeholder
        };
      case "inline":
        return {
          _: "replyInlineMarkup",
          rows: _2dToRows(obj.buttons, true)
        };
      default:
        assertNever$1();
    }
  }
  function parsePeer(peer, index) {
    switch (peer._) {
      case "peerUser":
        return new User(index.user(peer.userId));
      case "peerChat":
        return new Chat(index.chat(peer.chatId));
      case "peerChannel":
        return new Chat(index.chat(peer.channelId));
    }
  }
  class FactCheck {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Text of the fact-check
     */
    get text() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.text) == null ? void 0 : _a2.text) != null ? _b : "";
    }
    /**
     * Entities contained in the fact-check text
     */
    get entities() {
      var _a2;
      const entities = [];
      if ((_a2 = this.raw.text) == null ? void 0 : _a2.entities) {
        for(let   ent of this.raw.text.entities) {
          entities.push(new MessageEntity(ent, this.raw.text.text));
        }
      }
      return entities;
    }
    /**
     * Country for which the fact-check is relevant
     */
    get country() {
      var _a2;
      return (_a2 = this.raw.country) != null ? _a2 : null;
    }
    /**
     * Whether this information might be outdated
     * and should be re-fetched manually
     */
    get shouldRecheck() {
      return this.raw.needCheck;
    }
    /**
     * Hash of the fact-check
     */
    get hash() {
      return this.raw.hash;
    }
  }
  memoizeGetters(FactCheck, ["entities"]);
  function _callDiscardReasonFromTl(raw) {
    switch (raw._) {
      case "phoneCallDiscardReasonMissed":
        return "missed";
      case "phoneCallDiscardReasonDisconnect":
        return "disconnect";
      case "phoneCallDiscardReasonHangup":
        return "hangup";
      case "phoneCallDiscardReasonBusy":
        return "busy";
      default:
        assertNever$1();
    }
  }
  const _Thumbnail = class _Thumbnail extends FileLocation {
    constructor(media, sz) {
      switch (sz._) {
        case "photoSizeEmpty":
        case "photoCachedSize":
          throw new MtTypeAssertionError("sz", "not (photoSizeEmpty | photoCachedSize)", sz._);
      }
      let location;
      let size;
      let width;
      let height;
      switch (sz._) {
        case "photoStrippedSize":
          location = strippedPhotoToJpg(sz.bytes);
          width = height = Number.NaN;
          size = location.length;
          break;
        case "photoPathSize": {
          const imageSize = media._ === "document" ? media.attributes.find((it) => it._ === "documentAttributeImageSize") : void 0;
          location = () => svgPathToFile(this._path, imageSize);
          if (imageSize) {
            width = imageSize.w;
            height = imageSize.h;
          } else {
            width = height = 512;
          }
          size = Infinity;
          break;
        }
        case "videoSizeEmojiMarkup":
        case "videoSizeStickerMarkup":
          location = () => {
            throw new MtArgumentError("Cannot download thumbnail with emoji/sticker markup, try other size");
          };
          width = height = Number.NaN;
          size = Infinity;
          break;
        default:
          if (media._ === "stickerSet") {
            location = {
              _: "inputStickerSetThumb",
              stickerset: {
                _: "inputStickerSetID",
                id: media.id,
                accessHash: media.accessHash
              },
              thumbVersion: media.thumbVersion
            };
          } else if (media._ === "messageExtendedMediaPreview") {
            throw new MtTypeAssertionError("messageExtendedMediaPreview#thumb", "photoStrippedSize", sz._);
          } else {
            location = {
              _: media._ === "photo" ? "inputPhotoFileLocation" : "inputDocumentFileLocation",
              id: media.id,
              fileReference: media.fileReference,
              accessHash: media.accessHash,
              thumbSize: sz.type
            };
          }
          width = sz.w;
          height = sz.h;
          size = sz._ === "photoSizeProgressive" ? Math.max(...sz.sizes) : sz.size;
          break;
      }
      let dcId;
      if (media._ === "stickerSet") {
        dcId = media.thumbDcId;
      } else if (media._ === "messageExtendedMediaPreview") {
        dcId = 0;
      } else {
        dcId = media.dcId;
      }
      super(location, size, dcId);
      __publicField(this, "raw");
      /**
       * Thumbnail width
       * (`NaN` for {@link THUMB_OUTLINE} and {@link THUMB_STRIP})
       */
      __publicField(this, "width");
      /**
       * Thumbnail height
       * (`NaN` for {@link THUMB_OUTLINE} and {@link THUMB_STRIP})
       */
      __publicField(this, "height");
      __publicField(this, "_path");
      __publicField(this, "_media");
      this.raw = sz;
      this.width = width;
      this.height = height;
      this._media = media;
      if (sz._ === "photoPathSize") {
        this._path = inflateSvgPath(sz.bytes);
      }
    }
    get isVideo() {
      return this.raw._ === "videoSize";
    }
    /**
     * Thumbnail type
     */
    get type() {
      if (this.raw._ === "videoSizeEmojiMarkup") {
        return _Thumbnail.THUMB_EMOJI_MARKUP;
      }
      if (this.raw._ === "videoSizeStickerMarkup") {
        return _Thumbnail.THUMB_STICKER_MARKUP;
      }
      return this.raw.type;
    }
    /**
     * If {@link raw} is `tl.RawPhotoPathSize` (i.e. `raw.type === Thumbnail.THUMB_OUTLINE`),
     * this property will return raw SVG path of the preview.
     *
     * When downloading path thumbnails, a valid SVG file is returned.
     *
     * See also: https://core.telegram.org/api/files#vector-thumbnails
     *
     * @throws MtTypeAssertionError  In case {@link raw} is not `tl.RawPhotoPathSize`
     */
    get path() {
      assertTypeIs("Thumbnail#path", this.raw, "photoPathSize");
      return this._path;
    }
    /**
     * Get TDLib and Bot API compatible File ID
     * representing this thumbnail.
     *
     * > **Note:** You can't use this file id to send a thumbnail,
     * > only to download it.
     */
    get fileId() {
      if (this.raw._ !== "photoSize" && this.raw._ !== "photoSizeProgressive" && this.raw._ !== "videoSize" || this._media._ === "messageExtendedMediaPreview") {
        throw new MtArgumentError(`Cannot generate a file ID for "${this.type}"`);
      }
      if (this._media._ === "stickerSet") {
        return toFileId(getPlatform(), {
          type: typesInner.FileType.Thumbnail,
          dcId: this.dcId,
          fileReference: null,
          location: {
            _: "photo",
            id: Long.ZERO,
            accessHash: Long.ZERO,
            source: {
              _: "stickerSetThumbnailVersion",
              id: this._media.id,
              accessHash: this._media.accessHash,
              version: this._media.thumbVersion
            }
          }
        });
      }
      return toFileId(getPlatform(), {
        type: this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail,
        dcId: this.dcId,
        fileReference: this._media.fileReference,
        location: {
          _: "photo",
          id: this._media.id,
          accessHash: this._media.accessHash,
          source: {
            _: "thumbnail",
            fileType: this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail,
            thumbnailType: this.raw.type === "u" ? "\0" : this.raw.type
          }
        }
      });
    }
    /**
     * Get a unique File ID representing this thumbnail.
     */
    get uniqueFileId() {
      if (this.raw._ !== "photoSize" && this.raw._ !== "photoSizeProgressive" && this.raw._ !== "videoSize" || this._media._ === "messageExtendedMediaPreview") {
        throw new MtArgumentError(`Cannot generate a unique file ID for "${this.type}"`);
      }
      if (this._media._ === "stickerSet") {
        return toUniqueFileId(getPlatform(), typesInner.FileType.Thumbnail, {
          _: "photo",
          id: Long.ZERO,
          source: {
            _: "stickerSetThumbnailVersion",
            id: this._media.id,
            accessHash: this._media.accessHash,
            version: this._media.thumbVersion
          }
        });
      }
      return toUniqueFileId(getPlatform(), this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail, {
        _: "photo",
        id: this._media.id,
        source: {
          _: "thumbnail",
          fileType: this._media._ === "photo" ? typesInner.FileType.Photo : typesInner.FileType.Thumbnail,
          thumbnailType: this.raw.type === "u" ? "\0" : this.raw.type
        }
      });
    }
  };
  // see: https://core.telegram.org/api/files#image-thumbnail-types
  __publicField(_Thumbnail, "THUMB_100x100_BOX", "s");
  __publicField(_Thumbnail, "THUMB_320x320_BOX", "m");
  __publicField(_Thumbnail, "THUMB_800x800_BOX", "x");
  __publicField(_Thumbnail, "THUMB_1280x1280_BOX", "y");
  __publicField(_Thumbnail, "THUMB_2560x2560_BOX", "w");
  __publicField(_Thumbnail, "THUMB_160x160_CROP", "a");
  __publicField(_Thumbnail, "THUMB_320x320_CROP", "b");
  __publicField(_Thumbnail, "THUMB_640x640_CROP", "c");
  __publicField(_Thumbnail, "THUMB_1280x1280_CROP", "d");
  __publicField(_Thumbnail, "THUMB_STRIP", "i");
  __publicField(_Thumbnail, "THUMB_OUTLINE", "j");
  /** Animated profile pictures preview */
  __publicField(_Thumbnail, "THUMB_VIDEO_PROFILE", "u");
  /** Trimmed and downscaled video previews */
  __publicField(_Thumbnail, "THUMB_VIDEO_PREVIEW", "v");
  /** Fullscreen animation for Premium stickers */
  __publicField(_Thumbnail, "THUMB_VIDEO_FULLSCREEN", "f");
  /** (non-standard) Emoji-based markup for profile photo */
  __publicField(_Thumbnail, "THUMB_EMOJI_MARKUP", "pfp_em");
  /** (non-standard) Sticker-based markup for profile photo */
  __publicField(_Thumbnail, "THUMB_STICKER_MARKUP", "pfp_st");
  let Thumbnail = _Thumbnail;
  memoizeGetters(Thumbnail, ["fileId", "uniqueFileId"]);
  class Photo extends FileLocation {
    constructor(raw, media) {
      const location = {
        _: "inputPhotoFileLocation",
        id: raw.id,
        fileReference: raw.fileReference,
        accessHash: raw.accessHash,
        thumbSize: ""
      };
      let size;
      let width;
      let height;
      let bestSize;
      const progressive = raw.sizes.find((it) => it._ === "photoSizeProgressive");
      if (progressive) {
        location.thumbSize = progressive.type;
        size = Math.max(...progressive.sizes);
        width = progressive.w;
        height = progressive.h;
        bestSize = progressive;
      } else {
        let max2 = null;
        for(let   sz of raw.sizes) {
          if (sz._ === "photoSize" && (!max2 || sz.size > max2.size)) {
            max2 = sz;
          }
        }
        if (max2) {
          location.thumbSize = max2.type;
          size = max2.size;
          width = max2.w;
          height = max2.h;
          bestSize = max2;
        } else {
          throw new MtArgumentError("Photo does not have any sizes");
        }
      }
      super(location, size, raw.dcId);
      __publicField(this, "type", "photo");
      /** Biggest available photo width */
      __publicField(this, "width");
      /** Biggest available photo height */
      __publicField(this, "height");
      __publicField(this, "_bestSize");
      this.raw = raw;
      this.media = media;
      this._bestSize = bestSize;
      this.width = width;
      this.height = height;
      this.type = "photo";
    }
    /**
     * Photo ID
     */
    get id() {
      return this.raw.id;
    }
    /** Date this photo was sent */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Whether this photo is an animated profile picture
     */
    get isAnimatedAvatar() {
      var _a2;
      return Boolean((_a2 = this.raw.videoSizes) == null ? void 0 : _a2.some((s) => s._ === "videoSize" && s.type === "u"));
    }
    /**
     * Whether this photo is an animated profile picture, built from an emoji/sticker markup
     */
    get isMarkupAvatar() {
      var _a2;
      return Boolean(
        (_a2 = this.raw.videoSizes) == null ? void 0 : _a2.some((s) => s._ === "videoSizeEmojiMarkup" || s._ === "videoSizeStickerMarkup")
      );
    }
    /** Whether this photo is hidden with a spoiler */
    get hasSpoiler() {
      var _a2, _b;
      return (_b = (_a2 = this.media) == null ? void 0 : _a2.spoiler) != null ? _b : false;
    }
    /** For self-destructing photos, TTL in seconds */
    get ttlSeconds() {
      var _a2, _b;
      return (_b = (_a2 = this.media) == null ? void 0 : _a2.ttlSeconds) != null ? _b : null;
    }
    /**
     * Available thumbnails.
     *
     * **Note**: This list will also contain the largest thumbnail that is
     * represented by the current object.
     */
    get thumbnails() {
      var _a2;
      const res = this.raw.sizes.map((sz) => new Thumbnail(this.raw, sz));
      (_a2 = this.raw.videoSizes) == null ? void 0 : _a2.forEach((sz) => res.push(new Thumbnail(this.raw, sz)));
      return res;
    }
    /**
     * Get a photo thumbnail by its type.
     *
     * Thumbnail types are described in the
     * [Telegram docs](https://core.telegram.org/api/files#image-thumbnail-types),
     * and are also available as static members of {@link Thumbnail} for convenience.
     *
     * @param type  Thumbnail type
     */
    getThumbnail(type) {
      var _a2;
      return (_a2 = this.thumbnails.find((it) => it.type === type)) != null ? _a2 : null;
    }
    /**
     * Get TDLib and Bot API compatible File ID
     * representing this photo's best thumbnail.
     */
    get fileId() {
      if (!this._bestSize) {
        throw new MtArgumentError("Cannot get File ID for this photo");
      }
      return this.getThumbnail(this._bestSize.type).fileId;
    }
    /**
     * Get TDLib and Bot API compatible Unique File ID
     * representing this photo's best thumbnail.
     */
    get uniqueFileId() {
      if (!this._bestSize) {
        throw new MtArgumentError("Cannot get File ID for this photo");
      }
      return this.getThumbnail(this._bestSize.type).uniqueFileId;
    }
    /**
     * Input photo generated from this object.
     */
    get inputPhoto() {
      return {
        _: "inputPhoto",
        id: this.raw.id,
        accessHash: this.raw.accessHash,
        fileReference: this.raw.fileReference
      };
    }
    /**
     * Input media generated from this object,
     * to be used in {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     */
    get inputMedia() {
      return {
        _: "inputMediaPhoto",
        id: this.inputPhoto
      };
    }
  }
  memoizeGetters(Photo, ["thumbnails", "fileId", "uniqueFileId"]);
  class RawDocument extends FileLocation {
    constructor(raw) {
      super(
        {
          _: "inputDocumentFileLocation",
          id: raw.id,
          fileReference: raw.fileReference,
          accessHash: raw.accessHash,
          thumbSize: ""
        },
        raw.size,
        raw.dcId
      );
      this.raw = raw;
      this.raw = raw;
    }
    /**
     * Original file name, extracted from the document
     * attributes.
     */
    get fileName() {
      var _a2;
      const attr = this.raw.attributes.find((it) => it._ === "documentAttributeFilename");
      return (_a2 = attr == null ? void 0 : attr.fileName) != null ? _a2 : null;
    }
    /**
     * File MIME type, as defined by the sender.
     */
    get mimeType() {
      return this.raw.mimeType;
    }
    /**
     * Date the document was sent
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Available thumbnails, if any.
     *
     * If there are no thumbnails, the array will be empty.
     */
    get thumbnails() {
      var _a2, _b;
      const arr = [];
      (_a2 = this.raw.thumbs) == null ? void 0 : _a2.forEach((sz) => arr.push(new Thumbnail(this.raw, sz)));
      (_b = this.raw.videoThumbs) == null ? void 0 : _b.forEach((sz) => arr.push(new Thumbnail(this.raw, sz)));
      return arr;
    }
    /**
     * Get a thumbnail by its type.
     *
     * Thumbnail types are described in the
     * [Telegram docs](https://core.telegram.org/api/files#image-thumbnail-types),
     * and are also available as static members of {@link Thumbnail} for convenience.
     *
     * @param type  Thumbnail type
     */
    getThumbnail(type) {
      var _a2;
      return (_a2 = this.thumbnails.find((it) => {
        if (it.raw._ === "videoSizeEmojiMarkup" || it.raw._ === "videoSizeStickerMarkup") {
          return false;
        }
        return it.raw.type === type;
      })) != null ? _a2 : null;
    }
    /**
     * Input document TL object generated from this object,
     * to be used with methods that use it
     */
    get inputDocument() {
      return {
        _: "inputDocument",
        id: this.raw.id,
        accessHash: this.raw.accessHash,
        fileReference: this.raw.fileReference
      };
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     */
    get inputMedia() {
      return {
        _: "inputMediaDocument",
        id: this.inputDocument
      };
    }
    _fileIdType() {
      return typesInner.FileType.Document;
    }
    /**
     * Get TDLib and Bot API compatible File ID
     * representing this document.
     */
    get fileId() {
      return toFileId(getPlatform(), {
        type: this._fileIdType(),
        dcId: this.raw.dcId,
        fileReference: this.raw.fileReference,
        location: {
          _: "common",
          id: this.raw.id,
          accessHash: this.raw.accessHash
        }
      });
    }
    /**
     * Get a unique File ID representing this document.
     */
    get uniqueFileId() {
      return toUniqueFileId(getPlatform(), typesInner.FileType.Document, {
        _: "common",
        id: this.raw.id
      });
    }
  }
  class Document extends RawDocument {
    constructor() {
      super(...arguments);
      __publicField(this, "type", "document");
    }
  }
  memoizeGetters(Document, ["fileName", "thumbnails", "fileId", "uniqueFileId"]);
  class Audio extends RawDocument {
    constructor(doc, attr) {
      super(doc);
      /** Type of the media (for use in a tagged union) */
      __publicField(this, "type", "audio");
      this.attr = attr;
    }
    /** Type of the file for File ID generation */
    _fileIdType() {
      return typesInner.FileType.Audio;
    }
    /**
     * Duration of the audio in seconds.
     *
     * May not be accurate since provided by the sender.
     */
    get duration() {
      return this.attr.duration;
    }
    /**
     * Performer of the audio track.
     */
    get performer() {
      var _a2;
      return (_a2 = this.attr.performer) != null ? _a2 : null;
    }
    /**
     * Title of the audio track.
     */
    get title() {
      var _a2;
      return (_a2 = this.attr.title) != null ? _a2 : null;
    }
  }
  memoizeGetters(Audio, ["fileName", "thumbnails", "fileId", "uniqueFileId"]);
  const MASK_POSITION_POINT_TO_TL = {
    forehead: 0,
    eyes: 1,
    mouth: 2,
    chin: 3
  };
  const MASK_POS = ["forehead", "eyes", "mouth", "chin"];
  class Sticker extends RawDocument {
    constructor(doc, attr, attr2) {
      super(doc);
      __publicField(this, "type", "sticker");
      this.attr = attr;
      this.attr2 = attr2;
    }
    _fileIdType() {
      return typesInner.FileType.Sticker;
    }
    /**
     * Sticker width in pixels
     */
    get width() {
      var _a2, _b;
      return (_b = (_a2 = this.attr2) == null ? void 0 : _a2.w) != null ? _b : 512;
    }
    /**
     * Sticker height in pixels
     */
    get height() {
      var _a2, _b;
      return (_b = (_a2 = this.attr2) == null ? void 0 : _a2.h) != null ? _b : 512;
    }
    /**
     * Whether this sticker is a premium sticker
     * (has premium fullscreen animation)
     */
    get isPremiumSticker() {
      var _a2;
      return Boolean((_a2 = this.raw.videoThumbs) == null ? void 0 : _a2.some((s) => s._ === "videoSize" && s.type === "f"));
    }
    /**
     * Whether this sticker is a valid sticker.
     *
     * If it is not, then this is probably a WEBP photo
     * that Telegram treats as a sticker.
     */
    get isValidSticker() {
      return this.attr2 !== void 0 && (this.attr2.w === 512 || this.attr2.h === 512);
    }
    /**
     * Primary emoji associated with this sticker,
     * that is displayed in dialogs list.
     *
     * If there is none, empty string is returned.
     *
     * **Note:** This only contains at most one emoji.
     * Some stickers have multiple associated emojis,
     * but only one is returned here. This is Telegram's
     * limitation! Use {@link getAllEmojis} instead.
     *
     * For custom emojis, this alt should be used as a fallback
     * text that will be "behind" the custom emoji entity.
     */
    get emoji() {
      return this.attr.alt;
    }
    /**
     * Whether this custom emoji can be used by non-premium users.
     * `false` if this is not a custom emoji.
     *
     * > Not sure if there are any such stickers currently.
     */
    get customEmojiFree() {
      var _a2;
      return this.attr._ === "documentAttributeCustomEmoji" ? (_a2 = this.attr.free) != null ? _a2 : false : false;
    }
    /**
     * If this is a custom emoji, its unique ID
     * that can be used in {@link TelegramClient#getCustomEmojis}
     */
    get customEmojiId() {
      if (this.attr._ !== "documentAttributeCustomEmoji") {
        throw new MtArgumentError("This is not a custom emoji");
      }
      return this.raw.id;
    }
    /**
     * Type of the sticker
     */
    get stickerType() {
      if (this.attr._ === "documentAttributeSticker") {
        return this.attr.mask ? "mask" : "sticker";
      } else if (this.attr._ === "documentAttributeCustomEmoji") {
        return "emoji";
      }
      return "sticker";
    }
    /**
     * Type of the file representing the sticker
     */
    get sourceType() {
      var _a2;
      if (((_a2 = this.attr2) == null ? void 0 : _a2._) === "documentAttributeVideo") {
        return "video";
      }
      return this.mimeType === "application/x-tgsticker" ? "animated" : "static";
    }
    /**
     * Whether this sticker has an associated public sticker set.
     */
    get hasStickerSet() {
      return this.attr.stickerset._ === "inputStickerSetID";
    }
    /**
     * Input sticker set that it associated with this sticker, if available.
     */
    get inputStickerSet() {
      return this.attr.stickerset._ === "inputStickerSetEmpty" ? null : this.attr.stickerset;
    }
    /**
     * Position where this mask should be placed
     */
    get maskPosition() {
      if (this.attr._ !== "documentAttributeSticker" || !this.attr.maskCoords) {
        return null;
      }
      const raw = this.attr.maskCoords;
      return {
        point: MASK_POS[raw.n],
        x: raw.x,
        y: raw.y,
        scale: raw.zoom
      };
    }
  }
  memoizeGetters(Sticker, ["fileName", "thumbnails", "fileId", "uniqueFileId", "maskPosition"]);
  class Video extends RawDocument {
    constructor(doc, attr, media) {
      super(doc);
      __publicField(this, "type", "video");
      this.attr = attr;
      this.media = media;
    }
    _fileIdType() {
      if (this.isRound)
        return typesInner.FileType.VideoNote;
      if (this.isAnimation)
        return typesInner.FileType.Animation;
      return typesInner.FileType.Video;
    }
    /**
     * Video width in pixels
     */
    get width() {
      return this.attr.w;
    }
    /**
     * Video height in pixels
     */
    get height() {
      return this.attr.h;
    }
    /**
     * Video duration in seconds.
     *
     * `0` for legacy GIFs
     */
    get duration() {
      return this.attr._ === "documentAttributeVideo" ? this.attr.duration : 0;
    }
    /**
     * Whether this video is an animated GIF
     * (represented either by actual GIF or a silent MP4 video)
     */
    get isAnimation() {
      return this.attr._ === "documentAttributeImageSize" || this.raw.attributes.some((it) => it._ === "documentAttributeAnimated");
    }
    /**
     * Whether this video is a round video message (aka video note)
     */
    get isRound() {
      return this.attr._ === "documentAttributeVideo" && Boolean(this.attr.roundMessage);
    }
    /**
     * Whether this video is a legacy GIF (i.e. its MIME is `image/gif`)
     */
    get isLegacyGif() {
      return this.attr._ === "documentAttributeImageSize";
    }
    /** Whether this video is hidden with a spoiler */
    get hasSpoiler() {
      var _a2, _b;
      return (_b = (_a2 = this.media) == null ? void 0 : _a2.spoiler) != null ? _b : false;
    }
    /** For self-destructing videos, TTL in seconds */
    get ttlSeconds() {
      var _a2, _b;
      return (_b = (_a2 = this.media) == null ? void 0 : _a2.ttlSeconds) != null ? _b : null;
    }
    get videoStartTs() {
      var _a2;
      return this.attr._ === "documentAttributeVideo" ? (_a2 = this.attr.videoStartTs) != null ? _a2 : null : null;
    }
    get codec() {
      var _a2;
      return this.attr._ === "documentAttributeVideo" ? (_a2 = this.attr.videoCodec) != null ? _a2 : null : null;
    }
  }
  memoizeGetters(Video, ["fileName", "thumbnails", "fileId", "uniqueFileId", "isAnimation"]);
  class Voice extends RawDocument {
    constructor(doc, attr) {
      super(doc);
      __publicField(this, "type", "voice");
      this.attr = attr;
    }
    _fileIdType() {
      return typesInner.FileType.VoiceNote;
    }
    /**
     * Duration of the voice note in seconds.
     */
    get duration() {
      return this.attr.duration;
    }
    /**
     * Voice note's waveform
     *
     * Represented with integers in range [0, 31],
     * usually has length of 100
     */
    get waveform() {
      return decodeWaveform(this.attr.waveform);
    }
  }
  memoizeGetters(Voice, ["fileName", "thumbnails", "fileId", "uniqueFileId", "waveform"]);
  function parseSticker(doc) {
    const stickerAttr = doc.attributes.find(
      (a) => a._ === "documentAttributeSticker" || a._ === "documentAttributeCustomEmoji"
    );
    if (stickerAttr) {
      const sz = doc.attributes.find(
        (it) => it._ === "documentAttributeImageSize" || it._ === "documentAttributeVideo"
      );
      return new Sticker(doc, stickerAttr, sz);
    }
  }
  function parseDocument(doc, media) {
    const sticker = parseSticker(doc);
    if (sticker)
      return sticker;
    for(let   attr of doc.attributes) {
      switch (attr._) {
        case "documentAttributeAudio":
          if (attr.voice) {
            return new Voice(doc, attr);
          }
          return new Audio(doc, attr);
        case "documentAttributeVideo":
          return new Video(doc, attr, media);
        case "documentAttributeImageSize":
          if (doc.mimeType === "image/gif") {
            return new Video(doc, attr, media);
          }
      }
    }
    return new Document(doc);
  }
  class StarGift {
    constructor(raw) {
      this.raw = raw;
    }
    /** ID of the gift */
    get id() {
      return this.raw.id;
    }
    /** Sticker associated with the gift */
    get sticker() {
      assertTypeIs("StarGift#sticker", this.raw.sticker, "document");
      const parsed = parseDocument(this.raw.sticker);
      if (parsed.type !== "sticker") {
        throw new MtTypeAssertionError("StarGift#sticker", "sticker", parsed.type);
      }
      return parsed;
    }
    /** Amount of stars the gift was purchased for */
    get purchaseStars() {
      return this.raw.stars;
    }
    /**
     * Amount of stars the gift can be converted to by the recipient
     */
    get convertStars() {
      return this.raw.convertStars;
    }
    /**
     * For limited availability gifts,
     * the number of remaining and total gifts available
     */
    get availability() {
      if (!this.raw.availabilityRemains || !this.raw.availabilityTotal) {
        return null;
      }
      return {
        remains: this.raw.availabilityRemains,
        total: this.raw.availabilityTotal
      };
    }
  }
  memoizeGetters(StarGift, ["sticker"]);
  class UserStarGift {
    constructor(raw, peers) {
      this.raw = raw;
      this.peers = peers;
    }
    /** Whether the sender chose to appear anonymously */
    get nameHidden() {
      return this.raw.nameHidden;
    }
    /** Whether this gift is not visible on the recipient's profile */
    get hidden() {
      return this.raw.unsaved;
    }
    /** Sender of the gift, if available */
    get sender() {
      return this.raw.fromId ? new User(this.peers.user(this.raw.fromId)) : null;
    }
    /** Message ID where the gift was sent, if available */
    get messageId() {
      var _a2;
      return (_a2 = this.raw.msgId) != null ? _a2 : null;
    }
    /** Date the gift was sent */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /** The gift itself */
    get gift() {
      return new StarGift(this.raw.gift);
    }
    /** Text attached to the gift */
    get text() {
      var _a2;
      return (_a2 = this.raw.message) != null ? _a2 : null;
    }
    /**
     * If the gift was converted to stars, the amount of stars
     * it was converted to
     */
    get convertStars() {
      var _a2;
      return (_a2 = this.raw.convertStars) != null ? _a2 : null;
    }
  }
  memoizeGetters(UserStarGift, ["sender", "gift"]);
  function _messageActionFromTl(act) {
    var _a2, _b, _c, _d, _e;
    switch (act._) {
      case "messageActionChatCreate":
        return {
          type: "chat_created",
          title: act.title,
          users: act.users
        };
      case "messageActionChannelCreate":
        return {
          type: "channel_created",
          title: act.title
        };
      case "messageActionChatMigrateTo":
        return {
          type: "chat_migrate_to",
          id: act.channelId
        };
      case "messageActionChannelMigrateFrom":
        return {
          type: "channel_migrate_from",
          id: act.chatId,
          title: act.title
        };
      case "messageActionPinMessage":
        return {
          type: "message_pinned"
        };
      case "messageActionHistoryClear":
        return {
          type: "history_cleared"
        };
      case "messageActionGameScore":
        return {
          type: "game_score",
          gameId: act.gameId,
          score: act.score
        };
      case "messageActionContactSignUp":
        return {
          type: "contact_joined"
        };
      case "messageActionChatEditTitle":
        return {
          type: "title_changed",
          title: act.title
        };
      case "messageActionChatEditPhoto":
        return {
          type: "photo_changed",
          photo: new Photo(act.photo)
        };
      case "messageActionChatDeletePhoto":
        return {
          type: "photo_deleted"
        };
      case "messageActionChatAddUser":
        return {
          type: "users_added",
          users: act.users
        };
      case "messageActionChatDeleteUser":
        if (((_a2 = this.raw.fromId) == null ? void 0 : _a2._) === "peerUser" && act.userId === this.raw.fromId.userId) {
          return {
            type: "user_left"
          };
        }
        return {
          type: "user_removed",
          user: act.userId
        };
      case "messageActionChatJoinedByLink":
        return {
          type: "user_joined_link",
          inviter: act.inviterId
        };
      case "messageActionPaymentSentMe":
        return {
          type: "payment_received",
          currency: act.currency,
          amount: act.totalAmount,
          payload: act.payload,
          info: act.info,
          shippingOptionId: act.shippingOptionId,
          charge: act.charge
        };
      case "messageActionPaymentSent":
        return {
          type: "payment_sent",
          currency: act.currency,
          amount: act.totalAmount
        };
      case "messageActionPhoneCall":
        return {
          type: "call",
          id: act.callId,
          isVideo: Boolean(act.video),
          reason: act.reason ? _callDiscardReasonFromTl(act.reason) : void 0,
          duration: (_b = act.duration) != null ? _b : 0
        };
      case "messageActionScreenshotTaken":
        return {
          type: "screenshot_taken"
        };
      case "messageActionBotAllowed":
        return {
          type: "bot_allowed",
          domain: act.domain
        };
      case "messageActionGeoProximityReached":
        if (act.fromId._ !== "peerUser" || act.toId._ !== "peerUser") {
          return null;
        }
        return {
          type: "geo_proximity",
          targetId: act.toId.userId,
          userId: act.fromId.userId,
          distance: act.distance
        };
      case "messageActionGroupCall":
        if (act.duration) {
          return {
            type: "group_call_ended",
            call: act.call,
            duration: act.duration
          };
        }
        return {
          type: "group_call_started",
          call: act.call
        };
      case "messageActionGroupCallScheduled":
        return {
          type: "group_call_scheduled",
          call: act.call,
          date: new Date(act.scheduleDate * 1e3)
        };
      case "messageActionInviteToGroupCall":
        return {
          type: "group_call_invite",
          call: act.call,
          userIds: act.users
        };
      case "messageActionSetMessagesTTL":
        return {
          type: "ttl_changed",
          period: act.period
        };
      case "messageActionTopicCreate":
        return {
          type: "topic_created",
          title: act.title,
          iconColor: act.iconColor,
          iconCustomEmoji: act.iconEmojiId
        };
      case "messageActionTopicEdit":
        return {
          type: "topic_edited",
          title: act.title,
          iconCustomEmoji: act.iconEmojiId,
          closed: act.closed,
          hidden: act.hidden
        };
      case "messageActionCustomAction":
        return {
          type: "custom",
          action: act.message
        };
      case "messageActionSetChatTheme":
        return {
          type: "theme_changed",
          emoji: act.emoticon
        };
      case "messageActionChatJoinedByRequest":
        return {
          type: "user_joined_approved"
        };
      case "messageActionWebViewDataSent":
        return {
          type: "webview_sent",
          text: act.text
        };
      case "messageActionWebViewDataSentMe":
        return {
          type: "webview_received",
          text: act.text,
          data: act.data
        };
      case "messageActionGiftPremium":
        return {
          type: "premium_gifted",
          currency: act.currency,
          amount: act.amount.toNumber(),
          months: act.months,
          crypto: act.cryptoAmount ? {
            currency: act.cryptoCurrency,
            amount: act.cryptoAmount.toNumber()
          } : void 0
        };
      case "messageActionSuggestProfilePhoto":
        return {
          type: "photo_suggested",
          photo: new Photo(act.photo)
        };
      case "messageActionRequestedPeerSentMe":
        return {
          type: "peer_sent",
          buttonId: act.buttonId,
          peers: act.peers
        };
      case "messageActionRequestedPeer":
        return {
          type: "peer_chosen",
          buttonId: act.buttonId,
          peers: act.peers.map((it) => parsePeer(it, this._peers))
        };
      case "messageActionSetChatWallPaper":
        return {
          type: "wallpaper_changed",
          same: act.same,
          forBoth: act.forBoth,
          wallpaper: act.wallpaper
        };
      case "messageActionGiftCode":
        return {
          type: "gift_code",
          raw: act
        };
      case "messageActionGiveawayLaunch":
        return {
          type: "giveaway_started"
        };
      case "messageActionGiveawayResults":
        return {
          type: "giveaway_ended",
          winners: act.winnersCount,
          undistributed: act.unclaimedCount
        };
      case "messageActionBoostApply":
        return {
          type: "boost_apply",
          count: act.boosts
        };
      case "messageActionPaymentRefunded":
        return {
          type: "payment_refunded",
          currency: act.currency,
          peerId: getMarkedPeerId(act.peer),
          amount: act.totalAmount,
          payload: act.payload,
          charge: act.charge
        };
      case "messageActionGiftStars":
        return {
          type: "stars_gifted",
          isCrypto: Boolean(act.cryptoCurrency),
          currency: (_c = act.cryptoCurrency) != null ? _c : act.currency,
          amount: (_d = act.cryptoAmount) != null ? _d : act.amount,
          stars: act.stars,
          transactionId: act.transactionId
        };
      case "messageActionPrizeStars":
        return {
          type: "stars_prize",
          claimed: !act.unclaimed,
          stars: act.stars,
          transactionId: act.transactionId,
          boostPeer: parsePeer(act.boostPeer, this._peers),
          giveawayMessageId: act.giveawayMsgId
        };
      case "messageActionStarGift":
        return {
          type: "stars_gift",
          nameHidden: act.nameHidden,
          saved: act.saved,
          converted: act.converted,
          convertStars: act.convertStars,
          gift: new StarGift(act.gift),
          message: (_e = act.message) != null ? _e : null
        };
      default:
        return null;
    }
  }
  class MessageForwardInfo {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Date the original message was sent
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Sender of the original message (either user or a channel)
     * or their name (for users with private forwards)
     */
    get sender() {
      if (this.raw.fromName) {
        return {
          type: "anonymous",
          displayName: this.raw.fromName
        };
      }
      if (this.raw.fromId) {
        return parsePeer(this.raw.fromId, this._peers);
      }
      throw new MtTypeAssertionError("MessageForwardInfo", "to have fromId or fromName", "neither");
    }
    /**
     * For "saved" messages (i.e. messages forwarded to yourself,
     * "Saved Messages"), the peer where the message was originally sent
     */
    fromChat() {
      if (!this.raw.savedFromPeer)
        return null;
      return Chat._parseFromPeer(this.raw.savedFromPeer, this._peers);
    }
    /**
     * For messages forwarded from channels,
     * identifier of the original message in the channel
     */
    get fromMessageId() {
      var _a2;
      return (_a2 = this.raw.savedFromMsgId) != null ? _a2 : null;
    }
    /**
     * For messages forwarded from channels,
     * signature of the post author (if present)
     */
    get signature() {
      var _a2;
      return (_a2 = this.raw.postAuthor) != null ? _a2 : null;
    }
  }
  memoizeGetters(MessageForwardInfo, ["sender", "fromChat"]);
  class Contact {
    constructor(obj) {
      __publicField(this, "type", "contact");
      this.obj = obj;
    }
    /**
     * Contact's phone number
     */
    get phoneNumber() {
      return this.obj.phoneNumber;
    }
    /**
     * Contact's first name
     */
    get firstName() {
      return this.obj.firstName;
    }
    /**
     * Contact's last name
     */
    get lastName() {
      return this.obj.lastName;
    }
    /**
     * Contact's user ID in Telegram or `0` if not available
     */
    get userId() {
      return this.obj.userId;
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     */
    get inputMedia() {
      return __spreadProps(__spreadValues({}, this.obj), {
        _: "inputMediaContact"
      });
    }
  }
  class Dice {
    constructor(obj) {
      __publicField(this, "type", "dice");
      this.obj = obj;
    }
    /**
     * An emoji which was originally sent.
     *
     * See static members of {@link Dice} for a list
     * of possible values
     */
    get emoji() {
      return this.obj.emoticon;
    }
    /**
     * Emoji's interactive value.
     *
     * See what this value represents in the corresponding
     * type's documentation (in {@link Dice} static fields)
     */
    get value() {
      return this.obj.value;
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     *
     * Note that when you use this media, a new `value`
     * will be generated!
     */
    get inputMedia() {
      return {
        _: "inputMediaDice",
        emoticon: this.obj.emoticon
      };
    }
  }
  /**
   * A simple 6-sided dice.
   *
   * {@link value} represents its value (1-6)
   */
  __publicField(Dice, "TYPE_DICE", "ð²");
  /**
   * A dart. Telegram dart has 4 rings and middle.
   *
   * {@link value} represents the position of the dart:
   * ![Dart position graph](https://i.imgur.com/iPBm7HG.png)
   */
  __publicField(Dice, "TYPE_DART", "ð¯");
  /**
   * A basketball thrown into a hoop.
   *
   * {@link value} represents the motion of the ball:
   *  - 1: simple miss (ball hits right part, bounces to the left)
   *  - 2: first hit the ring, then miss
   *  - 3: ball gets stuck between the ring and the base
   *  - 4: first hit the ring, then score
   *  - 5: direct score
   */
  __publicField(Dice, "TYPE_BASKETBALL", "ð");
  /**
   * A football thrown to the gate.
   *
   * {@link value} represents the motion of the ball:
   *  - 1: flies above the top barbell
   *  - 2: hits right barbell, then miss
   *  - 3: direct score in the middle
   *  - 4: hits left barbell, then score, then hits right barbell
   *  - 5: score in the top-right corner
   */
  __publicField(Dice, "TYPE_FOOTBALL", "â½ï¸");
  /**
   * A bowling ball thrown to pins.
   *
   * Assuming the following identifiers for the pins:
   * ```
   * 4 5 6
   *  2 3
   *   1
   * ```
   *
   * {@link value} represents the motion of the ball and pins:
   *  - 1: the ball touched 6th pin, none are down
   *  - 2: the ball hit 4th pin, only 4th pin is down.
   *  - 3: the ball hit 1st pin, pins 1, 2, 5 are down, leaving pins 3, 4, 6
   *  - 4: the ball hit 1st pin on the right side, all the pins except 2nd and 6th are down
   *  - 5: the ball hit 3rd pin and all the pins except 2nd are down.
   *  - 6: the ball hit 1st pin and all pins are down
   */
  __publicField(Dice, "TYPE_BOWLING", "ð³");
  /**
   * A slot machine.
   *
   * {@link value} represents the result of the machine.
   * Value itself is an integer in range `[1, 64]`,
   * and is composed out of several parts.
   *
   * > **Note**: The following information is based on the TDesktop
   * > implementation. These are the relevant files:
   * >  - [`chat_helpers/stickers_dice_pack.cpp`](https://github.com/telegramdesktop/tdesktop/blob/dev/Telegram/SourceFiles/chat_helpers/stickers_dice_pack.cpp)
   * >  - [`history/view/media/history_view_slot_machine.cpp`](https://github.com/telegramdesktop/tdesktop/blob/dev/Telegram/SourceFiles/history/view/media/history_view_slot_machine.cpp)
   *
   * Unlike other animated dices, this does not have
   * all the possible combinations in the sticker set.
   * Instead, `value` is a specially encoded integer that contains
   * the information about the indexes.
   *
   * There are some base parts of the animations:
   *  - 0th sticker is the base background of the machine
   *  - 1st sticker is the background of the machine for the "winning" state (i.e. `777`)
   *  - 2nd sticker is the frame of the machine, including the handle
   *  - 8th sticker is the "idle" state for the left slot
   *  - 14th sticker is the "idle" state for the middle slot
   *  - 20th sticker is the "idle" state for the right slot
   *
   * The machine result is encoded as 3 concatenated two-bit integers,
   * and the resulting integer is incremented by one.
   *
   * So, to decode the value to its parts, you can use this code:
   * ```typescript
   * const computePartValue = (val: number, idx: number) => ((val - 1) >> (idx * 2)) & 0x03; // 0..3
   * const parts = [
   *   computePartValue(msg.media.value, 0),
   *   computePartValue(msg.media.value, 1),
   *   computePartValue(msg.media.value, 2),
   * ]
   * ```
   *
   * Each part of the value corresponds to a particular slot (i.e. part 0 is left slot,
   * part 1 is middle, part 2 is right). The slot values are as follows:
   *  - 0: BAR (displayed as a *BAR* sign on a black background)
   *  - 1: BERRIES (displayed as berries, similar to emoji ð)
   *  - 2: LEMON (displayed as a lemon, similar to emoji ð)
   *  - 3: SEVEN (displayed as a red digit 7)
   *
   * Therefore, the winning value (i.e. `777`) is represented as `(3 << 4 | 3 << 2 | 3 << 0) + 1 = 64`
   *
   * To determine the needed animation parts, you'll need to apply some shifts.
   * These are the offsets for the individual symbols:
   *  - WIN_SEVEN: 0
   *  - SEVEN: 1
   *  - BAR: 2
   *  - BERRIES: 3
   *  - LEMON: 4
   *
   * And these are the shifts for each slot:
   *  - LEFT: 3
   *  - MIDDLE: 9
   *  - RIGHT: 15
   *
   * > WIN_SEVEN is the same as SEVEN, but only used if the machine result is `777` (i.e. `value = 64`),
   * > as it contains additional "blinking" animation.
   *
   * The sticker index is computed as follows: `SHIFTS[SLOT] + OFFSETS[SYM]`.
   * For example, berries for the middle slot would be: `SHIFTS[MIDDLE] + OFFSETS[BERRIES] = 9 + 3 = 12`
   *
   * Currently, this sticker set is used for the machine: [SlotMachineAnimated](https://t.me/addstickers/SlotMachineAnimated)
   */
  __publicField(Dice, "TYPE_SLOTS", "ð°");
  class Game {
    constructor(game) {
      __publicField(this, "type", "game");
      this.game = game;
    }
    /**
     * Unique identifier of the game.
     */
    get id() {
      return this.game.id;
    }
    /**
     * Title of the game
     */
    get title() {
      return this.game.title;
    }
    /**
     * Description of the game
     */
    get description() {
      return this.game.description;
    }
    /**
     * Unique short name of the game
     */
    get shortName() {
      return this.game.shortName;
    }
    /**
     * Photo that will be displayed in the game message in chats
     */
    get photo() {
      if (this.game.photo._ === "photoEmpty")
        return null;
      return new Photo(this.game.photo);
    }
    /**
     * Animation that will be displayed in the game message in chats
     */
    get animation() {
      var _a2;
      if (((_a2 = this.game.document) == null ? void 0 : _a2._) !== "document")
        return null;
      const attr = this.game.document.attributes.find((it) => it._ === "documentAttributeVideo");
      if (!attr) {
        return null;
      }
      return new Video(this.game.document, attr);
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     */
    get inputMedia() {
      return {
        _: "inputMediaGame",
        id: {
          _: "inputGameID",
          id: this.game.id,
          accessHash: this.game.accessHash
        }
      };
    }
  }
  memoizeGetters(Game, ["photo", "animation"]);
  class ExtendedMediaPreview {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Width of the preview, in pixels (if available, else 0)
     */
    get width() {
      var _a2;
      return (_a2 = this.raw.w) != null ? _a2 : 0;
    }
    /**
     * Height of the preview, in pixels (if available, else 0)
     */
    get height() {
      var _a2;
      return (_a2 = this.raw.h) != null ? _a2 : 0;
    }
    get thumbnail() {
      if (!this.raw.thumb) {
        return null;
      }
      return new Thumbnail(this.raw, this.raw.thumb);
    }
    /**
     * If this is a video, the duration of the video,
     * in seconds (if available, else 0)
     */
    get videoDuration() {
      var _a2;
      return (_a2 = this.raw.videoDuration) != null ? _a2 : 0;
    }
  }
  memoizeGetters(ExtendedMediaPreview, ["thumbnail"]);
  class Invoice {
    constructor(raw, _extendedMedia) {
      __publicField(this, "type", "invoice");
      this.raw = raw;
      this._extendedMedia = _extendedMedia;
    }
    /**
     * Whether the shipping address was requested
     */
    isShippingAddressRequested() {
      return this.raw.shippingAddressRequested;
    }
    /**
     * Whether this is an example (test) invoice
     */
    isTest() {
      return this.raw.test;
    }
    /**
     * Product name, 1-32 characters
     */
    get title() {
      return this.raw.title;
    }
    /**
     * Product description, 1-255 characters
     */
    get description() {
      return this.raw.description;
    }
    /**
     * URL of the product photo for the invoice
     */
    get photo() {
      if (!this.raw.photo)
        return null;
      return new WebDocument(this.raw.photo);
    }
    /**
     * Message ID of receipt
     */
    get receiptMessageId() {
      var _a2;
      return (_a2 = this.raw.receiptMsgId) != null ? _a2 : null;
    }
    /**
     * Three-letter ISO 4217 currency code
     */
    get currency() {
      return this.raw.currency;
    }
    /**
     * Total price in the smallest units of the currency
     * (integer, not float/double). For example, for a price
     * of `US$ 1.45` `amount = 145`.
     *
     * See the exp parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json),
     * it shows the number of digits past the decimal point
     * for each currency (2 for the majority of currencies).
     */
    get amount() {
      return this.raw.totalAmount;
    }
    /**
     * Unique bot deep-linking parameter that can be used to generate this invoice
     */
    get startParam() {
      return this.raw.startParam;
    }
    /**
     * If this invoice has extended media
     */
    get extendedMediaState() {
      if (!this.raw.extendedMedia)
        return "none";
      if (this.raw.extendedMedia._ === "messageExtendedMediaPreview") {
        return "preview";
      }
      return "full";
    }
    /**
     * Get the invoice's extended media preview.
     * Only available if {@link extendedMediaState} is `preview`.
     * Otherwise, throws an error.
     */
    get extendedMediaPreview() {
      var _a2;
      if (((_a2 = this.raw.extendedMedia) == null ? void 0 : _a2._) !== "messageExtendedMediaPreview") {
        throw new MtArgumentError("No extended media preview available");
      }
      return new ExtendedMediaPreview(this.raw.extendedMedia);
    }
    /**
     * Get the invoice's extended media.
     * Only available if {@link extendedMediaState} is `full`.
     * Otherwise, throws an error.
     */
    get extendedMedia() {
      if (!this._extendedMedia) {
        throw new MtArgumentError("No extended media available");
      }
      return this._extendedMedia;
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}.
     *
     * Invoice can't provide an input media, since some
     * of the data is not available to the user,
     * which is required to send it. This getter
     * is only provided to allow using `msg.media.inputMedia`
     */
    get inputMedia() {
      throw new MtArgumentError("Invoice cannot provide an InputMedia");
    }
  }
  memoizeGetters(Invoice, ["extendedMediaPreview", "photo"]);
  class RawLocation {
    constructor(geo) {
      this.geo = geo;
    }
    /**
     * Geo point latitude
     */
    get latitude() {
      return this.geo.lat;
    }
    /**
     * Geo point longitude
     */
    get longitude() {
      return this.geo.long;
    }
    /**
     * Accuracy radius in meters.
     */
    get radius() {
      var _a2;
      return (_a2 = this.geo.accuracyRadius) != null ? _a2 : 0;
    }
    /**
     * Create {@link FileLocation} containing
     * server-generated image with the map preview
     */
    preview(params = {}) {
      var _a2, _b, _c, _d;
      return new FileLocation({
        _: "inputWebFileGeoPointLocation",
        geoPoint: {
          _: "inputGeoPoint",
          lat: this.geo.lat,
          long: this.geo.long,
          accuracyRadius: this.geo.accuracyRadius
        },
        accessHash: this.geo.accessHash,
        w: (_a2 = params.width) != null ? _a2 : 128,
        h: (_b = params.height) != null ? _b : 128,
        zoom: (_c = params.zoom) != null ? _c : 15,
        scale: (_d = params.scale) != null ? _d : 1
      });
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     */
    get inputMedia() {
      return {
        _: "inputMediaGeoPoint",
        geoPoint: {
          _: "inputGeoPoint",
          lat: this.geo.lat,
          long: this.geo.long,
          accuracyRadius: this.geo.accuracyRadius
        }
      };
    }
  }
  class Location extends RawLocation {
    constructor() {
      super(...arguments);
      __publicField(this, "type", "location");
    }
  }
  class LiveLocation extends RawLocation {
    constructor(live) {
      super(live.geo);
      __publicField(this, "type", "live_location");
      this.live = live;
    }
    /**
     * A direction in which the location moves, in degrees; 1-360
     */
    get heading() {
      var _a2;
      return (_a2 = this.live.heading) != null ? _a2 : null;
    }
    /**
     * Validity period of provided geolocation
     */
    get period() {
      return this.live.period;
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     *
     * Note that using this will result in an
     * independent live geolocation, which
     * will not be auto-updated with the current
     */
    get inputMedia() {
      return {
        _: "inputMediaGeoLive",
        geoPoint: {
          _: "inputGeoPoint",
          lat: this.geo.lat,
          long: this.geo.long,
          accuracyRadius: this.geo.accuracyRadius
        },
        heading: this.live.heading,
        period: this.live.period,
        proximityNotificationRadius: this.live.proximityNotificationRadius
      };
    }
    // todo: api to subscribe for real-time updates
  }
  class PaidMedia {
    constructor(raw, _extendedMedia) {
      __publicField(this, "type", "paid");
      this.raw = raw;
      this._extendedMedia = _extendedMedia;
    }
    /** Whether this media was paid for */
    get isPaid() {
      return this._extendedMedia !== void 0;
    }
    /** Price of the media (in Telegram Stars) */
    get price() {
      return this.raw.starsAmount;
    }
    /**
     * Get the available media previews.
     *
     * If the media is already paid for, this will return an empty array.
     */
    get previews() {
      const res = [];
      this.raw.extendedMedia.forEach((m2) => {
        if (m2._ !== "messageExtendedMediaPreview")
          return;
        res.push(new ExtendedMediaPreview(m2));
      });
      return res;
    }
    /**
     * Get the available full media.
     *
     * If the media is not paid for, this will return an empty array.
     */
    get medias() {
      return this._extendedMedia;
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}.
     *
     * Will throw if the media is not paid for.
     */
    get inputMedia() {
      if (!this.isPaid) {
        throw new Error("Cannot get input media for non-paid media");
      }
      return {
        _: "inputMediaPaidMedia",
        starsAmount: this.raw.starsAmount,
        extendedMedia: this._extendedMedia.map((m2) => m2.inputMedia)
      };
    }
  }
  memoizeGetters(PaidMedia, ["previews", "inputMedia"]);
  class PollAnswer {
    constructor(raw, result) {
      this.raw = raw;
      this.result = result;
    }
    /**
     * Answer text
     */
    get text() {
      return this.raw.text.text;
    }
    /**
     * Format entities for {@link text}, currently may only contain custom emojis
     */
    get textEntities() {
      return this.raw.text.entities.map((ent) => new MessageEntity(ent, this.raw.text.text));
    }
    /**
     * Answer data, to be passed to
     * {@link TelegramClient.sendVote}
     */
    get data() {
      return this.raw.option;
    }
    /**
     * Number of people who has chosen this result.
     * If not available (i.e. not voted yet)
     *
     * @default
     */
    get voters() {
      var _a2, _b;
      return (_b = (_a2 = this.result) == null ? void 0 : _a2.voters) != null ? _b : 0;
    }
    /**
     * Whether this answer was chosen by the current user
     */
    get chosen() {
      var _a2;
      return Boolean((_a2 = this.result) == null ? void 0 : _a2.chosen);
    }
    /**
     * Whether this answer is correct (for quizzes).
     * Not available before choosing an answer
     *
     * @default
     */
    get correct() {
      var _a2;
      return Boolean((_a2 = this.result) == null ? void 0 : _a2.correct);
    }
  }
  memoizeGetters(PollAnswer, ["textEntities"]);
  class Poll {
    constructor(raw, _peers, results) {
      __publicField(this, "type", "poll");
      this.raw = raw;
      this._peers = _peers;
      this.results = results;
    }
    /**
     * Unique identifier of the poll
     */
    get id() {
      return this.raw.id;
    }
    /**
     * Poll question
     */
    get question() {
      return this.raw.question.text;
    }
    /**
     * Format entities for {@link question} (currently may only contain custom emojis)
     */
    get questionEntities() {
      return this.raw.question.entities.map((ent) => new MessageEntity(ent, this.raw.question.text));
    }
    /**
     * List of answers in this poll
     */
    get answers() {
      var _a2;
      const results = (_a2 = this.results) == null ? void 0 : _a2.results;
      return this.raw.answers.map((ans, idx) => {
        if (results) {
          return new PollAnswer(ans, results[idx]);
        }
        return new PollAnswer(ans);
      });
    }
    /**
     * Total number of voters in this poll, if available
     */
    get voters() {
      var _a2, _b;
      return (_b = (_a2 = this.results) == null ? void 0 : _a2.totalVoters) != null ? _b : 0;
    }
    /**
     * Whether this poll is closed, i.e. does not
     * accept votes anymore
     */
    get isClosed() {
      return this.raw.closed;
    }
    /**
     * Whether this poll is public, i.e. you
     * list of voters is publicly available
     */
    get isPublic() {
      return this.raw.publicVoters;
    }
    /**
     * Whether this is a quiz
     */
    get isQuiz() {
      return this.raw.quiz;
    }
    /**
     * Whether this poll accepts multiple answers
     */
    get isMultiple() {
      return this.raw.multipleChoice;
    }
    /**
     * Solution for the quiz, only available
     * in case you have already answered
     */
    get solution() {
      var _a2, _b;
      return (_b = (_a2 = this.results) == null ? void 0 : _a2.solution) != null ? _b : null;
    }
    /**
     * Format entities for {@link solution}, only available
     * in case you have already answered
     */
    get solutionEntities() {
      var _a2;
      if (!this.results)
        return null;
      const res = [];
      if ((_a2 = this.results.solutionEntities) == null ? void 0 : _a2.length) {
        for(let   ent of this.results.solutionEntities) {
          res.push(new MessageEntity(ent, this.results.solution));
        }
      }
      return res;
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     *
     * A few notes:
     *  - Using this will result in an
     *    independent poll, which will not
     *    be auto-updated with the current.
     *  - If this is a quiz, a normal poll
     *    will be returned since the client does not
     *    know the correct answer.
     *  - This always returns a non-closed poll,
     *    even if the current poll was closed
     */
    get inputMedia() {
      return {
        _: "inputMediaPoll",
        poll: {
          _: "poll",
          closed: false,
          id: Long.ZERO,
          publicVoters: this.raw.publicVoters,
          multipleChoice: this.raw.multipleChoice,
          question: this.raw.question,
          answers: this.raw.answers,
          closePeriod: this.raw.closePeriod,
          closeDate: this.raw.closeDate
        }
      };
    }
  }
  memoizeGetters(Poll, ["answers", "solutionEntities", "questionEntities"]);
  function normalizeInputReaction(reaction) {
    if (typeof reaction === "string") {
      if (reaction === "paid") {
        return {
          _: "reactionPaid"
        };
      }
      return {
        _: "reactionEmoji",
        emoticon: reaction
      };
    } else if (Long.isLong(reaction)) {
      return {
        _: "reactionCustomEmoji",
        documentId: reaction
      };
    } else if (reaction) {
      return reaction;
    }
    return {
      _: "reactionEmpty"
    };
  }
  function toReactionEmoji(reaction, allowEmpty) {
    switch (reaction._) {
      case "reactionEmoji":
        return reaction.emoticon;
      case "reactionCustomEmoji":
        return reaction.documentId;
      case "reactionPaid":
        return "â­";
      case "reactionEmpty":
        if (!allowEmpty) {
          throw new MtTypeAssertionError("toReactionEmoji", "not reactionEmpty", reaction._);
        }
        return null;
    }
  }
  class PeerReaction {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Emoji representing the reaction
     */
    get emoji() {
      return toReactionEmoji(this.raw.reaction);
    }
    /**
     * Whether this is a big reaction
     */
    get big() {
      return this.raw.big;
    }
    /**
     * Whether this reaction is unread by the current user
     */
    get unread() {
      return this.raw.unread;
    }
    /**
     * ID of the user who has reacted
     */
    get userId() {
      return getMarkedPeerId(this.raw.peerId);
    }
    /**
     * User who has reacted
     */
    get user() {
      assertTypeIs("PeerReaction#user", this.raw.peerId, "peerUser");
      return new User(this._peers.user(this.raw.peerId.userId));
    }
  }
  memoizeGetters(PeerReaction, ["user"]);
  class PaidPeerReaction {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** Whether this reaction is from the current user */
    get my() {
      return this.raw.my;
    }
    /** Whether this reaction was sent anonymously */
    get anonymous() {
      return this.raw.anonymous;
    }
    /**
     * If this reaction was not sent anonymously,
     * this field will contain the user who sent it
     */
    get peer() {
      if (!this.raw.peerId)
        return null;
      return parsePeer(this.raw.peerId, this._peers);
    }
    /** Number of reactions sent by this user */
    get count() {
      return this.raw.count;
    }
  }
  memoizeGetters(PaidPeerReaction, ["peer"]);
  class StoryInteractiveArea {
    constructor(raw) {
      this.raw = raw;
      this.raw = raw;
    }
    /** X coordinate of the top-left corner of the area */
    get x() {
      return this.raw.coordinates.x;
    }
    /** Y coordinate of the top-left corner of the area */
    get y() {
      return this.raw.coordinates.y;
    }
    /** Width of the area */
    get width() {
      return this.raw.coordinates.w;
    }
    /** Height of the area */
    get height() {
      return this.raw.coordinates.h;
    }
    /** Rotation of the area */
    get rotation() {
      return this.raw.coordinates.rotation;
    }
  }
  class StoryInteractiveChannelPost extends StoryInteractiveArea {
    constructor(raw, _peers) {
      super(raw);
      __publicField(this, "type", "channel_post");
      this.raw = raw;
      this._peers = _peers;
    }
    /** Channel being mentioned */
    get chat() {
      return new Chat(this._peers.chat(this.raw.channelId));
    }
    /** ID of the message being mentioned */
    get messageId() {
      return this.raw.msgId;
    }
  }
  memoizeGetters(StoryInteractiveChannelPost, ["chat"]);
  class StoryInteractiveLocation extends StoryInteractiveArea {
    constructor(raw) {
      super(raw);
      __publicField(this, "type", "location");
      this.raw = raw;
    }
    /**
     * Geolocation
     */
    get location() {
      assertTypeIs("StoryInteractiveLocation#location", this.raw.geo, "geoPoint");
      return new Location(this.raw.geo);
    }
  }
  memoizeGetters(StoryInteractiveLocation, ["location"]);
  class StoryInteractiveReaction extends StoryInteractiveArea {
    constructor(raw) {
      super(raw);
      __publicField(this, "type", "reaction");
      this.raw = raw;
    }
    /** Whether this reaction is on a dark background */
    get isDark() {
      return this.raw.dark;
    }
    /** Whether this reaction is flipped (i.e. has tail on the left) */
    get isFlipped() {
      return this.raw.flipped;
    }
    /** Emoji representing the reaction */
    get emoji() {
      return toReactionEmoji(this.raw.reaction);
    }
  }
  class StoryInteractiveUrl extends StoryInteractiveArea {
    constructor(raw) {
      super(raw);
      __publicField(this, "type", "url");
      this.raw = raw;
    }
    get url() {
      return this.raw.url;
    }
  }
  class StoryInteractiveVenue extends StoryInteractiveArea {
    constructor(raw) {
      super(raw);
      __publicField(this, "type", "venue");
      this.raw = raw;
    }
    /**
     * Geolocation of the venue
     */
    get location() {
      assertTypeIs("StoryInteractiveVenue#location", this.raw.geo, "geoPoint");
      return new Location(this.raw.geo);
    }
    /**
     * Venue name
     */
    get title() {
      return this.raw.title;
    }
    /**
     * Venue address
     */
    get address() {
      return this.raw.address;
    }
    /**
     * When available, source from where this venue was acquired
     */
    get source() {
      if (!this.raw.provider)
        return null;
      return {
        provider: this.raw.provider,
        id: this.raw.venueId,
        type: this.raw.venueType
      };
    }
  }
  memoizeGetters(StoryInteractiveVenue, ["location"]);
  class StoryInteractiveWeather extends StoryInteractiveArea {
    constructor(raw) {
      super(raw);
      __publicField(this, "type", "weather");
      this.raw = raw;
    }
    /** Emoji representing the weather */
    get emoji() {
      return this.raw.emoji;
    }
    /** Temperature in Celsius */
    get temperature() {
      return this.raw.temperatureC;
    }
    get color() {
      return this.raw.color;
    }
  }
  function _storyInteractiveElementFromTl(raw, peers) {
    switch (raw._) {
      case "mediaAreaSuggestedReaction":
        return new StoryInteractiveReaction(raw);
      case "mediaAreaGeoPoint":
        return new StoryInteractiveLocation(raw);
      case "mediaAreaVenue":
        return new StoryInteractiveVenue(raw);
      case "mediaAreaChannelPost":
        return new StoryInteractiveChannelPost(raw, peers);
      case "mediaAreaUrl":
        return new StoryInteractiveUrl(raw);
      case "mediaAreaWeather":
        return new StoryInteractiveWeather(raw);
      case "inputMediaAreaVenue":
      case "inputMediaAreaChannelPost":
        throw new MtTypeAssertionError("StoryInteractiveElement", "!input*", raw._);
    }
  }
  class ReactionCount {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Emoji representing the reaction
     */
    get emoji() {
      return toReactionEmoji(this.raw.reaction);
    }
    /** Whether this is a paid reaction */
    get isPaid() {
      return this.raw.reaction._ === "reactionPaid";
    }
    /**
     * Number of users who reacted with this emoji
     */
    get count() {
      return this.raw.count;
    }
    /**
     * If the current user has reacted with this emoji,
     * this field will contain the order in which the
     * reaction was added.
     */
    get order() {
      var _a2;
      return (_a2 = this.raw.chosenOrder) != null ? _a2 : null;
    }
  }
  class StoryInteractions {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Whether information about viewers is available.
     *
     * When `true`, you can use {@link TelegarmClient.getStoryViewers}
     * to get the full list of viewers, and also {@link recentViewers}
     * will be available.
     */
    get hasViewers() {
      return this.raw.hasViewers;
    }
    /** Number of views */
    get viewsCount() {
      return this.raw.viewsCount;
    }
    /** Number of forwards (if available) */
    get forwardsCount() {
      var _a2;
      return (_a2 = this.raw.forwardsCount) != null ? _a2 : null;
    }
    /** Total number of reactions */
    get reactionsCount() {
      var _a2;
      return (_a2 = this.raw.reactionsCount) != null ? _a2 : 0;
    }
    /**
     * Reactions on the message, along with their counts
     */
    get reactions() {
      if (!this.raw.reactions)
        return [];
      return this.raw.reactions.map((it) => new ReactionCount(it));
    }
    /**
     * List of users who have recently viewed this story.
     */
    get recentViewers() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.recentViewers) == null ? void 0 : _a2.map((it) => new User(this._peers.user(it)))) != null ? _b : [];
    }
  }
  memoizeGetters(StoryInteractions, ["reactions", "recentViewers"]);
  class Story {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** Whether this story is pinned */
    get isPinned() {
      return this.raw.pinned;
    }
    /**
     * Whether this object contains reduced set of fields.
     *
     * When `true`, these field will not contain correct data:
     * {@link privacyRules}, {@link interactiveAreas}
     *
     */
    get isShort() {
      return this.raw.min;
    }
    /** Whether this story is content-protected, i.e. can't be forwarded */
    get isContentProtected() {
      return this.raw.noforwards;
    }
    /** Whether this story has been edited */
    get isEdited() {
      return this.raw.edited;
    }
    /** Whether this story has been posted by the current user */
    get isMy() {
      return this.raw.out;
    }
    /** ID of the story */
    get id() {
      return this.raw.id;
    }
    /** Date when this story was posted */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /** Date when this story will expire */
    get expireDate() {
      return new Date(this.raw.expireDate * 1e3);
    }
    /** Whether the story is active (i.e. not expired yet) */
    get isActive() {
      return Date.now() < this.expireDate.getTime();
    }
    /** Story visibility */
    get visibility() {
      if (this.raw.public)
        return "public";
      if (this.raw.contacts)
        return "contacts";
      if (this.raw.closeFriends)
        return "close_friends";
      if (this.raw.selectedContacts)
        return "selected_contacts";
      throw new MtUnsupportedError("Unknown story visibility");
    }
    /** Caption of the story */
    get caption() {
      var _a2;
      return (_a2 = this.raw.caption) != null ? _a2 : null;
    }
    /**
     * Caption entities (may be empty)
     */
    get entities() {
      var _a2;
      const entities = [];
      if ((_a2 = this.raw.entities) == null ? void 0 : _a2.length) {
        for(let   ent of this.raw.entities) {
          entities.push(new MessageEntity(ent, this.raw.caption));
        }
      }
      return entities;
    }
    /**
     * Story media.
     *
     * Currently, can only be {@link Photo} or {@link Video}.
     */
    get media() {
      var _a2, _b;
      switch (this.raw.media._) {
        case "messageMediaPhoto":
          if (((_a2 = this.raw.media.photo) == null ? void 0 : _a2._) !== "photo")
            throw new MtUnsupportedError("Unsupported story media type");
          return new Photo(this.raw.media.photo, this.raw.media);
        case "messageMediaDocument": {
          if (((_b = this.raw.media.document) == null ? void 0 : _b._) !== "document") {
            throw new MtUnsupportedError("Unsupported story media type");
          }
          const doc = parseDocument(this.raw.media.document, this.raw.media);
          if (doc.type === "video")
            return doc;
        }
      }
      throw new MtUnsupportedError("Unsupported story media type");
    }
    /**
     * Interactive elements of the story
     */
    get interactiveElements() {
      if (!this.raw.mediaAreas)
        return [];
      return this.raw.mediaAreas.map((it) => _storyInteractiveElementFromTl(it, this._peers));
    }
    /**
     * Privacy rules of the story.
     *
     * Only available when {@link isMy} is `true`.
     */
    get privacyRules() {
      if (!this.raw.privacy)
        return null;
      return this.raw.privacy;
    }
    /**
     * Information about story interactions
     */
    get interactions() {
      if (!this.raw.views)
        return null;
      return new StoryInteractions(this.raw.views, this._peers);
    }
    /**
     * Emoji representing a reaction sent by the current user, if any
     */
    get sentReactionEmoji() {
      if (!this.raw.sentReaction)
        return null;
      return toReactionEmoji(this.raw.sentReaction, true);
    }
  }
  memoizeGetters(Story, ["entities", "media", "interactiveElements", "interactions"]);
  class MediaStory {
    constructor(raw, _peers) {
      __publicField(this, "type", "story");
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Whether this story was automatically forwarded to you
     * because you were mentioned in it
     */
    get isMention() {
      return this.raw.viaMention;
    }
    /**
     * Peer who has posted this story
     */
    get peer() {
      return parsePeer(this.raw.peer, this._peers);
    }
    /**
     * ID of the story
     */
    get storyId() {
      return this.raw.id;
    }
    /**
     * Contents of the story. May not be available, in which case the story
     * should be fetched using {@link getStoriesById}
     */
    get story() {
      var _a2;
      if (((_a2 = this.raw.story) == null ? void 0 : _a2._) !== "storyItem")
        return null;
      return new Story(this.raw.story, this._peers);
    }
    get inputMedia() {
      return {
        _: "inputMediaStory",
        peer: this.peer.inputPeer,
        id: this.raw.id
      };
    }
  }
  class Venue {
    constructor(raw) {
      __publicField(this, "type", "venue");
      this.raw = raw;
    }
    /**
     * Geolocation of the venue
     */
    get location() {
      assertTypeIs("Venue#location", this.raw.geo, "geoPoint");
      return new Location(this.raw.geo);
    }
    /**
     * Venue name
     */
    get title() {
      return this.raw.title;
    }
    /**
     * Venue address
     */
    get address() {
      return this.raw.address;
    }
    /**
     * When available, source from where this venue was acquired
     */
    get source() {
      if (!this.raw.provider)
        return null;
      return {
        provider: this.raw.provider,
        id: this.raw.venueId,
        type: this.raw.venueType
      };
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}
     *
     * A few notes:
     *  - Using this will result in an
     *    independent poll, which will not
     *    be auto-updated with the current.
     *  - If this is a quiz, a normal poll
     *    will be returned since the client does not
     *    know the correct answer.
     *  - This always returns a non-closed poll,
     *    even if the current poll was closed
     */
    get inputMedia() {
      return {
        _: "inputMediaVenue",
        geoPoint: {
          _: "inputGeoPoint",
          lat: this.raw.geo.lat,
          long: this.raw.geo.long,
          accuracyRadius: this.raw.geo.accuracyRadius
        },
        title: this.raw.title,
        address: this.raw.address,
        provider: this.raw.provider,
        venueId: this.raw.venueId,
        venueType: this.raw.venueType
      };
    }
  }
  memoizeGetters(Venue, ["location", "source"]);
  class WebPage {
    constructor(raw) {
      __publicField(this, "type", "webpage");
      this.raw = raw;
    }
    /**
     * Unique ID of the preview
     */
    get id() {
      return this.raw.id;
    }
    /**
     * Original page URL
     */
    get url() {
      return this.raw.url;
    }
    /**
     * URL to be displayed to the user.
     *
     * Usually a normal URL with stripped protocol and garbage.
     */
    get displayUrl() {
      return this.raw.displayUrl;
    }
    /**
     * Type of the preview, taken directly from TL object
     *
     * Officially documented are:
     * `article, photo, audio, video, document, profile, app`,
     * but also these are encountered:
     * `telegram_user, telegram_bot, telegram_channel, telegram_megagroup, telegram_story`:
     *
     * - `telegram_*` ones seem to be used for `t.me` links.
     * - `article` seems to be used for almost all custom pages with `og:*` tags
     * - `photo`, `audio` and `video` seem to be derived from `og:type`,
     *    and the page itself may contain a preview photo and an embed link
     *    for the player. This may not correctly represent actual content type:
     *    Spotify links are `audio`, but SoundCloud are `video`. YouTube links are `video`,
     *    but tweets with video are `photo`.
     * - `document` seem to be used for files downloadable directly from the URL,
     *    like PDFs, audio files, videos, etc. {@link document} seem to be
     *    present if `type` is `document`.
     * - `profile` doesn't seem to be used
     * - `app` doesn't seem to be used
     *
     * `unknown` is returned if no type is returned in the TL object.
     */
    get previewType() {
      return this.raw.type || "unknown";
    }
    /**
     * Page title
     *
     * Usually defined by `og:site_name` meta tag or website domain
     */
    get siteName() {
      var _a2;
      return (_a2 = this.raw.siteName) != null ? _a2 : null;
    }
    /**
     * Page title
     *
     * Usually defined by `og:title` meta tag or `<title>` tag
     */
    get title() {
      var _a2;
      return (_a2 = this.raw.title) != null ? _a2 : null;
    }
    /**
     * Page description
     *
     * Usually defined by `description` or `og:description` meta tag
     */
    get description() {
      var _a2;
      return (_a2 = this.raw.description) != null ? _a2 : null;
    }
    /**
     * Page author
     *
     * The source for this is unknown, seems to be
     * custom-made for services like Twitter.
     *
     * In official apps this seems to be used as a fallback for description.
     */
    get author() {
      var _a2;
      return (_a2 = this.raw.author) != null ? _a2 : null;
    }
    /**
     * The embed URL.
     *
     * Based on my research, Telegram only allows
     * embedding pages from a server-side white-list of domains.
     *
     * That is, you can't just copy-paste meta tags
     * from YouTube to your own domain and expect Telegram
     * to return a webpage with embed.
     *
     * IDK why is that, maybe they are concerned about
     * leaking users' IPs to 3rd parties or something
     * (but why allow embedding in the first place then?)
     *
     * Telegram for Android does not show "play" button for
     * webpages without embeds, and instead treats it like a simple
     * photo (why?).
     *
     * TDesktop does not support embeds and seems
     * to use {@link type} to determine them, and specifically
     * [checks](https://github.com/telegramdesktop/tdesktop/blob/3343880ed0e5a86accc7334af54b3470e29ee686/Telegram/SourceFiles/history/view/media/history_view_web_page.cpp#L561)
     * for `YouTube` in {@link siteName} to display YouTube icon.
     */
    get embedUrl() {
      var _a2;
      return (_a2 = this.raw.embedUrl) != null ? _a2 : null;
    }
    /**
     * Embed type.
     *
     * Now this is actually stupid.
     * As per [official documentation](https://core.telegram.org/constructor/webPage),
     * `embed_type` contains Â«MIME type of the embedded preview, (e.g., text/html or video/mp4)Â».
     * But in fact every time I encountered it it contained a simple string `iframe`.
     *
     * I couldn't find any usage of this field in official apps either.
     */
    get embedType() {
      var _a2;
      return (_a2 = this.raw.embedType) != null ? _a2 : null;
    }
    /**
     * Width of the embed in pixels, 0 if not available.
     */
    get embedWidth() {
      return this.raw.embedWidth || 0;
    }
    /**
     * Height of the embed in pixels, 0 if not available.
     */
    get embedHeight() {
      return this.raw.embedHeight || 0;
    }
    /**
     * A photo inside this webpage preview.
     *
     * Used for most of the preview types.
     */
    get photo() {
      var _a2;
      if (((_a2 = this.raw.photo) == null ? void 0 : _a2._) !== "photo") {
        return null;
      }
      return new Photo(this.raw.photo);
    }
    /**
     * Document inside this webpage preview.
     *
     * Seems that this is only used for `document` previews.
     *
     * Can be a {@link Photo}, {@link Video},
     * {@link Audio}, {@link Document}.
     */
    get document() {
      var _a2;
      if (((_a2 = this.raw.document) == null ? void 0 : _a2._) !== "document") {
        return null;
      }
      return parseDocument(this.raw.document);
    }
    /**
     * Input media TL object generated from this object,
     * to be used inside {@link InputMediaLike} and
     * {@link TelegramClient.sendMedia}.
     *
     * WebPage can't provide an input media, since some
     * can only be auto-generated from a link. This getter
     * is only provided to allow using `msg.media.inputMedia`
     */
    get inputMedia() {
      throw new MtArgumentError("WebPage cannot provide an InputMedia");
    }
  }
  memoizeGetters(WebPage, ["photo", "document"]);
  function _messageMediaFromTl(peers, m2) {
    var _a2, _b, _c;
    switch (m2._) {
      case "messageMediaPhoto":
        if (!(((_a2 = m2.photo) == null ? void 0 : _a2._) === "photo"))
          return null;
        return new Photo(m2.photo, m2);
      case "messageMediaDice":
        return new Dice(m2);
      case "messageMediaContact":
        return new Contact(m2);
      case "messageMediaDocument":
        if (!(((_b = m2.document) == null ? void 0 : _b._) === "document"))
          return null;
        return parseDocument(m2.document, m2);
      case "messageMediaGeo":
        if (!(m2.geo._ === "geoPoint"))
          return null;
        return new Location(m2.geo);
      case "messageMediaGeoLive":
        if (!(m2.geo._ === "geoPoint"))
          return null;
        return new LiveLocation(m2);
      case "messageMediaGame":
        return new Game(m2.game);
      case "messageMediaWebPage":
        if (!(m2.webpage._ === "webPage"))
          return null;
        return new WebPage(m2.webpage);
      case "messageMediaVenue":
        return new Venue(m2);
      case "messageMediaPoll":
        if (!peers) {
          throw new MtTypeAssertionError("can't create poll without peers index", "PeersIndex", "null");
        }
        return new Poll(m2.poll, peers, m2.results);
      case "messageMediaInvoice": {
        const extended = ((_c = m2.extendedMedia) == null ? void 0 : _c._) === "messageExtendedMedia" ? _messageMediaFromTl(peers, m2.extendedMedia.media) : null;
        return new Invoice(m2, extended);
      }
      case "messageMediaStory": {
        if (!peers) {
          throw new MtTypeAssertionError("can't create story without peers index", "PeersIndex", "null");
        }
        return new MediaStory(m2, peers);
      }
      case "messageMediaPaidMedia": {
        const extended = [];
        m2.extendedMedia.forEach((e) => {
          if (e._ !== "messageExtendedMedia")
            return;
          extended.push(_messageMediaFromTl(peers, e.media));
        });
        return new PaidMedia(m2, extended);
      }
      default:
        return null;
    }
  }
  class MessageReactions {
    constructor(messageId, chatId, raw, _peers) {
      this.messageId = messageId;
      this.chatId = chatId;
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Whether you can use {@link getUsers}
     * (or {@link TelegramClient.getReactionUsers})
     * to get the users who reacted to this message
     */
    get usersVisible() {
      return this.raw.canSeeList;
    }
    /**
     * Reactions on the message, along with their counts
     */
    get reactions() {
      return this.raw.results.map((it) => new ReactionCount(it));
    }
    /**
     * Recently reacted users.
     * To get a full list of users, use {@link getUsers}
     */
    get recentReactions() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.recentReactions) == null ? void 0 : _a2.map((reaction) => new PeerReaction(reaction, this._peers))) != null ? _b : [];
    }
    /** Leaderboard of paid reactions to the message */
    get paidReactions() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.topReactors) == null ? void 0 : _a2.map((reaction) => new PaidPeerReaction(reaction, this._peers))) != null ? _b : [];
    }
  }
  memoizeGetters(MessageReactions, ["reactions", "recentReactions"]);
  class MessageRepliesInfo {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Whether this message is a channel post that has a comments thread
     * in the linked discussion group
     */
    get hasComments() {
      return this.raw.comments;
    }
    /**
     * Total number of replies
     */
    get count() {
      return this.raw.replies;
    }
    /**
     * Whether this reply thread has unread messages
     */
    get hasUnread() {
      return this.raw.readMaxId !== void 0 && this.raw.readMaxId !== this.raw.maxId;
    }
    /**
     * ID of the last message in the thread (if any)
     */
    get lastMessageId() {
      var _a2;
      return (_a2 = this.raw.maxId) != null ? _a2 : null;
    }
    /**
     * ID of the last read message in the thread (if any)
     */
    get lastReadMessageId() {
      var _a2;
      return (_a2 = this.raw.readMaxId) != null ? _a2 : null;
    }
    /**
     * ID of the discussion group for the post
     *
     * `null` if the post is not a channel post
     */
    get discussion() {
      if (!this.raw.channelId)
        return null;
      return getMarkedPeerId(this.raw.channelId, "channel");
    }
    /**
     * Last few commenters to the post (usually 3)
     */
    get repliers() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.recentRepliers) == null ? void 0 : _a2.map((it) => parsePeer(it, this._peers))) != null ? _b : [];
    }
  }
  memoizeGetters(MessageRepliesInfo, ["discussion", "repliers"]);
  class RepliedMessageInfo {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** Whether this message is a reply to another scheduled message */
    get isScheduled() {
      return this.raw.replyToScheduled;
    }
    /** Whether this message was sent to a forum topic */
    get isForumTopic() {
      return this.raw.forumTopic;
    }
    /** Whether this message is quoting another message */
    get isQuote() {
      return this.raw.quote;
    }
    /** Origin of the replied-to message */
    get origin() {
      if (!this.raw.replyToMsgId)
        return "private";
      if (!this.raw.replyFrom)
        return "same_chat";
      return "other_chat";
    }
    /**
     * Helper method to check {@link origin} that will also
     * narrow the type of this object respectively
     */
    originIs(origin) {
      var _a2;
      if (this.origin === origin) {
        switch (origin) {
          case "same_chat":
            return true;
          case "other_chat":
            return this.raw.replyToPeerId !== void 0;
          case "private":
            return ((_a2 = this.raw.replyFrom) == null ? void 0 : _a2.fromId) !== void 0;
        }
      }
      return false;
    }
    /**
     * For non-`private` origin, ID of the replied-to message in the original chat.
     */
    get id() {
      var _a2;
      return (_a2 = this.raw.replyToMsgId) != null ? _a2 : null;
    }
    /** ID of the replies thread where this message belongs to */
    get threadId() {
      var _a2;
      return (_a2 = this.raw.replyToTopId) != null ? _a2 : null;
    }
    /**
     * If replied-to message is available, chat where the message was sent.
     *
     * If `null`, the message was sent in the same chat.
     */
    get chat() {
      if (!this.raw.replyToPeerId || !this.raw.replyFrom) {
        return null;
      }
      return Chat._parseFromPeer(this.raw.replyToPeerId, this._peers);
    }
    /**
     * Sender of the replied-to message (either user or a channel)
     * or their name (for users with private forwards).
     *
     * For replies to channel messages, this will be the channel itself.
     *
     * `null` if the sender is not available (for `same_chat` origin)
     */
    get sender() {
      var _a2;
      const { replyFrom, replyToPeerId } = this.raw;
      if (!replyFrom && !replyToPeerId)
        return null;
      if (replyFrom == null ? void 0 : replyFrom.fromName) {
        return {
          type: "anonymous",
          displayName: replyFrom.fromName
        };
      }
      const peer = (_a2 = replyFrom == null ? void 0 : replyFrom.fromId) != null ? _a2 : replyToPeerId;
      if (peer) {
        switch (peer._) {
          case "peerChannel":
            return new Chat(this._peers.chat(peer.channelId));
          case "peerUser":
            return new User(this._peers.user(peer.userId));
          default:
            throw new MtTypeAssertionError("fromId ?? replyToPeerId", "peerUser | peerChannel", peer._);
        }
      }
      throw new MtTypeAssertionError("replyFrom", "to have fromId, replyToPeerId or fromName", "neither");
    }
    /**
     * For non-`same_chat` origin, date the original message was sent.
     */
    get date() {
      var _a2;
      if (!((_a2 = this.raw.replyFrom) == null ? void 0 : _a2.date))
        return null;
      return new Date(this.raw.replyFrom.date * 1e3);
    }
    /**
     * If this message is a quote, text of the quote.
     *
     * For non-`same_chat` origin, this will be the full text of the
     * replied-to message in case `.isQuote` is `false`
     */
    get quoteText() {
      var _a2;
      return (_a2 = this.raw.quoteText) != null ? _a2 : "";
    }
    /** Message entities contained in the quote */
    get quoteEntities() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.quoteEntities) == null ? void 0 : _a2.map((e) => new MessageEntity(e))) != null ? _b : [];
    }
    /**
     * Offset of the start of the {@link quoteText} in the replied-to message.
     *
     * Note that this offset should only be used as a hint, as the actual
     * quote offset may be different due to message being edited after the quote
     *
     * `null` if not available, in which case it should be assumed that the quote
     * starts at `.indexOf(quoteText)` of the replied-to message text.
     */
    get quoteOffset() {
      if (!this.raw.quoteOffset)
        return null;
      return this.raw.quoteOffset;
    }
    /**
     * Media contained in the replied-to message
     *
     * Only available for non-`same_chat` origin
     */
    get media() {
      if (!this.raw.replyMedia)
        return null;
      return _messageMediaFromTl(this._peers, this.raw.replyMedia);
    }
  }
  memoizeGetters(RepliedMessageInfo, ["chat", "sender", "quoteEntities", "media"]);
  class Message {
    constructor(raw, _peers, isScheduled = false) {
      /**
       * Raw TL object.
       */
      __publicField(this, "raw");
      this._peers = _peers;
      this.isScheduled = isScheduled;
      assertTypeIsNot("Message#ctor", raw, "messageEmpty");
      this.raw = raw;
    }
    /** Unique message identifier inside this chat */
    get id() {
      return this.raw.id;
    }
    /**
     * For channel posts, number of views
     *
     * `null` for service messages and non-post messages.
     */
    get views() {
      var _a2;
      return this.raw._ === "message" ? (_a2 = this.raw.views) != null ? _a2 : null : null;
    }
    /**
     * For channel posts, number of forwards
     *
     * `null` for service messages and non-post messages, or
     * if the current user is not an admin in the channel
     */
    get forwards() {
      var _a2;
      return this.raw._ === "message" ? (_a2 = this.raw.forwards) != null ? _a2 : null : null;
    }
    /**
     * For channel posts with signatures enabled, name of the post author
     */
    get signature() {
      var _a2;
      return this.raw._ === "message" ? (_a2 = this.raw.postAuthor) != null ? _a2 : null : null;
    }
    /**
     * Whether the message is incoming or outgoing:
     *  - Messages received from other chats are incoming (`outgoing = false`)
     *  - Messages sent by you to other chats are outgoing (`outgoing = true`)
     *  - Messages to yourself (i.e. *Saved Messages*) are incoming (`outgoing = false`)
     */
    get isOutgoing() {
      return this.raw.out;
    }
    /**
     * Whether this message is a service message
     */
    get isService() {
      return this.raw._ === "messageService";
    }
    /** Whether this message has content protection (i.e. disabled forwards) */
    get isContentProtected() {
      return this.raw._ === "message" && this.raw.noforwards;
    }
    /**
     * Whether the message was sent by an implicit action, for example,
     * as an away or a greeting business message, or as a scheduled message
     */
    get isFromOffline() {
      return this.raw._ === "message" && this.raw.offline;
    }
    /** Whether this is a silent message (no notification triggered) */
    get isSilent() {
      return this.raw.silent;
    }
    /** Whether there are unread media attachments in this message */
    get hasUnreadMedia() {
      return this.raw.mediaUnread;
    }
    /** Whether this is a broadcast channel post */
    get isChannelPost() {
      return this.raw._ === "message" && this.raw.post;
    }
    /**
     * Whether this message was automatically sent from a scheduled message.
     *
     * **Note**: for messages sent by other users, this is always `false`.
     */
    get isFromScheduled() {
      return this.raw._ === "message" && this.raw.fromScheduled;
    }
    /** Whether the message is pinned in the current chat */
    get isPinned() {
      return this.raw._ === "message" && this.raw.pinned;
    }
    /** Whether the message should be considered unedited, even if {@link editDate} â  null */
    get hideEditMark() {
      return this.raw._ === "message" && this.raw.editHide;
    }
    /**
     * If set, any eventual webpage preview should be shown on top of
     * the message instead of at the bottom.
     */
    get invertMedia() {
      return this.raw._ === "message" && this.raw.invertMedia;
    }
    /**
     * Multiple media messages with the same grouped ID
     * indicate an album or media group
     *
     * `null` for service messages and non-grouped messages
     */
    get groupedId() {
      var _a2;
      return this.raw._ === "message" ? (_a2 = this.raw.groupedId) != null ? _a2 : null : null;
    }
    /**
     * Same as {@link groupedId}, but is globally unique across chats.
     */
    get groupedIdUnique() {
      if (!(this.raw._ === "message" && this.raw.groupedId !== void 0))
        return null;
      return `${this.raw.groupedId.low}|${this.raw.groupedId.high}|${getMarkedPeerId(this.raw.peerId)}`;
    }
    /**
     * Message sender.
     *
     * Usually is a {@link User}, but can be a {@link Chat}
     * in case the message was sent by an anonymous admin, anonymous premium user,
     * or if the message is a forwarded channel post.
     *
     * If the message was sent by an anonymous admin,
     * sender will equal to {@link chat}.
     *
     * If the message is a forwarded channel post,
     * sender is the channel itself.
     */
    get sender() {
      const from = this.raw.fromId;
      if (!from) {
        if (this.raw.peerId._ === "peerUser") {
          return new User(this._peers.user(this.raw.peerId.userId));
        }
        return this.chat;
      }
      return parsePeer(from, this._peers);
    }
    /**
     * Number of boosts applied to this {@link chat} by the sender
     */
    get senderBoostCount() {
      var _a2;
      if (this.raw._ !== "message")
        return 0;
      return (_a2 = this.raw.fromBoostsApplied) != null ? _a2 : 0;
    }
    /**
     * Conversation the message belongs to
     */
    get chat() {
      return Chat._parseFromMessage(this.raw, this._peers);
    }
    /**
     * Date when the message was sent
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Date when the message was last edited
     */
    get editDate() {
      if (this.raw._ === "messageService")
        return null;
      return this.raw.editDate ? new Date(this.raw.editDate * 1e3) : null;
    }
    /**
     * If this message is a forward, contains info about it.
     */
    get forward() {
      if (this.raw._ !== "message" || !this.raw.fwdFrom) {
        return null;
      }
      return new MessageForwardInfo(this.raw.fwdFrom, this._peers);
    }
    /**
     * Whether the message is a channel post that was
     * automatically forwarded to the connected discussion group
     */
    get isAutomaticForward() {
      var _a2;
      if (this.raw._ === "messageService" || !this.raw.fwdFrom)
        return false;
      const fwd = this.raw.fwdFrom;
      return Boolean(
        this.chat.chatType === "supergroup" && fwd.savedFromMsgId && ((_a2 = fwd.savedFromPeer) == null ? void 0 : _a2._) === "peerChannel" && getMarkedPeerId(fwd.savedFromPeer) !== getMarkedPeerId(this.raw.peerId)
      );
    }
    /**
     * Information about comments (for channels) or replies (for groups)
     */
    get replies() {
      if (this.raw._ !== "message" || !this.raw.replies)
        return null;
      return new MessageRepliesInfo(this.raw.replies, this._peers);
    }
    /**
     * For replies, information about the that is being replied to.
     *
     * Mutually exclusive with {@link replyToStory}
     */
    get replyToMessage() {
      var _a2;
      if (((_a2 = this.raw.replyTo) == null ? void 0 : _a2._) !== "messageReplyHeader")
        return null;
      return new RepliedMessageInfo(this.raw.replyTo, this._peers);
    }
    /**
     * For replies, information about the story that is being replied to
     *
     * Mutually exclusive with {@link replyToMessage}
     */
    get replyToStory() {
      var _a2;
      if (((_a2 = this.raw.replyTo) == null ? void 0 : _a2._) !== "messageReplyStoryHeader")
        return null;
      return this.raw.replyTo;
    }
    /** Whether this message is in a forum topic */
    get isTopicMessage() {
      var _a2;
      if (((_a2 = this.raw.replyTo) == null ? void 0 : _a2._) !== "messageReplyHeader")
        return false;
      return this.raw.replyTo.forumTopic;
    }
    /**
     * Whether this message contains mention of the current user
     */
    get isMention() {
      return this.raw.mentioned;
    }
    /**
     * If non-null, this message is not actually sent, and is
     * instead inside a group of "quick reply" messages
     * under the given shortcut ID
     */
    get quickReplyShortcutId() {
      var _a2;
      if (this.raw._ === "messageService")
        return null;
      return (_a2 = this.raw.quickReplyShortcutId) != null ? _a2 : null;
    }
    /**
     * If this message is generated from an inline query,
     * information about the bot which generated it
     */
    get viaBot() {
      if (this.raw._ === "messageService" || !this.raw.viaBotId) {
        return null;
      }
      return new User(this._peers.user(this.raw.viaBotId));
    }
    /**
     * If this message was sent by a business bot on behalf of {@link sender},
     * information about the business bot.
     *
     * **Note**: only available to the business account and the bot itself.
     */
    get viaBusinessBot() {
      if (this.raw._ === "messageService" || !this.raw.viaBusinessBotId) {
        return null;
      }
      return new User(this._peers.user(this.raw.viaBusinessBotId));
    }
    /**
     * Message text or media caption.
     *
     * Empty string for service messages
     * (you should handle i18n yourself)
     */
    get text() {
      return this.raw._ === "messageService" ? "" : this.raw.message;
    }
    /**
     * Message text/caption entities (may be empty)
     */
    get entities() {
      var _a2;
      const entities = [];
      if (this.raw._ === "message" && ((_a2 = this.raw.entities) == null ? void 0 : _a2.length)) {
        for(let   ent of this.raw.entities) {
          entities.push(new MessageEntity(ent, this.raw.message));
        }
      }
      return entities;
    }
    get textWithEntities() {
      if (this.raw._ === "messageService")
        return { text: "", entities: [] };
      return {
        text: this.raw.message,
        entities: this.raw.entities
      };
    }
    /**
     * Message action. `null` for non-service messages
     * or for unsupported events.
     *
     * For unsupported events, use `.raw.action` directly.
     */
    get action() {
      if (this.raw._ === "message") {
        return null;
      }
      return _messageActionFromTl.call(this, this.raw.action);
    }
    /**
     * Message media. `null` for text-only and service messages
     * and for unsupported media types.
     *
     * For unsupported media types, use `.raw.media` directly.
     */
    get media() {
      if (this.raw._ === "messageService" || !this.raw.media || this.raw.media._ === "messageMediaEmpty") {
        return null;
      }
      return _messageMediaFromTl(this._peers, this.raw.media);
    }
    /**
     * Whether this is a premium media
     * (e.g. >2gb file or fullscreen sticker)
     * that was forwarded without author by a non-premium user
     */
    get isForwardedPremiumMedia() {
      var _a2;
      return this.raw._ === "message" && ((_a2 = this.raw.media) == null ? void 0 : _a2._) === "messageMediaDocument" && this.raw.media.nopremium;
    }
    /**
     * TTL period of the message, in seconds.
     */
    get ttlPeriod() {
      var _a2;
      return (_a2 = this.raw.ttlPeriod) != null ? _a2 : null;
    }
    /**
     * Reply markup provided with this message, if any.
     */
    get markup() {
      if (this.raw._ === "messageService" || !this.raw.replyMarkup) {
        return null;
      }
      const rm = this.raw.replyMarkup;
      switch (rm._) {
        case "replyKeyboardHide":
          return {
            type: "reply_hide",
            selective: rm.selective
          };
        case "replyKeyboardForceReply":
          return {
            type: "force_reply",
            singleUse: rm.singleUse,
            selective: rm.selective
          };
        case "replyKeyboardMarkup":
          return {
            type: "reply",
            resize: rm.resize,
            singleUse: rm.singleUse,
            selective: rm.selective,
            buttons: _rowsTo2d(rm.rows)
          };
        case "replyInlineMarkup":
          return {
            type: "inline",
            buttons: _rowsTo2d(rm.rows)
          };
        default:
          assertNever$1();
      }
    }
    /**
     * Whether this message can be forwarded
     *
     * `false` for service mesasges and private restricted chats/chanenls
     */
    get canBeForwarded() {
      return this.raw._ === "message" && !this.raw.noforwards;
    }
    /**
     * Reactions added to this message, if any
     */
    get reactions() {
      if (this.raw._ === "messageService" || !this.raw.reactions) {
        return null;
      }
      return new MessageReactions(this.raw.id, getMarkedPeerId(this.raw.peerId), this.raw.reactions, this._peers);
    }
    /**
     * Information about fact-check added to the message, if any
     */
    get factCheck() {
      if (this.raw._ === "messageService")
        return null;
      if (!this.raw.factcheck || this.raw.factcheck.hash.isZero())
        return null;
      return new FactCheck(this.raw.factcheck);
    }
    /**
     * If this message was sent with a message effect, ID of the effect
     */
    get effectId() {
      var _a2;
      if (this.raw._ === "messageService")
        return null;
      return (_a2 = this.raw.effect) != null ? _a2 : null;
    }
    /**
     * Generated permalink to this message, only for groups and channels
     *
     * @throws MtArgumentError  In case the chat does not support message links
     */
    get link() {
      if (this.chat.chatType === "supergroup" || this.chat.chatType === "channel") {
        if (this.chat.username) {
          return `https://t.me/${this.chat.username}/${this.id}`;
        }
        return `https://t.me/c/${toggleChannelIdMark(this.chat.id)}/${this.id}`;
      }
      throw new MtArgumentError(`Cannot generate message link for ${this.chat.chatType}`);
    }
  }
  memoizeGetters(Message, [
    "sender",
    "chat",
    "forward",
    "replies",
    "viaBot",
    "entities",
    "action",
    "media",
    "markup",
    "reactions",
    "factCheck"
  ]);
  class Dialog {
    constructor(raw, _peers, _messages) {
      this.raw = raw;
      this._peers = _peers;
      this._messages = _messages;
    }
    /**
     * Parse a list of dialogs from a TL object
     *
     * @param client  Client instance
     * @param dialogs  TL object
     * @param limit  Maximum number of dialogs to parse
     */
    static parseTlDialogs(dialogs, limit) {
      assertTypeIsNot("parseDialogs", dialogs, "messages.dialogsNotModified");
      const peers = PeersIndex.from(dialogs);
      const messages = /* @__PURE__ */ new Map();
      dialogs.messages.forEach((msg) => {
        if (!msg.peerId)
          return;
        messages.set(getMarkedPeerId(msg.peerId), msg);
      });
      const arr = dialogs.dialogs.filter(hasValueAtKey("_", "dialog")).map((it) => new Dialog(it, peers, messages));
      if (limit) {
        return arr.slice(0, limit);
      }
      return arr;
    }
    /**
     * Find pinned dialogs from a list of dialogs
     *
     * @param dialogs  Dialogs list
     * @param folder  If passed, status of pin will be checked against this folder, and not globally
     */
    static findPinned(dialogs, folder) {
      if (folder) {
        const index = {};
        folder.pinnedPeers.forEach((peer) => {
          index[getMarkedPeerId(peer)] = true;
        });
        return dialogs.filter((i) => index[i.chat.id]);
      }
      return dialogs.filter((i) => i.isPinned);
    }
    /**
     * Create a filter predicate for the given Folder.
     * Returned predicate can be used in `Array.filter()`
     *
     * @param folder  Folder to filter for
     * @param excludePinned  Whether to exclude pinned folders
     */
    static filterFolder(folder, excludePinned = true) {
      if (folder._ === "dialogFilterDefault") {
        return () => true;
      }
      const pinned = {};
      const include = {};
      const exclude = {};
      if (excludePinned) {
        folder.pinnedPeers.forEach((peer) => {
          pinned[getMarkedPeerId(peer)] = true;
        });
      }
      folder.includePeers.forEach((peer) => {
        include[getMarkedPeerId(peer)] = true;
      });
      if (folder._ === "dialogFilterChatlist") {
        return (dialog) => {
          const chatId = dialog.chat.id;
          if (excludePinned && pinned[chatId])
            return false;
          return include[chatId] || pinned[chatId];
        };
      }
      folder.excludePeers.forEach((peer) => {
        exclude[getMarkedPeerId(peer)] = true;
      });
      return (dialog) => {
        const chat = dialog.chat;
        const chatId = dialog.chat.id;
        const chatType = dialog.chat.chatType;
        if (include[chatId])
          return true;
        if (exclude[chatId] || excludePinned && pinned[chatId]) {
          return false;
        }
        if (folder.excludeRead && !dialog.isUnread)
          return false;
        if (folder.excludeMuted && dialog.isMuted)
          return false;
        if (folder.excludeArchived && dialog.isArchived)
          return false;
        if (folder.contacts && chatType === "private" && chat.isContact) {
          return true;
        }
        if (folder.nonContacts && chatType === "private" && !chat.isContact) {
          return true;
        }
        if (folder.groups && (chatType === "group" || chatType === "supergroup")) {
          return true;
        }
        if (folder.broadcasts && chatType === "channel")
          return true;
        if (folder.bots && chatType === "bot")
          return true;
        return false;
      };
    }
    /**
     * Whether this dialog is pinned
     */
    get isPinned() {
      return this.raw.pinned;
    }
    /**
     * Whether this chat was manually marked as unread
     */
    get isManuallyUnread() {
      return this.raw.unreadMark;
    }
    /**
     * Whether this chat should be considered unread
     * (i.e. has more than 1 unread message, or has
     * a "manually unread" mark)
     */
    get isUnread() {
      return this.raw.unreadMark || this.raw.unreadCount > 1;
    }
    /**
     * Whether this dialog is muted.
     *
     * If `null`, the default account-level setting should be used.
     */
    get isMuted() {
      var _a2;
      return (_a2 = this.raw.notifySettings.silent) != null ? _a2 : null;
    }
    /**
     * Whether this dialog is archived
     */
    get isArchived() {
      return this.raw.folderId === 1;
    }
    /**
     * Chat that this dialog represents
     */
    get chat() {
      return Chat._parseFromPeer(this.raw.peer, this._peers);
    }
    /**
     * The latest message sent in this chat (if any)
     */
    get lastMessage() {
      const cid = this.chat.id;
      if (this._messages.has(cid)) {
        return new Message(this._messages.get(cid), this._peers);
      }
      return null;
    }
    /**
     * ID of the last read outgoing message in this dialog
     */
    get lastReadOutgoing() {
      return this.raw.readOutboxMaxId;
    }
    /**
     * ID of the last read ingoing message in this dialog
     */
    get lastReadIngoing() {
      return this.raw.readInboxMaxId;
    }
    /**
     * ID of the last read message in this dialog
     */
    get lastRead() {
      return Math.max(this.raw.readOutboxMaxId, this.raw.readInboxMaxId);
    }
    /**
     * Number of unread messages
     */
    get unreadCount() {
      return this.raw.unreadCount;
    }
    /**
     * Number of unread mentions
     */
    get unreadMentionsCount() {
      return this.raw.unreadMentionsCount;
    }
    /**
     * Number of unread reactions
     */
    get unreadReactionsCount() {
      return this.raw.unreadReactionsCount;
    }
    /**
     * Draft message in this dialog
     */
    get draftMessage() {
      var _a2;
      if (((_a2 = this.raw.draft) == null ? void 0 : _a2._) === "draftMessage") {
        return new DraftMessage(this.raw.draft);
      }
      return null;
    }
    /**
     * TTL period of all messages in this dialog
     */
    get ttlPeriod() {
      var _a2;
      return (_a2 = this.raw.ttlPeriod) != null ? _a2 : null;
    }
  }
  memoizeGetters(Dialog, ["chat", "lastMessage", "draftMessage"]);
  function _normalizePeerId(peerId) {
    if (typeof peerId === "object") {
      if (tl.tl.isAnyPeer(peerId)) {
        peerId = getMarkedPeerId(peerId);
      } else if ("inputPeer" in peerId) {
        peerId = peerId.inputPeer;
      } else {
        peerId = toInputPeer(peerId);
      }
    }
    if (typeof peerId === "object") {
      switch (peerId._) {
        case "mtcute.dummyInputPeerMinUser":
          return peerId.userId;
        case "mtcute.dummyInputPeerMinChannel":
          return toggleChannelIdMark(peerId.channelId);
        default:
          return peerId;
      }
    }
    return peerId;
  }
  function resolvePeer(client, peerId, force = false) {
    return __async(this, null, function* () {
      var _a2;
      peerId = _normalizePeerId(peerId);
      if (typeof peerId === "object") {
        return peerId;
      }
      if (typeof peerId === "number" && !force) {
        const fromStorage = yield client.storage.peers.getById(peerId);
        if (fromStorage)
          return fromStorage;
      }
      if (typeof peerId === "string") {
        if (peerId === "self" || peerId === "me")
          return { _: "inputPeerSelf" };
        peerId = peerId.replace(/[@+\s()]/g, "");
        let res;
        if (peerId.match(/^\d+$/)) {
          const fromStorage = yield client.storage.peers.getByPhone(peerId);
          if (fromStorage)
            return fromStorage;
          try {
            res = yield client.call({
              _: "contacts.resolvePhone",
              phone: peerId
            });
          } catch (e) {
            if (tl.tl.RpcError.is(e, "PHONE_NOT_OCCUPIED")) {
              throw new MtPeerNotFoundError(`Peer with phone number ${peerId} was not found`);
            } else {
              throw e;
            }
          }
        } else {
          if (!force) {
            const fromStorage = yield client.storage.peers.getByUsername(peerId);
            if (fromStorage)
              return fromStorage;
          }
          try {
            res = yield client.call({
              _: "contacts.resolveUsername",
              username: peerId
            });
          } catch (e) {
            if (tl.tl.RpcError.is(e, "USERNAME_NOT_OCCUPIED")) {
              throw new MtPeerNotFoundError(`Peer with username ${peerId} was not found`);
            } else {
              throw e;
            }
          }
        }
        if (res.peer._ === "peerUser") {
          const id2 = res.peer.userId;
          const found = res.users.find((it) => it.id === id2);
          if (found && found._ === "user") {
            if (!found.accessHash) {
              throw new MtPeerNotFoundError(
                `Peer (user) with username ${peerId} was found, but it has no access hash`
              );
            }
            return {
              _: "inputPeerUser",
              userId: found.id,
              accessHash: found.accessHash
            };
          }
        } else if (res.peer._ === "peerChannel") {
          const id2 = res.peer.channelId;
          const found = res.chats.find((it) => it.id === id2);
          if (found) {
            if (!(found._ === "channel" || found._ === "channelForbidden")) {
              throw new MtTypeAssertionError("contacts.resolveUsername#chats", "channel", found._);
            }
            if (!found.accessHash) {
              throw new MtPeerNotFoundError(`Peer (channel) with ${peerId} was found, but it has no access hash`);
            }
            return {
              _: "inputPeerChannel",
              channelId: found.id,
              accessHash: found.accessHash
            };
          }
        } else {
          throw new MtTypeAssertionError("contacts.resolveUsername", "user or channel", res.peer._);
        }
        throw new MtPeerNotFoundError(`Could not find a peer by ${peerId}`);
      }
      const [peerType, bareId] = parseMarkedPeerId(peerId);
      if (!(peerType === "chat" || ((_a2 = client.storage.self.getCached(true)) == null ? void 0 : _a2.isBot))) {
        const cached = yield client.storage.peers.getCompleteById(peerId, true);
        if (cached && (cached._ === "channel" || cached._ === "user")) {
          const [username] = extractUsernames(cached);
          if (username) {
            const resolved = yield resolvePeer(client, username, true);
            if (getMarkedPeerId(resolved) === peerId) {
              return resolved;
            }
          }
          if (cached._ === "user" && cached.phone) {
            const resolved = yield resolvePeer(client, cached.phone, true);
            if (getMarkedPeerId(resolved) === peerId) {
              return resolved;
            }
          }
        }
        throw new MtPeerNotFoundError(`Peer ${peerId} is not found in local cache`);
      }
      switch (peerType) {
        case "user":
          return {
            _: "inputPeerUser",
            userId: bareId,
            accessHash: Long.ZERO
          };
        case "chat":
          return {
            _: "inputPeerChat",
            chatId: bareId
          };
        case "channel":
          return {
            _: "inputPeerChannel",
            channelId: bareId,
            accessHash: Long.ZERO
          };
      }
    });
  }
  function resolveUser(client, peerId, force = false) {
    return __async(this, null, function* () {
      return toInputUser(yield resolvePeer(client, peerId, force), peerId);
    });
  }
  function resolveChannel(client, peerId, force = false) {
    return __async(this, null, function* () {
      return toInputChannel(yield resolvePeer(client, peerId, force), peerId);
    });
  }
  function resolvePeerMany(client, peerIds, normalizer) {
    return __async(this, null, function* () {
      const ret = [];
      const limit = 8;
      if (peerIds.length < limit) {
        const res = yield Promise.all(
          peerIds.map(
            (it) => resolvePeer(client, it).catch((e) => {
              if (e instanceof MtPeerNotFoundError) {
                return null;
              }
              throw e;
            })
          )
        );
        if (!normalizer)
          return res;
        for(let   value of res) {
          if (!value)
            continue;
          const norm = normalizer(value);
          if (norm) {
            ret.push(norm);
          }
        }
        return ret;
      }
      const cv = new ConditionVariable();
      const buffer = {};
      let nextIdx = 0;
      let nextWorkerIdx = 0;
      const fetchNext = (..._0) => __async(this, [..._0], function* (idx = nextWorkerIdx++) {
        try {
          const result = yield resolvePeer(client, peerIds[idx]);
          buffer[idx] = result;
        } catch (e) {
          if (e instanceof MtPeerNotFoundError) {
            buffer[idx] = null;
          } else {
            throw e;
          }
        }
        if (nextIdx === idx) {
          cv.notify();
        }
        if (nextWorkerIdx < peerIds.length) {
          yield fetchNext(nextWorkerIdx++);
        }
      });
      let error;
      void Promise.all(Array.from({ length: limit }, (_, i) => fetchNext(i))).catch((e) => {
        client.log.debug("resolvePeerMany errored: %e", e);
        error = e;
        cv.notify();
      });
      while (nextIdx < peerIds.length) {
        yield cv.wait();
        if (error)
          throw error;
        while (nextIdx in buffer) {
          const buf = buffer[nextIdx];
          delete buffer[nextIdx];
          nextIdx++;
          if (!normalizer) {
            ret.push(buf);
            continue;
          }
          if (buf !== null) {
            const norm = normalizer(buf);
            if (norm) {
              ret.push(norm);
            }
          }
        }
      }
      return ret;
    });
  }
  function getPeerDialogs(client, peers) {
    return __async(this, null, function* () {
      if (!Array.isArray(peers))
        peers = [peers];
      const res = yield client.call({
        _: "messages.getPeerDialogs",
        peers: yield resolvePeerMany(client, peers).then(
          (peers2) => peers2.filter(isPresent).map((it) => ({
            _: "inputDialogPeer",
            peer: it
          }))
        )
      });
      return Dialog.parseTlDialogs(res);
    });
  }
  function readHistory(client, chatId, params) {
    return __async(this, null, function* () {
      const { maxId = 0, clearMentions, shouldDispatch } = params != null ? params : {};
      const peer = yield resolvePeer(client, chatId);
      if (clearMentions) {
        const res = yield client.call({
          _: "messages.readMentions",
          peer
        });
        if (!shouldDispatch) {
          if (isInputPeerChannel(peer)) {
            client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, peer.channelId));
          } else {
            client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
          }
        }
      }
      if (isInputPeerChannel(peer)) {
        const r = yield client.call({
          _: "channels.readHistory",
          channel: toInputChannel(peer),
          maxId
        });
        assertTrue("channels.readHistory", r);
      } else {
        const res = yield client.call({
          _: "messages.readHistory",
          peer,
          maxId
        });
        if (!shouldDispatch) {
          client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
        }
      }
    });
  }
  function inputTextToTl(text) {
    var _a2;
    return {
      _: "textWithEntities",
      text: typeof text === "string" ? text : text.text,
      entities: typeof text === "string" ? [] : (_a2 = text.entities) != null ? _a2 : []
    };
  }
  const FileType = typesInner.FileType;
  const EMPTY_BUFFER = new Uint8Array(0);
  function dialogPhotoToInputPeer(dialog) {
    const markedPeerId = dialog.id;
    const [peerType, peerId] = parseMarkedPeerId(markedPeerId);
    if (peerType === "user") {
      return {
        _: "inputPeerUser",
        userId: peerId,
        accessHash: dialog.accessHash
      };
    } else if (peerType === "chat") {
      return {
        _: "inputPeerChat",
        chatId: peerId
      };
    }
    return {
      _: "inputPeerChannel",
      channelId: peerId,
      accessHash: dialog.accessHash
    };
  }
  function fileIdToInputWebFileLocation(fileId) {
    if (typeof fileId === "string")
      fileId = parseFileId(getPlatform(), fileId);
    if (fileId.location._ !== "web") {
      throw new typesInner.ConversionError("inputWebFileLocation");
    }
    return {
      _: "inputWebFileLocation",
      url: fileId.location.url,
      accessHash: fileId.location.accessHash
    };
  }
  function fileIdToInputFileLocation(fileId) {
    if (typeof fileId === "string")
      fileId = parseFileId(getPlatform(), fileId);
    const loc = fileId.location;
    switch (loc._) {
      case "web":
        throw new typesInner.ConversionError("InputFileLocation");
      case "photo": {
        switch (loc.source._) {
          case "legacy":
            if (!fileId.fileReference) {
              throw new typesInner.InvalidFileIdError("Expected legacy photo to have file reference");
            }
            return {
              _: "inputPhotoLegacyFileLocation",
              fileReference: fileId.fileReference,
              id: loc.id,
              accessHash: loc.accessHash,
              volumeId: Long.ZERO,
              localId: 0,
              secret: loc.source.secret
            };
          case "thumbnail":
            if (!fileId.fileReference) {
              throw new typesInner.InvalidFileIdError("Expected thumbnail photo to have file reference");
            }
            if (loc.source.fileType !== FileType.Photo && loc.source.fileType !== FileType.Thumbnail) {
              throw new typesInner.InvalidFileIdError("Expected a thumbnail to have a correct file type");
            }
            return {
              _: loc.source.fileType === FileType.Photo ? "inputPhotoFileLocation" : "inputDocumentFileLocation",
              fileReference: fileId.fileReference,
              id: loc.id,
              accessHash: loc.accessHash,
              thumbSize: loc.source.thumbnailType
            };
          case "dialogPhoto":
            return {
              _: "inputPeerPhotoFileLocation",
              big: loc.source.big,
              peer: dialogPhotoToInputPeer(loc.source),
              photoId: loc.id
            };
          case "stickerSetThumbnail":
            return {
              _: "inputStickerSetThumb",
              stickerset: {
                _: "inputStickerSetID",
                id: loc.source.id,
                accessHash: loc.source.accessHash
              },
              thumbVersion: 0
            };
          case "fullLegacy":
            if (!fileId.fileReference) {
              throw new typesInner.InvalidFileIdError("Expected legacy photo to have file reference");
            }
            return {
              _: "inputPhotoLegacyFileLocation",
              fileReference: fileId.fileReference,
              id: loc.id,
              accessHash: loc.accessHash,
              volumeId: loc.source.volumeId,
              localId: loc.source.localId,
              secret: loc.source.secret
            };
          case "dialogPhotoLegacy":
            return {
              _: "inputPeerPhotoFileLocationLegacy",
              big: loc.source.big,
              peer: dialogPhotoToInputPeer(loc.source),
              volumeId: loc.source.volumeId,
              localId: loc.source.localId
            };
          case "stickerSetThumbnailLegacy":
            return {
              _: "inputStickerSetThumbLegacy",
              stickerset: {
                _: "inputStickerSetID",
                id: loc.source.id,
                accessHash: loc.source.accessHash
              },
              volumeId: loc.source.volumeId,
              localId: loc.source.localId
            };
          case "stickerSetThumbnailVersion":
            return {
              _: "inputStickerSetThumb",
              stickerset: {
                _: "inputStickerSetID",
                id: loc.source.id,
                accessHash: loc.source.accessHash
              },
              thumbVersion: loc.source.version
            };
          default:
            assertNever$1(loc.source);
        }
        throw new typesInner.ConversionError("inputFileLocation");
      }
      case "common": {
        if (!fileId.fileReference) {
          throw new typesInner.InvalidFileIdError("Expected common to have file reference");
        }
        if (fileId.type === FileType.Encrypted) {
          return {
            _: "inputEncryptedFileLocation",
            id: loc.id,
            accessHash: loc.accessHash
          };
        } else if (fileId.type === FileType.Secure || fileId.type === FileType.SecureRaw) {
          return {
            _: "inputSecureFileLocation",
            id: loc.id,
            accessHash: loc.accessHash
          };
        }
        return {
          _: "inputDocumentFileLocation",
          fileReference: fileId.fileReference,
          id: loc.id,
          accessHash: loc.accessHash,
          thumbSize: ""
        };
      }
      default:
        assertNever$1();
    }
  }
  function fileIdToInputDocument(fileId) {
    if (typeof fileId === "string")
      fileId = parseFileId(getPlatform(), fileId);
    if (fileId.location._ !== "common" || fileId.type === FileType.Secure || fileId.type === FileType.SecureRaw || fileId.type === FileType.Encrypted) {
      throw new typesInner.ConversionError("inputDocument");
    }
    let fileRef = fileId.fileReference;
    if (!fileRef) {
      if (fileId.type === FileType.Sticker) {
        fileRef = EMPTY_BUFFER;
      } else {
        throw new typesInner.InvalidFileIdError("Expected document to have file reference");
      }
    }
    return {
      _: "inputDocument",
      fileReference: fileRef,
      id: fileId.location.id,
      accessHash: fileId.location.accessHash
    };
  }
  function fileIdToInputPhoto(fileId) {
    if (typeof fileId === "string")
      fileId = parseFileId(getPlatform(), fileId);
    if (fileId.location._ !== "photo") {
      throw new typesInner.ConversionError("inputPhoto");
    }
    if (!fileId.fileReference) {
      throw new typesInner.InvalidFileIdError("Expected photo to have file reference");
    }
    return {
      _: "inputPhoto",
      fileReference: fileId.fileReference,
      id: fileId.location.id,
      accessHash: fileId.location.accessHash
    };
  }
  const empty = ["", void 0];
  function _normalizeInputText(client, input) {
    return __async(this, null, function* () {
      if (!input) {
        return empty;
      }
      if (typeof input === "string") {
        return [input, void 0];
      }
      const { text, entities } = input;
      if (!entities)
        return [text, void 0];
      for(let   ent of entities) {
        if (ent._ === "messageEntityMentionName") {
          try {
            const inputPeer = yield resolveUser(client, ent.userId);
            const ent_ = ent;
            ent_._ = "inputMessageEntityMentionName";
            ent_.userId = inputPeer;
          } catch (e) {
            client.log.warn("Failed to resolve mention entity for %s: %s", ent.userId, e);
          }
        }
      }
      return [text, entities];
    });
  }
  function guessFileMime(chunk) {
    if (chunk.length < 12)
      return null;
    const b0 = chunk[0];
    const b1 = chunk[1];
    if (b0 === 66 && b1 === 77)
      return "image/bmp";
    if (b0 === 77 && b1 === 90)
      return "application/x-msdownload";
    if (b0 === 31 && (b1 === 157 || b1 === 160))
      return "application/x-compress";
    if (b0 === 31 && b1 === 139)
      return "application/gzip";
    const b2 = chunk[2];
    if (b0 === 66 && b1 === 90 && b2 === 104)
      return "application/x-bzip2";
    if (b0 === 73 && b1 === 68 && b2 === 51)
      return "audio/mpeg";
    if (b0 === 255 && (b1 === 251 || b1 === 243 || b1 === 242))
      return "audio/mpeg";
    const b3 = chunk[3];
    if (b0 === 80 && b1 === 75 && b2 === 3 && b3 === 4)
      return "application/zip";
    if (b0 === 56 && b1 === 66 && b2 === 80 && b3 === 83)
      return "image/vnd.adobe.photoshop";
    if (b0 === 127 && b1 === 69 && b2 === 76 && b3 === 70)
      return "application/x-elf";
    if (b0 === 254 && b1 === 237 && b2 === 250 && b3 === 207)
      return "application/x-mach-binary";
    if (b0 === 40 && b1 === 181 && b2 === 47 && b3 === 253)
      return "application/zstd";
    if (b0 === 102 && b1 === 76 && b2 === 97 && b3 === 67)
      return "audio/x-flac";
    if (b0 === 255 && b1 === 216 && b2 === 255 && (b3 === 219 || b3 === 224 || b3 === 238 || b3 === 225)) {
      return "image/jpeg";
    }
    if (b0 === 79 && b1 === 103 && b2 === 103 && b3 === 83) {
      if (chunk.length > 36) {
        const type = String.fromCharCode(...chunk.subarray(28, 36));
        if (type === "OpusHead")
          return "audio/ogg";
        if (type.startsWith("Âtheora"))
          return "video/ogg";
        if (type.startsWith("video"))
          return "video/ogg";
        if (type.startsWith("FLAC"))
          return "audio/ogg";
        if (type.startsWith("Speex  "))
          return "audio/ogg";
        if (type.startsWith("vorbis"))
          return "audio/ogg";
      }
      return "application/ogg";
    }
    const b4 = chunk[4];
    if (b0 === 37 && b1 === 80 && b2 === 68 && b3 === 70 && b4 === 45)
      return "application/pdf";
    const b5 = chunk[5];
    if (b0 === 71 && b1 === 73 && b2 === 70 && b3 === 56) {
      if ((b4 === 55 || b4 === 57) && b5 === 97)
        return "image/gif";
    }
    if (b0 === 55 && b1 === 122 && b2 === 188 && b3 === 175 && b4 === 39 && b5 === 28) {
      return "application/x-7z-compressed";
    }
    const b6 = chunk[6];
    const b7 = chunk[7];
    if (b0 === 137 && b1 === 80 && b2 === 78 && b3 === 71 && b4 === 13 && b5 === 10 && b6 === 26 && b7 === 10) {
      return "image/png";
    }
    if (b0 === 82 && b1 === 97 && b2 === 114 && b3 === 33 && b4 === 26 && b5 === 7) {
      if (b6 === 0 || b6 === 1)
        return "application/x-rar-compressed";
    }
    if (b4 === 102 && b5 === 116 && b6 === 121 && b7 === 112 && chunk[8] & 96) {
      const brandMajor = String.fromCharCode(...chunk.subarray(8, 12)).replace(/\0/g, " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return "image/avif";
        case "mif1":
          return "image/heif";
        case "msf1":
          return "image/heif-sequence";
        case "heic":
        case "heix":
          return "image/heic";
        case "hevc":
        case "hevx":
          return "image/heic-sequence";
        case "qt":
          return "video/quicktime";
        case "M4V":
        case "M4VH":
        case "M4VP":
          return "video/x-m4v";
        case "M4A":
          return "audio/x-m4a";
        case "M4B":
        case "F4A":
        case "F4B":
          return "audio/mp4";
        case "crx":
          return "image/x-canon-cr3";
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return "video/3gpp2";
            }
            return "video/3gpp";
          }
          return "video/mp4";
      }
    }
    return null;
  }
  const MIME_TO_EXTENSION = {
    "image/bmp": "bmp",
    "application/x-msdownload": "exe",
    "application/x-compress": "z",
    "application/gzip": "gz",
    "application/x-bzip2": "bz2",
    "audio/mpeg": "mp3",
    "application/zip": "zip",
    "image/vnd.adobe.photoshop": "psd",
    "application/zstd": "zst",
    "audio/x-flac": "flac",
    "image/jpeg": "jpg",
    "audio/ogg": "ogg",
    "video/ogg": "ogv",
    "application/ogg": "ogg",
    "application/pdf": "pdf",
    "image/gif": "gif",
    "application/x-7z-compressed": "7z",
    "image/png": "png",
    "application/x-rar-compressed": "rar",
    "image/avif": "avif",
    "image/heif": "heif",
    "image/heif-sequence": "heif",
    "image/heic": "heic",
    "image/heic-sequence": "heic",
    "video/quicktime": "mov",
    "video/x-m4v": "m4v",
    "audio/x-m4a": "m4a",
    "audio/mp4": "m4a",
    "image/x-canon-cr3": "cr3",
    "video/3gpp2": "3g2",
    "video/3gpp": "3gp",
    "video/mp4": "mp4"
  };
  const OVERRIDE_MIME = {
    // tg doesn't interpret `audio/opus` files as voice messages for some reason
    "audio/opus": "audio/ogg"
  };
  const SMALL_FILE_MAX_SIZE$1 = 131072;
  const BIG_FILE_MIN_SIZE = 10485760;
  const DEFAULT_FILE_NAME = "unnamed";
  const REQUESTS_PER_CONNECTION$1 = 3;
  const MAX_PART_COUNT = 4e3;
  const MAX_PART_COUNT_PREMIUM = 8e3;
  const HAS_FILE = typeof File !== "undefined";
  const HAS_RESPONSE = typeof Response !== "undefined";
  const HAS_URL = typeof URL !== "undefined";
  const HAS_BLOB = typeof Blob !== "undefined";
  function uploadFile(client, params) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      let file = params.file;
      let fileSize = -1;
      let fileName = params.fileName;
      let fileMime = params.fileMime;
      const platform = getPlatform();
      if (platform.normalizeFile) {
        const res = yield platform.normalizeFile(file);
        if (res == null ? void 0 : res.file) {
          file = res.file;
          if (res.fileSize)
            fileSize = res.fileSize;
          if (res.fileName)
            fileName = res.fileName;
        }
      }
      if (ArrayBuffer.isView(file)) {
        fileSize = file.length;
        file = bufferToStream(file);
      }
      if (HAS_FILE && file instanceof File) {
        fileName = file.name;
        fileSize = file.size;
        fileMime = file.type;
        file = file.stream();
      }
      if (HAS_URL && file instanceof URL) {
        file = yield fetch(file);
      }
      if (HAS_BLOB && file instanceof Blob) {
        fileSize = file.size;
        file = file.stream();
      }
      if (HAS_RESPONSE && file instanceof Response) {
        const length = Number.parseInt(file.headers.get("content-length") || "0");
        if (!Number.isNaN(length) && length)
          fileSize = length;
        fileMime = (_a2 = file.headers.get("content-type")) == null ? void 0 : _a2.split(";")[0];
        const disposition = file.headers.get("content-disposition");
        if (disposition) {
          const idx2 = disposition.indexOf("filename=");
          if (idx2 > -1) {
            const raw = disposition.slice(idx2 + 9).split(";")[0];
            fileName = JSON.parse(raw);
          }
        }
        if (fileName === DEFAULT_FILE_NAME) {
          const url = new URL(file.url);
          const name = url.pathname.split("/").pop();
          if (name && name.includes(".")) {
            fileName = name;
          }
        }
        if (!file.body) {
          throw new MtArgumentError("Fetch response contains `null` body");
        }
        file = file.body;
      }
      if (!(file instanceof ReadableStream)) {
        throw new MtArgumentError("Could not convert input `file` to stream!");
      }
      if (fileSize === -1 && params.fileSize)
        fileSize = params.fileSize;
      if (fileSize === -1 && params.requireFileSize) {
        const buffer = yield streamToBuffer(file);
        fileSize = buffer.length;
        file = bufferToStream(buffer);
      }
      let partSizeKb = params.partSize;
      if (!partSizeKb) {
        if (fileSize === -1) {
          partSizeKb = params.estimatedSize ? determinePartSize(params.estimatedSize) : 64;
        } else {
          partSizeKb = determinePartSize(fileSize);
        }
      }
      if (partSizeKb > 512) {
        throw new MtArgumentError(`Invalid part size: ${partSizeKb}KB`);
      }
      const partSize = partSizeKb * 1024;
      let partCount = fileSize === -1 ? -1 : ~~((fileSize + partSize - 1) / partSize);
      const maxPartCount = ((_b = client.storage.self.getCached()) == null ? void 0 : _b.isPremium) ? MAX_PART_COUNT_PREMIUM : MAX_PART_COUNT;
      if (partCount > maxPartCount) {
        throw new MtArgumentError(`File is too large (max ${maxPartCount} parts, got ${partCount})`);
      }
      const isBig = fileSize === -1 || fileSize > BIG_FILE_MIN_SIZE;
      const isSmall = fileSize !== -1 && fileSize < SMALL_FILE_MAX_SIZE$1;
      const connectionKind = isSmall ? "main" : "upload";
      const connectionPoolSize = Math.min(yield client.getPoolSize(connectionKind), partCount);
      const requestsPerConnection = (_c = params.requestsPerConnection) != null ? _c : REQUESTS_PER_CONNECTION$1;
      client.log.debug(
        "uploading %d bytes file in %d chunks, each %d bytes in %s connection pool of size %d",
        fileSize,
        partCount,
        partSize,
        connectionKind,
        connectionPoolSize
      );
      const fileId = randomLong();
      const stream = file;
      let pos = 0;
      let idx = 0;
      const reader2 = createChunkedReader(stream, partSize);
      const uploadNextPart = () => __async(this, null, function* () {
        var _a3, _b2;
        const thisIdx = idx++;
        let part = yield reader2.read();
        if (!part && fileSize !== -1) {
          throw new MtArgumentError(`Unexpected EOS (there were only ${idx - 1} parts, but expected ${partCount})`);
        }
        if (fileSize === -1 && (reader2.ended() || !part)) {
          fileSize = pos + ((_a3 = part == null ? void 0 : part.length) != null ? _a3 : 0);
          partCount = ~~((fileSize + partSize - 1) / partSize);
          if (!part)
            part = new Uint8Array(0);
          client.log.debug("readable ended, file size = %d, part count = %d", fileSize, partCount);
        }
        if (!ArrayBuffer.isView(part)) {
          throw new MtArgumentError(`Part ${thisIdx} was not a Uint8Array!`);
        }
        if (part.length > partSize) {
          throw new MtArgumentError(`Part ${thisIdx} had invalid size (expected ${partSize}, got ${part.length})`);
        }
        if (thisIdx === 0 && fileMime === void 0) {
          const mime = guessFileMime(part);
          if (mime) {
            fileMime = mime;
          } else {
            const isPlainText = isProbablyPlainText(part.slice(0, 8));
            fileMime = isPlainText ? "text/plain" : "application/octet-stream";
          }
        }
        const request = isBig ? {
          _: "upload.saveBigFilePart",
          fileId,
          filePart: thisIdx,
          fileTotalParts: partCount,
          bytes: part
        } : {
          _: "upload.saveFilePart",
          fileId,
          filePart: thisIdx,
          bytes: part
        };
        const result = yield client.call(request, { kind: connectionKind });
        if (!result)
          throw new Error(`Failed to upload part ${idx}`);
        pos += part.length;
        (_b2 = params.progressCallback) == null ? void 0 : _b2.call(params, pos, fileSize);
        if (idx === partCount)
          return;
        return uploadNextPart();
      });
      let poolSize = partCount === -1 ? 1 : connectionPoolSize * requestsPerConnection;
      if (partCount !== -1 && poolSize > partCount)
        poolSize = partCount;
      yield Promise.all(Array.from({ length: poolSize }, uploadNextPart));
      if (fileName === void 0) {
        const ext = MIME_TO_EXTENSION[fileMime];
        fileName = ext ? `${DEFAULT_FILE_NAME}.${ext}` : DEFAULT_FILE_NAME;
      } else if (params.requireExtension) {
        const extFromMime = MIME_TO_EXTENSION[fileMime];
        const idx2 = fileName.lastIndexOf(".");
        const extFromName = idx2 === -1 ? void 0 : fileName.slice(idx2 + 1);
        if (!extFromName) {
          if (!extFromMime) {
            throw new MtArgumentError(`File name does not have an extension, and we cannot guess it from the mime type (${fileMime})`);
          }
          fileName = `${fileName}.${extFromMime}`;
        } else if (extFromMime && extFromName !== extFromMime) {
          throw new MtArgumentError(`File name has ${extFromName} extension (${fileName}), but the mime type (${fileMime}) expects it to be ${extFromMime}`);
        }
      }
      let inputFile;
      if (isBig) {
        inputFile = {
          _: "inputFileBig",
          id: fileId,
          parts: partCount,
          name: fileName
        };
      } else {
        inputFile = {
          _: "inputFile",
          id: fileId,
          parts: partCount,
          name: fileName,
          md5Checksum: ""
          // tdlib doesn't do this, why should we?
        };
      }
      if (fileMime in OVERRIDE_MIME)
        fileMime = OVERRIDE_MIME[fileMime];
      return {
        inputFile,
        size: fileSize,
        mime: fileMime
      };
    });
  }
  function _normalizeInputFile(client, input, params) {
    return __async(this, null, function* () {
      if (typeof input === "object" && tl.tl.isAnyInputMedia(input)) {
        throw new MtArgumentError("InputFile can't be created from an InputMedia");
      } else if (typesInner.isFileIdLike(input)) {
        if (typeof input === "string" && input.match(/^file:/)) {
          const uploaded = yield uploadFile(client, __spreadValues({
            file: input.substring(5)
          }, params));
          return uploaded.inputFile;
        }
        throw new MtArgumentError("InputFile can't be created from an URL or a File ID");
      } else if (isUploadedFile(input)) {
        return input.inputFile;
      } else if (typeof input === "object" && tl.tl.isAnyInputFile(input)) {
        return input;
      } else {
        const uploaded = yield uploadFile(client, __spreadValues({
          file: input
        }, params));
        return uploaded.inputFile;
      }
    });
  }
  function _normalizeInputMedia(_0, _1) {
    return __async(this, arguments, function* (client, media, params = {}, uploadMedia2 = false) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      if (tl.tl.isAnyInputMedia(media)) {
        switch (media._) {
          case "inputMediaStory":
            return __spreadProps(__spreadValues({}, media), {
              peer: yield resolvePeer(client, media.peer)
            });
        }
        return media;
      }
      if (media.type === "venue") {
        return {
          _: "inputMediaVenue",
          geoPoint: {
            _: "inputGeoPoint",
            lat: media.latitude,
            long: media.longitude
          },
          title: media.title,
          address: media.address,
          provider: (_b = (_a2 = media.source) == null ? void 0 : _a2.provider) != null ? _b : "",
          venueId: (_d = (_c = media.source) == null ? void 0 : _c.id) != null ? _d : "",
          venueType: (_f = (_e = media.source) == null ? void 0 : _e.type) != null ? _f : ""
        };
      }
      if (media.type === "geo") {
        return {
          _: "inputMediaGeoPoint",
          geoPoint: {
            _: "inputGeoPoint",
            lat: media.latitude,
            long: media.longitude
          }
        };
      }
      if (media.type === "geo_live") {
        return {
          _: "inputMediaGeoLive",
          geoPoint: {
            _: "inputGeoPoint",
            lat: media.latitude,
            long: media.longitude
          },
          stopped: media.stopped,
          heading: media.heading,
          period: media.period,
          proximityNotificationRadius: media.proximityNotificationRadius
        };
      }
      if (media.type === "dice") {
        return {
          _: "inputMediaDice",
          emoticon: media.emoji
        };
      }
      if (media.type === "contact") {
        return {
          _: "inputMediaContact",
          phoneNumber: media.phone,
          firstName: media.firstName,
          lastName: (_g = media.lastName) != null ? _g : "",
          vcard: (_h = media.vcard) != null ? _h : ""
        };
      }
      if (media.type === "game") {
        return {
          _: "inputMediaGame",
          id: typeof media.game === "string" ? {
            _: "inputGameShortName",
            botId: { _: "inputUserSelf" },
            shortName: media.game
          } : media.game
        };
      }
      if (media.type === "invoice") {
        return {
          _: "inputMediaInvoice",
          title: media.title,
          description: media.description,
          photo: typeof media.photo === "string" ? {
            _: "inputWebDocument",
            url: media.photo,
            mimeType: "image/jpeg",
            size: 0,
            attributes: []
          } : media.photo,
          invoice: media.invoice,
          payload: media.payload,
          provider: media.token,
          providerData: {
            _: "dataJSON",
            data: JSON.stringify(media.providerData)
          },
          startParam: media.startParam,
          extendedMedia: media.extendedMedia ? yield _normalizeInputMedia(client, media.extendedMedia, params) : void 0
        };
      }
      if (media.type === "poll" || media.type === "quiz") {
        const answers = media.answers.map((ans, idx) => {
          if (typeof ans === "object" && tl.tl.isAnyPollAnswer(ans))
            return ans;
          return {
            _: "pollAnswer",
            text: inputTextToTl(ans),
            // emulate the behaviour of most implementations
            option: new Uint8Array([48 + idx])
          };
        });
        let correct;
        let solution;
        let solutionEntities;
        if (media.type === "quiz") {
          let input2 = media.correct;
          if (!Array.isArray(input2))
            input2 = [input2];
          correct = input2.map((it) => {
            if (typeof it === "number") {
              return answers[it].option;
            }
            return it;
          });
          if (media.solution) {
            [solution, solutionEntities] = yield _normalizeInputText(client, media.solution);
          }
        }
        return {
          _: "inputMediaPoll",
          poll: {
            _: "poll",
            closed: media.closed,
            id: Long.ZERO,
            publicVoters: media.public,
            multipleChoice: media.multiple,
            quiz: media.type === "quiz",
            question: inputTextToTl(media.question),
            answers,
            closePeriod: media.closePeriod,
            closeDate: normalizeDate(media.closeDate)
          },
          correctAnswers: correct,
          solution,
          solutionEntities
        };
      }
      if (media.type === "story") {
        return {
          _: "inputMediaStory",
          peer: yield resolvePeer(client, media.peer),
          id: media.id
        };
      }
      if (media.type === "webpage") {
        return {
          _: "inputMediaWebPage",
          forceLargeMedia: media.size === "large",
          forceSmallMedia: media.size === "small",
          optional: !media.required,
          url: media.url
        };
      }
      if (media.type === "paid") {
        let medias;
        if (Array.isArray(media.media)) {
          medias = yield Promise.all(media.media.map((m2) => _normalizeInputMedia(client, m2, params)));
        } else {
          medias = [yield _normalizeInputMedia(client, media.media, params)];
        }
        return {
          _: "inputMediaPaidMedia",
          starsAmount: Long.isLong(media.starsAmount) ? media.starsAmount : Long.fromNumber(media.starsAmount),
          extendedMedia: medias,
          payload: media.payload
        };
      }
      let inputFile;
      let thumb;
      let mime = "application/octet-stream";
      const upload = (file) => __async(this, null, function* () {
        let sendMime;
        if (media.type === "sticker") {
          sendMime = media.isAnimated ? "application/x-tgsticker" : "image/webp";
        } else {
          sendMime = media.fileMime;
        }
        const uploaded = yield uploadFile(client, {
          file,
          progressCallback: params.progressCallback,
          fileName: media.fileName,
          fileMime: sendMime,
          fileSize: media.fileSize,
          requireFileSize: media.type === "photo",
          requireExtension: media.type === "photo"
        });
        inputFile = uploaded.inputFile;
        mime = uploaded.mime;
      });
      const uploadPeer = (_i = params.uploadPeer) != null ? _i : { _: "inputPeerSelf" };
      const uploadMediaIfNeeded = (inputMedia, photo) => __async(this, null, function* () {
        if (!uploadMedia2)
          return inputMedia;
        const res = yield client.call({
          _: "messages.uploadMedia",
          peer: uploadPeer,
          media: inputMedia,
          businessConnectionId: params.businessConnectionId
        });
        if (photo) {
          assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res, "messageMediaPhoto");
          assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res.photo, "photo");
          return {
            _: "inputMediaPhoto",
            id: {
              _: "inputPhoto",
              id: res.photo.id,
              accessHash: res.photo.accessHash,
              fileReference: res.photo.fileReference
            },
            ttlSeconds: media.ttlSeconds,
            spoiler: media.type === "video" && media.spoiler
          };
        }
        assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res, "messageMediaDocument");
        assertTypeIs("normalizeInputMedia (@ messages.uploadMedia)", res.document, "document");
        return {
          _: "inputMediaDocument",
          id: {
            _: "inputDocument",
            id: res.document.id,
            accessHash: res.document.accessHash,
            fileReference: res.document.fileReference
          },
          ttlSeconds: media.ttlSeconds,
          spoiler: media.type === "video" && media.spoiler
        };
      });
      const input = media.file;
      if (typesInner.isFileIdLike(input)) {
        if (typeof input === "string" && input.match(/^https?:\/\//)) {
          return uploadMediaIfNeeded(
            {
              _: media.type === "photo" ? "inputMediaPhotoExternal" : "inputMediaDocumentExternal",
              url: input
            },
            media.type === "photo"
          );
        } else if (typeof input === "string" && input.match(/^file:/)) {
          yield upload(input.substring(5));
        } else {
          const parsed = typeof input === "string" ? parseFileId(getPlatform(), input) : input;
          if (parsed.location._ === "photo") {
            return {
              _: "inputMediaPhoto",
              id: fileIdToInputPhoto(parsed)
            };
          } else if (parsed.location._ === "web") {
            return uploadMediaIfNeeded(
              {
                _: parsed.type === typesInner.FileType.Photo ? "inputMediaPhotoExternal" : "inputMediaDocumentExternal",
                url: parsed.location.url
              },
              parsed.type === typesInner.FileType.Photo
            );
          }
          return {
            _: "inputMediaDocument",
            id: fileIdToInputDocument(parsed)
          };
        }
      } else if (typeof input === "object" && tl.tl.isAnyInputMedia(input)) {
        return input;
      } else if (isUploadedFile(input)) {
        inputFile = input.inputFile;
        mime = input.mime;
      } else if (typeof input === "object" && tl.tl.isAnyInputFile(input)) {
        inputFile = input;
      } else {
        yield upload(input);
      }
      if (!inputFile)
        throw new Error("should not happen");
      if (media.type === "photo") {
        return uploadMediaIfNeeded(
          {
            _: "inputMediaUploadedPhoto",
            file: inputFile,
            ttlSeconds: media.ttlSeconds,
            spoiler: media.spoiler
          },
          true
        );
      }
      if ("thumb" in media && media.thumb) {
        thumb = yield _normalizeInputFile(client, media.thumb, {});
      }
      const attributes = [];
      if (media.type !== "voice") {
        attributes.push({
          _: "documentAttributeFilename",
          fileName: media.fileName || (inputFile._ === "inputFileStoryDocument" ? "story" : inputFile.name)
        });
      }
      if (media.type === "video") {
        attributes.push({
          _: "documentAttributeVideo",
          duration: media.duration || 0,
          w: media.width || 0,
          h: media.height || 0,
          supportsStreaming: media.supportsStreaming,
          roundMessage: media.isRound
        });
        if (media.isAnimated) {
          attributes.push({ _: "documentAttributeAnimated" });
        }
      }
      if (media.type === "audio" || media.type === "voice") {
        attributes.push({
          _: "documentAttributeAudio",
          voice: media.type === "voice",
          duration: media.duration || 0,
          title: media.type === "audio" ? media.title : void 0,
          performer: media.type === "audio" ? media.performer : void 0,
          waveform: media.type === "voice" && media.waveform ? encodeWaveform(media.waveform) : void 0
        });
      }
      if (media.type === "sticker") {
        attributes.push({
          _: "documentAttributeSticker",
          stickerset: {
            _: "inputStickerSetEmpty"
          },
          alt: (_j = media.alt) != null ? _j : ""
        });
      }
      return uploadMediaIfNeeded(
        {
          _: "inputMediaUploadedDocument",
          nosoundVideo: media.type === "video" && media.isAnimated,
          forceFile: media.type === "document",
          file: inputFile,
          thumb,
          mimeType: mime,
          attributes,
          ttlSeconds: media.ttlSeconds,
          spoiler: media.type === "video" && media.spoiler
        },
        false
      );
    });
  }
  class BusinessConnection {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** Whether the connection was removed by the user */
    get isRemoved() {
      return this.raw.disabled;
    }
    /** ID of the connection */
    get id() {
      return this.raw.connectionId;
    }
    /** Datacenter ID of the connected user */
    get dcId() {
      return this.raw.dcId;
    }
    /** Date when the connection was created */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /** Whether the bot can reply on behalf of the user */
    get canReply() {
      return this.raw.canReply;
    }
    /** Business account user that created the business connection */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
  }
  memoizeGetters(BusinessConnection, ["user"]);
  function getBusinessConnection(client, connectionId) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "account.getBotBusinessConnection",
        connectionId
      });
      assertIsUpdatesGroup("account.getBotBusinessConnection", res);
      client.handleClientUpdate(res);
      assertTypeIs("account.getBotBusinessConnection", res.updates[0], "updateBotBusinessConnect");
      const peers = PeersIndex.from(res);
      return new BusinessConnection(res.updates[0].connection, peers);
    });
  }
  const DC_MAP_SYMBOL = Symbol("dcMap");
  function getDcMap(client) {
    const client_ = client;
    if (!client_[DC_MAP_SYMBOL]) {
      client_[DC_MAP_SYMBOL] = new LruMap(50);
    }
    return client_[DC_MAP_SYMBOL];
  }
  function _maybeInvokeWithBusinessConnection(client, businessConnectionId, request, params) {
    return __async(this, null, function* () {
      if (!businessConnectionId) {
        return client.call(request, params);
      }
      const dcMap = getDcMap(client);
      if (!dcMap.has(businessConnectionId)) {
        const res = yield getBusinessConnection(client, businessConnectionId);
        dcMap.set(businessConnectionId, res.dcId);
      }
      const dcId = dcMap.get(businessConnectionId);
      return client.call(
        {
          _: "invokeWithBusinessConnection",
          connectionId: businessConnectionId,
          query: request
        },
        __spreadProps(__spreadValues({}, params), {
          localMigrate: true,
          // just in case
          dcId
        })
      );
    });
  }
  function normalizeInputMessageId(id2) {
    if ("chatId" in id2)
      return id2;
    return { chatId: id2.message.chat.inputPeer, message: id2.message.id };
  }
  class MessageEffect {
    constructor(raw, documentsMap) {
      this.raw = raw;
      this.documentsMap = documentsMap;
    }
    /** Whether Telegram Premium is required to use this effect */
    get isPremiumRequired() {
      return this.raw.premiumRequired;
    }
    /** ID of this effect */
    get id() {
      return this.raw.id;
    }
    /** Emoji representint this reaction */
    get emoji() {
      return this.raw.emoticon;
    }
    /** Sticker representing a static icon for this effect (if any) */
    get staticIcon() {
      if (!this.raw.staticIconId)
        return null;
      const document2 = this.documentsMap.get(this.raw.staticIconId);
      if (!document2)
        return null;
      const parsed = parseSticker(document2);
      if (!parsed) {
        throw new MtTypeAssertionError("MessageEffect.staticIcon", "sticker", "null");
      }
      return parsed;
    }
    /** Animated icon representing the effect  */
    get icon() {
      const document2 = this.documentsMap.get(this.raw.effectStickerId);
      if (!document2) {
        throw new MtTypeAssertionError("MessageEffect.effect", "document", "null");
      }
      const parsed = parseSticker(document2);
      if (!parsed) {
        throw new MtTypeAssertionError("MessageEffect.effect", "sticker", "null");
      }
      return parsed;
    }
    /** The animation itself */
    get animation() {
      if (!this.raw.effectAnimationId)
        return null;
      const document2 = this.documentsMap.get(this.raw.effectAnimationId);
      if (!document2)
        return null;
      const parsed = parseSticker(document2);
      if (!parsed) {
        throw new MtTypeAssertionError("MessageEffect.effectAnimation", "sticker", "null");
      }
      return parsed;
    }
  }
  memoizeGetters(MessageEffect, ["staticIcon", "icon", "animation"]);
  const SearchFilters = {
    Empty: { _: "inputMessagesFilterEmpty" }
  };
  class ChatInviteLink {
    constructor(raw, _peers) {
      __publicField(this, "raw");
      this._peers = _peers;
      assertTypeIsNot("ChatInviteLink", raw, "chatInvitePublicJoinRequests");
      this.raw = raw;
    }
    /**
     * The invite link as a `t.me/joinchat/` string.
     *
     * If the link was created by another administrator, the second
     * part of the link will be censored with `...` (e.g. `https://t.me/joinchat/BGxxHIg4...`
     *
     * See also: {@link isMyLink}
     */
    get link() {
      return this.raw.link;
    }
    /**
     * Whether this invite link was created by the current user.
     *
     * If so, {@link link} will be a full invite link.
     */
    get isMyLink() {
      var _a2, _b;
      return (_b = (_a2 = this.creator) == null ? void 0 : _a2.isSelf) != null ? _b : !this.raw.link.endsWith("...");
    }
    /**
     * Creator of the invite link, if available
     */
    get creator() {
      if (!this._peers)
        return null;
      return new User(this._peers.user(this.raw.adminId));
    }
    /**
     * Creation date of the link
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Whether this link is primary (i.e. "permanent")
     */
    get isPrimary() {
      return this.raw.permanent;
    }
    /**
     * Whether this link was revoked and can't be used anymore
     */
    get isRevoked() {
      return this.raw.revoked;
    }
    /**
     * The date since which the link will be valid (if any)
     */
    get startDate() {
      return this.raw.startDate ? new Date(this.raw.startDate * 1e3) : null;
    }
    /**
     * The date until which the link will be valid (if any)
     */
    get endDate() {
      return this.raw.expireDate ? new Date(this.raw.expireDate * 1e3) : null;
    }
    /**
     * Maximum number of users that can be members of this chat
     * at the same time after joining using this link.
     *
     * Integer in range `[1, 99999]` or `Infinity` if unspecified
     */
    get usageLimit() {
      var _a2;
      return (_a2 = this.raw.usageLimit) != null ? _a2 : Infinity;
    }
    /**
     * Number of users currently in the chat that joined using this link
     */
    get usage() {
      var _a2;
      return (_a2 = this.raw.usage) != null ? _a2 : 0;
    }
    /**
     * Whether users joined by this link need to be
     * approved by the group administrator before they can join
     */
    get approvalNeeded() {
      return this.raw.requestNeeded;
    }
    /**
     * Number of users currently awaiting admin approval.
     *
     * 0 in case the link is not using approvals
     */
    get pendingApprovals() {
      var _a2;
      return (_a2 = this.raw.requested) != null ? _a2 : 0;
    }
  }
  memoizeGetters(ChatInviteLink, ["creator"]);
  class ChatLocation {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Location of the chat
     */
    get location() {
      return new Location(this.raw.geoPoint);
    }
    /**
     * Textual description of the address
     */
    get address() {
      return this.raw.address;
    }
  }
  memoizeGetters(ChatLocation, ["location"]);
  class ChatMember {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Information about the user
     */
    get user() {
      switch (this.raw._) {
        case "channelParticipantBanned":
        case "channelParticipantLeft":
          assertTypeIs("ChatMember#user (raw.peer)", this.raw.peer, "peerUser");
          return new User(this._peers.user(this.raw.peer.userId));
        default:
          return new User(this._peers.user(this.raw.userId));
      }
    }
    /**
     * Get the chat member status
     */
    get status() {
      switch (this.raw._) {
        case "channelParticipant":
        case "channelParticipantSelf":
        case "chatParticipant":
          return "member";
        case "channelParticipantCreator":
        case "chatParticipantCreator":
          return "creator";
        case "channelParticipantAdmin":
        case "chatParticipantAdmin":
          return "admin";
        case "channelParticipantLeft":
          return "left";
        case "channelParticipantBanned":
          return this.raw.bannedRights.viewMessages ? "banned" : "restricted";
      }
    }
    /**
     * Custom title (for creators and admins).
     *
     * `null` for non-admins and in case custom title is not set.
     */
    get title() {
      var _a2;
      switch (this.raw._) {
        case "channelParticipantCreator":
        case "channelParticipantAdmin":
          return (_a2 = this.raw.rank) != null ? _a2 : null;
        default:
          return null;
      }
    }
    /**
     * Date when the user has joined the chat.
     *
     * Not available for creators and left members
     */
    get joinedDate() {
      switch (this.raw._) {
        case "channelParticipantCreator":
        case "chatParticipantCreator":
        case "channelParticipantLeft":
          return null;
        default:
          return new Date(this.raw.date * 1e3);
      }
    }
    /**
     * Information about whoever invited this member to the chat.
     *
     * Only available in the following cases:
     *  - `user` is yourself
     *  - `chat` is a legacy group
     *  - `chat` is a supergroup/channel, and `user` is an admin
     */
    get invitedBy() {
      if ("inviterId" in this.raw && this.raw.inviterId) {
        return new User(this._peers.user(this.raw.inviterId));
      }
      return null;
    }
    /**
     * Information about whoever promoted this admin.
     *
     * Only available if `status = admin`.
     */
    get promotedBy() {
      if (this.raw._ === "channelParticipantAdmin") {
        return new User(this._peers.user(this.raw.promotedBy));
      }
      return null;
    }
    /**
     * Information about whoever restricted this user.
     *
     * Only available if `status = restricted or status = banned`
     */
    get restrictedBy() {
      if (this.raw._ === "channelParticipantBanned") {
        return new User(this._peers.user(this.raw.kickedBy));
      }
      return null;
    }
    /**
     * For restricted and banned users,
     * information about the restrictions
     */
    get restrictions() {
      if (this.raw._ !== "channelParticipantBanned")
        return null;
      return new ChatPermissions(this.raw.bannedRights);
    }
    /**
     * Whether this member is a part of the chat now.
     *
     * Makes sense only when `status = restricted or staus = banned`
     */
    get isMember() {
      return this.raw._ === "channelParticipantBanned" ? !this.raw.left : this.raw._ !== "channelParticipantLeft";
    }
    /**
     * For admins and creator of supergroup/channels,
     * list of their admin permissions.
     *
     * Also contains whether this admin is anonymous.
     */
    get permissions() {
      switch (this.raw._) {
        case "channelParticipantAdmin":
        case "channelParticipantCreator":
          return this.raw.adminRights;
        default:
          return null;
      }
    }
    /**
     * If this member subscribed to a channel using Telegram Stars,
     * this field will contain the date when the subscription will expire
     */
    get subscriptionUntilDate() {
      switch (this.raw._) {
        case "channelParticipant":
        case "channelParticipantSelf":
          if (!this.raw.subscriptionUntilDate)
            return null;
          return new Date(this.raw.subscriptionUntilDate * 1e3);
      }
      return null;
    }
  }
  memoizeGetters(ChatMember, ["user", "invitedBy", "promotedBy", "restrictedBy", "restrictions"]);
  const _ForumTopic = class _ForumTopic {
    constructor(raw, _peers, _messages) {
      this.raw = raw;
      this._peers = _peers;
      this._messages = _messages;
    }
    static parseTlForumTopics(topics) {
      const peers = PeersIndex.from(topics);
      const messages = /* @__PURE__ */ new Map();
      topics.messages.forEach((msg) => {
        if (!msg.peerId)
          return;
        messages.set(msg.id, msg);
      });
      return topics.topics.filter(hasValueAtKey("_", "forumTopic")).map((it) => new _ForumTopic(it, peers, messages));
    }
    /**
     * Whether the topic was created by the current user
     */
    get isMy() {
      return this.raw.my;
    }
    /**
     * Whether the topic is closed
     */
    get isClosed() {
      return this.raw.closed;
    }
    /**
     * Whether the topic is pinned
     */
    get isPinned() {
      return this.raw.pinned;
    }
    /**
     * Whether this constructor is a reduced version of the full topic information.
     *
     * If `true`, only {@link isMy}, {@link isClosed}, {@link id}, {@link date},
     * {@link title}, {@link iconColor}, {@link iconCustomEmoji} and {@link creator}
     * parameters will contain valid information.
     */
    get isShort() {
      return this.raw.short;
    }
    /**
     * ID of the topic
     */
    get id() {
      return this.raw.id;
    }
    /**
     * Date when the topic was created
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Title of the topic
     */
    get title() {
      return this.raw.title;
    }
    /**
     * Color of the topic's icon, used as a fallback
     * in case {@link iconEmoji} is not set.
     *
     * One of the static `COLOR_*` fields.
     */
    get iconColor() {
      var _a2;
      return (_a2 = this.raw.iconColor) != null ? _a2 : null;
    }
    /**
     * Emoji used as the topic's icon.
     */
    get iconCustomEmoji() {
      var _a2;
      return (_a2 = this.raw.iconEmojiId) != null ? _a2 : null;
    }
    /**
     * Creator of the topic
     */
    get creator() {
      return parsePeer(this.raw.fromId, this._peers);
    }
    /**
     * The latest message sent in this topic
     */
    get lastMessage() {
      var _a2;
      const id2 = this.raw.topMessage;
      if ((_a2 = this._messages) == null ? void 0 : _a2.has(id2)) {
        return new Message(this._messages.get(id2), this._peers);
      }
      throw new MtMessageNotFoundError(0, id2);
    }
    /**
     * ID of the last read outgoing message in this topic
     */
    get lastReadIngoing() {
      return this.raw.readInboxMaxId;
    }
    /**
     * ID of the last read ingoing message in this topic
     */
    get lastReadOutgoing() {
      return this.raw.readOutboxMaxId;
    }
    /**
     * ID of the last read message in this topic
     */
    get lastRead() {
      return Math.max(this.raw.readOutboxMaxId, this.raw.readInboxMaxId);
    }
    /**
     * Number of unread messages in the topic
     */
    get unreadCount() {
      return this.raw.unreadCount;
    }
    /**
     * Number of unread mentions in the topic
     */
    get unreadMentionsCount() {
      return this.raw.unreadMentionsCount;
    }
    /**
     * Number of unread reactions in the topic
     */
    get unreadReactionsCount() {
      return this.raw.unreadReactionsCount;
    }
    /**
     * Draft message in the topic
     */
    get draftMessage() {
      if (!this.raw.draft || this.raw.draft._ === "draftMessageEmpty")
        return null;
      return new DraftMessage(this.raw.draft);
    }
  };
  __publicField(_ForumTopic, "COLOR_BLUE", 7322096);
  __publicField(_ForumTopic, "COLOR_YELLOW", 16766590);
  __publicField(_ForumTopic, "COLOR_PURPLE", 13338331);
  __publicField(_ForumTopic, "COLOR_GREEN", 9367192);
  __publicField(_ForumTopic, "COLOR_PINK", 16749490);
  __publicField(_ForumTopic, "COLOR_RED", 16478047);
  let ForumTopic = _ForumTopic;
  memoizeGetters(ForumTopic, ["creator", "lastMessage", "draftMessage"]);
  function _actionFromTl(e, peers) {
    switch (e._) {
      case "channelAdminLogEventActionParticipantJoin":
        return { type: "user_joined" };
      case "channelAdminLogEventActionChangeTitle":
        return {
          type: "title_changed",
          old: e.prevValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionChangeAbout":
        return {
          type: "description_changed",
          old: e.prevValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionChangeUsername":
        return {
          type: "username_changed",
          old: e.prevValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionChangeUsernames":
        return {
          type: "usernames_changed",
          old: e.prevValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionChangePhoto":
        return {
          type: "photo_changed",
          old: new Photo(e.prevPhoto),
          new: new Photo(e.newPhoto)
        };
      case "channelAdminLogEventActionToggleInvites":
        return {
          type: "invites_toggled",
          old: !e.newValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionToggleSignatures":
        return {
          type: "signatures_toggled",
          old: !e.newValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionUpdatePinned":
        return {
          type: "msg_pinned",
          message: new Message(e.message, peers)
        };
      case "channelAdminLogEventActionEditMessage":
        return {
          type: "msg_edited",
          old: new Message(e.prevMessage, peers),
          new: new Message(e.newMessage, peers)
        };
      case "channelAdminLogEventActionDeleteMessage":
        return {
          type: "msg_deleted",
          message: new Message(e.message, peers)
        };
      case "channelAdminLogEventActionParticipantLeave":
        return { type: "user_left" };
      case "channelAdminLogEventActionParticipantInvite":
        return {
          type: "user_invited",
          member: new ChatMember(e.participant, peers)
        };
      case "channelAdminLogEventActionParticipantToggleBan":
        return {
          type: "user_perms_changed",
          old: new ChatMember(e.prevParticipant, peers),
          new: new ChatMember(e.newParticipant, peers)
        };
      case "channelAdminLogEventActionParticipantToggleAdmin":
        return {
          type: "user_admin_perms_changed",
          old: new ChatMember(e.prevParticipant, peers),
          new: new ChatMember(e.newParticipant, peers)
        };
      case "channelAdminLogEventActionChangeStickerSet":
        return {
          type: "stickerset_changed",
          old: e.prevStickerset,
          new: e.newStickerset
        };
      case "channelAdminLogEventActionTogglePreHistoryHidden":
        return {
          type: "history_toggled",
          old: !e.newValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionDefaultBannedRights":
        return {
          type: "def_perms_changed",
          old: new ChatPermissions(e.prevBannedRights),
          new: new ChatPermissions(e.newBannedRights)
        };
      case "channelAdminLogEventActionStopPoll":
        return {
          type: "poll_stopped",
          message: new Message(e.message, peers)
        };
      case "channelAdminLogEventActionChangeLinkedChat":
        return {
          type: "linked_chat_changed",
          old: toggleChannelIdMark(e.prevValue),
          new: toggleChannelIdMark(e.newValue)
        };
      case "channelAdminLogEventActionChangeLocation":
        return {
          type: "location_changed",
          old: e.prevValue._ === "channelLocationEmpty" ? null : new ChatLocation(e.prevValue),
          new: e.newValue._ === "channelLocationEmpty" ? null : new ChatLocation(e.newValue)
        };
      case "channelAdminLogEventActionToggleSlowMode":
        return {
          type: "slow_mode_changed",
          old: e.prevValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionStartGroupCall":
        return {
          type: "call_started",
          call: e.call
        };
      case "channelAdminLogEventActionDiscardGroupCall":
        return {
          type: "call_ended",
          call: e.call
        };
      case "channelAdminLogEventActionParticipantMute":
      case "channelAdminLogEventActionParticipantUnmute":
      case "channelAdminLogEventActionParticipantVolume":
        return null;
      case "channelAdminLogEventActionToggleGroupCallSetting":
        return {
          type: "call_setting_changed",
          joinMuted: e.joinMuted
        };
      case "channelAdminLogEventActionParticipantJoinByInvite":
        return {
          type: "user_joined_invite",
          link: new ChatInviteLink(e.invite, peers)
        };
      case "channelAdminLogEventActionExportedInviteDelete":
        return {
          type: "invite_deleted",
          link: new ChatInviteLink(e.invite, peers)
        };
      case "channelAdminLogEventActionExportedInviteRevoke":
        return {
          type: "invite_revoked",
          link: new ChatInviteLink(e.invite, peers)
        };
      case "channelAdminLogEventActionExportedInviteEdit":
        return {
          type: "invite_edited",
          old: new ChatInviteLink(e.prevInvite, peers),
          new: new ChatInviteLink(e.newInvite, peers)
        };
      case "channelAdminLogEventActionChangeHistoryTTL":
        return {
          type: "ttl_changed",
          old: e.prevValue,
          new: e.newValue
        };
      case "channelAdminLogEventActionParticipantJoinByRequest":
        return {
          type: "user_joined_approved",
          link: new ChatInviteLink(e.invite, peers),
          approvedBy: new User(peers.user(e.approvedBy))
        };
      case "channelAdminLogEventActionToggleForum":
        return {
          type: "forum_toggled",
          enabled: e.newValue
        };
      case "channelAdminLogEventActionCreateTopic":
        assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e.topic, "forumTopic");
        return {
          type: "topic_created",
          topic: new ForumTopic(e.topic, peers)
        };
      case "channelAdminLogEventActionEditTopic":
        assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e.prevTopic, "forumTopic");
        assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e.newTopic, "forumTopic");
        return {
          type: "topic_edited",
          old: new ForumTopic(e.prevTopic, peers),
          new: new ForumTopic(e.newTopic, peers)
        };
      case "channelAdminLogEventActionDeleteTopic":
        assertTypeIs("ChannelAdminLogEventActionCreateTopic#topic", e.topic, "forumTopic");
        return {
          type: "topic_deleted",
          topic: new ForumTopic(e.topic, peers)
        };
      case "channelAdminLogEventActionToggleNoForwards":
        return {
          type: "no_forwards_toggled",
          enabled: e.newValue
        };
      case "channelAdminLogEventActionToggleSignatureProfiles":
        return {
          type: "signature_profiles_toggled",
          new: e.newValue
        };
      case "channelAdminLogEventActionParticipantSubExtend":
        return {
          type: "sub_extend",
          prev: new ChatMember(e.prevParticipant, peers),
          new: new ChatMember(e.newParticipant, peers)
        };
      default:
        return null;
    }
  }
  class ChatEvent {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Event ID.
     *
     * Event IDs are generated in direct chronological order
     * (i.e. newer events have bigger event ID)
     */
    get id() {
      return this.raw.id;
    }
    /**
     * Date of the event
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Actor of the event
     */
    get actor() {
      return new User(this._peers.user(this.raw.userId));
    }
    get action() {
      return _actionFromTl(this.raw.action, this._peers);
    }
  }
  memoizeGetters(ChatEvent, ["actor", "action"]);
  class ChatInviteLinkMember {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * User who joined the chat
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * Date when the user joined the chat
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Whether this user currently has a pending join request
     * (and is actually not a member yet)
     */
    get isPendingRequest() {
      return this.raw.requested;
    }
    /**
     * Whether the participant joined by importing a chat folder deep link
     */
    get isViaChatlist() {
      return this.raw.requested;
    }
    /**
     * For users with pending requests, contains bio of the user that requested to join
     */
    get bio() {
      var _a2;
      return (_a2 = this.raw.about) != null ? _a2 : null;
    }
    /**
     * The administrator that approved the join request of the user
     */
    get approvedBy() {
      if (!this.raw.approvedBy)
        return null;
      return new User(this._peers.user(this.raw.approvedBy));
    }
  }
  memoizeGetters(ChatInviteLinkMember, ["user", "approvedBy"]);
  class ChatPreview {
    constructor(invite, link) {
      this.invite = invite;
      this.link = link;
    }
    /**
     * Title of the chat
     */
    get title() {
      return this.invite.title;
    }
    /**
     * Type of the chat
     */
    get type() {
      if (this.invite.broadcast)
        return "channel";
      if (this.invite.megagroup || this.invite.channel)
        return "supergroup";
      return "group";
    }
    /**
     * Whether this chat is public
     */
    get public() {
      return this.invite.public;
    }
    /**
     * Total chat member count
     */
    get memberCount() {
      return this.invite.participantsCount;
    }
    /**
     * Chat photo
     */
    get photo() {
      if (this.invite.photo._ === "photoEmpty")
        return null;
      return new Photo(this.invite.photo);
    }
    /**
     * Preview of some of the chat members.
     *
     * This usually contains around 10 members,
     * and members that are inside your contacts list are
     * ordered before others.
     */
    get someMembers() {
      var _a2, _b;
      return (_b = (_a2 = this.invite.participants) == null ? void 0 : _a2.map((it) => new User(it))) != null ? _b : [];
    }
    /**
     * Whether by using this link you'll also need
     * to wait for admin approval.
     */
    get withApproval() {
      return this.invite.requestNeeded;
    }
  }
  memoizeGetters(ChatPreview, ["photo", "someMembers"]);
  class ChatlistPreview {
    constructor(raw) {
      __publicField(this, "peers");
      this.raw = raw;
      this.peers = PeersIndex.from(raw);
    }
    /** Whether the current user has already joined this chatlist */
    get isJoined() {
      return this.raw._ === "chatlists.chatlistInviteAlready";
    }
    /** If we joined the chatlist, ID of the folder representing it */
    get folderId() {
      return this.raw._ === "chatlists.chatlistInviteAlready" ? this.raw.filterId : null;
    }
    /** Title of the chatlist (only available for non-joined chatlists) */
    get title() {
      return this.raw._ === "chatlists.chatlistInvite" ? this.raw.title : "";
    }
    /** Emoji representing an icon of the chatlist (may only be available for non-joined chatlists) */
    get emoji() {
      var _a2;
      return this.raw._ === "chatlists.chatlistInvite" ? (_a2 = this.raw.emoticon) != null ? _a2 : null : null;
    }
    /** List of all chats contained in the chatlist */
    get chats() {
      let peers;
      if (this.raw._ === "chatlists.chatlistInvite") {
        peers = this.raw.peers;
      } else {
        peers = [...this.raw.alreadyPeers, ...this.raw.missingPeers];
      }
      return peers.map((peer) => Chat._parseFromPeer(peer, this.peers));
    }
  }
  memoizeGetters(ChatlistPreview, ["chats"]);
  function normalizeInputStickerSet(input) {
    if (typeof input === "string") {
      return {
        _: "inputStickerSetShortName",
        shortName: input
      };
    }
    if ("_" in input)
      return input;
    if (input instanceof StickerSet)
      return input.inputStickerSet;
    if ("dice" in input) {
      return {
        _: "inputStickerSetDice",
        emoticon: input.dice
      };
    }
    switch (input.system) {
      case "animated":
        return { _: "inputStickerSetAnimatedEmoji" };
      case "animated_animations":
        return { _: "inputStickerSetAnimatedEmojiAnimations" };
      case "premium_gifts":
        return { _: "inputStickerSetPremiumGifts" };
      case "generic_animations":
        return { _: "inputStickerSetEmojiGenericAnimations" };
      case "default_statuses":
        return { _: "inputStickerSetEmojiDefaultStatuses" };
      case "default_topic_icons":
        return { _: "inputStickerSetEmojiDefaultTopicIcons" };
      case "default_channel_statuses":
        return { _: "inputStickerSetEmojiChannelDefaultStatuses" };
    }
  }
  function parseStickerOrThrow(doc) {
    const sticker = parseSticker(doc);
    if (!sticker) {
      throw new MtTypeAssertionError("full.documents", "sticker", "not a sticker");
    }
    return sticker;
  }
  class StickerSet {
    constructor(raw) {
      __publicField(this, "brief");
      __publicField(this, "full");
      __publicField(this, "cover");
      /**
       * Whether this object contains information about stickers inside the set
       */
      __publicField(this, "isFull");
      if (raw._ === "messages.stickerSet") {
        this.full = raw;
        this.brief = raw.set;
      } else if (raw._ === "stickerSet") {
        this.brief = raw;
      } else if (tl.tl.isAnyStickerSetCovered(raw)) {
        this.cover = raw;
        this.brief = raw.set;
      } else {
        throw new MtTypeAssertionError("StickerSet", "messages.stickerSet | stickerSet", raw._);
      }
      this.isFull = raw._ === "messages.stickerSet";
    }
    /**
     * Whether this sticker set was archived
     * (due to too many saved stickers in the current account)
     */
    get isArchived() {
      return this.brief.archived;
    }
    /**
     * Whether this stickerset is official
     */
    get isOfficial() {
      return this.brief.official;
    }
    /**
     * Whether this sticker set was created by the current user
     */
    get isCreator() {
      return this.brief.creator;
    }
    /**
     * Type of the stickers in this set
     */
    get type() {
      if (this.brief.masks) {
        return "mask";
      }
      if (this.brief.emojis) {
        return "emoji";
      }
      return "sticker";
    }
    /**
     * Date when this sticker set was installed
     */
    get installedDate() {
      return this.brief.installedDate ? new Date(this.brief.installedDate * 1e3) : null;
    }
    /**
     * Number of stickers in this sticker set
     */
    get count() {
      return this.brief.count;
    }
    /**
     * Input sticker set to be used in other API methods
     */
    get inputStickerSet() {
      return {
        _: "inputStickerSetID",
        id: this.brief.id,
        accessHash: this.brief.accessHash
      };
    }
    /**
     * Title of the sticker set
     */
    get title() {
      return this.brief.title;
    }
    /**
     * Short name of sticker set to use in `tg://addstickers?set=short_name`
     * or `https://t.me/addstickers/short_name`
     */
    get shortName() {
      return this.brief.shortName;
    }
    /**
     * List of stickers inside this sticker set
     *
     * @throws MtEmptyError
     *     In case this object does not contain info about stickers (i.e. {@link isFull} = false)
     */
    get stickers() {
      if (!this.full)
        throw new MtEmptyError();
      const stickers = [];
      const index = new LongMap();
      this.full.documents.forEach((doc) => {
        const sticker = parseStickerOrThrow(doc);
        const info = {
          alt: sticker.emoji,
          emoji: "",
          // populated later
          sticker
        };
        stickers.push(info);
        index.set(doc.id, info);
      });
      this.full.packs.forEach((pack) => {
        pack.documents.forEach((id2) => {
          const item = index.get(id2);
          if (item) {
            item.emoji += pack.emoticon;
          }
        });
      });
      return stickers;
    }
    /** Cover stickers of the sticker set. Not the same as {@link thumbnails} */
    get covers() {
      if (!this.cover)
        return [];
      switch (this.cover._) {
        case "stickerSetCovered":
          return [parseStickerOrThrow(this.cover.cover)];
        case "stickerSetMultiCovered":
          return this.cover.covers.map((it) => parseStickerOrThrow(it));
        case "stickerSetFullCovered":
          return this.cover.documents.map((it) => parseStickerOrThrow(it));
        case "stickerSetNoCovered":
          return [];
      }
    }
    /**
     * Available sticker set thumbnails.
     *
     * Returns empty array if not available
     * (i.e. first sticker should be used as thumbnail)
     */
    get thumbnails() {
      var _a2, _b;
      return (_b = (_a2 = this.brief.thumbs) == null ? void 0 : _a2.map((sz) => new Thumbnail(this.brief, sz))) != null ? _b : [];
    }
    /**
     * Get a sticker set thumbnail by its type.
     *
     * Thumbnail types are described in the
     * [Telegram docs](https://core.telegram.org/api/files#image-thumbnail-types),
     * and are also available as static members of {@link Thumbnail} for convenience.
     *
     * @param type  Thumbnail type
     */
    getThumbnail(type) {
      var _a2;
      return (_a2 = this.thumbnails.find((it) => it.type === type)) != null ? _a2 : null;
    }
    /**
     * Find stickers given their emoji.
     *
     * @param emoji  Emoji to search for
     * @throws MtEmptyError
     *     In case this object does not contain info about stickers (i.e. {@link isFull} = false)
     */
    getStickersByEmoji(emoji) {
      return this.stickers.filter((it) => it.alt === emoji || it.emoji.includes(emoji));
    }
    _getInputDocument(idx) {
      if (!this.full)
        throw new MtEmptyError();
      if (idx < 0)
        idx = this.full.documents.length + idx;
      const doc = this.full.documents[idx];
      if (!doc) {
        throw new RangeError(`Sticker set does not have sticker ${idx}`);
      }
      return {
        _: "inputDocument",
        id: doc.id,
        accessHash: doc.accessHash,
        fileReference: doc.fileReference
      };
    }
  }
  memoizeGetters(StickerSet, ["thumbnails", "stickers"]);
  class BusinessIntro {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Title of the intro.
     */
    get title() {
      return this.raw.title;
    }
    /**
     * Description of the intro.
     */
    get description() {
      return this.raw.description;
    }
    /**
     * Sticker of the intro.
     */
    get sticker() {
      if (!this.raw.sticker || this.raw.sticker._ === "documentEmpty")
        return null;
      const doc = parseDocument(this.raw.sticker);
      if (doc.type !== "sticker")
        return null;
      return doc;
    }
  }
  memoizeGetters(BusinessIntro, ["sticker"]);
  class BusinessLocation {
    constructor(raw) {
      this.raw = raw;
    }
    /** Address of the business */
    get address() {
      return this.raw.address;
    }
    get location() {
      if (!this.raw.geoPoint || this.raw.geoPoint._ === "geoPointEmpty")
        return null;
      return new Location(this.raw.geoPoint);
    }
  }
  memoizeGetters(BusinessLocation, ["location"]);
  const DAYS_IN_WEEK = 7;
  const MINUTES_IN_DAY = 24 * 60;
  function businessWorkHoursDaysToRaw(day) {
    const res = [];
    for(let   d of day) {
      const dayStart = d.day * MINUTES_IN_DAY;
      if (d.is24h) {
        res.push({
          _: "businessWeeklyOpen",
          startMinute: dayStart,
          endMinute: dayStart + MINUTES_IN_DAY
        });
        continue;
      }
      for(let   interval of d.intervals) {
        const start2 = dayStart + interval.startHour * 60 + interval.startMinute;
        const end = dayStart + interval.endHour * 60 + interval.endMinute;
        if (start2 >= end) {
          throw new MtArgumentError("startMinute >= endMinute");
        }
        res.push({
          _: "businessWeeklyOpen",
          startMinute: start2,
          endMinute: end
        });
      }
    }
    return res;
  }
  class BusinessWorkHours {
    constructor(raw) {
      this.raw = raw;
    }
    /** Whether the business is open right now */
    get isOpenNow() {
      return this.raw.openNow;
    }
    /**
     * Identifier of the time zone in which the {@link hours} are defined,
     * in the IANA format.
     */
    get timezoneId() {
      return this.raw.timezoneId;
    }
    /** Raw "open" intervals */
    get intervals() {
      return this.raw.weeklyOpen;
    }
    /**
     * Parsed business hours intervals per week day.
     *
     * @returns  Array of 7 elements, each representing a day of the week (starting from Monday = 0)
     */
    get days() {
      const days = Array.from({ length: DAYS_IN_WEEK }, (_, i) => ({
        day: i,
        is24h: false,
        intervals: []
      }));
      const sorted = [...this.raw.weeklyOpen].sort((a, b) => a.startMinute - b.startMinute);
      for (let i = 1; i < sorted.length; i++) {
        const prev = sorted[i - 1];
        const cur = sorted[i];
        if (prev.endMinute >= cur.startMinute) {
          prev.endMinute = cur.endMinute;
          sorted.splice(i, 1);
          i--;
        }
      }
      const mondayPrepend = [];
      for(let   interval of sorted) {
        if (interval.startMinute > interval.endMinute) {
          throw new MtArgumentError("startMinute is greater than endMinute");
        }
        const startDay = Math.floor(interval.startMinute / MINUTES_IN_DAY);
        const endDay = Math.floor(interval.endMinute / MINUTES_IN_DAY);
        if (endDay > DAYS_IN_WEEK + 1) {
          throw new MtArgumentError("interval spans more than a week");
        }
        for (let day = startDay, dayStart = startDay * MINUTES_IN_DAY; day <= endDay; day++, dayStart += MINUTES_IN_DAY) {
          const startWithin = Math.max(interval.startMinute, dayStart) - dayStart;
          const endWithin = Math.min(interval.endMinute, dayStart + MINUTES_IN_DAY) - dayStart;
          const startHour = Math.floor(startWithin / 60);
          const startMinute = startWithin % 60;
          const endHour = Math.floor(endWithin / 60);
          const endMinute = endWithin % 60;
          if (startHour === 0 && startMinute === 0 && endHour === 0 && endMinute === 0) {
            continue;
          }
          const obj = {
            startHour,
            startMinute,
            endHour,
            endMinute
          };
          if (day === DAYS_IN_WEEK) {
            mondayPrepend.push(obj);
          } else {
            days[day].intervals.push(obj);
          }
        }
      }
      if (mondayPrepend.length > 0) {
        days[0].intervals.unshift(...mondayPrepend);
      }
      for(let   day of days) {
        if (day.intervals.length !== 1)
          continue;
        const interval = day.intervals[0];
        if (interval.startHour === 0 && interval.startMinute === 0 && (interval.endHour === 24 && interval.endMinute === 0 || interval.endHour === 23 && interval.endMinute === 59)) {
          day.is24h = true;
        }
      }
      return days;
    }
  }
  memoizeGetters(BusinessWorkHours, ["days"]);
  class BusinessAccount {
    constructor(info) {
      this.info = info;
    }
    /** Introduction of the business account */
    get intro() {
      if (!this.info.businessIntro)
        return null;
      return new BusinessIntro(this.info.businessIntro);
    }
    /** Work hours of the business */
    get workHours() {
      if (!this.info.businessWorkHours)
        return null;
      return new BusinessWorkHours(this.info.businessWorkHours);
    }
    /** Location of the business */
    get location() {
      if (!this.info.businessLocation)
        return null;
      return new BusinessLocation(this.info.businessLocation);
    }
    /** Information about a greeting message */
    get greetingMessage() {
      var _a2;
      return (_a2 = this.info.businessGreetingMessage) != null ? _a2 : null;
    }
    /** Information about an "away" message */
    get awayMessage() {
      var _a2;
      return (_a2 = this.info.businessAwayMessage) != null ? _a2 : null;
    }
  }
  memoizeGetters(BusinessAccount, ["intro", "workHours", "location"]);
  class FullChat extends Chat {
    constructor(peer, fullPeer) {
      super(peer);
      __publicField(this, "_linkedChat");
      this.fullPeer = fullPeer;
    }
    /** @internal */
    static _parse(full) {
      var _a2;
      const peers = PeersIndex.from(full);
      if (full._ === "users.userFull") {
        const { fullUser } = full;
        const user = peers.user(full.fullUser.id);
        if (!user || user._ === "userEmpty") {
          throw new MtTypeAssertionError("Chat._parseFull", "user", (_a2 = user == null ? void 0 : user._) != null ? _a2 : "undefined");
        }
        const ret2 = new FullChat(user, fullUser);
        if (fullUser.personalChannelId) {
          ret2._linkedChat = new Chat(peers.chat(fullUser.personalChannelId));
        }
        return ret2;
      }
      const { fullChat } = full;
      const ret = new FullChat(peers.chat(fullChat.id), fullChat);
      if (fullChat._ === "channelFull" && fullChat.linkedChatId) {
        ret._linkedChat = new Chat(peers.chat(fullChat.linkedChatId));
      }
      return ret;
    }
    /**
     * Whether this chat (user) has restricted sending them voice/video messages.
     */
    get hasBlockedVoices() {
      var _a2;
      return ((_a2 = this.fullPeer) == null ? void 0 : _a2._) === "userFull" && this.fullPeer.voiceMessagesForbidden;
    }
    /** Whether paid reactions are enabled for this channel */
    get hasPaidReactions() {
      var _a2;
      return ((_a2 = this.fullPeer) == null ? void 0 : _a2._) === "channelFull" && this.fullPeer.paidReactionsAvailable;
    }
    /**
     * Full information about this chat's photo, if any.
     *
     * Unlike {@link Chat.photo}, this field contains additional information
     * about the photo, such as its date, more sizes, and is the only
     * way to get the animated profile photo.
     *
     * This field takes into account any personal/fallback photo
     * that the user may have set
     */
    get fullPhoto() {
      var _a2, _b;
      if (!this.fullPeer)
        return null;
      let photo;
      switch (this.fullPeer._) {
        case "userFull":
          photo = (_b = (_a2 = this.fullPeer.personalPhoto) != null ? _a2 : this.fullPeer.profilePhoto) != null ? _b : this.fullPeer.fallbackPhoto;
          break;
        case "chatFull":
        case "channelFull":
          photo = this.fullPeer.chatPhoto;
      }
      if ((photo == null ? void 0 : photo._) !== "photo")
        return null;
      return new Photo(photo);
    }
    /**
     * A custom photo (set by the current user) that should be displayed
     * instead of the actual chat photo.
     *
     * Currently only available for users.
     */
    get personalPhoto() {
      var _a2;
      if (!this.fullPeer || this.fullPeer._ !== "userFull")
        return null;
      if (((_a2 = this.fullPeer.personalPhoto) == null ? void 0 : _a2._) !== "photo")
        return null;
      return new Photo(this.fullPeer.personalPhoto);
    }
    /**
     * Actual profile photo of the user, bypassing the custom one.
     */
    get realPhoto() {
      var _a2;
      if (!this.fullPeer)
        return null;
      if (this.fullPeer._ !== "userFull")
        return this.fullPhoto;
      if (((_a2 = this.fullPeer.personalPhoto) == null ? void 0 : _a2._) !== "photo")
        return null;
      return new Photo(this.fullPeer.personalPhoto);
    }
    /**
     * A photo that the user has set to be shown
     * in case their actual profile photo is not available
     * due to privacy settings.
     *
     * Currently only available for users.
     */
    get publicPhoto() {
      var _a2;
      if (!this.fullPeer || this.fullPeer._ !== "userFull")
        return null;
      if (((_a2 = this.fullPeer.fallbackPhoto) == null ? void 0 : _a2._) !== "photo")
        return null;
      return new Photo(this.fullPeer.fallbackPhoto);
    }
    /**
     * Bio of the other party in a private chat, or description of a
     * group, supergroup or channel.
     */
    get bio() {
      var _a2, _b;
      return (_b = (_a2 = this.fullPeer) == null ? void 0 : _a2.about) != null ? _b : null;
    }
    /**
     * Chat's primary invite link, for groups, supergroups and channels.
     */
    get inviteLink() {
      var _a2;
      if (this.fullPeer && this.fullPeer._ !== "userFull") {
        switch ((_a2 = this.fullPeer.exportedInvite) == null ? void 0 : _a2._) {
          case "chatInvitePublicJoinRequests":
            return null;
          case "chatInviteExported":
            return new ChatInviteLink(this.fullPeer.exportedInvite);
        }
      }
      return null;
    }
    /**
     * For supergroups, information about the group sticker set.
     */
    get stickerSet() {
      var _a2;
      if (((_a2 = this.fullPeer) == null ? void 0 : _a2._) !== "channelFull" || !this.fullPeer.stickerset)
        return null;
      return new StickerSet(this.fullPeer.stickerset);
    }
    /**
     * For supergroups, information about the group emoji set.
     */
    get emojiSet() {
      var _a2;
      if (((_a2 = this.fullPeer) == null ? void 0 : _a2._) !== "channelFull" || !this.fullPeer.emojiset)
        return null;
      return new StickerSet(this.fullPeer.emojiset);
    }
    /**
     * Whether the group sticker set can be changed by you.
     */
    get canSetStickerSet() {
      var _a2;
      return this.fullPeer && this.fullPeer._ === "channelFull" ? (_a2 = this.fullPeer.canSetStickers) != null ? _a2 : null : null;
    }
    /**
     * Number of boosts applied by the current user to this chat.
     */
    get boostsApplied() {
      var _a2, _b;
      if (!this.fullPeer || this.fullPeer._ !== "channelFull")
        return 0;
      return (_b = (_a2 = this.fullPeer) == null ? void 0 : _a2.boostsApplied) != null ? _b : 0;
    }
    /**
     * Number of boosts required for the user to be unrestricted in this chat.
     */
    get boostsForUnrestrict() {
      var _a2, _b;
      if (!this.fullPeer || this.fullPeer._ !== "channelFull")
        return 0;
      return (_b = (_a2 = this.fullPeer) == null ? void 0 : _a2.boostsUnrestrict) != null ? _b : 0;
    }
    /** Whether the current user can view Telegram Stars revenue for this chat */
    get canViewStarsRevenue() {
      return this.fullPeer._ === "channelFull" && this.fullPeer.canViewStats;
    }
    /**
     * Chat members count, for groups, supergroups and channels only.
     */
    get membersCount() {
      var _a2;
      switch (this.fullPeer._) {
        case "userFull":
          return null;
        case "chatFull":
          if (this.fullPeer.participants._ !== "chatParticipants") {
            return null;
          }
          return this.fullPeer.participants.participants.length;
        case "channelFull":
          return (_a2 = this.fullPeer.participantsCount) != null ? _a2 : null;
      }
    }
    /**
     * Location of the chat.
     */
    get location() {
      var _a2;
      if (!this.fullPeer || this.fullPeer._ !== "channelFull" || ((_a2 = this.fullPeer.location) == null ? void 0 : _a2._) !== "channelLocation") {
        return null;
      }
      return new ChatLocation(this.fullPeer.location);
    }
    /**
     * Information about a linked chat:
     * - for channels: the discussion group
     * - for supergroups: the linked channel
     * - for users: the personal channel
     */
    get linkedChat() {
      var _a2;
      return (_a2 = this._linkedChat) != null ? _a2 : null;
    }
    /**
     * TTL of all messages in this chat, in seconds
     */
    get ttlPeriod() {
      var _a2, _b;
      return (_b = (_a2 = this.fullPeer) == null ? void 0 : _a2.ttlPeriod) != null ? _b : null;
    }
    /**
     * If this is a business account, information about the business.
     */
    get business() {
      if (!this.fullPeer || this.fullPeer._ !== "userFull")
        return null;
      return new BusinessAccount(this.fullPeer);
    }
  }
  memoizeGetters(FullChat, [
    "fullPhoto",
    "personalPhoto",
    "realPhoto",
    "publicPhoto",
    "location",
    "stickerSet",
    "emojiSet",
    "business"
  ]);
  function _findMessageInUpdate(client, res, isEdit = false, noDispatch = true, allowNull = false, randomId) {
    assertIsUpdatesGroup("_findMessageInUpdate", res);
    client.handleClientUpdate(res, noDispatch);
    let ourMessageId = 0;
    for(let   u of res.updates) {
      if (randomId && u._ === "updateMessageID" && u.randomId.eq(randomId)) {
        ourMessageId = u.id;
        continue;
      }
      if (isEdit) {
        if (!(u._ === "updateEditMessage" || u._ === "updateEditChannelMessage" || u._ === "updateBotEditBusinessMessage" || u._ === "updateBotNewBusinessMessage")) {
          continue;
        }
      } else {
        if (!(u._ === "updateNewMessage" || u._ === "updateNewChannelMessage" || u._ === "updateNewScheduledMessage" || u._ === "updateQuickReplyMessage" || u._ === "updateBotNewBusinessMessage")) {
          continue;
        }
      }
      if (ourMessageId !== 0 && u.message.id !== ourMessageId)
        continue;
      const peers = PeersIndex.from(res);
      return new Message(u.message, peers, u._ === "updateNewScheduledMessage");
    }
    if (allowNull)
      return null;
    throw new MtTypeAssertionError(
      "_findInUpdate (@ .updates[*])",
      "updateNewMessage | updateNewChannelMessage | updateNewScheduledMessage",
      "none"
    );
  }
  function _getPeerChainId(client, peer, prefix = "peer") {
    const id2 = peer._ === "inputPeerSelf" ? client.storage.self.getCached().userId : getMarkedPeerId(peer);
    return `${prefix}:${id2}`;
  }
  function _getDiscussionMessage(client, peer, message2) {
    return __async(this, null, function* () {
      const inputPeer = yield resolvePeer(client, peer);
      const res = yield client.call({
        _: "messages.getDiscussionMessage",
        peer: inputPeer,
        msgId: message2
      });
      if (!res.messages.length || res.messages[0]._ === "messageEmpty") {
        return [inputPeer, message2];
      }
      const msg = res.messages[0];
      const chat = res.chats.find((it) => it.id === msg.peerId.channelId);
      return [
        {
          _: "inputPeerChannel",
          channelId: chat.id,
          accessHash: chat.accessHash
        },
        msg.id
      ];
    });
  }
  function getDiscussionMessage(client, params) {
    return __async(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const inputPeer = yield resolvePeer(client, chatId);
      const res = yield client.call({
        _: "messages.getDiscussionMessage",
        peer: inputPeer,
        msgId: message2
      });
      if (!res.messages.length || res.messages[0]._ === "messageEmpty") {
        return null;
      }
      const msg = res.messages[0];
      const peers = PeersIndex.from(res);
      return new Message(msg, peers);
    });
  }
  function getMessages(client, chatId, messageIds, fromReply = false) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, chatId);
      if (!Array.isArray(messageIds))
        messageIds = [messageIds];
      const type = fromReply ? "inputMessageReplyTo" : "inputMessageID";
      const ids = messageIds.map((it) => ({
        _: type,
        id: it
      }));
      const isChannel = isInputPeerChannel(peer);
      const res = yield client.call(
        isChannel ? {
          _: "channels.getMessages",
          id: ids,
          channel: toInputChannel(peer)
        } : {
          _: "messages.getMessages",
          id: ids
        }
      );
      assertTypeIsNot("getMessages", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      let selfId;
      return res.messages.map((msg) => {
        var _a2, _b;
        if (msg._ === "messageEmpty")
          return null;
        if (!isChannel) {
          switch (peer._) {
            case "inputPeerSelf":
              if (selfId === void 0)
                selfId = (_b = (_a2 = client.storage.self.getCached()) == null ? void 0 : _a2.userId) != null ? _b : null;
              if (!(msg.peerId._ === "peerUser" && msg.peerId.userId === selfId)) {
                return null;
              }
              break;
            case "inputPeerUser":
            case "inputPeerUserFromMessage":
              if (!(msg.peerId._ === "peerUser" && msg.peerId.userId === peer.userId)) {
                return null;
              }
              break;
            case "inputPeerChat":
              if (!(msg.peerId._ === "peerChat" && msg.peerId.chatId === peer.chatId)) {
                return null;
              }
              break;
          }
        }
        return new Message(msg, peers);
      });
    });
  }
  function _normalizeQuickReplyShortcut(shortcut) {
    if (!shortcut)
      return void 0;
    if (typeof shortcut === "number") {
      return {
        _: "inputQuickReplyShortcutId",
        shortcutId: shortcut
      };
    }
    return {
      _: "inputQuickReplyShortcut",
      shortcut
    };
  }
  function _processCommonSendParameters(client, chatId, params) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      let peer = yield resolvePeer(client, chatId);
      let replyTo = normalizeMessageId(params.replyTo);
      const replyToPeer = typeof params.replyTo === "number" ? void 0 : (_a2 = params.replyTo) == null ? void 0 : _a2.chat.inputPeer;
      if (params.commentTo) {
        [peer, replyTo] = yield _getDiscussionMessage(client, peer, normalizeMessageId(params.commentTo));
      }
      if (params.mustReply) {
        if (!replyTo) {
          throw new MtArgumentError("mustReply used, but replyTo was not passed");
        }
        const msg = yield getMessages(client, peer, replyTo);
        if (!msg) {
          throw new MtMessageNotFoundError(getMarkedPeerId(peer), replyTo, "to reply to");
        }
      }
      if (params.replyToStory && replyTo) {
        throw new MtArgumentError("replyTo/commentTo and replyToStory cannot be used together");
      }
      let tlReplyTo;
      if (replyTo) {
        tlReplyTo = {
          _: "inputReplyToMessage",
          replyToMsgId: replyTo,
          replyToPeerId: replyToPeer,
          quoteText: (_b = params.quote) == null ? void 0 : _b.text,
          quoteEntities: (_c = params.quote) == null ? void 0 : _c.entities,
          quoteOffset: params.quoteOffset
        };
      } else if (params.replyToStory) {
        tlReplyTo = {
          _: "inputReplyToStory",
          storyId: params.replyToStory,
          peer
        };
      }
      let scheduleDate;
      if (params.schedule === "online") {
        scheduleDate = 2147483646;
      } else if (params.schedule) {
        scheduleDate = normalizeDate(params.schedule);
      }
      return {
        peer,
        replyTo: tlReplyTo,
        scheduleDate,
        quickReplyShortcut: _normalizeQuickReplyShortcut(params.quickReply),
        chainId: _getPeerChainId(client, peer, "send")
      };
    });
  }
  function sendMedia(client, chatId, media, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      if (typeof media === "string") {
        media = {
          type: "auto",
          file: media
        };
      }
      const { peer, replyTo, scheduleDate, chainId, quickReplyShortcut } = yield _processCommonSendParameters(
        client,
        chatId,
        params
      );
      const inputMedia = yield _normalizeInputMedia(client, media, {
        progressCallback: params.progressCallback,
        uploadPeer: peer
      });
      const [message2, entities] = yield _normalizeInputText(
        client,
        // some types dont have `caption` field, and ts warns us,
        // but since it's JS, they'll just be `undefined` and properly handled by the method
        params.caption || media.caption
      );
      const replyMarkup = _convertToTl$2(params.replyMarkup);
      const randomId = randomLong();
      const res = yield _maybeInvokeWithBusinessConnection(
        client,
        params.businessConnectionId,
        {
          _: "messages.sendMedia",
          peer,
          media: inputMedia,
          silent: params.silent,
          replyTo,
          randomId,
          scheduleDate,
          replyMarkup,
          message: message2,
          entities,
          clearDraft: params.clearDraft,
          noforwards: params.forbidForwards,
          sendAs: params.sendAs ? yield resolvePeer(client, params.sendAs) : void 0,
          invertMedia: params.invert,
          quickReplyShortcut,
          effect: params.effect
        },
        { chainId }
      );
      const msg = _findMessageInUpdate(client, res, false, !params.shouldDispatch, false, randomId);
      return msg;
    });
  }
  function sendMediaGroup(client, chatId, medias, params) {
    return __async(this, null, function* () {
      var _a2;
      if (!params)
        params = {};
      const { peer, replyTo, scheduleDate, chainId, quickReplyShortcut } = yield _processCommonSendParameters(
        client,
        chatId,
        params
      );
      const multiMedia = [];
      for (let i = 0; i < medias.length; i++) {
        let media = medias[i];
        if (typeof media === "string") {
          media = {
            type: "auto",
            file: media
          };
        }
        const inputMedia = yield _normalizeInputMedia(
          client,
          media,
          {
            progressCallback: (_a2 = params.progressCallback) == null ? void 0 : _a2.bind(null, i),
            // i have no fucking clue why we should upload it manually,
            // but otherwise Telegram throws MEDIA_INVALID
            // fuck my life
            uploadPeer: peer,
            businessConnectionId: params.businessConnectionId
          },
          true
        );
        const [message2, entities] = yield _normalizeInputText(
          client,
          // some types dont have `caption` field, and ts warns us,
          // but since it's JS, they'll just be `undefined` and properly handled by the method
          media.caption
        );
        multiMedia.push({
          _: "inputSingleMedia",
          randomId: randomLong(),
          media: inputMedia,
          message: message2,
          entities
        });
      }
      const res = yield _maybeInvokeWithBusinessConnection(
        client,
        params.businessConnectionId,
        {
          _: "messages.sendMultiMedia",
          peer,
          multiMedia,
          silent: params.silent,
          replyTo,
          scheduleDate,
          clearDraft: params.clearDraft,
          noforwards: params.forbidForwards,
          sendAs: params.sendAs ? yield resolvePeer(client, params.sendAs) : void 0,
          invertMedia: params.invertMedia,
          quickReplyShortcut,
          effect: params.effect
        },
        { chainId }
      );
      assertIsUpdatesGroup("sendMediaGroup", res);
      client.handleClientUpdate(res);
      const peers = PeersIndex.from(res);
      const msgs = res.updates.filter(
        (u) => u._ === "updateNewMessage" || u._ === "updateNewChannelMessage" || u._ === "updateNewScheduledMessage"
      ).map((u) => new Message(u.message, peers, u._ === "updateNewScheduledMessage"));
      return msgs;
    });
  }
  function sendText(client, chatId, text, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      const [message2, entities] = yield _normalizeInputText(client, text);
      const replyMarkup = _convertToTl$2(params.replyMarkup);
      const { peer, replyTo, scheduleDate, chainId, quickReplyShortcut } = yield _processCommonSendParameters(
        client,
        chatId,
        params
      );
      const randomId = randomLong();
      const res = yield _maybeInvokeWithBusinessConnection(
        client,
        params.businessConnectionId,
        {
          _: "messages.sendMessage",
          peer,
          noWebpage: params.disableWebPreview,
          silent: params.silent,
          replyTo,
          randomId,
          scheduleDate,
          replyMarkup,
          message: message2,
          entities,
          clearDraft: params.clearDraft,
          noforwards: params.forbidForwards,
          sendAs: params.sendAs ? yield resolvePeer(client, params.sendAs) : void 0,
          invertMedia: params.invertMedia,
          quickReplyShortcut,
          effect: params.effect
        },
        { chainId }
      );
      if (res._ === "updateShortSentMessage") {
        const msg2 = {
          _: "message",
          id: res.id,
          peerId: inputPeerToPeer(peer),
          fromId: { _: "peerUser", userId: client.storage.self.getCached().userId },
          message: message2,
          date: res.date,
          out: res.out,
          replyMarkup,
          entities: res.entities
        };
        if (!params.shouldDispatch) {
          client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
        }
        const peers = new PeersIndex();
        const fetchPeer = (peer2) => __async(this, null, function* () {
          const id2 = getMarkedPeerId(peer2);
          let cached = yield client.storage.peers.getCompleteById(id2);
          if (!cached) {
            cached = yield _getRawPeerBatched(client, yield resolvePeer(client, peer2));
          }
          if (!cached) {
            throw new MtTypeAssertionError("sendText (@ getFullPeerById)", "user | chat", "null");
          }
          switch (cached._) {
            case "user":
              peers.users.set(cached.id, cached);
              break;
            case "chat":
            case "chatForbidden":
            case "channel":
            case "channelForbidden":
              peers.chats.set(cached.id, cached);
              break;
            default:
              throw new MtTypeAssertionError(
                "sendText (@ users.getUsers)",
                "user | chat | channel",
                // not very accurate, but good enough
                cached._
              );
          }
        });
        yield Promise.all([fetchPeer(peer), fetchPeer(msg2.fromId)]);
        const ret = new Message(msg2, peers);
        return ret;
      }
      const msg = _findMessageInUpdate(client, res, false, !params.shouldDispatch, false, randomId);
      return msg;
    });
  }
  const CONVERSATION_SYMBOL = Symbol("conversation");
  class Conversation {
    constructor(client, chat) {
      __publicField(this, "_inputPeer");
      __publicField(this, "_chatId");
      __publicField(this, "_started", false);
      __publicField(this, "_lastMessage");
      __publicField(this, "_lastReceivedMessage");
      __publicField(this, "_queuedNewMessage", new Deque());
      __publicField(this, "_pendingNewMessages", new Deque());
      __publicField(this, "_lock", new AsyncLock());
      __publicField(this, "_pendingEditMessage", /* @__PURE__ */ new Map());
      __publicField(this, "_recentEdits", new Deque(10));
      __publicField(this, "_pendingRead", /* @__PURE__ */ new Map());
      this.client = client;
      this.chat = chat;
      if (!(CONVERSATION_SYMBOL in client)) {
        client[CONVERSATION_SYMBOL] = {
          pendingConversations: /* @__PURE__ */ new Map(),
          hasConversations: false
        };
      }
    }
    static _getState(client) {
      return client[CONVERSATION_SYMBOL];
    }
    /**
     * Pass the update to the conversation manager and all registered
     * conversations on this client.
     *
     * @returns `true` if the update was handled by some conversation
     */
    static handleUpdate(client, update) {
      const state = Conversation._getState(client);
      if (!(state == null ? void 0 : state.hasConversations))
        return false;
      let chatId;
      switch (update.name) {
        case "new_message":
        case "edit_message":
          chatId = getMarkedPeerId(update.data.raw.peerId);
          break;
        case "history_read":
          chatId = update.data.chatId;
          break;
        default:
          return false;
      }
      const conv = state.pendingConversations.get(chatId);
      if (!conv)
        return false;
      for(let   c of conv) {
        switch (update.name) {
          case "new_message":
            c._onNewMessage(update.data);
            return true;
          case "edit_message":
            c._onEditMessage(update.data);
            return true;
          case "history_read":
            c._onHistoryRead(update.data);
            return true;
        }
      }
      return false;
    }
    /**
     * Get the input peer that this conversation is with
     */
    get inputPeer() {
      if (!this._started) {
        throw new MtArgumentError("Conversation hasn't started yet");
      }
      return this._inputPeer;
    }
    /**
     * ID of the very last message in this conversation.
     */
    get lastMessage() {
      if (!this._started) {
        throw new MtArgumentError("Conversation hasn't started yet");
      }
      return this._lastMessage;
    }
    /**
     * ID of the last incoming message in this conversation.
     *
     * Note that before any messages were received since the {@link start}
     * of the conversation, this will equal to {@link lastMessage}
     */
    get lastReceivedMessage() {
      if (!this._started) {
        throw new MtArgumentError("Conversation hasn't started yet");
      }
      return this._lastReceivedMessage;
    }
    /**
     * Start the conversation
     */
    start() {
      return __async(this, null, function* () {
        if (this._started)
          return;
        this._started = true;
        this._inputPeer = yield resolvePeer(this.client, this.chat);
        this._chatId = getMarkedPeerId(this._inputPeer);
        const [dialog] = yield getPeerDialogs(this.client, this._inputPeer);
        const lastMessage = dialog == null ? void 0 : dialog.lastMessage;
        if (lastMessage) {
          this._lastMessage = this._lastReceivedMessage = lastMessage.id;
        } else {
          this._lastMessage = this._lastReceivedMessage = 0;
        }
        const state = Conversation._getState(this.client);
        if (!state.pendingConversations.has(this._chatId)) {
          state.pendingConversations.set(this._chatId, []);
        }
        state.pendingConversations.get(this._chatId).push(this);
        state.hasConversations = true;
      });
    }
    /**
     * Stop the conversation
     */
    stop() {
      var _a2;
      if (!this._started)
        return;
      const state = Conversation._getState(this.client);
      const pending = state.pendingConversations.get(this._chatId);
      const pendingIdx = (_a2 = pending == null ? void 0 : pending.indexOf(this)) != null ? _a2 : -1;
      if (pendingIdx > -1) {
        pending.splice(pendingIdx, 1);
      }
      if (pending && !pending.length) {
        state.pendingConversations.delete(this._chatId);
      }
      state.hasConversations = Boolean(state.pendingConversations.size);
      this._queuedNewMessage.clear();
      this._pendingNewMessages.clear();
      this._pendingEditMessage.clear();
      this._recentEdits.clear();
      this._pendingRead.clear();
      this._started = false;
    }
    _recordMessage(msg, incoming = false) {
      this._lastMessage = msg.id;
      if (incoming)
        this._lastReceivedMessage = msg.id;
      return msg;
    }
    /**
     * Send a text message to this conversation.
     *
     * Wrapper over {@link sendText}
     */
    sendText(...params) {
      return __async(this, null, function* () {
        if (!this._started) {
          throw new MtArgumentError("Conversation hasn't started yet");
        }
        return this._recordMessage(yield sendText(this.client, this._inputPeer, ...params));
      });
    }
    /**
     * Send a media to this conversation.
     *
     * Wrapper over {@link sendMedia}
     */
    sendMedia(...params) {
      return __async(this, null, function* () {
        if (!this._started) {
          throw new MtArgumentError("Conversation hasn't started yet");
        }
        return this._recordMessage(yield sendMedia(this.client, this._inputPeer, ...params));
      });
    }
    /**
     * Send a media group to this conversation.
     *
     * Wrapper over {@link sendMediaGroup}
     */
    sendMediaGroup(...params) {
      return __async(this, null, function* () {
        if (!this._started) {
          throw new MtArgumentError("Conversation hasn't started yet");
        }
        const msgs = yield sendMediaGroup(this.client, this._inputPeer, ...params);
        this._recordMessage(msgs[msgs.length - 1]);
        return msgs;
      });
    }
    /**
     * Mark the conversation as read up to a certain point.
     *
     * By default, reads until the last message.
     * You can pass `message=null` to read the entire conversation,
     * or pass message ID to read up until that ID.
     */
    markRead({
      message: message2,
      clearMentions = true
    } = {}) {
      var _a2;
      if (!this._started) {
        throw new MtArgumentError("Conversation hasn't started yet");
      }
      if (message2 === null) {
        message2 = 0;
      } else if (message2 === void 0) {
        message2 = (_a2 = this._lastMessage) != null ? _a2 : 0;
      }
      return readHistory(this.client, this._inputPeer, { maxId: message2, clearMentions });
    }
    /**
     * Helper method that calls {@link start},
     * the provided function and then {@link stop}.
     *
     * It is preferred that you use this function rather than
     * manually starting and stopping the conversation.
     *
     * If you don't stop the conversation when you're done,
     * it *will* lead to memory leaks.
     *
     * @param handler
     */
    with(handler) {
      return __async(this, null, function* () {
        yield this.start();
        let err2;
        let res;
        try {
          res = yield handler();
        } catch (e) {
          err2 = e;
        }
        this.stop();
        if (err2)
          throw err2;
        return res;
      });
    }
    /**
     * Wait for a new message in the conversation
     *
     * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
     * @param [timeout]  Timeout for the handler in ms. Pass `null` to disable.
     *   When the timeout is reached, `MtTimeoutError` is thrown.
     */
    waitForNewMessage(filter, timeout = 15e3) {
      if (!this._started) {
        throw new MtArgumentError("Conversation hasn't started yet");
      }
      const promise = createControllablePromise();
      let timer;
      if (timeout !== null) {
        timer = setTimeoutWrap(() => {
          promise.reject(new MtTimeoutError(timeout));
          this._queuedNewMessage.removeBy((it) => it.promise === promise);
        }, timeout);
      }
      this._queuedNewMessage.pushBack({
        promise,
        check: filter,
        timeout: timer
      });
      this._processPendingNewMessages();
      return promise;
    }
    /**
     * Wait for a response for the given message
     * (def. the last one) in the conversation.
     *
     * A message is considered to be a response if
     * it was sent after the given one.
     *
     * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
     * @param params
     */
    waitForResponse(filter, params) {
      var _a2, _b;
      const msgId = (_b = (_a2 = params == null ? void 0 : params.message) != null ? _a2 : this._lastMessage) != null ? _b : 0;
      const pred = filter ? (msg) => msg.id > msgId ? filter(msg) : false : (msg) => msg.id > msgId;
      return this.waitForNewMessage(pred, params == null ? void 0 : params.timeout);
    }
    /**
     * Wait for the reply for the given message'
     * (def. the last one) in the conversation.
     *
     * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
     * @param params
     */
    waitForReply(filter, params) {
      var _a2;
      const msgId = (_a2 = params == null ? void 0 : params.message) != null ? _a2 : this._lastMessage;
      if (!msgId) {
        throw new MtArgumentError("Provide message for which to wait for reply for");
      }
      const pred = filter ? (msg) => {
        var _a3;
        return ((_a3 = msg.replyToMessage) == null ? void 0 : _a3.id) === msgId ? filter(msg) : false;
      } : (msg) => {
        var _a3;
        return ((_a3 = msg.replyToMessage) == null ? void 0 : _a3.id) === msgId;
      };
      return this.waitForNewMessage(pred, params == null ? void 0 : params.timeout);
    }
    /**
     * Wait for a message to be edited in the conversation.
     * By defaults wait for the last message sent by the other party
     * (at the moment) to be edited.
     *
     * Returns the edited message.
     *
     * @param filter  Filter for the handler. You can use any filter you can use for dispatcher
     * @param params
     */
    waitForEdit(filter, params) {
      return __async(this, null, function* () {
        var _a2;
        if (!this._started) {
          throw new MtArgumentError("Conversation hasn't started yet");
        }
        const msgId = (_a2 = params == null ? void 0 : params.message) != null ? _a2 : this._lastReceivedMessage;
        if (!msgId) {
          throw new MtArgumentError("Provide message for which to wait for edit for");
        }
        const promise = createControllablePromise();
        let timer;
        const timeout = params == null ? void 0 : params.timeout;
        if (timeout) {
          timer = setTimeoutWrap(() => {
            promise.reject(new MtTimeoutError(timeout));
            this._pendingEditMessage.delete(msgId);
          }, timeout);
        }
        this._pendingEditMessage.set(msgId, {
          promise,
          check: filter,
          timeout: timer
        });
        this._processRecentEdits();
        return promise;
      });
    }
    /**
     * Wait for the message to be read by the other party.
     *
     * Note that reading the message doesn't mean the response was sent,
     * and if the response was sent, it doesn't mean that the message was read.
     *
     * @param message  Message for which to wait for read for. Defaults to last message.
     * @param timeout  Timeout for the handler in ms, def. 15 sec. Pass `null` to disable.
     *   When the timeout is reached, `TimeoutError` is thrown.
     */
    waitForRead(message2, timeout = 15e3) {
      return __async(this, null, function* () {
        if (!this._started) {
          throw new MtArgumentError("Conversation hasn't started yet");
        }
        const msgId = message2 != null ? message2 : this._lastMessage;
        if (!msgId) {
          throw new MtArgumentError("Provide message for which to wait for read for");
        }
        const [dialog] = yield getPeerDialogs(this.client, this._inputPeer);
        if (dialog.lastRead >= msgId)
          return;
        const promise = createControllablePromise();
        let timer;
        if (timeout !== null) {
          timer = setTimeoutWrap(() => {
            promise.reject(new MtTimeoutError(timeout));
            this._pendingRead.delete(msgId);
          }, timeout);
        }
        this._pendingRead.set(msgId, {
          promise,
          timeout: timer
        });
        return promise;
      });
    }
    _onNewMessage(msg) {
      if (msg.chat.id !== this._chatId)
        return;
      if (!this._queuedNewMessage.length) {
        this._pendingNewMessages.pushBack(msg);
        return;
      }
      const it = this._queuedNewMessage.peekFront();
      void this._lock.acquire().then(() => __async(this, null, function* () {
        try {
          if (!it.check || (yield it.check(msg))) {
            if (it.timeout)
              clearTimeoutWrap(it.timeout);
            it.promise.resolve(msg);
            this._queuedNewMessage.popFront();
          }
        } catch (e) {
          this.client.emitError(e);
        }
        this._lastMessage = this._lastReceivedMessage = msg.id;
        this._lock.release();
      }));
    }
    _onEditMessage(msg, fromRecent = false) {
      if (msg.chat.id !== this._chatId)
        return;
      const it = this._pendingEditMessage.get(msg.id);
      if (!it) {
        if (!fromRecent) {
          this._recentEdits.pushBack(msg);
        }
        return;
      }
      (() => __async(this, null, function* () {
        if (!it.check || (yield it.check(msg))) {
          if (it.timeout)
            clearTimeoutWrap(it.timeout);
          it.promise.resolve(msg);
          this._pendingEditMessage.delete(msg.id);
        }
      }))().catch((e) => {
        this.client.emitError(e);
      });
    }
    _onHistoryRead(upd) {
      if (upd.chatId !== this._chatId)
        return;
      const lastRead = upd.maxReadId;
      for(let   msgId of this._pendingRead.keys()) {
        if (msgId <= lastRead) {
          const it = this._pendingRead.get(msgId);
          if (it.timeout)
            clearTimeoutWrap(it.timeout);
          it.promise.resolve();
          this._pendingRead.delete(msgId);
        }
      }
    }
    _processPendingNewMessages() {
      if (!this._pendingNewMessages.length)
        return;
      let it;
      while (it = this._pendingNewMessages.popFront()) {
        this._onNewMessage(it);
      }
    }
    _processRecentEdits() {
      if (!this._recentEdits.length)
        return;
      const iter = this._recentEdits.iter();
      let it;
      while (!(it = iter.next()).done) {
        this._onEditMessage(it.value, true);
      }
    }
  }
  const sentCodeMap = {
    "auth.sentCodeTypeApp": "app",
    "auth.sentCodeTypeCall": "call",
    "auth.sentCodeTypeFlashCall": "flash_call",
    "auth.sentCodeTypeSms": "sms",
    "auth.sentCodeTypeMissedCall": "missed_call",
    "auth.sentCodeTypeEmailCode": "email",
    "auth.sentCodeTypeSetUpEmailRequired": "email_required",
    "auth.sentCodeTypeFragmentSms": "fragment",
    "auth.sentCodeTypeFirebaseSms": "firebase",
    "auth.sentCodeTypeSmsWord": "sms_word",
    "auth.sentCodeTypeSmsPhrase": "sms_phrase"
  };
  const nextCodeMap = {
    "auth.codeTypeCall": "call",
    "auth.codeTypeFlashCall": "flash_call",
    "auth.codeTypeSms": "sms",
    "auth.codeTypeMissedCall": "missed_call",
    "auth.codeTypeFragmentSms": "fragment"
  };
  class SentCode {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Type of currently sent confirmation code
     */
    get type() {
      return sentCodeMap[this.raw.type._];
    }
    /**
     * Type of the confirmation code that will be sent
     * if you call {@link TelegramClient.resendCode}.
     */
    get nextType() {
      return this.raw.nextType ? nextCodeMap[this.raw.nextType._] : "none";
    }
    /**
     * Confirmation code identifier used for the next authorization steps
     * (like {@link TelegramClient.signIn} and {@link TelegramClient.signUp})
     */
    get phoneCodeHash() {
      return this.raw.phoneCodeHash;
    }
    /**
     * Delay in seconds to wait before calling {@link TelegramClient.resendCode}
     */
    get timeout() {
      var _a2;
      return (_a2 = this.raw.timeout) != null ? _a2 : 0;
    }
    /**
     * If the code is sent via SMS with a word/phrase, this field *may* contain the beginning of the message
     */
    get beginning() {
      switch (this.raw.type._) {
        case "auth.sentCodeTypeSmsPhrase":
        case "auth.sentCodeTypeSmsWord":
          return this.raw.type.beginning;
        default:
          return void 0;
      }
    }
    /**
     * Length of the code (0 for flash calls)
     */
    get length() {
      return "length" in this.raw.type ? this.raw.type.length : 0;
    }
  }
  class GameHighScore {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * User who has scored this score
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * Position in the records list
     */
    get position() {
      return this.raw.pos;
    }
    /**
     * Score
     */
    get score() {
      return this.raw.score;
    }
  }
  memoizeGetters(GameHighScore, ["user"]);
  function _convertToTl$1(client, obj) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      switch (obj.type) {
        case "text": {
          const [message2, entities] = yield _normalizeInputText(client, obj.text);
          return {
            _: "inputBotInlineMessageText",
            message: message2,
            entities,
            replyMarkup: _convertToTl$2(obj.replyMarkup),
            invertMedia: obj.invertMedia
          };
        }
        case "media": {
          const [message2, entities] = yield _normalizeInputText(client, obj.text);
          return {
            _: "inputBotInlineMessageMediaAuto",
            message: message2,
            entities,
            replyMarkup: _convertToTl$2(obj.replyMarkup),
            invertMedia: obj.invertMedia
          };
        }
        case "geo":
        case "geo_live":
          return {
            _: "inputBotInlineMessageMediaGeo",
            geoPoint: {
              _: "inputGeoPoint",
              lat: obj.latitude,
              long: obj.longitude
            },
            // fields will be `undefined` if this is a `geo`
            heading: obj.heading,
            period: obj.period,
            proximityNotificationRadius: obj.proximityNotificationRadius,
            replyMarkup: _convertToTl$2(obj.replyMarkup)
          };
        case "venue":
          return {
            _: "inputBotInlineMessageMediaVenue",
            geoPoint: {
              _: "inputGeoPoint",
              lat: obj.latitude,
              long: obj.longitude
            },
            title: obj.title,
            address: obj.address,
            provider: (_b = (_a2 = obj.source) == null ? void 0 : _a2.provider) != null ? _b : "",
            venueId: (_d = (_c = obj.source) == null ? void 0 : _c.id) != null ? _d : "",
            venueType: (_f = (_e = obj.source) == null ? void 0 : _e.type) != null ? _f : "",
            replyMarkup: _convertToTl$2(obj.replyMarkup)
          };
        case "game":
          return {
            _: "inputBotInlineMessageGame",
            replyMarkup: _convertToTl$2(obj.replyMarkup)
          };
        case "contact":
          return {
            _: "inputBotInlineMessageMediaContact",
            phoneNumber: obj.phone,
            firstName: obj.firstName,
            lastName: (_g = obj.lastName) != null ? _g : "",
            vcard: (_h = obj.vcard) != null ? _h : "",
            replyMarkup: _convertToTl$2(obj.replyMarkup)
          };
        case "webpage": {
          const [message2, entities] = yield _normalizeInputText(client, obj.text);
          return {
            _: "inputBotInlineMessageMediaWebPage",
            message: message2,
            entities,
            replyMarkup: _convertToTl$2(obj.replyMarkup),
            invertMedia: obj.invertMedia,
            forceLargeMedia: obj.size === "large",
            forceSmallMedia: obj.size === "small",
            optional: !obj.required,
            url: obj.url
          };
        }
        default:
          assertNever$1();
      }
    });
  }
  function _convertToTl(client, results) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e;
      const normalizeThumb = (obj, fallback) => {
        var _a3, _b2;
        if (obj.type !== "voice" && obj.type !== "audio" && obj.type !== "sticker" && obj.type !== "game") {
          if (!obj.thumb || typeof obj.thumb === "string") {
            if (!obj.thumb && !fallback) {
              return void 0;
            }
            return {
              _: "inputWebDocument",
              size: 0,
              url: obj.thumb || fallback,
              mimeType: obj.type === "gif" ? (_b2 = (_a3 = obj.thumbMime) != null ? _a3 : obj.mime) != null ? _b2 : "video/mp4" : "image/jpeg",
              attributes: []
            };
          }
          return obj.thumb;
        }
      };
      const items = [];
      let isGallery = false;
      let forceVertical = false;
      for(let   obj of results) {
        switch (obj.type) {
          case "article": {
            forceVertical = true;
            let sendMessage2;
            if (obj.message) {
              sendMessage2 = yield _convertToTl$1(client, obj.message);
            } else {
              let message2 = obj.title;
              const entities = [
                {
                  _: "messageEntityBold",
                  offset: 0,
                  length: message2.length
                }
              ];
              if (obj.url) {
                entities.push({
                  _: "messageEntityTextUrl",
                  url: obj.url,
                  offset: 0,
                  length: message2.length
                });
              }
              if (obj.description) {
                message2 += `
${obj.description}`;
              }
              sendMessage2 = {
                _: "inputBotInlineMessageText",
                message: message2,
                entities
              };
            }
            items.push({
              _: "inputBotInlineResult",
              id: obj.id,
              type: obj.type,
              title: obj.title,
              description: obj.description,
              url: obj.hideUrl ? void 0 : obj.url,
              content: obj.url && obj.hideUrl ? {
                _: "inputWebDocument",
                url: obj.url,
                mimeType: "text/html",
                size: 0,
                attributes: []
              } : void 0,
              thumb: typeof obj.thumb === "string" ? normalizeThumb(obj) : obj.thumb,
              sendMessage: sendMessage2
            });
            continue;
          }
          case "game": {
            let sendMessage2;
            if (obj.message) {
              sendMessage2 = yield _convertToTl$1(client, obj.message);
              if (sendMessage2._ !== "inputBotInlineMessageGame") {
                throw new MtArgumentError("game inline result must contain a game inline message");
              }
            } else {
              sendMessage2 = {
                _: "inputBotInlineMessageGame"
              };
            }
            items.push({
              _: "inputBotInlineResultGame",
              id: obj.id,
              shortName: obj.shortName,
              sendMessage: sendMessage2
            });
            continue;
          }
          case "gif":
          case "photo":
          case "sticker":
            isGallery = true;
            break;
          case "audio":
          case "contact":
          case "voice":
            forceVertical = true;
        }
        let sendMessage;
        if (obj.message) {
          sendMessage = yield _convertToTl$1(client, obj.message);
        } else if (obj.type === "venue") {
          if (obj.latitude && obj.longitude) {
            sendMessage = {
              _: "inputBotInlineMessageMediaVenue",
              title: obj.title,
              address: obj.address,
              geoPoint: {
                _: "inputGeoPoint",
                lat: obj.latitude,
                long: obj.longitude
              },
              provider: "",
              venueId: "",
              venueType: ""
            };
          } else {
            throw new MtArgumentError("message or location (lat&lon) bust be supplied for venue inline result");
          }
        } else if (obj.type === "video" && obj.isEmbed && typeof obj.media === "string") {
          sendMessage = {
            _: "inputBotInlineMessageText",
            message: obj.media
          };
        } else if (obj.type === "geo") {
          sendMessage = {
            _: "inputBotInlineMessageMediaGeo",
            geoPoint: {
              _: "inputGeoPoint",
              lat: obj.latitude,
              long: obj.longitude
            }
          };
        } else if (obj.type === "contact") {
          sendMessage = {
            _: "inputBotInlineMessageMediaContact",
            phoneNumber: obj.phone,
            firstName: obj.firstName,
            lastName: (_a2 = obj.lastName) != null ? _a2 : "",
            vcard: ""
          };
        } else {
          sendMessage = {
            _: "inputBotInlineMessageMediaAuto",
            message: ""
          };
        }
        let media;
        if (obj.type !== "geo" && obj.type !== "venue" && obj.type !== "contact") {
          if (typeof obj.media === "string") {
            if (obj.media.match(/^https?:\/\//)) {
              if (obj.type === "sticker") {
                throw new MtArgumentError("sticker inline result cannot contain a URL");
              }
              let mime;
              if (obj.type === "video") {
                mime = "video/mp4";
              } else if (obj.type === "audio") {
                mime = (_b = obj.mime) != null ? _b : "audio/mpeg";
              } else if (obj.type === "gif") {
                mime = (_c = obj.mime) != null ? _c : "video/mp4";
              } else if (obj.type === "voice") {
                mime = "audio/ogg";
              } else if (obj.type === "file") {
                if (!obj.mime) {
                  throw new MtArgumentError("MIME type must be specified for file inline result");
                }
                mime = obj.mime;
              } else {
                mime = "image/jpeg";
              }
              const attributes = [];
              if ((obj.type === "video" || obj.type === "gif" || obj.type === "photo") && obj.width && obj.height) {
                if (obj.type !== "photo" && obj.duration) {
                  attributes.push({
                    _: "documentAttributeVideo",
                    w: obj.width,
                    h: obj.height,
                    duration: obj.duration
                  });
                } else {
                  attributes.push({
                    _: "documentAttributeImageSize",
                    w: obj.width,
                    h: obj.height
                  });
                }
              } else if (obj.type === "audio" || obj.type === "voice") {
                attributes.push({
                  _: "documentAttributeAudio",
                  voice: obj.type === "voice",
                  duration: (_d = obj.duration) != null ? _d : 0,
                  title: obj.type === "audio" ? obj.title : "",
                  performer: obj.type === "audio" ? obj.performer : ""
                });
              }
              attributes.push({
                _: "documentAttributeFilename",
                fileName: extractFileName(obj.media)
              });
              media = {
                _: "inputWebDocument",
                url: obj.media,
                mimeType: mime,
                size: 0,
                attributes
              };
            } else if (obj.type === "photo") {
              media = fileIdToInputPhoto(obj.media);
            } else {
              media = fileIdToInputDocument(obj.media);
            }
          } else {
            media = obj.media;
          }
        }
        let title;
        let description;
        if (obj.type === "contact") {
          title = ((_e = obj.lastName) == null ? void 0 : _e.length) ? `${obj.firstName} ${obj.lastName}` : obj.firstName;
        } else if (obj.type !== "sticker") {
          title = obj.title;
        }
        if (obj.type === "audio") {
          description = obj.performer;
        } else if (obj.type === "geo") {
          description = `${obj.latitude} ${obj.longitude}`;
        } else if (obj.type === "venue") {
          description = obj.address;
        } else if (obj.type === "contact") {
          description = obj.phone;
        } else if (obj.type !== "voice" && obj.type !== "sticker") {
          description = obj.description;
        }
        if (!media || media._ === "inputWebDocument") {
          items.push({
            _: "inputBotInlineResult",
            id: obj.id,
            type: obj.type,
            title,
            description,
            content: media,
            thumb: normalizeThumb(obj, media == null ? void 0 : media.url),
            sendMessage
          });
          continue;
        }
        if (media._ === "inputPhoto" || media._ === "inputPhotoEmpty") {
          items.push({
            _: "inputBotInlineResultPhoto",
            id: obj.id,
            type: obj.type,
            photo: media,
            sendMessage
          });
          continue;
        }
        items.push({
          _: "inputBotInlineResultDocument",
          id: obj.id,
          type: obj.type,
          title,
          description,
          document: media,
          sendMessage
        });
      }
      return [isGallery && !forceVertical, items];
    });
  }
  class CollectibleInfo {
    constructor(raw) {
      this.raw = raw;
    }
    /** Date when the item was purchased */
    get purchaseDate() {
      return new Date(this.raw.purchaseDate * 1e3);
    }
    /** Crypto currency used to purchase the item */
    get cryptoCurrency() {
      return this.raw.cryptoCurrency;
    }
    /**
     * Amount of crypto currency used to purchase the item,
     * in the smallest units
     */
    get cryptoAmount() {
      return this.raw.cryptoAmount;
    }
    /** Fiat currency to which the crypto currency was converted */
    get currency() {
      return this.raw.currency;
    }
    /**
     * Converted amount in fiat currency,
     * in the smallest units (e.g. cents)
     */
    get amount() {
      return this.raw.amount;
    }
    /** URL to the collectible on Fragment */
    get url() {
      return this.raw.url;
    }
  }
  class TakeoutSession {
    constructor(client, session) {
      /**
       * Takeout session id
       */
      __publicField(this, "id");
      this.client = client;
      this.id = session.id;
    }
    /**
     * Make an API call using this takeout session
     *
     * This method just wraps the query into `invokeWithTakeout`
     * and passes the control down to {@link TelegramClient.call}.
     *
     * @param message  RPC method to call
     * @param params  Additional call parameters
     */
    call(message2, params) {
      return __async(this, null, function* () {
        return this.client.call(
          {
            _: "invokeWithTakeout",
            takeoutId: this.id,
            query: message2
          },
          params
        );
      });
    }
    /**
     * Create a proxy over {@link TelegramClient}
     * that will use this takeout session to call methods.
     *
     * You can optionally provide a function to check if some
     * RPC method should be called via a takeout session or directly,
     * otherwise all methods are called through the takeout session.
     *
     * > **Note**: This will return a `Proxy` object that
     * > overrides `call` method. Using this method requires
     * > that your target environment supports `Proxy` and `Reflect` APIs
     *
     * @param predicate
     *     Function that given the RPC call should determine whether
     *     that call should be called via takeout session or not.
     *     Returning `true` will use takeout session, `false` will not.
     */
    createProxy(predicate) {
      const boundCall = predicate ? (obj, params) => {
        if (predicate(obj)) {
          return this.call(obj, params);
        }
        return this.client.call(obj, params);
      } : this.call.bind(this);
      return new Proxy(this.client, {
        get(target, prop, receiver) {
          if (prop === "call")
            return boundCall;
          return Reflect.get(target, prop, receiver);
        }
      });
    }
    /**
     * Finish account takeout session
     *
     * @param success  Whether the data was successfully exported
     */
    finish(success = true) {
      return __async(this, null, function* () {
        const r = yield this.call({
          _: "account.finishTakeoutSession",
          success
        });
        assertTrue("account.finishTakeoutSession", r);
      });
    }
  }
  class Boost {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** Unique ID of this boost */
    get id() {
      return this.raw.id;
    }
    /** Number of boosts this boost is actually representing */
    get count() {
      var _a2;
      return (_a2 = this.raw.multiplier) != null ? _a2 : 1;
    }
    /** Date when this boost was applied */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /** Amount of Telegram Stars that were awarded along with this boost */
    get stars() {
      var _a2;
      return (_a2 = this.raw.stars) != null ? _a2 : null;
    }
    /**
     * Date when this boost will automatically expire.
     *
     * > **Note**: User can still manually cancel the boost before that date
     */
    get expireDate() {
      return new Date(this.raw.expires * 1e3);
    }
    /**
     * Whether this boost was applied because the channel
     * directly gifted a subscription to the user
     */
    get origin() {
      if (this.raw.unclaimed)
        return "unclaimed_gift";
      if (this.raw.gift)
        return "gift";
      if (this.raw.giveaway)
        return "giveaway";
      if (this.raw.userId)
        return "user";
      throw new MtUnsupportedError("Unknown boost origin");
    }
    /**
     * User who is boosting the channel.
     *
     * Only available for some origins
     */
    get user() {
      if (!this.raw.userId)
        return null;
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * ID of the message containing the giveaway where this
     * user has won
     */
    get giveawayMessageId() {
      var _a2;
      return (_a2 = this.raw.giveawayMsgId) != null ? _a2 : null;
    }
    /**
     * The created Telegram Premium gift code, only set if `origin` is not `user`,
     * AND it is either a gift code for the currently logged in user,
     * or if it was already claimed
     */
    get usedGiftSlug() {
      var _a2;
      return (_a2 = this.raw.usedGiftSlug) != null ? _a2 : null;
    }
  }
  memoizeGetters(Boost, ["user"]);
  class BoostSlot {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** ID of this slot */
    get id() {
      return this.raw.slot;
    }
    /**
     * Whether this slot is occupied
     */
    get occupied() {
      return this.raw.peer !== void 0;
    }
    /**
     * Channel that is occupying this slot, if any
     */
    get chat() {
      if (!this.raw.peer)
        return null;
      assertTypeIs("BoostSlot.chat", this.raw.peer, "peerChannel");
      return new Chat(this._peers.chat(this.raw.peer.channelId));
    }
    /**
     * Date when we started boosting this channel
     *
     * If this slot is not occupied, will be `0`
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Date when this boost will automatically expire.
     */
    get expireDate() {
      return new Date(this.raw.expires * 1e3);
    }
    /**
     * If this slot is occupied, returns the date when
     * we can reassing this slot to another channel.
     *
     * If `null`, we can reassign it immediately.
     */
    get cooldownUntil() {
      if (!this.raw.cooldownUntilDate)
        return null;
      return new Date(this.raw.cooldownUntilDate * 1e3);
    }
  }
  memoizeGetters(BoostSlot, ["chat"]);
  class BoostStats {
    constructor(raw) {
      this.raw = raw;
    }
    /** Whether this channel is being boosted by the current user */
    get isBoosting() {
      return this.raw.myBoost;
    }
    /**
     * Current level of boosts in this channel.
     *
     * Currently this maps 1-to-1 to the number of stories
     * the channel can post daily
     */
    get level() {
      return this.raw.level;
    }
    /** Whether this channel is already at the maximum level */
    get isMaxLevel() {
      return this.raw.nextLevelBoosts === void 0;
    }
    /**
     * The number of boosts acquired from created Telegram Premium
     * gift codes and giveaways, only available to channel admins
     */
    get gifts() {
      var _a2;
      return (_a2 = this.raw.giftBoosts) != null ? _a2 : 0;
    }
    /**
     * Number of boosts that were needed for the current level
     */
    get currentLevelBoosts() {
      return this.raw.currentLevelBoosts;
    }
    /** Total number of boosts this channel has */
    get currentBoosts() {
      return this.raw.boosts;
    }
    /**
     * Number of boosts the channel must have to reach the next level
     *
     * `null` if the channel is already at the maximum level
     */
    get nextLevelBoosts() {
      var _a2;
      return (_a2 = this.raw.nextLevelBoosts) != null ? _a2 : null;
    }
    /**
     * Number of boosts the channel needs in addition to the current value
     * to reach the next level
     */
    get remainingBoosts() {
      if (!this.raw.nextLevelBoosts)
        return 0;
      return this.raw.nextLevelBoosts - this.raw.boosts;
    }
    /** If available, total number of subscribers this channel has */
    get totalSubscribers() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.premiumAudience) == null ? void 0 : _a2.total) != null ? _b : null;
    }
    /** If available, total number of Premium subscribers this channel has */
    get totalPremiumSubscribers() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.premiumAudience) == null ? void 0 : _a2.part) != null ? _b : null;
    }
    /** If available, percentage of this channel's subscribers that are Premium */
    get premiumSubscribersPercentage() {
      if (!this.raw.premiumAudience)
        return null;
      return this.raw.premiumAudience.part / this.raw.premiumAudience.total * 100;
    }
    /** URL that would bring up the boost interface */
    get url() {
      return this.raw.boostUrl;
    }
    /**
     * If {@link isBoosting}, IDs of the boost slots that are
     * currently occupied by this channel
     */
    get boostSlots() {
      var _a2;
      return (_a2 = this.raw.myBoostSlots) != null ? _a2 : [];
    }
  }
  class BusinessChatLink {
    constructor(raw) {
      this.raw = raw;
    }
    /** The link itself */
    get link() {
      return this.raw.link;
    }
    /** Text to be inserted into the message input */
    get text() {
      return this.raw.message;
    }
    /** Entities for the text */
    get entities() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.entities) == null ? void 0 : _a2.map((x) => new MessageEntity(x))) != null ? _b : [];
    }
    /** Custom title for the link */
    get title() {
      var _a2;
      return (_a2 = this.raw.title) != null ? _a2 : null;
    }
    /** Number of clicks on the link */
    get clicks() {
      return this.raw.views;
    }
  }
  memoizeGetters(BusinessChatLink, ["entities"]);
  class StarsTransaction {
    constructor(raw, peers) {
      this.raw = raw;
      this.peers = peers;
    }
    /** ID of the transaction */
    get id() {
      return this.raw.id;
    }
    /** Whether this transaction is a refund */
    get isRefund() {
      return this.raw.refund;
    }
    /**
     * Whether this transaction is outgoing or incoming
     */
    get direction() {
      let isNegative = this.raw.stars.isNegative();
      if (this.raw.refund)
        isNegative = !isNegative;
      return isNegative ? "outgoing" : "incoming";
    }
    /** Absolute amount of stars in the transaction */
    get amount() {
      let res = this.raw.stars;
      if (res.isNegative()) {
        res = res.negate();
      }
      return res;
    }
    /** Date of the transaction */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /** Type of this transaction */
    get type() {
      var _a2;
      switch (this.raw.peer._) {
        case "starsTransactionPeerAppStore":
          return { type: "app_store" };
        case "starsTransactionPeerPlayMarket":
          return { type: "play_market" };
        case "starsTransactionPeerPremiumBot":
          return { type: "premium_bot" };
        case "starsTransactionPeerFragment": {
          if (this.raw.gift) {
            return { type: "fragment" };
          }
          let status;
          if (this.raw.pending) {
            status = "pending";
          } else if (this.raw.failed) {
            status = "failed";
          } else {
            status = "success";
          }
          return {
            type: "fragment_withdraw",
            status,
            date: this.raw.transactionDate ? new Date(this.raw.transactionDate * 1e3) : void 0,
            url: this.raw.transactionUrl
          };
        }
        case "starsTransactionPeerAds":
          return { type: "ads" };
        case "starsTransactionPeer": {
          const peer = parsePeer(this.raw.peer.peer, this.peers);
          if (this.raw.giveawayPostId) {
            return {
              type: "giveaway",
              peer,
              messageId: this.raw.giveawayPostId
            };
          }
          if (this.raw.stargift) {
            return {
              type: "star_gift",
              peer,
              gift: new StarGift(this.raw.stargift)
            };
          }
          if (this.raw.msgId) {
            if (this.raw.reaction) {
              return {
                type: "reaction",
                peer,
                messageId: this.raw.msgId
              };
            }
            return {
              type: "media_purchase",
              peer,
              messageId: this.raw.msgId,
              media: this.raw.extendedMedia ? this.raw.extendedMedia.map((it) => _messageMediaFromTl(this.peers, it)) : void 0
            };
          }
          if (this.raw.subscriptionPeriod) {
            return {
              type: "channel_subscription",
              peer,
              period: this.raw.subscriptionPeriod
            };
          }
          if (peer.type === "user") {
            if (this.raw.gift && !peer.isBot) {
              return { type: "gift", user: peer };
            }
            if (this.raw.title || this.raw.description || this.raw.photo || this.raw.botPayload) {
              return {
                type: "bot_purchase",
                user: peer,
                title: (_a2 = this.raw.title) != null ? _a2 : "",
                description: this.raw.description,
                payload: this.raw.botPayload,
                photo: this.raw.photo ? new WebDocument(this.raw.photo) : void 0
              };
            }
            return { type: "unsupported" };
          }
          return { type: "unsupported" };
        }
        default:
          return { type: "unsupported" };
      }
    }
  }
  memoizeGetters(StarsTransaction, ["amount", "type"]);
  class StarsStatus {
    constructor(raw) {
      __publicField(this, "peers");
      this.raw = raw;
      this.peers = PeersIndex.from(raw);
    }
    /** Current Telegram Stars balance */
    get balance() {
      return this.raw.balance;
    }
    /**
     * History of Telegram Stars transactions
     */
    get transactions() {
      var _a2, _b;
      return (_b = (_a2 = this.raw.history) == null ? void 0 : _a2.map((it) => new StarsTransaction(it, this.peers))) != null ? _b : [];
    }
    /** Next offset of {@link transactions} for pagination */
    get transactionsNextOffset() {
      var _a2;
      return (_a2 = this.raw.nextOffset) != null ? _a2 : null;
    }
  }
  memoizeGetters(StarsStatus, ["transactions"]);
  class PeerStories {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Peer that owns these stories.
     */
    get peer() {
      return parsePeer(this.raw.peer, this._peers);
    }
    /**
     * ID of the last read story of this peer.
     */
    get maxReadId() {
      var _a2;
      return (_a2 = this.raw.maxReadId) != null ? _a2 : 0;
    }
    /**
     * List of peer stories.
     */
    get stories() {
      return this.raw.stories.map((it) => {
        assertTypeIs("PeerStories#stories", it, "storyItem");
        return new Story(it, this._peers);
      });
    }
  }
  memoizeGetters(PeerStories, ["peer", "stories"]);
  class StoriesStealthMode {
    constructor(raw) {
      this.raw = raw;
    }
    /** Stealth mode is active until this date */
    get activeUntil() {
      if (!this.raw.activeUntilDate)
        return null;
      return new Date(this.raw.activeUntilDate * 1e3);
    }
    /** Stealth mode is having a cooldown until this date */
    get cooldownUntil() {
      if (!this.raw.cooldownUntilDate)
        return null;
      return new Date(this.raw.cooldownUntilDate * 1e3);
    }
  }
  class AllStories {
    constructor(raw) {
      /** Peers index */
      __publicField(this, "_peers");
      this.raw = raw;
      this._peers = PeersIndex.from(this.raw);
    }
    /** Whether there are more stories to fetch */
    get hasMore() {
      return this.raw.hasMore;
    }
    /** Next offset for pagination */
    get next() {
      return this.raw.state;
    }
    /** Total number of {@link PeerStories} available */
    get total() {
      return this.raw.count;
    }
    /** Peers with their stories */
    get peerStories() {
      return this.raw.peerStories.map((it) => new PeerStories(it, this._peers));
    }
    /** Stealth mode info */
    get stealthMode() {
      return new StoriesStealthMode(this.raw.stealthMode);
    }
  }
  memoizeGetters(AllStories, ["peerStories", "stealthMode"]);
  class StoryViewer {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** Whether this user is in current user's global blacklist */
    get isBlocked() {
      return this.raw.blocked;
    }
    /** Whether current user's stories are hidden from this user */
    get isStoriesBlocked() {
      return this.raw.blockedMyStoriesFrom;
    }
    /** Date when the view has occurred */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /** Reaction this user has left, if any */
    get reactionEmoji() {
      if (!this.raw.reaction)
        return null;
      return toReactionEmoji(this.raw.reaction, true);
    }
    /** Information about the user */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
  }
  memoizeGetters(StoryViewer, ["user"]);
  class StoryViewersList {
    constructor(raw) {
      __publicField(this, "_peers");
      this.raw = raw;
      this._peers = PeersIndex.from(this.raw);
    }
    /** Next offset for pagination */
    get next() {
      return this.raw.nextOffset;
    }
    /** Total number of views this story has */
    get total() {
      return this.raw.count;
    }
    /** Total number of reactions this story has */
    get reactionsTotal() {
      return this.raw.reactionsCount;
    }
    /** List of viewers */
    get viewers() {
      const res = [];
      for(let   view of this.raw.views) {
        if (view._ === "storyView") {
          res.push(new StoryViewer(view, this._peers));
        }
      }
      return res;
    }
  }
  memoizeGetters(StoryViewersList, ["viewers"]);
  class BotChatJoinRequestUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Chat ID where the user is requesting to join.
     */
    get chatId() {
      return getMarkedPeerId(this.raw.peer);
    }
    /**
     * Object containing the chat information.
     */
    get chat() {
      return new Chat(this._peers.chat(getBarePeerId(this.raw.peer)));
    }
    /**
     * ID of the user who requested to join the chat.
     */
    get userId() {
      return this.raw.userId;
    }
    /**
     * Object containing the user information.
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * Bio of the user who requested to join the chat.
     */
    get userBio() {
      return this.raw.about;
    }
    /**
     * Date when the request was sent.
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Invite link used to request joining.
     */
    get invite() {
      return new ChatInviteLink(this.raw.invite);
    }
  }
  memoizeGetters(BotChatJoinRequestUpdate, ["chat", "user", "invite"]);
  class BotStoppedUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * ID of the user who stopped or restarted the bot
     */
    get userId() {
      return this.raw.userId;
    }
    /**
     * User who stopped or restarted the bot
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * Whether the bot is currently stopped.
     *
     * If `true`, then the user has stopped the bot.
     * If `false`, then the user has re-started the bot.
     */
    get stopped() {
      return this.raw.stopped;
    }
  }
  memoizeGetters(BotStoppedUpdate, ["user"]);
  class BaseCallbackQuery {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * ID of this callback query
     */
    get id() {
      return this.raw.queryId;
    }
    /**
     * User who has pressed the button
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * Unique ID, that represents the chat to which the inline
     * message was sent. Does *not* contain actual chat ID.
     */
    get uniqueChatId() {
      return this.raw.chatInstance;
    }
    /**
     * Data that was contained in the callback button, if any
     *
     * Note that this field is defined by the client, and a bad
     * client can send arbitrary data in this field.
     */
    get data() {
      var _a2;
      return (_a2 = this.raw.data) != null ? _a2 : null;
    }
    /**
     * Data that was contained in the callback button, if any,
     * parsed as a UTF8 string
     *
     * Note that this field is defined by the client, and a bad
     * client can send arbitrary data in this field.
     */
    get dataStr() {
      if (!this.raw.data)
        return null;
      return getPlatform().utf8Decode(this.raw.data);
    }
    /**
     * In case this message was from {@link InputInlineResultGame},
     * or the button was {@link BotKeyboard.game},
     * short name of the game that should be returned.
     */
    get game() {
      var _a2;
      if (this.raw._ === "updateBusinessBotCallbackQuery")
        return null;
      return (_a2 = this.raw.gameShortName) != null ? _a2 : null;
    }
  }
  class CallbackQuery extends BaseCallbackQuery {
    constructor(raw, _peers) {
      super(raw, _peers);
      this.raw = raw;
    }
    /**
     * Chat where the originating message was sent
     */
    get chat() {
      if (this.raw._ !== "updateBotCallbackQuery") {
        throw new MtArgumentError("Cannot get message id for inline callback");
      }
      return new Chat(this._peers.get(this.raw.peer));
    }
    /**
     * Identifier of the message containing the button which was clicked.
     */
    get messageId() {
      return this.raw.msgId;
    }
  }
  memoizeGetters(CallbackQuery, ["user", "dataStr", "chat"]);
  class InlineCallbackQuery extends BaseCallbackQuery {
    constructor(raw, _peers) {
      super(raw, _peers);
      this.raw = raw;
    }
    /**
     * Identifier of the previously sent inline message,
     * that contained the button which was clicked.
     * This ID can be used in `TelegramClient.editInlineMessage`
     */
    get inlineMessageId() {
      return this.raw.msgId;
    }
    /**
     * Identifier of the previously sent inline message,
     * that contained the button which was clicked,
     * as a TDLib and Bot API compatible string.
     * Can be used instead of {@link inlineMessageId} in
     * case you want to store it in some storage.
     */
    get inlineMessageIdStr() {
      return encodeInlineMessageId(this.raw.msgId);
    }
  }
  memoizeGetters(InlineCallbackQuery, ["user", "dataStr", "inlineMessageIdStr"]);
  class BusinessCallbackQuery extends BaseCallbackQuery {
    constructor(raw, _peers) {
      super(raw, _peers);
      this.raw = raw;
    }
    /** ID of the business connection */
    get connectionId() {
      return this.raw.connectionId;
    }
    /** Message containing the button */
    get message() {
      return new Message(this.raw.message, this._peers);
    }
    /** Message that {@link message} is a reply to (if any) */
    get replyToMessage() {
      if (!this.raw.replyToMessage)
        return null;
      return new Message(this.raw.replyToMessage, this._peers);
    }
  }
  memoizeGetters(BusinessCallbackQuery, ["user", "dataStr", "message", "replyToMessage"]);
  class ChatJoinRequestUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    // in this update, peers index only contains
    // recent requesters, not the chat
    /**
     * Marked ID of the chat/channel
     */
    get chatId() {
      return getMarkedPeerId(this.raw.peer);
    }
    /**
     * IDs of the users who recently requested to join the chat
     */
    get recentRequestersIds() {
      return this.raw.recentRequesters;
    }
    /**
     * Users who recently requested to join the chat
     */
    get recentRequesters() {
      return this.raw.recentRequesters.map((id2) => new User(this._peers.user(id2)));
    }
    /**
     * Total number of pending requests
     */
    get totalPending() {
      return this.raw.requestsPending;
    }
  }
  memoizeGetters(ChatJoinRequestUpdate, ["recentRequesters"]);
  function extractPeerId(raw) {
    if (!raw)
      return 0;
    if (tl.tl.isAnyChatParticipant(raw)) {
      return raw.userId;
    }
    switch (raw._) {
      case "channelParticipant":
      case "channelParticipantSelf":
      case "channelParticipantCreator":
      case "channelParticipantAdmin":
        return raw.userId;
      default:
        return getMarkedPeerId(raw.peer);
    }
  }
  class ChatMemberUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Date of the event
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * Whether this is an update about current user
     */
    get isSelf() {
      return this.user.isSelf;
    }
    /**
     * Type of the update
     *
     * @link ChatMemberUpdate.Type
     */
    get type() {
      const old = this.raw.prevParticipant;
      const cur = this.raw.newParticipant;
      const oldId = extractPeerId(old);
      const curId = extractPeerId(cur);
      const actorId = this.raw.actorId;
      if (!old && cur) {
        return actorId === curId ? "joined" : "added";
      }
      if (old && !cur) {
        if (actorId === oldId)
          return "left";
        if (old._ === "channelParticipantBanned") {
          return "unkicked";
        }
        return "kicked";
      }
      if (!old || !cur)
        return "other";
      switch (old._) {
        case "chatParticipant":
        case "channelParticipant":
          switch (cur._) {
            case "chatParticipantAdmin":
            case "channelParticipantAdmin":
              return "promoted";
            case "channelParticipantBanned":
              if (cur.left)
                return "kicked";
              return "restricted";
          }
          break;
        case "chatParticipantCreator":
        case "channelParticipantCreator":
          return "old_owner";
      }
      switch (cur._) {
        case "chatParticipantCreator":
        case "channelParticipantCreator":
          return "new_owner";
      }
      if (old._ === "channelParticipantBanned" && cur._ === "channelParticipant") {
        return "unrestricted";
      }
      if (old._ === "channelParticipantBanned" && cur._ === "channelParticipantAdmin") {
        return "unrestricted_promoted";
      }
      if (old._ === "channelParticipantAdmin" && cur._ === "channelParticipant") {
        return "demoted";
      }
      if (old._ === "channelParticipantAdmin" && cur._ === "channelParticipantBanned") {
        return cur.left ? "demoted_kicked" : "demoted_restricted";
      }
      if (old._ === "channelParticipantBanned" && cur._ === "channelParticipantBanned" && old.left !== cur.left) {
        if (actorId === curId) {
          return cur.left ? "left" : "joined";
        }
        return cur.left ? "kicked" : "added";
      }
      return "other";
    }
    /**
     * Chat in which this event has occurred
     */
    get chat() {
      const id2 = this.raw._ === "updateChannelParticipant" ? this.raw.channelId : this.raw.chatId;
      return new Chat(this._peers.chat(id2));
    }
    /**
     * Performer of the action which resulted in this update.
     *
     * Can be chat/channel administrator or the {@link user} themself.
     */
    get actor() {
      return new User(this._peers.user(this.raw.actorId));
    }
    /**
     * User representing the chat member whose status was changed.
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /** Whether this is a self-made action (i.e. actor == user) */
    get isSelfMade() {
      return this.raw.actorId === this.raw.userId;
    }
    /**
     * Previous (old) information about chat member.
     */
    get oldMember() {
      if (!this.raw.prevParticipant)
        return null;
      return new ChatMember(this.raw.prevParticipant, this._peers);
    }
    /**
     * Current (new) information about chat member.
     */
    get newMember() {
      if (!this.raw.newParticipant)
        return null;
      return new ChatMember(this.raw.newParticipant, this._peers);
    }
    /**
     * In case this is a "join" event, invite link that was used to join (if any)
     */
    get inviteLink() {
      if (!this.raw.invite)
        return null;
      return new ChatInviteLink(this.raw.invite);
    }
  }
  memoizeGetters(ChatMemberUpdate, ["type", "chat", "actor", "user", "oldMember", "newMember", "inviteLink"]);
  const PEER_TYPE_MAP = {
    inlineQueryPeerTypeBroadcast: "channel",
    inlineQueryPeerTypeChat: "group",
    inlineQueryPeerTypeMegagroup: "supergroup",
    inlineQueryPeerTypePM: "user",
    inlineQueryPeerTypeSameBotPM: "bot",
    inlineQueryPeerTypeBotPM: "bot"
  };
  class InlineQuery {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Unique query ID
     */
    get id() {
      return this.raw.queryId;
    }
    /**
     * User who sent this query
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * Text of the query (0-512 characters)
     */
    get query() {
      return this.raw.query;
    }
    /**
     * Attached geolocation.
     *
     * Only used in case the bot requested user location
     */
    get location() {
      var _a2;
      if (((_a2 = this.raw.geo) == null ? void 0 : _a2._) !== "geoPoint")
        return null;
      return new Location(this.raw.geo);
    }
    /**
     * Inline query scroll offset, controlled by the bot
     */
    get offset() {
      return this.raw.offset;
    }
    /**
     * Peer type from which this query was sent.
     *
     * Can be:
     *  - `bot`: Query was sent in this bot's PM
     *  - `user`: Query was sent in somebody's PM
     *  - `group`: Query was sent in a legacy group
     *  - `supergroup`: Query was sent in a supergroup
     *  - `channel`: Query was sent in a channel
     *  - `null`, in case this information is not available
     */
    get peerType() {
      return this.raw.peerType ? PEER_TYPE_MAP[this.raw.peerType._] : null;
    }
  }
  memoizeGetters(InlineQuery, ["user", "location"]);
  class BotReactionUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Chat where the reaction has been changed
     */
    get chat() {
      return Chat._parseFromPeer(this.raw.peer, this._peers);
    }
    /**
     * ID of the message where the reaction has been changed
     */
    get messageId() {
      return this.raw.msgId;
    }
    /**
     * Date when the reaction has been changed
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * ID of the user who has set/removed the reaction
     */
    get actor() {
      return parsePeer(this.raw.actor, this._peers);
    }
    /**
     * List of reactions before the change
     */
    get before() {
      return this.raw.oldReactions.map((it) => toReactionEmoji(it));
    }
    /**
     * List of reactions after the change
     */
    get after() {
      return this.raw.newReactions.map((it) => toReactionEmoji(it));
    }
  }
  memoizeGetters(BotReactionUpdate, ["chat", "actor", "before", "after"]);
  class BotReactionCountUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Chat where the reaction has been changed
     */
    get chat() {
      return Chat._parseFromPeer(this.raw.peer, this._peers);
    }
    /**
     * ID of the message where the reaction has been changed
     */
    get messageId() {
      return this.raw.msgId;
    }
    /**
     * Date when the reaction has been changed
     */
    get date() {
      return new Date(this.raw.date * 1e3);
    }
    /**
     * The new list of reactions to the message
     */
    get reactions() {
      return this.raw.reactions.map((it) => new ReactionCount(it));
    }
  }
  memoizeGetters(BotReactionCountUpdate, ["chat"]);
  class BusinessMessage extends Message {
    constructor(update, _peers) {
      super(update.message, _peers);
      this.update = update;
      this._peers = _peers;
    }
    /**
     * Unique identifier of the business connection from which the message was received.
     */
    get connectionId() {
      return this.update.connectionId;
    }
    get groupedIdUnique() {
      const superGroupedIdUnique = super.groupedIdUnique;
      if (!superGroupedIdUnique) {
        return null;
      }
      return `${super.groupedIdUnique}|${this.update.connectionId}`;
    }
    /** The replied message (if any) */
    get replyTo() {
      return this.update.replyToMessage ? new Message(this.update.replyToMessage, this._peers) : null;
    }
  }
  class ChosenInlineResult {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Unique identifier of the chosen result,
     * as set in `InputInlineResult.id`
     */
    get id() {
      return this.raw.id;
    }
    /**
     * User who has chosen the query
     */
    get user() {
      return new User(this._peers.user(this.raw.userId));
    }
    /**
     * The query that was previously sent by the user,
     * which was used to obtain this result
     */
    get query() {
      return this.raw.query;
    }
    /**
     * Sender location, only applicable to bots that requested user location
     */
    get location() {
      var _a2;
      if (((_a2 = this.raw.geo) == null ? void 0 : _a2._) !== "geoPoint")
        return null;
      return new Location(this.raw.geo);
    }
    /**
     * Identifier of the sent inline message,
     * which can be used in `TelegramClient.editInlineMessage`
     *
     * > **Note**: this is only available in case the `InputInlineMessage`
     * > contained a reply keyboard markup.
     */
    get messageId() {
      var _a2;
      return (_a2 = this.raw.msgId) != null ? _a2 : null;
    }
    /**
     * Identifier of the sent inline message
     * as a TDLib and Bot API compatible string.
     * Can be used instead of {@link messageId} in
     * case you want to store it in some storage.
     *
     * > **Note**: this is only available in case the `InputInlineMessage`
     * > contained a reply keyboard markup.
     */
    get messageIdStr() {
      if (!this.raw.msgId)
        return null;
      return encodeInlineMessageId(this.raw.msgId);
    }
  }
  memoizeGetters(ChosenInlineResult, ["user", "location"]);
  class DeleteBusinessMessageUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /** Unique identifier of the business connection */
    get connectionId() {
      return this.raw.connectionId;
    }
    /**
     * IDs of the messages which were deleted
     */
    get messageIds() {
      return this.raw.messages;
    }
    /**
     * Chat where the messages were deleted
     */
    get chat() {
      return Chat._parseFromPeer(this.raw.peer, this._peers);
    }
  }
  memoizeGetters(DeleteBusinessMessageUpdate, ["chat"]);
  class DeleteMessageUpdate {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * IDs of the messages which were deleted
     */
    get messageIds() {
      return this.raw.messages;
    }
    /**
     * Marked ID of the channel where the messages were deleted
     */
    get channelId() {
      return this.raw._ === "updateDeleteChannelMessages" ? toggleChannelIdMark(this.raw.channelId) : null;
    }
  }
  class DeleteStoryUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Peer that owns these stories.
     */
    get peer() {
      return parsePeer(this.raw.peer, this._peers);
    }
    /**
     * ID of the deleted story
     */
    get storyId() {
      return this.raw.story.id;
    }
  }
  memoizeGetters(DeleteStoryUpdate, ["peer"]);
  class HistoryReadUpdate {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * Whether this update is about an "outbox" read
     * (i.e. a message you have sent earlier was read)
     */
    get isOutbox() {
      switch (this.raw._) {
        case "updateReadChannelDiscussionOutbox":
        case "updateReadHistoryOutbox":
        case "updateReadChannelOutbox":
          return true;
        default:
          return false;
      }
    }
    /**
     * Whether this update is about messages in a thread
     * (e.g. a comments thread or a topic in a forum)
     */
    get isDiscussion() {
      switch (this.raw._) {
        case "updateReadChannelDiscussionOutbox":
        case "updateReadChannelDiscussionInbox":
          return true;
        default:
          return false;
      }
    }
    /**
     * Marked peer ID of the chat where the messages were read.
     */
    get chatId() {
      switch (this.raw._) {
        case "updateReadHistoryOutbox":
        case "updateReadHistoryInbox":
          return getMarkedPeerId(this.raw.peer);
        case "updateReadChannelOutbox":
        case "updateReadChannelInbox":
        case "updateReadChannelDiscussionOutbox":
        case "updateReadChannelDiscussionInbox":
          return toggleChannelIdMark(this.raw.channelId);
      }
    }
    /**
     * For inbox updates (i.e. `isOutbox = false`),
     * number of messages that are still unread in the chat.
     *
     * For other updates, `0`
     */
    get unreadCount() {
      switch (this.raw._) {
        case "updateReadHistoryInbox":
        case "updateReadChannelInbox":
          return this.raw.stillUnreadCount;
        case "updateReadChannelDiscussionInbox":
        case "updateReadHistoryOutbox":
        case "updateReadChannelOutbox":
        case "updateReadChannelDiscussionOutbox":
          return 0;
      }
    }
    /**
     * ID of the last read message.
     *
     * Note that if `isDiscussion == true`, this contains the ID of the
     * last read message inside that thread, and not in the group itself.
     */
    get maxReadId() {
      switch (this.raw._) {
        case "updateReadHistoryOutbox":
        case "updateReadHistoryInbox":
        case "updateReadChannelOutbox":
        case "updateReadChannelInbox":
          return this.raw.maxId;
        case "updateReadChannelDiscussionOutbox":
        case "updateReadChannelDiscussionInbox":
          return this.raw.readMaxId;
      }
    }
    /**
     * ID of the thread/topic (i.e. ID of the top message).
     *
     * For non-thread updates, 0.
     */
    get threadId() {
      switch (this.raw._) {
        case "updateReadHistoryOutbox":
        case "updateReadHistoryInbox":
        case "updateReadChannelOutbox":
        case "updateReadChannelInbox":
          return 0;
        case "updateReadChannelDiscussionOutbox":
        case "updateReadChannelDiscussionInbox":
          return this.raw.topMsgId;
      }
    }
  }
  class PollUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Unique poll ID
     */
    get pollId() {
      return this.raw.pollId;
    }
    /**
     * Whether this is a shortened version of update, not containing the poll itself.
     */
    get isShort() {
      return this.raw.poll === void 0;
    }
    /**
     * The poll.
     *
     * When {@link isShort} is set, mtcute creates a stub poll
     * with empty question, answers and flags
     * (like `quiz`, `public`, etc.)
     *
     * If you need access to them, you should
     * map the {@link pollId} with full poll on your side
     * (e.g. in a database) and fetch from there.
     *
     * Bot API and TDLib do basically the same internally,
     * and thus are able to always provide them,
     * but mtcute currently does not have a way to do that.
     */
    get poll() {
      var _a2, _b;
      let poll = this.raw.poll;
      if (!poll) {
        poll = {
          _: "poll",
          id: this.raw.pollId,
          question: { _: "textWithEntities", text: "", entities: [] },
          answers: (_b = (_a2 = this.raw.results.results) == null ? void 0 : _a2.map((res) => ({
            _: "pollAnswer",
            text: { _: "textWithEntities", text: "", entities: [] },
            option: res.option
          }))) != null ? _b : []
        };
      }
      return new Poll(poll, this._peers, this.raw.results);
    }
  }
  memoizeGetters(PollUpdate, ["poll"]);
  class PollVoteUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Unique poll ID
     */
    get pollId() {
      return this.raw.pollId;
    }
    /**
     * Peer who has voted
     */
    get peer() {
      return parsePeer(this.raw.peer, this._peers);
    }
    /**
     * Answers that the user has chosen.
     *
     * Note that due to incredible Telegram APIs, you
     * have to have the poll cached to be able to properly
     * tell which answers were chosen, since in the API
     * there are just arbitrary `Buffer`s, which are
     * defined by the client.
     *
     * However, most of the major implementations
     * (tested with TDLib and Bot API, official apps
     * for Android, Desktop, iOS/macOS) and mtcute
     * (by default) create `option` as a one-byte `Buffer`,
     * incrementing from `48` (ASCII `0`) up to `57` (ASCII `9`),
     * and ASCII representation would define index in the array.
     * Meaning, if `chosen[0][0] === 48` or `chosen[0].toString() === '0'`,
     * then the first answer (indexed with `0`) was chosen. To get the index,
     * you simply subtract `48` from the first byte.
     *
     * This might break at any time, but seems to be consistent for now.
     * To get chosen answer indexes derived as before, use {@link chosenIndexesAuto}.
     */
    get chosen() {
      return this.raw.options;
    }
    /**
     * Indexes of the chosen answers, derived based on observations
     * described in {@link chosen}.
     * This might break at any time, but seems to be consistent for now.
     *
     * If something does not add up, {@link MtUnsupportedError} is thrown
     */
    get chosenIndexesAuto() {
      return this.raw.options.map((buf) => {
        if (buf.length > 1) {
          throw new MtUnsupportedError("option had >1 byte");
        }
        if (buf[0] < 48 || buf[0] > 57) {
          throw new MtUnsupportedError("option had first byte out of 0-9 range");
        }
        return buf[0] - 48;
      });
    }
  }
  memoizeGetters(PollVoteUpdate, ["peer"]);
  class PreCheckoutQuery {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * ID of the query
     */
    get queryId() {
      return this.raw.queryId;
    }
    /**
     * ID of the user who sent the query
     */
    get userId() {
      return this.raw.userId;
    }
    /**
     * User who sent the query
     */
    get user() {
      return new User(this._peers.user(this.userId));
    }
    /**
     * Bot-defined payload of the original invoice
     * (see {@link InputMediaInvoice.payload})
     */
    get payload() {
      return this.raw.payload;
    }
    /**
     * User-provided payment info (like name, phone, shipping address, etc.)
     */
    get paymentInfo() {
      if (!this.raw.info)
        return null;
      return this.raw.info;
    }
    /**
     * Currency of the payment
     */
    get currency() {
      return this.raw.currency;
    }
    /**
     * Total price of the payment
     */
    get totalAmount() {
      return this.raw.totalAmount;
    }
  }
  memoizeGetters(PreCheckoutQuery, ["user"]);
  class StoryUpdate {
    constructor(raw, _peers) {
      this.raw = raw;
      this._peers = _peers;
    }
    /**
     * Peer that owns these stories.
     */
    get peer() {
      return parsePeer(this.raw.peer, this._peers);
    }
    /**
     * Story that was posted or edited.
     */
    get story() {
      assertTypeIs("StoryUpdate.story", this.raw.story, "storyItem");
      return new Story(this.raw.story, this._peers);
    }
  }
  memoizeGetters(StoryUpdate, ["peer", "story"]);
  class UserStatusUpdate {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * ID of the user whose status has updated
     */
    get userId() {
      return this.raw.userId;
    }
    get _parsedStatus() {
      return User.parseStatus(this.raw.status);
    }
    /**
     * User's new Last Seen & Online status
     */
    get status() {
      return this._parsedStatus.status;
    }
    /**
     * Last time this user was seen online.
     * Only available if {@link status} is `offline`
     */
    get lastOnline() {
      return this._parsedStatus.lastOnline;
    }
    /**
     * Time when this user will automatically go offline.
     * Only available if {@link status} is `online`
     */
    get nextOffline() {
      return this._parsedStatus.nextOffline;
    }
  }
  memoizeGetters(UserStatusUpdate, ["_parsedStatus"]);
  class UserTypingUpdate {
    constructor(raw) {
      this.raw = raw;
    }
    /**
     * ID of the user whose typing status changed
     */
    get userId() {
      return this.raw._ === "updateUserTyping" ? this.raw.userId : getBarePeerId(this.raw.fromId);
    }
    /**
     * Marked ID of the chat where the user is typing,
     *
     * If the user is typing in PMs, this will
     * equal to {@link userId}
     */
    get chatId() {
      switch (this.raw._) {
        case "updateUserTyping":
          return this.raw.userId;
        case "updateChatUserTyping":
          return -this.raw.chatId;
        case "updateChannelUserTyping":
          return toggleChannelIdMark(this.raw.channelId);
      }
    }
    /**
     * Type of the chat where this event has occurred
     */
    get chatType() {
      switch (this.raw._) {
        case "updateUserTyping":
          return "user";
        case "updateChatUserTyping":
          return "chat";
        case "updateChannelUserTyping":
          return "channel";
      }
    }
    /**
     * Current typing status
     */
    get status() {
      switch (this.raw.action._) {
        case "sendMessageTypingAction":
          return "typing";
        case "sendMessageCancelAction":
          return "cancel";
        case "sendMessageRecordVideoAction":
          return "record_video";
        case "sendMessageUploadVideoAction":
          return "upload_video";
        case "sendMessageRecordAudioAction":
          return "record_voice";
        case "sendMessageUploadAudioAction":
          return "upload_voice";
        case "sendMessageUploadPhotoAction":
          return "upload_photo";
        case "sendMessageUploadDocumentAction":
          return "upload_document";
        case "sendMessageGeoLocationAction":
          return "geo";
        case "sendMessageGamePlayAction":
          return "game";
        case "sendMessageChooseContactAction":
          return "contact";
        case "sendMessageRecordRoundAction":
          return "record_round";
        case "sendMessageUploadRoundAction":
          return "upload_round";
        case "speakingInGroupCallAction":
          return "speak_call";
        case "sendMessageHistoryImportAction":
          return "history_import";
        case "sendMessageChooseStickerAction":
          return "sticker";
        case "sendMessageEmojiInteraction":
          return "interaction";
        case "sendMessageEmojiInteractionSeen":
          return "interaction_seen";
        default:
          assertNever$1(this.raw.action);
      }
    }
  }
  function _parseUpdate(update, peers) {
    switch (update._) {
      case "updateNewMessage":
      case "updateNewChannelMessage":
      case "updateNewScheduledMessage":
        return {
          name: "new_message",
          data: new Message(update.message, peers, update._ === "updateNewScheduledMessage")
        };
      case "updateEditMessage":
      case "updateEditChannelMessage":
        return { name: "edit_message", data: new Message(update.message, peers) };
      case "updateChatParticipant":
      case "updateChannelParticipant":
        return { name: "chat_member", data: new ChatMemberUpdate(update, peers) };
      case "updateBotInlineQuery":
        return { name: "inline_query", data: new InlineQuery(update, peers) };
      case "updateBotInlineSend":
        return { name: "chosen_inline_result", data: new ChosenInlineResult(update, peers) };
      case "updateBotCallbackQuery":
        return { name: "callback_query", data: new CallbackQuery(update, peers) };
      case "updateInlineBotCallbackQuery":
        return { name: "inline_callback_query", data: new InlineCallbackQuery(update, peers) };
      case "updateMessagePoll":
        return { name: "poll", data: new PollUpdate(update, peers) };
      case "updateMessagePollVote":
        return { name: "poll_vote", data: new PollVoteUpdate(update, peers) };
      case "updateUserStatus":
        return { name: "user_status", data: new UserStatusUpdate(update) };
      case "updateChannelUserTyping":
      case "updateChatUserTyping":
      case "updateUserTyping":
        return { name: "user_typing", data: new UserTypingUpdate(update) };
      case "updateDeleteChannelMessages":
      case "updateDeleteMessages":
        return { name: "delete_message", data: new DeleteMessageUpdate(update) };
      case "updateReadHistoryInbox":
      case "updateReadHistoryOutbox":
      case "updateReadChannelInbox":
      case "updateReadChannelOutbox":
      case "updateReadChannelDiscussionInbox":
      case "updateReadChannelDiscussionOutbox":
        return { name: "history_read", data: new HistoryReadUpdate(update) };
      case "updateBotStopped":
        return { name: "bot_stopped", data: new BotStoppedUpdate(update, peers) };
      case "updateBotChatInviteRequester":
        return { name: "bot_chat_join_request", data: new BotChatJoinRequestUpdate(update, peers) };
      case "updatePendingJoinRequests":
        return { name: "chat_join_request", data: new ChatJoinRequestUpdate(update, peers) };
      case "updateBotPrecheckoutQuery":
        return { name: "pre_checkout_query", data: new PreCheckoutQuery(update, peers) };
      case "updateStory": {
        const story = update.story;
        if (story._ === "storyItemDeleted") {
          return { name: "delete_story", data: new DeleteStoryUpdate(update, peers) };
        }
        return {
          name: "story",
          data: new StoryUpdate(update, peers)
        };
      }
      case "updateBotMessageReaction":
        return { name: "bot_reaction", data: new BotReactionUpdate(update, peers) };
      case "updateBotMessageReactions":
        return { name: "bot_reaction_count", data: new BotReactionCountUpdate(update, peers) };
      case "updateBotBusinessConnect":
        return { name: "business_connection", data: new BusinessConnection(update.connection, peers) };
      case "updateBotNewBusinessMessage":
        return { name: "new_business_message", data: new BusinessMessage(update, peers) };
      case "updateBotEditBusinessMessage":
        return { name: "edit_business_message", data: new BusinessMessage(update, peers) };
      case "updateBotDeleteBusinessMessage":
        return { name: "delete_business_message", data: new DeleteBusinessMessageUpdate(update, peers) };
      case "updateBusinessBotCallbackQuery":
        return { name: "business_callback_query", data: new BusinessCallbackQuery(update, peers) };
      default:
        return null;
    }
  }
  function makeParsedUpdateHandler(params) {
    const { messageGroupingInterval, onUpdate, onRawUpdate = () => {
    } } = params;
    if (!messageGroupingInterval) {
      return (update, peers) => {
        const parsed = _parseUpdate(update, peers);
        onRawUpdate(update, peers);
        if (parsed)
          onUpdate(parsed);
      };
    }
    const pending = /* @__PURE__ */ new Map();
    return (update, peers) => {
      const parsed = _parseUpdate(update, peers);
      onRawUpdate(update, peers);
      if (parsed) {
        if (parsed.name === "new_message" || parsed.name === "new_business_message") {
          const group = parsed.data.groupedIdUnique;
          if (group) {
            const isBusiness = parsed.name === "new_business_message";
            const pendingGroup = pending.get(group);
            if (pendingGroup) {
              pendingGroup[0].push(parsed.data);
            } else {
              const messages = [parsed.data];
              const timeout = setTimeoutWrap(() => {
                pending.delete(group);
                if (isBusiness) {
                  onUpdate({ name: "business_message_group", data: messages });
                } else {
                  onUpdate({ name: "message_group", data: messages });
                }
              }, messageGroupingInterval);
              pending.set(group, [messages, timeout]);
            }
            return;
          }
        }
        onUpdate(parsed);
      }
    };
  }
  function _onAuthorization(client, auth) {
    return __async(this, null, function* () {
      const user = yield client.notifyLoggedIn(auth);
      return new User(user);
    });
  }
  function isSelfPeer(client, peer) {
    const state = client.storage.self.getCached();
    if (!state)
      return false;
    switch (peer._) {
      case "inputPeerSelf":
      case "inputUserSelf":
        return true;
      case "inputPeerUser":
      case "inputPeerUserFromMessage":
      case "inputUser":
      case "inputUserFromMessage":
      case "peerUser":
        return peer.userId === state.userId;
      default:
        return false;
    }
  }
  function checkPassword(client, password) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "auth.checkPassword",
        password: yield client.computeSrpParams(
          yield client.call({
            _: "account.getPassword"
          }),
          password
        )
      });
      return _onAuthorization(client, res);
    });
  }
  function getPasswordHint(client) {
    return client.call({
      _: "account.getPassword"
    }).then((res) => {
      var _a2;
      return (_a2 = res.hint) != null ? _a2 : null;
    });
  }
  function logOut(client) {
    return __async(this, null, function* () {
      const res = yield client.call({ _: "auth.logOut" });
      yield client.notifyLoggedOut();
      return {
        futureAuthToken: res.futureAuthToken
      };
    });
  }
  function recoverPassword(client, params) {
    return __async(this, null, function* () {
      const { recoveryCode } = params;
      const res = yield client.call({
        _: "auth.recoverPassword",
        code: recoveryCode
      });
      return _onAuthorization(client, res);
    });
  }
  function resendCode(client, params) {
    return __async(this, null, function* () {
      const { phone, phoneCodeHash, abortSignal } = params;
      const res = yield client.call(
        {
          _: "auth.resendCode",
          phoneNumber: normalizePhoneNumber(phone),
          phoneCodeHash
        },
        { abortSignal }
      );
      assertTypeIs("sendCode", res, "auth.sentCode");
      return new SentCode(res);
    });
  }
  function getMe(client) {
    return client.call({
      _: "users.getUsers",
      id: [
        {
          _: "inputUserSelf"
        }
      ]
    }).then((_0) => __async(this, [_0], function* ([user]) {
      assertTypeIs("getMe (@ users.getUsers)", user, "user");
      yield client.storage.self.storeFrom(user);
      return new User(user);
    }));
  }
  function sendCode(client, params) {
    return __async(this, null, function* () {
      const phone = normalizePhoneNumber(params.phone);
      const { id: id2, hash } = yield client.getApiCrenetials();
      const res = yield client.call(
        {
          _: "auth.sendCode",
          phoneNumber: phone,
          apiId: id2,
          apiHash: hash,
          settings: __spreadValues({
            _: "codeSettings",
            logoutTokens: params.futureAuthTokens
          }, params.codeSettings)
        },
        { abortSignal: params.abortSignal }
      );
      assertTypeIs("sendCode", res, "auth.sentCode");
      return new SentCode(res);
    });
  }
  function signIn(client, params) {
    return __async(this, null, function* () {
      const { phone, phoneCodeHash, phoneCode, abortSignal } = params;
      const res = yield client.call(
        {
          _: "auth.signIn",
          phoneNumber: normalizePhoneNumber(phone),
          phoneCodeHash,
          phoneCode
        },
        { abortSignal }
      );
      return _onAuthorization(client, res);
    });
  }
  function signInBot(client, token) {
    return __async(this, null, function* () {
      const { id: id2, hash } = yield client.getApiCrenetials();
      const res = yield client.call({
        _: "auth.importBotAuthorization",
        flags: 0,
        apiId: id2,
        apiHash: hash,
        botAuthToken: token
      });
      return _onAuthorization(client, res);
    });
  }
  function signInQr(client, params) {
    return __async(this, null, function* () {
      const { onUrlUpdated, abortSignal, onQrScanned } = params;
      let waiter;
      const originalHandler = client.getServerUpdateHandler();
      const onUpdate = (upd) => {
        if (upd._ === "updateShort" && upd.update._ === "updateLoginToken") {
          onQrScanned == null ? void 0 : onQrScanned();
          waiter == null ? void 0 : waiter.resolve();
          client.onServerUpdate(originalHandler);
        }
      };
      client.onServerUpdate(onUpdate);
      abortSignal == null ? void 0 : abortSignal.addEventListener("abort", () => {
        client.onServerUpdate(originalHandler);
        waiter == null ? void 0 : waiter.reject(abortSignal.reason);
      });
      function handle2fa(input) {
        return __async(this, null, function* () {
          var _a2;
          const isDynamic = typeof input === "function";
          while (true) {
            const password = yield resolveMaybeDynamic(input);
            try {
              return yield checkPassword(client, password);
            } catch (e) {
              if (tl.tl.RpcError.is(e, "PASSWORD_HASH_INVALID")) {
                if (!isDynamic) {
                  throw e;
                }
                if (params.invalidPasswordCallback) {
                  yield (_a2 = params.invalidPasswordCallback) == null ? void 0 : _a2.call(params);
                } else {
                  console.log("Invalid password. Please try again");
                }
                continue;
              }
              throw e;
            }
          }
        });
      }
      try {
        const { id: id2, hash } = yield client.getApiCrenetials();
        const platform = getPlatform();
        loop:
          while (true) {
            let res;
            try {
              res = yield client.call(
                {
                  _: "auth.exportLoginToken",
                  apiId: id2,
                  apiHash: hash,
                  exceptIds: []
                },
                { abortSignal }
              );
            } catch (e) {
              if (tl.tl.RpcError.is(e, "SESSION_PASSWORD_NEEDED") && params.password) {
                return yield handle2fa(params.password);
              }
              throw e;
            }
            switch (res._) {
              case "auth.loginToken":
                onUrlUpdated(
                  `tg://login?token=${platform.base64Encode(res.token, true)}`,
                  new Date(res.expires * 1e3)
                );
                waiter = createControllablePromise();
                yield Promise.race([waiter, sleepWithAbort(res.expires * 1e3 - Date.now(), client.stopSignal)]);
                break;
              case "auth.loginTokenMigrateTo": {
                yield client.changePrimaryDc(res.dcId);
                let res2;
                try {
                  res2 = yield client.call(
                    {
                      _: "auth.importLoginToken",
                      token: res.token
                    },
                    { abortSignal }
                  );
                } catch (e) {
                  if (tl.tl.RpcError.is(e, "SESSION_PASSWORD_NEEDED") && params.password) {
                    return yield handle2fa(params.password);
                  }
                  throw e;
                }
                assertTypeIs("auth.importLoginToken", res2, "auth.loginTokenSuccess");
                break loop;
              }
              case "auth.loginTokenSuccess":
                break loop;
            }
          }
        const [self2] = yield client.call(
          {
            _: "users.getUsers",
            id: [{ _: "inputUserSelf" }]
          },
          { abortSignal }
        );
        assertTypeIs("users.getUsers", self2, "user");
        yield client.notifyLoggedIn(self2);
        return new User(self2);
      } finally {
        client.onServerUpdate(originalHandler);
      }
    });
  }
  function start(client, params) {
    return __async(this, null, function* () {
      if (params.session) {
        yield client.importSession(params.session, params.sessionForce);
      }
      const { abortSignal } = params;
      let has2fa = false;
      let sentCode;
      let phone = null;
      try {
        const me = yield getMe(client);
        client.log.info("Logged in as %s (ID: %s, username: %s, bot: %s)", me.displayName, me.id, me.username, me.isBot);
        yield client.notifyLoggedIn(me.raw);
        return me;
      } catch (e) {
        if (tl.tl.RpcError.is(e)) {
          if (e.text === "SESSION_PASSWORD_NEEDED")
            has2fa = true;
          else if (e.text !== "AUTH_KEY_UNREGISTERED")
            throw e;
        } else {
          throw e;
        }
      }
      if (!has2fa && !params.qrCodeHandler) {
        if (!params.phone && !params.botToken) {
          throw new MtArgumentError("Neither phone nor bot token were provided");
        }
        phone = params.phone ? yield resolveMaybeDynamic(params.phone) : null;
        if (phone) {
          phone = normalizePhoneNumber(phone);
          if (!params.code) {
            throw new MtArgumentError("You must pass `code` to use `phone`");
          }
        } else {
          const botToken = params.botToken ? yield resolveMaybeDynamic(params.botToken) : null;
          if (!botToken) {
            throw new MtArgumentError("Either bot token or phone number must be provided");
          }
          return signInBot(client, botToken);
        }
        try {
          sentCode = yield sendCode(client, {
            phone,
            futureAuthTokens: params.futureAuthTokens,
            codeSettings: params.codeSettings,
            abortSignal
          });
        } catch (e) {
          if (tl.tl.RpcError.is(e, "SESSION_PASSWORD_NEEDED")) {
            has2fa = true;
          } else {
            throw e;
          }
        }
      }
      if (sentCode) {
        if (params.forceSms && (sentCode.type === "app" || sentCode.type === "email")) {
          sentCode = yield resendCode(client, {
            phone,
            phoneCodeHash: sentCode.phoneCodeHash,
            abortSignal
          });
        }
        if (params.codeSentCallback) {
          yield params.codeSentCallback(sentCode);
        } else {
          if (sentCode.type === "email_required") {
            throw new MtcuteError("Email login setup is required to sign in");
          }
          console.log(`The confirmation code has been sent via ${sentCode.type}.`);
        }
        for (; ; ) {
          const code2 = yield resolveMaybeDynamic(params.code);
          if (!code2)
            throw new tl.tl.RpcError(400, "PHONE_CODE_EMPTY");
          try {
            return yield signIn(client, {
              phone,
              phoneCodeHash: sentCode.phoneCodeHash,
              phoneCode: code2,
              abortSignal
            });
          } catch (e) {
            if (!tl.tl.RpcError.is(e))
              throw e;
            if (e.is("SESSION_PASSWORD_NEEDED")) {
              has2fa = true;
              break;
            } else if (e.is("PHONE_CODE_EMPTY") || e.is("PHONE_CODE_EXPIRED") || e.is("PHONE_CODE_INVALID") || e.is("PHONE_CODE_HASH_EMPTY")) {
              if (typeof params.code !== "function") {
                throw new MtArgumentError("Provided code was invalid");
              }
              if (params.invalidCodeCallback) {
                yield params.invalidCodeCallback("code");
              } else {
                console.log("Invalid code. Please try again");
              }
              continue;
            } else {
              throw e;
            }
          }
          break;
        }
      }
      if (has2fa) {
        if (!params.password) {
          throw new MtArgumentError("2FA is enabled, but `password` was not provided.");
        }
        for (; ; ) {
          const password = yield resolveMaybeDynamic(params.password);
          try {
            return yield checkPassword(client, password);
          } catch (e) {
            if (typeof params.password !== "function") {
              throw new MtArgumentError("Provided password was invalid");
            }
            if (tl.tl.RpcError.is(e, "PASSWORD_HASH_INVALID")) {
              if (params.invalidCodeCallback) {
                yield params.invalidCodeCallback("password");
              } else {
                console.log("Invalid password. Please try again");
              }
              continue;
            } else {
              throw e;
            }
          }
        }
      }
      if (params.qrCodeHandler) {
        return signInQr(client, {
          onUrlUpdated: params.qrCodeHandler,
          password: params.password,
          invalidPasswordCallback: params.invalidCodeCallback ? () => params.invalidCodeCallback("password") : void 0,
          abortSignal
        });
      }
      throw new MtArgumentError("Failed to log in with provided credentials");
    });
  }
  function run(client, params, then) {
    start(client, params).then(then).catch((err2) => client.emitError(err2));
  }
  function sendRecoveryCode(client) {
    return client.call({
      _: "auth.requestPasswordRecovery"
    }).then((res) => res.emailPattern);
  }
  function startTest(client, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      if (params.logout) {
        try {
          yield logOut(client);
        } catch (e) {
        }
      }
      const availableDcs = yield client.call({
        _: "help.getConfig"
      }).then((res) => res.dcOptions);
      let phone = params.phone;
      if (phone) {
        if (!phone.match(/^99966\d{5}/)) {
          throw new MtArgumentError(`${phone} is an invalid test phone number`);
        }
        const id2 = Number.parseInt(phone[5]);
        if (!availableDcs.find((dc) => dc.id === id2)) {
          throw new MtArgumentError(`${phone} has invalid DC ID (${id2})`);
        }
      } else {
        let dcId = yield client.getPrimaryDcId();
        if (params.dcId) {
          if (!availableDcs.find((dc) => dc.id === params.dcId)) {
            throw new MtArgumentError(`DC ID is invalid (${dcId})`);
          }
          dcId = params.dcId;
        }
        let numbers = Math.floor(Math.random() * 9999).toString();
        while (numbers.length !== 4)
          numbers += "0";
        phone = `99966${dcId}${numbers}`;
      }
      let code2 = "";
      return start(client, {
        phone,
        code: () => code2,
        codeSentCallback: (sent) => {
          for (let i = 0; i < sent.length; i++) {
            code2 += phone[5];
          }
        }
      });
    });
  }
  function answerCallbackQuery(client, queryId, params) {
    return __async(this, null, function* () {
      const { cacheTime = 0, text, alert, url } = params != null ? params : {};
      const r = yield client.call({
        _: "messages.setBotCallbackAnswer",
        queryId: Long.isLong(queryId) ? queryId : queryId.id,
        cacheTime,
        alert,
        message: text,
        url
      });
      assertTrue("messages.setBotCallbackAnswer", r);
    });
  }
  function answerInlineQuery(client, queryId, results, params) {
    return __async(this, null, function* () {
      const { cacheTime = 300, gallery, private: priv, nextOffset, switchPm, switchWebview } = params != null ? params : {};
      const [defaultGallery, tlResults] = yield _convertToTl(client, results);
      yield client.call({
        _: "messages.setInlineBotResults",
        queryId: Long.isLong(queryId) ? queryId : queryId.id,
        results: tlResults,
        cacheTime,
        gallery: gallery != null ? gallery : defaultGallery,
        private: priv,
        nextOffset,
        switchPm: switchPm ? {
          _: "inlineBotSwitchPM",
          text: switchPm.text,
          startParam: switchPm.parameter
        } : void 0,
        switchWebview: switchWebview ? {
          _: "inlineBotWebView",
          text: switchWebview.text,
          url: switchWebview.url
        } : void 0
      });
    });
  }
  function answerPreCheckoutQuery(client, queryId, params) {
    return __async(this, null, function* () {
      const { error } = params != null ? params : {};
      const r = yield client.call({
        _: "messages.setBotPrecheckoutResults",
        queryId: Long.isLong(queryId) ? queryId : queryId.queryId,
        success: !error,
        error
      });
      assertTrue("messages.setBotPrecheckoutResults", r);
    });
  }
  function _normalizeCommandScope(client, scope) {
    return __async(this, null, function* () {
      if (tl.tl.isAnyBotCommandScope(scope))
        return scope;
      switch (scope.type) {
        case "peer":
        case "peer_admins": {
          const peer = yield resolvePeer(client, scope.peer);
          return {
            _: scope.type === "peer" ? "botCommandScopePeer" : "botCommandScopePeerAdmins",
            peer
          };
        }
        case "member": {
          const user = yield resolveUser(client, scope.user);
          const chat = yield resolvePeer(client, scope.chat);
          return {
            _: "botCommandScopePeerUser",
            peer: chat,
            userId: user
          };
        }
        default:
          assertNever$1();
      }
    });
  }
  function deleteMyCommands(client, params) {
    return __async(this, null, function* () {
      var _a2;
      const scope = (params == null ? void 0 : params.scope) ? yield _normalizeCommandScope(client, params.scope) : {
        _: "botCommandScopeDefault"
      };
      yield client.call({
        _: "bots.resetBotCommands",
        scope,
        langCode: (_a2 = params == null ? void 0 : params.langCode) != null ? _a2 : ""
      });
    });
  }
  function getBotInfo(client, params) {
    return __async(this, null, function* () {
      const { bot, langCode = "" } = params;
      return client.call({
        _: "bots.getBotInfo",
        bot: bot ? yield resolveUser(client, bot) : void 0,
        langCode
      });
    });
  }
  function getBotMenuButton(client, user) {
    return __async(this, null, function* () {
      return client.call({
        _: "bots.getBotMenuButton",
        userId: yield resolveUser(client, user)
      });
    });
  }
  function getCallbackAnswer(client, params) {
    return __async(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const { data: data2, game, timeout = 1e4, fireAndForget } = params;
      let password;
      if (params == null ? void 0 : params.password) {
        const pwd = yield client.call({ _: "account.getPassword" });
        password = yield client.computeSrpParams(pwd, params.password);
      }
      const promise = client.call(
        {
          _: "messages.getBotCallbackAnswer",
          peer: yield resolvePeer(client, chatId),
          msgId: message2,
          data: typeof data2 === "string" ? getPlatform().utf8Encode(data2) : data2,
          password,
          game
        },
        { timeout, throw503: true }
      );
      if (fireAndForget) {
        promise.catch(() => {
        });
        return {
          _: "messages.botCallbackAnswer",
          cacheTime: 0
        };
      }
      return promise;
    });
  }
  function getGameHighScores(client, params) {
    return __async(this, null, function* () {
      const { userId } = params;
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const chat = yield resolvePeer(client, chatId);
      let user;
      if (userId) {
        user = yield resolveUser(client, userId);
      } else {
        user = { _: "inputUserEmpty" };
      }
      const res = yield client.call({
        _: "messages.getGameHighScores",
        peer: chat,
        id: message2,
        userId: user
      });
      const peers = PeersIndex.from(res);
      return res.scores.map((score) => new GameHighScore(score, peers));
    });
  }
  function getInlineGameHighScores(client, messageId, userId) {
    return __async(this, null, function* () {
      const id2 = normalizeInlineId(messageId);
      let user;
      if (userId) {
        user = yield resolveUser(client, userId);
      } else {
        user = { _: "inputUserEmpty" };
      }
      const res = yield client.call(
        {
          _: "messages.getInlineGameHighScores",
          id: id2,
          userId: user
        },
        { dcId: id2.dcId }
      );
      const peers = PeersIndex.from(res);
      return res.scores.map((score) => new GameHighScore(score, peers));
    });
  }
  function getMyCommands(client, params) {
    return __async(this, null, function* () {
      var _a2;
      return client.call({
        _: "bots.getBotCommands",
        scope: (params == null ? void 0 : params.scope) ? yield _normalizeCommandScope(client, params.scope) : {
          _: "botCommandScopeDefault"
        },
        langCode: (_a2 = params == null ? void 0 : params.langCode) != null ? _a2 : ""
      });
    });
  }
  function setBotInfo(client, params) {
    return __async(this, null, function* () {
      const { bot, langCode = "", name, bio, description } = params;
      const r = yield client.call({
        _: "bots.setBotInfo",
        bot: bot ? yield resolveUser(client, bot) : void 0,
        langCode,
        name,
        about: bio,
        description
      });
      assertTrue("bots.setBotInfo", r);
    });
  }
  function setBotMenuButton(client, user, button) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "bots.setBotMenuButton",
        userId: yield resolveUser(client, user),
        button
      });
      assertTrue("bots.setBotMenuButton", r);
    });
  }
  function setGameScore(client, params) {
    return __async(this, null, function* () {
      const { userId, score, noEdit, force, shouldDispatch } = params;
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const user = yield resolveUser(client, userId);
      const chat = yield resolvePeer(client, chatId);
      const res = yield client.call({
        _: "messages.setGameScore",
        peer: chat,
        id: message2,
        userId: user,
        score,
        editMessage: !noEdit,
        force
      });
      return _findMessageInUpdate(client, res, true, !shouldDispatch);
    });
  }
  function setInlineGameScore(client, params) {
    return __async(this, null, function* () {
      const { messageId, userId, score, noEdit, force } = params;
      const user = yield resolveUser(client, userId);
      const id2 = normalizeInlineId(messageId);
      const r = yield client.call(
        {
          _: "messages.setInlineGameScore",
          id: id2,
          userId: user,
          score,
          editMessage: !noEdit,
          force
        },
        { dcId: id2.dcId }
      );
      assertTrue("messages.setInlineGameScore", r);
    });
  }
  function setMyCommands(client, params) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      const scope = params.scope ? yield _normalizeCommandScope(client, params.scope) : {
        _: "botCommandScopeDefault"
      };
      if ((_a2 = params.commands) == null ? void 0 : _a2.length) {
        const r = yield client.call({
          _: "bots.setBotCommands",
          commands: params.commands,
          scope,
          langCode: (_b = params.langCode) != null ? _b : ""
        });
        assertTrue("bots.setBotCommands", r);
      } else {
        const r = yield client.call({
          _: "bots.resetBotCommands",
          scope,
          langCode: (_c = params.langCode) != null ? _c : ""
        });
        assertTrue("bots.resetBotCommands", r);
      }
    });
  }
  function setMyDefaultRights(client, params) {
    return __async(this, null, function* () {
      const { target, rights } = params;
      const r = yield client.call({
        _: target === "group" ? "bots.setBotGroupDefaultAdminRights" : "bots.setBotBroadcastDefaultAdminRights",
        adminRights: __spreadValues({
          _: "chatAdminRights"
        }, rights)
      });
      assertTrue("bots.setBotGroupDefaultAdminRights", r);
    });
  }
  function addChatMembers(client, chatId, users, params) {
    return __async(this, null, function* () {
      const { forwardCount = 100 } = params;
      const chat = yield resolvePeer(client, chatId);
      if (!Array.isArray(users))
        users = [users];
      if (isInputPeerChat(chat)) {
        const missing = [];
        for(let   user of users) {
          const p = yield resolveUser(client, user);
          const { updates, missingInvitees } = yield client.call({
            _: "messages.addChatUser",
            chatId: chat.chatId,
            userId: p,
            fwdLimit: forwardCount
          });
          client.handleClientUpdate(updates);
          missing.push(...missingInvitees);
        }
        return missing;
      } else if (isInputPeerChannel(chat)) {
        const { updates, missingInvitees } = yield client.call({
          _: "channels.inviteToChannel",
          channel: toInputChannel(chat),
          users: yield resolvePeerMany(client, users, toInputUser)
        });
        client.handleClientUpdate(updates);
        return missingInvitees;
      }
      throw new MtInvalidPeerTypeError(chatId, "chat or channel");
    });
  }
  function archiveChats(client, chats) {
    return __async(this, null, function* () {
      if (!Array.isArray(chats))
        chats = [chats];
      const resolvedPeers = yield resolvePeerMany(client, chats);
      const updates = yield client.call({
        _: "folders.editPeerFolders",
        folderPeers: resolvedPeers.filter(isPresent).map((peer) => ({
          _: "inputFolderPeer",
          peer,
          folderId: 1
        }))
      });
      client.handleClientUpdate(updates);
    });
  }
  function banChatMember(client, params) {
    return __async(this, null, function* () {
      var _a2;
      const { chatId, participantId, shouldDispatch } = params;
      const chat = yield resolvePeer(client, chatId);
      const peer = yield resolvePeer(client, participantId);
      let res;
      if (isInputPeerChannel(chat)) {
        res = yield client.call({
          _: "channels.editBanned",
          channel: toInputChannel(chat),
          participant: peer,
          bannedRights: {
            _: "chatBannedRights",
            untilDate: (_a2 = normalizeDate(params == null ? void 0 : params.untilDate)) != null ? _a2 : 0,
            viewMessages: true
          }
        });
      } else if (isInputPeerChat(chat)) {
        res = yield client.call({
          _: "messages.deleteChatUser",
          chatId: chat.chatId,
          userId: toInputUser(peer)
        });
      } else {
        throw new MtInvalidPeerTypeError(chatId, "chat or channel");
      }
      return _findMessageInUpdate(client, res, false, !shouldDispatch, true);
    });
  }
  function createChannel(client, params) {
    return __async(this, null, function* () {
      const { title, description = "" } = params;
      const res = yield client.call({
        _: "channels.createChannel",
        title,
        about: description,
        broadcast: true
      });
      assertIsUpdatesGroup("channels.createChannel", res);
      client.handleClientUpdate(res);
      return new Chat(res.chats[0]);
    });
  }
  function createGroup(client, params) {
    return __async(this, null, function* () {
      const { title } = params;
      let { users } = params;
      if (!Array.isArray(users))
        users = [users];
      const peers = yield resolvePeerMany(client, users, toInputUser);
      const { updates, missingInvitees } = yield client.call({
        _: "messages.createChat",
        title,
        users: peers
      });
      assertIsUpdatesGroup("messages.createChat", updates);
      client.handleClientUpdate(updates);
      return {
        chat: new Chat(updates.chats[0]),
        missing: missingInvitees
      };
    });
  }
  function createSupergroup(client, params) {
    return __async(this, null, function* () {
      const { title, description = "", forum, ttlPeriod = 0 } = params;
      const res = yield client.call({
        _: "channels.createChannel",
        title,
        about: description,
        megagroup: true,
        forum,
        ttlPeriod
      });
      assertIsUpdatesGroup("channels.createChannel", res);
      client.handleClientUpdate(res);
      return new Chat(res.chats[0]);
    });
  }
  function deleteChannel(client, chatId) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "channels.deleteChannel",
        channel: yield resolveChannel(client, chatId)
      });
      client.handleClientUpdate(res);
    });
  }
  function deleteChatPhoto(client, chatId) {
    return __async(this, null, function* () {
      const chat = yield resolvePeer(client, chatId);
      let res;
      if (isInputPeerChat(chat)) {
        res = yield client.call({
          _: "messages.editChatPhoto",
          chatId: chat.chatId,
          photo: { _: "inputChatPhotoEmpty" }
        });
      } else if (isInputPeerChannel(chat)) {
        res = yield client.call({
          _: "channels.editPhoto",
          channel: toInputChannel(chat),
          photo: { _: "inputChatPhotoEmpty" }
        });
      } else {
        throw new MtInvalidPeerTypeError(chatId, "chat or channel");
      }
      client.handleClientUpdate(res);
    });
  }
  function deleteGroup(client, chatId) {
    return __async(this, null, function* () {
      const chat = yield resolvePeer(client, chatId);
      if (!isInputPeerChat(chat))
        throw new MtInvalidPeerTypeError(chatId, "chat");
      const res = yield client.call({
        _: "messages.deleteChatUser",
        revokeHistory: true,
        chatId: chat.chatId,
        userId: { _: "inputUserSelf" }
      });
      client.handleClientUpdate(res);
      const r = yield client.call({
        _: "messages.deleteChat",
        chatId: chat.chatId
      });
      assertTrue("messages.deleteChat", r);
    });
  }
  function deleteHistory(client, chat, params) {
    return __async(this, null, function* () {
      const { mode = "delete", maxId = 0 } = params != null ? params : {};
      const peer = yield resolvePeer(client, chat);
      const res = yield client.call({
        _: "messages.deleteHistory",
        justClear: mode === "clear",
        revoke: mode === "revoke",
        peer,
        maxId
      });
      if (isInputPeerChannel(peer)) {
        client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, peer.channelId));
      } else {
        client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
      }
    });
  }
  function deleteUserHistory(client, params) {
    return __async(this, null, function* () {
      const { chatId, participantId, shouldDispatch } = params;
      const channel = yield resolveChannel(client, chatId);
      const peer = yield resolvePeer(client, participantId);
      const res = yield client.call({
        _: "channels.deleteParticipantHistory",
        channel,
        participant: peer
      });
      if (!shouldDispatch) {
        client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, channel.channelId));
      }
    });
  }
  function editAdminRights(client, params) {
    return __async(this, null, function* () {
      const { chatId, userId, rights, rank = "" } = params;
      const chat = yield resolveChannel(client, chatId);
      const user = yield resolveUser(client, userId);
      const res = yield client.call({
        _: "channels.editAdmin",
        channel: chat,
        userId: user,
        adminRights: __spreadValues({
          _: "chatAdminRights"
        }, rights),
        rank
      });
      client.handleClientUpdate(res);
    });
  }
  function normalizeChatEventFilters(input) {
    if (!input) {
      return {};
    }
    if (typeof input === "string" || Array.isArray(input)) {
      if (!Array.isArray(input))
        input = [input];
      const serverFilter = {
        _: "channelAdminLogEventsFilter"
      };
      const localFilter = {};
      input.forEach((type) => {
        localFilter[type] = true;
        switch (type) {
          case "user_joined":
          case "user_joined_invite":
          case "user_joined_approved":
            serverFilter.join = true;
            break;
          case "user_left":
            serverFilter.leave = true;
            break;
          case "user_invited":
            serverFilter.invite = true;
            break;
          case "title_changed":
          case "description_changed":
          case "linked_chat_changed":
          case "location_changed":
          case "photo_changed":
          case "username_changed":
          case "usernames_changed":
          case "stickerset_changed":
          case "slow_mode_changed":
          case "ttl_changed":
            serverFilter.info = true;
            break;
          case "invites_toggled":
          case "history_toggled":
          case "signatures_toggled":
          case "def_perms_changed":
          case "forum_toggled":
          case "no_forwards_toggled":
          case "signature_profiles_toggled":
            serverFilter.settings = true;
            break;
          case "msg_pinned":
            serverFilter.pinned = true;
            break;
          case "msg_edited":
          case "poll_stopped":
            serverFilter.edit = true;
            break;
          case "msg_deleted":
            serverFilter.delete = true;
            break;
          case "user_perms_changed":
            serverFilter.ban = true;
            serverFilter.unban = true;
            serverFilter.kick = true;
            serverFilter.unkick = true;
            break;
          case "user_admin_perms_changed":
            serverFilter.promote = true;
            serverFilter.demote = true;
            break;
          case "call_started":
          case "call_ended":
            serverFilter.groupCall = true;
            break;
          case "call_setting_changed":
            serverFilter.groupCall = true;
            serverFilter.settings = true;
            serverFilter.info = true;
            break;
          case "invite_deleted":
          case "invite_edited":
          case "invite_revoked":
            serverFilter.invites = true;
            break;
          case "topic_created":
          case "topic_edited":
          case "topic_deleted":
            serverFilter.forums = true;
            break;
          case "sub_extend":
            serverFilter.invite = true;
            serverFilter.invites = true;
            serverFilter.join = true;
            serverFilter.info = true;
            serverFilter.settings = true;
            break;
          default:
            assertNever$1();
        }
      });
      return {
        serverFilter,
        localFilter
      };
    }
    if ("_" in input) {
      return {
        serverFilter: input
      };
    }
    return input;
  }
  function getChatEventLog(client, chatId, params) {
    return __async(this, null, function* () {
      const { maxId = Long.ZERO, minId = Long.ZERO, query = "", limit = 100, users, filters } = params != null ? params : {};
      const channel = yield resolveChannel(client, chatId);
      const admins = users ? yield resolvePeerMany(client, users, toInputUser) : void 0;
      const { serverFilter, localFilter } = normalizeChatEventFilters(filters);
      const res = yield client.call({
        _: "channels.getAdminLog",
        channel,
        q: query,
        eventsFilter: serverFilter,
        admins,
        maxId,
        minId,
        limit
      });
      if (!res.events.length)
        return [];
      const peers = PeersIndex.from(res);
      const results = [];
      for(let   evt of res.events) {
        const parsed = new ChatEvent(evt, peers);
        if (localFilter && (!parsed.action || !localFilter[parsed.action.type])) {
          continue;
        }
        results.push(parsed);
      }
      return results;
    });
  }
  function getChatMember(client, params) {
    return __async(this, null, function* () {
      const { chatId, userId } = params;
      const user = yield resolvePeer(client, userId);
      const chat = yield resolvePeer(client, chatId);
      if (isInputPeerChat(chat)) {
        if (!isInputPeerUser(user)) {
          throw new MtInvalidPeerTypeError(userId, "user");
        }
        const res = yield client.call({
          _: "messages.getFullChat",
          chatId: chat.chatId
        });
        assertTypeIs("getChatMember (@ messages.getFullChat)", res.fullChat, "chatFull");
        const members = res.fullChat.participants._ === "chatParticipantsForbidden" ? [] : res.fullChat.participants.participants;
        const peers = PeersIndex.from(res);
        for(let   m2 of members) {
          if (user._ === "inputPeerSelf" && peers.user(m2.userId).self || user._ === "inputPeerUser" && m2.userId === user.userId) {
            return new ChatMember(m2, peers);
          }
        }
        return null;
      } else if (isInputPeerChannel(chat)) {
        try {
          const res = yield client.call({
            _: "channels.getParticipant",
            channel: toInputChannel(chat),
            participant: user
          });
          const peers = PeersIndex.from(res);
          return new ChatMember(res.participant, peers);
        } catch (e) {
          if (tl.tl.RpcError.is(e, "USER_NOT_PARTICIPANT")) {
            return null;
          }
          throw e;
        }
      } else {
        throw new MtInvalidPeerTypeError(chatId, "chat or channel");
      }
    });
  }
  function getChatMembers(client, chatId, params) {
    return __async(this, null, function* () {
      const { query = "", offset = 0, limit = 200, type = "recent" } = params != null ? params : {};
      const chat = yield resolvePeer(client, chatId);
      if (isInputPeerChat(chat)) {
        const res = yield client.call({
          _: "messages.getFullChat",
          chatId: chat.chatId
        });
        assertTypeIs("getChatMember (@ messages.getFullChat)", res.fullChat, "chatFull");
        let members = res.fullChat.participants._ === "chatParticipantsForbidden" ? [] : res.fullChat.participants.participants;
        if (offset)
          members = members.slice(offset);
        if (limit)
          members = members.slice(0, limit);
        const peers = PeersIndex.from(res);
        const ret = members.map((m2) => new ChatMember(m2, peers));
        return makeArrayWithTotal(ret, ret.length);
      }
      if (isInputPeerChannel(chat)) {
        const q = query;
        let filter;
        switch (type) {
          case "all":
            filter = { _: "channelParticipantsSearch", q };
            break;
          case "banned":
            filter = { _: "channelParticipantsKicked", q };
            break;
          case "restricted":
            filter = { _: "channelParticipantsBanned", q };
            break;
          case "mention":
            filter = { _: "channelParticipantsMentions", q };
            break;
          case "bots":
            filter = { _: "channelParticipantsBots" };
            break;
          case "recent":
            filter = { _: "channelParticipantsRecent" };
            break;
          case "admins":
            filter = { _: "channelParticipantsAdmins" };
            break;
          case "contacts":
            filter = { _: "channelParticipantsContacts", q };
            break;
          default:
            assertNever$1();
        }
        const res = yield client.call({
          _: "channels.getParticipants",
          channel: toInputChannel(chat),
          filter,
          offset,
          limit,
          hash: Long.ZERO
        });
        assertTypeIs("getChatMembers (@ channels.getParticipants)", res, "channels.channelParticipants");
        const peers = PeersIndex.from(res);
        const ret = res.participants.map((i) => new ChatMember(i, peers));
        return makeArrayWithTotal(ret, res.count);
      }
      throw new MtInvalidPeerTypeError(chatId, "chat or channel");
    });
  }
  function getChatPreview(client, inviteLink) {
    return __async(this, null, function* () {
      const m2 = inviteLink.match(INVITE_LINK_REGEX);
      if (!m2)
        throw new MtArgumentError("Invalid invite link");
      const res = yield client.call({
        _: "messages.checkChatInvite",
        hash: m2[1]
      });
      if (res._ !== "chatInvite") {
        throw new MtPeerNotFoundError("You have already joined this chat!");
      }
      return new ChatPreview(res, inviteLink);
    });
  }
  function getChat(client, chatId) {
    return __async(this, null, function* () {
      if (typeof chatId === "string") {
        const m2 = chatId.match(INVITE_LINK_REGEX);
        if (m2) {
          const res2 = yield client.call({
            _: "messages.checkChatInvite",
            hash: m2[1]
          });
          if (res2._ === "chatInvite") {
            throw new MtArgumentError(`You haven't joined ${JSON.stringify(res2.title)}`);
          }
          return new Chat(res2.chat);
        }
      }
      const peer = yield resolvePeer(client, chatId);
      const res = yield _getRawPeerBatched(client, peer);
      if (!res)
        throw new MtPeerNotFoundError(`Chat ${JSON.stringify(chatId)} was not found`);
      return new Chat(res);
    });
  }
  function getFullChat(client, chatId) {
    return __async(this, null, function* () {
      if (typeof chatId === "string") {
        const m2 = chatId.match(INVITE_LINK_REGEX);
        if (m2) {
          const res2 = yield client.call({
            _: "messages.checkChatInvite",
            hash: m2[1]
          });
          if (res2._ === "chatInvite") {
            throw new MtArgumentError(`You haven't joined ${JSON.stringify(res2.title)}`);
          }
          chatId = res2.chat.id;
        }
      }
      const peer = yield resolvePeer(client, chatId);
      let res;
      if (isInputPeerChannel(peer)) {
        res = yield client.call({
          _: "channels.getFullChannel",
          channel: toInputChannel(peer)
        });
      } else if (isInputPeerUser(peer)) {
        res = yield client.call({
          _: "users.getFullUser",
          id: toInputUser(peer)
        });
      } else if (isInputPeerChat(peer)) {
        res = yield client.call({
          _: "messages.getFullChat",
          chatId: peer.chatId
        });
      } else {
        throw new Error("should not happen");
      }
      return FullChat._parse(res);
    });
  }
  function getNearbyChats(client, latitude, longitude) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "contacts.getLocated",
        geoPoint: {
          _: "inputGeoPoint",
          lat: latitude,
          long: longitude
        }
      });
      assertIsUpdatesGroup("contacts.getLocated", res);
      client.handleClientUpdate(res, true);
      if (!res.updates.length)
        return [];
      assertTypeIs("contacts.getLocated (@ .updates[0])", res.updates[0], "updatePeerLocated");
      const chats = res.chats.map((it) => new Chat(it));
      const index = {};
      chats.forEach((c) => index[c.id] = c);
      res.updates[0].peers.forEach((peer) => {
        if (peer._ === "peerSelfLocated")
          return;
        const id2 = getMarkedPeerId(peer.peer);
        if (index[id2]) {
          index[id2].distance = peer.distance;
        }
      });
      return chats;
    });
  }
  function getSimilarChannels(client, channel) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "channels.getChannelRecommendations",
        channel: yield resolveChannel(client, channel)
      });
      const parsed = res.chats.map((chat) => new Chat(chat));
      switch (res._) {
        case "messages.chatsSlice":
          return makeArrayWithTotal(parsed, res.count);
        case "messages.chats":
          return makeArrayWithTotal(parsed, parsed.length);
      }
    });
  }
  function iterChatEventLog(client, chatId, params) {
    return __asyncGenerator(this, null, function* () {
      var _a2;
      if (!params)
        params = {};
      const channel = yield new __await(resolveChannel(client, chatId));
      const { minId = Long.ZERO, query = "", limit = Infinity, chunkSize = 100, users, filters } = params;
      const admins = users ? yield new __await(resolvePeerMany(client, users, toInputUser)) : void 0;
      const { serverFilter, localFilter } = normalizeChatEventFilters(filters);
      let current = 0;
      let maxId = (_a2 = params.maxId) != null ? _a2 : Long.ZERO;
      for (; ; ) {
        const chunk = yield new __await(getChatEventLog(client, channel, {
          minId,
          maxId,
          query,
          limit: localFilter ? chunkSize : Math.min(limit - current, chunkSize),
          // provide already resolved users to avoid resolving them again
          users: admins,
          // local filters may mess with pagination
          filters: { serverFilter }
        }));
        if (!chunk.length)
          break;
        const last = chunk[chunk.length - 1];
        maxId = last.id;
        for(let   item of chunk) {
          if (localFilter && (!item.action || !localFilter[item.action.type])) {
            continue;
          }
          current += 1;
          yield item;
          if (current >= limit)
            break;
        }
      }
    });
  }
  function iterChatMembers(client, chatId, params) {
    return __asyncGenerator(this, null, function* () {
      var _a2, _b;
      if (!params)
        params = {};
      let current = 0;
      let total = params.limit || Infinity;
      const limit = Math.min((_a2 = params.chunkSize) != null ? _a2 : 200, total);
      let offset = (_b = params.offset) != null ? _b : 0;
      const yielded = /* @__PURE__ */ new Set();
      const chat = yield new __await(resolvePeer(client, chatId));
      for (; ; ) {
        const members = yield new __await(getChatMembers(client, chat, {
          offset,
          limit,
          query: params.query,
          type: params.type
        }));
        if (!members.length)
          break;
        if (isInputPeerChat(chat)) {
          total = members.length;
        }
        offset += members.length;
        for(let   m2 of members) {
          const uid2 = m2.user.id;
          if (yielded.has(uid2))
            continue;
          yielded.add(uid2);
          yield m2;
          current += 1;
          if (current >= total)
            return;
        }
      }
    });
  }
  function joinChat(client, chatId) {
    return __async(this, null, function* () {
      if (typeof chatId === "string") {
        const m2 = chatId.match(INVITE_LINK_REGEX);
        if (m2) {
          const res2 = yield client.call({
            _: "messages.importChatInvite",
            hash: m2[1]
          });
          assertIsUpdatesGroup("messages.importChatInvite", res2);
          client.handleClientUpdate(res2);
          return new Chat(res2.chats[0]);
        }
      }
      const res = yield client.call({
        _: "channels.joinChannel",
        channel: yield resolveChannel(client, chatId)
      });
      assertIsUpdatesGroup("channels.joinChannel", res);
      client.handleClientUpdate(res);
      return new Chat(res.chats[0]);
    });
  }
  function unbanChatMember(client, params) {
    return __async(this, null, function* () {
      const { chatId, participantId } = params;
      const chat = yield resolvePeer(client, chatId);
      const peer = yield resolvePeer(client, participantId);
      if (isInputPeerChannel(chat)) {
        const res = yield client.call({
          _: "channels.editBanned",
          channel: toInputChannel(chat),
          participant: peer,
          bannedRights: {
            _: "chatBannedRights",
            untilDate: 0
          }
        });
        client.handleClientUpdate(res);
      } else if (isInputPeerChat(chat))
        ;
      else {
        throw new MtInvalidPeerTypeError(chatId, "chat or channel");
      }
    });
  }
  function kickChatMember(client, params) {
    return __async(this, null, function* () {
      const { chatId, userId } = params;
      const chat = yield resolvePeer(client, chatId);
      const user = yield resolvePeer(client, userId);
      const msg = yield banChatMember(client, { chatId: chat, participantId: user });
      if (isInputPeerChannel(chat)) {
        yield sleepWithAbort(1e3, client.stopSignal);
        yield unbanChatMember(client, { chatId: chat, participantId: user });
      }
      return msg;
    });
  }
  function leaveChat(client, chatId, params) {
    return __async(this, null, function* () {
      const chat = yield resolvePeer(client, chatId);
      if (isInputPeerChannel(chat)) {
        const res = yield client.call({
          _: "channels.leaveChannel",
          channel: toInputChannel(chat)
        });
        client.handleClientUpdate(res);
      } else if (isInputPeerChat(chat)) {
        const res = yield client.call({
          _: "messages.deleteChatUser",
          chatId: chat.chatId,
          userId: { _: "inputUserSelf" }
        });
        client.handleClientUpdate(res);
        if (params == null ? void 0 : params.clear) {
          yield deleteHistory(client, chat);
        }
      } else {
        throw new MtInvalidPeerTypeError(chatId, "chat or channel");
      }
    });
  }
  function markChatUnread(client, chatId) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "messages.markDialogUnread",
        peer: {
          _: "inputDialogPeer",
          peer: yield resolvePeer(client, chatId)
        },
        unread: true
      });
      assertTrue("messages.markDialogUnread", r);
    });
  }
  function openChat(client, chat) {
    return __async(this, null, function* () {
      var _a2, _b;
      const peer = yield resolvePeer(client, chat);
      if (isInputPeerChannel(peer)) {
        let pts;
        if (!((_a2 = client.storage.self.getCached()) == null ? void 0 : _a2.isBot)) {
          const [dialog] = yield getPeerDialogs(client, peer);
          pts = dialog.raw.pts;
        } else {
          pts = (_b = yield client.storage.updates.getChannelPts(peer.channelId)) != null ? _b : void 0;
        }
        yield client.notifyChannelOpened(peer.channelId, pts);
      }
    });
  }
  function closeChat(client, chat) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, chat);
      if (isInputPeerChannel(peer)) {
        yield client.notifyChannelClosed(peer.channelId);
      }
    });
  }
  function reorderUsernames(client, peerId, order) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, peerId);
      if (isInputPeerUser(peer)) {
        if (isSelfPeer(client, peer)) {
          const r2 = yield client.call({
            _: "account.reorderUsernames",
            order
          });
          assertTrue("account.reorderUsernames", r2);
          return;
        }
        const r = yield client.call({
          _: "bots.reorderUsernames",
          bot: toInputUser(peer, peerId),
          order
        });
        assertTrue("bots.reorderUsernames", r);
      } else if (isInputPeerChannel(peer)) {
        const r = yield client.call({
          _: "channels.reorderUsernames",
          channel: toInputChannel(peer, peerId),
          order
        });
        assertTrue("channels.reorderUsernames", r);
      }
    });
  }
  function restrictChatMember(client, params) {
    return __async(this, null, function* () {
      var _a2;
      const { chatId, userId, restrictions, until = 0 } = params;
      const chat = yield resolvePeer(client, chatId);
      if (!isInputPeerChannel(chat)) {
        throw new MtInvalidPeerTypeError(chatId, "channel");
      }
      const user = yield resolvePeer(client, userId);
      const res = yield client.call({
        _: "channels.editBanned",
        channel: toInputChannel(chat),
        participant: user,
        bannedRights: __spreadValues({
          _: "chatBannedRights",
          untilDate: (_a2 = normalizeDate(until)) != null ? _a2 : 0
        }, restrictions)
      });
      client.handleClientUpdate(res);
    });
  }
  function saveDraft(client, chatId, draft) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, chatId);
      if (draft) {
        yield client.call(__spreadValues({
          _: "messages.saveDraft",
          peer
        }, draft));
      } else {
        yield client.call({
          _: "messages.saveDraft",
          peer,
          message: ""
        });
      }
    });
  }
  function setChatColor(client, params) {
    return __async(this, null, function* () {
      var _a2;
      const { color, backgroundEmojiId, forProfile } = params;
      const peer = yield resolvePeer(client, (_a2 = params.peer) != null ? _a2 : "me");
      if (isInputPeerChannel(peer)) {
        const res = yield client.call({
          _: "channels.updateColor",
          channel: toInputChannel(peer),
          color,
          backgroundEmojiId
        });
        client.handleClientUpdate(res);
        return;
      }
      if (isInputPeerUser(peer)) {
        if (!isSelfPeer(client, peer)) {
          throw new MtTypeAssertionError("setChatColor", "self", peer._);
        }
        const r = yield client.call({
          _: "account.updateColor",
          color,
          backgroundEmojiId,
          forProfile
        });
        assertTrue("account.updateColor", r);
      }
      throw new MtInvalidPeerTypeError(peer, "channel | user");
    });
  }
  function setChatDefaultPermissions(client, chatId, restrictions) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, chatId);
      const res = yield client.call({
        _: "messages.editChatDefaultBannedRights",
        peer,
        bannedRights: __spreadValues({
          _: "chatBannedRights",
          untilDate: 0
        }, restrictions)
      });
      assertIsUpdatesGroup("messages.editChatDefaultBannedRights", res);
      client.handleClientUpdate(res);
      return new Chat(res.chats[0]);
    });
  }
  function setChatDescription(client, chatId, description) {
    return __async(this, null, function* () {
      const chat = yield resolvePeer(client, chatId);
      const r = yield client.call({
        _: "messages.editChatAbout",
        peer: chat,
        about: description
      });
      assertTrue("messages.editChatAbout", r);
    });
  }
  function setChatPhoto(client, params) {
    return __async(this, null, function* () {
      const { chatId, type, media, previewSec } = params;
      const chat = yield resolvePeer(client, chatId);
      if (!(isInputPeerChannel(chat) || isInputPeerChat(chat))) {
        throw new MtInvalidPeerTypeError(chatId, "chat or channel");
      }
      let photo;
      let inputFile;
      if (typesInner.isFileIdLike(media)) {
        if (typeof media === "string" && media.match(/^https?:\/\//)) {
          throw new MtArgumentError("Chat photo can't be external");
        }
        if (typeof media === "string" && media.match(/^file:/)) {
          const uploaded = yield uploadFile(client, {
            file: media.substring(5)
          });
          inputFile = uploaded.inputFile;
        } else {
          const input = fileIdToInputPhoto(media);
          photo = {
            _: "inputChatPhoto",
            id: input
          };
        }
      } else if (typeof media === "object" && tl.tl.isAnyInputMedia(media)) {
        if (media._ === "inputMediaPhoto") {
          photo = {
            _: "inputChatPhoto",
            id: media.id
          };
        } else {
          throw new MtArgumentError("Chat photo can't be InputMedia");
        }
      } else if (isUploadedFile(media)) {
        inputFile = media.inputFile;
      } else if (typeof media === "object" && tl.tl.isAnyInputFile(media)) {
        inputFile = media;
      } else {
        const uploaded = yield uploadFile(client, {
          file: media
        });
        inputFile = uploaded.inputFile;
      }
      if (!photo) {
        photo = {
          _: "inputChatUploadedPhoto",
          [type === "photo" ? "file" : "video"]: inputFile,
          videoStartTs: previewSec
        };
      }
      let res;
      if (isInputPeerChat(chat)) {
        res = yield client.call({
          _: "messages.editChatPhoto",
          chatId: chat.chatId,
          photo
        });
      } else {
        res = yield client.call({
          _: "channels.editPhoto",
          channel: toInputChannel(chat),
          photo
        });
      }
      client.handleClientUpdate(res);
    });
  }
  function setChatTitle(client, chatId, title) {
    return __async(this, null, function* () {
      const chat = yield resolvePeer(client, chatId);
      let res;
      if (isInputPeerChat(chat)) {
        res = yield client.call({
          _: "messages.editChatTitle",
          chatId: chat.chatId,
          title
        });
      } else if (isInputPeerChannel(chat)) {
        res = yield client.call({
          _: "channels.editTitle",
          channel: toInputChannel(chat),
          title
        });
      } else {
        throw new MtInvalidPeerTypeError(chatId, "chat or channel");
      }
      client.handleClientUpdate(res);
    });
  }
  function setChatTtl(client, chatId, period) {
    return __async(this, null, function* () {
      yield client.call({
        _: "messages.setHistoryTTL",
        peer: yield resolvePeer(client, chatId),
        period
      });
    });
  }
  function setChatUsername(client, chatId, username) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "channels.updateUsername",
        channel: yield resolveChannel(client, chatId),
        username: username || ""
      });
      assertTrue("channels.updateUsername", r);
    });
  }
  function setSlowMode(client, chatId, seconds = 0) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "channels.toggleSlowMode",
        channel: yield resolveChannel(client, chatId),
        seconds
      });
      client.handleClientUpdate(res);
    });
  }
  function toggleContentProtection(client, chatId, enabled = false) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.toggleNoForwards",
        peer: yield resolvePeer(client, chatId),
        enabled
      });
      client.handleClientUpdate(res);
    });
  }
  function toggleFragmentUsername(client, params) {
    return __async(this, null, function* () {
      const { peerId, username, active } = params;
      const peer = yield resolvePeer(client, peerId);
      if (isInputPeerUser(peer)) {
        if (isSelfPeer(client, peer)) {
          const r2 = yield client.call({
            _: "account.toggleUsername",
            username,
            active
          });
          assertTrue("account.toggleUsername", r2);
          return;
        }
        const r = yield client.call({
          _: "bots.toggleUsername",
          bot: toInputUser(peer, peerId),
          username,
          active
        });
        assertTrue("bots.toggleUsername", r);
      } else if (isInputPeerChannel(peer)) {
        const r = yield client.call({
          _: "channels.toggleUsername",
          channel: toInputChannel(peer, peerId),
          username,
          active
        });
        assertTrue("channels.toggleUsername", r);
      }
    });
  }
  function toggleJoinRequests(client, chatId, enabled = false) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "channels.toggleJoinRequest",
        channel: yield resolveChannel(client, chatId),
        enabled
      });
      client.handleClientUpdate(res);
    });
  }
  function toggleJoinToSend(client, chatId, enabled = false) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "channels.toggleJoinToSend",
        channel: yield resolveChannel(client, chatId),
        enabled
      });
      client.handleClientUpdate(res);
    });
  }
  function unarchiveChats(client, chats) {
    return __async(this, null, function* () {
      if (!Array.isArray(chats))
        chats = [chats];
      const folderPeers = [];
      for(let   chat of chats) {
        folderPeers.push({
          _: "inputFolderPeer",
          peer: yield resolvePeer(client, chat),
          folderId: 0
        });
      }
      const res = yield client.call({
        _: "folders.editPeerFolders",
        folderPeers
      });
      client.handleClientUpdate(res);
    });
  }
  function addContact(client, params) {
    return __async(this, null, function* () {
      const { userId, firstName, lastName = "", phone = "", sharePhone = false } = params;
      const peer = yield resolveUser(client, userId);
      const res = yield client.call({
        _: "contacts.addContact",
        id: peer,
        firstName,
        lastName,
        phone,
        addPhonePrivacyException: sharePhone
      });
      assertIsUpdatesGroup("contacts.addContact", res);
      client.handleClientUpdate(res);
      return new User(res.users[0]);
    });
  }
  function deleteContacts(client, userIds) {
    return __async(this, null, function* () {
      if (!Array.isArray(userIds))
        userIds = [userIds];
      const inputPeers = yield resolvePeerMany(client, userIds, toInputUser);
      if (!inputPeers.length) {
        throw new MtInvalidPeerTypeError("all provided ids", "user");
      }
      const res = yield client.call({
        _: "contacts.deleteContacts",
        id: inputPeers
      });
      assertIsUpdatesGroup("contacts.deleteContacts", res);
      client.handleClientUpdate(res);
      return res.users.map((user) => new User(user));
    });
  }
  function getContacts(client) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "contacts.getContacts",
        hash: Long.ZERO
      });
      assertTypeIs("getContacts", res, "contacts.contacts");
      return res.users.map((user) => new User(user));
    });
  }
  function importContacts(client, contacts) {
    return __async(this, null, function* () {
      let seq = Long.ZERO;
      const contactsNorm = contacts.map((input) => __spreadValues({
        _: "inputPhoneContact",
        clientId: seq = seq.add(1)
      }, input));
      return client.call({
        _: "contacts.importContacts",
        contacts: contactsNorm
      });
    });
  }
  function getFolders(client) {
    return __async(this, null, function* () {
      return client.call({
        _: "messages.getDialogFilters"
      });
    });
  }
  function _normalizeInputFolder(client, folder) {
    return __async(this, null, function* () {
      if (typeof folder === "string" || typeof folder === "number") {
        const folders = yield getFolders(client);
        const found = folders.filters.find((it) => {
          if (it._ === "dialogFilterDefault") {
            return folder === 0;
          }
          return it.id === folder || it.title === folder;
        });
        if (!found) {
          throw new MtArgumentError(`Could not find folder ${folder}`);
        }
        return found;
      }
      return folder;
    });
  }
  function createFolder(client, folder) {
    return __async(this, null, function* () {
      let id2 = folder.id;
      if (!id2) {
        const old = yield getFolders(client);
        let max2 = 1;
        old.filters.forEach((it) => {
          if (it._ === "dialogFilter" && it.id > max2)
            max2 = it.id;
        });
        id2 = max2 + 1;
      }
      const filter = __spreadProps(__spreadValues({
        _: "dialogFilter",
        pinnedPeers: [],
        includePeers: [],
        excludePeers: []
      }, folder), {
        id: id2
      });
      const r = yield client.call({
        _: "messages.updateDialogFilter",
        id: id2,
        filter
      });
      assertTrue("messages.updateDialogFilter", r);
      return filter;
    });
  }
  function deleteFolder(client, id2) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "messages.updateDialogFilter",
        id: typeof id2 === "number" ? id2 : id2.id
      });
      assertTrue("messages.updateDialogFilter", r);
    });
  }
  function editFolder(client, params) {
    return __async(this, null, function* () {
      const { modification } = params;
      let { folder } = params;
      if (folder === 0) {
        throw new MtArgumentError("Cannot modify default folder");
      }
      if (typeof folder === "number" || typeof folder === "string") {
        const old = yield getFolders(client);
        const found = old.filters.find((it) => it._ === "dialogFilter" && (it.id === folder || it.title === folder));
        if (!found) {
          throw new MtArgumentError(`Could not find a folder ${folder}`);
        }
        folder = found;
      }
      const filter = __spreadValues(__spreadValues({}, folder), modification);
      const r = yield client.call({
        _: "messages.updateDialogFilter",
        id: folder.id,
        filter
      });
      assertTrue("messages.updateDialogFilter", r);
      return filter;
    });
  }
  function iterDialogs(client, params) {
    return __asyncGenerator(this, null, function* () {
      var _a2;
      if (!params)
        params = {};
      const { limit = Infinity, chunkSize = 100, folder, filter, pinned = "include" } = params;
      let { offsetId = 0, offsetPeer = { _: "inputPeerEmpty" }, archived = "exclude" } = params;
      let offsetDate = (_a2 = normalizeDate(params.offsetDate)) != null ? _a2 : 0;
      let localFilters_;
      if (folder) {
        localFilters_ = yield new __await(_normalizeInputFolder(client, folder));
      }
      if (filter) {
        if (localFilters_ && localFilters_._ !== "dialogFilterDefault") {
          localFilters_ = __spreadValues(__spreadValues({}, localFilters_), filter);
        } else {
          localFilters_ = __spreadValues({
            _: "dialogFilter",
            id: 0,
            title: "",
            pinnedPeers: [],
            includePeers: [],
            excludePeers: []
          }, params.filter);
        }
      }
      if ((localFilters_ == null ? void 0 : localFilters_._) === "dialogFilterDefault") {
        localFilters_ = void 0;
      }
      const localFilters = localFilters_;
      if ((localFilters == null ? void 0 : localFilters._) === "dialogFilterChatlist") {
        if (offsetId !== 0 || offsetDate !== 0 || offsetPeer._ !== "inputPeerEmpty") {
          throw new MtArgumentError("Cannot use offset parameters with chatlist filters");
        }
        let remaining = Math.min(limit, localFilters.includePeers.length + localFilters.pinnedPeers.length);
        if (pinned === "include" || pinned === "only") {
          const peers = [];
          for(let   peer of localFilters.pinnedPeers) {
            if (remaining <= 0)
              break;
            remaining--;
            peers.push({
              _: "inputDialogPeer",
              peer
            });
          }
          const res = yield new __await(client.call({
            _: "messages.getPeerDialogs",
            peers
          }));
          res.dialogs.forEach((dialog) => dialog.pinned = true);
          yield* __yieldStar(Dialog.parseTlDialogs(res));
        }
        if (pinned === "only" || remaining <= 0) {
          return;
        }
        let offset = 0;
        while (remaining > 0) {
          const peers = [];
          for (let i = 0; i < chunkSize; i++) {
            if (remaining <= 0)
              break;
            remaining--;
            peers.push({
              _: "inputDialogPeer",
              peer: localFilters.includePeers[offset + i]
            });
          }
          offset += chunkSize;
          const res = yield new __await(client.call({
            _: "messages.getPeerDialogs",
            peers
          }));
          yield* __yieldStar(Dialog.parseTlDialogs(res));
        }
        return;
      }
      if (localFilters) {
        archived = localFilters.excludeArchived ? "exclude" : "keep";
      }
      const fetchPinnedDialogsFromFolder = () => __async(this, null, function* () {
        if (!localFilters || !localFilters.pinnedPeers.length) {
          return null;
        }
        const res = yield client.call({
          _: "messages.getPeerDialogs",
          peers: localFilters.pinnedPeers.map((peer) => ({
            _: "inputDialogPeer",
            peer
          }))
        });
        res.dialogs.forEach((dialog) => dialog.pinned = true);
        return res;
      });
      if (pinned === "only") {
        let res;
        if (localFilters) {
          res = yield new __await(fetchPinnedDialogsFromFolder());
        } else {
          res = yield new __await(client.call({
            _: "messages.getPinnedDialogs",
            folderId: archived === "exclude" ? 0 : 1
          }));
        }
        if (res)
          yield* __yieldStar(Dialog.parseTlDialogs(res, limit));
        return;
      }
      let current = 0;
      if ((localFilters == null ? void 0 : localFilters.pinnedPeers.length) && pinned === "include" && offsetId === 0 && offsetDate === 0 && offsetPeer._ === "inputPeerEmpty") {
        const res = yield new __await(fetchPinnedDialogsFromFolder());
        if (res) {
          const dialogs = Dialog.parseTlDialogs(res, limit);
          for(let   d of dialogs) {
            yield d;
            if (++current >= limit)
              return;
          }
        }
      }
      const filterFolder = localFilters ? Dialog.filterFolder(localFilters, pinned !== "keep") : void 0;
      let folderId;
      if (archived === "keep") {
        folderId = void 0;
      } else if (archived === "only") {
        folderId = 1;
      } else {
        folderId = 0;
      }
      for (; ; ) {
        const dialogs = Dialog.parseTlDialogs(
          yield new __await(client.call({
            _: "messages.getDialogs",
            excludePinned: params.pinned === "exclude",
            folderId,
            offsetDate,
            offsetId,
            offsetPeer,
            limit: filterFolder ? chunkSize : Math.min(limit - current, chunkSize),
            hash: Long.ZERO
          }))
        );
        if (!dialogs.length)
          return;
        const last = dialogs[dialogs.length - 1];
        offsetPeer = last.chat.inputPeer;
        offsetId = last.raw.topMessage;
        if (last.lastMessage) {
          offsetDate = last.lastMessage.raw.date;
        }
        for(let   d of dialogs) {
          if (filterFolder && !filterFolder(d))
            continue;
          yield d;
          if (++current >= limit)
            return;
        }
      }
    });
  }
  function findDialogs(client, peers) {
    return __async(this, null, function* () {
      if (!Array.isArray(peers))
        peers = [peers];
      const resolved = yield resolvePeerMany(client, peers);
      const notFoundIds = /* @__PURE__ */ new Map();
      const notFoundUsernames = /* @__PURE__ */ new Map();
      let notFoundCount = 0;
      const foundInputPeers = [];
      const foundIdxToOriginalIdx = /* @__PURE__ */ new Map();
      for (let i = 0; i < peers.length; i++) {
        const input = peers[i];
        const resolvedPeer = resolved[i];
        if (!resolvedPeer) {
          if (typeof input === "number") {
            notFoundIds.set(input, i);
          } else {
            notFoundUsernames.set(input, i);
          }
          notFoundCount += 1;
          continue;
        }
        foundInputPeers.push(resolvedPeer);
        foundIdxToOriginalIdx.set(foundInputPeers.length - 1, i);
      }
      const ret = Array.from({ length: peers.length });
      if (foundInputPeers.length !== 0) {
        const dialogs = yield getPeerDialogs(client, foundInputPeers);
        if (foundInputPeers.length === peers.length) {
          return dialogs;
        }
        for(let   [idx, origIdx] of foundIdxToOriginalIdx) {
          ret[origIdx] = dialogs[idx];
        }
      }
      try {
        for (var iter = __forAwait(iterDialogs(client, {
          archived: "keep"
        })), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const dialog = temp.value;
          const chat = dialog.chat;
          const idxById = notFoundIds.get(chat.id);
          if (idxById !== void 0) {
            ret[idxById] = dialog;
            notFoundIds.delete(chat.id);
            notFoundCount -= 1;
          }
          if (notFoundCount === 0)
            break;
          if (!chat.username)
            continue;
          const idxByUsername = notFoundUsernames.get(chat.username);
          if (idxByUsername !== void 0) {
            ret[idxByUsername] = dialog;
            notFoundUsernames.delete(chat.username);
            notFoundCount -= 1;
          }
          if (notFoundCount === 0)
            break;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      if (notFoundCount > 0) {
        const notFound = [...notFoundIds.keys(), ...notFoundUsernames.keys()];
        throw new MtPeerNotFoundError(`Could not find dialogs with peers: ${notFound.join(", ")}`);
      }
      return ret;
    });
  }
  function findFolder(client, params) {
    return __async(this, null, function* () {
      var _a2;
      if (!params.title && !params.emoji && !params.id) {
        throw new MtArgumentError("One of search parameters must be passed");
      }
      const folders = yield getFolders(client);
      return (_a2 = folders.filters.find((it) => {
        if (it._ === "dialogFilterDefault")
          return false;
        if (params.id && it.id !== params.id)
          return false;
        if (params.title && it.title !== params.title)
          return false;
        if (params.emoji && it.emoticon !== params.emoji)
          return false;
        return true;
      })) != null ? _a2 : null;
    });
  }
  function getChatlistPreview(client, link) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "chatlists.checkChatlistInvite",
        slug: link
      });
      return new ChatlistPreview(res);
    });
  }
  function joinChatlist(client, link, params) {
    return __async(this, null, function* () {
      let peers;
      if (params == null ? void 0 : params.peers) {
        const inputs = Array.isArray(params.peers) ? params.peers : [params.peers];
        const all = yield resolvePeerMany(client, inputs);
        peers = all.filter(isPresent);
      } else {
        const preview = yield getChatlistPreview(client, link);
        peers = preview.chats.filter((it) => !it.isUnavailable).map((it) => it.inputPeer);
      }
      const res = yield client.call({
        _: "chatlists.joinChatlistInvite",
        slug: link,
        peers
      });
      assertIsUpdatesGroup("joinChatlist", res);
      client.handleClientUpdate(res);
      const filter = res.updates.find((it) => it._ === "updateDialogFilter");
      if (!(filter == null ? void 0 : filter.filter)) {
        throw new MtTypeAssertionError("joinChatlist", "updateDialogFilter", "nothing");
      }
      assertTypeIs("joinChatlist", filter.filter, "dialogFilterChatlist");
      return filter.filter;
    });
  }
  function setFoldersOrder(client, order) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "messages.updateDialogFiltersOrder",
        order
      });
      assertTrue("messages.updateDialogFiltersOrder", r);
    });
  }
  const SMALL_FILE_MAX_SIZE = 131072;
  const REQUESTS_PER_CONNECTION = 3;
  function downloadAsIterable(client, input, params) {
    return __asyncGenerator(this, null, function* () {
      var _a2, _b, _c, _d, _e;
      const offset = (_a2 = params == null ? void 0 : params.offset) != null ? _a2 : 0;
      if (offset % 4096 !== 0) {
        throw new MtArgumentError(`Invalid offset: ${offset}. Must be divisible by 4096`);
      }
      let dcId = params == null ? void 0 : params.dcId;
      let fileSize = params == null ? void 0 : params.fileSize;
      const abortSignal = params == null ? void 0 : params.abortSignal;
      let aborted = false;
      let location;
      if (input instanceof FileLocation) {
        let locationInner = input.location;
        if (typeof locationInner === "function") {
          locationInner = locationInner();
        }
        if (ArrayBuffer.isView(locationInner)) {
          yield locationInner;
          return;
        }
        if (!dcId)
          dcId = input.dcId;
        if (!fileSize)
          fileSize = input.fileSize;
        location = locationInner;
      } else if (typeof input === "string") {
        const parsed = parseFileId(getPlatform(), input);
        if (parsed.location._ === "web") {
          location = fileIdToInputWebFileLocation(parsed);
        } else {
          location = fileIdToInputFileLocation(parsed);
        }
      } else {
        location = input;
      }
      const isWeb = tl.tl.isAnyInputWebFileLocation(location);
      const primaryDcId = yield new __await(client.getPrimaryDcId());
      if (!dcId)
        dcId = primaryDcId;
      const partSizeKb = (_b = params == null ? void 0 : params.partSize) != null ? _b : fileSize ? determinePartSize(fileSize) : 64;
      if (partSizeKb % 4 !== 0) {
        throw new MtArgumentError(`Invalid part size: ${partSizeKb}. Must be divisible by 4.`);
      }
      const chunkSize = partSizeKb * 1024;
      let limitBytes = (_d = (_c = params == null ? void 0 : params.limit) != null ? _c : fileSize) != null ? _d : Infinity;
      if (limitBytes === 0)
        return;
      let numChunks = limitBytes === Infinity ? Infinity : ~~((limitBytes + chunkSize - offset - 1) / chunkSize);
      let nextChunkIdx = 0;
      let nextWorkerChunkIdx = 0;
      const nextChunkCv = new ConditionVariable();
      const buffer = {};
      const isSmall = fileSize && fileSize <= SMALL_FILE_MAX_SIZE;
      let connectionKind;
      if (isSmall) {
        connectionKind = dcId === primaryDcId ? "main" : "downloadSmall";
      } else {
        connectionKind = "download";
      }
      const poolSize = yield new __await(client.getPoolSize(connectionKind, dcId));
      client.log.debug(
        "Downloading file of size %d from dc %d using %s connection pool (pool size: %d)",
        limitBytes,
        dcId,
        connectionKind,
        poolSize
      );
      const downloadChunk = (..._0) => __async(this, [..._0], function* (chunk = nextWorkerChunkIdx++) {
        let result;
        if (aborted) {
          return;
        }
        try {
          result = yield client.call(
            {
              _: isWeb ? "upload.getWebFile" : "upload.getFile",
              // eslint-disable-next-line
              location,
              offset: chunkSize * chunk,
              limit: chunkSize
            },
            {
              dcId,
              kind: connectionKind,
              maxRetryCount: Infinity,
              // retry until explicitly aborted (or finished)
              abortSignal
            }
          );
        } catch (e) {
          if (e instanceof DOMException && e.name === "AbortError")
            return;
          if (!tl.tl.RpcError.is(e))
            throw e;
          if (e.is("FILE_MIGRATE_%d")) {
            dcId = e.newDc;
            return downloadChunk(chunk);
          } else if (e.is("FILEREF_UPGRADE_NEEDED")) {
            throw new MtUnsupportedError("File ref expired!");
          } else {
            throw e;
          }
        }
        if (result._ === "upload.fileCdnRedirect") {
          throw new MtUnsupportedError("Received CDN redirect, which is not supported (yet)");
        }
        if (aborted) {
          return;
        }
        if (result._ === "upload.webFile" && result.size && limitBytes === Infinity) {
          limitBytes = result.size;
          numChunks = ~~((limitBytes + chunkSize - offset - 1) / chunkSize);
        }
        buffer[chunk] = result.bytes;
        if (chunk === nextChunkIdx) {
          nextChunkCv.notify();
        }
        if (nextWorkerChunkIdx < numChunks && result.bytes.length === chunkSize) {
          return downloadChunk();
        }
      });
      let error;
      void Promise.all(Array.from({ length: Math.min(poolSize * REQUESTS_PER_CONNECTION, numChunks) }, downloadChunk)).catch((e) => {
        client.log.debug("download workers errored: %e", e);
        error = e;
        aborted = true;
        nextChunkCv.notify();
      }).then(() => {
        client.log.debug("download workers finished");
      });
      abortSignal == null ? void 0 : abortSignal.addEventListener("abort", () => {
        client.log.debug("download aborted");
        error = abortSignal.reason;
        aborted = true;
        nextChunkCv.notify();
      });
      let position = offset;
      while (position < limitBytes) {
        yield new __await(nextChunkCv.wait());
        if (error)
          throw error;
        while (nextChunkIdx in buffer) {
          const buf = buffer[nextChunkIdx];
          delete buffer[nextChunkIdx];
          position += buf.length;
          (_e = params == null ? void 0 : params.progressCallback) == null ? void 0 : _e.call(params, position, limitBytes);
          yield buf;
          nextChunkIdx++;
          if (buf.length < chunkSize) {
            return;
          }
        }
      }
    });
  }
  function downloadAsBuffer(client, location, params) {
    return __async(this, null, function* () {
      if (location instanceof FileLocation && ArrayBuffer.isView(location.location)) {
        return location.location;
      }
      const chunks = [];
      try {
        for (var iter = __forAwait(downloadAsIterable(client, location, params)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const chunk = temp.value;
          chunks.push(chunk);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return concatBuffers(chunks);
    });
  }
  function downloadAsStream(client, location, params) {
    if (location instanceof FileLocation && ArrayBuffer.isView(location.location)) {
      return bufferToStream(location.location);
    }
    const cancel = new AbortController();
    if (params == null ? void 0 : params.abortSignal) {
      params == null ? void 0 : params.abortSignal.addEventListener("abort", () => {
        cancel.abort();
      });
    }
    return new ReadableStream({
      start(controller) {
        (() => __async(this, null, function* () {
          try {
            for (var iter = __forAwait(downloadAsIterable(client, location, params)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const chunk = temp.value;
              controller.enqueue(chunk);
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          controller.close();
        }))().catch((e) => controller.error(e));
      },
      cancel() {
        cancel.abort();
      }
    });
  }
  function uploadMedia(_0, _1) {
    return __async(this, arguments, function* (client, media, params = {}) {
      const normMedia = yield _normalizeInputMedia(client, media, params, false);
      switch (normMedia._) {
        case "inputMediaEmpty":
        case "inputMediaGeoPoint":
        case "inputMediaGeoLive":
        case "inputMediaContact":
        case "inputMediaVenue":
        case "inputMediaGame":
        case "inputMediaInvoice":
        case "inputMediaPoll":
        case "inputMediaDice":
        case "inputMediaPaidMedia":
          throw new MtArgumentError("This media can't be uploaded");
      }
      const res = yield client.call({
        _: "messages.uploadMedia",
        peer: params.peer ? yield resolvePeer(client, params.peer) : {
          _: "inputPeerSelf"
        },
        media: normMedia
      });
      assertTypeIsNot("uploadMedia", res, "messageMediaEmpty");
      switch (normMedia._) {
        case "inputMediaUploadedPhoto":
        case "inputMediaPhoto":
        case "inputMediaPhotoExternal":
          assertTypeIs("uploadMedia", res, "messageMediaPhoto");
          assertTypeIs("uploadMedia", res.photo, "photo");
          return new Photo(res.photo);
        case "inputMediaUploadedDocument":
        case "inputMediaDocument":
        case "inputMediaDocumentExternal":
          assertTypeIs("uploadMedia", res, "messageMediaDocument");
          assertTypeIs("uploadMedia", res.document, "document");
          return parseDocument(res.document, res);
        case "inputMediaStory":
        case "inputMediaWebPage":
          throw new MtArgumentError(`This media (${normMedia._}) can't be uploaded`);
        default:
          assertNever$1();
      }
    });
  }
  function createForumTopic(client, params) {
    return __async(this, null, function* () {
      const { chatId, title, icon, sendAs, shouldDispatch } = params;
      const res = yield client.call({
        _: "channels.createForumTopic",
        channel: yield resolveChannel(client, chatId),
        title,
        iconColor: typeof icon === "number" ? icon : void 0,
        iconEmojiId: typeof icon !== "number" ? icon : void 0,
        sendAs: sendAs ? yield resolvePeer(client, sendAs) : void 0,
        randomId: randomLong()
      });
      return _findMessageInUpdate(client, res, false, !shouldDispatch);
    });
  }
  function deleteForumTopicHistory(client, chat, topicId, params) {
    return __async(this, null, function* () {
      const { shouldDispatch } = params != null ? params : {};
      const channel = yield resolveChannel(client, chat);
      assertTypeIsNot("deleteForumTopicHistory", channel, "inputChannelEmpty");
      const res = yield client.call({
        _: "channels.deleteTopicHistory",
        channel,
        topMsgId: typeof topicId === "number" ? topicId : topicId.id
      });
      if (!shouldDispatch) {
        client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, channel.channelId));
      }
    });
  }
  function editForumTopic(client, params) {
    return __async(this, null, function* () {
      const { chatId, topicId, title, icon, shouldDispatch } = params;
      const res = yield client.call({
        _: "channels.editForumTopic",
        channel: yield resolveChannel(client, chatId),
        topicId: typeof topicId === "number" ? topicId : topicId.id,
        title,
        iconEmojiId: icon ? icon != null ? icon : Long.ZERO : void 0
      });
      return _findMessageInUpdate(client, res, false, shouldDispatch);
    });
  }
  function getForumTopicsById(client, chatId, ids) {
    return __async(this, null, function* () {
      if (!Array.isArray(ids))
        ids = [ids];
      const res = yield client.call({
        _: "channels.getForumTopicsByID",
        channel: yield resolveChannel(client, chatId),
        topics: ids
      });
      return ForumTopic.parseTlForumTopics(res);
    });
  }
  const defaultOffset$3 = {
    date: 0,
    id: 0,
    topic: 0
  };
  function getForumTopics(client, chatId, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      const {
        query,
        offset: { date: offsetDate, id: offsetId, topic: offsetTopic } = defaultOffset$3,
        limit = 100
      } = params;
      const res = yield client.call({
        _: "channels.getForumTopics",
        channel: yield resolveChannel(client, chatId),
        q: query,
        offsetDate,
        offsetId,
        offsetTopic,
        limit
      });
      const topics = ForumTopic.parseTlForumTopics(res);
      const last = topics[topics.length - 1];
      const next = last ? {
        date: res.orderByCreateDate ? last.raw.date : last.lastMessage.raw.date,
        id: last.raw.topMessage,
        topic: last.raw.id
      } : void 0;
      return makeArrayPaginated(topics, res.count, next);
    });
  }
  function iterForumTopics(client, chatId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { query, limit = Infinity, chunkSize = 100 } = params;
      const peer = yield new __await(resolveChannel(client, chatId));
      let { offset } = params;
      let current = 0;
      for (; ; ) {
        const res = yield new __await(getForumTopics(client, peer, {
          query,
          offset,
          limit: Math.min(chunkSize, limit - current)
        }));
        for(let   topic of res) {
          yield topic;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
      }
    });
  }
  function reorderPinnedForumTopics(client, params) {
    return __async(this, null, function* () {
      const { chatId, order, force } = params;
      yield client.call({
        _: "channels.reorderPinnedForumTopics",
        channel: yield resolveChannel(client, chatId),
        order: order.map((it) => typeof it === "number" ? it : it.id),
        force
      });
    });
  }
  function toggleForumTopicClosed(client, parmas) {
    return __async(this, null, function* () {
      const { chatId, topicId, closed, shouldDispatch } = parmas;
      const res = yield client.call({
        _: "channels.editForumTopic",
        channel: yield resolveChannel(client, chatId),
        topicId: typeof topicId === "number" ? topicId : topicId.id,
        closed
      });
      return _findMessageInUpdate(client, res, false, shouldDispatch);
    });
  }
  function toggleForumTopicPinned(client, params) {
    return __async(this, null, function* () {
      const { chatId, topicId, pinned } = params;
      yield client.call({
        _: "channels.updatePinnedForumTopic",
        channel: yield resolveChannel(client, chatId),
        topicId: typeof topicId === "number" ? topicId : topicId.id,
        pinned
      });
    });
  }
  function toggleForum(client, chatId, enabled = false) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "channels.toggleForum",
        channel: yield resolveChannel(client, chatId),
        enabled
      });
      client.handleClientUpdate(res);
    });
  }
  function toggleGeneralTopicHidden(client, params) {
    return __async(this, null, function* () {
      const { chatId, hidden, shouldDispatch } = params;
      const res = yield client.call({
        _: "channels.editForumTopic",
        channel: yield resolveChannel(client, chatId),
        topicId: 1,
        hidden
      });
      return _findMessageInUpdate(client, res, false, shouldDispatch);
    });
  }
  function createInviteLink(client, chatId, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      const res = yield client.call({
        _: "messages.exportChatInvite",
        peer: yield resolvePeer(client, chatId),
        expireDate: normalizeDate(params.expires),
        usageLimit: params.usageLimit,
        requestNeeded: params.withApproval
      });
      return new ChatInviteLink(res);
    });
  }
  function editInviteLink(client, params) {
    return __async(this, null, function* () {
      const { chatId, link, expires, usageLimit, withApproval } = params;
      const res = yield client.call({
        _: "messages.editExportedChatInvite",
        peer: yield resolvePeer(client, chatId),
        link: typeof link === "string" ? link : link.link,
        expireDate: normalizeDate(expires),
        usageLimit,
        requestNeeded: withApproval
      });
      const peers = PeersIndex.from(res);
      return new ChatInviteLink(res.invite, peers);
    });
  }
  function exportInviteLink(client, chatId) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.exportChatInvite",
        peer: yield resolvePeer(client, chatId),
        legacyRevokePermanent: true
      });
      return new ChatInviteLink(res);
    });
  }
  function getInviteLinkMembers(client, chatId, params) {
    return __async(this, null, function* () {
      var _a2;
      const peer = yield resolvePeer(client, chatId);
      if (!params)
        params = {};
      const { limit = 100, link, requestedSearch, requested = Boolean(requestedSearch) } = params;
      const { offsetUser = { _: "inputUserEmpty" } } = params;
      const offsetDate = (_a2 = normalizeDate(params.offsetDate)) != null ? _a2 : 0;
      const res = yield client.call({
        _: "messages.getChatInviteImporters",
        limit,
        peer,
        link: typeof link === "string" ? link : link == null ? void 0 : link.link,
        requested,
        q: requestedSearch,
        offsetDate,
        offsetUser
      });
      const peers = PeersIndex.from(res);
      const members = res.importers.map((it) => new ChatInviteLinkMember(it, peers));
      const last = members[members.length - 1];
      const nextOffset = last ? {
        date: last.raw.date,
        user: toInputUser(last.user.inputPeer)
      } : void 0;
      return makeArrayPaginated(members, res.count, nextOffset);
    });
  }
  function getInviteLink(client, chatId, link) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.getExportedChatInvite",
        peer: yield resolvePeer(client, chatId),
        link
      });
      const peers = PeersIndex.from(res);
      return new ChatInviteLink(res.invite, peers);
    });
  }
  function getInviteLinks(client, chatId, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      const { revoked = false, limit = Infinity, admin, offset } = params;
      const res = yield client.call({
        _: "messages.getExportedChatInvites",
        peer: yield resolvePeer(client, chatId),
        revoked,
        adminId: admin ? yield resolveUser(client, admin) : { _: "inputUserSelf" },
        limit,
        offsetDate: offset == null ? void 0 : offset.date,
        offsetLink: offset == null ? void 0 : offset.link
      });
      const peers = PeersIndex.from(res);
      const links = res.invites.map((it) => new ChatInviteLink(it, peers));
      const last = links[links.length - 1];
      const nextOffset = last ? {
        date: last.raw.date,
        link: last.raw.link
      } : void 0;
      return makeArrayPaginated(links, res.count, nextOffset);
    });
  }
  function getPrimaryInviteLink(client, chatId) {
    return __async(this, null, function* () {
      var _a2, _b;
      const res = yield client.call({
        _: "messages.getExportedChatInvites",
        peer: yield resolvePeer(client, chatId),
        adminId: { _: "inputUserSelf" },
        limit: 1,
        revoked: false
      });
      if (((_a2 = res.invites[0]) == null ? void 0 : _a2._) !== "chatInviteExported") {
        throw new MtTypeAssertionError(
          "messages.getExportedChatInvites (@ .invites[0])",
          "chatInviteExported",
          (_b = res.invites[0]) == null ? void 0 : _b._
        );
      }
      if (!res.invites[0].permanent) {
        throw new MtTypeAssertionError("messages.getExportedChatInvites (@ .invites[0].permanent)", "true", "false");
      }
      const peers = PeersIndex.from(res);
      return new ChatInviteLink(res.invites[0], peers);
    });
  }
  function hideAllJoinRequests(client, params) {
    return __async(this, null, function* () {
      const { chatId, action, link } = params;
      yield client.call({
        _: "messages.hideAllChatJoinRequests",
        approved: action === "approve",
        peer: yield resolvePeer(client, chatId),
        link: typeof link === "string" ? link : link == null ? void 0 : link.link
      });
    });
  }
  function hideJoinRequest(client, params) {
    return __async(this, null, function* () {
      const { chatId, user, action } = params;
      const userId = yield resolveUser(client, user);
      yield client.call({
        _: "messages.hideChatJoinRequest",
        approved: action === "approve",
        peer: yield resolvePeer(client, chatId),
        userId
      });
    });
  }
  function iterInviteLinkMembers(client, chatId, params) {
    return __asyncGenerator(this, null, function* () {
      const peer = yield new __await(resolvePeer(client, chatId));
      if (!params)
        params = {};
      const { limit = Infinity, chunkSize = 100, link, requestedSearch, requested = Boolean(requestedSearch) } = params;
      let { offsetDate, offsetUser = { _: "inputUserEmpty" } } = params;
      let current = 0;
      for (; ; ) {
        const items = yield new __await(getInviteLinkMembers(client, peer, {
          limit: Math.min(chunkSize, limit - current),
          link,
          requested,
          requestedSearch,
          offsetDate,
          offsetUser
        }));
        if (!items.length)
          break;
        for(let   it of items) {
          yield it;
          if (++current >= limit)
            return;
        }
        if (!items.next)
          return;
        offsetDate = items.next.date;
        offsetUser = items.next.user;
      }
    });
  }
  function iterInviteLinks(client, chatId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { revoked = false, limit = Infinity, chunkSize = 100, admin } = params;
      let { offset } = params;
      let current = 0;
      const peer = yield new __await(resolvePeer(client, chatId));
      const adminResolved = admin ? yield new __await(resolvePeer(client, admin)) : { _: "inputUserSelf" };
      for (; ; ) {
        const links = yield new __await(getInviteLinks(client, peer, {
          admin: adminResolved,
          revoked,
          limit: Math.min(chunkSize, limit - current),
          offset
        }));
        if (!links.length)
          return;
        for(let   link of links) {
          yield link;
          if (++current >= limit)
            break;
        }
        if (!links.next)
          return;
        offset = links.next;
      }
    });
  }
  function revokeInviteLink(client, chatId, link) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.editExportedChatInvite",
        peer: yield resolvePeer(client, chatId),
        link: typeof link === "string" ? link : link.link,
        revoked: true
      });
      const peers = PeersIndex.from(res);
      const invite = res._ === "messages.exportedChatInviteReplaced" ? res.newInvite : res.invite;
      return new ChatInviteLink(invite, peers);
    });
  }
  function closePoll(client, params) {
    return __async(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const res = yield client.call({
        _: "messages.editMessage",
        peer: yield resolvePeer(client, chatId),
        id: message2,
        media: {
          _: "inputMediaPoll",
          poll: {
            _: "poll",
            id: Long.ZERO,
            closed: true,
            question: { _: "textWithEntities", text: "", entities: [] },
            answers: []
          }
        }
      });
      assertIsUpdatesGroup("messages.editMessage", res);
      client.handleClientUpdate(res, !params.shouldDispatch);
      const upd = res.updates[0];
      assertTypeIs("messages.editMessage (@ .updates[0])", upd, "updateMessagePoll");
      if (!upd.poll) {
        throw new MtTypeAssertionError("messages.editMessage (@ .updates[0].poll)", "poll", "undefined");
      }
      const peers = PeersIndex.from(res);
      return new Poll(upd.poll, peers, upd.results);
    });
  }
  function deleteScheduledMessages(client, chatId, ids) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, chatId);
      const res = yield client.call({
        _: "messages.deleteScheduledMessages",
        peer,
        id: ids
      });
      client.handleClientUpdate(res);
    });
  }
  function deleteMessagesById(client, chatId, ids, params) {
    return __async(this, null, function* () {
      const { revoke = true, shouldDispatch } = params != null ? params : {};
      const peer = yield resolvePeer(client, chatId);
      let upd;
      if (isInputPeerChannel(peer)) {
        const channel = toInputChannel(peer);
        const res = yield client.call({
          _: "channels.deleteMessages",
          channel,
          id: ids
        });
        upd = createDummyUpdate(res.pts, res.ptsCount, peer.channelId);
      } else {
        const res = yield client.call({
          _: "messages.deleteMessages",
          id: ids,
          revoke
        });
        upd = createDummyUpdate(res.pts, res.ptsCount);
      }
      if (!shouldDispatch) {
        client.handleClientUpdate(upd);
      }
    });
  }
  function deleteMessages(client, messages, params) {
    return __async(this, null, function* () {
      if (messages.length === 1) {
        return deleteMessagesById(client, messages[0].chat.inputPeer, [messages[0].id], params);
      }
      const byChat = /* @__PURE__ */ new Map();
      const byChatScheduled = /* @__PURE__ */ new Map();
      for(let   msg of messages) {
        const map = msg.isScheduled ? byChatScheduled : byChat;
        if (!map.has(msg.chat.id)) {
          map.set(msg.chat.id, [msg.chat.inputPeer, []]);
        }
        map.get(msg.chat.id)[1].push(msg.id);
      }
      for(let   [peer, ids] of byChat.values()) {
        yield deleteMessagesById(client, peer, ids, params);
      }
      for(let   [peer, ids] of byChatScheduled.values()) {
        yield deleteScheduledMessages(client, peer, ids);
      }
    });
  }
  function editInlineMessage(client, params) {
    return __async(this, null, function* () {
      let content;
      let entities;
      let media;
      const id2 = normalizeInlineId(params.messageId);
      if (params.media) {
        media = yield _normalizeInputMedia(client, params.media, params, true);
        if ("caption" in params.media && params.media.caption !== void 0) {
          [content, entities] = yield _normalizeInputText(client, params.media.caption);
        }
      } else if (params.text !== void 0) {
        [content, entities] = yield _normalizeInputText(client, params.text);
      }
      let retries = 3;
      while (retries--) {
        try {
          yield client.call(
            {
              _: "messages.editInlineBotMessage",
              id: id2,
              noWebpage: params.disableWebPreview,
              replyMarkup: _convertToTl$2(params.replyMarkup),
              message: content,
              entities,
              media,
              invertMedia: params.invertMedia
            },
            { dcId: id2.dcId }
          );
          return;
        } catch (e) {
          if (tl.tl.RpcError.is(e, "MEDIA_EMPTY")) {
            continue;
          }
          throw e;
        }
      }
    });
  }
  function editMessage(client, params) {
    return __async(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      let content;
      let entities;
      let media;
      if (params.media) {
        media = yield _normalizeInputMedia(client, params.media, params);
        if ("caption" in params.media && params.media.caption !== void 0) {
          [content, entities] = yield _normalizeInputText(client, params.media.caption);
        }
      }
      if (params.text !== void 0) {
        [content, entities] = yield _normalizeInputText(client, params.text);
      }
      const res = yield _maybeInvokeWithBusinessConnection(client, params.businessConnectionId, {
        _: "messages.editMessage",
        id: message2,
        peer: yield resolvePeer(client, chatId),
        noWebpage: params.disableWebPreview,
        replyMarkup: _convertToTl$2(params.replyMarkup),
        message: content,
        entities,
        media,
        invertMedia: params.invertMedia
      });
      return _findMessageInUpdate(client, res, true, !params.shouldDispatch);
    });
  }
  function forwardMessagesById(client, params) {
    return __async(this, null, function* () {
      const { messages, toChatId, fromChatId, silent, schedule, forbidForwards, sendAs, noAuthor, noCaption } = params;
      if (messages.length > 100) {
        throw new MtArgumentError("You can forward no more than 100 messages at once");
      }
      const toPeer = yield resolvePeer(client, toChatId);
      const res = yield client.call({
        _: "messages.forwardMessages",
        toPeer,
        fromPeer: yield resolvePeer(client, fromChatId),
        id: messages,
        silent,
        scheduleDate: normalizeDate(schedule),
        randomId: Array.from({ length: messages.length }, () => randomLong()),
        dropAuthor: noAuthor,
        dropMediaCaptions: noCaption,
        noforwards: forbidForwards,
        sendAs: sendAs ? yield resolvePeer(client, sendAs) : void 0,
        quickReplyShortcut: _normalizeQuickReplyShortcut(params.quickReply)
      });
      assertIsUpdatesGroup("messages.forwardMessages", res);
      client.handleClientUpdate(res, !params.shouldDispatch);
      const peers = PeersIndex.from(res);
      const forwarded = [];
      res.updates.forEach((upd) => {
        switch (upd._) {
          case "updateNewMessage":
          case "updateNewChannelMessage":
          case "updateNewScheduledMessage":
            forwarded.push(new Message(upd.message, peers, upd._ === "updateNewScheduledMessage"));
            break;
        }
      });
      return forwarded;
    });
  }
  function forwardMessages(client, params) {
    return __async(this, null, function* () {
      const _a2 = params, { messages } = _a2, rest = __objRest(_a2, ["messages"]);
      return forwardMessagesById(client, __spreadProps(__spreadValues({}, rest), {
        fromChatId: messages[0].chat.inputPeer,
        messages: messages.map((it) => it.id)
      }));
    });
  }
  function getAllScheduledMessages(client, chatId) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, chatId);
      const res = yield client.call({
        _: "messages.getScheduledHistory",
        peer,
        hash: Long.ZERO
      });
      assertTypeIsNot("getScheduledMessages", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      const ret = res.messages.map((msg) => {
        assertTypeIsNot("getScheduledMessages", msg, "messageEmpty");
        return new Message(msg, peers, true);
      });
      return ret;
    });
  }
  function getAvailableMessageEffects(client) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.getAvailableEffects",
        hash: 0
      });
      assertTypeIsNot("getAvailableMessageEffects", res, "messages.availableEffectsNotModified");
      const documentsMap = new LongMap();
      for(let   doc of res.documents) {
        if (doc._ !== "document")
          continue;
        documentsMap.set(doc.id, doc);
      }
      return res.effects.map((effect) => new MessageEffect(effect, documentsMap));
    });
  }
  function getCallbackQueryMessage(client, id2) {
    return __async(this, null, function* () {
      let msgId;
      let queryId;
      let peer;
      if ("_" in id2) {
        msgId = id2.msgId;
        queryId = id2.queryId;
        peer = yield resolvePeer(client, id2.peer);
      } else if ("raw" in id2) {
        msgId = id2.messageId;
        queryId = id2.id;
        peer = id2.chat.inputPeer;
      } else {
        msgId = id2.messageId;
        queryId = id2.queryId;
        peer = yield resolvePeer(client, id2.peer);
      }
      const inputMessage = {
        _: "inputMessageCallbackQuery",
        id: msgId,
        queryId
      };
      const isChannel = isInputPeerChannel(peer);
      const res = yield client.call(
        isChannel ? {
          _: "channels.getMessages",
          id: [inputMessage],
          channel: toInputChannel(peer)
        } : {
          _: "messages.getMessages",
          id: [inputMessage]
        }
      );
      assertTypeIsNot("getCallbackQueryMessage", res, "messages.messagesNotModified");
      if (res.messages[0]._ === "messageEmpty") {
        return null;
      }
      return new Message(res.messages[0], PeersIndex.from(res));
    });
  }
  function getFactCheck(client, chatId, msgIds) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.getFactCheck",
        peer: yield resolvePeer(client, chatId),
        msgId: Array.isArray(msgIds) ? msgIds : [msgIds]
      });
      return res.map((x) => {
        if (x.hash.isZero()) {
          return null;
        }
        return new FactCheck(x);
      });
    });
  }
  const defaultOffset$2 = {
    id: 0,
    date: 0
  };
  const defaultOffsetReverse = {
    id: 1,
    date: 0
  };
  function getHistory(client, chatId, params) {
    return __async(this, null, function* () {
      var _a2;
      if (!params)
        params = {};
      const {
        reverse = false,
        limit = 100,
        offset: { id: offsetId, date: offsetDate } = reverse ? defaultOffsetReverse : defaultOffset$2,
        addOffset = 0,
        minId = 0,
        maxId = 0
      } = params;
      const addOffsetAdjusted = addOffset + (reverse ? -limit : 0);
      const peer = yield resolvePeer(client, chatId);
      const res = yield client.call({
        _: "messages.getHistory",
        peer,
        offsetId,
        offsetDate,
        addOffset: addOffsetAdjusted,
        limit,
        maxId,
        minId,
        hash: Long.ZERO
      });
      assertTypeIsNot("getHistory", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
      if (reverse)
        msgs.reverse();
      const last = msgs[msgs.length - 1];
      const next = last ? {
        id: last.id + (reverse ? 1 : 0),
        date: last.raw.date
      } : void 0;
      return makeArrayPaginated(msgs, (_a2 = res.count) != null ? _a2 : msgs.length, next);
    });
  }
  function getMessageByLink(client, link) {
    return __async(this, null, function* () {
      const parsed = message.parse(link);
      if (!parsed) {
        throw new MtArgumentError(`Invalid message link: ${link}`);
      }
      let peer;
      if ("username" in parsed) {
        peer = yield resolvePeer(client, parsed.username);
      } else {
        peer = yield resolvePeer(client, toggleChannelIdMark(parsed.channelId));
      }
      let msgId = parsed.id;
      if (parsed.commentId) {
        [peer] = yield _getDiscussionMessage(client, peer, parsed.id);
        msgId = parsed.commentId;
      }
      const [msg] = yield getMessages(client, peer, msgId);
      return msg;
    });
  }
  function getMessageGroup(client, params) {
    return __async(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const peer = yield resolvePeer(client, chatId);
      const delta = isInputPeerChannel(peer) ? 9 : 19;
      const ids = [];
      for (let i = Math.max(message2 - delta, 0); i <= message2 + delta; i++) {
        ids.push(i);
      }
      const messages = yield getMessages(client, chatId, ids);
      const groupedId = messages.find((it) => (it == null ? void 0 : it.id) === message2).groupedId;
      if (!groupedId)
        throw new MtArgumentError("This message is not grouped");
      return messages.filter(isPresent).filter((it) => {
        var _a2;
        return (_a2 = it.groupedId) == null ? void 0 : _a2.eq(groupedId);
      });
    });
  }
  function getMessageReactionsById(client, chatId, messages) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.getMessagesReactions",
        peer: yield resolvePeer(client, chatId),
        id: messages
      });
      assertIsUpdatesGroup("messages.getMessagesReactions", res);
      client.handleClientUpdate(res);
      const index = {};
      const peers = PeersIndex.from(res);
      for(let   update of res.updates) {
        assertTypeIs("messages.getMessagesReactions", update, "updateMessageReactions");
        index[update.msgId] = new MessageReactions(update.msgId, getMarkedPeerId(update.peer), update.reactions, peers);
      }
      return messages.map((messageId) => {
        var _a2;
        return (_a2 = index[messageId]) != null ? _a2 : null;
      });
    });
  }
  function getMessageReactions(client, messages) {
    return __async(this, null, function* () {
      return getMessageReactionsById(
        client,
        messages[0].chat.inputPeer,
        messages.map((it) => it.id)
      );
    });
  }
  function getMessagesUnsafe(client, messageIds, fromReply = false) {
    return __async(this, null, function* () {
      if (!Array.isArray(messageIds))
        messageIds = [messageIds];
      const type = fromReply ? "inputMessageReplyTo" : "inputMessageID";
      const ids = messageIds.map((it) => ({
        _: type,
        id: it
      }));
      const res = yield client.call({
        _: "messages.getMessages",
        id: ids
      });
      assertTypeIsNot("getMessagesUnsafe", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      return res.messages.map((msg) => {
        if (msg._ === "messageEmpty")
          return null;
        return new Message(msg, peers);
      });
    });
  }
  function getReactionUsers(client, params) {
    return __async(this, null, function* () {
      const { limit = 100, offset, emoji } = params;
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const peer = yield resolvePeer(client, chatId);
      const reaction = normalizeInputReaction(emoji);
      const res = yield client.call({
        _: "messages.getMessageReactionsList",
        peer,
        id: message2,
        reaction,
        limit,
        offset
      });
      const peers = PeersIndex.from(res);
      return makeArrayPaginated(
        res.reactions.map((it) => new PeerReaction(it, peers)),
        res.count,
        res.nextOffset
      );
    });
  }
  function getReplyTo(client, message2) {
    return __async(this, null, function* () {
      var _a2;
      if (!((_a2 = message2.replyToMessage) == null ? void 0 : _a2.id)) {
        return null;
      }
      if (message2.raw.peerId._ === "peerChannel") {
        const [msg2] = yield getMessages(client, message2.chat.inputPeer, message2.id, true);
        return msg2;
      }
      const [msg] = yield getMessagesUnsafe(client, message2.id, true);
      return msg;
    });
  }
  function getScheduledMessages(client, chatId, messageIds) {
    return __async(this, null, function* () {
      const peer = yield resolvePeer(client, chatId);
      if (!Array.isArray(messageIds))
        messageIds = [messageIds];
      const res = yield client.call({
        _: "messages.getScheduledMessages",
        peer,
        id: messageIds
      });
      assertTypeIsNot("getScheduledMessages", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      const ret = res.messages.map((msg) => {
        if (msg._ === "messageEmpty")
          return null;
        return new Message(msg, peers, true);
      });
      return ret;
    });
  }
  function iterHistory(client, chatId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { limit = Infinity, chunkSize = 100, minId = 0, maxId = 0, reverse = false } = params;
      let { offset, addOffset = 0 } = params;
      let current = 0;
      const peer = yield new __await(resolvePeer(client, chatId));
      for (; ; ) {
        const res = yield new __await(getHistory(client, peer, {
          offset,
          addOffset,
          limit: Math.min(chunkSize, limit - current),
          maxId,
          minId,
          reverse
        }));
        for(let   msg of res) {
          yield msg;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
        addOffset = 0;
      }
    });
  }
  function iterReactionUsers(client, params) {
    return __asyncGenerator(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const peer = yield new __await(resolvePeer(client, chatId));
      const { limit = Infinity, chunkSize = 100 } = params;
      let current = 0;
      let { offset } = params;
      const reaction = normalizeInputReaction(params.emoji);
      for (; ; ) {
        const res = yield new __await(getReactionUsers(client, {
          chatId: peer,
          message: message2,
          emoji: reaction,
          limit: Math.min(chunkSize, limit - current),
          offset
        }));
        offset = res.next;
        for(let   reaction2 of res) {
          yield reaction2;
          if (++current >= limit)
            break;
        }
      }
    });
  }
  const defaultOffset$1 = {
    rate: 0,
    peer: { _: "inputPeerEmpty" },
    id: 0
  };
  function searchGlobal(client, params) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d;
      if (!params)
        params = {};
      const {
        query = "",
        filter = SearchFilters.Empty,
        limit = 100,
        offset: { rate: offsetRate, peer: offsetPeer, id: offsetId } = defaultOffset$1,
        onlyChannels
      } = params;
      const minDate = (_a2 = normalizeDate(params.minDate)) != null ? _a2 : 0;
      const maxDate = (_b = normalizeDate(params.maxDate)) != null ? _b : 0;
      const res = yield client.call({
        _: "messages.searchGlobal",
        q: query,
        filter,
        minDate,
        maxDate,
        offsetId,
        offsetRate,
        offsetPeer,
        limit,
        broadcastsOnly: onlyChannels
      });
      assertTypeIsNot("searchGlobal", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
      const last = msgs[msgs.length - 1];
      const next = last ? {
        rate: (_c = res.nextRate) != null ? _c : last.raw.date,
        peer: last.chat.inputPeer,
        id: last.id
      } : void 0;
      return makeArrayPaginated(msgs, (_d = res.count) != null ? _d : msgs.length, next);
    });
  }
  function iterSearchGlobal(client, params) {
    return __asyncGenerator(this, null, function* () {
      var _a2, _b;
      if (!params)
        params = {};
      const { query = "", filter = SearchFilters.Empty, limit = Infinity, chunkSize = 100, onlyChannels } = params;
      const minDate = (_a2 = normalizeDate(params.minDate)) != null ? _a2 : 0;
      const maxDate = (_b = normalizeDate(params.maxDate)) != null ? _b : 0;
      let { offset } = params;
      let current = 0;
      for (; ; ) {
        const res = yield new __await(searchGlobal(client, {
          query,
          filter,
          limit: Math.min(chunkSize, limit - current),
          minDate,
          maxDate,
          offset,
          onlyChannels
        }));
        if (!res.length)
          return;
        for(let   msg of res) {
          yield msg;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
      }
    });
  }
  function searchMessages(client, params) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      if (!params)
        params = {};
      const {
        query = "",
        chatId = { _: "inputPeerEmpty" },
        offset = 0,
        addOffset = 0,
        minId = 0,
        maxId = 0,
        threadId,
        limit = 100,
        filter = SearchFilters.Empty
      } = params;
      const minDate = (_a2 = normalizeDate(params.minDate)) != null ? _a2 : 0;
      const maxDate = (_b = normalizeDate(params.maxDate)) != null ? _b : 0;
      const peer = yield resolvePeer(client, chatId);
      const fromUser = params.fromUser ? yield resolvePeer(client, params.fromUser) : void 0;
      const res = yield client.call({
        _: "messages.search",
        peer,
        q: query,
        filter,
        minDate,
        maxDate,
        offsetId: offset,
        addOffset,
        limit,
        minId,
        maxId,
        fromId: fromUser,
        topMsgId: threadId,
        hash: Long.ZERO
      });
      assertTypeIsNot("searchMessages", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
      const last = msgs[msgs.length - 1];
      const next = last ? last.id : void 0;
      return makeArrayPaginated(msgs, (_c = res.count) != null ? _c : msgs.length, next);
    });
  }
  function iterSearchMessages(client, params) {
    return __asyncGenerator(this, null, function* () {
      var _a2, _b;
      if (!params)
        params = {};
      const {
        query = "",
        chatId = { _: "inputPeerEmpty" },
        minId = 0,
        maxId = 0,
        threadId,
        limit = Infinity,
        chunkSize = 100,
        filter = SearchFilters.Empty
      } = params;
      const minDate = (_a2 = normalizeDate(params.minDate)) != null ? _a2 : 0;
      const maxDate = (_b = normalizeDate(params.maxDate)) != null ? _b : 0;
      const peer = yield new __await(resolvePeer(client, chatId));
      const fromUser = params.fromUser ? yield new __await(resolvePeer(client, params.fromUser)) : void 0;
      let { offset, addOffset } = params;
      let current = 0;
      for (; ; ) {
        const res = yield new __await(searchMessages(client, {
          query,
          chatId: peer,
          offset,
          addOffset,
          minId,
          maxId,
          threadId,
          filter,
          fromUser,
          minDate,
          maxDate,
          limit: Math.min(chunkSize, limit - current)
        }));
        if (!res.length)
          break;
        for(let   msg of res) {
          yield msg;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          break;
        offset = res.next;
        addOffset = void 0;
      }
    });
  }
  function pinMessage(client, params) {
    return __async(this, null, function* () {
      const { notify, bothSides, shouldDispatch } = params != null ? params : {};
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const res = yield client.call({
        _: "messages.updatePinnedMessage",
        peer: yield resolvePeer(client, chatId),
        id: message2,
        silent: !notify,
        pmOneside: !bothSides
      });
      return _findMessageInUpdate(client, res, false, !shouldDispatch, true);
    });
  }
  function readReactions(client, chatId, params) {
    return __async(this, null, function* () {
      const { shouldDispatch } = params != null ? params : {};
      const res = yield client.call({
        _: "messages.readReactions",
        peer: yield resolvePeer(client, chatId)
      });
      if (!shouldDispatch) {
        client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
      }
    });
  }
  const defaultOffset = {
    rate: 0,
    peer: { _: "inputPeerEmpty" },
    id: 0
  };
  function searchHashtag(client, hashtag, params) {
    return __async(this, null, function* () {
      var _a2, _b;
      const { offset: { rate: offsetRate, peer: offsetPeer, id: offsetId } = defaultOffset, limit = 100 } = params != null ? params : {};
      const res = yield client.call({
        _: "channels.searchPosts",
        hashtag,
        offsetId,
        offsetRate,
        offsetPeer,
        limit
      });
      assertTypeIsNot("searchHashtag", res, "messages.messagesNotModified");
      const peers = PeersIndex.from(res);
      const msgs = res.messages.filter((msg) => msg._ !== "messageEmpty").map((msg) => new Message(msg, peers));
      const last = msgs[msgs.length - 1];
      const next = last ? {
        rate: (_a2 = res.nextRate) != null ? _a2 : last.raw.date,
        peer: last.chat.inputPeer,
        id: last.id
      } : void 0;
      return makeArrayPaginated(msgs, (_b = res.count) != null ? _b : msgs.length, next);
    });
  }
  function iterSearchHashtag(client, hashtag, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { limit = Infinity, chunkSize = 100 } = params;
      let { offset } = params;
      let current = 0;
      for (; ; ) {
        const res = yield new __await(searchHashtag(client, hashtag, {
          offset,
          limit: Math.min(chunkSize, limit - current)
        }));
        if (!res.length)
          return;
        for(let   msg of res) {
          yield msg;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
      }
    });
  }
  function answerText(client, message2, ...params) {
    var _a2;
    if (!message2.isTopicMessage || !((_a2 = message2.replyToMessage) == null ? void 0 : _a2.threadId)) {
      return sendText(client, message2.chat.inputPeer, ...params);
    }
    const [text, params_ = {}] = params;
    params_.replyTo = message2.replyToMessage.threadId;
    return sendText(client, message2.chat.inputPeer, text, params_);
  }
  function answerMedia(client, message2, ...params) {
    var _a2;
    if (!message2.isTopicMessage || !((_a2 = message2.replyToMessage) == null ? void 0 : _a2.threadId)) {
      return sendMedia(client, message2.chat.inputPeer, ...params);
    }
    const [media, params_ = {}] = params;
    params_.replyTo = message2.replyToMessage.threadId;
    return sendMedia(client, message2.chat.inputPeer, media, params_);
  }
  function answerMediaGroup(client, message2, ...params) {
    var _a2;
    if (!message2.isTopicMessage || !((_a2 = message2.replyToMessage) == null ? void 0 : _a2.threadId)) {
      return sendMediaGroup(client, message2.chat.inputPeer, ...params);
    }
    const [media, params_ = {}] = params;
    params_.replyTo = message2.replyToMessage.threadId;
    return sendMediaGroup(client, message2.chat.inputPeer, media, params_);
  }
  function replyText(client, message2, ...params) {
    const [text, params_ = {}] = params;
    params_.replyTo = message2.id;
    return sendText(client, message2.chat.inputPeer, text, params_);
  }
  function replyMedia(client, message2, ...params) {
    const [media, params_ = {}] = params;
    params_.replyTo = message2.id;
    return sendMedia(client, message2.chat.inputPeer, media, params_);
  }
  function replyMediaGroup(client, message2, ...params) {
    const [media, params_ = {}] = params;
    params_.replyTo = message2.id;
    return sendMediaGroup(client, message2.chat.inputPeer, media, params_);
  }
  function commentText(client, message2, ...params) {
    if (message2.chat.chatType !== "channel") {
      return replyText(client, message2, ...params);
    }
    if (!message2.replies || !message2.replies.hasComments) {
      throw new MtArgumentError("This message does not have comments section");
    }
    const [text, params_ = {}] = params;
    params_.commentTo = message2.id;
    return sendText(client, message2.chat.inputPeer, text, params_);
  }
  function commentMedia(client, message2, ...params) {
    if (message2.chat.chatType !== "channel") {
      return replyMedia(client, message2, ...params);
    }
    if (!message2.replies || !message2.replies.hasComments) {
      throw new MtArgumentError("This message does not have comments section");
    }
    const [media, params_ = {}] = params;
    params_.commentTo = message2.id;
    return sendMedia(client, message2.chat.inputPeer, media, params_);
  }
  function commentMediaGroup(client, message2, ...params) {
    if (message2.chat.chatType !== "channel") {
      return replyMediaGroup(client, message2, ...params);
    }
    if (!message2.replies || !message2.replies.hasComments) {
      throw new MtArgumentError("This message does not have comments section");
    }
    const [media, params_ = {}] = params;
    params_.commentTo = message2.id;
    return sendMediaGroup(client, message2.chat.inputPeer, media, params_);
  }
  function sendCopyGroup(client, params) {
    return __async(this, null, function* () {
      var _b;
      const _a2 = params, { toChatId } = _a2, rest = __objRest(_a2, ["toChatId"]);
      let msgs;
      if ("fromChatId" in params) {
        const fromPeer = yield resolvePeer(client, params.fromChatId);
        msgs = yield getMessages(client, fromPeer, params.messages).then((r) => r.filter(isPresent));
      } else {
        msgs = params.messages;
      }
      const messageGroupId = msgs[0].groupedId;
      for (let i = 1; i < msgs.length; i++) {
        if (!((_b = msgs[i].groupedId) == null ? void 0 : _b.eq(messageGroupId)) || !msgs[i].media) {
          throw new MtArgumentError("All messages must be in the same message group");
        }
      }
      return sendMediaGroup(
        client,
        toChatId,
        msgs.map((msg) => {
          const raw = msg.raw;
          return {
            type: "auto",
            file: msg.media.inputMedia,
            caption: raw.message,
            entities: raw.entities
          };
        }),
        rest
      );
    });
  }
  function sendCopy(client, params) {
    return __async(this, null, function* () {
      var _b;
      const _a2 = params, { toChatId } = _a2, rest = __objRest(_a2, ["toChatId"]);
      let msg;
      if ("fromChatId" in params) {
        const fromPeer = yield resolvePeer(client, params.fromChatId);
        [msg] = yield getMessages(client, fromPeer, params.message);
        if (!msg) {
          throw new MtMessageNotFoundError(getMarkedPeerId(fromPeer), params.message, "to copy");
        }
      } else {
        msg = params.message;
      }
      if (msg.raw._ === "messageService") {
        throw new MtArgumentError("Service messages can't be copied");
      }
      if (msg.media && msg.media.type !== "webpage" && msg.media.type !== "invoice") {
        let caption = params.caption;
        if (!caption) {
          if ((_b = msg.raw.entities) == null ? void 0 : _b.length) {
            caption = {
              text: msg.raw.message,
              entities: msg.raw.entities
            };
          } else {
            caption = msg.raw.message;
          }
        }
        return sendMedia(
          client,
          toChatId,
          {
            type: "auto",
            file: msg.media.inputMedia,
            caption
          },
          rest
        );
      }
      return sendText(client, toChatId, msg.raw.message, rest);
    });
  }
  function sendPaidReaction(client, params) {
    return __async(this, null, function* () {
      const { anonymous, count = 1 } = params;
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const peer = yield resolvePeer(client, chatId);
      let res;
      for (let i = 0; i < 3; i++) {
        try {
          res = yield client.call({
            _: "messages.sendPaidReaction",
            peer,
            msgId: message2,
            count,
            private: anonymous,
            randomId: yield client.getMtprotoMessageId()
          });
          break;
        } catch (e) {
          if (tl.tl.RpcError.is(e, "RANDOM_ID_EXPIRED")) {
            continue;
          }
          throw e;
        }
      }
      if (!res) {
        throw new MtcuteError("Could not send paid reaction");
      }
      assertIsUpdatesGroup("messages.sendReaction", res);
      const peers = PeersIndex.from(res);
      const upd = res.updates[0];
      assertTypeIs("messages.sendPaidReaction (@ .updates[0])", upd, "updateMessageReactions");
      return new MessageReactions(upd.msgId, getMarkedPeerId(upd.peer), upd.reactions, peers);
    });
  }
  function extractQuote(message2, from, to) {
    const { raw } = message2;
    if (raw._ === "messageService")
      throw new MtArgumentError("Cannot quote service message");
    if (!raw.message)
      throw new MtArgumentError("Cannot quote empty message");
    const text = raw.message;
    if (from < 0)
      from = 0;
    if (to > text.length)
      to = text.length;
    if (from >= to)
      throw new MtArgumentError("Invalid quote range");
    if (!raw.entities)
      return { text: text.slice(from, to), entities: void 0 };
    const entities = [];
    for(let   ent of raw.entities) {
      const start2 = ent.offset;
      const end = ent.offset + ent.length;
      if (start2 >= to || end <= from)
        continue;
      const newStart = Math.max(start2, from) - from;
      const newEnd = Math.min(end, to) - from;
      const newEnt = __spreadProps(__spreadValues({}, ent), { offset: newStart, length: newEnd - newStart });
      entities.push(newEnt);
    }
    return { text: text.slice(from, to), entities };
  }
  function quoteWithText(client, message2, params) {
    const _a2 = params, { toChatId = message2.chat, start: start2, end, text } = _a2, params__ = __objRest(_a2, ["toChatId", "start", "end", "text"]);
    const params_ = params__;
    params_.replyTo = message2;
    params_.quote = extractQuote(message2, params.start, params.end);
    params_.quoteOffset = params.start;
    return sendText(client, toChatId, text, params_);
  }
  function quoteWithMedia(client, message2, params) {
    const _a2 = params, { toChatId = message2.chat, start: start2, end, media } = _a2, params__ = __objRest(_a2, ["toChatId", "start", "end", "media"]);
    const params_ = params__;
    params_.replyTo = message2;
    params_.quote = extractQuote(message2, params.start, params.end);
    params_.quoteOffset = params.start;
    return sendMedia(client, toChatId, media, params_);
  }
  function quoteWithMediaGroup(client, message2, params) {
    const _a2 = params, { toChatId, start: start2, end, medias } = _a2, params__ = __objRest(_a2, ["toChatId", "start", "end", "medias"]);
    const params_ = params__;
    params_.replyTo = message2;
    params_.quote = extractQuote(message2, params.start, params.end);
    params_.quoteOffset = params.start;
    return sendMediaGroup(client, message2.chat.inputPeer, medias, params_);
  }
  function sendReaction(client, params) {
    return __async(this, null, function* () {
      const { emoji, big } = params;
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const emojis = Array.isArray(emoji) ? emoji : [emoji];
      const reactions = emojis.map(normalizeInputReaction);
      const res = yield client.call({
        _: "messages.sendReaction",
        peer: yield resolvePeer(client, chatId),
        msgId: message2,
        reaction: reactions,
        big
      });
      assertIsUpdatesGroup("messages.sendReaction", res);
      return _findMessageInUpdate(client, res, true, !params.shouldDispatch, true);
    });
  }
  function sendScheduled(client, peer, ids) {
    return __async(this, null, function* () {
      if (!Array.isArray(ids))
        ids = [ids];
      const res = yield client.call({
        _: "messages.sendScheduledMessages",
        peer: yield resolvePeer(client, peer),
        id: ids
      });
      assertIsUpdatesGroup("sendScheduled", res);
      client.handleClientUpdate(res, true);
      const peers = PeersIndex.from(res);
      const msgs = res.updates.filter(
        (u) => u._ === "updateNewMessage" || u._ === "updateNewChannelMessage"
      ).map((u) => new Message(u.message, peers));
      return msgs;
    });
  }
  function sendTyping(client, chatId, status = "typing", params) {
    return __async(this, null, function* () {
      var _a2;
      if (typeof status === "string") {
        const progress = (_a2 = params == null ? void 0 : params.progress) != null ? _a2 : 0;
        switch (status) {
          case "typing":
            status = { _: "sendMessageTypingAction" };
            break;
          case "cancel":
            status = { _: "sendMessageCancelAction" };
            break;
          case "record_video":
            status = { _: "sendMessageRecordVideoAction" };
            break;
          case "upload_video":
            status = { _: "sendMessageUploadVideoAction", progress };
            break;
          case "record_voice":
            status = { _: "sendMessageRecordAudioAction" };
            break;
          case "upload_voice":
            status = { _: "sendMessageUploadAudioAction", progress };
            break;
          case "upload_photo":
            status = { _: "sendMessageUploadPhotoAction", progress };
            break;
          case "upload_document":
            status = { _: "sendMessageUploadDocumentAction", progress };
            break;
          case "geo":
            status = { _: "sendMessageGeoLocationAction" };
            break;
          case "contact":
            status = { _: "sendMessageChooseContactAction" };
            break;
          case "game":
            status = { _: "sendMessageGamePlayAction" };
            break;
          case "record_round":
            status = { _: "sendMessageRecordRoundAction" };
            break;
          case "upload_round":
            status = { _: "sendMessageUploadRoundAction", progress };
            break;
          case "speak_call":
            status = { _: "speakingInGroupCallAction" };
            break;
          case "history_import":
            status = { _: "sendMessageHistoryImportAction", progress };
            break;
          case "sticker":
            status = { _: "sendMessageChooseStickerAction" };
            break;
          default:
            assertNever$1();
        }
      }
      const r = yield _maybeInvokeWithBusinessConnection(client, params == null ? void 0 : params.businessConnectionId, {
        _: "messages.setTyping",
        peer: yield resolvePeer(client, chatId),
        action: status,
        topMsgId: params == null ? void 0 : params.threadId
      });
      assertTrue("messages.setTyping", r);
    });
  }
  function sendVote(client, params) {
    return __async(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      let { options } = params;
      if (options === null)
        options = [];
      if (!Array.isArray(options))
        options = [options];
      const peer = yield resolvePeer(client, chatId);
      let poll;
      if (options.some((it) => typeof it === "number")) {
        const [msg] = yield getMessages(client, peer, message2);
        if (!msg) {
          throw new MtMessageNotFoundError(getMarkedPeerId(peer), message2, "to vote in");
        }
        if (!(msg.media instanceof Poll)) {
          throw new MtArgumentError("This message does not contain a poll");
        }
        poll = msg.media;
        options = options.map((opt) => {
          if (typeof opt === "number") {
            return poll.raw.answers[opt].option;
          }
          return opt;
        });
      }
      const res = yield client.call({
        _: "messages.sendVote",
        peer,
        msgId: message2,
        options
      });
      assertIsUpdatesGroup("messages.sendVote", res);
      client.handleClientUpdate(res, true);
      const upd = res.updates[0];
      assertTypeIs("messages.sendVote (@ .updates[0])", upd, "updateMessagePoll");
      if (!upd.poll) {
        throw new MtTypeAssertionError("messages.sendVote (@ .updates[0].poll)", "poll", "undefined");
      }
      const peers = PeersIndex.from(res);
      return new Poll(upd.poll, peers, upd.results);
    });
  }
  function translateMessage(client, params) {
    return __async(this, null, function* () {
      const { toLanguage } = params;
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const res = yield client.call({
        _: "messages.translateText",
        peer: yield resolvePeer(client, chatId),
        id: [message2],
        toLang: toLanguage
      });
      return {
        text: res.result[0].text,
        entities: res.result[0].entities
      };
    });
  }
  function translateText(client, text, toLanguage) {
    return __async(this, null, function* () {
      const [message2, entities] = yield _normalizeInputText(client, text);
      const res = yield client.call({
        _: "messages.translateText",
        text: [
          {
            _: "textWithEntities",
            text: message2,
            entities: entities || []
          }
        ],
        toLang: toLanguage
      });
      if (!res.result[0]) {
        throw new MtTypeAssertionError("messages.translateResult#result", "not empty", "empty");
      }
      return {
        text: res.result[0].text,
        entities: res.result[0].entities
      };
    });
  }
  function unpinAllMessages(client, chatId, params) {
    return __async(this, null, function* () {
      const { topicId, shouldDispatch } = params != null ? params : {};
      const peer = yield resolvePeer(client, chatId);
      const res = yield client.call({
        _: "messages.unpinAllMessages",
        peer,
        topMsgId: topicId
      });
      if (!shouldDispatch) {
        if (isInputPeerChannel(peer)) {
          client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount, peer.channelId));
        } else {
          client.handleClientUpdate(createDummyUpdate(res.pts, res.ptsCount));
        }
      }
    });
  }
  function unpinMessage(client, params) {
    return __async(this, null, function* () {
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const res = yield client.call({
        _: "messages.updatePinnedMessage",
        peer: yield resolvePeer(client, chatId),
        id: message2,
        unpin: true
      });
      client.handleClientUpdate(res);
    });
  }
  function getCollectibleInfo(client, kind, item) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "fragment.getCollectibleInfo",
        collectible: kind === "phone" ? {
          _: "inputCollectiblePhone",
          phone: normalizePhoneNumber(item)
        } : {
          _: "inputCollectibleUsername",
          username: item
        }
      });
      return new CollectibleInfo(res);
    });
  }
  function initTakeoutSession(client, params) {
    return __async(this, null, function* () {
      return new TakeoutSession(
        client,
        yield client.call(__spreadValues({
          _: "account.initTakeoutSession"
        }, params))
      );
    });
  }
  function _normalizePrivacyRules(client, rules) {
    return __async(this, null, function* () {
      const res = [];
      for(let   rule of rules) {
        if ("_" in rule) {
          res.push(rule);
          continue;
        }
        if ("users" in rule) {
          const users = yield resolvePeerMany(client, rule.users, toInputUser);
          res.push({
            _: rule.allow ? "inputPrivacyValueAllowUsers" : "inputPrivacyValueDisallowUsers",
            users
          });
          continue;
        }
        if ("chats" in rule) {
          const chats = yield resolvePeerMany(client, rule.chats);
          res.push({
            _: rule.allow ? "inputPrivacyValueAllowChatParticipants" : "inputPrivacyValueDisallowChatParticipants",
            chats: chats.filter(isPresent).map((peer) => {
              if ("channelId" in peer)
                return peer.channelId;
              if ("chatId" in peer)
                return peer.chatId;
              throw new Error("UNREACHABLE");
            })
          });
          continue;
        }
      }
      return res;
    });
  }
  function changeCloudPassword(client, params) {
    return __async(this, null, function* () {
      const { currentPassword, newPassword, hint } = params;
      const pwd = yield client.call({ _: "account.getPassword" });
      if (!pwd.hasPassword) {
        throw new MtArgumentError("Cloud password is not enabled");
      }
      const algo = pwd.newAlgo;
      const oldSrp = yield client.computeSrpParams(pwd, currentPassword);
      const newHash = yield client.computeNewPasswordHash(algo, newPassword);
      yield client.call({
        _: "account.updatePasswordSettings",
        password: oldSrp,
        newSettings: {
          _: "account.passwordInputSettings",
          newAlgo: algo,
          newPasswordHash: newHash,
          hint
        }
      });
    });
  }
  function enableCloudPassword(client, params) {
    return __async(this, null, function* () {
      const { password, hint, email } = params;
      const pwd = yield client.call({ _: "account.getPassword" });
      if (pwd.hasPassword) {
        throw new MtArgumentError("Cloud password is already enabled");
      }
      const algo = pwd.newAlgo;
      assertTypeIs("account.getPassword", algo, "passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow");
      const newHash = yield client.computeNewPasswordHash(algo, password);
      yield client.call({
        _: "account.updatePasswordSettings",
        password: { _: "inputCheckPasswordEmpty" },
        newSettings: {
          _: "account.passwordInputSettings",
          newAlgo: algo,
          newPasswordHash: newHash,
          hint,
          email
        }
      });
    });
  }
  function verifyPasswordEmail(client, code2) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "account.confirmPasswordEmail",
        code: code2
      });
      assertTrue("account.confirmPasswordEmail", r);
    });
  }
  function resendPasswordEmail(client) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "account.resendPasswordEmail"
      });
      assertTrue("account.resendPasswordEmail", r);
    });
  }
  function cancelPasswordEmail(client) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "account.cancelPasswordEmail"
      });
      assertTrue("account.cancelPasswordEmail", r);
    });
  }
  function removeCloudPassword(client, password) {
    return __async(this, null, function* () {
      const pwd = yield client.call({ _: "account.getPassword" });
      if (!pwd.hasPassword) {
        throw new MtArgumentError("Cloud password is not enabled");
      }
      const oldSrp = yield client.computeSrpParams(pwd, password);
      yield client.call({
        _: "account.updatePasswordSettings",
        password: oldSrp,
        newSettings: {
          _: "account.passwordInputSettings",
          newAlgo: { _: "passwordKdfAlgoUnknown" },
          newPasswordHash: new Uint8Array(0),
          hint: ""
        }
      });
    });
  }
  function acceptStarGift(client, params) {
    return __async(this, null, function* () {
      const { action } = params;
      const { chatId, message: message2 } = normalizeInputMessageId(params);
      const userId = yield resolveUser(client, chatId);
      return client.call(
        action === "convert" ? {
          _: "payments.convertStarGift",
          userId,
          msgId: message2
        } : {
          _: "payments.saveStarGift",
          unsave: action === "hide",
          userId,
          msgId: message2
        }
      );
    });
  }
  function applyBoost(client, peerId) {
    return __async(this, null, function* () {
      yield client.call({
        _: "premium.applyBoost",
        peer: yield resolvePeer(client, peerId)
      });
    });
  }
  function getMyBoostSlots(client) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "premium.getMyBoosts"
      });
      const peers = PeersIndex.from(res);
      return res.myBoosts.map((it) => new BoostSlot(it, peers));
    });
  }
  function canApplyBoost(client) {
    return __async(this, null, function* () {
      const myBoosts = yield getMyBoostSlots(client);
      if (!myBoosts.length) {
        return { can: false, reason: "need_premium", slots: myBoosts };
      }
      const emptySlots = myBoosts.filter((it) => !it.occupied);
      if (emptySlots.length > 0) {
        return { can: true, slots: myBoosts };
      }
      const replaceableSlots = myBoosts.filter((it) => it.cooldownUntil === null);
      if (replaceableSlots.length) {
        return { can: true, replace: replaceableSlots.map((it) => it.chat), slots: myBoosts };
      }
      return { can: false, reason: "no_slots", slots: myBoosts };
    });
  }
  function createBusinessChatLink(client, text, params) {
    return __async(this, null, function* () {
      const [message2, entities] = yield _normalizeInputText(client, text);
      const res = yield client.call({
        _: "account.createBusinessChatLink",
        link: {
          _: "inputBusinessChatLink",
          message: message2,
          entities,
          title: params == null ? void 0 : params.title
        }
      });
      return new BusinessChatLink(res);
    });
  }
  function editBusinessChatLink(client, link, params) {
    return __async(this, null, function* () {
      const [message2, entities] = yield _normalizeInputText(client, params.text);
      const res = yield client.call({
        _: "account.editBusinessChatLink",
        slug: link instanceof BusinessChatLink ? link.link : link,
        link: {
          _: "inputBusinessChatLink",
          message: message2,
          entities,
          title: params == null ? void 0 : params.title
        }
      });
      return new BusinessChatLink(res);
    });
  }
  function deleteBusinessChatLink(client, link) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "account.deleteBusinessChatLink",
        slug: typeof link === "string" ? link : link.link
      });
      assertTrue("account.deleteBusinessChatLink", res);
    });
  }
  function getBoostStats(client, peerId) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "premium.getBoostsStatus",
        peer: yield resolvePeer(client, peerId)
      });
      return new BoostStats(res);
    });
  }
  function getBoosts(client, peerId, params) {
    return __async(this, null, function* () {
      const { offset = "", limit = 100 } = params != null ? params : {};
      const res = yield client.call({
        _: "premium.getBoostsList",
        peer: yield resolvePeer(client, peerId),
        offset,
        limit
      });
      const peers = PeersIndex.from(res);
      return makeArrayPaginated(
        res.boosts.map((it) => new Boost(it, peers)),
        res.count,
        res.nextOffset
      );
    });
  }
  function getBusinessChatLinks(client) {
    return __async(this, null, function* () {
      const res = yield client.call({ _: "account.getBusinessChatLinks" });
      return res.links.map((x) => new BusinessChatLink(x));
    });
  }
  function getStarGiftOptions(client) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "payments.getStarGifts",
        hash: 0
      });
      assertTypeIsNot("payments.getStarGifts", res, "payments.starGiftsNotModified");
      return res.gifts.map((gift) => new StarGift(gift));
    });
  }
  function getStarGifts(client, userId, params) {
    return __async(this, null, function* () {
      const { offset = "", limit = 100 } = params != null ? params : {};
      const res = yield client.call({
        _: "payments.getUserStarGifts",
        userId: yield resolveUser(client, userId),
        offset,
        limit
      });
      const peers = PeersIndex.from(res);
      const gifts = res.gifts.map((gift) => new UserStarGift(gift, peers));
      return makeArrayPaginated(gifts, res.count, offset);
    });
  }
  function getStarsTransactions(client, peerId, params) {
    return __async(this, null, function* () {
      const { direction, sort, subscriptionId, offset = "", limit = 100 } = params != null ? params : {};
      const res = yield client.call({
        _: "payments.getStarsTransactions",
        peer: yield resolvePeer(client, peerId),
        offset,
        limit,
        outbound: direction === "outgoing",
        inbound: direction === "incoming",
        ascending: sort === "asc",
        subscriptionId
      });
      return new StarsStatus(res);
    });
  }
  function iterBoosters(client, peerId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { limit = Infinity, chunkSize = 100 } = params;
      let { offset } = params;
      let current = 0;
      const peer = yield new __await(resolvePeer(client, peerId));
      for (; ; ) {
        const res = yield new __await(getBoosts(client, peer, {
          offset,
          limit: Math.min(limit - current, chunkSize)
        }));
        for(let   booster of res) {
          yield booster;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
      }
    });
  }
  function iterStarGifts(client, peerId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { limit = Infinity, chunkSize = 100 } = params;
      let { offset } = params;
      let current = 0;
      const peer = yield new __await(resolvePeer(client, peerId));
      for (; ; ) {
        const res = yield new __await(getStarGifts(client, peer, {
          offset,
          limit: Math.min(limit - current, chunkSize)
        }));
        for(let   gift of res) {
          yield gift;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
      }
    });
  }
  function iterStarsTransactions(client, peerId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { limit = Infinity, chunkSize = 100 } = params;
      let { offset } = params;
      let current = 0;
      const peer = yield new __await(resolvePeer(client, peerId));
      for (; ; ) {
        const res = yield new __await(getStarsTransactions(client, peer, {
          offset,
          limit: Math.min(limit - current, chunkSize)
        }));
        for(let   transaction of res.transactions) {
          yield transaction;
          if (++current >= limit)
            return;
        }
        if (!res.transactionsNextOffset)
          return;
        offset = res.transactionsNextOffset;
      }
    });
  }
  function sendStarGift(client, params) {
    return __async(this, null, function* () {
      const { userId, gift, anonymous, message: message2, shouldDispatch } = params;
      const invoice = {
        _: "inputInvoiceStarGift",
        hideName: anonymous,
        userId: yield resolveUser(client, userId),
        giftId: Long.isLong(gift) ? gift : gift.id,
        message: message2 ? inputTextToTl(message2) : void 0
      };
      const form = yield client.call({
        _: "payments.getPaymentForm",
        invoice
      });
      const res = yield client.call({
        _: "payments.sendStarsForm",
        invoice,
        formId: form.formId
      });
      assertTypeIs("payments.sendStarsForm", res, "payments.paymentResult");
      return _findMessageInUpdate(client, res.updates, false, !shouldDispatch);
    });
  }
  function _normalizeFileToDocument(client, file, params) {
    return __async(this, null, function* () {
      if (typeof file === "object" && tl.tl.isAnyInputDocument(file)) {
        return file;
      }
      const media = yield _normalizeInputMedia(
        client,
        {
          type: "document",
          file
        },
        params,
        true
      );
      assertTypeIs("_normalizeFileToDocument", media, "inputMediaDocument");
      assertTypeIs("_normalizeFileToDocument", media.id, "inputDocument");
      return media.id;
    });
  }
  function isInputMediaSticker(media) {
    return typeof media === "object" && media !== null && "type" in media && media.type === "sticker";
  }
  function setBusinessIntro(client, intro) {
    return __async(this, null, function* () {
      var _a2, _b;
      let tlIntro;
      if (intro) {
        let sticker;
        if (intro.sticker) {
          if (isInputMediaSticker(intro.sticker)) {
            const media = yield _normalizeInputMedia(client, intro.sticker, void 0, true);
            assertTypeIs("_normalizeInputMedia", media, "inputMediaDocument");
            sticker = media.id;
          } else {
            sticker = yield _normalizeFileToDocument(client, intro.sticker, {});
          }
        }
        tlIntro = {
          _: "inputBusinessIntro",
          title: (_a2 = intro.title) != null ? _a2 : "",
          description: (_b = intro.description) != null ? _b : "",
          sticker
        };
      }
      const res = yield client.call({
        _: "account.updateBusinessIntro",
        intro: tlIntro
      });
      assertTrue("account.updateBusinessIntro", res);
    });
  }
  function setBusinessWorkHours(client, params) {
    return __async(this, null, function* () {
      let businessWorkHours;
      if (params) {
        let weeklyOpen;
        if ("hours" in params) {
          weeklyOpen = businessWorkHoursDaysToRaw(params.hours);
        } else {
          weeklyOpen = params.intervals;
        }
        businessWorkHours = {
          _: "businessWorkHours",
          timezoneId: params.timezone,
          weeklyOpen
        };
      }
      const res = yield client.call({
        _: "account.updateBusinessWorkHours",
        businessWorkHours
      });
      assertTrue("account.updateBusinessWorkHours", res);
    });
  }
  function _normalizeInputStickerSetItem(client, sticker, params) {
    return __async(this, null, function* () {
      return {
        _: "inputStickerSetItem",
        document: yield _normalizeFileToDocument(client, sticker.file, params != null ? params : {}),
        emoji: sticker.emojis,
        maskCoords: sticker.maskPosition ? {
          _: "maskCoords",
          n: MASK_POSITION_POINT_TO_TL[sticker.maskPosition.point],
          x: sticker.maskPosition.x,
          y: sticker.maskPosition.y,
          zoom: sticker.maskPosition.scale
        } : void 0
      };
    });
  }
  function addStickerToSet(client, setId, sticker, params) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "stickers.addStickerToSet",
        stickerset: normalizeInputStickerSet(setId),
        sticker: yield _normalizeInputStickerSetItem(client, sticker, params)
      });
      return new StickerSet(res);
    });
  }
  function createStickerSet(client, params) {
    return __async(this, null, function* () {
      var _a2;
      const owner = yield resolveUser(client, params.owner);
      const inputStickers = [];
      let i = 0;
      for(let   sticker of params.stickers) {
        const progressCallback = (_a2 = params.progressCallback) == null ? void 0 : _a2.bind(null, i);
        inputStickers.push(yield _normalizeInputStickerSetItem(client, sticker, { progressCallback }));
        i += 1;
      }
      const res = yield client.call({
        _: "stickers.createStickerSet",
        masks: params.type === "mask",
        emojis: params.type === "emoji",
        textColor: params.adaptive,
        userId: owner,
        title: params.title,
        shortName: params.shortName,
        stickers: inputStickers,
        thumb: params.thumb ? yield _normalizeFileToDocument(client, params.thumb, {}) : void 0
      });
      return new StickerSet(res);
    });
  }
  function deleteStickerFromSet(client, sticker) {
    return __async(this, null, function* () {
      if (typesInner.isFileIdLike(sticker)) {
        sticker = fileIdToInputDocument(sticker);
      }
      const res = yield client.call({
        _: "stickers.removeStickerFromSet",
        sticker
      });
      return new StickerSet(res);
    });
  }
  function getCustomEmojis(client, ids) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.getCustomEmojiDocuments",
        documentId: ids
      });
      return res.map((it) => {
        assertTypeIs("getCustomEmojis", it, "document");
        const doc = parseDocument(it);
        if (doc.type !== "sticker") {
          throw new MtTypeAssertionError("getCustomEmojis", "sticker", doc.type);
        }
        return doc;
      });
    });
  }
  function getCustomEmojisFromMessages(client, messages) {
    return __async(this, null, function* () {
      const set2 = new LongSet();
      if (!Array.isArray(messages))
        messages = [messages];
      for(let   { raw } of messages) {
        if (raw._ === "messageService" || !raw.entities)
          continue;
        for(let   entity of raw.entities) {
          if (entity._ === "messageEntityCustomEmoji") {
            set2.add(entity.documentId);
          }
        }
      }
      const arr = set2.toArray();
      if (!arr.length)
        return [];
      return getCustomEmojis(client, arr);
    });
  }
  function getInstalledStickers(client) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.getAllStickers",
        hash: Long.ZERO
      });
      assertTypeIs("getInstalledStickers", res, "messages.allStickers");
      return res.sets.map((set2) => new StickerSet(set2));
    });
  }
  function getMyStickerSets(client, params) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      const res = yield client.call({
        _: "messages.getMyStickers",
        offsetId: (_a2 = params == null ? void 0 : params.offset) != null ? _a2 : Long.ZERO,
        limit: (_b = params == null ? void 0 : params.limit) != null ? _b : 100
      });
      const items = res.sets.map((x) => new StickerSet(x));
      return makeArrayPaginated(items, res.count, (_c = items[items.length - 1]) == null ? void 0 : _c.brief.id);
    });
  }
  function getStickerSet(client, setId) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "messages.getStickerSet",
        stickerset: normalizeInputStickerSet(setId),
        hash: 0
      });
      return new StickerSet(res);
    });
  }
  function moveStickerInSet(client, sticker, position) {
    return __async(this, null, function* () {
      if (typesInner.isFileIdLike(sticker)) {
        sticker = fileIdToInputDocument(sticker);
      }
      const res = yield client.call({
        _: "stickers.changeStickerPosition",
        sticker,
        position
      });
      return new StickerSet(res);
    });
  }
  function replaceStickerInSet(client, sticker, newSticker, params) {
    return __async(this, null, function* () {
      if (typesInner.isFileIdLike(sticker)) {
        sticker = fileIdToInputDocument(sticker);
      }
      const res = yield client.call({
        _: "stickers.replaceSticker",
        sticker,
        newSticker: yield _normalizeInputStickerSetItem(client, newSticker, params)
      });
      return new StickerSet(res);
    });
  }
  function setChatStickerSet(client, chatId, setId) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "channels.setStickers",
        channel: yield resolveChannel(client, chatId),
        stickerset: normalizeInputStickerSet(setId)
      });
      assertTrue("channels.setStickers", r);
    });
  }
  function setStickerSetThumb(client, id2, thumb, params) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "stickers.setStickerSetThumb",
        stickerset: normalizeInputStickerSet(id2),
        thumb: yield _normalizeFileToDocument(client, thumb, params != null ? params : {})
      });
      return new StickerSet(res);
    });
  }
  function canSendStory(client, peerId) {
    return __async(this, null, function* () {
      try {
        const res = yield client.call({
          _: "stories.canSendStory",
          peer: yield resolvePeer(client, peerId)
        });
        if (!res)
          return "need_admin";
        return true;
      } catch (e) {
        if (tl.tl.RpcError.is(e, "CHAT_ADMIN_REQUIRED")) {
          return "need_admin";
        }
        if (tl.tl.RpcError.is(e, "BOOSTS_REQUIRED")) {
          return "need_boosts";
        }
        throw e;
      }
    });
  }
  function deleteStories(client, params) {
    return __async(this, null, function* () {
      const { ids, peer = "me" } = params;
      return client.call({
        _: "stories.deleteStories",
        peer: yield resolvePeer(client, peer),
        id: Array.isArray(ids) ? ids : [ids]
      });
    });
  }
  function _findStoryInUpdate(client, res) {
    assertIsUpdatesGroup("_findStoryInUpdate", res);
    client.handleClientUpdate(res, true);
    const peers = PeersIndex.from(res);
    const updateStory = res.updates.find(hasValueAtKey("_", "updateStory"));
    if (!updateStory) {
      throw new MtTypeAssertionError("_findStoryInUpdate (@ .updates[*])", "updateStory", "none");
    }
    assertTypeIs("updateStory.story", updateStory.story, "storyItem");
    return new Story(updateStory.story, peers);
  }
  function editStory(client, params) {
    return __async(this, null, function* () {
      const { id: id2, peer = "me", interactiveElements } = params;
      let caption;
      let entities;
      let media;
      if (params.media) {
        media = yield _normalizeInputMedia(client, params.media);
        if ("caption" in params.media && params.media.caption !== void 0) {
          [caption, entities] = yield _normalizeInputText(client, params.media.caption);
        }
      }
      if (params.caption) {
        [caption, entities] = yield _normalizeInputText(client, params.caption);
      }
      const privacyRules = params.privacyRules ? yield _normalizePrivacyRules(client, params.privacyRules) : void 0;
      const res = yield client.call({
        _: "stories.editStory",
        peer: yield resolvePeer(client, peer),
        id: id2,
        media,
        mediaAreas: interactiveElements,
        caption,
        entities,
        privacyRules
      });
      return _findStoryInUpdate(client, res);
    });
  }
  function getAllStories(client, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      const { offset, archived } = params;
      const res = yield client.call({
        _: "stories.getAllStories",
        state: offset,
        next: Boolean(offset),
        hidden: archived
      });
      assertTypeIsNot("getAllStories", res, "stories.allStoriesNotModified");
      return new AllStories(res);
    });
  }
  function getPeerStories(client, peerId) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "stories.getPeerStories",
        peer: yield resolvePeer(client, peerId)
      });
      const peers = PeersIndex.from(res);
      return new PeerStories(res.stories, peers);
    });
  }
  function getProfileStories(client, peerId, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      const { kind = "pinned", offsetId = 0, limit = 100 } = params;
      const res = yield client.call({
        _: kind === "pinned" ? "stories.getPinnedStories" : "stories.getStoriesArchive",
        peer: yield resolvePeer(client, peerId),
        offsetId,
        limit
      });
      const peers = PeersIndex.from(res);
      const stories = res.stories.map((it) => {
        assertTypeIs("getProfileStories", it, "storyItem");
        return new Story(it, peers);
      });
      const last = stories[stories.length - 1];
      const next = last == null ? void 0 : last.id;
      return makeArrayPaginated(stories, res.count, next);
    });
  }
  function getStoriesById(client, peerId, storyIds) {
    return __async(this, null, function* () {
      if (!Array.isArray(storyIds))
        storyIds = [storyIds];
      const res = yield client.call({
        _: "stories.getStoriesByID",
        peer: yield resolvePeer(client, peerId),
        id: storyIds
      });
      const peers = PeersIndex.from(res);
      const stories = res.stories.map((it) => {
        assertTypeIs("getProfileStories", it, "storyItem");
        return new Story(it, peers);
      });
      return stories;
    });
  }
  function getStoriesInteractions(client, peerId, storyIds) {
    return __async(this, null, function* () {
      if (!Array.isArray(storyIds))
        storyIds = [storyIds];
      const res = yield client.call({
        _: "stories.getStoriesViews",
        peer: yield resolvePeer(client, peerId),
        id: storyIds
      });
      const peers = PeersIndex.from(res);
      const infos = res.views.map((it) => new StoryInteractions(it, peers));
      return infos;
    });
  }
  function getStoryLink(client, peerId, storyId) {
    return __async(this, null, function* () {
      return client.call({
        _: "stories.exportStoryLink",
        peer: yield resolvePeer(client, peerId),
        id: storyId
      }).then((r) => r.link);
    });
  }
  function getStoryViewers(client, peerId, storyId, params) {
    return __async(this, null, function* () {
      if (!params)
        params = {};
      const { onlyContacts, sortBy = "reaction", query, offset = "", limit = 100 } = params;
      const res = yield client.call({
        _: "stories.getStoryViewsList",
        peer: yield resolvePeer(client, peerId),
        justContacts: onlyContacts,
        reactionsFirst: sortBy === "reaction",
        q: query,
        id: storyId,
        offset,
        limit
      });
      return new StoryViewersList(res);
    });
  }
  function hideMyStoriesViews(client, params) {
    return __async(this, null, function* () {
      const { past = true, future = true } = params != null ? params : {};
      const res = yield client.call({
        _: "stories.activateStealthMode",
        past,
        future
      });
      assertIsUpdatesGroup("hideMyStoriesViews", res);
      client.handleClientUpdate(res, true);
      const upd = res.updates.find(hasValueAtKey("_", "updateStoriesStealthMode"));
      if (!upd) {
        throw new MtTypeAssertionError("hideMyStoriesViews (@ res.updates[*])", "updateStoriesStealthMode", "none");
      }
      return new StoriesStealthMode(upd.stealthMode);
    });
  }
  function incrementStoriesViews(client, peerId, ids) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "stories.incrementStoryViews",
        peer: yield resolvePeer(client, peerId),
        id: Array.isArray(ids) ? ids : [ids]
      });
      assertTrue("stories.incrementStoryViews", r);
    });
  }
  function iterAllStories(client, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { archived, limit = Infinity } = params;
      let { offset } = params;
      let current = 0;
      for (; ; ) {
        const res = yield new __await(getAllStories(client, {
          offset,
          archived
        }));
        for(let   peer of res.peerStories) {
          yield peer;
          if (++current >= limit)
            return;
        }
        if (!res.hasMore)
          return;
        offset = res.next;
      }
    });
  }
  function iterProfileStories(client, peerId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { kind = "pinned", limit = Infinity, chunkSize = 100 } = params;
      let { offsetId } = params;
      let current = 0;
      const peer = yield new __await(resolvePeer(client, peerId));
      for (; ; ) {
        const res = yield new __await(getProfileStories(client, peer, {
          kind,
          offsetId,
          limit: Math.min(limit - current, chunkSize)
        }));
        for(let   peer2 of res) {
          yield peer2;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offsetId = res.next;
      }
    });
  }
  function iterStoryViewers(client, peerId, storyId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const { onlyContacts, sortBy = "reaction", query, limit = Infinity, chunkSize = 100 } = params;
      let { offset = "" } = params;
      let current = 0;
      const peer = yield new __await(resolvePeer(client, peerId));
      for (; ; ) {
        const res = yield new __await(getStoryViewers(client, peer, storyId, {
          onlyContacts,
          sortBy,
          query,
          offset,
          limit: Math.min(limit - current, chunkSize)
        }));
        for(let   peer2 of res.viewers) {
          yield peer2;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
      }
    });
  }
  function readStories(client, peerId, maxId) {
    return __async(this, null, function* () {
      return client.call({
        _: "stories.readStories",
        peer: yield resolvePeer(client, peerId),
        maxId
      });
    });
  }
  function sendStoryReaction(client, params) {
    return __async(this, null, function* () {
      const { peerId, storyId, reaction, addToRecent } = params;
      const res = yield client.call({
        _: "stories.sendReaction",
        peer: yield resolvePeer(client, peerId),
        storyId,
        reaction: normalizeInputReaction(reaction),
        addToRecent
      });
      client.handleClientUpdate(res, true);
    });
  }
  function sendStory(client, params) {
    return __async(this, null, function* () {
      const { peer = "me", pinned, forbidForwards, interactiveElements, period } = params;
      let { media } = params;
      if (typeof media === "string") {
        media = {
          type: "auto",
          file: media
        };
      }
      const inputMedia = yield _normalizeInputMedia(client, media);
      const privacyRules = params.privacyRules ? yield _normalizePrivacyRules(client, params.privacyRules) : [{ _: "inputPrivacyValueAllowAll" }];
      const [caption, entities] = yield _normalizeInputText(
        client,
        // some types dont have `caption` field, and ts warns us,
        // but since it's JS, they'll just be `undefined` and properly handled by the method
        params.caption || media.caption
      );
      const res = yield client.call({
        _: "stories.sendStory",
        pinned,
        noforwards: forbidForwards,
        peer: yield resolvePeer(client, peer),
        media: inputMedia,
        mediaAreas: interactiveElements,
        caption,
        entities,
        privacyRules,
        randomId: randomLong(),
        period
      });
      return _findStoryInUpdate(client, res);
    });
  }
  function togglePeerStoriesArchived(client, peerId, archived) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "stories.togglePeerStoriesHidden",
        peer: yield resolvePeer(client, peerId),
        hidden: archived
      });
      assertTrue("stories.togglePeerStoriesHidden", r);
    });
  }
  function toggleStoriesPinned(client, params) {
    return __async(this, null, function* () {
      const { ids, pinned, peer = "me" } = params;
      return client.call({
        _: "stories.togglePinned",
        peer: yield resolvePeer(client, peer),
        id: Array.isArray(ids) ? ids : [ids],
        pinned
      });
    });
  }
  function blockUser(client, id2) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "contacts.block",
        id: yield resolvePeer(client, id2)
      });
      assertTrue("contacts.block", r);
    });
  }
  function deleteProfilePhotos(client, ids) {
    return __async(this, null, function* () {
      if (!Array.isArray(ids))
        ids = [ids];
      const photos = ids.map((id2) => {
        if (typeof id2 === "string") {
          return fileIdToInputPhoto(id2);
        }
        return id2;
      });
      yield client.call({
        _: "photos.deletePhotos",
        id: photos
      });
    });
  }
  function editCloseFriendsRaw(client, ids) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "contacts.editCloseFriends",
        id: ids
      });
      assertTrue("contacts.editCloseFriends", r);
    });
  }
  function editCloseFriends(client, ids) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "contacts.editCloseFriends",
        id: yield resolvePeerMany(client, ids, toInputUser).then(
          (r2) => r2.map((u) => {
            if ("userId" in u)
              return u.userId;
            return 0;
          })
        )
      });
      assertTrue("contacts.editCloseFriends", r);
    });
  }
  function getCommonChats(client, userId) {
    return __async(this, null, function* () {
      return client.call({
        _: "messages.getCommonChats",
        userId: yield resolveUser(client, userId),
        maxId: 0,
        limit: 100
      }).then((res) => res.chats.map((it) => new Chat(it)));
    });
  }
  function getGlobalTtl(client) {
    return __async(this, null, function* () {
      return client.call({
        _: "messages.getDefaultHistoryTTL"
      }).then((r) => r.period);
    });
  }
  function getMyUsername(client) {
    return __async(this, null, function* () {
      return client.storage.self.fetch().then((self2) => {
        var _a2;
        return (_a2 = self2 == null ? void 0 : self2.usernames[0]) != null ? _a2 : null;
      });
    });
  }
  function getProfilePhoto(client, userId, photoId) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "photos.getUserPhotos",
        userId: yield resolveUser(client, userId),
        offset: -1,
        limit: 1,
        maxId: photoId
      });
      const photo = res.photos[0];
      assertTypeIs("getProfilePhotos", photo, "photo");
      return new Photo(photo);
    });
  }
  function getProfilePhotos(client, userId, params) {
    return __async(this, null, function* () {
      var _a2;
      if (!params)
        params = {};
      const { offset = 0, limit = 100 } = params;
      const res = yield client.call({
        _: "photos.getUserPhotos",
        userId: yield resolveUser(client, userId),
        offset,
        limit,
        maxId: Long.ZERO
      });
      return makeArrayPaginated(
        res.photos.map((it) => {
          assertTypeIs("getProfilePhotos", it, "photo");
          return new Photo(it);
        }),
        (_a2 = res.count) != null ? _a2 : res.photos.length,
        offset + res.photos.length
      );
    });
  }
  function getUsers(client, ids) {
    return __async(this, null, function* () {
      if (!Array.isArray(ids)) {
        const res2 = yield _getUsersBatched(client, yield resolveUser(client, ids));
        return [res2 ? new User(res2) : null];
      }
      const inputPeers = yield resolvePeerMany(client, ids, toInputUser);
      const res = yield Promise.all(inputPeers.map((peer) => _getUsersBatched(client, peer)));
      return res.map((it) => it ? new User(it) : null);
    });
  }
  function isPeerAvailable(client, peerId) {
    return __async(this, null, function* () {
      var _a2;
      peerId = _normalizePeerId(peerId);
      if (typeof peerId === "object") {
        return true;
      }
      if (typeof peerId === "number") {
        const fromStorage = yield client.storage.peers.getById(peerId);
        if (fromStorage)
          return true;
        const [peerType] = parseMarkedPeerId(peerId);
        if (peerType === "chat" || ((_a2 = client.storage.self.getCached(true)) == null ? void 0 : _a2.isBot)) {
          return true;
        }
        return false;
      }
      if (typeof peerId === "string") {
        if (peerId === "self" || peerId === "me") {
          return true;
        }
        peerId = peerId.replace(/[@+\s()]/g, "");
        if (peerId.match(/^\d+$/)) {
          const fromStorage = yield client.storage.peers.getByPhone(peerId);
          if (fromStorage)
            return true;
        } else {
          const fromStorage = yield client.storage.peers.getByUsername(peerId);
          if (fromStorage)
            return true;
        }
        return false;
      }
      return false;
    });
  }
  function iterProfilePhotos(client, userId, params) {
    return __asyncGenerator(this, null, function* () {
      if (!params)
        params = {};
      const peer = yield new __await(resolveUser(client, userId));
      const { limit = Infinity, chunkSize = 100 } = params;
      let { offset } = params;
      let current = 0;
      for (; ; ) {
        const res = yield new __await(getProfilePhotos(client, peer, {
          offset,
          limit: Math.min(chunkSize, limit - current)
        }));
        for(let   it of res) {
          yield it;
          if (++current >= limit)
            return;
        }
        if (!res.next)
          return;
        offset = res.next;
      }
    });
  }
  function setGlobalTtl(client, period) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "messages.setDefaultHistoryTTL",
        period
      });
      assertTrue("messages.setDefaultHistoryTTL", r);
    });
  }
  function setMyBirthday(client, birthday) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "account.updateBirthday",
        birthday: birthday ? __spreadValues({
          _: "birthday"
        }, birthday) : void 0
      });
      assertTrue("account.updateBirthday", res);
    });
  }
  function setMyEmojiStatus(client, emoji, params) {
    return __async(this, null, function* () {
      const { until } = params != null ? params : {};
      let emojiStatus;
      if (emoji === null) {
        emojiStatus = { _: "emojiStatusEmpty" };
      } else if (until) {
        emojiStatus = {
          _: "emojiStatusUntil",
          documentId: emoji,
          until: normalizeDate(until)
        };
      } else {
        emojiStatus = {
          _: "emojiStatus",
          documentId: emoji
        };
      }
      const r = yield client.call({
        _: "account.updateEmojiStatus",
        emojiStatus
      });
      assertTrue("account.updateEmojiStatus", r);
    });
  }
  function setMyProfilePhoto(client, params) {
    return __async(this, null, function* () {
      const { type, previewSec } = params;
      let { media } = params;
      if (typesInner.isFileIdLike(media) || typeof media === "object" && tl.tl.isAnyInputPhoto(media)) {
        if (typeof media === "string" && media.match(/^https?:\/\//)) {
          throw new MtArgumentError("Profile photo can't be set from URL.");
        }
        if (typeof media !== "string" || !media.match(/^file:/)) {
          if (typesInner.isFileIdLike(media)) {
            media = fileIdToInputPhoto(media);
          }
          const res2 = yield client.call({
            _: "photos.updateProfilePhoto",
            id: media
          });
          return new Photo(res2.photo);
        }
      }
      const res = yield client.call({
        _: "photos.uploadProfilePhoto",
        [type === "photo" ? "file" : "video"]: yield _normalizeInputFile(client, media, {}),
        videoStartTs: previewSec
      });
      return new Photo(res.photo);
    });
  }
  function setMyUsername(client, username) {
    return __async(this, null, function* () {
      if (username === null)
        username = "";
      const res = yield client.call({
        _: "account.updateUsername",
        username
      });
      yield client.storage.self.update({ username });
      return new User(res);
    });
  }
  function setOffline(client, offline = true) {
    return __async(this, null, function* () {
      yield client.call({
        _: "account.updateStatus",
        offline
      });
    });
  }
  function unblockUser(client, id2) {
    return __async(this, null, function* () {
      const r = yield client.call({
        _: "contacts.unblock",
        id: yield resolvePeer(client, id2)
      });
      assertTrue("contacts.unblock", r);
    });
  }
  function updateProfile(client, params) {
    return __async(this, null, function* () {
      const res = yield client.call({
        _: "account.updateProfile",
        firstName: params.firstName,
        lastName: params.lastName,
        about: params.bio
      });
      return new User(res);
    });
  }
  function withParams(client, params) {
    const wrappedCall = (message2, extraParams) => client.call(message2, extraParams ? __spreadValues(__spreadValues({}, params), extraParams) : params);
    const proxy2 = new Proxy(client, {
      get: (target, prop, receiver) => {
        if (prop === "call") {
          return wrappedCall;
        }
        if (prop === "_client") {
          return proxy2;
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    return proxy2;
  }
  let TelegramClient$1 = class TelegramClient extends EventEmitter {
    constructor(opts) {
      var _a2, _b;
      super();
      __publicField(this, "_client");
      if ("client" in opts) {
        this._client = opts.client;
      } else {
        if (!opts.storage || typeof opts.storage === "string" || !opts.transport || !opts.crypto) {
          throw new MtUnsupportedError(
            "You need to explicitly provide storage, transport and crypto for @mtcute/core"
          );
        }
        this._client = new BaseTelegramClient$1(opts);
      }
      this.log = this._client.log;
      this.storage = this._client.storage;
      Object.defineProperty(this, "stopSignal", {
        get: () => this._client.stopSignal
      });
      Object.defineProperty(this, "appConfig", {
        get: () => this._client.appConfig
      });
      if (!opts.disableUpdates) {
        const skipConversationUpdates = (_a2 = opts.skipConversationUpdates) != null ? _a2 : true;
        const { messageGroupingInterval } = (_b = opts.updates) != null ? _b : {};
        this._client.onUpdate(
          makeParsedUpdateHandler({
            messageGroupingInterval,
            onUpdate: (update) => {
              if (Conversation.handleUpdate(this, update) && skipConversationUpdates)
                return;
              this.emit("update", update);
              this.emit(update.name, update.data);
            },
            onRawUpdate: (update, peers) => {
              this.emit("raw_update", update, peers);
            }
          })
        );
      }
    }
    withParams(params) {
      return withParams(this, params);
    }
  };
  TelegramClient$1.prototype.checkPassword = function(...args) {
    return checkPassword(this._client, ...args);
  };
  TelegramClient$1.prototype.getPasswordHint = function(...args) {
    return getPasswordHint(this._client, ...args);
  };
  TelegramClient$1.prototype.logOut = function(...args) {
    return logOut(this._client, ...args);
  };
  TelegramClient$1.prototype.recoverPassword = function(...args) {
    return recoverPassword(this._client, ...args);
  };
  TelegramClient$1.prototype.resendCode = function(...args) {
    return resendCode(this._client, ...args);
  };
  TelegramClient$1.prototype.run = function(...args) {
    return run(this._client, ...args);
  };
  TelegramClient$1.prototype.sendCode = function(...args) {
    return sendCode(this._client, ...args);
  };
  TelegramClient$1.prototype.sendRecoveryCode = function(...args) {
    return sendRecoveryCode(this._client, ...args);
  };
  TelegramClient$1.prototype.signInBot = function(...args) {
    return signInBot(this._client, ...args);
  };
  TelegramClient$1.prototype.signInQr = function(...args) {
    return signInQr(this._client, ...args);
  };
  TelegramClient$1.prototype.signIn = function(...args) {
    return signIn(this._client, ...args);
  };
  TelegramClient$1.prototype.startTest = function(...args) {
    return startTest(this._client, ...args);
  };
  TelegramClient$1.prototype.start = function(...args) {
    return start(this._client, ...args);
  };
  TelegramClient$1.prototype.isSelfPeer = function(...args) {
    return isSelfPeer(this._client, ...args);
  };
  TelegramClient$1.prototype.answerCallbackQuery = function(...args) {
    return answerCallbackQuery(this._client, ...args);
  };
  TelegramClient$1.prototype.answerInlineQuery = function(...args) {
    return answerInlineQuery(this._client, ...args);
  };
  TelegramClient$1.prototype.answerPreCheckoutQuery = function(...args) {
    return answerPreCheckoutQuery(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteMyCommands = function(...args) {
    return deleteMyCommands(this._client, ...args);
  };
  TelegramClient$1.prototype.getBotInfo = function(...args) {
    return getBotInfo(this._client, ...args);
  };
  TelegramClient$1.prototype.getBotMenuButton = function(...args) {
    return getBotMenuButton(this._client, ...args);
  };
  TelegramClient$1.prototype.getCallbackAnswer = function(...args) {
    return getCallbackAnswer(this._client, ...args);
  };
  TelegramClient$1.prototype.getGameHighScores = function(...args) {
    return getGameHighScores(this._client, ...args);
  };
  TelegramClient$1.prototype.getInlineGameHighScores = function(...args) {
    return getInlineGameHighScores(this._client, ...args);
  };
  TelegramClient$1.prototype.getMyCommands = function(...args) {
    return getMyCommands(this._client, ...args);
  };
  TelegramClient$1.prototype.setBotInfo = function(...args) {
    return setBotInfo(this._client, ...args);
  };
  TelegramClient$1.prototype.setBotMenuButton = function(...args) {
    return setBotMenuButton(this._client, ...args);
  };
  TelegramClient$1.prototype.setGameScore = function(...args) {
    return setGameScore(this._client, ...args);
  };
  TelegramClient$1.prototype.setInlineGameScore = function(...args) {
    return setInlineGameScore(this._client, ...args);
  };
  TelegramClient$1.prototype.setMyCommands = function(...args) {
    return setMyCommands(this._client, ...args);
  };
  TelegramClient$1.prototype.setMyDefaultRights = function(...args) {
    return setMyDefaultRights(this._client, ...args);
  };
  TelegramClient$1.prototype.addChatMembers = function(...args) {
    return addChatMembers(this._client, ...args);
  };
  TelegramClient$1.prototype.archiveChats = function(...args) {
    return archiveChats(this._client, ...args);
  };
  TelegramClient$1.prototype.banChatMember = function(...args) {
    return banChatMember(this._client, ...args);
  };
  TelegramClient$1.prototype.createChannel = function(...args) {
    return createChannel(this._client, ...args);
  };
  TelegramClient$1.prototype.createGroup = function(...args) {
    return createGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.createSupergroup = function(...args) {
    return createSupergroup(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteChannel = function(...args) {
    return deleteChannel(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteSupergroup = function(...args) {
    return deleteChannel(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteChatPhoto = function(...args) {
    return deleteChatPhoto(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteGroup = function(...args) {
    return deleteGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteHistory = function(...args) {
    return deleteHistory(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteUserHistory = function(...args) {
    return deleteUserHistory(this._client, ...args);
  };
  TelegramClient$1.prototype.editAdminRights = function(...args) {
    return editAdminRights(this._client, ...args);
  };
  TelegramClient$1.prototype.getChatEventLog = function(...args) {
    return getChatEventLog(this._client, ...args);
  };
  TelegramClient$1.prototype.getChatMember = function(...args) {
    return getChatMember(this._client, ...args);
  };
  TelegramClient$1.prototype.getChatMembers = function(...args) {
    return getChatMembers(this._client, ...args);
  };
  TelegramClient$1.prototype.getChatPreview = function(...args) {
    return getChatPreview(this._client, ...args);
  };
  TelegramClient$1.prototype.getChat = function(...args) {
    return getChat(this._client, ...args);
  };
  TelegramClient$1.prototype.getFullChat = function(...args) {
    return getFullChat(this._client, ...args);
  };
  TelegramClient$1.prototype.getNearbyChats = function(...args) {
    return getNearbyChats(this._client, ...args);
  };
  TelegramClient$1.prototype.getSimilarChannels = function(...args) {
    return getSimilarChannels(this._client, ...args);
  };
  TelegramClient$1.prototype.iterChatEventLog = function(...args) {
    return iterChatEventLog(this._client, ...args);
  };
  TelegramClient$1.prototype.iterChatMembers = function(...args) {
    return iterChatMembers(this._client, ...args);
  };
  TelegramClient$1.prototype.joinChat = function(...args) {
    return joinChat(this._client, ...args);
  };
  TelegramClient$1.prototype.kickChatMember = function(...args) {
    return kickChatMember(this._client, ...args);
  };
  TelegramClient$1.prototype.leaveChat = function(...args) {
    return leaveChat(this._client, ...args);
  };
  TelegramClient$1.prototype.markChatUnread = function(...args) {
    return markChatUnread(this._client, ...args);
  };
  TelegramClient$1.prototype.openChat = function(...args) {
    return openChat(this._client, ...args);
  };
  TelegramClient$1.prototype.closeChat = function(...args) {
    return closeChat(this._client, ...args);
  };
  TelegramClient$1.prototype.reorderUsernames = function(...args) {
    return reorderUsernames(this._client, ...args);
  };
  TelegramClient$1.prototype.restrictChatMember = function(...args) {
    return restrictChatMember(this._client, ...args);
  };
  TelegramClient$1.prototype.saveDraft = function(...args) {
    return saveDraft(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatColor = function(...args) {
    return setChatColor(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatDefaultPermissions = function(...args) {
    return setChatDefaultPermissions(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatDescription = function(...args) {
    return setChatDescription(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatPhoto = function(...args) {
    return setChatPhoto(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatTitle = function(...args) {
    return setChatTitle(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatTtl = function(...args) {
    return setChatTtl(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatUsername = function(...args) {
    return setChatUsername(this._client, ...args);
  };
  TelegramClient$1.prototype.setSlowMode = function(...args) {
    return setSlowMode(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleContentProtection = function(...args) {
    return toggleContentProtection(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleFragmentUsername = function(...args) {
    return toggleFragmentUsername(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleJoinRequests = function(...args) {
    return toggleJoinRequests(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleJoinToSend = function(...args) {
    return toggleJoinToSend(this._client, ...args);
  };
  TelegramClient$1.prototype.unarchiveChats = function(...args) {
    return unarchiveChats(this._client, ...args);
  };
  TelegramClient$1.prototype.unbanChatMember = function(...args) {
    return unbanChatMember(this._client, ...args);
  };
  TelegramClient$1.prototype.unrestrictChatMember = function(...args) {
    return unbanChatMember(this._client, ...args);
  };
  TelegramClient$1.prototype.addContact = function(...args) {
    return addContact(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteContacts = function(...args) {
    return deleteContacts(this._client, ...args);
  };
  TelegramClient$1.prototype.getContacts = function(...args) {
    return getContacts(this._client, ...args);
  };
  TelegramClient$1.prototype.importContacts = function(...args) {
    return importContacts(this._client, ...args);
  };
  TelegramClient$1.prototype.createFolder = function(...args) {
    return createFolder(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteFolder = function(...args) {
    return deleteFolder(this._client, ...args);
  };
  TelegramClient$1.prototype.editFolder = function(...args) {
    return editFolder(this._client, ...args);
  };
  TelegramClient$1.prototype.findDialogs = function(...args) {
    return findDialogs(this._client, ...args);
  };
  TelegramClient$1.prototype.findFolder = function(...args) {
    return findFolder(this._client, ...args);
  };
  TelegramClient$1.prototype.getChatlistPreview = function(...args) {
    return getChatlistPreview(this._client, ...args);
  };
  TelegramClient$1.prototype.getFolders = function(...args) {
    return getFolders(this._client, ...args);
  };
  TelegramClient$1.prototype.getPeerDialogs = function(...args) {
    return getPeerDialogs(this._client, ...args);
  };
  TelegramClient$1.prototype.iterDialogs = function(...args) {
    return iterDialogs(this._client, ...args);
  };
  TelegramClient$1.prototype.joinChatlist = function(...args) {
    return joinChatlist(this._client, ...args);
  };
  TelegramClient$1.prototype.setFoldersOrder = function(...args) {
    return setFoldersOrder(this._client, ...args);
  };
  TelegramClient$1.prototype.downloadAsBuffer = function(...args) {
    return downloadAsBuffer(this._client, ...args);
  };
  TelegramClient$1.prototype.downloadAsIterable = function(...args) {
    return downloadAsIterable(this._client, ...args);
  };
  TelegramClient$1.prototype.downloadAsStream = function(...args) {
    return downloadAsStream(this._client, ...args);
  };
  TelegramClient$1.prototype._normalizeInputFile = function(...args) {
    return _normalizeInputFile(this._client, ...args);
  };
  TelegramClient$1.prototype._normalizeInputMedia = function(...args) {
    return _normalizeInputMedia(this._client, ...args);
  };
  TelegramClient$1.prototype.uploadFile = function(...args) {
    return uploadFile(this._client, ...args);
  };
  TelegramClient$1.prototype.uploadMedia = function(...args) {
    return uploadMedia(this._client, ...args);
  };
  TelegramClient$1.prototype.createForumTopic = function(...args) {
    return createForumTopic(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteForumTopicHistory = function(...args) {
    return deleteForumTopicHistory(this._client, ...args);
  };
  TelegramClient$1.prototype.editForumTopic = function(...args) {
    return editForumTopic(this._client, ...args);
  };
  TelegramClient$1.prototype.getForumTopicsById = function(...args) {
    return getForumTopicsById(this._client, ...args);
  };
  TelegramClient$1.prototype.getForumTopics = function(...args) {
    return getForumTopics(this._client, ...args);
  };
  TelegramClient$1.prototype.iterForumTopics = function(...args) {
    return iterForumTopics(this._client, ...args);
  };
  TelegramClient$1.prototype.reorderPinnedForumTopics = function(...args) {
    return reorderPinnedForumTopics(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleForumTopicClosed = function(...args) {
    return toggleForumTopicClosed(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleForumTopicPinned = function(...args) {
    return toggleForumTopicPinned(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleForum = function(...args) {
    return toggleForum(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleGeneralTopicHidden = function(...args) {
    return toggleGeneralTopicHidden(this._client, ...args);
  };
  TelegramClient$1.prototype.createInviteLink = function(...args) {
    return createInviteLink(this._client, ...args);
  };
  TelegramClient$1.prototype.editInviteLink = function(...args) {
    return editInviteLink(this._client, ...args);
  };
  TelegramClient$1.prototype.exportInviteLink = function(...args) {
    return exportInviteLink(this._client, ...args);
  };
  TelegramClient$1.prototype.getInviteLinkMembers = function(...args) {
    return getInviteLinkMembers(this._client, ...args);
  };
  TelegramClient$1.prototype.getInviteLink = function(...args) {
    return getInviteLink(this._client, ...args);
  };
  TelegramClient$1.prototype.getInviteLinks = function(...args) {
    return getInviteLinks(this._client, ...args);
  };
  TelegramClient$1.prototype.getPrimaryInviteLink = function(...args) {
    return getPrimaryInviteLink(this._client, ...args);
  };
  TelegramClient$1.prototype.hideAllJoinRequests = function(...args) {
    return hideAllJoinRequests(this._client, ...args);
  };
  TelegramClient$1.prototype.hideJoinRequest = function(...args) {
    return hideJoinRequest(this._client, ...args);
  };
  TelegramClient$1.prototype.iterInviteLinkMembers = function(...args) {
    return iterInviteLinkMembers(this._client, ...args);
  };
  TelegramClient$1.prototype.iterInviteLinks = function(...args) {
    return iterInviteLinks(this._client, ...args);
  };
  TelegramClient$1.prototype.revokeInviteLink = function(...args) {
    return revokeInviteLink(this._client, ...args);
  };
  TelegramClient$1.prototype.closePoll = function(...args) {
    return closePoll(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteMessagesById = function(...args) {
    return deleteMessagesById(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteMessages = function(...args) {
    return deleteMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteScheduledMessages = function(...args) {
    return deleteScheduledMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.editInlineMessage = function(...args) {
    return editInlineMessage(this._client, ...args);
  };
  TelegramClient$1.prototype.editMessage = function(...args) {
    return editMessage(this._client, ...args);
  };
  TelegramClient$1.prototype.forwardMessagesById = function(...args) {
    return forwardMessagesById(this._client, ...args);
  };
  TelegramClient$1.prototype.forwardMessages = function(...args) {
    return forwardMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.getAllScheduledMessages = function(...args) {
    return getAllScheduledMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.getAvailableMessageEffects = function(...args) {
    return getAvailableMessageEffects(this._client, ...args);
  };
  TelegramClient$1.prototype.getCallbackQueryMessage = function(...args) {
    return getCallbackQueryMessage(this._client, ...args);
  };
  TelegramClient$1.prototype.getDiscussionMessage = function(...args) {
    return getDiscussionMessage(this._client, ...args);
  };
  TelegramClient$1.prototype.getFactCheck = function(...args) {
    return getFactCheck(this._client, ...args);
  };
  TelegramClient$1.prototype.getHistory = function(...args) {
    return getHistory(this._client, ...args);
  };
  TelegramClient$1.prototype.getMessageByLink = function(...args) {
    return getMessageByLink(this._client, ...args);
  };
  TelegramClient$1.prototype.getMessageGroup = function(...args) {
    return getMessageGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.getMessageReactionsById = function(...args) {
    return getMessageReactionsById(this._client, ...args);
  };
  TelegramClient$1.prototype.getMessageReactions = function(...args) {
    return getMessageReactions(this._client, ...args);
  };
  TelegramClient$1.prototype.getMessagesUnsafe = function(...args) {
    return getMessagesUnsafe(this._client, ...args);
  };
  TelegramClient$1.prototype.getMessages = function(...args) {
    return getMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.getReactionUsers = function(...args) {
    return getReactionUsers(this._client, ...args);
  };
  TelegramClient$1.prototype.getReplyTo = function(...args) {
    return getReplyTo(this._client, ...args);
  };
  TelegramClient$1.prototype.getScheduledMessages = function(...args) {
    return getScheduledMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.iterHistory = function(...args) {
    return iterHistory(this._client, ...args);
  };
  TelegramClient$1.prototype.iterReactionUsers = function(...args) {
    return iterReactionUsers(this._client, ...args);
  };
  TelegramClient$1.prototype.iterSearchGlobal = function(...args) {
    return iterSearchGlobal(this._client, ...args);
  };
  TelegramClient$1.prototype.iterSearchMessages = function(...args) {
    return iterSearchMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.pinMessage = function(...args) {
    return pinMessage(this._client, ...args);
  };
  TelegramClient$1.prototype.readHistory = function(...args) {
    return readHistory(this._client, ...args);
  };
  TelegramClient$1.prototype.readReactions = function(...args) {
    return readReactions(this._client, ...args);
  };
  TelegramClient$1.prototype.searchGlobal = function(...args) {
    return searchGlobal(this._client, ...args);
  };
  TelegramClient$1.prototype.searchHashtag = function(...args) {
    return searchHashtag(this._client, ...args);
  };
  TelegramClient$1.prototype.iterSearchHashtag = function(...args) {
    return iterSearchHashtag(this._client, ...args);
  };
  TelegramClient$1.prototype.searchMessages = function(...args) {
    return searchMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.answerText = function(...args) {
    return answerText(this._client, ...args);
  };
  TelegramClient$1.prototype.answerMedia = function(...args) {
    return answerMedia(this._client, ...args);
  };
  TelegramClient$1.prototype.answerMediaGroup = function(...args) {
    return answerMediaGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.commentText = function(...args) {
    return commentText(this._client, ...args);
  };
  TelegramClient$1.prototype.commentMedia = function(...args) {
    return commentMedia(this._client, ...args);
  };
  TelegramClient$1.prototype.commentMediaGroup = function(...args) {
    return commentMediaGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.sendCopyGroup = function(...args) {
    return sendCopyGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.sendCopy = function(...args) {
    return sendCopy(this._client, ...args);
  };
  TelegramClient$1.prototype.sendMediaGroup = function(...args) {
    return sendMediaGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.sendMedia = function(...args) {
    return sendMedia(this._client, ...args);
  };
  TelegramClient$1.prototype.sendPaidReaction = function(...args) {
    return sendPaidReaction(this._client, ...args);
  };
  TelegramClient$1.prototype.quoteWithText = function(...args) {
    return quoteWithText(this._client, ...args);
  };
  TelegramClient$1.prototype.quoteWithMedia = function(...args) {
    return quoteWithMedia(this._client, ...args);
  };
  TelegramClient$1.prototype.quoteWithMediaGroup = function(...args) {
    return quoteWithMediaGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.sendReaction = function(...args) {
    return sendReaction(this._client, ...args);
  };
  TelegramClient$1.prototype.replyText = function(...args) {
    return replyText(this._client, ...args);
  };
  TelegramClient$1.prototype.replyMedia = function(...args) {
    return replyMedia(this._client, ...args);
  };
  TelegramClient$1.prototype.replyMediaGroup = function(...args) {
    return replyMediaGroup(this._client, ...args);
  };
  TelegramClient$1.prototype.sendScheduled = function(...args) {
    return sendScheduled(this._client, ...args);
  };
  TelegramClient$1.prototype.sendText = function(...args) {
    return sendText(this._client, ...args);
  };
  TelegramClient$1.prototype.sendTyping = function(...args) {
    return sendTyping(this._client, ...args);
  };
  TelegramClient$1.prototype.sendVote = function(...args) {
    return sendVote(this._client, ...args);
  };
  TelegramClient$1.prototype.translateMessage = function(...args) {
    return translateMessage(this._client, ...args);
  };
  TelegramClient$1.prototype.translateText = function(...args) {
    return translateText(this._client, ...args);
  };
  TelegramClient$1.prototype.unpinAllMessages = function(...args) {
    return unpinAllMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.unpinMessage = function(...args) {
    return unpinMessage(this._client, ...args);
  };
  TelegramClient$1.prototype.getCollectibleInfo = function(...args) {
    return getCollectibleInfo(this._client, ...args);
  };
  TelegramClient$1.prototype.initTakeoutSession = function(...args) {
    return initTakeoutSession(this._client, ...args);
  };
  TelegramClient$1.prototype._normalizePrivacyRules = function(...args) {
    return _normalizePrivacyRules(this._client, ...args);
  };
  TelegramClient$1.prototype.changeCloudPassword = function(...args) {
    return changeCloudPassword(this._client, ...args);
  };
  TelegramClient$1.prototype.enableCloudPassword = function(...args) {
    return enableCloudPassword(this._client, ...args);
  };
  TelegramClient$1.prototype.verifyPasswordEmail = function(...args) {
    return verifyPasswordEmail(this._client, ...args);
  };
  TelegramClient$1.prototype.resendPasswordEmail = function(...args) {
    return resendPasswordEmail(this._client, ...args);
  };
  TelegramClient$1.prototype.cancelPasswordEmail = function(...args) {
    return cancelPasswordEmail(this._client, ...args);
  };
  TelegramClient$1.prototype.removeCloudPassword = function(...args) {
    return removeCloudPassword(this._client, ...args);
  };
  TelegramClient$1.prototype.acceptStarGift = function(...args) {
    return acceptStarGift(this._client, ...args);
  };
  TelegramClient$1.prototype.applyBoost = function(...args) {
    return applyBoost(this._client, ...args);
  };
  TelegramClient$1.prototype.canApplyBoost = function(...args) {
    return canApplyBoost(this._client, ...args);
  };
  TelegramClient$1.prototype.createBusinessChatLink = function(...args) {
    return createBusinessChatLink(this._client, ...args);
  };
  TelegramClient$1.prototype.editBusinessChatLink = function(...args) {
    return editBusinessChatLink(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteBusinessChatLink = function(...args) {
    return deleteBusinessChatLink(this._client, ...args);
  };
  TelegramClient$1.prototype.getBoostStats = function(...args) {
    return getBoostStats(this._client, ...args);
  };
  TelegramClient$1.prototype.getBoosts = function(...args) {
    return getBoosts(this._client, ...args);
  };
  TelegramClient$1.prototype.getBusinessChatLinks = function(...args) {
    return getBusinessChatLinks(this._client, ...args);
  };
  TelegramClient$1.prototype.getBusinessConnection = function(...args) {
    return getBusinessConnection(this._client, ...args);
  };
  TelegramClient$1.prototype.getMyBoostSlots = function(...args) {
    return getMyBoostSlots(this._client, ...args);
  };
  TelegramClient$1.prototype.getStarGiftOptions = function(...args) {
    return getStarGiftOptions(this._client, ...args);
  };
  TelegramClient$1.prototype.getStarGifts = function(...args) {
    return getStarGifts(this._client, ...args);
  };
  TelegramClient$1.prototype.getStarsTransactions = function(...args) {
    return getStarsTransactions(this._client, ...args);
  };
  TelegramClient$1.prototype.iterBoosters = function(...args) {
    return iterBoosters(this._client, ...args);
  };
  TelegramClient$1.prototype.iterStarGifts = function(...args) {
    return iterStarGifts(this._client, ...args);
  };
  TelegramClient$1.prototype.iterStarsTransactions = function(...args) {
    return iterStarsTransactions(this._client, ...args);
  };
  TelegramClient$1.prototype.sendStarGift = function(...args) {
    return sendStarGift(this._client, ...args);
  };
  TelegramClient$1.prototype.setBusinessIntro = function(...args) {
    return setBusinessIntro(this._client, ...args);
  };
  TelegramClient$1.prototype.setBusinessWorkHours = function(...args) {
    return setBusinessWorkHours(this._client, ...args);
  };
  TelegramClient$1.prototype.addStickerToSet = function(...args) {
    return addStickerToSet(this._client, ...args);
  };
  TelegramClient$1.prototype.createStickerSet = function(...args) {
    return createStickerSet(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteStickerFromSet = function(...args) {
    return deleteStickerFromSet(this._client, ...args);
  };
  TelegramClient$1.prototype.getCustomEmojis = function(...args) {
    return getCustomEmojis(this._client, ...args);
  };
  TelegramClient$1.prototype.getCustomEmojisFromMessages = function(...args) {
    return getCustomEmojisFromMessages(this._client, ...args);
  };
  TelegramClient$1.prototype.getInstalledStickers = function(...args) {
    return getInstalledStickers(this._client, ...args);
  };
  TelegramClient$1.prototype.getMyStickerSets = function(...args) {
    return getMyStickerSets(this._client, ...args);
  };
  TelegramClient$1.prototype.getStickerSet = function(...args) {
    return getStickerSet(this._client, ...args);
  };
  TelegramClient$1.prototype.moveStickerInSet = function(...args) {
    return moveStickerInSet(this._client, ...args);
  };
  TelegramClient$1.prototype.replaceStickerInSet = function(...args) {
    return replaceStickerInSet(this._client, ...args);
  };
  TelegramClient$1.prototype.setChatStickerSet = function(...args) {
    return setChatStickerSet(this._client, ...args);
  };
  TelegramClient$1.prototype.setStickerSetThumb = function(...args) {
    return setStickerSetThumb(this._client, ...args);
  };
  TelegramClient$1.prototype.canSendStory = function(...args) {
    return canSendStory(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteStories = function(...args) {
    return deleteStories(this._client, ...args);
  };
  TelegramClient$1.prototype.editStory = function(...args) {
    return editStory(this._client, ...args);
  };
  TelegramClient$1.prototype.getAllStories = function(...args) {
    return getAllStories(this._client, ...args);
  };
  TelegramClient$1.prototype.getPeerStories = function(...args) {
    return getPeerStories(this._client, ...args);
  };
  TelegramClient$1.prototype.getProfileStories = function(...args) {
    return getProfileStories(this._client, ...args);
  };
  TelegramClient$1.prototype.getStoriesById = function(...args) {
    return getStoriesById(this._client, ...args);
  };
  TelegramClient$1.prototype.getStoriesInteractions = function(...args) {
    return getStoriesInteractions(this._client, ...args);
  };
  TelegramClient$1.prototype.getStoryLink = function(...args) {
    return getStoryLink(this._client, ...args);
  };
  TelegramClient$1.prototype.getStoryViewers = function(...args) {
    return getStoryViewers(this._client, ...args);
  };
  TelegramClient$1.prototype.hideMyStoriesViews = function(...args) {
    return hideMyStoriesViews(this._client, ...args);
  };
  TelegramClient$1.prototype.incrementStoriesViews = function(...args) {
    return incrementStoriesViews(this._client, ...args);
  };
  TelegramClient$1.prototype.iterAllStories = function(...args) {
    return iterAllStories(this._client, ...args);
  };
  TelegramClient$1.prototype.iterProfileStories = function(...args) {
    return iterProfileStories(this._client, ...args);
  };
  TelegramClient$1.prototype.iterStoryViewers = function(...args) {
    return iterStoryViewers(this._client, ...args);
  };
  TelegramClient$1.prototype.readStories = function(...args) {
    return readStories(this._client, ...args);
  };
  TelegramClient$1.prototype.sendStoryReaction = function(...args) {
    return sendStoryReaction(this._client, ...args);
  };
  TelegramClient$1.prototype.sendStory = function(...args) {
    return sendStory(this._client, ...args);
  };
  TelegramClient$1.prototype.togglePeerStoriesArchived = function(...args) {
    return togglePeerStoriesArchived(this._client, ...args);
  };
  TelegramClient$1.prototype.toggleStoriesPinned = function(...args) {
    return toggleStoriesPinned(this._client, ...args);
  };
  TelegramClient$1.prototype.blockUser = function(...args) {
    return blockUser(this._client, ...args);
  };
  TelegramClient$1.prototype.deleteProfilePhotos = function(...args) {
    return deleteProfilePhotos(this._client, ...args);
  };
  TelegramClient$1.prototype.editCloseFriendsRaw = function(...args) {
    return editCloseFriendsRaw(this._client, ...args);
  };
  TelegramClient$1.prototype.editCloseFriends = function(...args) {
    return editCloseFriends(this._client, ...args);
  };
  TelegramClient$1.prototype.getCommonChats = function(...args) {
    return getCommonChats(this._client, ...args);
  };
  TelegramClient$1.prototype.getGlobalTtl = function(...args) {
    return getGlobalTtl(this._client, ...args);
  };
  TelegramClient$1.prototype.getMe = function(...args) {
    return getMe(this._client, ...args);
  };
  TelegramClient$1.prototype.getMyUsername = function(...args) {
    return getMyUsername(this._client, ...args);
  };
  TelegramClient$1.prototype.getProfilePhoto = function(...args) {
    return getProfilePhoto(this._client, ...args);
  };
  TelegramClient$1.prototype.getProfilePhotos = function(...args) {
    return getProfilePhotos(this._client, ...args);
  };
  TelegramClient$1.prototype.getUsers = function(...args) {
    return getUsers(this._client, ...args);
  };
  TelegramClient$1.prototype.isPeerAvailable = function(...args) {
    return isPeerAvailable(this._client, ...args);
  };
  TelegramClient$1.prototype.iterProfilePhotos = function(...args) {
    return iterProfilePhotos(this._client, ...args);
  };
  TelegramClient$1.prototype.resolvePeerMany = function(...args) {
    return resolvePeerMany(this._client, ...args);
  };
  TelegramClient$1.prototype.resolvePeer = function(...args) {
    return resolvePeer(this._client, ...args);
  };
  TelegramClient$1.prototype.resolveUser = function(...args) {
    return resolveUser(this._client, ...args);
  };
  TelegramClient$1.prototype.resolveChannel = function(...args) {
    return resolveChannel(this._client, ...args);
  };
  TelegramClient$1.prototype.setGlobalTtl = function(...args) {
    return setGlobalTtl(this._client, ...args);
  };
  TelegramClient$1.prototype.setMyBirthday = function(...args) {
    return setMyBirthday(this._client, ...args);
  };
  TelegramClient$1.prototype.setMyEmojiStatus = function(...args) {
    return setMyEmojiStatus(this._client, ...args);
  };
  TelegramClient$1.prototype.setMyProfilePhoto = function(...args) {
    return setMyProfilePhoto(this._client, ...args);
  };
  TelegramClient$1.prototype.setMyUsername = function(...args) {
    return setMyUsername(this._client, ...args);
  };
  TelegramClient$1.prototype.setOffline = function(...args) {
    return setOffline(this._client, ...args);
  };
  TelegramClient$1.prototype.unblockUser = function(...args) {
    return unblockUser(this._client, ...args);
  };
  TelegramClient$1.prototype.updateProfile = function(...args) {
    return updateProfile(this._client, ...args);
  };
  TelegramClient$1.prototype.prepare = function(...args) {
    return this._client.prepare(...args);
  };
  TelegramClient$1.prototype.connect = function(...args) {
    return this._client.connect(...args);
  };
  TelegramClient$1.prototype.close = function(...args) {
    return this._client.close(...args);
  };
  TelegramClient$1.prototype.notifyLoggedIn = function(...args) {
    return this._client.notifyLoggedIn(...args);
  };
  TelegramClient$1.prototype.notifyLoggedOut = function(...args) {
    return this._client.notifyLoggedOut(...args);
  };
  TelegramClient$1.prototype.notifyChannelOpened = function(...args) {
    return this._client.notifyChannelOpened(...args);
  };
  TelegramClient$1.prototype.notifyChannelClosed = function(...args) {
    return this._client.notifyChannelClosed(...args);
  };
  TelegramClient$1.prototype.startUpdatesLoop = function(...args) {
    return this._client.startUpdatesLoop(...args);
  };
  TelegramClient$1.prototype.stopUpdatesLoop = function(...args) {
    return this._client.stopUpdatesLoop(...args);
  };
  TelegramClient$1.prototype.call = function(...args) {
    return this._client.call(...args);
  };
  TelegramClient$1.prototype.importSession = function(...args) {
    return this._client.importSession(...args);
  };
  TelegramClient$1.prototype.exportSession = function(...args) {
    return this._client.exportSession(...args);
  };
  TelegramClient$1.prototype.onError = function(...args) {
    return this._client.onError(...args);
  };
  TelegramClient$1.prototype.emitError = function(...args) {
    return this._client.emitError(...args);
  };
  TelegramClient$1.prototype.handleClientUpdate = function(...args) {
    return this._client.handleClientUpdate(...args);
  };
  TelegramClient$1.prototype.getApiCrenetials = function(...args) {
    return this._client.getApiCrenetials(...args);
  };
  TelegramClient$1.prototype.getPoolSize = function(...args) {
    return this._client.getPoolSize(...args);
  };
  TelegramClient$1.prototype.getPrimaryDcId = function(...args) {
    return this._client.getPrimaryDcId(...args);
  };
  TelegramClient$1.prototype.computeSrpParams = function(...args) {
    return this._client.computeSrpParams(...args);
  };
  TelegramClient$1.prototype.computeNewPasswordHash = function(...args) {
    return this._client.computeNewPasswordHash(...args);
  };
  TelegramClient$1.prototype.onConnectionState = function(...args) {
    return this._client.onConnectionState(...args);
  };
  TelegramClient$1.prototype.getServerUpdateHandler = function(...args) {
    return this._client.getServerUpdateHandler(...args);
  };
  TelegramClient$1.prototype.changePrimaryDc = function(...args) {
    return this._client.changePrimaryDc(...args);
  };
  TelegramClient$1.prototype.getMtprotoMessageId = function(...args) {
    return this._client.getMtprotoMessageId(...args);
  };
  TelegramClient$1.prototype.onServerUpdate = function() {
    throw new Error("onServerUpdate is not available for TelegramClient, use .on() methods instead");
  };
  TelegramClient$1.prototype.onUpdate = function() {
    throw new Error("onUpdate is not available for TelegramClient, use .on() methods instead");
  };
  class WebCryptoProvider {
    constructor() {
      __publicField(this, "instance");
    }
    initialize() {
      return __async(this, null, function* () {
        {
          const m2 = yield Promise.resolve().then(function() {
            return crypto;
          });
          this.instance = new m2.AsmCryptoProvider();
        }
        yield this.instance.initialize();
      });
    }
    pbkdf2(password, salt, iterations, keylen, algo) {
      return this.instance.pbkdf2(password, salt, iterations, keylen, algo);
    }
    createAesCtr(key, iv) {
      return this.instance.createAesCtr(key, iv);
    }
    createAesIge(key, iv) {
      return this.instance.createAesIge(key, iv);
    }
    factorizePQ(pq) {
      return this.instance.factorizePQ(pq);
    }
    gzip(data2, maxSize) {
      return this.instance.gzip(data2, maxSize);
    }
    gunzip(data2) {
      return this.instance.gunzip(data2);
    }
    randomFill(buf) {
      return this.instance.randomFill(buf);
    }
    randomBytes(size) {
      return this.instance.randomBytes(size);
    }
    sha1(data2) {
      return this.instance.sha1(data2);
    }
    sha256(data2) {
      return this.instance.sha256(data2);
    }
    hmacSha256(data2, key) {
      return this.instance.hmacSha256(data2, key);
    }
  }
  class BaseStorageDriver {
    constructor() {
      __publicField(this, "_loadedTimes", 0);
      __publicField(this, "_destroyed", false);
      __publicField(this, "_log");
    }
    setup(log) {
      this._log = log.create("sqlite");
    }
    get loaded() {
      return this._loadedTimes > 0;
    }
    load() {
      return __async(this, null, function* () {
        if (this._loadedTimes === 0) {
          yield this._load();
          this._destroyed = false;
        }
        this._loadedTimes++;
      });
    }
    destroy() {
      return __async(this, null, function* () {
        if (this._destroyed) {
          return;
        }
        this._loadedTimes--;
        if (this._loadedTimes === 0) {
          yield this._destroy();
          this._destroyed = true;
        }
      });
    }
    save() {
      var _a2;
      return (_a2 = this._save) == null ? void 0 : _a2.call(this);
    }
  }
  function txToPromise(tx) {
    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }
  function reqToPromise(req) {
    return new Promise((resolve, reject) => {
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  const REPO_VERSION_PREFIX = "__version:";
  class IdbStorageDriver extends BaseStorageDriver {
    constructor(_dbName) {
      super();
      __publicField(this, "db");
      __publicField(this, "_pendingWrites", []);
      __publicField(this, "_pendingWritesOses", /* @__PURE__ */ new Set());
      __publicField(this, "_migrations", /* @__PURE__ */ new Map());
      __publicField(this, "_maxVersion", /* @__PURE__ */ new Map());
      this._dbName = _dbName;
      if (typeof indexedDB === "undefined") {
        throw new MtUnsupportedError("IndexedDB is not available");
      }
    }
    registerMigration(repo, version2, migration) {
      var _a2;
      if (this.loaded) {
        throw new Error("Cannot register migrations after loading");
      }
      let map = this._migrations.get(repo);
      if (!map) {
        map = /* @__PURE__ */ new Map();
        this._migrations.set(repo, map);
      }
      if (map.has(version2)) {
        throw new Error(`Migration for ${repo} version ${version2} is already registered`);
      }
      map.set(version2, migration);
      const prevMax = (_a2 = this._maxVersion.get(repo)) != null ? _a2 : 0;
      if (version2 > prevMax) {
        this._maxVersion.set(repo, version2);
      }
    }
    writeLater(os, obj) {
      this._pendingWrites.push([os, obj]);
      this._pendingWritesOses.add(os);
    }
    _load() {
      return __async(this, null, function* () {
        this.db = yield new Promise((resolve, reject) => {
          const req = indexedDB.open(this._dbName, Date.now());
          req.onerror = () => reject(req.error);
          const postUpgrade = [];
          req.onsuccess = () => __async(this, null, function* () {
            try {
              for(let   cb of postUpgrade) {
                yield cb(req.result);
              }
              resolve(req.result);
            } catch (e) {
              reject(e);
            }
          });
          req.onupgradeneeded = () => {
            const db = req.result;
            const didUpgrade = /* @__PURE__ */ new Set();
            const doUpgrade = (repo, fromVersion) => {
              const migrations = this._migrations.get(repo);
              if (!migrations)
                return;
              const targetVer = this._maxVersion.get(repo);
              while (fromVersion < targetVer) {
                const nextVersion = fromVersion + 1;
                const migration = migrations.get(nextVersion);
                if (!migration) {
                  throw new Error(`No migration for ${repo} to version ${nextVersion}`);
                }
                const result = migration(db);
                if (result) {
                  postUpgrade.push(result);
                }
                fromVersion = nextVersion;
              }
              didUpgrade.add(repo);
              db.createObjectStore(`${REPO_VERSION_PREFIX}${repo}:${targetVer}`);
            };
            for(let   key of db.objectStoreNames) {
              if (!key.startsWith(REPO_VERSION_PREFIX))
                continue;
              const [, repo, version2] = key.split(":");
              const currentVer = Number(version2);
              db.deleteObjectStore(key);
              doUpgrade(repo, currentVer);
              didUpgrade.add(repo);
            }
            for(let   repo of this._migrations.keys()) {
              if (didUpgrade.has(repo))
                continue;
              doUpgrade(repo, 0);
            }
          };
        });
      });
    }
    _save() {
      return __async(this, null, function* () {
        if (this._pendingWritesOses.size === 0)
          return;
        const writes = this._pendingWrites;
        const oses = this._pendingWritesOses;
        this._pendingWrites = [];
        this._pendingWritesOses = /* @__PURE__ */ new Set();
        const tx = this.db.transaction(oses, "readwrite");
        const osMap = /* @__PURE__ */ new Map();
        for(let   table of oses) {
          osMap.set(table, tx.objectStore(table));
        }
        for(let   [table, obj] of writes) {
          const os = osMap.get(table);
          if (obj === null) {
            os.delete(table);
          } else {
            os.put(obj);
          }
        }
        yield txToPromise(tx);
      });
    }
    _destroy() {
      this.db.close();
    }
  }
  const TABLE_AUTH_KEYS = "authKeys";
  const TABLE_TEMP_AUTH_KEYS = "tempAuthKeys";
  class IdbAuthKeysRepository {
    constructor(_driver) {
      this._driver = _driver;
      _driver.registerMigration(TABLE_AUTH_KEYS, 1, (db) => {
        db.createObjectStore(TABLE_AUTH_KEYS, { keyPath: "dc" });
        db.createObjectStore(TABLE_TEMP_AUTH_KEYS, { keyPath: ["dc", "idx"] });
      });
    }
    os(mode) {
      return this._driver.db.transaction(TABLE_AUTH_KEYS, mode).objectStore(TABLE_AUTH_KEYS);
    }
    set(dc, key) {
      return __async(this, null, function* () {
        const os = this.os("readwrite");
        if (key === null) {
          return reqToPromise(os.delete(dc));
        }
        yield reqToPromise(os.put({ dc, key }));
      });
    }
    get(dc) {
      return __async(this, null, function* () {
        const os = this.os();
        const it = yield reqToPromise(os.get(dc));
        if (it === void 0)
          return null;
        return it.key;
      });
    }
    osTemp(mode) {
      return this._driver.db.transaction(TABLE_TEMP_AUTH_KEYS, mode).objectStore(TABLE_TEMP_AUTH_KEYS);
    }
    setTemp(dc, idx, key, expires) {
      return __async(this, null, function* () {
        const os = this.osTemp("readwrite");
        if (!key) {
          return reqToPromise(os.delete([dc, idx]));
        }
        yield reqToPromise(os.put({ dc, idx, key, expiresAt: expires }));
      });
    }
    getTemp(dc, idx, now) {
      return __async(this, null, function* () {
        const os = this.osTemp();
        const row = yield reqToPromise(os.get([dc, idx]));
        if (row === void 0 || row.expiresAt < now)
          return null;
        return row.key;
      });
    }
    deleteByDc(dc) {
      return __async(this, null, function* () {
        return new Promise((res) => {
          const tx = this._driver.db.transaction([TABLE_AUTH_KEYS, TABLE_TEMP_AUTH_KEYS], "readwrite");
          tx.objectStore(TABLE_AUTH_KEYS).delete(dc);
          const tempOs = tx.objectStore(TABLE_TEMP_AUTH_KEYS);
          const keys2 = tempOs.getAllKeys();
          keys2.onsuccess = () => {
            for(let   key of keys2.result) {
              if (key[0] === dc) {
                tempOs.delete(key);
              }
            }
            res(txToPromise(tx));
          };
        });
      });
    }
    deleteAll() {
      const tx = this._driver.db.transaction([TABLE_AUTH_KEYS, TABLE_TEMP_AUTH_KEYS], "readwrite");
      tx.objectStore(TABLE_AUTH_KEYS).clear();
      tx.objectStore(TABLE_TEMP_AUTH_KEYS).clear();
      return txToPromise(tx);
    }
  }
  const KV_TABLE = "kv";
  class IdbKvRepository {
    constructor(_driver) {
      this._driver = _driver;
      _driver.registerMigration(KV_TABLE, 1, (db) => {
        db.createObjectStore(KV_TABLE, { keyPath: "key" });
      });
    }
    set(key, value) {
      this._driver.writeLater(KV_TABLE, { key, value });
    }
    os(mode) {
      return this._driver.db.transaction(KV_TABLE, mode).objectStore(KV_TABLE);
    }
    get(key) {
      return __async(this, null, function* () {
        const os = this.os();
        const res = yield reqToPromise(os.get(key));
        if (res === void 0)
          return null;
        return res.value;
      });
    }
    delete(key) {
      return __async(this, null, function* () {
        yield reqToPromise(this.os("readwrite").delete(key));
      });
    }
    deleteAll() {
      return __async(this, null, function* () {
        yield reqToPromise(this.os("readwrite").clear());
      });
    }
  }
  const TABLE$1 = "peers";
  class IdbPeersRepository {
    constructor(_driver) {
      this._driver = _driver;
      _driver.registerMigration(TABLE$1, 1, (db) => {
        const os = db.createObjectStore(TABLE$1, { keyPath: "id" });
        os.createIndex("by_username", "usernames", { unique: true, multiEntry: true });
        os.createIndex("by_phone", "phone", { unique: true });
      });
    }
    store(peer) {
      this._driver.writeLater(TABLE$1, peer);
    }
    os(mode) {
      return this._driver.db.transaction(TABLE$1, mode).objectStore(TABLE$1);
    }
    getById(id2, allowMin) {
      return __async(this, null, function* () {
        const it = yield reqToPromise(this.os().get(id2));
        if (!it)
          return null;
        if (it.isMin && !allowMin)
          return null;
        return it;
      });
    }
    getByUsername(username) {
      return __async(this, null, function* () {
        const it = yield reqToPromise(
          this.os().index("by_username").get(username)
        );
        if (!it || it.isMin)
          return null;
        return it;
      });
    }
    getByPhone(phone) {
      return __async(this, null, function* () {
        const it = yield reqToPromise(this.os().index("by_phone").get(phone));
        if (!it || it.isMin)
          return null;
        return it;
      });
    }
    deleteAll() {
      return reqToPromise(this.os("readwrite").clear());
    }
  }
  const TABLE = "messageRefs";
  class IdbRefMsgRepository {
    constructor(_driver) {
      this._driver = _driver;
      _driver.registerMigration(TABLE, 1, (db) => {
        const os = db.createObjectStore(TABLE, { keyPath: ["peerId", "chatId", "msgId"] });
        os.createIndex("by_peer", "peerId");
        os.createIndex("by_msg", ["chatId", "msgId"]);
      });
    }
    os(mode) {
      return this._driver.db.transaction(TABLE, mode).objectStore(TABLE);
    }
    store(peerId, chatId, msgId) {
      return __async(this, null, function* () {
        const os = this.os("readwrite");
        yield reqToPromise(os.put({ peerId, chatId, msgId }));
      });
    }
    getByPeer(peerId) {
      return __async(this, null, function* () {
        const os = this.os();
        const index = os.index("by_peer");
        const it = yield reqToPromise(index.get(peerId));
        if (!it)
          return null;
        return [it.chatId, it.msgId];
      });
    }
    delete(chatId, msgIds) {
      return __async(this, null, function* () {
        const tx = this._driver.db.transaction(TABLE, "readwrite");
        const os = tx.objectStore(TABLE);
        const index = os.index("by_msg");
        for(let   msgId of msgIds) {
          const req = index.getAllKeys([chatId, msgId]);
          req.onsuccess = () => {
            for(let   key of req.result) {
              os.delete(key);
            }
          };
        }
        return txToPromise(tx);
      });
    }
    deleteByPeer(peerId) {
      return __async(this, null, function* () {
        const tx = this._driver.db.transaction(TABLE, "readwrite");
        const os = tx.objectStore(TABLE);
        const index = os.index("by_peer");
        const req = index.openCursor(peerId);
        req.onsuccess = () => {
          if (req.result) {
            req.result.delete();
            req.result.continue();
          }
        };
        return txToPromise(tx);
      });
    }
    deleteAll() {
      return __async(this, null, function* () {
        yield reqToPromise(this.os("readwrite").clear());
      });
    }
  }
  class IdbStorage {
    constructor(dbName) {
      __publicField(this, "driver");
      __publicField(this, "kv");
      __publicField(this, "authKeys");
      __publicField(this, "peers");
      __publicField(this, "refMessages");
      this.dbName = dbName;
      this.driver = new IdbStorageDriver(this.dbName);
      this.kv = new IdbKvRepository(this.driver);
      this.authKeys = new IdbAuthKeysRepository(this.driver);
      this.peers = new IdbPeersRepository(this.driver);
      this.refMessages = new IdbRefMsgRepository(this.driver);
    }
  }
  const lookup = [];
  const revLookup = [];
  const code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (let i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  function getLens(b64) {
    const len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    let validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len;
    const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64, arr) {
    let tmp;
    const lens = getLens(b64);
    const validLen = lens[0];
    const placeHoldersLen = lens[1];
    let curByte = 0;
    const len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    let i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start2, end) {
    let tmp;
    const output = [];
    for (let i = start2; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    let tmp;
    const len = uint8.length;
    const extraBytes = len % 3;
    const parts = [];
    const maxChunkLength = 16383;
    for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(`${lookup[tmp >> 2] + lookup[tmp << 4 & 63]}==`);
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(`${lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63]}=`);
    }
    return parts.join("");
  }
  function base64Encode(buf, url = false) {
    const str = fromByteArray(buf);
    if (url)
      return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return str;
  }
  function base64Decode(string, url = false) {
    if (url) {
      string = string.replace(/-/g, "+").replace(/_/g, "/");
      while (string.length % 4)
        string += "=";
    }
    const buf = new Uint8Array(_byteLength(string, ...getLens(string)));
    toByteArray(string, buf);
    return buf;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = Array.from({ length: 256 });
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  const hexCharValueTable = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15
  };
  function hexEncode(buf) {
    let out = "";
    for (let i = 0; i < buf.byteLength; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function hexDecodeInner(buf, string) {
    const strLen = string.length;
    const length = Math.min(buf.length, strLen / 2);
    let i;
    for (i = 0; i < length; ++i) {
      const a = hexCharValueTable[string[i * 2]];
      const b = hexCharValueTable[string[i * 2 + 1]];
      if (a === void 0 || b === void 0) {
        return;
      }
      buf[i] = a << 4 | b;
    }
  }
  function hexDecode(string) {
    const buf = new Uint8Array(Math.ceil(string.length / 2));
    hexDecodeInner(buf, string);
    return buf;
  }
  const BASE_FORMAT = "%s [%c%s%c] [%c%s%c] ";
  const LEVEL_NAMES = [
    "",
    // OFF
    "ERR",
    "WRN",
    "INF",
    "DBG",
    "VRB"
  ];
  const COLORS = [
    "",
    // OFF
    "color: #7a5f9d",
    "color: #8d7041",
    "color: #396c9e",
    "color: #437761",
    "color: #7a5f9d"
  ];
  const TAG_COLORS = [
    "color: #437761",
    "color: #537a36",
    "color: #8d7041",
    "color: #396c9e",
    "color: #7a5f9d",
    "color: #7a5f9d"
  ];
  const defaultLoggingHandler = (color, level, tag, fmt, args) => {
    console.log(
      BASE_FORMAT + fmt,
      (/* @__PURE__ */ new Date()).toISOString(),
      COLORS[level],
      LEVEL_NAMES[level],
      "",
      TAG_COLORS[color],
      tag,
      "",
      ...args
    );
  };
  const sharedEncoder = new TextEncoder();
  const sharedDecoder = new TextDecoder("utf8");
  function utf8ByteLength(str) {
    let s = str.length;
    for (let i = str.length - 1; i >= 0; i--) {
      const code2 = str.charCodeAt(i);
      if (code2 > 127 && code2 <= 2047)
        s++;
      else if (code2 > 2047 && code2 <= 65535)
        s += 2;
      if (code2 >= 56320 && code2 <= 57343)
        i--;
    }
    return s;
  }
  function utf8Decode(buf) {
    return sharedDecoder.decode(buf);
  }
  function utf8Encode(str) {
    return sharedEncoder.encode(str);
  }
  const callbacks = /* @__PURE__ */ new Set();
  let registered = false;
  function beforeExit(fn) {
    if (typeof window === "undefined") {
      return () => {
      };
    }
    if (!registered) {
      registered = true;
      window.addEventListener("beforeunload", () => {
        for(let   callback of callbacks) {
          callback();
        }
      });
    }
    callbacks.add(fn);
    return () => {
      callbacks.delete(fn);
    };
  }
  class WebPlatform {
    getDeviceModel() {
      if (typeof navigator === "undefined")
        return "Browser";
      return navigator.userAgent;
    }
    getDefaultLogLevel() {
      if (typeof localStorage !== "undefined") {
        const localLogLevel = Number.parseInt(localStorage.MTCUTE_LOG_LEVEL);
        if (!Number.isNaN(localLogLevel)) {
          return localLogLevel;
        }
      }
      return null;
    }
    onNetworkChanged(fn) {
      if (!("onLine" in navigator))
        return () => {
        };
      const onlineHandler = () => fn(navigator.onLine);
      window.addEventListener("online", onlineHandler);
      window.addEventListener("offline", onlineHandler);
      return () => {
        window.removeEventListener("online", onlineHandler);
        window.removeEventListener("offline", onlineHandler);
      };
    }
    isOnline() {
      return navigator.onLine;
    }
  }
  WebPlatform.prototype.log = defaultLoggingHandler;
  WebPlatform.prototype.beforeExit = beforeExit;
  WebPlatform.prototype.utf8ByteLength = utf8ByteLength;
  WebPlatform.prototype.utf8Encode = utf8Encode;
  WebPlatform.prototype.utf8Decode = utf8Decode;
  WebPlatform.prototype.hexEncode = hexEncode;
  WebPlatform.prototype.hexDecode = hexDecode;
  WebPlatform.prototype.base64Encode = base64Encode;
  WebPlatform.prototype.base64Decode = base64Decode;
  const subdomainsMap = {
    1: "pluto",
    2: "venus",
    3: "aurora",
    4: "vesta",
    5: "flora"
  };
  class BaseWebSocketTransport extends EventEmitter {
    constructor({
      ws = WebSocket,
      baseDomain = "web.telegram.org",
      subdomains = subdomainsMap
    } = {}) {
      ws = ws != null ? ws : WebSocket;
      baseDomain = baseDomain != null ? baseDomain : "web.telegram.org";
      subdomains = subdomains != null ? subdomains : subdomainsMap;
      super();
      __publicField(this, "_currentDc", null);
      __publicField(this, "_state", TransportState.Idle);
      __publicField(this, "_socket", null);
      __publicField(this, "_crypto");
      __publicField(this, "log");
      __publicField(this, "packetCodecInitialized", false);
      __publicField(this, "_baseDomain");
      __publicField(this, "_subdomains");
      __publicField(this, "_WebSocket");
      __publicField(this, "_closeWaiters", []);
      if (!ws) {
        throw new MtUnsupportedError(
          "To use WebSocket transport with NodeJS, install `ws` package and pass it to constructor"
        );
      }
      if ("default" in ws) {
        ws = ws.default;
      }
      this._baseDomain = baseDomain;
      this._subdomains = subdomains;
      this._WebSocket = ws;
    }
    _updateLogPrefix() {
      if (this._currentDc) {
        this.log.prefix = `[WS:${this._subdomains[this._currentDc.id]}.${this._baseDomain}] `;
      } else {
        this.log.prefix = "[WS:disconnected] ";
      }
    }
    setup(crypto2, log) {
      this._crypto = crypto2;
      this.log = log.create("ws");
    }
    state() {
      return this._state;
    }
    currentDc() {
      return this._currentDc;
    }
    connect(dc, testMode) {
      var _a2, _b;
      if (this._state !== TransportState.Idle) {
        throw new MtcuteError("Transport is not IDLE");
      }
      if (!this.packetCodecInitialized) {
        (_b = (_a2 = this._packetCodec).setup) == null ? void 0 : _b.call(_a2, this._crypto, this.log);
        this._packetCodec.on("error", (err2) => this.emit("error", err2));
        this._packetCodec.on("packet", (buf) => this.emit("message", buf));
        this.packetCodecInitialized = true;
      }
      this._state = TransportState.Connecting;
      this._currentDc = dc;
      this._socket = new this._WebSocket(
        `wss://${this._subdomains[dc.id]}.${this._baseDomain}/apiws${testMode ? "_test" : ""}`,
        "binary"
      );
      this._updateLogPrefix();
      this.log.debug("connecting to %s (%j)", this._socket.url, dc);
      this._socket.binaryType = "arraybuffer";
      this._socket.addEventListener("message", (evt) => this._packetCodec.feed(new Uint8Array(evt.data)));
      this._socket.addEventListener("open", this.handleConnect.bind(this));
      this._socket.addEventListener("error", this.handleError.bind(this));
      this._socket.addEventListener("close", this.handleClosed.bind(this));
    }
    close() {
      return __async(this, null, function* () {
        if (this._state === TransportState.Idle)
          return;
        const promise = createControllablePromise();
        this._closeWaiters.push(promise);
        this._socket.close();
        return promise;
      });
    }
    handleClosed() {
      this.log.info("connection closed");
      this._state = TransportState.Idle;
      this._socket = null;
      this._currentDc = null;
      this._packetCodec.reset();
      this.emit("close");
      for(let   waiter of this._closeWaiters) {
        waiter.resolve();
      }
      this._closeWaiters = [];
    }
    handleError(event) {
      const error = "error" in event ? event.error : new Error("unknown WebSocket error");
      this.log.error("error: %s", error.stack);
      this.emit("error", error);
    }
    handleConnect() {
      this.log.info("connected");
      Promise.resolve(this._packetCodec.tag()).then((initialMessage) => {
        this._socket.send(initialMessage);
        this._state = TransportState.Ready;
        this.emit("ready");
      }).catch((err2) => this.emit("error", err2));
    }
    send(bytes) {
      return __async(this, null, function* () {
        if (this._state !== TransportState.Ready) {
          throw new MtcuteError("Transport is not READY");
        }
        const framed = yield this._packetCodec.encode(bytes);
        this._socket.send(framed);
      });
    }
  }
  class WebSocketTransport extends BaseWebSocketTransport {
    constructor() {
      super(...arguments);
      __publicField(this, "_packetCodec", new ObfuscatedPacketCodec(new IntermediatePacketCodec()));
    }
  }
  class BaseTelegramClient extends BaseTelegramClient$1 {
    constructor(opts) {
      var _a2;
      if (!opts.platformless)
        setPlatform(new WebPlatform());
      super(__spreadProps(__spreadValues({
        crypto: new WebCryptoProvider(),
        transport: () => new WebSocketTransport()
      }, opts), {
        storage: typeof opts.storage === "string" ? new IdbStorage(opts.storage) : (_a2 = opts.storage) != null ? _a2 : new IdbStorage("client.session")
      }));
    }
  }
  function serializeError(error) {
    if (!(error instanceof Error))
      return { name: "Error", message: String(error) };
    const res = {
      name: "Error",
      message: error.message,
      stack: error.stack
    };
    const ctor = error.constructor;
    if (ctor === MtTypeAssertionError) {
      const _error = error;
      res.name = "MtTypeAssertionError";
      res.custom = {
        context: _error.context,
        expected: _error.expected,
        actual: _error.actual
      };
    } else if (ctor === MtTimeoutError) {
      const _error = error;
      res.name = "MtTimeoutError";
      res.custom = {
        timeout: _error.timeout
      };
    } else if (ctor === MtMessageNotFoundError) {
      const _error = error;
      res.name = "MtMessageNotFoundError";
      res.custom = {
        peerId: _error.peerId,
        messageId: _error.messageId,
        context: _error.context
      };
    } else if (ctor === tl.tl.RpcError) {
      res.name = "RpcError";
      res.custom = __spreadValues({}, error);
    } else if (ctor === MtArgumentError) {
      res.name = "MtArgumentError";
    } else if (ctor === MtSecurityError) {
      res.name = "MtSecurityError";
    } else if (ctor === MtUnsupportedError) {
      res.name = "MtUnsupportedError";
    } else if (ctor === MtPeerNotFoundError) {
      res.name = "MtPeerNotFoundError";
    } else if (ctor === MtInvalidPeerTypeError) {
      res.name = "MtInvalidPeerTypeError";
    } else if (ctor === MtEmptyError) {
      res.name = "MtEmptyError";
    } else if (ctor instanceof MtcuteError) {
      res.name = "MtcuteError";
    }
    return res;
  }
  function serializeResult(result) {
    if (ArrayBuffer.isView(result))
      return result;
    if (Array.isArray(result)) {
      return result.map(serializeResult);
    }
    if (result instanceof Map) {
      for(let   [key, value] of result.entries()) {
        result.set(key, serializeResult(value));
      }
      return result;
    }
    if (result && typeof result === "object") {
      const newResult = {};
      for(let   [key, value] of Object.entries(result)) {
        if (Long.isLong(value)) {
          newResult[key] = {
            __type: "long",
            low: value.low,
            high: value.high,
            unsigned: value.unsigned
          };
        } else if (typeof value === "object") {
          newResult[key] = serializeResult(value);
        } else {
          newResult[key] = value;
        }
      }
      return newResult;
    }
    return result;
  }
  function deserializeResult(result) {
    if (ArrayBuffer.isView(result))
      return result;
    if (Array.isArray(result)) {
      return result.map(deserializeResult);
    }
    if (result instanceof Map) {
      for(let   [key, value] of result.entries()) {
        result.set(key, deserializeResult(value));
      }
      return result;
    }
    if (result && typeof result === "object") {
      for(let   [key, value] of Object.entries(result)) {
        if (value && typeof value === "object" && value.__type === "long") {
          result[key] = Long.fromValue(value);
        } else if (typeof value === "object") {
          result[key] = deserializeResult(value);
        }
      }
    }
    return result;
  }
  let TelegramWorker$1 = class TelegramWorker {
    constructor(params) {
      __publicField(this, "client");
      __publicField(this, "broadcast");
      __publicField(this, "pendingAborts", /* @__PURE__ */ new Map());
      this.params = params;
      this.broadcast = this.registerWorker((message2, respond) => {
        switch (message2.type) {
          case "invoke":
            this.onInvoke(message2, respond);
            break;
          case "abort": {
            const abort = this.pendingAborts.get(message2.id);
            if (abort) {
              abort.abort();
              this.pendingAborts.delete(message2.id);
            }
          }
        }
      });
      const client = params.client;
      this.client = client;
      client.log.mgr.handler = (color, level, tag, fmt, args) => this.broadcast({
        type: "log",
        color,
        level,
        tag,
        fmt,
        args
      });
      client.onError(
        (err2) => this.broadcast({
          type: "error",
          error: err2
        })
      );
      client.onConnectionState(
        (state) => this.broadcast({
          type: "conn_state",
          state
        })
      );
      client.stopSignal.addEventListener("abort", () => this.broadcast({ type: "stop" }));
      if (client.updates) {
        client.onUpdate(
          (update, peers) => this.broadcast({
            type: "update",
            update: serializeResult(update),
            users: serializeResult(peers.users),
            chats: serializeResult(peers.chats),
            hasMin: peers.hasMin
          })
        );
      } else {
        client.onServerUpdate(
          (update) => this.broadcast({
            type: "server_update",
            update: serializeResult(update)
          })
        );
      }
    }
    onInvoke(msg, respond) {
      let target;
      switch (msg.target) {
        case "custom":
          target = this.params.customMethods;
          break;
        case "client":
          target = this.client;
          break;
        case "storage":
          target = this.client.storage;
          break;
        case "storage-self":
          target = this.client.storage.self;
          break;
        case "storage-peers":
          target = this.client.storage.peers;
          break;
        case "app-config":
          target = this.client.appConfig;
          break;
        default: {
          respond({
            type: "result",
            id: msg.id,
            error: new Error(`Unknown target ${msg.target}`)
          });
          return;
        }
      }
      const method = target[msg.method];
      if (!method) {
        respond({
          type: "result",
          id: msg.id,
          error: new Error(`Method ${msg.method} not found on ${msg.target}`)
        });
        return;
      }
      let args;
      if (msg.target === "client" && msg.method === "call" && msg.withAbort) {
        const abort = new AbortController();
        this.pendingAborts.set(msg.id, abort);
        args = [
          deserializeResult(msg.args[0]),
          __spreadProps(__spreadValues({}, msg.args[1]), {
            abortSignal: abort.signal
          })
        ];
      } else {
        args = deserializeResult(msg.args);
      }
      Promise.resolve(method.apply(target, args)).then((res) => {
        if (msg.withAbort) {
          this.pendingAborts.delete(msg.id);
        }
        if (msg.void)
          return;
        respond({
          type: "result",
          id: msg.id,
          result: serializeResult(res)
        });
      }).catch((err2) => {
        if (msg.withAbort) {
          this.pendingAborts.delete(msg.id);
        }
        respond({
          type: "result",
          id: msg.id,
          error: serializeError(err2)
        });
      });
    }
  };
  let _registered = false;
  class TelegramWorker extends TelegramWorker$1 {
    registerWorker(handler) {
      if (_registered) {
        throw new Error("TelegramWorker must be created only once");
      }
      _registered = true;
      if (typeof SharedWorkerGlobalScope !== "undefined" && self instanceof SharedWorkerGlobalScope) {
        const connections = [];
        const broadcast = (message2) => {
          for(let   port of connections) {
            port.postMessage(message2);
          }
        };
        self.onconnect = (event) => {
          const port = event.ports[0];
          connections.push(port);
          const respond = port.postMessage.bind(port);
          const onClose = () => {
            port.close();
            const idx = connections.indexOf(port);
            if (idx >= 0) {
              connections.splice(connections.indexOf(port), 1);
            }
          };
          const onTimeout = () => {
            console.warn("some connection timed out!");
            respond({ __type__: "timeout" });
            onClose();
          };
          let timeout = setTimeout(onTimeout, 6e4);
          port.addEventListener("message", (message2) => {
            if (message2.data.__type__ === "close") {
              onClose();
              return;
            }
            if (message2.data.__type__ === "ping") {
              clearTimeout(timeout);
              timeout = setTimeout(onTimeout, 6e4);
              return;
            }
            handler(message2.data, respond);
          });
          port.start();
        };
        return broadcast;
      }
      if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
        const respond = self.postMessage.bind(self);
        self.addEventListener("message", (message2) => handler(message2.data, respond));
        return respond;
      }
      throw new Error("TelegramWorker must be created from a worker");
    }
  }
  function parseUserAgent(a) {
    let model = navigator.appCodeName;
    try {
      let idx = a.indexOf("Mobile;");
      if (idx != -1) {
        let m2 = a.substring(idx + 8);
        let idx2 = m2.indexOf(")");
        m2 = m2.substring(0, idx2);
        if (m2 != "")
          model = m2;
      }
    } catch (err2) {
    }
    let version2 = "1.0";
    try {
      if (a.indexOf("KAIOS/") > -1) {
        version2 = a.substring(a.indexOf("KAIOS/"));
      } else if (a.indexOf("Firefox/") > -1) {
        version2 = a.substring(a.indexOf("Firefox/"));
      } else if (a.indexOf("Gecko/") > -1) {
        version2 = a.substring(a.indexOf("Gecko/"));
      } else if (a.indexOf("rv:") > -1) {
        let idx = a.indexOf("rv:");
        if (idx != -1) {
          let v = a.substring(idx);
          let idx2 = v.indexOf(")");
          v = v.substring(0, idx2);
          if (v != "")
            version2 = v;
        }
      }
    } catch (err2) {
    }
    return { deviceModel: model, systemVersion: version2 };
  }
  const apiId = 25792998;
  const apiHash = "b3aed8b5d53685566b35d325a67d575c";
  let onLogoutCallback;
  const appVersion = (() => {
    {
      const manifestURL = "/manifest.webapp";
      const xhr = new XMLHttpRequest();
      xhr.open("GET", manifestURL, false);
      xhr.responseType = "json";
      xhr.send();
      const manifest = xhr.response;
      const version2 = manifest.version;
      return version2;
    }
  })();
  const fromUA = parseUserAgent(navigator.userAgent);
  const version = appVersion;
  class KaiPlatform extends WebPlatform {
    onNetworkChanged(fn) {
      return () => {
      };
    }
    isOnline() {
      return true;
    }
  }
  setPlatform(new KaiPlatform());
  const tg = new BaseTelegramClient({
    platformless: true,
    apiId,
    apiHash,
    initConnectionOptions: {
      deviceModel: navigator.userAgent,
      systemVersion: fromUA.systemVersion.replace("/", " "),
      appVersion: version
    },
    // reconnectionStrategy: (params, lastError, consequentFails, previousWait) => {
    // 	// console.error("RECONNECTION STRATEGYYYY", params, lastError, consequentFails, previousWait);
    // 	return defaultReconnectionStrategy(params, lastError, consequentFails, previousWait);
    // },
    testMode: false,
    network: {
      middlewares: [
        (ctx, next) => __async(this, null, function* () {
          const res = yield next(ctx);
          if (isTlRpcError(res) && res.errorMessage == "AUTH_KEY_UNREGISTERED") {
            setTimeout(() => {
              getMe(tg).catch(() => {
                onLogoutCallback();
              });
            }, 3e3);
          }
          return res;
        })
      ]
    },
    logLevel: 3
  });
  Object.assign(self, { tg });
  new TelegramWorker({
    client: tg
  });
  const exposed = {
    setLogoutCallback(cb) {
      onLogoutCallback = cb;
    },
    gzip(data2, maxSize) {
      return tg.crypto.gzip(data2, maxSize != null ? maxSize : Math.floor(data2.length * 0.9));
    },
    gunzip(data2) {
      return tg.crypto.gunzip(data2);
    },
    getAvailableMemory() {
      {
        if ("instance" in tg.crypto) {
          return tg.crypto.instance.getAvailableMemory();
        }
      }
      return null;
    },
    webp(buff2, width, height) {
      {
        if ("instance" in tg.crypto) {
          return tg.crypto.instance.webp(buff2, width, height);
        }
      }
      return null;
    }
  };
  expose(exposed);
  var MtcuteAsmURL = "/assets/mtcute.asm-C1k7DT9Y.js";
  var MtcuteMemURL = "/assets/mtcute.asm.js-UYBqYTqt.mem";
  var bpe = 0;
  var mask = 0;
  var radix = mask + 1;
  var digitsStr = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_=!@#$%^&*()[]{}|;:,.<>/?`~ \\'\"+-";
  for (bpe = 0; 1 << bpe + 1 > 1 << bpe; bpe++) {
  }
  bpe >>= 1;
  mask = (1 << bpe) - 1;
  radix = mask + 1;
  var one = int2bigInt(1, 1, 1);
  int2bigInt(0, 1, 1);
  var t = new Array(0);
  var s6 = t;
  var eg_u = t, eg_A = t, eg_B = t, eg_C = t, eg_D = t;
  var k, buff;
  function eGCD_(x, y, v, a, b) {
    var g = 0;
    var k2 = Math.max(x.length, y.length);
    if (eg_u.length != k2) {
      eg_u = new Array(k2);
      eg_A = new Array(k2);
      eg_B = new Array(k2);
      eg_C = new Array(k2);
      eg_D = new Array(k2);
    }
    while (!(x[0] & 1) && !(y[0] & 1)) {
      halve_(x);
      halve_(y);
      g++;
    }
    copy_(eg_u, x);
    copy_(v, y);
    copyInt_(eg_A, 1);
    copyInt_(eg_B, 0);
    copyInt_(eg_C, 0);
    copyInt_(eg_D, 1);
    for (; ; ) {
      while (!(eg_u[0] & 1)) {
        halve_(eg_u);
        if (!(eg_A[0] & 1) && !(eg_B[0] & 1)) {
          halve_(eg_A);
          halve_(eg_B);
        } else {
          add_(eg_A, y);
          halve_(eg_A);
          sub_(eg_B, x);
          halve_(eg_B);
        }
      }
      while (!(v[0] & 1)) {
        halve_(v);
        if (!(eg_C[0] & 1) && !(eg_D[0] & 1)) {
          halve_(eg_C);
          halve_(eg_D);
        } else {
          add_(eg_C, y);
          halve_(eg_C);
          sub_(eg_D, x);
          halve_(eg_D);
        }
      }
      if (!greater(v, eg_u)) {
        sub_(eg_u, v);
        sub_(eg_A, eg_C);
        sub_(eg_B, eg_D);
      } else {
        sub_(v, eg_u);
        sub_(eg_C, eg_A);
        sub_(eg_D, eg_B);
      }
      if (equalsInt(eg_u, 0)) {
        while (negative(eg_C)) {
          add_(eg_C, y);
          sub_(eg_D, x);
        }
        multInt_(eg_D, -1);
        copy_(a, eg_C);
        copy_(b, eg_D);
        leftShift_(v, g);
        return;
      }
    }
  }
  function negative(x) {
    return x[x.length - 1] >> bpe - 1 & 1;
  }
  function greaterShift(x, y, shift) {
    var i, kx = x.length, ky = y.length;
    k = kx + shift < ky ? kx + shift : ky;
    for (i = ky - 1 - shift; i < kx && i >= 0; i++) {
      if (x[i] > 0)
        return 1;
    }
    for (i = kx - 1 + shift; i < ky; i++) {
      if (y[i] > 0)
        return 0;
    }
    for (i = k - 1; i >= shift; i--) {
      if (x[i - shift] > y[i])
        return 1;
      else if (x[i - shift] < y[i])
        return 0;
    }
    return 0;
  }
  function greater(x, y) {
    var i;
    var k2 = x.length < y.length ? x.length : y.length;
    for (i = x.length; i < y.length; i++) {
      if (y[i])
        return 0;
    }
    for (i = y.length; i < x.length; i++) {
      if (x[i])
        return 1;
    }
    for (i = k2 - 1; i >= 0; i--) {
      if (x[i] > y[i])
        return 1;
      else if (x[i] < y[i])
        return 0;
    }
    return 0;
  }
  function divide_(x, y, q, r) {
    var kx, ky;
    var i, y1, y2, c, a, b;
    copy_(r, x);
    for (ky = y.length; y[ky - 1] === 0; ky--) {
    }
    b = y[ky - 1];
    for (a = 0; b; a++) {
      b >>= 1;
    }
    a = bpe - a;
    leftShift_(y, a);
    leftShift_(r, a);
    for (kx = r.length; r[kx - 1] === 0 && kx > ky; kx--) {
    }
    copyInt_(q, 0);
    while (!greaterShift(y, r, kx - ky)) {
      subShift_(r, y, kx - ky);
      q[kx - ky]++;
    }
    for (i = kx - 1; i >= ky; i--) {
      if (r[i] == y[ky - 1])
        q[i - ky] = mask;
      else
        q[i - ky] = Math.floor((r[i] * radix + r[i - 1]) / y[ky - 1]);
      for (; ; ) {
        y2 = (ky > 1 ? y[ky - 2] : 0) * q[i - ky];
        c = y2 >> bpe;
        y2 = y2 & mask;
        y1 = c + q[i - ky] * y[ky - 1];
        c = y1 >> bpe;
        y1 = y1 & mask;
        if (c == r[i] ? y1 == r[i - 1] ? y2 > (i > 1 ? r[i - 2] : 0) : y1 > r[i - 1] : c > r[i])
          q[i - ky]--;
        else
          break;
      }
      linCombShift_(r, y, -q[i - ky], i - ky);
      if (negative(r)) {
        addShift_(r, y, i - ky);
        q[i - ky]--;
      }
    }
    rightShift_(y, a);
    rightShift_(r, a);
  }
  function int2bigInt(t2, bits2, minSize) {
    var k2;
    k2 = Math.ceil(bits2 / bpe) + 1;
    k2 = minSize > k2 ? minSize : k2;
    var buff2 = new Array(k2);
    copyInt_(buff2, t2);
    return buff2;
  }
  function str2bigInt(s, base, minSize) {
    var d, i, x, y, kk;
    var k2 = s.length;
    x = int2bigInt(0, base * k2, 0);
    for (i = 0; i < k2; i++) {
      d = digitsStr.indexOf(s.substring(i, i + 1), 0);
      if (d >= 36)
        d -= 26;
      if (d >= base || d < 0) {
        break;
      }
      multInt_(x, base);
      addInt_(x, d);
    }
    for (k2 = x.length; k2 > 0 && !x[k2 - 1]; k2--) {
    }
    k2 = minSize > k2 + 1 ? minSize : k2 + 1;
    y = new Array(k2);
    kk = k2 < x.length ? k2 : x.length;
    for (i = 0; i < kk; i++) {
      y[i] = x[i];
    }
    for (; i < k2; i++) {
      y[i] = 0;
    }
    return y;
  }
  function equalsInt(x, y) {
    var i;
    if (x[0] != y)
      return 0;
    for (i = 1; i < x.length; i++) {
      if (x[i])
        return 0;
    }
    return 1;
  }
  function isZero(x) {
    var i;
    for (i = 0; i < x.length; i++) {
      if (x[i])
        return 0;
    }
    return 1;
  }
  function bigInt2str(x, base) {
    var t2, s = "";
    if (s6.length !== x.length)
      s6 = dup(x);
    else
      copy_(s6, x);
    {
      while (!isZero(s6)) {
        t2 = divInt_(s6, base);
        s = digitsStr.substring(t2, t2 + 1) + s;
      }
    }
    if (s.length === 0)
      s = "0";
    return s;
  }
  function dup(x) {
    buff = Array(x.length);
    copy_(buff, x);
    return buff;
  }
  function copy_(x, y) {
    var i;
    var k2 = x.length < y.length ? x.length : y.length;
    for (i = 0; i < k2; i++) {
      x[i] = y[i];
    }
    for (i = k2; i < x.length; i++) {
      x[i] = 0;
    }
  }
  function copyInt_(x, n) {
    var i, c;
    var len = x.length;
    for (c = n, i = 0; i < len; i++) {
      x[i] = c & mask;
      c >>= bpe;
    }
  }
  function addInt_(x, n) {
    var i, k2, c, b;
    x[0] += n;
    k2 = x.length;
    c = 0;
    for (i = 0; i < k2; i++) {
      c += x[i];
      b = 0;
      if (c < 0) {
        b = -(c >> bpe);
        c += b * radix;
      }
      x[i] = c & mask;
      c = (c >> bpe) - b;
      if (!c)
        return;
    }
  }
  function rightShift_(x, n) {
    var i;
    var k2 = Math.floor(n / bpe);
    if (k2) {
      for (i = 0; i < x.length - k2; i++) {
        x[i] = x[i + k2];
      }
      for (; i < x.length; i++) {
        x[i] = 0;
      }
      n %= bpe;
    }
    for (i = 0; i < x.length - 1; i++) {
      x[i] = mask & (x[i + 1] << bpe - n | x[i] >> n);
    }
    x[i] >>= n;
  }
  function halve_(x) {
    var i;
    for (i = 0; i < x.length - 1; i++) {
      x[i] = mask & (x[i + 1] << bpe - 1 | x[i] >> 1);
    }
    x[i] = x[i] >> 1 | x[i] & radix >> 1;
  }
  function leftShift_(x, n) {
    var i;
    var k2 = Math.floor(n / bpe);
    if (k2) {
      for (i = x.length; i >= k2; i--) {
        x[i] = x[i - k2];
      }
      for (; i >= 0; i--) {
        x[i] = 0;
      }
      n %= bpe;
    }
    if (!n)
      return;
    for (i = x.length - 1; i > 0; i--) {
      x[i] = mask & (x[i] << n | x[i - 1] >> bpe - n);
    }
    x[i] = mask & x[i] << n;
  }
  function multInt_(x, n) {
    var i, k2, c, b;
    if (!n)
      return;
    k2 = x.length;
    c = 0;
    for (i = 0; i < k2; i++) {
      c += x[i] * n;
      b = 0;
      if (c < 0) {
        b = -(c >> bpe);
        c += b * radix;
      }
      x[i] = c & mask;
      c = (c >> bpe) - b;
    }
  }
  function divInt_(x, n) {
    var i, r = 0, s;
    for (i = x.length - 1; i >= 0; i--) {
      s = r * radix + x[i];
      x[i] = Math.floor(s / n);
      r = s % n;
    }
    return r;
  }
  function linCombShift_(x, y, b, ys) {
    var i, c, k2, kk;
    k2 = x.length < ys + y.length ? x.length : ys + y.length;
    kk = x.length;
    for (c = 0, i = ys; i < k2; i++) {
      c += x[i] + b * y[i - ys];
      x[i] = c & mask;
      c >>= bpe;
    }
    for (i = k2; c && i < kk; i++) {
      c += x[i];
      x[i] = c & mask;
      c >>= bpe;
    }
  }
  function addShift_(x, y, ys) {
    var i, c, k2, kk;
    k2 = x.length < ys + y.length ? x.length : ys + y.length;
    kk = x.length;
    for (c = 0, i = ys; i < k2; i++) {
      c += x[i] + y[i - ys];
      x[i] = c & mask;
      c >>= bpe;
    }
    for (i = k2; c && i < kk; i++) {
      c += x[i];
      x[i] = c & mask;
      c >>= bpe;
    }
  }
  function subShift_(x, y, ys) {
    var i, c, k2, kk;
    k2 = x.length < ys + y.length ? x.length : ys + y.length;
    kk = x.length;
    for (c = 0, i = ys; i < k2; i++) {
      c += x[i] - y[i - ys];
      x[i] = c & mask;
      c >>= bpe;
    }
    for (i = k2; c && i < kk; i++) {
      c += x[i];
      x[i] = c & mask;
      c >>= bpe;
    }
  }
  function sub_(x, y) {
    var i, c, k2;
    k2 = x.length < y.length ? x.length : y.length;
    for (c = 0, i = 0; i < k2; i++) {
      c += x[i] - y[i];
      x[i] = c & mask;
      c >>= bpe;
    }
    for (i = k2; c && i < x.length; i++) {
      c += x[i];
      x[i] = c & mask;
      c >>= bpe;
    }
  }
  function add_(x, y) {
    var i, c, k2;
    k2 = x.length < y.length ? x.length : y.length;
    for (c = 0, i = 0; i < k2; i++) {
      c += x[i] + y[i];
      x[i] = c & mask;
      c >>= bpe;
    }
    for (i = k2; c && i < x.length; i++) {
      c += x[i];
      x[i] = c & mask;
      c >>= bpe;
    }
  }
  function bytesFromLeemonBigInt(bigInt) {
    const str = bigInt2str(bigInt, 16);
    return getPlatform().hexDecode(str);
  }
  function nextRandomInt(maxValue) {
    return Math.floor(Math.random() * maxValue);
  }
  function pqPrimeLeemon(what) {
    const minBits = 64;
    const minLen = Math.ceil(minBits / bpe) + 1;
    let i, q;
    let j, lim;
    let P;
    let Q;
    const a = new Array(minLen);
    const b = new Array(minLen);
    const c = new Array(minLen);
    const g = new Array(minLen);
    const z = new Array(minLen);
    const x = new Array(minLen);
    const y = new Array(minLen);
    for (i = 0; i < 3; i++) {
      q = (nextRandomInt(128) & 15) + 17;
      copyInt_(x, nextRandomInt(1e9) + 1);
      copy_(y, x);
      lim = 1 << i + 18;
      for (j = 1; j < lim; j++) {
        copy_(a, x);
        copy_(b, x);
        copyInt_(c, q);
        while (!isZero(b)) {
          if (b[0] & 1) {
            add_(c, a);
            if (greater(c, what)) {
              sub_(c, what);
            }
          }
          add_(a, a);
          if (greater(a, what)) {
            sub_(a, what);
          }
          rightShift_(b, 1);
        }
        copy_(x, c);
        if (greater(x, y)) {
          copy_(z, x);
          sub_(z, y);
        } else {
          copy_(z, y);
          sub_(z, x);
        }
        eGCD_(z, what, g, a, b);
        if (!equalsInt(g, 1)) {
          break;
        }
        if ((j & j - 1) === 0) {
          copy_(y, x);
        }
      }
      if (greater(g, one)) {
        break;
      }
    }
    divide_(what, g, x, y);
    if (greater(g, x)) {
      P = x;
      Q = g;
    } else {
      P = g;
      Q = x;
    }
    return [bytesFromLeemonBigInt(P), bytesFromLeemonBigInt(Q)];
  }
  function webogramFactorizePQSync(crypto2, pq) {
    const what = bufferToBigInt(pq);
    try {
      console.time("leemon pq");
      const result = pqPrimeLeemon(str2bigInt(what.toString(16), 16, Math.ceil(64 / bpe) + 1));
      console.timeEnd("leemon pq");
      return result;
    } catch (e) {
      console.error("Leemon pq failed", e);
    }
    return factorizePQSync(crypto2, pq);
  }
  const u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
  const fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    0
  ]);
  const fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  const clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  const freb = (eb, start2) => {
    const b = new u16(31);
    for (let i = 0; i < 31; ++i) {
      b[i] = start2 += 1 << eb[i - 1];
    }
    const r = new i32(b[30]);
    for (let i = 1; i < 30; ++i) {
      for (let j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return { b, r };
  };
  const { b: fl, r: revfl } = freb(fleb, 2);
  fl[28] = 258, revfl[258] = 28;
  const { b: fd, r: revfd } = freb(fdeb, 0);
  const rev = new u16(32768);
  for (let i = 0; i < 32768; ++i) {
    let x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  const hMap = (cd, mb, r) => {
    const s = cd.length;
    let i = 0;
    const l = new u16(mb);
    for (; i < s; ++i) {
      if (cd[i])
        ++l[cd[i] - 1];
    }
    const le = new u16(mb);
    for (i = 1; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    let co;
    if (r) {
      co = new u16(1 << mb);
      const rvb = 15 - mb;
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          const sv = i << 4 | cd[i];
          const r2 = mb - cd[i];
          let v = le[cd[i] - 1]++ << r2;
          for(let   m2 = v | (1 << r2) - 1; v <= m2; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
        }
      }
    }
    return co;
  };
  const flt = new u8(288);
  for (let i = 0; i < 144; ++i)
    flt[i] = 8;
  for (let i = 144; i < 256; ++i)
    flt[i] = 9;
  for (let i = 256; i < 280; ++i)
    flt[i] = 7;
  for (let i = 280; i < 288; ++i)
    flt[i] = 8;
  const fdt = new u8(32);
  for (let i = 0; i < 32; ++i)
    fdt[i] = 5;
  const flm = /* @__PURE__ */ hMap(flt, 9, 0), flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  const fdm = /* @__PURE__ */ hMap(fdt, 5, 0), fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  const max = (a) => {
    let m2 = a[0];
    for (let i = 1; i < a.length; ++i) {
      if (a[i] > m2)
        m2 = a[i];
    }
    return m2;
  };
  const bits = (d, p, m2) => {
    const o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m2;
  };
  const bits16 = (d, p) => {
    const o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  const shft = (p) => (p + 7) / 8 | 0;
  const slc = (v, s, e) => {
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  const ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    // determined by compression function
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  const err = (ind, msg, nt) => {
    const e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  const inflt = (dat, st, buf, dict) => {
    const sl = dat.length, dl = 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    const noBuf = !buf;
    const resize = noBuf || st.i != 2;
    const noSt = st.i;
    if (noBuf)
      buf = new u8(sl * 3);
    const cbuf = (l) => {
      let bl = buf.length;
      if (l > bl) {
        const nbuf = new u8(Math.max(bl * 2, l));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    let final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    const tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        const type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          const s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;
          if (t2 > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t2), bt);
          st.b = bt += l, st.p = pos = t2 * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          const hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          const tl2 = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          const ldt = new u8(tl2);
          const clt = new u8(19);
          for (let i = 0; i < hcLen; ++i) {
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }
          pos += hcLen * 3;
          const clb = max(clt), clbmsk = (1 << clb) - 1;
          const clm = hMap(clt, clb, 1);
          for (let i = 0; i < tl2; ) {
            const r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            const s = r >> 4;
            if (s < 16) {
              ldt[i++] = s;
            } else {
              let c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i++] = c;
            }
          }
          const lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      const lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      let lpos = pos;
      for (; ; lpos = pos) {
        const c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          let add = sym - 254;
          if (sym > 264) {
            const i = sym - 257, b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          }
          const d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          let dt = fd[dsym];
          if (dsym > 3) {
            const b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          const end = bt + add;
          if (bt < dt) {
            const shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; ++bt)
            buf[bt] = buf[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  const wbits = (d, p, v) => {
    v <<= p & 7;
    const o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
  };
  const wbits16 = (d, p, v) => {
    v <<= p & 7;
    const o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
  };
  const hTree = (d, mb) => {
    const t2 = [];
    for (let i = 0; i < d.length; ++i) {
      if (d[i])
        t2.push({ s: i, f: d[i] });
    }
    const s = t2.length;
    const t22 = t2.slice();
    if (!s)
      return { t: et, l: 0 };
    if (s == 1) {
      const v = new u8(t2[0].s + 1);
      v[t2[0].s] = 1;
      return { t: v, l: 1 };
    }
    t2.sort((a, b) => a.f - b.f);
    t2.push({ s: -1, f: 25001 });
    let l = t2[0], r = t2[1], i0 = 0, i1 = 1, i2 = 2;
    t2[0] = { s: -1, f: l.f + r.f, l, r };
    while (i1 != s - 1) {
      l = t2[t2[i0].f < t2[i2].f ? i0++ : i2++];
      r = t2[i0 != i1 && t2[i0].f < t2[i2].f ? i0++ : i2++];
      t2[i1++] = { s: -1, f: l.f + r.f, l, r };
    }
    let maxSym = t22[0].s;
    for (let i = 1; i < s; ++i) {
      if (t22[i].s > maxSym)
        maxSym = t22[i].s;
    }
    const tr = new u16(maxSym + 1);
    let mbt = ln(t2[i1 - 1], tr, 0);
    if (mbt > mb) {
      let i = 0, dt = 0;
      const lft = mbt - mb, cst = 1 << lft;
      t22.sort((a, b) => tr[b.s] - tr[a.s] || a.f - b.f);
      for (; i < s; ++i) {
        const i22 = t22[i].s;
        if (tr[i22] > mb) {
          dt += cst - (1 << mbt - tr[i22]);
          tr[i22] = mb;
        } else
          break;
      }
      dt >>= lft;
      while (dt > 0) {
        const i22 = t22[i].s;
        if (tr[i22] < mb)
          dt -= 1 << mb - tr[i22]++ - 1;
        else
          ++i;
      }
      for (; i >= 0 && dt; --i) {
        const i22 = t22[i].s;
        if (tr[i22] == mb) {
          --tr[i22];
          ++dt;
        }
      }
      mbt = mb;
    }
    return { t: new u8(tr), l: mbt };
  };
  const ln = (n, l, d) => {
    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
  };
  const lc = (c) => {
    let s = c.length;
    while (s && !c[--s])
      ;
    const cl = new u16(++s);
    let cli = 0, cln = c[0], cls = 1;
    const w = (v) => {
      cl[cli++] = v;
    };
    for (let i = 1; i <= s; ++i) {
      if (c[i] == cln && i != s)
        ++cls;
      else {
        if (!cln && cls > 2) {
          for (; cls > 138; cls -= 138)
            w(32754);
          if (cls > 2) {
            w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
            cls = 0;
          }
        } else if (cls > 3) {
          w(cln), --cls;
          for (; cls > 6; cls -= 6)
            w(8304);
          if (cls > 2)
            w(cls - 3 << 5 | 8208), cls = 0;
        }
        while (cls--)
          w(cln);
        cls = 1;
        cln = c[i];
      }
    }
    return { c: cl.subarray(0, cli), n: s };
  };
  const clen = (cf, cl) => {
    let l = 0;
    for (let i = 0; i < cl.length; ++i)
      l += cf[i] * cl[i];
    return l;
  };
  const wfblk = (out, pos, dat) => {
    const s = dat.length;
    const o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (let i = 0; i < s; ++i)
      out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
  };
  const wblk = (dat, out, final, syms, lf, df, eb, li, bs, bl, p) => {
    wbits(out, p++, final);
    ++lf[256];
    const { t: dlt, l: mlb } = hTree(lf, 15);
    const { t: ddt, l: mdb } = hTree(df, 15);
    const { c: lclt, n: nlc } = lc(dlt);
    const { c: lcdt, n: ndc } = lc(ddt);
    const lcfreq = new u16(19);
    for (let i = 0; i < lclt.length; ++i)
      ++lcfreq[lclt[i] & 31];
    for (let i = 0; i < lcdt.length; ++i)
      ++lcfreq[lcdt[i] & 31];
    const { t: lct, l: mlcb } = hTree(lcfreq, 7);
    let nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
      ;
    const flen = bl + 5 << 3;
    const ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    const dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen)
      return wfblk(out, p, dat.subarray(bs, bs + bl));
    let lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
      lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
      const llm = hMap(lct, mlcb, 0);
      wbits(out, p, nlc - 257);
      wbits(out, p + 5, ndc - 1);
      wbits(out, p + 10, nlcc - 4);
      p += 14;
      for (let i = 0; i < nlcc; ++i)
        wbits(out, p + 3 * i, lct[clim[i]]);
      p += 3 * nlcc;
      const lcts = [lclt, lcdt];
      for (let it = 0; it < 2; ++it) {
        const clct = lcts[it];
        for (let i = 0; i < clct.length; ++i) {
          const len = clct[i] & 31;
          wbits(out, p, llm[len]), p += lct[len];
          if (len > 15)
            wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
        }
      }
    } else {
      lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (let i = 0; i < li; ++i) {
      const sym = syms[i];
      if (sym > 255) {
        const len = sym >> 18 & 31;
        wbits16(out, p, lm[len + 257]), p += ll[len + 257];
        if (len > 7)
          wbits(out, p, sym >> 23 & 31), p += fleb[len];
        const dst = sym & 31;
        wbits16(out, p, dm[dst]), p += dl[dst];
        if (dst > 3)
          wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
      } else {
        wbits16(out, p, lm[sym]), p += ll[sym];
      }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
  };
  const deo = /* @__PURE__ */ new i32([
    65540,
    131080,
    131088,
    131104,
    262176,
    1048704,
    1048832,
    2114560,
    2117632
  ]);
  const et = /* @__PURE__ */ new u8(0);
  const dflt = (dat, lvl, plvl, pre, post, st) => {
    const s = st.z || dat.length;
    const o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
    const w = o.subarray(pre, o.length - post);
    const lst = st.l;
    let pos = (st.r || 0) & 7;
    if (lvl) {
      if (pos)
        w[0] = st.r >> 3;
      const opt = deo[lvl - 1];
      const n = opt >> 13, c = opt & 8191;
      const msk = (1 << plvl) - 1;
      const prev = st.p || new u16(32768), head = st.h || new u16(msk + 1);
      const bs1 = Math.ceil(plvl / 3), bs2 = 2 * bs1;
      const hsh = (i2) => (dat[i2] ^ dat[i2 + 1] << bs1 ^ dat[i2 + 2] << bs2) & msk;
      const syms = new i32(25e3);
      const lf = new u16(288), df = new u16(32);
      let lc2 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
      for (; i + 2 < s; ++i) {
        const hv = hsh(i);
        let imod = i & 32767, pimod = head[hv];
        prev[imod] = pimod;
        head[hv] = imod;
        if (wi <= i) {
          const rem = s - i;
          if ((lc2 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
            pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
            li = lc2 = eb = 0, bs = i;
            for (let j = 0; j < 286; ++j)
              lf[j] = 0;
            for (let j = 0; j < 30; ++j)
              df[j] = 0;
          }
          let l = 2, d = 0, ch2 = c, dif = imod - pimod & 32767;
          if (rem > 2 && hv == hsh(i - dif)) {
            const maxn = Math.min(n, rem) - 1;
            const maxd = Math.min(32767, i);
            const ml = Math.min(258, rem);
            while (dif <= maxd && --ch2 && imod != pimod) {
              if (dat[i + l] == dat[i + l - dif]) {
                let nl = 0;
                for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                  ;
                if (nl > l) {
                  l = nl, d = dif;
                  if (nl > maxn)
                    break;
                  const mmd = Math.min(dif, nl - 2);
                  let md = 0;
                  for (let j = 0; j < mmd; ++j) {
                    const ti = i - dif + j & 32767;
                    const pti = prev[ti];
                    const cd = ti - pti & 32767;
                    if (cd > md)
                      md = cd, pimod = ti;
                  }
                }
              }
              imod = pimod, pimod = prev[imod];
              dif += imod - pimod & 32767;
            }
          }
          if (d) {
            syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
            const lin = revfl[l] & 31, din = revfd[d] & 31;
            eb += fleb[lin] + fdeb[din];
            ++lf[257 + lin];
            ++df[din];
            wi = i + l;
            ++lc2;
          } else {
            syms[li++] = dat[i];
            ++lf[dat[i]];
          }
        }
      }
      for (i = Math.max(i, wi); i < s; ++i) {
        syms[li++] = dat[i];
        ++lf[dat[i]];
      }
      pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
      if (!lst) {
        st.r = pos & 7 | w[pos / 8 | 0] << 3;
        pos -= 7;
        st.h = head, st.p = prev, st.i = i, st.w = wi;
      }
    } else {
      for (let i = st.w || 0; i < s + lst; i += 65535) {
        let e = i + 65535;
        if (e >= s) {
          w[pos / 8 | 0] = lst;
          e = s;
        }
        pos = wfblk(w, pos + 1, dat.subarray(i, e));
      }
      st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
  };
  const crct = /* @__PURE__ */ (() => {
    const t2 = new Int32Array(256);
    for (let i = 0; i < 256; ++i) {
      let c = i, k2 = 9;
      while (--k2)
        c = (c & 1 && -306674912) ^ c >>> 1;
      t2[i] = c;
    }
    return t2;
  })();
  const crc = () => {
    let c = -1;
    return {
      p(d) {
        let cr = c;
        for (let i = 0; i < d.length; ++i)
          cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
        c = cr;
      },
      d() {
        return ~c;
      }
    };
  };
  const dopt = (dat, opt, pre, post, st) => {
    if (!st) {
      st = { l: 1 };
      if (opt.dictionary) {
        const dict = opt.dictionary.subarray(-32768);
        const newDat = new u8(dict.length + dat.length);
        newDat.set(dict);
        newDat.set(dat, dict.length);
        dat = newDat;
        st.w = dict.length;
      }
    }
    return dflt(
      dat,
      opt.level == null ? 6 : opt.level,
      opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem,
      pre,
      post,
      st
    );
  };
  const wbytes = (d, b, v) => {
    for (; v; ++b)
      d[b] = v, v >>>= 8;
  };
  const gzh = (c, o) => {
    const fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
    if (o.mtime != 0)
      wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
    if (fn) {
      c[3] = 8;
      for (let i = 0; i <= fn.length; ++i)
        c[i + 10] = fn.charCodeAt(i);
    }
  };
  const gzs = (d) => {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
      err(6, "invalid gzip data");
    const flg = d[3];
    let st = 10;
    if (flg & 4)
      st += (d[10] | d[11] << 8) + 2;
    for (let zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
      ;
    return st + (flg & 2);
  };
  const gzl = (d) => {
    const l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
  };
  const gzhl = (o) => 10 + (o.filename ? o.filename.length + 1 : 0);
  function gzipSync(data2, opts) {
    if (!opts)
      opts = {};
    const c = crc(), l = data2.length;
    c.p(data2);
    const d = dopt(data2, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
  }
  function gunzipSync(data2, opts) {
    const st = gzs(data2);
    if (st + 8 > data2.length)
      err(6, "invalid gzip data");
    return inflt(
      data2.subarray(st, -8),
      { i: 2 },
      new u8(gzl(data2)),
      opts
    );
  }
  let asm = null;
  let compressor;
  let decompressor;
  let sharedOutPtr;
  let sharedKeyPtr;
  let sharedIvPtr;
  function getUint8Memory() {
    return asm.HEAPU8;
  }
  const MAX_MEMORY = 16777216;
  function getAvailableMemory() {
    return MAX_MEMORY - asm._getUsedMemory();
  }
  function loadAsm() {
    return __async(this, null, function* () {
      {
        const factory = (yield System.import(MtcuteAsmURL)).default;
        asm = yield factory({
          locateFile() {
            return MtcuteMemURL;
          }
        });
      }
    });
  }
  const ALGO_TO_SUBTLE = {
    sha256: "SHA-256",
    sha1: "SHA-1",
    sha512: "SHA-512"
  };
  function createCtr256(key, iv) {
    getUint8Memory().set(key, sharedKeyPtr);
    getUint8Memory().set(iv, sharedIvPtr);
    return asm._ctr256_alloc();
  }
  function freeCtr256(ctx) {
    asm._ctr256_free(ctx);
  }
  function ctr256(ctx, data2) {
    const { _malloc, _free } = asm;
    const inputPtr = _malloc(data2.length);
    const outputPtr = _malloc(data2.length);
    const mem = getUint8Memory();
    mem.set(data2, inputPtr);
    asm._ctr256(ctx, inputPtr, data2.length, outputPtr);
    const result = mem.slice(outputPtr, outputPtr + data2.length);
    _free(outputPtr);
    return result;
  }
  function sha256(data2) {
    const { _malloc, _free } = asm;
    const inputPtr = _malloc(data2.length);
    const mem = getUint8Memory();
    mem.set(data2, inputPtr);
    asm._sha256(inputPtr, data2.length);
    _free(inputPtr);
    return mem.slice(sharedOutPtr, sharedOutPtr + 32);
  }
  function ige256Encrypt(data2, key, iv) {
    const ptr = asm._malloc(data2.length + data2.length);
    const inputPtr = ptr;
    const outputPtr = inputPtr + data2.length;
    const mem = getUint8Memory();
    mem.set(data2, inputPtr);
    mem.set(key, sharedKeyPtr);
    mem.set(iv, sharedIvPtr);
    asm._ige256_encrypt(inputPtr, data2.length, outputPtr);
    const result = mem.slice(outputPtr, outputPtr + data2.length);
    asm._free(ptr);
    return result;
  }
  function ige256Decrypt(data2, key, iv) {
    const ptr = asm._malloc(data2.length + data2.length);
    const inputPtr = ptr;
    const outputPtr = inputPtr + data2.length;
    const mem = getUint8Memory();
    mem.set(data2, inputPtr);
    mem.set(key, sharedKeyPtr);
    mem.set(iv, sharedIvPtr);
    asm._ige256_decrypt(inputPtr, data2.length, outputPtr);
    const result = mem.slice(outputPtr, outputPtr + data2.length);
    asm._free(ptr);
    return result;
  }
  function deflateMaxSize(bytes, size) {
    if (bytes.length > getAvailableMemory()) {
      console.warn("asm.js out of memory!! will use fflate.");
      const result2 = gzipSync(bytes);
      if (result2.length > size) {
        return null;
      }
      return result2;
    }
    const outputPtr = asm._malloc(size);
    const inputPtr = asm._malloc(bytes.length);
    const mem = getUint8Memory();
    mem.set(bytes, inputPtr);
    const written = asm._libdeflate_zlib_compress(compressor, inputPtr, bytes.length, outputPtr, size);
    asm._free(inputPtr);
    if (written === 0) {
      asm._free(outputPtr);
      return null;
    }
    const result = mem.slice(outputPtr, outputPtr + written);
    asm._free(outputPtr);
    return result;
  }
  function gunzip(bytes) {
    if (bytes.length > getAvailableMemory()) {
      console.warn("asm.js out of memory!! will use fflate.");
      const result2 = gunzipSync(bytes);
      return result2;
    }
    const inputPtr = asm._malloc(bytes.length);
    getUint8Memory().set(bytes, inputPtr);
    const size = asm._libdeflate_gzip_get_output_size(inputPtr, bytes.length);
    const outputPtr = asm._malloc(size);
    const ret = asm._libdeflate_gzip_decompress(decompressor, inputPtr, bytes.length, outputPtr, size);
    if (ret === -1)
      throw new Error("gunzip error -- bad data");
    if (ret === -2)
      throw new Error("gunzip error -- short output");
    if (ret === -3)
      throw new Error("gunzip error -- short input");
    const result = getUint8Memory().slice(outputPtr, outputPtr + size);
    asm._free(inputPtr);
    asm._free(outputPtr);
    return result;
  }
  class AsmCryptoProvider extends BaseCryptoProvider {
    constructor(params) {
      var _a2;
      super();
      __publicField(this, "crypto");
      const crypto2 = (_a2 = params == null ? void 0 : params.crypto) != null ? _a2 : globalThis.crypto;
      if (!crypto2 || !crypto2.subtle) {
        throw new Error("WebCrypto is not available");
      }
      this.crypto = crypto2;
    }
    factorizePQ(pq) {
      return webogramFactorizePQSync(this, pq);
    }
    /**
     * convert webp to rgba
     * width and height is required so no OOM will occur
     */
    webp(buff2, width, height) {
      if (buff2.length + width * height * 4 > getAvailableMemory()) {
        console.error("WEBP CONVERSION FAILED BECAUSE NOT ENOUGH MEMORY");
        return null;
      }
      const buffPointer = asm._malloc(buff2.length);
      const mem = getUint8Memory();
      mem.set(buff2, buffPointer);
      const decodedPtr = asm._webp_decode(buffPointer, buff2.length);
      if (!decodedPtr) {
        asm._free(buffPointer);
        return null;
      }
      width = asm._webp_getWidth();
      height = asm._webp_getHeight();
      const rgba = new Uint8ClampedArray(mem.slice(decodedPtr, decodedPtr + width * height * 4).buffer);
      asm._webp_free(decodedPtr);
      asm._free(buffPointer);
      return {
        rgba,
        width,
        height
      };
    }
    sha1(data2) {
      const { _malloc, _free } = asm;
      const inputPtr = _malloc(data2.length);
      const mem = getUint8Memory();
      mem.set(data2, inputPtr);
      asm._sha1(inputPtr, data2.length);
      _free(inputPtr);
      const res = mem.slice(sharedOutPtr, sharedOutPtr + 20);
      return res;
    }
    sha256(bytes) {
      const hashBytes = sha256(bytes);
      return hashBytes;
    }
    createAesCtr(key, iv) {
      const ctx = createCtr256(key, iv);
      return {
        process: (data2) => ctr256(ctx, data2),
        close: () => freeCtr256(ctx)
      };
    }
    createAesIge(key, iv) {
      return {
        encrypt: (data2) => ige256Encrypt(data2, key, iv),
        decrypt: (data2) => ige256Decrypt(data2, key, iv)
      };
    }
    gzip(data2, maxSize) {
      return deflateMaxSize(data2, maxSize);
    }
    gunzip(data2) {
      return gunzip(data2);
    }
    initialize() {
      return __async(this, null, function* () {
        console.log("INIT CRYPTO", typeof importScripts == "function" ? "WORKER" : "MAIN THREAD");
        yield loadAsm();
        compressor = asm._libdeflate_alloc_compressor(6);
        decompressor = asm._libdeflate_alloc_decompressor();
        sharedOutPtr = asm.___get_shared_out();
        sharedKeyPtr = asm.___get_shared_key_buffer();
        sharedIvPtr = asm.___get_shared_iv_buffer();
      });
    }
    pbkdf2(password, salt, iterations, keylen, algo) {
      return __async(this, null, function* () {
        const keyMaterial = yield this.crypto.subtle.importKey("raw", password, "PBKDF2", false, ["deriveBits"]);
        return this.crypto.subtle.deriveBits(
          {
            name: "PBKDF2",
            salt,
            iterations,
            hash: algo ? ALGO_TO_SUBTLE[algo] : "SHA-512"
          },
          keyMaterial,
          (keylen || 64) * 8
        ).then((result) => {
          const buf = new Uint8Array(result);
          return buf;
        });
      });
    }
    hmacSha256(data2, key) {
      return __async(this, null, function* () {
        const keyMaterial = yield this.crypto.subtle.importKey(
          "raw",
          key,
          { name: "HMAC", hash: { name: "SHA-256" } },
          false,
          ["sign"]
        );
        const res = yield this.crypto.subtle.sign({ name: "HMAC" }, keyMaterial, data2);
        const buf = new Uint8Array(res);
        return buf;
      });
    }
    randomFill(buf) {
      this.crypto.getRandomValues(buf);
    }
    getAvailableMemory() {
      return getAvailableMemory();
    }
  }
  var crypto = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AsmCryptoProvider
  });
})();
